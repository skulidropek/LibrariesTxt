[AttributeUsageAttribute("12")]
public class JetBrains.Build.BuildArtifactAttribute : BuildPartAttribute {
    private Cardinality Cardinality;
    public BuildArtifactAttribute(Cardinality Cardinality);
}
public class JetBrains.Build.BuildErrorException : BuildException {
    public string Code;
    public int Col;
    public int ColRangeEnd;
    public string File;
    public string Kind;
    public int Line;
    public int LineRangeEnd;
    public string OriginalMessage;
    public string Subcategory;
    public int ThreadId;
    public BuildErrorException(string kind, string subcategory, string text, string code, string file, int line, int lineRangeEnd, int col, int colRangeEnd, int threadId, Exception innerException);
    [NotNullAttribute]
public static string FormatBuildMessage(string kind, string subcategory, string text, string code, string file, int line, int lineRangeEnd, int col, int colRangeEnd, int threadId);
    private static string Ctor_CombineExceptionAndText(string text, Exception innerException);
    private static string FormatBuildMessage_FormatString(string subcategory, string message, string code, string file, int line, int lineRangeEnd, int col, int colRangeEnd);
}
public class JetBrains.Build.BuildException : ApplicationException {
    public BuildException(string message, Exception innerException);
}
[AttributeUsageAttribute("1028")]
[MeansImplicitUseAttribute("8")]
public class JetBrains.Build.BuildHelperAttribute : BuildPartAttribute {
    public BuildHelperAttribute(BuildHelperFlags Flags);
}
[FlagsAttribute]
public enum JetBrains.Build.BuildHelperFlags : Enum {
    public int value__;
    public static BuildHelperFlags O;
    public static BuildHelperFlags IsSingleton;
}
[AttributeUsageAttribute("12")]
public class JetBrains.Build.BuildPartAttribute : PartAttribute {
}
[AttributeUsageAttribute("492")]
[MeansImplicitUseAttribute("8")]
public class JetBrains.Build.BuildStepAttribute : BuildPartAttribute {
}
public enum JetBrains.Build.Cardinality : Enum {
    public int value__;
    public static Cardinality Singular;
    public static Cardinality Plural;
}
public static class JetBrains.Build.Engine.IsolatedBuild.BuildLogRecordChannel : object {
    private static ILogger Logger;
    private static BuildLogRecordChannel();
    public static ChannelName CreateMessageReader(Lifetime lifetime, Action`1<BuildLogRecord> FOnRead);
    public static Writer CreateMessageWriter(OuterLifetime lifetimeOuter, ChannelName channelname);
    private static IPipeMessageChannel ChoosePreferredChannelEngine();
    private static IPipeMessageChannel GetChannelEngine(string engine);
}
public enum JetBrains.Build.Helpers.Caches.ArchiveFormat : Enum {
    public int value__;
    public static ArchiveFormat GZip;
    public static ArchiveFormat BZip2;
    public static ArchiveFormat Zip;
    public static ArchiveFormat Xz;
    public static ArchiveFormat Tar;
}
public static class JetBrains.Build.Helpers.Caches.ArchiveUtil : object {
    public static ArchiveFormat DetectArchiveFormat(Stream inStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Build.Helpers.Caches.BuildInterfacesDistributedCacheEx : object {
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Caches.BuildInterfacesDistributedCacheEx/<CacheFileItems>d__0")]
[ExtensionAttribute]
public static Task`1<IReadOnlyCollection`1<ImmutableFileItem>> CacheFileItems(DistributedCache distrocache, IHasher hasher, Func`1<Task`1<IReadOnlyCollection`1<ImmutableFileItem>>> generator);
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Caches.BuildInterfacesDistributedCacheEx/<CacheObjectValue>d__1`1")]
[ExtensionAttribute]
public static Task`1<TObject> CacheObjectValue(DistributedCache distrocache, IHasher hasher, Func`1<Task`1<TObject>> generator);
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Caches.BuildInterfacesDistributedCacheEx/<CacheObjectValueWithLogs>d__2`1")]
[ExtensionAttribute]
public static Task`1<TObject> CacheObjectValueWithLogs(DistributedCache distrocache, IHasher hasher, ILogger logger, Func`2<ILogger, Task`1<TObject>> generator);
    [ExtensionAttribute]
public static Task`1<ImmutableFileItem> DoSingleFileItemAsync(DistributedCache distrocache, Func`1<Task`1<ImmutableFileItem>> generator, IHasher hasher);
}
public static class JetBrains.Build.Helpers.Caches.DistributedCaches : object {
    private static string PackageSourceNameToHackReadCredentialsFrom;
    public static string RemoteCacheTokenNugetConfigSettingsKey;
    public static string RemoteCacheUrlNugetConfigSettingsKey;
    private static string RemoteCacheWriteAccessTokenEnvVarOnTeamCity;
    private static DistributedCaches();
    public static DistributedCache Full(RelativePath name, NugetConfigFile nugetConfigFile, ILogger logger, string buildUnitName);
    public static DistributedCache LocalOnly(RelativePath name, ILogger logger, string buildUnitName);
    private static void AttachLogger(DistributedCache distroCache, ILogger logger);
    [CompilerGeneratedAttribute]
internal static string <Full>g__GetConfigValue|4_0(string key, <>c__DisplayClass4_0& );
}
public class JetBrains.Build.Helpers.Caches.DotNetPackagesCredentials : object {
    public static Lazy`1<string> TokenFromNuGetConfiguration;
    private static DotNetPackagesCredentials();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Build.Helpers.Caches.ObjectWithLogsDump`1 : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<ImmutableByteStream, Nullable`1<ImmutableArray`1<BuildLogRecord>>> Logs;
    public TObject ObjectValue;
    public ObjectWithLogsDump`1(TObject value, ImmutableByteStream logsAsBinaryDump);
    [UsedImplicitlyAttribute]
public ObjectWithLogsDump`1(IStructuredStorage sstg);
    [NullableContextAttribute("0")]
public ObjectWithLogsDump`1(TObject value, ImmutableArray`1<BuildLogRecord> logsAsRecords);
    public void ForEachLogRecord(TArg arg, Action`2<BuildLogRecord, TArg> F);
    public void PumpLogsIntoLogger(ILogger logger);
    private sealed virtual override void JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData(IStructuredStorage sstg);
    private static ImmutableByteStream ReadLogs(IStructuredStorageStream sstm);
    private static TObject ReadObjectValue(IStructuredStorage sstg);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData>b__7_0(Stream stream);
}
public class JetBrains.Build.Helpers.Caches.PersistentCache : object {
    [ItemNotNullAttribute]
public static Task`1<FileSystemPath> DownloadAndExtractZipArtifact(string artifactUrl, Action`1<HttpRequestMessage> prepare);
}
public static class JetBrains.Build.Helpers.Caches.StampUtil : object {
    private static string StampFile;
    private static ILogger ourLogger;
    private static JetHashSet`1<RelativePath> ourInternalFiles;
    private static StampUtil();
    [NotNullAttribute]
public static ICollection`1<FileSystemPath> GetInternalFiles(FileSystemPath dir);
    public static void CleanUp(FileSystemPath dir);
    public static void Write(FileSystemPath dir, Nullable`1<long> expectedCount, IEnumerable`1<string> components);
    public static bool Validate(FileSystemPath dir, IEnumerable`1<string> components);
    private static long GetUserFilesCountFromDir(FileSystemPath dir);
}
public class JetBrains.Build.Helpers.Caches.ToolsDownloadHelper : object {
    private static int MaxAttempt;
    private static ILogger ourLogger;
    private static TimeSpan ourAttemptTimeout;
    private FileSystemPath myCacheDir;
    private static Lazy`1<HttpClient> ourHttpClient;
    public ToolsDownloadHelper(FileSystemPath cacheDir);
    private static ToolsDownloadHelper();
    public static long ExtractArchive(FileSystemPath archiveFile, FileSystemPath destinationDir);
    public static long ExtractArchive(Stream inStream, FileSystemPath destinationDir);
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Caches.ToolsDownloadHelper/<DownloadAndExtractArchive>d__7")]
[ItemNotNullAttribute]
public Task`1<FileSystemPath> DownloadAndExtractArchive(string artifactUrl, Action`1<HttpRequestMessage> prepare);
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Caches.ToolsDownloadHelper/<DownloadUrlToFile>d__9")]
public static Task DownloadUrlToFile(string url, FileSystemPath file, Action`1<HttpRequestMessage> prepare);
    [CompilerGeneratedAttribute]
internal static long <ExtractArchive>g__ExtractTarArchive|6_0(Stream tarStream, <>c__DisplayClass6_0& );
}
public class JetBrains.Build.Helpers.General.BooleanArtifactConverter`1 : TypeConverterBase`1<TArtifact> {
}
public static class JetBrains.Build.Helpers.General.BooleanArtifactHelpers : object {
    [NotNullAttribute]
public static TArtifact CreateInstance(bool value);
}
public class JetBrains.Build.Helpers.General.BooleanArtifactSerializer`1 : ValueSerializerBase`1<TArtifact> {
}
public class JetBrains.Build.Helpers.General.BuildLogRecordLogger : LoggerBase {
    [NotNullAttribute]
private string myCategory;
    [CanBeNullAttribute]
private Action`1<BuildLogRecord> myFOnBuildLogRecord;
    [CanBeNullAttribute]
private Action`1<LogEvent> myFOnLogEvent;
    private ILogger myLoggerChainInto;
    private LoggingLevel myMaxLoggingLevel;
    [CanBeNullAttribute]
private ConcurrentQueue`1<BuildLogRecord> myRecorded;
    public string Category { get; }
    public bool IsFireOnlyNoRecording { get; }
    public Result`1<IEnumerable`1<BuildLogRecord>> Recording { get; }
    public BuildLogRecordLogger(Nullable`1<LoggingLevel> maxLoggingLevel, string category, ILogger loggerChainInto, Action`1<LogEvent> FOnLogEvent, Action`1<BuildLogRecord> FOnBuildLogRecord, bool isFireOnlyNoRecording);
    public BuildLogRecordLogger(IStructuredStorage sstg);
    public virtual string get_Category();
    public bool get_IsFireOnlyNoRecording();
    public Result`1<IEnumerable`1<BuildLogRecord>> get_Recording();
    public virtual bool IsEnabled(LoggingLevel level);
    public virtual void Log(LogEvent levent);
    public void PumpRecordingIntoLogger(ILogger logger);
    private sealed virtual override void JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData(IStructuredStorage sstg);
}
[BuildHelperAttribute]
public class JetBrains.Build.Helpers.General.BuildTaskHostWrapper : object {
    private ITaskHost myTaskHost;
    private TaskFactory JetBrains.Application.Threading.Tasks.ITaskHost.Factory { get; }
    private ReentrancyGuardTaskScheduler JetBrains.Application.Threading.Tasks.ITaskHost.GuardedMainThreadScheduler { get; }
    private ReentrancyGuardTaskScheduler JetBrains.Application.Threading.Tasks.ITaskHost.GuardedMainThreadSchedulerIfPresent { get; }
    private TaskScheduler JetBrains.Application.Threading.Tasks.ITaskHost.Scheduler { get; }
    private TaskScheduler JetBrains.Application.Threading.Tasks.ITaskHost.SystemThreadPool { get; }
    private JetDispatcherTaskScheduler JetBrains.Application.Threading.Tasks.ITaskHost.UnguardedMainThreadScheduler { get; }
    private JetDispatcherTaskScheduler JetBrains.Application.Threading.Tasks.ITaskHost.UnguardedMainThreadSchedulerIfPresent { get; }
    private TaskScheduler JetBrains.Application.Threading.Tasks.ITaskHost.WriteLockMainThreadScheduler { get; }
    public BuildTaskHostWrapper(IRunningIsolatedBuildContext ctx);
    private BuildTaskHostWrapper(ITaskHost taskHost);
    [NotNullAttribute]
public static IBuildTaskHost FromTaskHost(ITaskHost taskhost);
    private sealed virtual override Task JetBrains.Application.Threading.Tasks.ITaskHost.Create(Lifetime lifetime, Action action, InterruptionSet checkForInterrupt, TaskCreationOptions options, TaskJetProperties properties);
    private sealed virtual override Task`1<T> JetBrains.Application.Threading.Tasks.ITaskHost.Create(Lifetime lifetime, Func`1<T> action, InterruptionSet checkForInterrupt, TaskCreationOptions options, TaskJetProperties properties);
    private sealed virtual override TaskBarrier JetBrains.Application.Threading.Tasks.ITaskHost.CreateBarrier(Lifetime lifetime, InterruptionSet checkForInterrupt, bool sync, bool takeReadLock, TaskCreationOptions options);
    public sealed virtual void ReportThreadIsBlocked(Lifetime lifetime);
    private sealed virtual override TaskFactory JetBrains.Application.Threading.Tasks.ITaskHost.get_Factory();
    private sealed virtual override ReentrancyGuardTaskScheduler JetBrains.Application.Threading.Tasks.ITaskHost.get_GuardedMainThreadScheduler();
    private sealed virtual override ReentrancyGuardTaskScheduler JetBrains.Application.Threading.Tasks.ITaskHost.get_GuardedMainThreadSchedulerIfPresent();
    private sealed virtual override Task JetBrains.Application.Threading.Tasks.ITaskHost.Queue(Lifetime lifetime, Action action, TaskPriority priority);
    private sealed virtual override Task JetBrains.Application.Threading.Tasks.ITaskHost.QueueAt(Lifetime lifetime, Action action, DateTime date);
    private sealed virtual override Task JetBrains.Application.Threading.Tasks.ITaskHost.QueueAt(Lifetime lifetime, Action action, DateTimeOffset date);
    private sealed virtual override void JetBrains.Application.Threading.Tasks.ITaskHost.QueueRecurring(Lifetime lifetime, Action action, DateTime firstTime, TimeSpan interval);
    private sealed virtual override void JetBrains.Application.Threading.Tasks.ITaskHost.QueueRecurring(Lifetime lifetime, Action action, DateTimeOffset firstTime, TimeSpan interval);
    private sealed virtual override TaskScheduler JetBrains.Application.Threading.Tasks.ITaskHost.get_Scheduler();
    private sealed virtual override Task JetBrains.Application.Threading.Tasks.ITaskHost.Start(Task task);
    private sealed virtual override Task`1<T> JetBrains.Application.Threading.Tasks.ITaskHost.Start(Task`1<T> task);
    private sealed virtual override TaskScheduler JetBrains.Application.Threading.Tasks.ITaskHost.get_SystemThreadPool();
    private sealed virtual override JetDispatcherTaskScheduler JetBrains.Application.Threading.Tasks.ITaskHost.get_UnguardedMainThreadScheduler();
    private sealed virtual override JetDispatcherTaskScheduler JetBrains.Application.Threading.Tasks.ITaskHost.get_UnguardedMainThreadSchedulerIfPresent();
    private sealed virtual override TaskScheduler JetBrains.Application.Threading.Tasks.ITaskHost.get_WriteLockMainThreadScheduler();
}
public class JetBrains.Build.Helpers.General.BuildWorkingDirectory : object {
    [NotNullAttribute]
public FileSystemPath Path;
    private FileSystemPath JetBrains.Util.IWorkingDirectory.Path { get; }
    private BuildWorkingDirectory(FileSystemPath path);
    [NotNullAttribute]
public static BuildWorkingDirectory Create(Lifetime lifetime, string prefix);
    [NotNullAttribute]
public static BuildWorkingDirectory Wrap(FileSystemPath path);
    private sealed virtual override FileSystemPath JetBrains.Util.IWorkingDirectory.get_Path();
}
public interface JetBrains.Build.Helpers.General.IBooleanArtifact {
    public bool Value { get; }
    public abstract virtual bool get_Value();
}
public static class JetBrains.Build.Helpers.General.ImmutableFileOnDisk : object {
    public static ulong SnapshotSizeThreshold;
    private static ImmutableFileOnDisk();
    [NotNullAttribute]
public static ImmutableFileItem OpenFromDisk(FileSystemPath path, Nullable`1<ulong> sizeEstimateIfKnown);
    [NotNullAttribute]
private static ImmutableFileItem OpenDirectlyFromDisk(FileSystemPath path);
}
[ExtensionAttribute]
public static class JetBrains.Build.Helpers.General.PreviewBuildParametersFromRequestHelpers : object {
    [ExtensionAttribute]
public static bool TryPreviewIsIncrementalFromRequest(EitherBuildRunnerRequest request, ILogger logger);
    [ExtensionAttribute]
public static bool TryPreviewIsParallelBuildDisabledFromRequest(EitherBuildRunnerRequest request, ILogger logger);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static NugetConfigFile TryPreviewNugetConfigFromRequest(EitherBuildRunnerRequest request, Func`2<TBaseDirArt, FileSystemPath> FPathReader, ILogger logger);
    [CanBeNullAttribute]
public static FileSystemPath TryPreviewNugetConfigPathOnlyFromRequest(EitherBuildRunnerRequest request, Func`2<TBaseDirArt, FileSystemPath> FPathReader, ILogger logger);
    [CanBeNullAttribute]
private static FileSystemPath TryPreviewNugetConfigPathOnlyFromRequest_Explicit(EitherBuildRunnerRequest request, ILogger logger);
    [CanBeNullAttribute]
private static FileSystemPath TryPreviewNugetConfigPathOnlyFromRequest_GuessOnBase(EitherBuildRunnerRequest request, Func`2<TBaseDirArt, FileSystemPath> FPathReader, ILogger logger);
}
public interface JetBrains.Build.Helpers.Inputs.ITrackableFileItemDescriptions {
}
public interface JetBrains.Build.Helpers.Inputs.ITrackableFileItems {
    [NotNullAttribute]
public IEnumerable`1<ImmutableFileItem> Files { get; }
    public abstract virtual IEnumerable`1<ImmutableFileItem> get_Files();
}
public class JetBrains.Build.Helpers.Inputs.NontrackedFileItem : object {
    [NotNullAttribute]
public ImmutableFileItem File;
    private IEnumerable`1<ImmutableFileItem> JetBrains.Build.Helpers.Inputs.ITrackableFileItems.Files { get; }
    public NontrackedFileItem(ImmutableFileItem file);
    public virtual string ToString();
    [IteratorStateMachineAttribute("JetBrains.Build.Helpers.Inputs.NontrackedFileItem/<JetBrains-Build-Helpers-Inputs-ITrackableFileItems-get_Files>d__4")]
private sealed virtual override IEnumerable`1<ImmutableFileItem> JetBrains.Build.Helpers.Inputs.ITrackableFileItems.get_Files();
}
public static class JetBrains.Build.Helpers.Inputs.TrackableFileItemsHelpers : object {
    public static string BaseName;
    public static string EmittedFileName;
    public static Missing v1;
    public static XNamespace Xmlns;
    private static TrackableFileItemsHelpers();
    [NotNullAttribute]
public static ImmutableFileItem EmitTrackingInfoFile(IReadOnlyCollection`1<ITrackableFileItemDescriptions> items);
    [NotNullAttribute]
public static XDocument EmitTrackingInfoFileXml(IReadOnlyCollection`1<ITrackableFileItemDescriptions> items);
    public static bool IsUpToDate(IReadOnlyCollection`1<ITrackableFileItemDescriptions> items, FileSystemPath dirBase, ILogger logger);
    [NotNullAttribute]
public static IReadOnlyCollection`1<ITrackableFileItemDescriptions> LoadTrackingInfoFileXml(IEnumerable`1<ImmutableFileItem> filesPossible);
    [NotNullAttribute]
public static IReadOnlyCollection`1<ITrackableFileItemDescriptions> LoadTrackingInfoFileXml(XDocument xd);
    [NotNullAttribute]
public static IReadOnlyCollection`1<ITrackableFileItemDescriptions> LoadTrackingListFileXml(XDocument xd);
    internal static IReadOnlyCollection`1<DirectoryEntryData> GetDirectoryEntriesCached(FileSystemPath dir, ConcurrentDictionary`2& cache);
    internal static IReadOnlyCollection`1<DirectoryEntryData> GetDirectoryEntriesRecursiveCached(FileSystemPath dir, ConcurrentDictionary`2& cache);
    [NotNullAttribute]
private static IReadOnlyCollection`1<ITrackableFileItemDescriptions> LoadFileXmlCore(XDocument xd, bool isWithFilesAndHashes);
    [CompilerGeneratedAttribute]
internal static XElement <EmitTrackingInfoFileXml>g__EmitFile|5_0(TrackedFileInfo finf);
}
public class JetBrains.Build.Helpers.Inputs.TrackedDirectoryItems : TrackedDirectoryItemsDescription {
    [NotNullAttribute]
public IReadOnlyCollection`1<ImmutableFileItem> FileItems;
    private IEnumerable`1<ImmutableFileItem> JetBrains.Build.Helpers.Inputs.ITrackableFileItems.Files { get; }
    public TrackedDirectoryItems(RelativePath dirUnderHome, string mask, bool isRecursive, string sRegexPassFilter, IReadOnlyCollection`1<ImmutableFileItem> files);
    [NotNullAttribute]
public static TrackedDirectoryItems CreateFromDisk(FileSystemPath pathBaseDir, RelativePath relSearchDir, string mask, bool isRecursive, string sRegexPassFilter, ConcurrentDictionary`2<ValueTuple`2<FileSystemPath, bool>, IReadOnlyCollection`1<DirectoryEntryData>> dedcache);
    private sealed virtual override IEnumerable`1<ImmutableFileItem> JetBrains.Build.Helpers.Inputs.ITrackableFileItems.get_Files();
}
public class JetBrains.Build.Helpers.Inputs.TrackedDirectoryItemsDescription : object {
    [NotNullAttribute]
public IReadOnlyCollection`1<TrackedFileInfo> FileInfos;
    public bool IsRecursive;
    [NotNullAttribute]
public string Mask;
    [CanBeNullAttribute]
public string RegexPassFilter;
    [NotNullAttribute]
public RelativePath RelativeToBase;
    public TrackedDirectoryItemsDescription(RelativePath dirUnderHome, string mask, bool isRecursive, string sRegexPassFilter, IReadOnlyCollection`1<TrackedFileInfo> files);
    [NotNullAttribute]
public static IReadOnlyCollection`1<DirectoryEntryData> GetMatchingFilesOnDisk(FileSystemPath dirBaseForTracking, RelativePath relThisDirUnderTrackingBase, string mask, bool isRecursive, string sRegexPassFilter, ConcurrentDictionary`2<ValueTuple`2<FileSystemPath, bool>, IReadOnlyCollection`1<DirectoryEntryData>> dedcache);
    public virtual string ToString();
}
public class JetBrains.Build.Helpers.Inputs.TrackedFileInfo : object {
    public ImmutableArray`1<byte> ContentHash;
    public ulong ContentLength;
    [NotNullAttribute]
public RelativePath RelativeToBase;
    public TrackedFileInfo(RelativePath relativeToBase, ImmutableArray`1<byte> hash, ulong contentLength);
    [NotNullAttribute]
public static TrackedFileInfo CreateFromSearch(DirectoryEntryData ded);
    public sealed virtual bool Equals(TrackedFileInfo other);
    public virtual bool Equals(object obj);
    [NotNullAttribute]
public static TrackedFileInfo FromFileItem(ImmutableFileItem fi);
    public virtual int GetHashCode();
    public static bool op_Equality(TrackedFileInfo left, TrackedFileInfo right);
    public static bool op_Inequality(TrackedFileInfo left, TrackedFileInfo right);
    public virtual string ToString();
}
public class JetBrains.Build.Helpers.Inputs.TrackedFileItem : TrackedFileItemDescription {
    [NotNullAttribute]
public ImmutableFileItem FileItem;
    private IEnumerable`1<ImmutableFileItem> JetBrains.Build.Helpers.Inputs.ITrackableFileItems.Files { get; }
    public TrackedFileItem(ImmutableFileItem fileRelToBaseDir);
    [NotNullAttribute]
public static TrackedFileItem CreateFromDisk(FileSystemPath pathBaseDir, RelativePath relFileUnderBase);
    [NotNullAttribute]
public static TrackedFileItem CreateFromDisk(FileSystemPath pathBaseDir, FileSystemPath pathFile);
    public virtual string ToString();
    [IteratorStateMachineAttribute("JetBrains.Build.Helpers.Inputs.TrackedFileItem/<JetBrains-Build-Helpers-Inputs-ITrackableFileItems-get_Files>d__6")]
private sealed virtual override IEnumerable`1<ImmutableFileItem> JetBrains.Build.Helpers.Inputs.ITrackableFileItems.get_Files();
}
public class JetBrains.Build.Helpers.Inputs.TrackedFileItemDescription : object {
    [NotNullAttribute]
public TrackedFileInfo FileInfo;
    public TrackedFileItemDescription(TrackedFileInfo fileInfo);
    public virtual string ToString();
}
[BuildHelperAttribute]
public class JetBrains.Build.Helpers.Metadata.BuildTimeRealizedAssemblyItemUnificationWrapper : object {
    private IRealizedAssemblyItemUnification myUnification;
    private IRealizedAssemblyItemUnification JetBrains.Build.Helpers.Metadata.IBuildTimeRealizedAssemblyItemUnification.Unification { get; }
    public BuildTimeRealizedAssemblyItemUnificationWrapper(IRunningIsolatedBuildContext ctx);
    private sealed virtual override IRealizedAssemblyItemUnification JetBrains.Build.Helpers.Metadata.IBuildTimeRealizedAssemblyItemUnification.get_Unification();
}
[BuildHelperAttribute]
public interface JetBrains.Build.Helpers.Metadata.IBuildTimeRealizedAssemblyItemUnification {
    public IRealizedAssemblyItemUnification Unification { get; }
    public abstract virtual IRealizedAssemblyItemUnification get_Unification();
}
public class JetBrains.Build.Helpers.Metadata.PrecalculatedPartCatalog : object {
    public static string AssembliesStreamName;
    public static RelativePath DefaultFileName;
    public static string FileSubstorageName;
    [NotNullAttribute]
public IReadOnlyDictionary`2<AssemblyNameInfo, RelativePath> AssembliesAndFiles;
    public ImmutableFileItem PartCatalogTablesMemoryDump;
    [NotNullAttribute]
public IEnumerable`1<AssemblyNameInfo> Assemblies { get; }
    public PrecalculatedPartCatalog(IStructuredStorage sstg);
    public PrecalculatedPartCatalog(IReadOnlyDictionary`2<AssemblyNameInfo, RelativePath> assemblies, ImmutableFileItem partCatalogTablesMemoryDump);
    private static PrecalculatedPartCatalog();
    public IEnumerable`1<AssemblyNameInfo> get_Assemblies();
    public virtual string ToString();
    private sealed virtual override void JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData(IStructuredStorage sstg);
    [CompilerGeneratedAttribute]
private void <JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData>b__10_0(CsexpWriter writer);
}
public class JetBrains.Build.Helpers.Msbuild.BuildResults : object {
    [NotNullAttribute]
public IDictionary`2<FileSystemPath, MessageCounts> MapMessageCountsByProject;
    public UInt32 MsbuildExeErrorLevel;
    public MessageCounts TotalMessageCounts;
    public BuildResults(MessageCounts counts, UInt32 msbuildExeErrorLevel, IDictionary`2<FileSystemPath, MessageCounts> mapMessageCountsByProject);
    public virtual string ToString();
}
[ValueSerializerAttribute("JetBrains.Build.Helpers.Msbuild.DispositionAgainstCommonTargetsSerializer")]
public enum JetBrains.Build.Helpers.Msbuild.DispositionAgainstCommonTargets : Enum {
    public int value__;
    public static DispositionAgainstCommonTargets Before;
    public static DispositionAgainstCommonTargets After;
}
public class JetBrains.Build.Helpers.Msbuild.DispositionAgainstCommonTargetsSerializer : ValueSerializerBase`1<DispositionAgainstCommonTargets> {
}
public interface JetBrains.Build.Helpers.Msbuild.IInvokeMsbuild {
    [NotNullAttribute]
public abstract virtual Task`1<InvokeMsbuild> CreateSessionAsync(MsbuildToolsetPackageIdentity toolset);
}
public class JetBrains.Build.Helpers.Msbuild.InvokeMsbuild : object {
    private static bool OptionNeverUseTeamcityLogger;
    [NotNullAttribute]
private ITaskHost myTasker;
    [CompilerGeneratedAttribute]
private TimeSpan <BuildTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <EnvironmentVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private Nodes <IsConcurrent>k__BackingField;
    [CompilerGeneratedAttribute]
private InvokeMsbuildToolset <MsbuildToolset>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ProcessPriorityClass> <PriorityClass>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FileSystemPath> <Projects>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectsOrdering <ProjectsOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<MsbuildLoggerVerbosity> <Verbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggingLevel <InfoMessagesLoggingLevel>k__BackingField;
    public TimeSpan BuildTimeout { get; public set; }
    public IDictionary`2<string, string> EnvironmentVariables { get; }
    public Nodes IsConcurrent { get; public set; }
    [NotNullAttribute]
public InvokeMsbuildToolset MsbuildToolset { get; }
    public Nullable`1<ProcessPriorityClass> PriorityClass { get; public set; }
    public IList`1<FileSystemPath> Projects { get; }
    public ProjectsOrdering ProjectsOrder { get; public set; }
    public IDictionary`2<string, string> Properties { get; }
    public IList`1<string> Targets { get; }
    public Nullable`1<MsbuildLoggerVerbosity> Verbosity { get; public set; }
    public LoggingLevel InfoMessagesLoggingLevel { get; public set; }
    public InvokeMsbuild(InvokeMsbuildToolset toolset, ITaskHost tasker);
    private static InvokeMsbuild();
    [CompilerGeneratedAttribute]
public TimeSpan get_BuildTimeout();
    [CompilerGeneratedAttribute]
public void set_BuildTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
public Nodes get_IsConcurrent();
    [CompilerGeneratedAttribute]
public void set_IsConcurrent(Nodes value);
    [CompilerGeneratedAttribute]
public InvokeMsbuildToolset get_MsbuildToolset();
    [CompilerGeneratedAttribute]
public Nullable`1<ProcessPriorityClass> get_PriorityClass();
    [CompilerGeneratedAttribute]
public void set_PriorityClass(Nullable`1<ProcessPriorityClass> value);
    [CompilerGeneratedAttribute]
public IList`1<FileSystemPath> get_Projects();
    [CompilerGeneratedAttribute]
public ProjectsOrdering get_ProjectsOrder();
    [CompilerGeneratedAttribute]
public void set_ProjectsOrder(ProjectsOrdering value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public IList`1<string> get_Targets();
    [CompilerGeneratedAttribute]
public Nullable`1<MsbuildLoggerVerbosity> get_Verbosity();
    [CompilerGeneratedAttribute]
public void set_Verbosity(Nullable`1<MsbuildLoggerVerbosity> value);
    [CompilerGeneratedAttribute]
public LoggingLevel get_InfoMessagesLoggingLevel();
    [CompilerGeneratedAttribute]
public void set_InfoMessagesLoggingLevel(LoggingLevel value);
    public void AddTarget(WellKnownTargets target);
    public void AddTarget(string projectName, WellKnownTargets target);
    [NotNullAttribute]
public BuildResults Build();
    [NotNullAttribute]
public Task`1<BuildResults> BuildAsync();
    [NotNullAttribute]
public Task`1<BuildResults> BuildAsync(OuterLifetime outerlifetime, ILogger logger);
    [NotNullAttribute]
public static BuildResults BuildProject(FileSystemPath pathProject, ITaskHost tasker, Nullable`1<WellKnownTargets> target, Nullable`1<WellKnownProperties> properties, IList`1<FileSystemPath> allprojects, IList`1<string> rawtargets, IDictionary`2<string, string> rawproperties, Nullable`1<Nodes> isConcurrent, Nullable`1<MsbuildLoggerVerbosity> verbosity, Version2 msbuildversion, ProjectsOrdering ordering, IDictionary`2<string, string> envvariables, Nullable`1<TimeSpan> timeout);
    public static void FixEnvironmentForCompatibilityWithAgents(IDictionary`2<string, string> environmentVariables, ILogger logger);
    public void SetProperties(WellKnownProperties props);
    private void AssertProjectsExist(ILogger logger);
    [NotNullAttribute]
private FileSystemPath EmitTmpBuildFileIfNeeded(Lifetime lifetime, ILogger logger);
    [NotNullAttribute]
private string GetProjectsDisplayNameForDiag();
    private bool IsConsideredVerbose();
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Msbuild.InvokeMsbuild/<MakeStartInfoCommandLineAsync>d__54")]
[NotNullAttribute]
private Task`1<StartInfo> MakeStartInfoCommandLineAsync(IJetMsbuildLoggerApiSession loggersession, FileSystemPath pathBuildFile, LoggerMode loggermode, ILogger logger);
    [CanBeNullAttribute]
private static IJetMsbuildLoggerApiSession TryCreateMsbuildLoggerSession(Lifetime lifetime, FileSystemPath pathToLoggerAssembly, ILogger logger);
}
[ExtensionAttribute]
public static class JetBrains.Build.Helpers.Msbuild.InvokeMsbuildEx : object {
    [ExtensionAttribute]
public static WellKnownPlatform ToWellKnownPlatform(Nullable`1<JetArchitecture> architecture);
    [ExtensionAttribute]
public static WellKnownPlatform ToWellKnownPlatform(JetArchitecture architecture);
}
[BuildHelperAttribute]
public class JetBrains.Build.Helpers.Msbuild.InvokeMsbuildHelper : object {
    private Optional`1<NugetPackageManagerForBuild> myNugetter;
    private IBuildTaskHost myTasker;
    private Dictionary`2<MsbuildToolsetPackageIdentity, InvokeMsbuildToolset> myToolsets;
    public InvokeMsbuildHelper(Optional`1<NugetPackageManagerForBuild> nugetter, IBuildTaskHost tasker);
    private sealed virtual override Task`1<InvokeMsbuild> JetBrains.Build.Helpers.Msbuild.IInvokeMsbuild.CreateSessionAsync(MsbuildToolsetPackageIdentity toolset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.Build.Helpers.Msbuild.InvokeMsbuildToolset : object {
    public string DisplayName { get; }
    public abstract virtual string get_DisplayName();
    public static InvokeMsbuildToolset FromIdentity(MsbuildToolsetPackageIdentity identity, IJetNugetPackageManager nugetter, ITaskHost tasker);
    public static MachineInstalledMsbuildToolset FromMachineInstalled(Version2 version, ITaskHost tasker, DotNetFrameworkArchitecture architecture, IJetNugetPackageManager nugetter);
    public static InvokeMsbuildToolset FromNetCoreSdk(OuterLifetime lifetime, LocallyExpandable sdkpkg, IJetNugetPackageManager nugetter, ITaskHost tasker, ILogger logger);
    public abstract virtual Task`1<Version> GetEngineVersionAsync();
    public abstract virtual Task`1<FileSystemPath> GetPathToLoggerAssemblyAsync();
    public abstract virtual Task`1<FileSystemPath> GetPathToMsbuildExeAsync();
    public abstract virtual Task`1<FileSystemPath> GetRuntimeEntryPointIfApplicableAsync();
    public virtual string ToString();
}
public static class JetBrains.Build.Helpers.Msbuild.JetMsbuildToolsetLoggerLoader : object {
    public static JetPackageIdentity FallbackLoggerBodyPackage;
    public static Type LoggerInterfaceType;
    [NotNullAttribute]
public static AssemblyNameInfo LoggerClientAssemblyName;
    private static JetMsbuildToolsetLoggerLoader();
    public static Type FindEntryPointType(Assembly assembly);
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Msbuild.JetMsbuildToolsetLoggerLoader/<LoadFallbackLoggerAssemblyAsync>d__4")]
[NotNullAttribute]
public static Task`1<FileSystemPath> LoadFallbackLoggerAssemblyAsync(OuterLifetime outer, IJetNugetPackageManager nugetter, ITaskHost tasker, ILogger logger);
    public static IJetMsbuildLoggerApi TryCreateLoggerInstance(FileSystemPath pathToLoggerAssembly, OnError onerror);
}
public class JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset : InvokeMsbuildToolset {
    public static FileSystemPath AllToolsetsExpandRoot;
    public static Guid Generation;
    private static string MsbuildExeFileName;
    private static string SectionMonoSpecific;
    private static string SectionNetfx;
    private ILogger Logger;
    [CanBeNullAttribute]
private FileSystemPath myDirForToolsetOverride;
    private AsyncLazy`1<ExpandedToolsetInfo> myExpandedToolset;
    [NotNullAttribute]
private JetPackageIdentity myIdentityPackageWithToolset;
    private IJetNugetPackageManager myNugetter;
    [NotNullAttribute]
private AsyncLazy`1<IJetNugetPackage> myNugetWithMsBuildOriginal;
    private AsyncLazy`1<OriginalMsbuildInfo> myOriginalMsbuildInfo;
    [NotNullAttribute]
private ITaskHost myTasker;
    private AsyncLazy`1<ReferencedToolsetIdentity> myToolsetIdentity;
    public string DisplayName { get; }
    public JetPackagedMsbuildToolset(JetPackageIdentity identityPackageWithToolset, IJetNugetPackageManager nugetter, ITaskHost tasker, FileSystemPath dirForToolsetOverride);
    private static JetPackagedMsbuildToolset();
    public virtual string get_DisplayName();
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset/<GetEngineVersionAsync>d__17")]
public virtual Task`1<Version> GetEngineVersionAsync();
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset/<GetPathToLoggerAssemblyAsync>d__18")]
public virtual Task`1<FileSystemPath> GetPathToLoggerAssemblyAsync();
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset/<GetPathToMsbuildExeAsync>d__19")]
public virtual Task`1<FileSystemPath> GetPathToMsbuildExeAsync();
    public virtual Task`1<FileSystemPath> GetRuntimeEntryPointIfApplicableAsync();
    public virtual string ToString();
    private AsyncLazy`1<ExpandedToolsetInfo> Ctor_ExpandedToolset();
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset/<Ctor_ExpandedToolset_ChooseLogger>d__23")]
private Task`1<FileSystemPath> Ctor_ExpandedToolset_ChooseLogger(Lifetime lifetime, Task`1<IJetNugetPackage[]> futureSdkPackages, FileSystemPath dirToolsetUnlessOverridden, ITaskHost tasker);
    private AsyncLazy`1<OriginalMsbuildInfo> Ctor_OriginalMsbuildInfo();
    private AsyncLazy`1<ReferencedToolsetIdentity> Ctor_ToolsetIdentity();
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset/<ExpandConfigFileMacrosAsync>d__26")]
[NotNullAttribute]
private static Task`1<ImmutableFileItem> ExpandConfigFileMacrosAsync(ImmutableFileItem fiOriginal, FileSystemPath dirMsbuildExe, Dictionary`2<string, AsyncLazy`1<RestoredPackage>> mapSdkPackagesRestored, ILogger logger);
    private static ImmutableArray`1<JetNugetEntry> FilterByRuntime(ImmutableArray`1<JetNugetEntry> entries, ILogger logger);
    [NotNullAttribute]
private static RelativePath FilterByRuntime_ChooseSection(JetHashSet`1<string> sections, ILogger logger);
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset/<PatchMsbuildPackageWithLocalPathsAsync>d__29")]
[UsedImplicitlyAttribute]
private static Task`1<MsbuildNugetPatched> PatchMsbuildPackageWithLocalPathsAsync(IJetNugetPackage original, FileSystemPath pathExpandRoot, ReferencedToolsetIdentity identity, Dictionary`2<string, AsyncLazy`1<RestoredPackage>> mapSdkPackagesRestored, ILogger logger);
    [CompilerGeneratedAttribute]
private Task`1<ExpandedToolsetInfo> <Ctor_ExpandedToolset>b__22_0();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset/<<Ctor_ExpandedToolset>b__22_1>d")]
[CompilerGeneratedAttribute]
private Task`1<ExpandedToolsetInfo> <Ctor_ExpandedToolset>b__22_1(Lifetime lifetime);
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset/<<Ctor_OriginalMsbuildInfo>b__24_0>d")]
[CompilerGeneratedAttribute]
private Task`1<OriginalMsbuildInfo> <Ctor_OriginalMsbuildInfo>b__24_0();
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset/<<Ctor_ToolsetIdentity>b__25_0>d")]
[CompilerGeneratedAttribute]
private Task`1<ReferencedToolsetIdentity> <Ctor_ToolsetIdentity>b__25_0();
}
public class JetBrains.Build.Helpers.Msbuild.LogReceiveHandler : object {
    [NotNullAttribute]
private ILogger Logger;
    [CanBeNullAttribute]
private FileSystemPath myBaseDirForProjectNames;
    [NotNullAttribute]
private JetHashSet`1<string> myHashWaitingForProjects;
    private LoggerMode myLoggerMode;
    [NotNullAttribute]
private IDictionary`2<Pair`2<int, int>, FileSystemPath> myMapProjectId;
    private int myWereTotalProjects;
    public LoggingLevel InfoMessagesLoggingLevel;
    public LockObject LockNeutralThreading;
    public IDictionary`2<FileSystemPath, MessageCounts> MapMessageCountsByProject;
    public MessageCounts TotalMessageCounts;
    public LogReceiveHandler(ILogger logger, LoggerMode loggermode, LoggingLevel infoMessagesLoggingLevel, IList`1<FileSystemPath> projectsExpected);
    private sealed virtual override void JetBrains.MSBuild.Logger.Api.IJetMsbuildLoggerApiMessageSink.LogMessageReceived(JetMsbuildLoggerApiLoggerMessageKind kind, string text, string errorCode, int nodeid, int projectid);
    private static void ReportMessage(JetMsbuildLoggerApiLoggerMessageKind kind, string text, ILogger logger, int nodeid);
}
public class JetBrains.Build.Helpers.Msbuild.MachineInstalledMsbuildToolset : InvokeMsbuildToolset {
    public static FileSystemPath LoggerPackageExpandRoot;
    private DotNetFrameworkArchitecture myArchitecture;
    [NotNullAttribute]
private Version2 myEngineVersion;
    private AsyncLazy`1<FileSystemPath> myPathToLoggerAssemblyAsync;
    public DotNetFrameworkArchitecture CpuArchitecture { get; }
    public string DisplayName { get; }
    public MachineInstalledMsbuildToolset(Version2 engineVersion, DotNetFrameworkArchitecture architecture, IJetNugetPackageManager nugetter, ITaskHost tasker);
    private static MachineInstalledMsbuildToolset();
    public DotNetFrameworkArchitecture get_CpuArchitecture();
    public virtual string get_DisplayName();
    [NotNullAttribute]
public virtual Task`1<Version> GetEngineVersionAsync();
    public virtual Task`1<FileSystemPath> GetPathToLoggerAssemblyAsync();
    [NotNullAttribute]
public virtual Task`1<FileSystemPath> GetPathToMsbuildExeAsync();
    public virtual Task`1<FileSystemPath> GetRuntimeEntryPointIfApplicableAsync();
    public static bool IsInstalled(Version2 version, DotNetFrameworkArchitecture cpuarch);
    internal static FileSystemPath GetPathToMsbuildExe_40(DotNetFrameworkArchitecture cpuArchitecture);
    private static FileSystemPath GetPathToMsbuildExe_Since120(Version2 msbuildVersion, DotNetFrameworkArchitecture cpuArchitecture);
    [CanBeNullAttribute]
private static FileSystemPath GetSideBySideLoggerAssemblyOrErrNull(ILogger logger);
}
internal static class JetBrains.Build.Helpers.Msbuild.MsbuildCompositeProjectEmitter : object {
    public static FileSystemPath Run(Lifetime lifetime, IList`1<FileSystemPath> projects, ProjectsOrdering ordering, IList`1<string> targets, IDictionary`2<string, string> properties, ILogger logger);
    [NotNullAttribute]
private static IReadOnlyCollection`1<string> GetDelegatedTargetsFromAllTargets(IList`1<string> targets);
    [NotNullAttribute]
private static IReadOnlyCollection`1<string> GetDependsOnTargetsFromAllTargets(IList`1<string> targets);
    private static FileSystemPath[][] ImposeProjectOrdering(IList`1<FileSystemPath> projects, ProjectsOrdering ordering, ILogger logger);
}
internal static class JetBrains.Build.Helpers.Msbuild.MsbuildEscapingUtilities : object {
    private static Char[] s_charsToEscape;
    private static Dictionary`2<string, string> s_unescapedToEscapedStrings;
    private static MsbuildEscapingUtilities();
    private static void AppendEscapedChar(StringBuilder sb, char ch);
    private static void AppendEscapedString(StringBuilder sb, string unescapedString);
    internal static bool ContainsEscapedWildcards(string escapedString);
    private static bool ContainsReservedCharacters(string unescapedString);
    internal static string Escape(string unescapedString);
    internal static string EscapeWithCaching(string unescapedString);
    private static string EscapeWithOptionalCaching(string unescapedString, bool cache);
    private static char HexDigitChar(int x);
    private static bool IsHexDigit(char character);
    internal static string UnescapeAll(string escapedString);
    internal static string UnescapeAll(string escapedString, Boolean& escapingWasNecessary);
}
public static class JetBrains.Build.Helpers.Msbuild.MsbuildFile : object {
}
public class JetBrains.Build.Helpers.Msbuild.MsbuildToolsetPackageIdentity : JetPackageIdentity {
    [NotNullAttribute]
public static string LocalMachineToolsetSyntheticId;
    public MsbuildToolsetPackageIdentity(string id, JetSemanticVersion version);
    private static MsbuildToolsetPackageIdentity();
    public sealed virtual bool Equals(MsbuildToolsetPackageIdentity other);
    [NotNullAttribute]
public static MsbuildToolsetPackageIdentity CreateToolsetIdentity(string name, JetSemanticVersion version);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MsbuildToolsetPackageIdentity left, MsbuildToolsetPackageIdentity right);
    public static bool op_Inequality(MsbuildToolsetPackageIdentity left, MsbuildToolsetPackageIdentity right);
    [NotNullAttribute]
public static MsbuildToolsetPackageIdentity Parse(string text);
}
public class JetBrains.Build.Helpers.Msbuild.NetCoreSdkMsbuildToolset : InvokeMsbuildToolset {
    private AsyncLazy`1<FileSystemPath> myLazyLoggerAssemblyPath;
    public LocallyExpandable Package;
    public string DisplayName { get; }
    public NetCoreSdkMsbuildToolset(OuterLifetime lifetime, LocallyExpandable package, IJetNugetPackageManager nugetter, ITaskHost tasker, ILogger logger);
    public virtual string get_DisplayName();
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Msbuild.NetCoreSdkMsbuildToolset/<GetEngineVersionAsync>d__5")]
public virtual Task`1<Version> GetEngineVersionAsync();
    public virtual Task`1<FileSystemPath> GetPathToLoggerAssemblyAsync();
    public virtual Task`1<FileSystemPath> GetPathToMsbuildExeAsync();
    public virtual Task`1<FileSystemPath> GetRuntimeEntryPointIfApplicableAsync();
}
public static class JetBrains.Build.Helpers.Msbuild.ToolsetHelpers : object {
}
public class JetBrains.Build.Helpers.Nuget.AssemblyItemInPackage : object {
    private ImmutableFileItem myFile;
    private AssemblyNameInfo myName;
    [NotNullAttribute]
private IJetNugetPackage myNuget;
    private NugetPartPaths myNugetPartPaths;
    private AssemblyNameInfo JetBrains.Metadata.Utils.IAssemblyItem.AssemblyName { get; }
    private ImmutableFileItem JetBrains.Metadata.Utils.IAssemblyItem.File { get; }
    [NotNullAttribute]
private IJetNugetPackage JetBrains.Build.Helpers.Nuget.IAssemblyItemInPackage.Package { get; }
    private NugetPartPaths JetBrains.Build.Helpers.Nuget.IAssemblyItemInPackage.PartPaths { get; }
    public AssemblyItemInPackage(AssemblyNameInfo name, IJetNugetPackage nuget, ImmutableFileItem fi, NugetPartPaths nugetPartPaths);
    [NotNullAttribute]
public static AssemblyItemInPackage FromNugetEntry(AssemblyNameInfo name, IJetNugetPackage nuget, JetNugetEntry ne);
    public virtual string ToString();
    private sealed virtual override AssemblyNameInfo JetBrains.Metadata.Utils.IAssemblyItem.get_AssemblyName();
    private sealed virtual override ImmutableFileItem JetBrains.Metadata.Utils.IAssemblyItem.get_File();
    private sealed virtual override IJetNugetPackage JetBrains.Build.Helpers.Nuget.IAssemblyItemInPackage.get_Package();
    private sealed virtual override NugetPartPaths JetBrains.Build.Helpers.Nuget.IAssemblyItemInPackage.get_PartPaths();
}
public interface JetBrains.Build.Helpers.Nuget.IAssemblyItemInPackage {
    [NotNullAttribute]
public IJetNugetPackage Package { get; }
    public NugetPartPaths PartPaths { get; }
    public abstract virtual IJetNugetPackage get_Package();
    public abstract virtual NugetPartPaths get_PartPaths();
}
[ExtensionAttribute]
public static class JetBrains.Build.Helpers.Nuget.NugetAssemblyItemsExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IReadOnlyCollection`1<IAssemblyItem> GetAssemblyItems(IHaveJetNugetPackage thіs);
    [ExtensionAttribute]
public static PackageAssemblyItems GetAssemblyItems3(IHaveJetNugetPackage thіs, AssemblyFilesSetFlags fileset, JetNugetTargetFramework nugetTargetFramework, AssemblyListSource assemblyListSource, ILogger logger);
    [ExtensionAttribute]
public static PackageAssemblyItems GetAssemblyItemsEx(IHaveJetNugetPackage thіs);
    [ExtensionAttribute]
public static ValueTuple`2<AssemblyFilesSetFlags, JetNugetTargetFramework> RefAsmPackageInfoToNugetLookupFlags(RefAsmInfo refasm);
    [ExtensionAttribute]
public static bool TryReadAssemblyName(JetNugetEntry ne, AssemblyInfo& assinfo);
    private static Nullable`1<PackageAssemblyItems> GetAssemblyItemsEx_CatalogInJetMetadata(IHaveJetNugetPackage nupkg, IReadOnlyList`1<JetNugetEntry> entries, ILogger logger);
    private static ImmutableArray`1<IAssemblyItemInPackage> GetAssemblyItemsEx_ReadFromEntries(IHaveJetNugetPackage nupkg, IReadOnlyList`1<JetNugetEntry> entries, AssemblyFilesSetFlags fileset);
}
[BuildArtifactAttribute]
[ValueSerializerAttribute("JetBrains.Build.Helpers.Nuget.NugetConfigFile/NugetConfigFileSerializer")]
public class JetBrains.Build.Helpers.Nuget.NugetConfigFile : object {
    [NotNullAttribute]
public ImmutableFileItem File;
    public NugetConfigFile(ImmutableFileItem file);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Build.Helpers.Nuget.NugetConfigFileHelpers : object {
    public static ImmutableFileItem CreateConfigForSources(ImmutableArray`1<PackageSource> sources);
    public static NugetConfigFile CreateFakeEmptyNugetConfigFile();
    [BuildStepAttribute]
public static NugetConfigFile ReadNugetConfigFileFromLocalPath(NugetConfigFileLocalPath localpath, ILogger logger);
    public static ISettings LoadNugetSettingsGen4FromFile(ImmutableFileItem fiNugetConfig);
    [ExtensionAttribute]
public static Optional`1<NugetConfigFile> OptionalNugetConfigFile(IJetNugetPackageManager nugetter);
    [ExtensionAttribute]
public static NugetConfigFile NugetConfigFileArtifact(IJetNugetPackageManager nugetter);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<SourceRepository> ReadEnabledSourceRepositoriesFromNugetConfig(ImmutableFileItem fiNugetConfig);
}
[BuildArtifactAttribute]
[MemberwiseSerializableAttribute]
[ValueSerializerAttribute("JetBrains.Build.Helpers.Nuget.NugetConfigFileLocalPath/NugetConfigFileLocalPathSerializer")]
public class JetBrains.Build.Helpers.Nuget.NugetConfigFileLocalPath : object {
    [NotNullAttribute]
public FileSystemPath LocalPath;
    public NugetConfigFileLocalPath(FileSystemPath localPath);
    public virtual string ToString();
}
public class JetBrains.Build.Helpers.Nuget.NuGetLogger : LoggerBase {
    [NotNullAttribute]
private ILogger myLogger;
    public NuGetLogger(ILogger logger);
    public virtual void Log(ILogMessage message);
    public virtual Task LogAsync(ILogMessage message);
}
[BuildHelperAttribute]
public class JetBrains.Build.Helpers.Nuget.NugetPackageManagerForBuild : object {
    private static TimeSpan MaxTimeoutBetweenRemoteAttempts;
    private static bool OptionDecompress;
    [NotNullAttribute]
private LocalRestoreNugetPackagesCentralCache myCentralCache;
    private int myIsCleanupInitiated;
    [NotNullAttribute]
private Lazy`1<ImmutableArray`1<SourceRepository>> myLazyEnabledSourceRepositories;
    [NotNullAttribute]
private ILogger myLogger;
    [NotNullAttribute]
private StrongToWeakDictionary`2<JetPackageIdentity, object> myMemCache;
    [NotNullAttribute]
private Optional`1<NugetConfigFile> myNugetConfigFile;
    [NotNullAttribute]
private ITaskHost myTasker;
    private ImmutableFileItem JetBrains.Util.Storage.Packages.IJetNugetPackageManager.NugetConfigFile { get; }
    public NugetPackageManagerForBuild(Lifetime lifetime, Optional`1<NugetConfigFile> nugetConfigFile, ITaskHost tasker, ILogger logger);
    public NugetPackageManagerForBuild(Lifetime lifetime, Optional`1<NugetConfigFile> nugetConfigFile, IBuildTaskHost tasker, ILogger logger, IEnumerable`1<SourceRepository> sourceRepositories);
    private static NugetPackageManagerForBuild();
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Nuget.NugetPackageManagerForBuild/<ChainDownloadTasks>d__11")]
private static Task`1<SourceRepositoryDownloadResult> ChainDownloadTasks(Task`1<SourceRepositoryDownloadResult> taskFromPrev, Task`1<SourceRepositoryDownloadResult> taskThis, OnError onerror);
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Nuget.NugetPackageManagerForBuild/<CleanupExpiredFoldersInCentralCacheAsync>d__12")]
private Task CleanupExpiredFoldersInCentralCacheAsync(OuterLifetime lifetimeLimit);
    [CanBeNullAttribute]
private static ImmutableFileItem DecompressNugetIfNeeded(ImmutableFileItem fileOriginal);
    private sealed virtual override Task`1<IJetNugetPackage> JetBrains.Util.Storage.Packages.IJetNugetPackageManager.GetPackageAsync(OuterLifetime lifetimeLimit, JetPackageIdentity package, OnError onerror, IProperty`1<GetPackageStatus> status);
    private sealed virtual override ImmutableFileItem JetBrains.Util.Storage.Packages.IJetNugetPackageManager.get_NugetConfigFile();
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Nuget.NugetPackageManagerForBuild/<TryBeginDownloadFromRepoAsync>d__17")]
private static Task`1<SourceRepositoryDownloadResult> TryBeginDownloadFromRepoAsync(OuterLifetime lifetime, JetPackageIdentity package, SourceRepository sr, ITaskHost tasker, ILogger logger, ILogger loggerNuget, DownloadProgress progress);
    [CompilerGeneratedAttribute]
internal static SourceRepositoryDownloadResult <TryBeginDownloadFromRepoAsync>g__MakeErrorAndLogVerbose|17_0(string message, <>c__DisplayClass17_0& );
}
public class JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged : object {
    [NotNullAttribute]
public static string ProgressTaskDisplayName;
    [NotNullAttribute]
private AsyncLazy`1<ExploredPackage> myLazyDownloadedAndExploredNupkg;
    private OuterLifetime myLifetime;
    [NotNullAttribute]
private ILogger myLogger;
    [NotNullAttribute]
private ITaskHost myTasker;
    [NotNullAttribute]
public JetPackageIdentity PackageId;
    public DotNetCoreSdkPackaged(OuterLifetime lifetime, JetPackageIdentity packageId, IJetNugetPackageManager nugetter, ITaskHost tasker, ILogger logger);
    private static DotNetCoreSdkPackaged();
    [NotNullAttribute]
public LocallyExpandable AsLocalExpandableInto(FileSystemPath dirLocalExpandBase);
    [NotNullAttribute]
public Task`1<ExploredPackage> DownloadAndExploreAsync();
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged/<DownloadAndExploreCoreAsync>d__9")]
public static Task`1<ExploredPackage> DownloadAndExploreCoreAsync(OuterLifetime lifetime, JetPackageIdentity pkgid, IJetNugetPackageManager nugetter, ITaskHost tasker, ILogger logger);
    public virtual string ToString();
}
public interface JetBrains.Build.Helpers.TeamCity.ITeamCityProperties {
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> EnumConfigurationProperties();
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> EnumSystemProperties();
    public abstract virtual string GetConfigurationProperty(string name);
    public abstract virtual string GetSystemProperty(string name);
    public abstract virtual string TryGetConfigurationProperty(string name);
    public abstract virtual string TryGetSystemProperty(string name);
}
public class JetBrains.Build.Helpers.TeamCity.MockTeamCityProperties : object {
    [NotNullAttribute]
private IDictionary`2<string, string> myConfigurationProperties;
    [NotNullAttribute]
private IDictionary`2<string, string> mySystemProperties;
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> EnumConfigurationProperties();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> EnumSystemProperties();
    public sealed virtual string GetConfigurationProperty(string name);
    public sealed virtual string GetSystemProperty(string name);
    public void LoadHybridPropertiesFile(FileSystemPath path);
    public void LoadHybridPropertiesFile(Stream stream);
    public void LoadHybridPropertiesXmlFile(FileSystemPath path);
    public void LoadHybridPropertiesXmlFile(Stream stream);
    public void SetConfigurationProperty(string name, string value);
    public void SetSystemProperty(string name, string value);
    public sealed virtual string TryGetConfigurationProperty(string name);
    public sealed virtual string TryGetSystemProperty(string name);
    private static bool IsScrambledSecureProperty(KeyValuePair`2<string, string> pair);
    private void LoadHybridProperties(IDictionary`2<string, string> allprops);
}
public static class JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers : object {
    private static string BuildIdConfigPropName;
    private static TeamCityBuildHelpers();
    public static Task`1<ImmutableFileItem> GetArtifactAsync(Lifetime lifetime, BuildArtifactInfo artinfo, ITeamCityProperties tcprops, IBuildTaskHost tasker, ILogger logger);
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers/<GetArtifactAsync>d__3")]
public static Task`1<ImmutableFileItem> GetArtifactAsync(Lifetime lifetime, string filename, string buildid, ITeamCityProperties tcprops, IBuildTaskHost tasker, ILogger logger, string sHRefIfKnown, Nullable`1<ulong> nSizeIfKnown);
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers/<GetArtifactsListAsync>d__4")]
public static Task`1<IReadOnlyCollection`1<BuildArtifactInfo>> GetArtifactsListAsync(Lifetime lifetime, string buildid, ITeamCityProperties tcprops, IBuildTaskHost tasker, ILogger logger);
    [NotNullAttribute]
public static string GetRunningBuildTeamCityId(ITeamCityProperties tcprops);
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers/<MakeXmlQueryAsync>d__6")]
public static Task`1<XmlDocument> MakeXmlQueryAsync(Lifetime lifetime, string query, ITeamCityProperties tcprops, IBuildTaskHost tasker, ILogger logger);
    public static void PublishArtifact(ImmutableFileItem file, ILogger logger);
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers/<GetArtifactAsync_SingleAttempt>d__8")]
[ItemNotNullAttribute]
private static Task`1<ImmutableFileItem> GetArtifactAsync_SingleAttempt(string filename, string buildid, string sHRef, ITeamCityProperties tcprops, Nullable`1<ulong> nSizeIfKnown, ILogger logger);
    [AsyncStateMachineAttribute("JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers/<MakeXmlQueryAsync_SingleAttempt>d__9")]
[ItemNotNullAttribute]
private static Task`1<XmlDocument> MakeXmlQueryAsync_SingleAttempt(string query, ITeamCityProperties tcprops, ILogger logger);
}
public static class JetBrains.Build.Helpers.TeamCity.TeamCityLoggingUtil : object {
    public static string LoggingLevelToTeamCityMessageStatus(LoggingLevel level);
    public static void LogRecordToTeamCity(LoggingLevel severity, string sCategory, string sShort, string sLong);
}
public class JetBrains.Build.Helpers.TeamCity.TeamCityMessages : object {
    private static Byte[] ourLookupHi;
    private static Byte[] ourLookupLo;
    public static string ServiceMessageOpen;
    public static string ServiceMessageClose;
    private static TeamCityMessages();
    public static MessageContext BeginMessage(string sMessageName, TextWriter writer);
    public static void EmitFailedTest(string sFakeSuiteName, string sFakeTestName, string sErrorMessage, Exception ex);
    public static string Escape(string value);
    public static string EscapeEx(string value);
    private static string FormatMessageCore(string sMessageName, FrugalLocalList`1<Pair`2<string, string>> parameters);
    private static void SendMessageCore(string sMessageName, FrugalLocalList`1<Pair`2<string, string>> parameters, TextWriter writer);
}
public static class JetBrains.Build.Helpers.TeamCity.TeamCityNetfxTools : object {
    [CanBeNullAttribute]
public static string TryGetTeamCityMsbuildLoggerParam(Version version, TeamCityProperties tc);
    [CanBeNullAttribute]
public static FileSystemPath TryGetTeamCityNunitLauncherExe(TeamCityProperties tc);
}
public class JetBrains.Build.Helpers.TeamCity.TeamCityProperties : object {
    public static string FlowIdEnvironmentVariable;
    public static string NUnitSuitePatternEnvironmentVariable;
    public static string TEAMCITY_BUILD_PROPERTIES_FILE_ENV_VAR_NAME;
    private IDictionary`2<string, string> myConfigurationProperties;
    private IDictionary`2<string, string> mySystemProperties;
    public string FlowId;
    private static TeamCityProperties();
    public static void AssertIsRunningInTeamCity();
    [NotNullAttribute]
public static TeamCityProperties CreateFromRunningTeamCity();
    [NotNullAttribute]
public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> EnumConfigurationProperties();
    [NotNullAttribute]
public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> EnumSystemProperties();
    [NotNullAttribute]
public sealed virtual string GetConfigurationProperty(string name);
    public static bool GetIsRunningInTeamCity();
    public static bool GetIsRunningInTeamCityEx(String& reason);
    [NotNullAttribute]
public sealed virtual string GetSystemProperty(string name);
    [CanBeNullAttribute]
public sealed virtual string TryGetConfigurationProperty(string name);
    [CanBeNullAttribute]
public sealed virtual string TryGetSystemProperty(string name);
    [NotNullAttribute]
internal static IDictionary`2<string, string> ReadJavaProperties(FileSystemPath pathFile);
    [NotNullAttribute]
internal static IDictionary`2<string, string> ReadJavaProperties(Stream stream);
    [NotNullAttribute]
internal static IDictionary`2<string, string> ReadJavaPropertiesXml(FileSystemPath pathFile);
    [NotNullAttribute]
internal static IDictionary`2<string, string> ReadJavaPropertiesXml(Stream stream);
    private static bool TryGetSystemPropertiesFilePath(FileSystemPath& pathIfValid, String& reason);
    private void TryLoadConfigurationPropertiesFile();
    private void TryLoadSystemPropertiesFile();
}
[ExtensionAttribute]
public static class JetBrains.Build.Helpers.TeamCity.TeamCityPropertiesEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static FileSystemPath GetPersistentCacheFolder(ITeamCityProperties tcprops);
}
public class JetBrains.Build.Running.AdHocBuiltInBuildEngineExtraction : object {
    public static string BuildEngineAssemblyWellKnownSimpleName;
    private Optional`1<PartCatalog> myCatalog;
    public AdHocBuiltInBuildEngineExtraction(Optional`1<PartCatalog> catalog);
    private static AdHocBuiltInBuildEngineExtraction();
    [NotNullAttribute]
public static List`1<AssemblyNameAndLocation> AddReferencedAssemblies(Assembly assemblyStart, bool isNoGacAssemblies);
    public static IReadOnlyCollection`1<ImmutableFileItem> CollectBuiltInEngineDlls(Optional`1<PartCatalog> catalogset);
    [NotNullAttribute]
public Assembly GetEngineAssemblyToStartWith();
    [NotNullAttribute]
public static Assembly GetEngineAssemblyToStartWith(Optional`1<PartCatalog> catalogset);
    private sealed virtual override IReadOnlyCollection`1<ImmutableFileItem> JetBrains.Build.Running.IBuiltInBuildEngineExtraction.GetBuildEngineFiles();
}
[AttributeUsageAttribute("4")]
public class JetBrains.Build.Running.BuildEngineImplementationAttribute : PartAttribute {
}
public class JetBrains.Build.Running.BuildLogRecord : ValueType {
    public string Category;
    [NotNullAttribute]
public static IEqualityComparer`1<BuildLogRecord> EqualityComparer;
    public LoggingLevel Level;
    [NotNullAttribute]
public string LongMessage;
    [CanBeNullAttribute]
public Byte[] Metadata;
    [NotNullAttribute]
public string ShortMessage;
    public DateTime Time;
    public BuildLogRecord(LogEvent logevent);
    public BuildLogRecord(LoggingLevel level, string shortMessage, string longMessage, DateTime time, string category, Byte[] metadata);
    private static BuildLogRecord();
    public LogEvent ToLogEvent();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Build.Running.BuildLogRecordEx : object {
    [NullableContextAttribute("2")]
public static ValueTuple`2<ConcurrentQueue`1<BuildLogRecord>, ILogger> CreateRecordingLogger(string logcategory);
    [ExtensionAttribute]
public static bool IsError(BuildLogRecord& evt);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsNoErrors(IEnumerable`1<BuildLogRecord> records);
    [ExtensionAttribute]
public static bool IsNoErrors(ImmutableArray`1<BuildLogRecord> records);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsWithErrors(IEnumerable`1<BuildLogRecord> records);
    [ExtensionAttribute]
public static bool IsWithErrors(ImmutableArray`1<BuildLogRecord> records);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IEnumerable`1<BuildLogRecord> WhereErrors(IEnumerable`1<BuildLogRecord> records);
}
public static class JetBrains.Build.Running.BuildLogRecordSerialization : object {
    public static UInt32 LogMessageBufferSize;
    private static BuildLogRecordSerialization();
    public static BuildLogRecord BinaryReaderRead(ByteBuffer buffer);
    public static Byte[] BinaryReaderWrite(BuildLogRecord rec);
    public static UInt32 BlobGetCbSize(BuildLogRecord& rec);
    public static BuildLogRecord BlobRead(ByteBuffer& buffer);
    public static void BlobWrite(BuildLogRecord& rec, ByteBuffer& buffer);
    public static void CsexpReadForEach(CsexpReader reader, TArg arg, Action`2<BuildLogRecord, TArg> F);
    public static ImmutableArray`1<BuildLogRecord> CsexpReadMany(CsexpReader reader);
    public static void CsexpWriteMany(CsexpWriter writer, IReadOnlyCollection`1<BuildLogRecord> logrecords);
    [NotNullAttribute]
public static ImmutableArray`1<BuildLogRecord> StructuredStorageReadMany(IStructuredStorage sstg);
    public static void StructuredStorageWriteMany(IStructuredStorage sstg, IReadOnlyCollection`1<BuildLogRecord> logrecords);
}
[BuildArtifactAttribute("1")]
public class JetBrains.Build.Running.BuildOutputFileArtifact : object {
    private static string BuildStageOutputSerializationMarker;
    [NotNullAttribute]
public ImmutableFileItem File;
    public BuildOutputFileArtifact(ImmutableFileItem file);
    public BuildOutputFileArtifact(IStructuredStorage sstg);
    private static BuildOutputFileArtifact();
    public virtual string ToString();
    [CanBeNullAttribute]
public static ImmutableFileItem TryReadFromStorage(IStructuredStorage sstg);
    private sealed virtual override void JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData(IStructuredStorage storage);
    protected virtual void GetObjectDataCore(IStructuredStorage sstg);
}
public abstract class JetBrains.Build.Running.BuildOutputPackageFileArtifact : BuildOutputFileArtifact {
    public IJetNugetPackage Package;
    private IJetNugetPackage JetBrains.Util.Storage.Packages.IHaveJetNugetPackage.Package { get; }
    protected BuildOutputPackageFileArtifact(IJetNugetPackage package);
    protected BuildOutputPackageFileArtifact(IStructuredStorage sstg);
    protected virtual void GetObjectDataCore(IStructuredStorage sstg);
    private sealed virtual override IJetNugetPackage JetBrains.Util.Storage.Packages.IHaveJetNugetPackage.get_Package();
}
public static class JetBrains.Build.Running.BuildRunner : object {
    public static ILogger Logger;
    private static BuildRunner();
    [HandleProcessCorruptedStateExceptionsAttribute]
public static HResults RunCommand(BuildRunnerCommandString commandstring, BeforeSessionStartHandler onBeforeSessionStart, SessionStartedHandler onSessionStarted);
    private static bool UploadToBuildLogMessageChannel(Lifetime lifetime, BuildRunnerSession session, string sMessageChannelText);
}
[PublicAPIAttribute]
public class JetBrains.Build.Running.BuildRunnerCommandString : object {
    public static int vCurrent;
    private static JsonSerializerSettings myJsonSerializerSettings;
    public IDictionary`2<string, String[]> ArtifactMultiStrings;
    public IDictionary`2<string, string> ArtifactStrings;
    [CanBeNullAttribute]
public Byte[] ArtifactsValueSerializer;
    public List`1<string> BuildEngineFiles;
    public string BuildLogRecordChannel;
    public List`1<string> BuildScriptBinaryFiles;
    public List`1<string> BuildScriptSourceFilesOrDirectories;
    public string BuildStageDisplayName;
    public List`1<string> Objectives;
    public string OutputsDir;
    public string OutputsFile;
    public string SerializedBuildRequestFile;
    public int v;
    private static BuildRunnerCommandString();
    [IteratorStateMachineAttribute("JetBrains.Build.Running.BuildRunnerCommandString/<EnumAllArtifactStrings>d__15")]
[NotNullAttribute]
public IEnumerable`1<Pair`2<string, string>> EnumAllArtifactStrings();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static BuildRunnerCommandString Parse(string s);
    public virtual string ToString();
    [CanBeNullAttribute]
public static BuildRunnerCommandString TryFromProcessCommandLineString(string cmdls);
    private sealed virtual override int System.IComparable<JetBrains.Build.Running.BuildRunnerCommandString>.CompareTo(BuildRunnerCommandString other);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override bool System.IEquatable<JetBrains.Build.Running.BuildRunnerCommandString>.Equals(BuildRunnerCommandString other);
}
public enum JetBrains.Build.Running.BuildRunnerEngineType : Enum {
    public int value__;
    public static BuildRunnerEngineType BuiltIn;
    public static BuildRunnerEngineType CustomCompiled;
}
public class JetBrains.Build.Running.BuildRunnerRequest : object {
    [CompilerGeneratedAttribute]
private IList`1<ImmutableFileItem> <BuildScriptBinaries>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<AssemblyQualifiedTypeName> <BuildScriptBinariesInInputArtifacts>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ImmutableFileItem> <BuildScriptSources>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ImmutableFileItem> <CustomEngineBinaries>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildRunnerEngineType <EngineChoice>k__BackingField;
    [CompilerGeneratedAttribute]
private SerializedValuesResolver <InputArtifacts>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<InputArtifactStringName, String[]> <InputArtifactStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<AssemblyQualifiedTypeName> <Objectives>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StageDisplayName>k__BackingField;
    public IList`1<ImmutableFileItem> BuildScriptBinaries { get; }
    public IList`1<AssemblyQualifiedTypeName> BuildScriptBinariesInInputArtifacts { get; }
    public IList`1<ImmutableFileItem> BuildScriptSources { get; }
    [NotNullAttribute]
public IList`1<ImmutableFileItem> CustomEngineBinaries { get; }
    public BuildRunnerEngineType EngineChoice { get; public set; }
    [NotNullAttribute]
public SerializedValuesResolver InputArtifacts { get; }
    [NotNullAttribute]
public IDictionary`2<InputArtifactStringName, String[]> InputArtifactStrings { get; }
    [NotNullAttribute]
public IList`1<AssemblyQualifiedTypeName> Objectives { get; }
    [CanBeNullAttribute]
public string StageDisplayName { get; public set; }
    public BuildRunnerRequest(Lifetime lifetime);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ImmutableFileItem> get_BuildScriptBinaries();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<AssemblyQualifiedTypeName> get_BuildScriptBinariesInInputArtifacts();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ImmutableFileItem> get_BuildScriptSources();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ImmutableFileItem> get_CustomEngineBinaries();
    [CompilerGeneratedAttribute]
public sealed virtual BuildRunnerEngineType get_EngineChoice();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EngineChoice(BuildRunnerEngineType value);
    [CompilerGeneratedAttribute]
public sealed virtual SerializedValuesResolver get_InputArtifacts();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<InputArtifactStringName, String[]> get_InputArtifactStrings();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<AssemblyQualifiedTypeName> get_Objectives();
    [CompilerGeneratedAttribute]
public sealed virtual string get_StageDisplayName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StageDisplayName(string value);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Build.Running.BuildRunnerRequestEx : object {
    private static ILogger Logger;
    private static BuildRunnerRequestEx();
    public static string CreateStageDisplayName(IList`1<AssemblyQualifiedTypeName> objectives);
    [ExtensionAttribute]
public static string GetOrCreateStageDisplayName(IBuildRunnerRequest thіs);
    [ExtensionAttribute]
public static bool HasInput(IBuildRunnerRequest thіs);
    [AsyncStateMachineAttribute("JetBrains.Build.Running.BuildRunnerRequestEx/<ReadInputArtifactInstancesAsFilesAsync>d__4")]
public static Task`1<IList`1<ImmutableFileItem>> ReadInputArtifactInstancesAsFilesAsync(Lifetime lifetime, IReadOnlyCollection`1<AssemblyQualifiedTypeName> artnames, SerializedValuesResolver resolveInputArtifactInstances, ITaskHost tasker, ILogger logger);
    [ExtensionAttribute]
public static void Serialize(IBuildRunnerRequest thіs, IStructuredStorage sstg, bool isStoring, OnError onerror);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TValue TryReadInputArtifactValue(EitherBuildRunnerRequest thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBuildRunnerRequest WithBuildScriptBinaries(IBuildRunnerRequest thіs, ICollection`1<IHaveJetNugetPackage> binaries);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBuildRunnerRequest WithInputs(IBuildRunnerRequest thіs, Object[] inputs);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBuildRunnerRequest WithInputs(IBuildRunnerRequest thіs, IEnumerable`1<object> inputs);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBuildRunnerRequest WithObjective(IBuildRunnerRequest thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBuildRunnerRequest WithoutInput(IBuildRunnerRequest thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBuildRunnerRequest WithSources(IBuildRunnerRequest thіs, IEnumerable`1<ImmutableFileItem> src);
    [ExtensionAttribute]
public static void WithSourcesFromDisk(IBuildRunnerRequest thіs, FileSystemPath dirRelativeRoot, ICollection`1<string> dirsOrFilesWithSources);
    [ExtensionAttribute]
public static void WithSourcesFromDisk(EitherBuildRunnerRequest thіs, FileSystemPath dirRelativeRoot, ICollection`1<string> dirsOrFilesWithSources);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBuildRunnerRequest WithSourcesFromDisk(IBuildRunnerRequest thіs, FileSystemPath dirRelativeRoot, IEnumerable`1<RelativePath> subdirsOrFilesWithSources);
    [ExtensionAttribute]
[NotNullAttribute]
public static EitherBuildRunnerRequest WithSourcesFromDisk(EitherBuildRunnerRequest thіs, FileSystemPath dirRelativeRoot, IEnumerable`1<RelativePath> subdirsOrFilesWithSources);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBuildRunnerRequest WithSourcesFromDisk(IBuildRunnerRequest thіs, FileSystemPath dirRelativeRoot, IEnumerable`1<FileSystemPath> dirsOrFilesWithSources);
    [ExtensionAttribute]
[NotNullAttribute]
public static EitherBuildRunnerRequest WithSourcesFromDisk(EitherBuildRunnerRequest thіs, FileSystemPath dirRelativeRoot, IEnumerable`1<FileSystemPath> dirsOrFilesWithSources);
    private static void Serialize_Files(IStructuredStorage sstgRoot, bool isStoring, string sMemberName, IList`1<ImmutableFileItem> filelist, OnError onerror);
    private static void Serialize_TypeList(IStructuredStorage sstg, bool isStoring, string sName, IList`1<AssemblyQualifiedTypeName> typelist, bool isWriteEmptyList, OnError onerror);
}
public class JetBrains.Build.Running.BuildRunnerResult : object {
    [NotNullAttribute]
public IBindTypeByName ArtifactTypeBinder;
    [NotNullAttribute]
public Func`2<Lifetime, IStructuredStorage> OutputArtifactsStorage;
    public BuildRunnerResult(Func`2<Lifetime, IStructuredStorage> FSstgOutputArtifacts, IBindTypeByName bindTypeByName);
    [NotNullAttribute]
public SerializedValuesResolver OpenOutputArtifacts(Lifetime lifetime);
    [NotNullAttribute]
public BuildRunnerResult WithAnotherTypeBinder(IBindTypeByName bindTypeByName);
}
[ExtensionAttribute]
public static class JetBrains.Build.Running.BuildRunnerResultEx : object {
    private static ILogger Logger;
    private static BuildRunnerResultEx();
    [ExtensionAttribute]
[NotNullAttribute]
public static ICollection`1<BuildOutputFileArtifact> ExtractAnythingWhichLooksLikeAFile(BuildRunnerResult result);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICollection`1<BuildOutputFileArtifact> ExtractBuildOutputFiles(BuildRunnerResult result);
    [ExtensionAttribute]
[NotNullAttribute]
public static TComponent Resolve(BuildRunnerResult thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICollection`1<TComponent> ResolveMultipleOrEmpty(BuildRunnerResult thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static TResult WithOutputArtifacts(BuildRunnerResult thіs, Func`2<SerializedValuesResolver, TResult> F);
    [ExtensionAttribute]
public static void WithOutputArtifacts(BuildRunnerResult thіs, Action`1<SerializedValuesResolver> F);
}
public class JetBrains.Build.Running.BuildRunnerSession : object {
    [NotNullAttribute]
public Task`1<BuildRunnerResult> AsyncBuildResult;
    [NotNullAttribute]
public IListEvents`1<BuildLogRecord> LogEntries;
    [NotNullAttribute]
public BuildRunnerRequest Request;
    public BuildRunnerSession(Task`1<BuildRunnerResult> task, BuildRunnerRequest request, IListEvents`1<BuildLogRecord> logEntries);
}
internal class JetBrains.Build.Running.Data.BuildArtifactClass : object {
    private static ILogger Logger;
    private ICollectionEvents`1<object> myArtifactValues;
    private Cardinality myCardinality;
    [NotNullAttribute]
private PartCatalogType myType;
    private ICollectionEvents`1<object> JetBrains.Build.Running.Storage.IBuildArtifactClass.ArtifactValues { get; }
    private Cardinality JetBrains.Build.Running.Storage.IBuildArtifactClass.Cardinality { get; }
    private Cardinality JetBrains.Build.Running.Storage.IHaveCardinality.Cardinality { get; }
    private PartCatalogType JetBrains.Build.Running.Storage.IBuildEntityOnType.Type { get; }
    public BuildArtifactClass(Lifetime lifetime, PartCatalogType type, Cardinality cardinality);
    private static BuildArtifactClass();
    public virtual string ToString();
    private sealed virtual override ICollectionEvents`1<object> JetBrains.Build.Running.Storage.IBuildArtifactClass.get_ArtifactValues();
    private sealed virtual override Cardinality JetBrains.Build.Running.Storage.IBuildArtifactClass.get_Cardinality();
    private sealed virtual override Cardinality JetBrains.Build.Running.Storage.IHaveCardinality.get_Cardinality();
    private sealed virtual override PartCatalogType JetBrains.Build.Running.Storage.IBuildEntityOnType.get_Type();
}
public class JetBrains.Build.Running.Data.BuildStepInputInfo : BuildStepIoInfo {
    public BuildStepInputInfo(PartCatalogType rawType, PartCatalogType itemType, Cardinality cardinality, BuildStepParameterFlags flags);
    public BuildStepInputInfo(BuildStepIoInfo basicinfo);
}
public class JetBrains.Build.Running.Data.BuildStepIoInfo : object {
    [CompilerGeneratedAttribute]
private Cardinality <Cardinality>k__BackingField;
    public BuildStepParameterFlags Flags;
    public PartCatalogType ItemType;
    public PartCatalogType RawType;
    public Cardinality Cardinality { get; }
    public BuildStepIoInfo(PartCatalogType rawType, PartCatalogType itemType, Cardinality cardinality, BuildStepParameterFlags flags);
    [CompilerGeneratedAttribute]
public sealed virtual Cardinality get_Cardinality();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BuildStepIoInfo other);
    public virtual int GetHashCode();
    public static bool op_Equality(BuildStepIoInfo left, BuildStepIoInfo right);
    public static bool op_Inequality(BuildStepIoInfo left, BuildStepIoInfo right);
    public virtual string ToString();
}
public class JetBrains.Build.Running.Data.BuildStepOutputInfo : BuildStepIoInfo {
    public BuildStepOutputInfo(PartCatalogType rawType, PartCatalogType itemType, Cardinality cardinality, BuildStepParameterFlags flags);
    public BuildStepOutputInfo(BuildStepIoInfo basicinfo);
}
[FlagsAttribute]
public enum JetBrains.Build.Running.Data.BuildStepParameterFlags : Enum {
    public int value__;
    public static BuildStepParameterFlags IsOptional;
    public static BuildStepParameterFlags IsAsync;
}
public class JetBrains.Build.Running.Data.BuildStepRunnableClass : object {
    private PartCatalogType myPartClass;
    private IList`1<BuildStepInputInfo> JetBrains.Build.Running.Storage.IBuildStepRunnable.Inputs { get; }
    private IList`1<BuildStepOutputInfo> JetBrains.Build.Running.Storage.IBuildStepRunnable.Outputs { get; }
    private PartCatalogType JetBrains.Build.Running.Storage.IBuildEntityOnType.Type { get; }
    public BuildStepRunnableClass(PartCatalogType partClass);
    public virtual string ToString();
    private sealed virtual override IList`1<BuildStepInputInfo> JetBrains.Build.Running.Storage.IBuildStepRunnable.get_Inputs();
    private sealed virtual override IList`1<BuildStepOutputInfo> JetBrains.Build.Running.Storage.IBuildStepRunnable.get_Outputs();
    private sealed virtual override Task`1<Object[]> JetBrains.Build.Running.Storage.IBuildStepRunnable.RunAsync(Object[] inputs);
    private sealed virtual override PartCatalogType JetBrains.Build.Running.Storage.IBuildEntityOnType.get_Type();
}
internal class JetBrains.Build.Running.Data.BuildStepRunnableMethod : object {
    private static ILogger Logger;
    private AssignInputDelegate[] myAssignInputs;
    private AssignOutputDelegate[] myAssignOutputs;
    private BuildStepInputInfo[] myInputs;
    private bool myIsReturnValueNeedsSplitting;
    private int myMethodParametersCount;
    private BuildStepOutputInfo[] myOutputs;
    private PartCatalogTypeMember myPartMethod;
    private BuildStepParameterFlags myReturnValueFlags;
    private IList`1<BuildStepInputInfo> JetBrains.Build.Running.Storage.IBuildStepRunnable.Inputs { get; }
    private PartCatalogTypeMember JetBrains.Build.Running.Storage.IBuildEntityOnMember.Member { get; }
    private IList`1<BuildStepOutputInfo> JetBrains.Build.Running.Storage.IBuildStepRunnable.Outputs { get; }
    public BuildStepRunnableMethod(PartCatalogTypeMember partMethod);
    private static BuildStepRunnableMethod();
    public virtual string ToString();
    private static void Ctor_ParseInputTypes(PartCatalogTypeMember partMethod, BuildStepInputInfo[]& inputs, AssignInputDelegate[]& assignInputs, Int32& nMethodParametersCount);
    private static void Ctor_ParseOutputTypes(PartCatalogTypeMember member, BuildStepOutputInfo[]& outputinfos, AssignOutputDelegate[]& outputassigners, BuildStepParameterFlags& returnValueFlags, Boolean& isReturnValueNeedsSplitting);
    private sealed virtual override IList`1<BuildStepInputInfo> JetBrains.Build.Running.Storage.IBuildStepRunnable.get_Inputs();
    private sealed virtual override PartCatalogTypeMember JetBrains.Build.Running.Storage.IBuildEntityOnMember.get_Member();
    private sealed virtual override IList`1<BuildStepOutputInfo> JetBrains.Build.Running.Storage.IBuildStepRunnable.get_Outputs();
    [AsyncStateMachineAttribute("JetBrains.Build.Running.Data.BuildStepRunnableMethod/<JetBrains-Build-Running-Storage-IBuildStepRunnable-RunAsync>d__19")]
private sealed virtual override Task`1<Object[]> JetBrains.Build.Running.Storage.IBuildStepRunnable.RunAsync(Object[] inputs);
    [AsyncStateMachineAttribute("JetBrains.Build.Running.Data.BuildStepRunnableMethod/<RunAsync_SplitCompoundOutputs>d__20")]
[NotNullAttribute]
private Task`1<Object[]> RunAsync_SplitCompoundOutputs(object retval);
}
[BuildArtifactAttribute]
[ValueSerializerAttribute("JetBrains.Build.Helpers.General.BooleanArtifactSerializer`1<JetBrains.Build.Running.DisableParallelBuild>")]
public class JetBrains.Build.Running.DisableParallelBuild : object {
    public bool IsParallelBuildDisabled;
    private bool JetBrains.Build.Helpers.General.IBooleanArtifact.Value { get; }
    public DisableParallelBuild(bool isParallelBuildDisabled);
    public virtual string ToString();
    private sealed virtual override bool JetBrains.Build.Helpers.General.IBooleanArtifact.get_Value();
}
public class JetBrains.Build.Running.EitherBuildRunnerRequest : object {
    [CanBeNullAttribute]
public BuildRunnerCommandString CommandString;
    public Nullable`1<GuestRequestInfo> Guest;
    public IReadOnlyCollection`1<KeyValuePair`2<InputArtifactStringName, string>> InputArtifactStrings;
    [CanBeNullAttribute]
public IBuildRunnerRequest Request;
    [CanBeNullAttribute]
public SerializedValuesResolver EitherFullArtifactResolver { get; }
    [NotNullAttribute]
public IEnumerable`1<KeyValuePair`2<string, string>> EitherStringArtifacts { get; }
    public EitherBuildRunnerRequest(GuestRequestInfo& guest);
    public EitherBuildRunnerRequest(IBuildRunnerRequest request);
    public EitherBuildRunnerRequest(BuildRunnerCommandString commandstring);
    public SerializedValuesResolver get_EitherFullArtifactResolver();
    public IEnumerable`1<KeyValuePair`2<string, string>> get_EitherStringArtifacts();
    public void IfCommandString(Action`1<BuildRunnerCommandString> FWithCommandString);
    public void IfGuestRequest(Action`1<GuestRequestInfo> FWithGuest);
    public void IfRunnerRequest(Action`1<IBuildRunnerRequest> FWithRequest);
    public void Switch(Action`1<IBuildRunnerRequest> FWithRequest, Action`1<BuildRunnerCommandString> FWithCommandString, Action`1<GuestRequestInfo> FWithGuest);
    public void SwitchWriteOp(Action`1<IBuildRunnerRequest> FWithRequest, Action`1<BuildRunnerCommandString> FWithCommandString);
}
public class JetBrains.Build.Running.FillNestedRequestDelegate : MulticastDelegate {
    public FillNestedRequestDelegate(object object, IntPtr method);
    public virtual Task Invoke(Lifetime lifetime, IBuildRunnerRequest requestWithParentInputs);
    public virtual IAsyncResult BeginInvoke(Lifetime lifetime, IBuildRunnerRequest requestWithParentInputs, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
public interface JetBrains.Build.Running.IBuildRunnerRequest {
    [NotNullAttribute]
public IList`1<ImmutableFileItem> BuildScriptBinaries { get; }
    [NotNullAttribute]
public IList`1<AssemblyQualifiedTypeName> BuildScriptBinariesInInputArtifacts { get; }
    [NotNullAttribute]
public IList`1<ImmutableFileItem> BuildScriptSources { get; }
    [NotNullAttribute]
public IList`1<ImmutableFileItem> CustomEngineBinaries { get; }
    public BuildRunnerEngineType EngineChoice { get; public set; }
    [NotNullAttribute]
public SerializedValuesResolver InputArtifacts { get; }
    [NotNullAttribute]
public IDictionary`2<InputArtifactStringName, String[]> InputArtifactStrings { get; }
    [NotNullAttribute]
public IList`1<AssemblyQualifiedTypeName> Objectives { get; }
    [CanBeNullAttribute]
public string StageDisplayName { get; public set; }
    public abstract virtual IList`1<ImmutableFileItem> get_BuildScriptBinaries();
    public abstract virtual IList`1<AssemblyQualifiedTypeName> get_BuildScriptBinariesInInputArtifacts();
    public abstract virtual IList`1<ImmutableFileItem> get_BuildScriptSources();
    public abstract virtual IList`1<ImmutableFileItem> get_CustomEngineBinaries();
    public abstract virtual BuildRunnerEngineType get_EngineChoice();
    public abstract virtual void set_EngineChoice(BuildRunnerEngineType value);
    public abstract virtual SerializedValuesResolver get_InputArtifacts();
    public abstract virtual IDictionary`2<InputArtifactStringName, String[]> get_InputArtifactStrings();
    public abstract virtual IList`1<AssemblyQualifiedTypeName> get_Objectives();
    public abstract virtual string get_StageDisplayName();
    public abstract virtual void set_StageDisplayName(string value);
}
[BuildHelperAttribute]
public interface JetBrains.Build.Running.IBuildTaskHost {
}
public interface JetBrains.Build.Running.IBuiltInBuildEngineExtraction {
    public abstract virtual IReadOnlyCollection`1<ImmutableFileItem> GetBuildEngineFiles();
}
public interface JetBrains.Build.Running.IIsolatedBuildRunners {
    public abstract virtual BuildRunnerSession BeginRunBuildScript(Lifetime lifetime, BuildRunnerRequest request);
}
[BuildArtifactAttribute]
[ValueSerializerAttribute("JetBrains.Build.Helpers.General.BooleanArtifactSerializer`1<JetBrains.Build.Running.IncrementalBuild>")]
public class JetBrains.Build.Running.IncrementalBuild : object {
    public bool IsIncrementalBuildEnabled;
    private bool JetBrains.Build.Helpers.General.IBooleanArtifact.Value { get; }
    public IncrementalBuild(bool isIncrementalBuildEnabled);
    public virtual string ToString();
    private sealed virtual override bool JetBrains.Build.Helpers.General.IBooleanArtifact.get_Value();
}
[BuildHelperAttribute]
public interface JetBrains.Build.Running.INestedBuildRunner {
    [NotNullAttribute]
public abstract virtual Task`1<BuildRunnerResult> RunNestedBuildAsync(Lifetime lifetime, IBuildRunnerRequest request);
    [NotNullAttribute]
public abstract virtual Task`1<BuildRunnerResult> RunNestedBuildInheritedAsync(Lifetime lifetime, InheritFromParentRequest inherit, FillNestedRequestDelegate λFillRequest);
    [NotNullAttribute]
[ObsoleteAttribute("Use RunNestedBuildInheritedAsync as a more general case. Often you also want engine besides the inputs.")]
public abstract virtual Task`1<BuildRunnerResult> RunNestedBuildOnParentInputsAsync(Lifetime lifetime, FillNestedRequestDelegate λFillRequest);
    [NotNullAttribute]
[ObsoleteAttribute("Use the async version wherever possible.")]
public abstract virtual BuildRunnerResult RunNestedBuildSync(Lifetime lifetime, IBuildRunnerRequest request);
}
[FlagsAttribute]
public enum JetBrains.Build.Running.InheritFromParentRequest : Enum {
    public int value__;
    public static InheritFromParentRequest Inputs;
    public static InheritFromParentRequest BuildScript;
    public static InheritFromParentRequest BuildEngine;
    public static InheritFromParentRequest Objectives;
}
public class JetBrains.Build.Running.InputArtifactStringName : object {
    public static string Suffix;
    [NotNullAttribute]
public string FullOrLocalTypeName;
    public bool IsIgnoringNonexistent;
    public InputArtifactStringName(string fullOrLocalTypeName);
    public InputArtifactStringName(string fullOrLocalTypeName, bool isIgnoringNonexistent);
    private static InputArtifactStringName();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(InputArtifactStringName other);
    public virtual int GetHashCode();
    public static bool op_Equality(InputArtifactStringName left, InputArtifactStringName right);
    public static bool op_Inequality(InputArtifactStringName left, InputArtifactStringName right);
    [NotNullAttribute]
public static InputArtifactStringName Parse(string value);
    public virtual string ToString();
    [NotNullAttribute]
public InputArtifactStringName WithDontIgnoreNonexistent();
    [NotNullAttribute]
public InputArtifactStringName WithIgnoreNonexistent();
}
[BuildHelperAttribute]
public interface JetBrains.Build.Running.IRunningIsolatedBuildContext {
    [NotNullAttribute]
public BindArtifactTypeByName BindTypesInEngineContext { get; }
    [NotNullAttribute]
public ITaskHost BuildTaskHost { get; }
    [NotNullAttribute]
public Writer LowLevelBuildLogRecordWriter { get; }
    [NotNullAttribute]
public RealizedAssemblyItemUnificationSlave RealizedAssemblyItemUnificationSlave { get; }
    public abstract virtual BindArtifactTypeByName get_BindTypesInEngineContext();
    public abstract virtual ITaskHost get_BuildTaskHost();
    public abstract virtual Writer get_LowLevelBuildLogRecordWriter();
    public abstract virtual RealizedAssemblyItemUnificationSlave get_RealizedAssemblyItemUnificationSlave();
}
public static class JetBrains.Build.Running.Logic.BuildExecutionPlanner : object {
    public static ILogger Logger;
    private static BuildExecutionPlanner();
    [ObsoleteAttribute("Not used for real planning now, only for logging, switch logging to plan when it stores deps.")]
public static DirectedGraphWithEdges`2<PlannedItem, PlannedItemDependency> AssignDependencies(IList`1<PlannedItem> planneditems, BuildStorageCore storage);
    [ObsoleteAttribute("Use with care. PCTypes might not match src and package representations.")]
public static BuildExecutionPlan Plan(BuildStorage storage, IList`1<PartCatalogType> outputparts);
    public static BuildExecutionPlan Plan(BuildStorage storage, IList`1<BuildEntityPointer> outputparts);
    [NotNullAttribute]
public static BuildExecutionPlan Plan(BuildStorage storage, BuildStorageArtifact[] outputartifacts);
    [NotNullAttribute]
public static BuildExecutionPlan Plan(BuildStorage storage, IList`1<BuildStorageArtifact> outputartifacts);
    [NotNullAttribute]
public static BuildExecutionPlan Plan(BuildStorageCore storage, ICollection`1<IBuildArtifactClass> outputartifacts);
    [NotNullAttribute]
public static DirectedGraphWithEdges`2<PlannedItem, PlannedItemDependency> PlanCore(JetHashSet`1<IBuildEntity> planneds, JetHashSet`1<IBuildArtifactClass> artifactsToKeep, BuildStorageCore storage);
    private static void FindAndDropArtifactErrors(BuildStorageCore storage, JetHashSet`1<IBuildEntity> planneds, JetHashSet`1<IBuildArtifactClass> unresolveds);
    [NotNullAttribute]
private static IList`1<IBuildEntity> FindBestPath(BuildStorageCore storage, IBuildEntity from, IBuildEntity to);
    private static void TakeDependenciesOfOutputs(BuildStorageCore storage, JetHashSet`1<IBuildArtifactClass> unresolveds, JetHashSet`1<IBuildEntity> planneds);
    private static List`1<PlannedItem> TopoSortItems(IDirectedGraph`1<PlannedItem> dependencies);
}
public class JetBrains.Build.Running.Logic.BuildExecutor : object {
    private static Comparer`1<PlannedItem> myComparerByPlannedItemExecutionPriority;
    private ILogger Logger;
    private IUntypedProperty[] myAllProperties;
    private Lifetime myLifetime;
    private LockObject myLockPropertiesChange;
    [CanBeNullAttribute]
private Writer myLowLevelWriter;
    private ReadonlyToken myReatoken;
    [NotNullAttribute]
private ITaskHost myTasker;
    [NotNullAttribute]
public IProperty`1<PlannedItem> ExecutingItem;
    [NotNullAttribute]
public IProperty`1<bool> IsRunning;
    [NotNullAttribute]
public BuildExecutionPlan Plan;
    [NotNullAttribute]
public IProperty`1<int> PlanPosition;
    [NotNullAttribute]
public BuildStorage Storage;
    public BuildExecutor(Lifetime lifetime, BuildStorage storage, BuildExecutionPlan plan, Writer writerLowLevel, ITaskHost tasker, ILogger logger);
    private static BuildExecutor();
    [AsyncStateMachineAttribute("JetBrains.Build.Running.Logic.BuildExecutor/<RunAsync>d__14")]
public Task RunAsync(Parallelism parallelism);
    private sealed virtual override void JetBrains.Build.Running.Logic.IBuildExecutorDrive.AttachDriven(IBuildExecutorDrive driven);
    [AsyncStateMachineAttribute("JetBrains.Build.Running.Logic.BuildExecutor/<ExecuteSingleItemAsync>d__16")]
private static Task ExecuteSingleItemAsync(Lifetime lifetime, PlannedItem item, BuildStorage storage, ITaskHost tasker, ILogger Logger);
    private static int GetPlannedItemExecutionPriority(PlannedItem item);
    private static Object[] ResolveStepInputs(BuildStorage storage, IBuildStepRunnable step, EntityValueRetrievalContext retrctx, ILogger Logger);
    private void RunAsync_ReportExecutingItem(PlannedItem planneditem);
    private void RunAsync_ReportPlanPosition(int nPlannedItem);
    [AsyncStateMachineAttribute("JetBrains.Build.Running.Logic.BuildExecutor/<RunStepAsync>d__21")]
private static Task`1<Object[]> RunStepAsync(IBuildStepRunnable step, Object[] inputvalues, ILogger Logger);
    private sealed virtual override void JetBrains.Build.Running.Logic.IBuildExecutorDrive.SetProperty(PropertyId id, object value);
    [AsyncStateMachineAttribute("JetBrains.Build.Running.Logic.BuildExecutor/<SubmitStepOutputsAsync>d__23")]
private static Task SubmitStepOutputsAsync(BuildStorage storage, IBuildStepRunnable step, Object[] outputvalues, ILogger logger);
}
public static class JetBrains.Build.Running.Logic.BuildTypeSystemHelpers : object {
    public static string FullName_BuildArtifactAttribute;
    public static string FullName_BuildHelperAttribute;
    public static string FullName_BuildStepAttribute;
    public static string FullName_IHideImplementation1;
    public static string FullName_Optional1;
    public static string FullName_Task1;
    internal static ILogger Logger;
    public static MethodInfo MethodCreateImmutableArrayContainerOpenGeneric;
    public static MethodInfo MethodCreateListContainerOpenGeneric;
    public static MethodInfo MethodCreateOptionalOpenGeneric;
    public static MethodInfo MethodCreateTaskOpenGeneric;
    public static String[] PluralContainerNames;
    public static string PropertyOptional1CanBeNullName;
    public static string PropertyTask1ResultName;
    public static Type TypeOf_Optional1;
    public static Type TypeOf_Task1;
    [CanBeNullAttribute]
public static Type TypeOf_AsyncStateMachineBox1;
    private static BuildTypeSystemHelpers();
    [NotNullAttribute]
public static IBuildArtifactClass CreateArtifact(Lifetime lifetime, PartCatalogType partType, Nullable`1<PartCatalogAttribute> attrArtifact, OnError onerror);
    public static IBuildArtifactClass CreateArtifact(Lifetime lifetime);
    [NotNullAttribute]
public static IBuildArtifactClass CreateArtifactFromValue(Lifetime lifetime, TArtifact value);
    public static List`1<IBuildEntity> ExtractFromCatalog(Lifetime lifetime, PartCatalog catalog);
    public static FrugalLocalList`1<PartCatalogType> GetHiddenImplementations(PartCatalogType type);
    [NotNullAttribute]
public static BuildStepInputInfo StepInputFromParameterType(PartCatalogType typeParam);
    [NotNullAttribute]
public static BuildStepOutputInfo StepOutputFromParameterType(PartCatalogType typeParam);
    [ItemNotNullAttribute]
public static FrugalLocalList`1<BuildStepOutputInfo> StepOutputsFromReturnType(PartCatalogType typeParam);
    public static BuildStepParameterFlags TryGetWrapping(StringSource ssGenericTypeDefinition);
    public static BuildStepParameterFlags TryUnwrap(PartCatalogType ctypePossiblyWrapped, PartCatalogType& ctypeUnwrapped);
    public static object WrapWithModifiers(object theValue, BuildStepParameterFlags flags, PartCatalogType pctypeTarget, OnError onerror);
    private static IBuildHelper CreateBuildHelper(Lifetime lifetime, PartCatalogType partType, PartCatalogAttribute attrBuildHelper, ILogger logger);
    private static IBuildStepRunnable CreateBuildStepFromClass(PartCatalogType partType, ILogger logger);
    private static IBuildStepRunnable CreateBuildStepFromMethod(PartCatalogTypeMember partMember, ILogger logger);
    private static ImmutableArray`1<TItem> CreateImmutableArrayContainer(IList`1<object> instances, OnError onerror);
    private static List`1<TItem> CreateListContainer(IList`1<object> instances, OnError onerror);
    private static Optional`1<TItem> CreateOptional(object item, OnError onerror);
    private static Task`1<TItem> CreateTask(object item, OnError onerror);
    [ItemNotNullAttribute]
private static FrugalLocalList`1<TBuildStepIoInfo> StepInputOutputFromParameterType(PartCatalogType typeOriginalRaw, PartCatalogType typeCurrent, BuildStepParameterFlags& flags, bool isTuplesAllowed);
    private static FrugalLocalList`1<TBuildStepIoInfo> StepInputOutputFromParameterType_AfterAllUnwraps(PartCatalogType typeOriginalRaw, PartCatalogType typeAllUnwrapped, Cardinality cardinality, BuildStepParameterFlags flags);
}
public interface JetBrains.Build.Running.Logic.IBuildExecutorDrive {
    public abstract virtual void AttachDriven(IBuildExecutorDrive driven);
    public abstract virtual void SetProperty(PropertyId id, object value);
}
public class JetBrains.Build.Running.Serialization.BindArtifactTypeByName : object {
    private ILogger Logger;
    private Lazy`1<Dictionary`2<StringSource, PartCatalogType>> myCatalogTypesByFullName;
    private BuildStorage myStorage;
    private IEqualityComparer`1<AssemblyQualifiedTypeName> JetBrains.Build.Serialization.IBindTypeByName.Equality { get; }
    public BindArtifactTypeByName(BuildStorage storage, PartCatalog catalog);
    private sealed virtual override Type JetBrains.Build.Serialization.IBindTypeByName.Bind(AssemblyQualifiedTypeName name, OnError onerror);
    private static JetHashSet`1<PartCatalogType> CollectCatalogTypes(PartCatalog catalog);
    private sealed virtual override IEqualityComparer`1<AssemblyQualifiedTypeName> JetBrains.Build.Serialization.IBindTypeByName.get_Equality();
}
[XamlSerializableAttribute]
public class JetBrains.Build.Running.Serialization.Build.DataHelpers.ArtifactProperties : object {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildEntityPointer <BuildEntityPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public string AssemblyName { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public AssemblyQualifiedTypeName AssemblyQualifiedTypeName { get; public set; }
    public BuildEntityPointer BuildEntityPointer { get; public set; }
    public string TypeName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    public AssemblyQualifiedTypeName get_AssemblyQualifiedTypeName();
    public void set_AssemblyQualifiedTypeName(AssemblyQualifiedTypeName value);
    [CompilerGeneratedAttribute]
public BuildEntityPointer get_BuildEntityPointer();
    [CompilerGeneratedAttribute]
public void set_BuildEntityPointer(BuildEntityPointer value);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
}
[BuildArtifactAttribute]
public class JetBrains.Build.Running.Serialization.BuildEngineOrScriptBinaries : object {
    [NotNullAttribute]
public IReadOnlyList`1<ImmutableFileItem> Files;
    public BuildEngineOrScriptBinaries(IEnumerable`1<ImmutableFileItem> files);
    public BuildEngineOrScriptBinaries(IStructuredStorage sstg);
    public static bool IsInStorage(IStructuredStorage sstg);
    private sealed virtual override void JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData(IStructuredStorage sstg);
}
public class JetBrains.Build.Running.Serialization.BuildResultsRoot : object {
    public SerializedValuesResolver Artifacts;
    public BuildResultsRoot(SerializedValuesResolver resolver);
    public BuildResultsRoot(Lifetime lifetime, IStructuredStorage sstg);
    public static bool IsInStorage(IStructuredStorage sstg);
    public static IStructuredStorage OpenStorageWithArtifacts(IStructuredStorage sstg);
    public void Save(IStructuredStorage sstg);
    private sealed virtual override void JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData(IStructuredStorage storage);
}
public static class JetBrains.Build.Running.Serialization.BuildSerialization : object {
    public static string StreamName_ArtifactEntityPointer;
    public static string StreamName_ArtifactProperties;
    private static BuildSerialization();
    public static IBuildArtifactClass ReadArtifact(Lifetime lifetime, IStructuredStorage sstg, BuildStorage bstor, OnError onerror);
    public static IEnumerable`1<IBuildArtifactClass> ReadArtifactsSet(Lifetime lifetime, IStructuredStorage sstg, BuildStorage bstor, OnError onerror);
    [NotNullAttribute]
public static IList`1<Pair`2<IBuildArtifactClass, object>> ReadArtifactValuesRaw(IStructuredStorage sstgArtifactsSet, BuildStorage bstor, Func`2<BuildEntityPointer, bool> FIsReadingArtifact, OnError onerror);
    public static void WriteArtifact(IBuildArtifactClass artifact, IStructuredStorage storage, OnError onerror);
    public static void WriteArtifactsSet(IEnumerable`1<IBuildArtifactClass> artifacts, IStructuredStorage storage, OnError onerror);
    private static BuildEntityPointer ReadArtifact_EntityPointer(IStructuredStorage sstg, OnError onerror);
}
public static class JetBrains.Build.Running.Storage.BuildEntityKinds : object {
    public static Type[] AllKinds;
    [NotNullAttribute]
public static Type Artifact;
    [NotNullAttribute]
public static Type CustomObject;
    [NotNullAttribute]
public static Type Helper;
    [NotNullAttribute]
public static Type Step;
    private static BuildEntityKinds();
}
public class JetBrains.Build.Running.Storage.BuildEntityLifetime : object {
    public static Type TypeofItem;
    private PartCatalogType myLifetimeType;
    private Cardinality JetBrains.Build.Running.Storage.IHaveCardinality.Cardinality { get; }
    private PartCatalogType JetBrains.Build.Running.Storage.IBuildEntityOnType.Type { get; }
    public BuildEntityLifetime(PartCatalogType lifetimetype);
    private static BuildEntityLifetime();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override Cardinality JetBrains.Build.Running.Storage.IHaveCardinality.get_Cardinality();
    private sealed virtual override Object[] JetBrains.Build.Running.Storage.IBuildCustomObject.GetEntityValues(EntityValueRetrievalContext retrctx);
    private sealed virtual override PartCatalogType JetBrains.Build.Running.Storage.IBuildEntityOnType.get_Type();
}
public class JetBrains.Build.Running.Storage.BuildEntityLogger : object {
    public static Type TypeofItem;
    private PartCatalogType myLoggerType;
    private Cardinality JetBrains.Build.Running.Storage.IHaveCardinality.Cardinality { get; }
    private PartCatalogType JetBrains.Build.Running.Storage.IBuildEntityOnType.Type { get; }
    public BuildEntityLogger(PartCatalogType loggertype);
    private static BuildEntityLogger();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override Cardinality JetBrains.Build.Running.Storage.IHaveCardinality.get_Cardinality();
    protected bool Equals(BuildEntityLogger other);
    private sealed virtual override Object[] JetBrains.Build.Running.Storage.IBuildCustomObject.GetEntityValues(EntityValueRetrievalContext retrctx);
    private sealed virtual override PartCatalogType JetBrains.Build.Running.Storage.IBuildEntityOnType.get_Type();
}
[ValueSerializerAttribute("JetBrains.Build.Running.Storage.BuildEntityPointerSerializer")]
[TypeConverterAttribute("JetBrains.Build.Running.Storage.BuildEntityPointerConverter")]
public class JetBrains.Build.Running.Storage.BuildEntityPointer : object {
    private UInt32 myKindIndex;
    [CanBeNullAttribute]
private static Regex myRegexParse;
    [NotNullAttribute]
public string AssemblyShortName;
    [NotNullAttribute]
public string MemberName;
    [NotNullAttribute]
public string TypeFullName;
    [NotNullAttribute]
public Type EntityKind { get; }
    public string LocalName { get; }
    public BuildEntityPointer(Type type, Type kind);
    public BuildEntityPointer(MemberInfo member, Type kind);
    public BuildEntityPointer(PartCatalogType parttype, Type kind);
    public BuildEntityPointer(PartCatalogTypeMember partmember, Type kind);
    public BuildEntityPointer(string assemblyShortName, string typeFullName, string memberName, Type kind);
    public BuildEntityPointer(AssemblyQualifiedTypeName name, Type kind);
    public Type get_EntityKind();
    public string get_LocalName();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BuildEntityPointer other);
    [NotNullAttribute]
public static BuildEntityPointer FromType(Type kind);
    public virtual int GetHashCode();
    public static bool op_Equality(BuildEntityPointer left, BuildEntityPointer right);
    public static bool op_Inequality(BuildEntityPointer left, BuildEntityPointer right);
    public static BuildEntityPointer Parse(string text, OnError onerror);
    public virtual string ToString();
}
public class JetBrains.Build.Running.Storage.BuildEntityPointerConverter : TypeConverterBase`1<BuildEntityPointer> {
}
[ExtensionAttribute]
public static class JetBrains.Build.Running.Storage.BuildEntityPointerEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IBuildEntity ToEntity(BuildEntityPointer thіs, BuildStorage storage);
    [ExtensionAttribute]
public static IBuildEntity ToEntity(BuildEntityPointer thіs, BuildStorage storage, OnError onerror);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBuildEntity ToEntity(BuildEntityPointer thіs, BuildStorageCore storage);
    [ExtensionAttribute]
public static IBuildEntity ToEntity(BuildEntityPointer thіs, BuildStorageCore storage, OnError onerror);
    [ExtensionAttribute]
[NotNullAttribute]
public static BuildEntityPointer ToPointer(IBuildEntity thіs);
    [ExtensionAttribute]
public static BuildEntityPointer ToPointer(IBuildEntity thіs, OnError onerror);
}
public class JetBrains.Build.Running.Storage.BuildEntityPointerSerializer : ValueSerializerBase`1<BuildEntityPointer> {
}
public class JetBrains.Build.Running.Storage.BuildExecutionPlan : object {
    [NotNullAttribute]
public UInt32[] Dependencies;
    [NotNullAttribute]
public IList`1<BuildEntityPointer> Objectives;
    [NotNullAttribute]
public IList`1<PlannedItem> PlannedItems;
    public BuildExecutionPlan(IList`1<PlannedItem> plannedItems, IList`1<BuildEntityPointer> objectives, UInt32[] dependencies);
}
public class JetBrains.Build.Running.Storage.BuildExecutorRunResolveContext : object {
    public BuildExecutorRunResolveContext(Lifetime lifetimeRun, BuildStorage storage);
    [NotNullAttribute]
public IBuildEntityInstanceResolveContext CreateStepResolver(Lifetime lifetimeStep, BuildStorageStep step);
    private sealed virtual override Object[] JetBrains.Build.Running.Storage.IBuildEntityInstanceResolveContext.GetPluralInstances(IBuildEntityOnType entityOnType);
    private sealed virtual override object JetBrains.Build.Running.Storage.IBuildEntityInstanceResolveContext.GetSingleInstance(IBuildEntityOnType entityOnType);
}
internal class JetBrains.Build.Running.Storage.BuildHelper : object {
    private static ILogger Logger;
    private BuildHelperFlags myFlags;
    [NotNullAttribute]
private BuildStepInputInfo[][] myInputs;
    private PartCatalogType myType;
    private BuildHelperFlags JetBrains.Build.Running.Storage.IBuildHelper.Flags { get; }
    private BuildStepInputInfo[][] JetBrains.Build.Running.Storage.IBuildHelper.InputsChoice { get; }
    private PartCatalogType JetBrains.Build.Running.Storage.IBuildEntityOnType.Type { get; }
    public BuildHelper(Lifetime lifetime, PartCatalogType type, BuildHelperFlags flags);
    private static BuildHelper();
    public virtual string ToString();
    private sealed virtual override object JetBrains.Build.Running.Storage.IBuildHelper.CreateInstance(IList`1<BuildStepInputInfo> inputsChosen, Object[] inputvalues);
    private int CreateInstance_ChooseCtor(IList`1<BuildStepInputInfo> inputsChosen);
    private static void Ctor_ParseInputs(PartCatalogType type, BuildStepInputInfo[][]& inputs);
    private sealed virtual override BuildHelperFlags JetBrains.Build.Running.Storage.IBuildHelper.get_Flags();
    private sealed virtual override BuildStepInputInfo[][] JetBrains.Build.Running.Storage.IBuildHelper.get_InputsChoice();
    private sealed virtual override PartCatalogType JetBrains.Build.Running.Storage.IBuildEntityOnType.get_Type();
}
public class JetBrains.Build.Running.Storage.BuildStepResolveContext : object {
    public static ILogger Logger;
    private Lifetime myLifetimeOutsideBody;
    private IBuildEntityInstanceResolveContext myContextRun;
    private Lifetime myLifetimeBuildStepBody;
    public BuildStepResolveContext(Lifetime lifetime, IBuildStepRunnable buildstep, IBuildEntityInstanceResolveContext contextRun);
    private static BuildStepResolveContext();
    private sealed virtual override Object[] JetBrains.Build.Running.Storage.IBuildEntityInstanceResolveContext.GetPluralInstances(IBuildEntityOnType entityOnType);
    private sealed virtual override object JetBrains.Build.Running.Storage.IBuildEntityInstanceResolveContext.GetSingleInstance(IBuildEntityOnType entityOnType);
}
public class JetBrains.Build.Running.Storage.BuildStorage : object {
    private static ILogger Logger;
    private Lifetime myLifetime;
    public BuildStorageCore Core;
    public BuildStorageArtifacts Artifacts { get; }
    public BuildStorageSteps Steps { get; }
    public BuildStorage(Lifetime lifetime);
    private static BuildStorage();
    public BuildStorageArtifacts get_Artifacts();
    public BuildStorageSteps get_Steps();
    [NotNullAttribute]
public static BuildStorage CreateFromCatalog(Lifetime lifetime, PartCatalog catalog);
    public void FillFromCatalog(PartCatalog catalog);
    [NotNullAttribute]
public IBuildEntityOnType ResolveExact(BuildStepIoInfo item);
    [NotNullAttribute]
public IBuildEntityOnType ResolveExact(PartCatalogType type);
}
public class JetBrains.Build.Running.Storage.BuildStorageCore : object {
    public static ILogger Logger;
    private ReadonlyToken myReatoken;
    public ICollectionEvents`1<IBuildEntity> AllEntities;
    public ICollectionEvents`1<IBuildArtifactClass> Artifacts;
    public DirectedGraph`1<IBuildHelper> BuildHelperHides;
    public ICollectionEvents`1<IBuildHelper> BuildHelpers;
    public ICollectionEvents`1<IBuildStepRunnable> BuildSteps;
    public OneToSetMap`2<PartCatalogType, IBuildEntityOnType> CacheEntityByBaseType;
    public OneToSetMap`2<string, IBuildEntity> CacheEntityByLocalName;
    public IDictionary`2<PartCatalogType, IBuildEntityOnType> CacheEntityByType;
    public IDictionary`2<IBuildEntity, IList`1<InputResolved>> CacheInputsResolution;
    public IDictionary`2<IBuildEntity, IList`1<OutputResolved>> CacheOutputsResolution;
    public DirectedGraphWithEdges`2<IBuildEntity, EntityDependency> Dependencies;
    public ConcurrentDictionary`2<IBuildEntity, EntityInstance> EntityInstances;
    public IDictionary`2<BuildEntityPointer, IBuildEntity> PointerToEntity;
    public BuildStorageCore(Lifetime lifetime);
    private static BuildStorageCore();
    public void AddEntities(IList`1<IBuildEntity> entities);
    private void AddEntities_CacheByPointer(ICollection`1<IBuildEntity> entities);
    private void AddEntities_CacheByType(ICollection`1<IBuildEntity> entities);
    private void AddEntities_CrossResolve(ICollection`1<IBuildEntity> entities);
    private void AddEntities_CrossResolve_BuildHelper(IBuildHelper buildhelper);
    private void AddEntities_CrossResolve_BuildStep(IBuildStepRunnable step);
    private IList`1<IBuildEntity> AddEntities_EnsureCustomObjects(IList`1<IBuildEntity> entities);
    private void AddEntities_EnsureDependenciesNode(ICollection`1<IBuildEntity> entities);
    private void AddEntities_Hides(ICollection`1<IBuildEntity> entities);
    private void AddEntities_Submit(ICollection`1<IBuildEntity> entities);
    private static void InitDataFlow_AssertCachedByType(Lifetime lifetime, ICollectionEvents`1<IBuildEntity> allentities, IDictionary`2<PartCatalogType, IBuildEntityOnType> cacheEntityByType);
    private static void InitDataFlow_AssertNoRemove(Lifetime lifetime, ICollectionEvents`1<IBuildEntity> entities);
    private static bool IsGoodInputForBuildHelper(IBuildEntityOnType entityInput, OnError onerror);
}
[ExtensionAttribute]
public static class JetBrains.Build.Running.Storage.BuildStorageEx : object {
    [ExtensionAttribute]
public static TEntity GetEntityByFullOrLocalName(BuildStorageCore thіs, AssemblyQualifiedTypeName name, OnError onerror);
}
public static class JetBrains.Build.Running.Storage.BuildStorageInstances : object {
    public static ILogger Logger;
    private static BuildStorageInstances();
    public static void CreateEntityInstance(BuildStorageCore storage, IBuildEntity entity, OnError onerror);
    public static void DeleteEntityInstance(BuildStorageCore storage, IBuildEntity entity, OnError onerror);
    public static object GetRunningInstance(BuildStorageCore storage, IBuildEntity entity, OnError onerror);
    public static bool HasEntityInstance(BuildStorageCore storage, IBuildEntity entity, OnError onerror);
    public static void SetEntityInstance(Lifetime lifetime, BuildStorageCore storage, IBuildEntity entity, object oInstance, OnError onerror);
    private static void CreateEntityInstance_Helper(BuildStorageCore storage, IBuildHelper helper, OnError onerror);
}
public static class JetBrains.Build.Running.Storage.BuildStorageResolve : object {
    public static ILogger Logger;
    private static ConcurrentStack`1<JetHashSet`1<IBuildEntityOnType>> myWorkingHashsets;
    private static BuildStorageResolve();
    [NotNullAttribute]
public static OverloadResolutionInfo ResolveAssignable(BuildStorageCore storage, BuildStepInputInfo[][] overloads, OnError onerror);
    public static FrugalLocalList`1<IBuildEntityOnType> ResolveAssignable(BuildStorageCore storage, BuildStepInputInfo item, OnError onerror);
    public static FrugalLocalList`1<IBuildEntityOnType> ResolveAssignable(BuildStorageCore storage, PartCatalogType type, OnError onerror);
    public static IBuildEntityOnType ResolveExact(BuildStorageCore storage, BuildStepIoInfo item, OnError onerror);
    public static IBuildEntityOnType ResolveExact(BuildStorageCore storage, PartCatalogType type, OnError onerror);
    private static bool IsResolveAllowed(PartCatalogType typeBeingResolved, IBuildEntityOnType entityCandidate, OnError onerror);
    private static void ReportExceptionOnResolveFailure(PartCatalogType type, OnError onerror);
    private static void ValidateResolvedEntityCardinality(BuildStepIoInfo item, IBuildEntityOnType entity, OnError onerror);
}
public static class JetBrains.Build.Running.Storage.BuildStorageValues : object {
    public static ILogger Logger;
    private static BuildStorageValues();
    [NotNullAttribute]
public static IEnumerable`1<object> GetEntityValues(BuildStorageCore storage, IBuildEntity entity, EntityValueRetrievalContext retrctx, OnError onerror);
    public static Object[] GetValuesForEntityInputs(BuildStorageCore storage, IBuildEntity entity, EntityValueRetrievalContext retrctx, OnError onerror);
    public static object UnwrapValue(object value, BuildStepParameterFlags flags, OnError onerror);
    [AsyncStateMachineAttribute("JetBrains.Build.Running.Storage.BuildStorageValues/<UnwrapValueAsync>d__4")]
[ItemCanBeNullAttribute]
public static Task`1<object> UnwrapValueAsync(object value, BuildStepParameterFlags flags, OnError onerror);
    [CanBeNullAttribute]
private static object GetValuesForEntityInputs_InputPlural(BuildStorageCore storage, int nInput, InputResolved resinput, EntityValueRetrievalContext retrctx, OnError onerror);
    private static object GetValuesForEntityInputs_InputSingle(BuildStorageCore storage, int nInput, InputResolved resinput, EntityValueRetrievalContext retrctx, OnError onerror);
}
public class JetBrains.Build.Running.Storage.DirectedGraphWithEdges`2 : DirectedGraph`1<TNode> {
    private IDictionary`2<Pair`2<TNode, TNode>, TEdge> myMapEdgeData;
    public void AddDependency(TNode from, TNode to, TEdge edgedata);
    public void AddOrUpdateDependency(TNode from, TNode to, TEdge edgedata, Func`3<TEdge, TEdge, TEdge> FCombineOldAndNew);
    public IEnumerable`1<Edge<TNode, TEdge>> IncomingEdges(TNode to);
    public IEnumerable`1<EdgeEnd<TNode, TEdge>> IncomingEnds(TNode to);
    public IEnumerable`1<Edge<TNode, TEdge>> OutgoingEdges(TNode from);
    public IEnumerable`1<EdgeEnd<TNode, TEdge>> OutgoingEnds(TNode from);
    public virtual void RemoveAllIncoming(TNode to);
    public virtual void RemoveDependency(TNode from, TNode to);
    public Nullable`1<Edge<TNode, TEdge>> TryGetEdge(TNode from, TNode to);
    [CanBeNullAttribute]
public TEdge TryGetEdgeData(TNode from, TNode to);
    protected virtual void Clear();
    protected virtual bool RemoveNode(TNode node);
}
public class JetBrains.Build.Running.Storage.EntityValueRetrievalContext : object {
    [NotNullAttribute]
public Func`1<Lifetime> FImportLifetime;
    [NotNullAttribute]
public IBuildEntity ImportingEntity;
    public EntityValueRetrievalContext(Func`1<Lifetime> FImportLifetime, IBuildEntity entityImportingFor);
}
public interface JetBrains.Build.Running.Storage.IBuildArtifactClass {
    [NotNullAttribute]
public ICollectionEvents`1<object> ArtifactValues { get; }
    public Cardinality Cardinality { get; }
    public abstract virtual ICollectionEvents`1<object> get_ArtifactValues();
    public abstract virtual Cardinality get_Cardinality();
}
public interface JetBrains.Build.Running.Storage.IBuildCustomObject {
    [NotNullAttribute]
public abstract virtual Object[] GetEntityValues(EntityValueRetrievalContext retrctx);
}
public interface JetBrains.Build.Running.Storage.IBuildEntity {
}
[ExtensionAttribute]
public static class JetBrains.Build.Running.Storage.IBuildEntityEx : object {
    private static ConcurrentDictionary`2<Type, string> MapKindInterfaceToDisplayName;
    private static ConcurrentDictionary`2<Type, Type> MapObjectTypeToKindInterface;
    private static Func`2<Type, string> myFMapKindInterfaceToDisplayNameCore;
    private static Func`2<Type, Type> myFGetEntityKindInterfaceCore;
    public static IList`1<Type> BuildEntityKindInterfaces;
    private static IBuildEntityEx();
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetEntityKindDisplayName(IBuildEntity entity);
    [NotNullAttribute]
public static string GetEntityKindDisplayName(Type typeEntityKindInterface);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetEntityKindDisplayName(BuildEntityPointer pointer);
    [ExtensionAttribute]
[NotNullAttribute]
public static Type GetEntityKindInterface(IBuildEntity entity);
    [NotNullAttribute]
public static Type GetEntityKindInterface(Type typeOfEntity);
    [ExtensionAttribute]
[NotNullAttribute]
public static Type GetEntityKindInterface(BuildEntityPointer pointer);
    [ExtensionAttribute]
public static EntityKindAndNameString ToKindAndNameString(IBuildEntity entity);
    [ExtensionAttribute]
public static EntityPointerKindAndNameString ToKindAndNameString(BuildEntityPointer pointer);
}
public interface JetBrains.Build.Running.Storage.IBuildEntityInstanceResolveContext {
    [NotNullAttribute]
public abstract virtual Object[] GetPluralInstances(IBuildEntityOnType entityOnType);
    [NotNullAttribute]
public abstract virtual object GetSingleInstance(IBuildEntityOnType entityOnType);
}
public interface JetBrains.Build.Running.Storage.IBuildEntityOnMember {
    public PartCatalogTypeMember Member { get; }
    public abstract virtual PartCatalogTypeMember get_Member();
}
public interface JetBrains.Build.Running.Storage.IBuildEntityOnType {
    public PartCatalogType Type { get; }
    public abstract virtual PartCatalogType get_Type();
}
public interface JetBrains.Build.Running.Storage.IBuildHelper {
    public BuildHelperFlags Flags { get; }
    [NotNullAttribute]
public BuildStepInputInfo[][] InputsChoice { get; }
    public abstract virtual BuildHelperFlags get_Flags();
    public abstract virtual BuildStepInputInfo[][] get_InputsChoice();
    [NotNullAttribute]
public abstract virtual object CreateInstance(IList`1<BuildStepInputInfo> inputsChosen, Object[] inputvalues);
}
public interface JetBrains.Build.Running.Storage.IBuildStepRunnable {
    [NotNullAttribute]
public IList`1<BuildStepInputInfo> Inputs { get; }
    [NotNullAttribute]
public IList`1<BuildStepOutputInfo> Outputs { get; }
    public abstract virtual IList`1<BuildStepInputInfo> get_Inputs();
    public abstract virtual IList`1<BuildStepOutputInfo> get_Outputs();
    [NotNullAttribute]
public abstract virtual Task`1<Object[]> RunAsync(Object[] inputs);
}
public interface JetBrains.Build.Running.Storage.IHaveCardinality {
    public Cardinality Cardinality { get; }
    public abstract virtual Cardinality get_Cardinality();
}
[XamlSerializableAttribute]
[TypeConverterAttribute("JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName/AssemblyQualifiedTypeMemberNameConverter")]
[ValueSerializerAttribute("JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName/AssemblyQualifiedTypeMemberNameSerializer")]
public class JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName : object {
    public static IEqualityComparer`1<AssemblyQualifiedTypeMemberName> EqualityByLooseVersionMatch;
    public static IEqualityComparer`1<AssemblyQualifiedTypeMemberName> EqualityByTypeFullNameOnly;
    [CompilerGeneratedAttribute]
private AssemblyNameInfo <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeFullName>k__BackingField;
    [CanBeNullAttribute]
public AssemblyNameInfo AssemblyName { get; public set; }
    [CanBeNullAttribute]
public string MemberName { get; public set; }
    [CanBeNullAttribute]
public string TypeFullName { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public StringSlice TypeLocalName { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public StringSlice TypeNamespace { get; }
    public AssemblyQualifiedTypeMemberName(IStructuredStorage sstg);
    public AssemblyQualifiedTypeMemberName(string typeFullName, string membername, AssemblyNameInfo assemblyName);
    public AssemblyQualifiedTypeMemberName(PartCatalogueTypeMember member);
    public AssemblyQualifiedTypeMemberName(MemberInfo member);
    public AssemblyQualifiedTypeMemberName(Expression`1<Func`1<object>> expression);
    private static AssemblyQualifiedTypeMemberName();
    [CompilerGeneratedAttribute]
public AssemblyNameInfo get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(AssemblyNameInfo value);
    [CompilerGeneratedAttribute]
public string get_MemberName();
    [CompilerGeneratedAttribute]
public void set_MemberName(string value);
    [CompilerGeneratedAttribute]
public string get_TypeFullName();
    [CompilerGeneratedAttribute]
public void set_TypeFullName(string value);
    public StringSlice get_TypeLocalName();
    public StringSlice get_TypeNamespace();
    [NotNullAttribute]
public AssemblyQualifiedTypeMemberName AsBareAssemblyName();
    [NotNullAttribute]
public static AssemblyQualifiedTypeMemberName Create(Expression`1<Func`2<TType, object>> lambdaexpression);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AssemblyQualifiedTypeMemberName other);
    public sealed virtual bool Equals(MemberInfo other);
    public sealed virtual bool Equals(PartCatalogueTypeMember other);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyQualifiedTypeMemberName left, AssemblyQualifiedTypeMemberName right);
    public static bool op_Inequality(AssemblyQualifiedTypeMemberName left, AssemblyQualifiedTypeMemberName right);
    [NotNullAttribute]
public static AssemblyQualifiedTypeMemberName Parse(string value);
    public virtual string ToString();
    private sealed virtual override int System.IComparable<JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName>.CompareTo(AssemblyQualifiedTypeMemberName other);
    private sealed virtual override void JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData(IStructuredStorage sstg);
    private void Serialize(CsexpArchive ar);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(Stream stream);
    [CompilerGeneratedAttribute]
private void <JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData>b__36_0(CsexpWriter writer);
}
[XamlSerializableAttribute]
[TypeConverterAttribute("JetBrains.Build.Serialization.AssemblyQualifiedTypeName/AssemblyQualifiedTypeNameConverter")]
[ValueSerializerAttribute("JetBrains.Build.Serialization.AssemblyQualifiedTypeName/AssemblyQualifiedTypeNameSerializer")]
public class JetBrains.Build.Serialization.AssemblyQualifiedTypeName : object {
    public static IEqualityComparer`1<AssemblyQualifiedTypeName> EqualityByLooseVersionMatch;
    public static IEqualityComparer`1<AssemblyQualifiedTypeName> EqualityByTypeFullNameOnly;
    [CompilerGeneratedAttribute]
private AssemblyNameInfo <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeFullName>k__BackingField;
    [CanBeNullAttribute]
public AssemblyNameInfo AssemblyName { get; public set; }
    [CanBeNullAttribute]
public string TypeFullName { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public StringSlice TypeLocalName { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public StringSlice TypeNamespace { get; }
    public AssemblyQualifiedTypeName(string typeFullName, AssemblyNameInfo assemblyName);
    public AssemblyQualifiedTypeName(PartCatalogueType type);
    public AssemblyQualifiedTypeName(PartCatalogType type);
    public AssemblyQualifiedTypeName(Type type);
    public AssemblyQualifiedTypeName(IStructuredStorage sstg);
    private static AssemblyQualifiedTypeName();
    [CompilerGeneratedAttribute]
public AssemblyNameInfo get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(AssemblyNameInfo value);
    [CompilerGeneratedAttribute]
public string get_TypeFullName();
    [CompilerGeneratedAttribute]
public void set_TypeFullName(string value);
    public StringSlice get_TypeLocalName();
    public StringSlice get_TypeNamespace();
    [NotNullAttribute]
public AssemblyQualifiedTypeName AsBareAssemblyName();
    [NotNullAttribute]
public static AssemblyQualifiedTypeName Create();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AssemblyQualifiedTypeName other);
    public sealed virtual bool Equals(PartCatalogueType other);
    public bool Equals(PartCatalogType other);
    public sealed virtual bool Equals(Type other);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyQualifiedTypeName left, AssemblyQualifiedTypeName right);
    public static bool op_Inequality(AssemblyQualifiedTypeName left, AssemblyQualifiedTypeName right);
    [NotNullAttribute]
public static AssemblyQualifiedTypeName Parse(string value);
    public void Serialize(CsexpArchive ar);
    [NotNullAttribute]
public PartCatalogueType ToFakePartType();
    [NotNullAttribute]
public PartCatalogueType ToRealPartType(IPartCatalogueFactory partCatalogueFactory);
    [NotNullAttribute]
public PartCatalogType ToRealPartType2(IPartCatalogueFactory partCatalogueFactory);
    [NotNullAttribute]
public Type ToRuntimeType(IBindTypeByName typebinder, OnError onerror);
    public virtual string ToString();
    private sealed virtual override int System.IComparable<JetBrains.Build.Serialization.AssemblyQualifiedTypeName>.CompareTo(AssemblyQualifiedTypeName other);
    private sealed virtual override void JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData(IStructuredStorage sstg);
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_0(Stream stream);
    [CompilerGeneratedAttribute]
private void <JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData>b__38_0(CsexpWriter writer);
}
public class JetBrains.Build.Serialization.BindIntoLoadedAssemblies : object {
    private ILogger Logger;
    private IDictionary`2<AssemblyQualifiedTypeName, Type> myCache;
    private Lazy`1<Dictionary`2<string, Assembly>> myMapLoadedTypesByName;
    private Lazy`1<FileSystemPath> myCachedFqnsPath;
    private Dictionary`2<FileSystemPath, DateTime> myCachedFqnsTimestamp;
    private OneToListMap`2<FileSystemPath, string> myCachedFqns;
    private IEqualityComparer`1<AssemblyQualifiedTypeName> JetBrains.Build.Serialization.IBindTypeByName.Equality { get; }
    private void LoadFqns();
    private void SaveFqns();
    private Type BindCore(AssemblyQualifiedTypeName name, OnError onerror);
    private sealed virtual override IEqualityComparer`1<AssemblyQualifiedTypeName> JetBrains.Build.Serialization.IBindTypeByName.get_Equality();
    private sealed virtual override Type JetBrains.Build.Serialization.IBindTypeByName.Bind(AssemblyQualifiedTypeName name, OnError onerror);
    [CompilerGeneratedAttribute]
private FileSystemPath <.ctor>b__6_0();
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Assembly> <.ctor>b__6_1();
    [CompilerGeneratedAttribute]
private void <SaveFqns>b__8_0(BinaryWriter writer);
}
public class JetBrains.Build.Serialization.BindTypeByName : object {
    public static IBindTypeByName Default;
    private IEqualityComparer`1<AssemblyQualifiedTypeName> JetBrains.Build.Serialization.IBindTypeByName.Equality { get; }
    private static BindTypeByName();
    private sealed virtual override IEqualityComparer`1<AssemblyQualifiedTypeName> JetBrains.Build.Serialization.IBindTypeByName.get_Equality();
    private sealed virtual override Type JetBrains.Build.Serialization.IBindTypeByName.Bind(AssemblyQualifiedTypeName name, OnError onerror);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Build.Serialization.BindTypeByNameEx : object {
    [ExtensionAttribute]
public static Type BindWithTypeFullNameHinting(IBindTypeByName binder, AssemblyQualifiedTypeName typeForBinding, AssemblyQualifiedTypeName typeRedirectBindTo, OnError onerror);
    [ExtensionAttribute]
public static void HintBindingIfApplicable(IBindTypeByName binder, AssemblyQualifiedTypeName redirectFrom, AssemblyQualifiedTypeName redirectTo);
}
public class JetBrains.Build.Serialization.BindTypeByNameHinted : object {
    [CanBeNullAttribute]
private OneToSetMap`2<AssemblyNameInfo, AssemblyNameInfo> myAssemblyNameHints;
    [CanBeNullAttribute]
private IDictionary`2<AssemblyQualifiedTypeName, Type> myCacheBoundTypes;
    private SpinWaitLockRef myLock;
    [CanBeNullAttribute]
private IDictionary`2<AssemblyQualifiedTypeName, AssemblyQualifiedTypeName> myTypeFullNameHints;
    private IEqualityComparer`1<AssemblyQualifiedTypeName> JetBrains.Build.Serialization.IBindTypeByName.Equality { get; }
    public void AddHint(AssemblyQualifiedTypeName redirectFrom, AssemblyQualifiedTypeName redirectTo);
    public void AddHintFromTypeFullName(AssemblyQualifiedTypeName redirectTo);
    private sealed virtual override Type JetBrains.Build.Serialization.IBindTypeByName.Bind(AssemblyQualifiedTypeName name, OnError onerror);
    private sealed virtual override IEqualityComparer`1<AssemblyQualifiedTypeName> JetBrains.Build.Serialization.IBindTypeByName.get_Equality();
    private static bool TryBindExact(AssemblyQualifiedTypeName name, IDictionary`2<AssemblyQualifiedTypeName, Type> cacheBoundTypes, Type& bound);
    [CompilerGeneratedAttribute]
private object <JetBrains.Build.Serialization.IBindTypeByName.Bind>b__6_0();
    [CompilerGeneratedAttribute]
private object <JetBrains.Build.Serialization.IBindTypeByName.Bind>b__6_1();
}
public class JetBrains.Build.Serialization.DataHelpers.InstanceTypeInfo : object {
    private List`1<AssemblyQualifiedTypeName> myBaseTypes;
    private AssemblyQualifiedTypeName myInstanceType;
    [DesignerSerializationVisibilityAttribute("2")]
public List`1<AssemblyQualifiedTypeName> BaseTypes { get; }
    public AssemblyQualifiedTypeName InstanceType { get; public set; }
    public List`1<AssemblyQualifiedTypeName> get_BaseTypes();
    public AssemblyQualifiedTypeName get_InstanceType();
    public void set_InstanceType(AssemblyQualifiedTypeName value);
    public void Serialize(CsexpArchive ar);
}
public interface JetBrains.Build.Serialization.IBindTypeByName {
    [NotNullAttribute]
public IEqualityComparer`1<AssemblyQualifiedTypeName> Equality { get; }
    public abstract virtual IEqualityComparer`1<AssemblyQualifiedTypeName> get_Equality();
    public abstract virtual Type Bind(AssemblyQualifiedTypeName name, OnError onerror);
}
public interface JetBrains.Build.Serialization.ISerializedValuesResolverLoader {
    [NotNullAttribute]
public SerializedValuesResolver Resolver { get; }
    public abstract virtual SerializedValuesResolver get_Resolver();
}
public static class JetBrains.Build.Serialization.MemberwiseSerializationHelper : object {
    public static object Read(IStructuredStorage storage, IBindTypeByName typebinder, OnError onerror);
    public static void Write(IStructuredStorage storage, object value, OnError onerror);
    private static void Read_AssignWritableMembers(Type type, object instance, ConstructorInfo ctorToUse, List`1<PropertyInfo> membersReadonly, List`1<MemberInfo> membersWritable, IDictionary`2<string, object> mapNameToValue, OnError onerror);
    private static ConstructorInfo Read_ChooseCtor(Type type, List`1<PropertyInfo> membersReadonly, List`1<MemberInfo> membersWritable, OnError onerror);
    private static void Read_DeserializeMembers(Type type, IStructuredStorage storage, IDictionary`2<string, MemberInfo> members, IBindTypeByName typebinder, OnError onerror, IDictionary`2& mapNameToValue, IDictionary`2& mapNameToType);
    private static void Read_FindMembers(Type type, IStructuredStorage storage, OnError onerror, IDictionary`2& members, List`1& membersWritable, List`1& membersReadonly);
    private static object Read_InvokeCtor(Type type, ConstructorInfo ctorToUse, List`1<PropertyInfo> membersReadonly, List`1<MemberInfo> membersWritable, IDictionary`2<string, Type> mapNameToType, IDictionary`2<string, object> mapNameToValue, OnError onerror);
    private static Type Read_Type(IStructuredStorage storage, IBindTypeByName typebinder, OnError onerror);
}
public class JetBrains.Build.Serialization.SerializedValuesResolver : object {
    private static ILogger Logger;
    private ICollectionEvents`1<Instance> myInstances;
    private Lifetime myLifetime;
    private OneToSetMap`2<string, Instance> myMapTypeFullNameToExactInstances;
    private OneToSetMap`2<AssemblyQualifiedTypeName, Instance> myMapTypeToAssignableInstances;
    private LocalLazy`2<IValueResolveContext, SerializedValuesResolver> mySelfValueResolveContextChained;
    private LocalLazy`2<IValueResolveContext, SerializedValuesResolver> mySelfValueResolveContextEndpoint;
    private IBindTypeByName myTypeBinder;
    private IValueResolver[] myWrapperResolversCache;
    [NotNullAttribute]
public IReadOnlyCollection`1<Instance> Instances { get; }
    public SerializedValuesResolver(Lifetime lifetime, IEnumerable`1<object> instances, IStructuredStorage storage, IBindTypeByName typebinder);
    private static SerializedValuesResolver();
    public IReadOnlyCollection`1<Instance> get_Instances();
    [NotNullAttribute]
public IComponentContainer AsContainerForChaining();
    public sealed virtual void GetObjectData(IStructuredStorage storage);
    public void LoadFromStorage(Func`2<Lifetime, IStructuredStorage> λStorage);
    public void LoadFromStorage(IStructuredStorage storage);
    [NotNullAttribute]
public SerializedValuesResolver Register(object instance);
    [NotNullAttribute]
private object Resolve(ResolveRequest request, ValueResolveFlags flags);
    [NotNullAttribute]
public TComponent Resolve();
    [NotNullAttribute]
public ICollection`1<TComponent> ResolveMultiple();
    [CanBeNullAttribute]
public ICollection`1<Instance> ResolveMultiple(AssemblyQualifiedTypeName request);
    [NotNullAttribute]
public ICollection`1<TComponent> ResolveMultipleOrEmpty();
    private void LoadFromStorage_V1V2(IStructuredStorage stgRoot);
    private void LoadFromStorage_V3(IStructuredStorage stgRoot, IStructuredStorageStream stmAllInfos);
    private IValueDescriptor ResolveCore(ResolveRequest resolveRequest, ValueResolveFlags flags, RequestRoute route);
    [CanBeNullAttribute]
private IValueDescriptor ResolveCore_Wrappers(ResolveRequest request, ValueResolveFlags flags, RequestRoute route);
    private static void SerializeInstanceTypeInfos(CsexpArchive ar, ICollection`1& instances);
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_0(AddRemoveEventArgs`1<Instance> args);
    [CompilerGeneratedAttribute]
private IEnumerable`1<IValueDescriptor> <ResolveCore_Wrappers>b__25_1(Type request, IValueResolveContext _);
}
public static class JetBrains.Build.Serialization.StringSerializationHelper : object {
    public static object Read(IStructuredStorage sstg, IBindTypeByName typebinder, OnError onerror);
    public static void Write(IStructuredStorage sstg, object value, OnError onerror);
    [CanBeNullAttribute]
private static Type Read_Type(IStructuredStorage storage, IBindTypeByName typebinder, OnError onerror);
}
public static class JetBrains.Build.Serialization.StructuredStorageSerialization : object {
    public static string StorageName_Value;
    public static string StreamName_BinaryFormatter;
    public static string StreamName_StringSerialization;
    public static string StreamName_Type;
    public static string StreamName_XamlSerialization;
    private static StructuredStorageSerialization();
    public static bool IsTypeSerializable(Type type);
    public static bool IsTypeSerializable(PartCatalogType type);
    [NotNullAttribute]
public static IReadOnlyList`1<object> ReadObjectsCollection(IStructuredStorage storage, OnError onerror, IBindTypeByName typebinder);
    [NotNullAttribute]
public static IReadOnlyList`1<TObject> ReadObjectsCollection(IStructuredStorage storage, OnError onerror, IBindTypeByName typebinder);
    public static object ReadObjectValue(AssemblyQualifiedTypeName type, IStructuredStorage storageValue, OnError onerror, IBindTypeByName typebinder);
    public static TInstance ReadObjectValue(IStructuredStorage storageValue, OnError onerror, IBindTypeByName typebinder);
    public static object ReadObjectValue(Type type, IStructuredStorage storageValue, OnError onerror, IBindTypeByName typebinder);
    public static void WriteObjectsCollection(IEnumerable`1<TItem> objects, IStructuredStorage storage, OnError onerror);
    public static void WriteObjectValue(object value, IStructuredStorage storageValue, OnError onerror);
    [NotNullAttribute]
private static IEnumerable`1<ConstructorInfo> SelectCompoundStorageCtors(Type type);
    private static void WriteObjectsCollectionCore(IEnumerable objects, IStructuredStorage storage, OnError onerror);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
