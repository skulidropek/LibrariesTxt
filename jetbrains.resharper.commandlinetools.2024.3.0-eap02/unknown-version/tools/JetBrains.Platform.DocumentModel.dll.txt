[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RdTypeAttribute]
public class JetBrains.DocumentModel.CommandProcessing.BackendUndoableActionRecord : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private RunningDocumentId <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUndo>k__BackingField;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public int Id { get; public set; }
    public RunningDocumentId DocumentId { get; public set; }
    public bool IsUndo { get; public set; }
    public BackendUndoableActionRecord(int Id, RunningDocumentId DocumentId, bool IsUndo);
    [CompilerGeneratedAttribute]
private BackendUndoableActionRecord(BackendUndoableActionRecord original);
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(int value);
    [CompilerGeneratedAttribute]
public sealed virtual RunningDocumentId get_DocumentId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DocumentId(RunningDocumentId value);
    [CompilerGeneratedAttribute]
public bool get_IsUndo();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsUndo(bool value);
    [NullableContextAttribute("0")]
public sealed virtual IUndoableActionRecord Reverse();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(BackendUndoableActionRecord left, BackendUndoableActionRecord right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(BackendUndoableActionRecord left, BackendUndoableActionRecord right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(BackendUndoableActionRecord other);
    [CompilerGeneratedAttribute]
public BackendUndoableActionRecord <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Id, RunningDocumentId& DocumentId, Boolean& IsUndo);
}
[ShellComponentAttribute("0")]
public class JetBrains.DocumentModel.CommandProcessing.DocumentCommandProcessor : object {
    private Lifetime myLifetime;
    private IThreading myThreading;
    [CompilerGeneratedAttribute]
private Signal`1<IUndoableActionRecord> <OnExecuted>k__BackingField;
    [CompilerGeneratedAttribute]
private Signal`1<IAsyncUndoRedo> <OnAsyncUndo>k__BackingField;
    [CompilerGeneratedAttribute]
private ICommandProcessor <CommandProcessor>k__BackingField;
    public Signal`1<IUndoableActionRecord> OnExecuted { get; }
    public Signal`1<IAsyncUndoRedo> OnAsyncUndo { get; }
    public ICommandProcessor CommandProcessor { get; }
    public DocumentCommandProcessor(Lifetime lifetime, ICommandProcessor commandProcessor, IThreading threading);
    [CompilerGeneratedAttribute]
public Signal`1<IUndoableActionRecord> get_OnExecuted();
    [CompilerGeneratedAttribute]
public Signal`1<IAsyncUndoRedo> get_OnAsyncUndo();
    [CompilerGeneratedAttribute]
public ICommandProcessor get_CommandProcessor();
    public virtual void ExecuteFrontendUndoableAction(IUndoableActionRecord actionRecord);
    public virtual void QueueBackendUndoableAction(IDocument document, IAsyncUndoRedo asyncUndoRedo);
}
public static class JetBrains.DocumentModel.DataContext.DocumentModelDataConstants : object {
    [NotNullAttribute]
public static DataConstant`1<IDocument> DOCUMENT;
    [NotNullAttribute]
public static DataConstant`1<DocumentEditorContext> EDITOR_CONTEXT;
    private static DocumentModelDataConstants();
}
[ExtensionAttribute]
public static class JetBrains.DocumentModel.DataContext.DocumentModelDataConstantsExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IDataContext FromDocument(DataContexts th—ñs, Lifetime lifetime, IDocument document);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static Func`3<Lifetime, DataContexts, IDataContext> ToDataContext(IDocument document);
}
public class JetBrains.DocumentModel.DataContext.DocumentModelDataRules : object {
    public DocumentModelDataRules(Lifetime lifetime, DataContexts contexts);
}
public class JetBrains.DocumentModel.DocColumn : ValueType {
}
public class JetBrains.DocumentModel.DocLine : ValueType {
}
public class JetBrains.DocumentModel.DocLineColumnRange : ValueType {
    public DocumentCoords End;
    public DocumentCoords Start;
    public DocLineColumnRange(DocumentCoords start, DocumentCoords end);
    public DocLineColumnRange(DocumentCoords posStartAndEnd);
    public static bool op_Equality(DocLineColumnRange left, DocLineColumnRange right);
    public static bool op_Inequality(DocLineColumnRange left, DocLineColumnRange right);
    public bool Contains(DocumentCoords pos);
    public bool ContainsLine(Int32`1<DocLine> line);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(DocLineColumnRange other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.DocumentModel.DocumentChange : object {
    [CompilerGeneratedAttribute]
private IDocument <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewText>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OldLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ModificationStamp <OldModificationStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private TextModificationSide <ModificationSide>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <OldText>k__BackingField;
    public IDocument Document { get; }
    public int StartOffset { get; }
    public DocumentOffset StartDocumentOffset { get; }
    public string NewText { get; }
    public int OldLength { get; }
    public ModificationStamp OldModificationStamp { get; }
    public TextModificationSide ModificationSide { get; }
    public TextRange NewExtent { get; }
    public DocumentRange NewExtentRange { get; }
    public int NewLength { get; }
    public TextRange OldExtent { get; }
    public DocumentRange OldExtentRange { get; }
    [NullableAttribute("2")]
public string OldText { get; }
    public DocumentChange(IDocument document, int startOffset, int oldLength, string newText, ModificationStamp oldModificationStamp, TextModificationSide modificationSide);
    public DocumentChange(string oldText, IDocument document, int startOffset, string newText, int oldLength, ModificationStamp oldModificationStamp, TextModificationSide modificationSide);
    [CompilerGeneratedAttribute]
public IDocument get_Document();
    [CompilerGeneratedAttribute]
public int get_StartOffset();
    public DocumentOffset get_StartDocumentOffset();
    [CompilerGeneratedAttribute]
public string get_NewText();
    [CompilerGeneratedAttribute]
public int get_OldLength();
    [CompilerGeneratedAttribute]
public ModificationStamp get_OldModificationStamp();
    [CompilerGeneratedAttribute]
public TextModificationSide get_ModificationSide();
    public TextRange get_NewExtent();
    public DocumentRange get_NewExtentRange();
    public int get_NewLength();
    public TextRange get_OldExtent();
    public DocumentRange get_OldExtentRange();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_OldText();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class JetBrains.DocumentModel.DocumentChangeData : ValueType {
    [CompilerGeneratedAttribute]
private int <StartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OldLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NewLength>k__BackingField;
    [CompilerGeneratedAttribute]
private TextModificationSide <ModificationSide>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NewDocumentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ModificationStamp <OldDocumentModificationStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private ModificationStamp <NewDocumentModificationStamp>k__BackingField;
    public int StartOffset { get; public set; }
    public int OldLength { get; public set; }
    public int NewLength { get; public set; }
    public TextModificationSide ModificationSide { get; public set; }
    public int NewDocumentLength { get; public set; }
    public ModificationStamp OldDocumentModificationStamp { get; public set; }
    public ModificationStamp NewDocumentModificationStamp { get; public set; }
    public int OldDocumentLength { get; }
    public DocumentChangeData(int StartOffset, int OldLength, int NewLength, TextModificationSide ModificationSide, int NewDocumentLength, ModificationStamp OldDocumentModificationStamp, ModificationStamp NewDocumentModificationStamp);
    public DocumentChangeData(DocumentChange documentChange, int overrideNewDocumentTextLength);
    [CompilerGeneratedAttribute]
public int get_StartOffset();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StartOffset(int value);
    [CompilerGeneratedAttribute]
public int get_OldLength();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OldLength(int value);
    [CompilerGeneratedAttribute]
public int get_NewLength();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NewLength(int value);
    [CompilerGeneratedAttribute]
public TextModificationSide get_ModificationSide();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ModificationSide(TextModificationSide value);
    [CompilerGeneratedAttribute]
public int get_NewDocumentLength();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NewDocumentLength(int value);
    [CompilerGeneratedAttribute]
public ModificationStamp get_OldDocumentModificationStamp();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OldDocumentModificationStamp(ModificationStamp value);
    [CompilerGeneratedAttribute]
public ModificationStamp get_NewDocumentModificationStamp();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NewDocumentModificationStamp(ModificationStamp value);
    public int get_OldDocumentLength();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocumentChangeData left, DocumentChangeData right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocumentChangeData left, DocumentChangeData right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DocumentChangeData other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& StartOffset, Int32& OldLength, Int32& NewLength, TextModificationSide& ModificationSide, Int32& NewDocumentLength, ModificationStamp& OldDocumentModificationStamp, ModificationStamp& NewDocumentModificationStamp);
}
public class JetBrains.DocumentModel.DocumentChangedEventHandler : MulticastDelegate {
    public DocumentChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EventArgs`1<DocumentChange> args);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs`1<DocumentChange> args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.DocumentModel.DocumentChangesRangeTranslator : object {
    private static ILogger ourLog;
    private static DocumentChangesRangeTranslator();
    public static DRangeTranslator TryCreate(IDocument document, ModificationStamp from, ModificationStamp to, bool throwOnError);
    public static DocumentChangeData ReverseChange(DocumentChangeData c);
}
[IsReadOnlyAttribute]
public class JetBrains.DocumentModel.DocumentCoords : ValueType {
    public static DocumentCoords Empty;
    public static DocumentCoords Invalid;
    [CompilerGeneratedAttribute]
private Int32`1<DocLine> <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32`1<DocColumn> <Column>k__BackingField;
    public Int32`1<DocLine> Line { get; }
    public Int32`1<DocColumn> Column { get; }
    public DocumentCoords(Int32`1<DocLine> line, Int32`1<DocColumn> column);
    private static DocumentCoords();
    public static Nullable`1<DocumentCoords> TryParse(string str);
    public static Nullable`1<DocumentCoords> TryParse(string str, IFormatProvider formatProvider);
    public static DocumentCoords Parse(string str);
    [CompilerGeneratedAttribute]
public Int32`1<DocLine> get_Line();
    [CompilerGeneratedAttribute]
public Int32`1<DocColumn> get_Column();
    public virtual string ToString();
    [NotNullAttribute]
[PureAttribute]
public string ToString(IFormatProvider formatProvider);
    public static int Compare(DocumentCoords left, DocumentCoords right);
    public sealed virtual int CompareTo(DocumentCoords other);
    public static bool op_LessThan(DocumentCoords left, DocumentCoords right);
    public static bool op_LessThanOrEqual(DocumentCoords left, DocumentCoords right);
    public static bool op_GreaterThan(DocumentCoords left, DocumentCoords right);
    public static bool op_GreaterThanOrEqual(DocumentCoords left, DocumentCoords right);
    public sealed virtual bool Equals(DocumentCoords other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DocumentCoords left, DocumentCoords right);
    public static bool op_Inequality(DocumentCoords left, DocumentCoords right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.DocumentModel.DocumentCopyChanged : object {
    [CompilerGeneratedAttribute]
private DocumentChange <DocumentChange>k__BackingField;
    public DocumentChange DocumentChange { get; }
    public DocumentCopyChanged(DocumentChange documentChange);
    [CompilerGeneratedAttribute]
public DocumentChange get_DocumentChange();
}
public class JetBrains.DocumentModel.DocumentEditorContext : object {
    [CompilerGeneratedAttribute]
private DocumentOffset <CaretOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentRange <SelectionRange>k__BackingField;
    public DocumentOffset CaretOffset { get; }
    public DocumentRange SelectionRange { get; }
    public bool HasSelection { get; }
    [NotNullAttribute]
public IDocument Document { get; }
    public DocumentEditorContext(DocumentOffset caretOffset);
    public DocumentEditorContext(DocumentRange selectionRange);
    public DocumentEditorContext(DocumentOffset caretOffset, DocumentRange selectionRange);
    [CompilerGeneratedAttribute]
public DocumentOffset get_CaretOffset();
    [CompilerGeneratedAttribute]
public DocumentRange get_SelectionRange();
    public bool get_HasSelection();
    public IDocument get_Document();
}
[ExtensionAttribute]
public static class JetBrains.DocumentModel.DocumentExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IDocumentPointer ToPointer(IDocument document);
    [ExtensionAttribute]
public static void InsertText(IDocument document, DocumentOffset offset, string text, TextModificationSide modificationSide);
    [ExtensionAttribute]
public static void ReplaceText(IDocument document, DocumentRange atRange, string text);
    [ExtensionAttribute]
public static void DeleteText(IDocument document, DocumentRange fromRange, TextModificationSide modificationSide);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRange GetDocumentRange(IDocument document);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentOffset GetDocumentStartOffset(IDocument document);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentOffset GetDocumentEndOffset(IDocument document);
    [ExtensionAttribute]
public static DocumentOffset GetDocumentOffsetByCoords(IDocument document, DocumentCoords coords);
    [ExtensionAttribute]
public static DocumentOffset GetLineStartDocumentOffset(IDocument document, Int32`1<DocLine> line);
    [ExtensionAttribute]
public static DocumentOffset GetLineEndDocumentOffsetNoLineBreak(IDocument document, Int32`1<DocLine> line);
    [ExtensionAttribute]
public static DocumentOffset GetLineEndDocumentOffsetWithLineBreak(IDocument document, Int32`1<DocLine> line);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRange GetLineDocumentRange(IDocument document, Int32`1<DocLine> line);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRange GetLineDocumentRangeNoLineBreak(IDocument document, Int32`1<DocLine> line);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string GetShortDocumentMoniker(IDocument document);
    [ExtensionAttribute]
public static bool IsSubsetOfFileApproximately(IDocument document, string filePath);
}
public static class JetBrains.DocumentModel.DocumentIndentUtils : object {
    [NotNullAttribute]
public static string GetLineIndent(IDocument document, Int32`1<DocLine> line);
    public static DocumentRange GetIndentRange(IDocument document, Int32`1<DocLine> line, IBuffer documentBuffer);
    public static PopularIndentInfo GetPopularIndentInfo(IDocument document);
    private static bool IsStartOfMultilineComment(IBuffer buffer, int pos);
    private static bool IsEndOfMultilineComment(IBuffer buffer, int pos);
}
[ExtensionAttribute]
public static class JetBrains.DocumentModel.DocumentLineEndings : object {
    [ExtensionAttribute]
public static LineEnding GetFirstLineEnding(IDocument document);
    [ExtensionAttribute]
public static LineEnding GetLineEnding(IDocument document, Int32`1<DocLine> line);
    [ExtensionAttribute]
public static LineEnding GetLineEnding(IDocument document, Int32`1<DocLine> line, IBuffer buffer);
    public static LineEnding GetMostPopularLineEnding(IDocument document);
    private static void ProcessLineEndings(IDocument document, IBuffer buffer, List`1<Pair`2<LineEnding, UInt32>> rating, Int32`1<DocLine> from, Int32`1<DocLine> to);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebugView,nq}")]
public class JetBrains.DocumentModel.DocumentOffset : ValueType {
    [DebuggerBrowsableAttribute("0")]
public static DocumentOffset InvalidOffset;
    [DebuggerBrowsableAttribute("0")]
private int myOffset;
    [DebuggerBrowsableAttribute("0")]
private IDocument myDocument;
    public int Offset { get; }
    public IDocument Document { get; }
    [NotNullAttribute]
[DebuggerBrowsableAttribute("0")]
private string DebugView { get; }
    [NotNullAttribute]
private object Text { get; }
    [DebuggerStepThroughAttribute]
private DocumentOffset(bool unused);
    [DebuggerStepThroughAttribute]
public DocumentOffset(IDocument document, int offset);
    private static DocumentOffset();
    [DebuggerStepThroughAttribute]
public int get_Offset();
    [DebuggerStepThroughAttribute]
public IDocument get_Document();
    private string get_DebugView();
    [PureAttribute]
public bool IsValid();
    public virtual string ToString();
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertValid();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.IEquatable<JetBrains.DocumentModel.DocumentOffset>.Equals(DocumentOffset otherOffset);
    public bool Equals(DocumentOffset& otherOffset);
    public sealed virtual int CompareTo(DocumentOffset other);
    public virtual int GetHashCode();
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static DocumentOffset op_Subtraction(DocumentOffset offset, int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static DocumentOffset op_Addition(DocumentOffset offset, int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static int op_Subtraction(DocumentOffset left, DocumentOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static DocumentOffset op_Addition(DocumentOffset left, DocumentOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static bool op_Equality(DocumentOffset left, DocumentOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static bool op_Inequality(DocumentOffset left, DocumentOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static bool op_GreaterThan(DocumentOffset left, DocumentOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static bool op_LessThan(DocumentOffset left, DocumentOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static bool op_GreaterThanOrEqual(DocumentOffset left, DocumentOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static bool op_LessThanOrEqual(DocumentOffset left, DocumentOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static DocumentOffset Min(DocumentOffset left, DocumentOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static DocumentOffset Max(DocumentOffset left, DocumentOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static DocumentOffset op_Increment(DocumentOffset offset);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static DocumentOffset op_Decrement(DocumentOffset offset);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public DocumentOffset Shift(int delta);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public DocumentRange ExtendRight(int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public DocumentRange ExtendRightTo(DocumentOffset offset);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public DocumentRange ExtendLeft(int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public DocumentRange ExtendLeftTo(DocumentOffset offset);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public bool ContainedIn(DocumentRange& documentRange);
    [PureAttribute]
public DocumentCoords ToDocumentCoords();
    private object get_Text();
}
[ExtensionAttribute]
public static class JetBrains.DocumentModel.DocumentOwnerExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[MustDisposeResourceAttribute]
public static IDisposable EnableDocumentPointerCaching(IDocument document);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebugView,nq}")]
public class JetBrains.DocumentModel.DocumentRange : ValueType {
    [DebuggerBrowsableAttribute("0")]
public static DocumentRange InvalidRange;
    [DebuggerBrowsableAttribute("0")]
private TextRange myTextRange;
    [DebuggerBrowsableAttribute("0")]
private IDocument myDocument;
    public TextRange TextRange { get; }
    public IDocument Document { get; }
    public DocumentOffset StartOffset { get; }
    public DocumentOffset EndOffset { get; }
    [DebuggerBrowsableAttribute("0")]
public int Length { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsEmpty { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsNormalized { get; }
    [NotNullAttribute]
[DebuggerBrowsableAttribute("0")]
private string DebugView { get; }
    [NotNullAttribute]
private object Text { get; }
    [DebuggerStepThroughAttribute]
private DocumentRange(bool unused);
    [DebuggerStepThroughAttribute]
public DocumentRange(IDocument document, int offset);
    [DebuggerStepThroughAttribute]
public DocumentRange(DocumentOffset& documentOffset);
    [DebuggerStepThroughAttribute]
public DocumentRange(DocumentOffset& startOffset, DocumentOffset& endOffset);
    [DebuggerStepThroughAttribute]
public DocumentRange(IDocument document, TextRange textRange);
    private static DocumentRange();
    [DebuggerStepThroughAttribute]
public TextRange get_TextRange();
    [DebuggerStepThroughAttribute]
public IDocument get_Document();
    public DocumentOffset get_StartOffset();
    public DocumentOffset get_EndOffset();
    public int get_Length();
    public bool get_IsEmpty();
    public bool get_IsNormalized();
    private string get_DebugView();
    [PureAttribute]
public bool IsValid();
    public virtual string ToString();
    [PureAttribute]
[NotNullAttribute]
public string GetText();
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertValid();
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertNormalized();
    [PureAttribute]
public DocumentRange Normalized();
    [PureAttribute]
public static DocumentRange FromLength(DocumentOffset& startOffset, int length);
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.IEquatable<JetBrains.DocumentModel.DocumentRange>.Equals(DocumentRange otherRange);
    public bool Equals(DocumentRange& otherRange);
    public virtual int GetHashCode();
    [PureAttribute]
[DebuggerStepThroughAttribute]
public bool ContainedIn(DocumentRange& documentRange);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public bool StrictContainedIn(DocumentRange& documentRange);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public bool Contains(DocumentOffset& documentOffset);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public bool Contains(DocumentRange& documentRange);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public bool IntersectsOrContacts(DocumentRange& documentRange);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public bool StrictIntersects(DocumentRange& documentRange);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public DocumentRange Intersect(DocumentRange& documentRange);
    [PureAttribute]
public int DistanceTo(DocumentOffset offset);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public DocumentRange StartOffsetRange();
    [PureAttribute]
[DebuggerStepThroughAttribute]
public DocumentRange EndOffsetRange();
    [PureAttribute]
[DebuggerStepThroughAttribute]
public DocumentRange Shift(int delta);
    [PureAttribute]
[DebuggerStepThroughAttribute]
[ObsoleteAttribute("Untyped, use overload with parameter of DocumentOffset type")]
public DocumentRange SetStartTo(int offset);
    [PureAttribute]
[DebuggerStepThroughAttribute]
[ObsoleteAttribute("Untyped, use overload with parameter of DocumentOffset type")]
public DocumentRange SetEndTo(int offset);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public DocumentRange SetStartTo(DocumentOffset& offset);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public DocumentRange SetEndTo(DocumentOffset& offset);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public DocumentRange ExtendLeft(int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public DocumentRange ExtendRight(int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public DocumentRange TrimLeft(int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public DocumentRange TrimRight(int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public DocumentRange JoinLeft(DocumentRange& documentRange);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public DocumentRange JoinRight(DocumentRange& documentRange);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public DocumentRange Join(DocumentRange& documentRange);
    public static bool op_Equality(DocumentRange& range1, DocumentRange& range2);
    public static bool op_Inequality(DocumentRange& range1, DocumentRange& range2);
    public void Deconstruct(DocumentOffset& startOffset, DocumentOffset& endOffset);
    private object get_Text();
}
[ExtensionAttribute]
public static class JetBrains.DocumentModel.DocumentRangeExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRange CreateDocumentRange(TextRange textRange, IDocument document);
    [ExtensionAttribute]
[PureAttribute]
public static IBuffer GetBuffer(DocumentRange documentRange);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.DocumentModel.DocumentRangeMarkers : object {
    private WeakCollection`1<IRangeMarker> myAllRangeMarkers;
    private List`1<DocumentChangeData> myDocumentChanges;
    public void AddRangeMarker(IRangeMarker rangeMarker);
    public void RemoveRangeMarker(IRangeMarker rangeMarker);
    public void NotifyDocumentChanged(DocumentChange documentChange);
    public List`1<DocumentChangeData> GetAllChanges();
    public void Invalidate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.DocumentModel.DocumentRangeMarkersEx : object {
    private static Key`1<DocumentRangeMarkers> ourDocumentRangeMarkersKey;
    private static DocumentRangeMarkersEx();
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRangeMarkers GetOrCreateRangeMarkers(IUserDataHolder holder);
    [ExtensionAttribute]
public static void SetRangeMarkers(IUserDataHolder holder, DocumentRangeMarkers rangeMarkers);
}
internal class JetBrains.DocumentModel.DocumentRangeTextView : object {
    [DebuggerBrowsableAttribute("0")]
private DocumentRange myDocumentRange;
    [DebuggerBrowsableAttribute("0")]
private static int MaxLineLength;
    [DebuggerBrowsableAttribute("0")]
private static int MaxContinuousRangeLength;
    [DebuggerBrowsableAttribute("0")]
private static char Ellipsis;
    [DebuggerBrowsableAttribute("0")]
private static char LeftEdgeSymbol;
    [DebuggerBrowsableAttribute("0")]
private static char RightEdgeSymbol;
    [DebuggerBrowsableAttribute("0")]
private static char EdgeSymbol;
    [NotNullAttribute]
[DebuggerBrowsableAttribute("3")]
private DebugLine[] Lines { get; }
    public DocumentRangeTextView(DocumentRange documentRange);
    private DebugLine[] get_Lines();
    private DebugLine PresentLineWithRangeEdge(IDocument document, Int32`1<DocLine> line, char edgeSymbol, DocumentOffset edgeOffset);
    [NotNullAttribute]
private string GetPossiblyTrimmedRangeText(DocumentRange textRange);
    [NotNullAttribute]
private static string MarkRange(string rangeText);
    [NotNullAttribute]
private string GetTrimmedAndEscapedLineText(IDocument document, Int32`1<DocLine> line);
    [NotNullAttribute]
private string GetTrimmedAndEscapedText(DocumentOffset startOffset, DocumentOffset endOffset, bool trimRight, int maxLength);
    [NotNullAttribute]
private string GetEscapedText(DocumentOffset startOffset, DocumentOffset endOffset);
    private static void AppendEscaped(StringBuilder sb, char ch);
    public virtual string ToString();
}
[ShellComponentAttribute("16")]
public class JetBrains.DocumentModel.DocumentSettings : object {
    private Nullable`1<bool> myForceOpenDocumentAfterModification;
    private bool myEnableCancellationOnOpenDocumentForModificationPrompt;
    private bool myShowUiProgressOnLongModifications;
    [NullableContextAttribute("1")]
[PureAttribute]
public bool GetOpenDocumentAfterModification(IContextBoundSettingsStore settingsStore);
    [NullableContextAttribute("1")]
public void SetOpenDocumentAfterModification(IContextBoundSettingsStore settingsStore, bool value);
    [MustDisposeResourceAttribute]
public OpenDocumentCookie WithOpenDocumentAfterModification(bool allowCancellation);
    [MustDisposeResourceAttribute]
public OpenDocumentCookie WithNoOpenDocumentAfterModification();
    [PureAttribute]
public bool CanCancelOpenDocumentsForModificationPrompt();
    [NullableContextAttribute("1")]
[PureAttribute]
public int GetOpenFilesCountWithoutWarningThreshold(IContextBoundSettingsStore settingsStore);
    [PureAttribute]
public bool ShowUiProgressOnLongModifications();
    [MustDisposeResourceAttribute]
public ShowProgressCookie WithUiProgressOnLongModifications();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ShellComponentAttribute("0")]
public class JetBrains.DocumentModel.DocumentSyncMomentStatusManager : object {
    [CompilerGeneratedAttribute]
private ISimpleSignal <OnChanged>k__BackingField;
    public ISimpleSignal OnChanged { get; }
    public virtual bool AreAllDocumentsInSyncMoments();
    public virtual bool IsDocumentInSyncMoment(IDocument document);
    public virtual Nullable`1<ModificationStamp> GetSyncMomentModificationStamp(IDocument document);
    [CompilerGeneratedAttribute]
public ISimpleSignal get_OnChanged();
}
[ExtensionAttribute]
public static class JetBrains.DocumentModel.DocumentSyncMomentStatusManagerEx : object {
    [AsyncStateMachineAttribute("JetBrains.DocumentModel.DocumentSyncMomentStatusManagerEx/<StartBackgroundInterruptableReadWhenDocumentInSyncMoment>d__0`1")]
[ExtensionAttribute]
[NotNullAttribute]
public static Task`1<TValue> StartBackgroundInterruptableReadWhenDocumentInSyncMoment(DocumentSyncMomentStatusManager th—ñs, Lifetime lifetime, IDocument document, IShellLocks locks, Func`1<TValue> F);
}
public class JetBrains.DocumentModel.DRangeTranslator : MulticastDelegate {
    public DRangeTranslator(object object, IntPtr method);
    public virtual TextRange Invoke(TextRange range);
    public virtual IAsyncResult BeginInvoke(TextRange range, AsyncCallback callback, object object);
    public virtual TextRange EndInvoke(IAsyncResult result);
}
[ShellComponentAttribute("10")]
public class JetBrains.DocumentModel.IdeInMemoryDocumentFactory : object {
    private IShellLocks myShellLocks;
    private DocumentChangeManager myDocumentChangeManager;
    [CompilerGeneratedAttribute]
private IDocumentTransactionManager <DummyTransactionManager>k__BackingField;
    protected IDocumentTransactionManager DummyTransactionManager { get; }
    public IdeInMemoryDocumentFactory(IShellLocks locks, DocumentChangeManager documentChangeManager);
    [CompilerGeneratedAttribute]
protected IDocumentTransactionManager get_DummyTransactionManager();
    public virtual IDocument CreateIdeDocumentFromText(Lifetime lifetime, string text, string moniker, Func`2<IDocument, ModificationCookie> ensureWritableHandler);
    public sealed virtual IDocumentPointer CreateDocumentPointer(IDocument document);
    public sealed virtual void EnableDocumentPointerCaching(Lifetime lifetime, IDocument document);
}
[NullableContextAttribute("1")]
public interface JetBrains.DocumentModel.IDocument {
    public string Moniker { get; }
    public IDocumentOwner Owner { get; }
    public IBuffer Buffer { get; }
    [NullableAttribute("2")]
public Encoding Encoding { get; }
    public TextRange DocumentRange { get; }
    public ModificationStamp LastModificationStamp { get; }
    public abstract virtual string get_Moniker();
    public abstract virtual IDocumentOwner get_Owner();
    public abstract virtual IBuffer get_Buffer();
    [NullableContextAttribute("2")]
public abstract virtual Encoding get_Encoding();
    [PureAttribute]
public abstract virtual string GetText();
    [PureAttribute]
public abstract virtual string GetText(TextRange fromRange);
    [PureAttribute]
public abstract virtual int GetTextLength();
    public abstract virtual TextRange get_DocumentRange();
    [NullableContextAttribute("0")]
[PureAttribute]
public abstract virtual int GetLineStartOffset(Int32`1<DocLine> line);
    [NullableContextAttribute("0")]
[PureAttribute]
public abstract virtual int GetLineEndOffsetNoLineBreak(Int32`1<DocLine> line);
    [NullableContextAttribute("0")]
[PureAttribute]
public abstract virtual int GetLineEndOffsetWithLineBreak(Int32`1<DocLine> line);
    [NullableContextAttribute("0")]
public abstract virtual Int32`1<DocColumn> GetLineLength(Int32`1<DocLine> line);
    [NullableContextAttribute("0")]
[PureAttribute]
public abstract virtual Int32`1<DocLine> GetLineCount();
    [NullableContextAttribute("0")]
[PureAttribute]
public abstract virtual string GetLineText(Int32`1<DocLine> lineNumber);
    [ObsoleteAttribute("Use DocumentOffset and JetBrains.DocumentModel.DocumentOffset.ToDocumentCoords")]
[PureAttribute]
public abstract virtual DocumentCoords GetCoordsByOffset(int offset);
    [PureAttribute]
public abstract virtual int GetOffsetByCoords(DocumentCoords coords);
    [ObsoleteAttribute("Use JetBrains.DocumentModel.DocumentExtensions.InsertText")]
public abstract virtual void InsertText(int offset, string text);
    [ObsoleteAttribute("Use JetBrains.DocumentModel.DocumentExtensions.InsertText")]
public abstract virtual void InsertText(int offset, string text, TextModificationSide modificationSide);
    public abstract virtual void ReplaceText(TextRange atRange, string text);
    public abstract virtual void DeleteText(TextRange fromRange);
    public abstract virtual void DeleteText(TextRange fromRange, TextModificationSide modificationSide);
    public abstract virtual ModificationStamp get_LastModificationStamp();
    [ObsoleteAttribute("Document Transaction must be used.")]
[MustDisposeResourceAttribute]
public abstract virtual ModificationCookie EnsureWritable();
    [CompilerGeneratedAttribute]
public abstract virtual void add_DocumentChanged(DocumentChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DocumentChanged(DocumentChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforeDocumentChanged(DocumentChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforeDocumentChanged(DocumentChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforeDocumentCopyChanged(DocumentChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforeDocumentCopyChanged(DocumentChangedEventHandler value);
    [PureAttribute]
public abstract virtual bool ContainsReadOnlyRegions();
    public abstract virtual void MakeReadonly(Lifetime lifetime, TextRange range);
}
[ZoneDefinitionAttribute]
public interface JetBrains.DocumentModel.IDocumentModelZone {
}
[NullableContextAttribute("1")]
public interface JetBrains.DocumentModel.IDocumentOwner {
    [PureAttribute]
public abstract virtual IDocumentPointer CreateDocumentPointer(IDocument document);
    public abstract virtual void EnableDocumentPointerCaching(Lifetime lifetime, IDocument document);
}
[NullableContextAttribute("2")]
public interface JetBrains.DocumentModel.IDocumentPointer {
    public abstract virtual IDocument GetOrCreateDocument();
}
public interface JetBrains.DocumentModel.IFileEncodingProvider {
    [CanBeNullAttribute]
public abstract virtual Encoding GetEncodingForFile(VirtualFileSystemPath filePath);
}
[NullableContextAttribute("1")]
public interface JetBrains.DocumentModel.IIdeInMemoryDocumentFactory {
    public abstract virtual IDocument CreateIdeDocumentFromText(Lifetime lifetime, string text, string moniker, Func`2<IDocument, ModificationCookie> ensureWritableHandler);
}
[NullableContextAttribute("1")]
public interface JetBrains.DocumentModel.IInMemoryDocumentFactory {
    [PureAttribute]
public abstract virtual IDocument CreateSimpleDocumentFromText(string text, string moniker, IDocumentTransactionManager customTransactionManager);
}
internal class JetBrains.DocumentModel.Impl.<IReadTextFromFileCache>F92F7278F300DDCCFA86D2BC5612B0F8AA0DC713BADBA2C7E9442108F402CC35B__ReadTextFromFileWithoutCaching : object {
    [NullableAttribute("1")]
public static IReadTextFromFileCache Instance;
    private static <IReadTextFromFileCache>F92F7278F300DDCCFA86D2BC5612B0F8AA0DC713BADBA2C7E9442108F402CC35B__ReadTextFromFileWithoutCaching();
    [NullableContextAttribute("1")]
public sealed virtual ValueTuple`2<string, Encoding> GetOrCreateFileTextAndEncoding(VirtualFileSystemPath path, Encoding encoding);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.DocumentModel.Impl.DocumentBase : UserDataHolder {
    private DocumentChangeManager myDocumentChangeManager;
    private Func`2<IDocument, ModificationCookie> myEnsureWritableHandler;
    private IEditableBuffer myTextBuffer;
    protected IShellLocks myLocks;
    private static Statistics ourStatistics;
    [CompilerGeneratedAttribute]
private IDocumentOwner <Owner>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private LocalLazy`2<LineIndex, IBuffer> myLineIndex;
    protected bool myIsDocumentChanging;
    protected ModificationStamp myLastModificationStamp;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DocumentChangedEventHandler DocumentChanged;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DocumentChangedEventHandler BeforeDocumentChanged;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DocumentChangedEventHandler BeforeDocumentCopyChanged;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private FrugalLocalLazy`1<List`1<Action>> myActionsToExecuteAfterChange;
    private int myIsExpectingCallbacksFromUnderlyingStore;
    public string Moniker { get; }
    public IDocumentOwner Owner { get; }
    public IBuffer Buffer { get; }
    [NullableAttribute("2")]
public Encoding Encoding { get; public set; }
    public TextRange DocumentRange { get; }
    public ModificationStamp LastModificationStamp { get; public set; }
    public bool IsExpectingCallbacksFromUnderlyingStore { get; }
    protected DocumentBase(IEditableBuffer textBuffer, Func`2<IDocument, ModificationCookie> ensureWritableHandler, IShellLocks locks, DocumentChangeManager documentChangeManager, IDocumentOwner owner);
    private static DocumentBase();
    public abstract virtual string get_Moniker();
    [CompilerGeneratedAttribute]
public sealed virtual IDocumentOwner get_Owner();
    public virtual IBuffer get_Buffer();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Encoding get_Encoding();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    public virtual string GetText();
    public virtual string GetText(TextRange range);
    public virtual int GetTextLength();
    public sealed virtual TextRange get_DocumentRange();
    protected virtual LineIndex GetOrCreateLineIndex();
    [NullableContextAttribute("2")]
public virtual LineIndex TryGetLineIndex();
    [NullableContextAttribute("0")]
public sealed virtual int GetLineStartOffset(Int32`1<DocLine> lineNumber);
    [NullableContextAttribute("0")]
public sealed virtual int GetLineEndOffsetNoLineBreak(Int32`1<DocLine> lineNumber);
    [NullableContextAttribute("0")]
public sealed virtual int GetLineEndOffsetWithLineBreak(Int32`1<DocLine> lineNumber);
    [NullableContextAttribute("0")]
public sealed virtual Int32`1<DocColumn> GetLineLength(Int32`1<DocLine> line);
    [NullableContextAttribute("0")]
public sealed virtual Int32`1<DocLine> GetLineCount();
    [NullableContextAttribute("0")]
public virtual string GetLineText(Int32`1<DocLine> lineNumber);
    public sealed virtual DocumentCoords GetCoordsByOffset(int offset);
    public sealed virtual int GetOffsetByCoords(DocumentCoords coords);
    public sealed virtual void InsertText(int offset, string text);
    public sealed virtual void DeleteText(TextRange fromRange);
    public abstract virtual void InsertText(int offset, string text, TextModificationSide modificationSide);
    public abstract virtual void DeleteText(TextRange fromRange, TextModificationSide modificationSide);
    public abstract virtual void ReplaceText(TextRange atRange, string text);
    public sealed virtual ModificationStamp get_LastModificationStamp();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LastModificationStamp(ModificationStamp value);
    public sealed virtual ModificationCookie EnsureWritable();
    public abstract virtual void ChangeDocument(DocumentChange documentChange, ModificationStamp timestamp);
    public abstract virtual void HandleExternalChange(DocumentChange documentChange, ModificationStamp timestamp);
    protected void ApplyDocumentChangeToTheOwnTextBuffer(DocumentChange documentChange);
    protected virtual void AssertOnDocumentModification();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_DocumentChanged(DocumentChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_DocumentChanged(DocumentChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_BeforeDocumentChanged(DocumentChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_BeforeDocumentChanged(DocumentChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_BeforeDocumentCopyChanged(DocumentChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_BeforeDocumentCopyChanged(DocumentChangedEventHandler value);
    protected void RaiseEventsBeforeChange(DocumentChange change);
    public void RaiseEventsBeforeCopyChange(DocumentChange change);
    protected void RaiseDocumentChangedEvents(DocumentChange change, bool needCopyChangeEvent);
    public void ExecuteAfterDocumentChanged(Action action);
    protected void InvokeActionsToExecuteAfterChange();
    public bool get_IsExpectingCallbacksFromUnderlyingStore();
    public void ExpectCallbacksFromUnderlyingStore(Action action);
    public void ExpectCallbacksFromUnderlyingStore(Lifetime lifetime);
    public abstract virtual bool ContainsReadOnlyRegions();
    public abstract virtual void MakeReadonly(Lifetime lifetime, TextRange range);
    public abstract virtual IRangeMarker CreateRangeMarker(TextRange range);
    public virtual TextRange PlayChanges(TextRange rangeBeforeTransaction, bool isGreedyToLeft, bool isGreedyToRight, bool reallyGreedy);
    public virtual string ToString();
    [UsedImplicitlyAttribute]
internal void Validate();
    [CompilerGeneratedAttribute]
private int <ExpectCallbacksFromUnderlyingStore>b__67_0();
    [CompilerGeneratedAttribute]
private void <ExpectCallbacksFromUnderlyingStore>b__67_1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ShellComponentAttribute("10")]
public class JetBrains.DocumentModel.Impl.DocumentChangeManager : object {
    private ChangeManager myChangeManager;
    public DocumentChangeManager(Lifetime lifetime, ChangeManager changeManager);
    private sealed virtual override object JetBrains.Application.changes.IChangeProvider.Execute(IChangeMap changeMap);
    public void FireDocumentCopyChange(DocumentChange args);
    public void FireDocumentChange(DocumentChange args);
}
public class JetBrains.DocumentModel.Impl.DocumentChangesRecorder : object {
    private List`1<RevertableDocumentChange> myChanges;
    private IDocument myDocument;
    private bool myIsPaused;
    private bool myIsStopped;
    public DocumentChangesRecorder(IDocument document);
    public sealed virtual void Dispose();
    public void Record();
    private void AddDocumentChange(object sender, EventArgs`1<DocumentChange> args);
    public void Stop();
    public void Rewind();
    public void Replay();
    public void Pause();
    public void Resume();
}
[ExtensionAttribute]
public static class JetBrains.DocumentModel.Impl.DocumentUtil : object {
    [NotNullAttribute]
public static string ReadTextFromFile(VirtualFileSystemPath path, bool bFailOnErrors);
    [NotNullAttribute]
public static string ReadTextFromFile(VirtualFileSystemPath path, bool bFailOnErrors, Encoding& encoding, Encoding defaultEncoding);
    public static string ReadTextFromFile(Stream stream, Encoding& detectedEncoding, Encoding defaultEncoding);
    public static void FixDocumentEncoding(IDocument document);
    [ExtensionAttribute]
public static void SetText(IDocument document, string text);
    public static void CommitDiffChanges(IDocument document, IBuffer oldText, IBuffer newText, DocumentRange oldRange, TextRange newRange);
    public static string ReadTextFromFile(VirtualFileSystemPath path, Encoding& detectedEncoding, Encoding defaultEncoding);
    public static string ReadTextImpl(Func`2<Lifetime, Stream> createStream, Encoding& detectedEncoding, Encoding defaultEncoding);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.DocumentModel.Impl.EditableBuffer : object {
    private int myInsertPoint;
    private StringBuilder myInsertBuffer;
    private Char[] myText;
    public int Length { get; }
    public char Item { get; }
    public EditableBuffer(int length);
    public EditableBuffer(string text);
    private void Normalize();
    [NotNullAttribute]
private string GetTextInternal();
    public sealed virtual int get_Length();
    public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual string GetText();
    public sealed virtual void Remove(int offset, int length);
    public sealed virtual void Insert(int offset, string text);
    public sealed virtual void Replace(int offset, int length, string text);
    public sealed virtual void Replace(int offset, int length, BufferRange newText);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
}
[NullableContextAttribute("1")]
public interface JetBrains.DocumentModel.Impl.IReadTextFromFileCache {
    public abstract virtual ValueTuple`2<string, Encoding> GetOrCreateFileTextAndEncoding(VirtualFileSystemPath path, Encoding encoding);
}
public class JetBrains.DocumentModel.Impl.LineIndex : object {
    [NotNullAttribute]
private IBuffer myBuffer;
    [NotNullAttribute]
private List`1<LineSegment> myLineSegments;
    [NotNullAttribute]
public static Char[] EndOfLineChars;
    public Int32`1<DocLine> LineCount { get; }
    public LineIndex(IBuffer buffer);
    private static LineIndex();
    public Int32`1<DocLine> get_LineCount();
    public DocumentCoords GetLineColByOffset(int offset);
    public int GetLineEndOffsetNoLineBreak(Int32`1<DocLine> line);
    public int GetLineEndOffsetWithLineBreak(Int32`1<DocLine> line);
    public int GetLineStartOffset(Int32`1<DocLine> line);
    [NotNullAttribute]
public string GetLineText(Int32`1<DocLine> line);
    public int GetOffsetByCoords(DocumentCoords coords);
    public void UpdateByChange(DocumentChange args);
    [ConditionalAttribute("HARD_DEBUG")]
public void Validate();
    private static Int32`1<DocLine> FindLineByOffset(List`1<LineSegment> segments, int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.DocumentModel.Impl.ManagedDocumentBase : DocumentBase {
    private IDocumentTransactionManager myDocumentTransactionManager;
    public bool IsInTemporaryState { get; }
    public IBuffer Buffer { get; }
    protected ManagedDocumentBase(IDocumentTransactionManager documentTransactionManager, string text, Func`2<IDocument, ModificationCookie> ensureWritableHandler, IShellLocks locks, DocumentChangeManager documentChangeManager, IDocumentOwner owner);
    protected ManagedDocumentBase(IEditableBuffer textBuffer, IDocumentTransactionManager documentTransactionManager, Func`2<IDocument, ModificationCookie> ensureWritableHandler, IShellLocks locks, DocumentChangeManager documentChangeManager, IDocumentOwner owner);
    [NullableContextAttribute("2")]
private DocumentTransaction GetCurrentTransaction();
    public bool get_IsInTemporaryState();
    public sealed virtual IBuffer get_Buffer();
    protected virtual LineIndex GetOrCreateLineIndex();
    [NullableContextAttribute("2")]
public virtual LineIndex TryGetLineIndex();
    public virtual void InsertText(int offset, string text, TextModificationSide modificationSide);
    public virtual void ReplaceText(TextRange atRange, string text);
    public virtual void DeleteText(TextRange fromRange, TextModificationSide modificationSide);
    public virtual void ChangeDocument(DocumentChange documentChange, ModificationStamp timestamp);
    public virtual void HandleExternalChange(DocumentChange documentChange, ModificationStamp timestamp);
    protected virtual void ApplyInternalDocumentChange(DocumentChange documentChange, ModificationStamp timestamp);
    public void HandleInternalDocumentChange(DocumentChange documentChange, ModificationStamp timestamp);
    public virtual IRangeMarker CreateRangeMarker(TextRange range);
    public virtual TextRange PlayChanges(TextRange rangeBeforeTransaction, bool isGreedyToLeft, bool isGreedyToRight, bool reallyGreedy);
}
public class JetBrains.DocumentModel.Impl.ReadTextFromFileCache : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ValueTuple`2<VirtualFileSystemPath, Encoding>, ValueTuple`2<string, Encoding>> myCache;
    [NullableAttribute("2")]
private static ReadTextFromFileCache ourCache;
    [NullableContextAttribute("1")]
public sealed virtual ValueTuple`2<string, Encoding> GetOrCreateFileTextAndEncoding(VirtualFileSystemPath path, Encoding encoding);
    [NullableContextAttribute("1")]
[PureAttribute]
public static IReadTextFromFileCache GetCache();
    public static void EnableCaching(Lifetime lifetime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ShellComponentAttribute("0")]
public class JetBrains.DocumentModel.InMemoryDocumentFactory : object {
    [CompilerGeneratedAttribute]
private DocumentChangeManager <documentChangeManager>P;
    private IShellLocks myShellLocks;
    [CompilerGeneratedAttribute]
private IDocumentTransactionManager <DummyTransactionManager>k__BackingField;
    private IDocumentTransactionManager DummyTransactionManager { get; }
    public InMemoryDocumentFactory(IShellLocks locks, DocumentChangeManager documentChangeManager);
    [CompilerGeneratedAttribute]
private IDocumentTransactionManager get_DummyTransactionManager();
    public sealed virtual IDocument CreateSimpleDocumentFromText(string text, string moniker, IDocumentTransactionManager customTransactionManager);
    public sealed virtual IDocumentPointer CreateDocumentPointer(IDocument document);
    public sealed virtual void EnableDocumentPointerCaching(Lifetime lifetime, IDocument document);
}
[ExtensionAttribute]
public static class JetBrains.DocumentModel.InMemoryDocumentFactoryEx : object {
    [ExtensionAttribute]
public static IDocument CreateSimpleDocumentFromFile(IInMemoryDocumentFactory documentFactory, VirtualFileSystemPath path);
    [ExtensionAttribute]
public static IDocument CreateSimpleDocumentFromFileSafe(IInMemoryDocumentFactory documentFactory, VirtualFileSystemPath path, Func`2<IDocument, ModificationCookie> ensureWritableHandler);
    [ExtensionAttribute]
public static IDocument CreateSimpleDocumentFromStream(IInMemoryDocumentFactory documentFactory, Stream stream, string moniker);
}
[NullableContextAttribute("1")]
public interface JetBrains.DocumentModel.IRangeMarker {
    public TextRange Range { get; }
    public DocumentRange DocumentRange { get; }
    public IDocument Document { get; }
    public bool IsValid { get; public set; }
    public bool IsGreedyToLeft { get; public set; }
    public bool IsGreedyToRight { get; public set; }
    public bool ReallyGreedy { get; public set; }
    public IDocumentPointer DocumentPointer { get; }
    public abstract virtual TextRange get_Range();
    public abstract virtual DocumentRange get_DocumentRange();
    public abstract virtual IDocument get_Document();
    public abstract virtual bool get_IsValid();
    public abstract virtual void set_IsValid(bool value);
    public abstract virtual bool get_IsGreedyToLeft();
    public abstract virtual void set_IsGreedyToLeft(bool value);
    public abstract virtual bool get_IsGreedyToRight();
    public abstract virtual void set_IsGreedyToRight(bool value);
    public abstract virtual bool get_ReallyGreedy();
    public abstract virtual void set_ReallyGreedy(bool value);
    public abstract virtual IDocumentPointer get_DocumentPointer();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changed(EventHandler`1<RangeMarkerChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changed(EventHandler`1<RangeMarkerChangedEventArgs> value);
}
public interface JetBrains.DocumentModel.IRangeMarkerTipProvider {
    public abstract virtual string GetTipText(IRangeMarker marker);
}
[DerivedComponentsInstantiationRequirementAttribute("1")]
public interface JetBrains.DocumentModel.IRunningDocuments {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ICollectionEvents`1<ValueTuple`2<IDocument, RunningDocumentId>> DocumentsWithIds { get; }
    public abstract virtual RunningDocumentId LockDocument(IDocument document, string documentOwner);
    public abstract virtual void UnlockDocument(RunningDocumentId documentId, string documentOwner);
    [CanBeNullAttribute]
public abstract virtual IDocument TryFindRunningDocument(RunningDocumentId documentId);
    public abstract virtual RunningDocumentId TryGetRunningDocumentId(IDocument document);
    public abstract virtual ICollectionEvents`1<ValueTuple`2<IDocument, RunningDocumentId>> get_DocumentsWithIds();
}
[NullableContextAttribute("1")]
public interface JetBrains.DocumentModel.IUndoableActionRecord {
    public RunningDocumentId DocumentId { get; }
    public abstract virtual RunningDocumentId get_DocumentId();
    public abstract virtual IUndoableActionRecord Reverse();
}
[SettingsKeyAttribute("JetBrains.Application.Settings.WellKnownRootKeys.EnvironmentSettings", "JetBrains.DocumentModel.Resources.Strings", "DocumentSettingsSettingDescription")]
public class JetBrains.DocumentModel.OpenDocumentSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.DocumentModel.Resources.Strings", "DoOpenDocumentAfterModificationSettingDescription")]
public bool OpenDocumentAfterModification;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.DocumentModel.Resources.Strings", "ShowWarningIfTheProductIsAboutToOpenTooManyFilesAfterModificationSettingDescription")]
public int OpenFilesCountWithoutWarningThreshold;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.DocumentModel.Resources.Strings", "OpenNewFilesInPreviewTabFromEverywhereSettingDescription")]
public bool OpenProvisionTabByDefault;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.DocumentModel.RangeMarker : object {
    protected TextRange myRangeBeforeTransaction;
    protected ModificationStamp myDocumentTimestamp;
    protected Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myIsValid;
    protected object myUpdateLockObject;
    [CompilerGeneratedAttribute]
private IDocumentPointer <DocumentPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGreedyToLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGreedyToRight>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReallyGreedy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLiveUpdatable>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<RangeMarkerChangedEventArgs> ChangedImpl;
    public static IRangeMarker InvalidMarker;
    public IDocumentPointer DocumentPointer { get; }
    public bool IsGreedyToLeft { get; public set; }
    public bool IsGreedyToRight { get; public set; }
    public bool ReallyGreedy { get; public set; }
    protected internal bool IsLiveUpdatable { get; protected set; }
    public TextRange Range { get; }
    public DocumentRange DocumentRange { get; }
    public IDocument Document { get; }
    public bool IsValid { get; public set; }
    public RangeMarker(IDocument document, TextRange range);
    private static RangeMarker();
    [CompilerGeneratedAttribute]
public sealed virtual IDocumentPointer get_DocumentPointer();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsGreedyToLeft();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsGreedyToLeft(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsGreedyToRight();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsGreedyToRight(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ReallyGreedy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReallyGreedy(bool value);
    [CompilerGeneratedAttribute]
protected internal bool get_IsLiveUpdatable();
    [CompilerGeneratedAttribute]
protected void set_IsLiveUpdatable(bool value);
    public sealed virtual void add_Changed(EventHandler`1<RangeMarkerChangedEventArgs> value);
    public sealed virtual void remove_Changed(EventHandler`1<RangeMarkerChangedEventArgs> value);
    [CompilerGeneratedAttribute]
private void add_ChangedImpl(EventHandler`1<RangeMarkerChangedEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove_ChangedImpl(EventHandler`1<RangeMarkerChangedEventArgs> value);
    public virtual TextRange get_Range();
    public sealed virtual DocumentRange get_DocumentRange();
    public sealed virtual IDocument get_Document();
    protected virtual void UpdateRangeToCurrentDocumentTimestamp(IDocument document);
    public virtual bool get_IsValid();
    public virtual void set_IsValid(bool value);
    protected void NotifyDocumentChangedNoFire(DocumentChangeData e);
    public virtual void NotifyDocumentChanged(DocumentChangeData documentChangeData);
    [NullableContextAttribute("2")]
public bool Equals(RangeMarker other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.DocumentModel.RangeMarkerChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private TextRange <OldRange>k__BackingField;
    public TextRange OldRange { get; }
    public RangeMarkerChangedEventArgs(TextRange oldRange);
    [CompilerGeneratedAttribute]
public TextRange get_OldRange();
}
[ExtensionAttribute]
public static class JetBrains.DocumentModel.RangeMarkerExtentions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[MustUseReturnValueAttribute]
public static IRangeMarker CreateRangeMarker(DocumentRange documentRange);
    [ExtensionAttribute]
[NotNullAttribute]
[MustUseReturnValueAttribute]
public static IRangeMarker CreateRangeMarker(DocumentOffset documentOffset);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
private static IRangeMarker CreateRangeMarkerImpl(DocumentRange documentRange);
    [ExtensionAttribute]
[NotNullAttribute]
[MustUseReturnValueAttribute]
public static IRangeMarker CreateRangeMarker(TextRange textRange, IDocument document);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetText(IRangeMarker rangeMarker);
    [ExtensionAttribute]
public static void ReplaceText(IRangeMarker rangeMarker, string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ShellComponentAttribute("10")]
public class JetBrains.DocumentModel.RangeMarkersManager : object {
    private DocumentChangeManager myDocumentChangeManager;
    private IShellLocks myLocks;
    public RangeMarkersManager(Lifetime lifetime, IShellLocks locks, DocumentChangeManager documentChangeManager, ChangeManager changeManager);
    private sealed virtual override object JetBrains.Application.changes.IChangeProvider.Execute(IChangeMap changeMap);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.DocumentModel.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string DocumentSettingsSettingDescription { get; }
    public static string DoOpenDocumentAfterModificationSettingDescription { get; }
    public static string OpenNewFilesInPreviewTabFromEverywhereSettingDescription { get; }
    public static string ShowWarningIfTheProductIsAboutToOpenTooManyFilesAfterModificationSettingDescription { get; }
    public static string ApplyingSourceCodeChanges_Text { get; }
    public static string File___Text { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get_DocumentSettingsSettingDescription();
    public static string get_DoOpenDocumentAfterModificationSettingDescription();
    public static string get_OpenNewFilesInPreviewTabFromEverywhereSettingDescription();
    public static string get_ShowWarningIfTheProductIsAboutToOpenTooManyFilesAfterModificationSettingDescription();
    public static string get_ApplyingSourceCodeChanges_Text();
    public static string get_File___Text();
}
public class JetBrains.DocumentModel.RunningDocumentId : ValueType {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    public static RunningDocumentId Invalid;
    public int Id { get; }
    public RunningDocumentId(int id);
    private static RunningDocumentId();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Id();
    public bool IsInvalid();
    public bool IsValid();
    public bool Equals(RunningDocumentId other);
    public static bool op_Equality(Nullable`1<RunningDocumentId> x, Nullable`1<RunningDocumentId> y);
    public static bool op_Inequality(Nullable`1<RunningDocumentId> x, Nullable`1<RunningDocumentId> y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ShellComponentAttribute("16")]
public class JetBrains.DocumentModel.RunningDocuments : object {
    private IShellLocks myLocks;
    private ILogger myLogger;
    private object myLockObject;
    private Dictionary`2<RunningDocumentId, IDocument> myIdsToDocuments;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<IDocument, ValueTuple`2<RunningDocumentId, HashSet`1<string>>> myRunningDocuments;
    private int myLastDocumentId;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ICollectionEvents`1<ValueTuple`2<IDocument, RunningDocumentId>> <DocumentsWithIds>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ICollectionEvents`1<ValueTuple`2<IDocument, RunningDocumentId>> DocumentsWithIds { get; }
    public RunningDocuments(Lifetime lifetime, IShellLocks locks, ILogger logger);
    [CompilerGeneratedAttribute]
public sealed virtual ICollectionEvents`1<ValueTuple`2<IDocument, RunningDocumentId>> get_DocumentsWithIds();
    public sealed virtual IDocument TryFindRunningDocument(RunningDocumentId documentId);
    public sealed virtual RunningDocumentId TryGetRunningDocumentId(IDocument document);
    public sealed virtual RunningDocumentId LockDocument(IDocument document, string documentOwner);
    public sealed virtual void UnlockDocument(RunningDocumentId documentId, string documentOwner);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0();
}
[ExtensionAttribute]
public static class JetBrains.DocumentModel.RunningDocumentsEx : object {
    [ExtensionAttribute]
public static T ExecuteWithDocumentId(IDocument document, IRunningDocuments runningDocuments, string name, Func`2<RunningDocumentId, T> action);
    [ExtensionAttribute]
public static void ExecuteWithDocumentId(IDocument document, IRunningDocuments runningDocuments, string name, Action`1<RunningDocumentId> action);
    [ExtensionAttribute]
public static RunningDocumentId LockDocument(IDocument document, Lifetime lifetime, IRunningDocuments runningDocuments, string name, IShellLocks locks);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JetBrains.DocumentModel.SimpleDocumentPointer : object {
    [CompilerGeneratedAttribute]
private IDocument <document>P;
    [NullableAttribute("1")]
public static IDocumentPointer InvalidPointer;
    public SimpleDocumentPointer(IDocument document);
    private static SimpleDocumentPointer();
    public sealed virtual IDocument GetOrCreateDocument();
}
[ExtensionAttribute]
public static class JetBrains.DocumentModel.SimpleTextDiffEx : object {
    [ExtensionAttribute]
public static DocumentChange ToDocumentChange(SimpleTextDiff diff, IDocument document, IBuffer actualBuffer, List`1<string> parsedBufferLines);
    private static int GetLineStartOffset(IReadOnlyList`1<string> documentLines, int lineIndex);
}
public class JetBrains.DocumentModel.StandaloneDocument : ManagedDocumentBase {
    [CompilerGeneratedAttribute]
private string <Moniker>k__BackingField;
    public string Moniker { get; }
    public StandaloneDocument(IDocumentTransactionManager documentTransactionManager, string text, string moniker, Func`2<IDocument, ModificationCookie> ensureWritableHandler, IShellLocks locks, DocumentChangeManager documentChangeManager, IDocumentOwner owner);
    public virtual bool ContainsReadOnlyRegions();
    public virtual void MakeReadonly(Lifetime lifetime, TextRange range);
    [CompilerGeneratedAttribute]
public virtual string get_Moniker();
}
public class JetBrains.DocumentModel.Storage.BeforeDocumentReloadedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IDocument <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskExecutor <TaskExecutor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConflictWithPersistentVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCanceled>k__BackingField;
    [NotNullAttribute]
public IDocument Document { get; }
    public ITaskExecutor TaskExecutor { get; public set; }
    public bool IsConflictWithPersistentVersion { get; }
    public bool IsCanceled { get; private set; }
    public BeforeDocumentReloadedEventArgs(IDocument document, bool isConflictWithPersistentVersion);
    [CompilerGeneratedAttribute]
public IDocument get_Document();
    [CompilerGeneratedAttribute]
public ITaskExecutor get_TaskExecutor();
    [CompilerGeneratedAttribute]
public void set_TaskExecutor(ITaskExecutor value);
    [CompilerGeneratedAttribute]
public bool get_IsConflictWithPersistentVersion();
    public void Cancel();
    [CompilerGeneratedAttribute]
public bool get_IsCanceled();
    [CompilerGeneratedAttribute]
private void set_IsCanceled(bool value);
}
public class JetBrains.DocumentModel.Storage.BeforeDocumentSavedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IDocument <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConflictWithPersistentVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCanceled>k__BackingField;
    [NotNullAttribute]
public IDocument Document { get; }
    public bool IsConflictWithPersistentVersion { get; }
    public bool IsCanceled { get; private set; }
    public BeforeDocumentSavedEventArgs(IDocument document, bool isConflictWithPersistentVersion);
    [CompilerGeneratedAttribute]
public IDocument get_Document();
    [CompilerGeneratedAttribute]
public bool get_IsConflictWithPersistentVersion();
    public void Cancel();
    [CompilerGeneratedAttribute]
public bool get_IsCanceled();
    [CompilerGeneratedAttribute]
private void set_IsCanceled(bool value);
}
public class JetBrains.DocumentModel.Storage.DocumentSavedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IDocument <Document>k__BackingField;
    public IDocument Document { get; }
    public DocumentSavedEventArgs(IDocument document);
    [CompilerGeneratedAttribute]
public IDocument get_Document();
}
public class JetBrains.DocumentModel.Storage.EmptyDocumentStorageHelpers : object {
    [NotNullAttribute]
public static IDocumentStorageHelpers Default;
    [CompilerGeneratedAttribute]
private ISignal`1<DocumentSavedEventArgs> <JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.AfterDocumentSaved>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignal`1<UnknownDocumentSavedEventArgs> <JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.AfterUnknownDocumentSaved>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignal`1<BeforeDocumentSavedEventArgs> <JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.BeforeDocumentSaved>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignal`1<BeforeDocumentReloadedEventArgs> <JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.BeforeDocumentReloaded>k__BackingField;
    private ISignal`1<DocumentSavedEventArgs> JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.AfterDocumentSaved { get; }
    private ISignal`1<UnknownDocumentSavedEventArgs> JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.AfterUnknownDocumentSaved { get; }
    private ISignal`1<BeforeDocumentSavedEventArgs> JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.BeforeDocumentSaved { get; }
    private ISignal`1<BeforeDocumentReloadedEventArgs> JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.BeforeDocumentReloaded { get; }
    private static EmptyDocumentStorageHelpers();
    private sealed virtual override void JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.SaveDocument(IDocument document);
    private sealed virtual override IEnumerable`1<IDocument> JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.GetUnsavedDocuments();
    private sealed virtual override bool JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.IsDocumentUnsaved(IDocument document);
    private sealed virtual override void JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.SaveAllDocuments();
    [CompilerGeneratedAttribute]
private sealed virtual override ISignal`1<DocumentSavedEventArgs> JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.get_AfterDocumentSaved();
    [CompilerGeneratedAttribute]
private sealed virtual override ISignal`1<UnknownDocumentSavedEventArgs> JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.get_AfterUnknownDocumentSaved();
    [CompilerGeneratedAttribute]
private sealed virtual override ISignal`1<BeforeDocumentSavedEventArgs> JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.get_BeforeDocumentSaved();
    [CompilerGeneratedAttribute]
private sealed virtual override ISignal`1<BeforeDocumentReloadedEventArgs> JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.get_BeforeDocumentReloaded();
    private sealed virtual override void JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.SaveDocumentAfterModification(IDocument document, bool forceSaveOpenDocuments);
    private sealed virtual override void JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.CommitFileSystemTrackerChanges(IDocument document);
    private sealed virtual override void JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.MarkReconciledWithExternalVersion(IDocument document, string onlyIfTextOnDiskEquals);
    private sealed virtual override void JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.SynchronizeDocumentContentsWithStorage(IDocument document, VirtualFileSystemPath documentPath);
    private sealed virtual override void JetBrains.DocumentModel.Storage.IDocumentStorageHelpers.SynchronizeDocumentContentsWithDiskFile(IDocument document, VirtualFileSystemPath location);
}
public interface JetBrains.DocumentModel.Storage.IDocumentStorageHelpers {
    public ISignal`1<DocumentSavedEventArgs> AfterDocumentSaved { get; }
    public ISignal`1<UnknownDocumentSavedEventArgs> AfterUnknownDocumentSaved { get; }
    public ISignal`1<BeforeDocumentSavedEventArgs> BeforeDocumentSaved { get; }
    public ISignal`1<BeforeDocumentReloadedEventArgs> BeforeDocumentReloaded { get; }
    public abstract virtual void SaveDocument(IDocument document);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IDocument> GetUnsavedDocuments();
    public abstract virtual bool IsDocumentUnsaved(IDocument document);
    public abstract virtual void SaveAllDocuments();
    public abstract virtual ISignal`1<DocumentSavedEventArgs> get_AfterDocumentSaved();
    public abstract virtual ISignal`1<UnknownDocumentSavedEventArgs> get_AfterUnknownDocumentSaved();
    public abstract virtual ISignal`1<BeforeDocumentSavedEventArgs> get_BeforeDocumentSaved();
    public abstract virtual ISignal`1<BeforeDocumentReloadedEventArgs> get_BeforeDocumentReloaded();
    public abstract virtual void SaveDocumentAfterModification(IDocument document, bool forceSaveOpenDocuments);
    public abstract virtual void CommitFileSystemTrackerChanges(IDocument document);
    public abstract virtual void MarkReconciledWithExternalVersion(IDocument document, string onlyIfTextOnDiskEquals);
    public abstract virtual void SynchronizeDocumentContentsWithStorage(IDocument document, VirtualFileSystemPath documentPath);
    public abstract virtual void SynchronizeDocumentContentsWithDiskFile(IDocument document, VirtualFileSystemPath documentPath);
}
public class JetBrains.DocumentModel.Storage.UnknownDocumentSavedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <Location>k__BackingField;
    public VirtualFileSystemPath Location { get; }
    public UnknownDocumentSavedEventArgs(VirtualFileSystemPath location);
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_Location();
}
public enum JetBrains.DocumentModel.TextModificationSide : Enum {
    public int value__;
    public static TextModificationSide NotSpecified;
    public static TextModificationSide LeftSide;
    public static TextModificationSide RightSide;
}
public class JetBrains.DocumentModel.Transactions.DocumentChangeInfo : object {
    private ArrayBuffer myBuffer;
    private List`1<DocumentTransactionAction> myTransactionActions;
    private LocalLazy`2<LineIndex, ArrayBuffer> myLineIndex;
    private DocumentChangeManager myDocumentChangeManager;
    private IShellLocks myLocks;
    [CompilerGeneratedAttribute]
private ManagedDocumentBase <ManagedDocument>k__BackingField;
    private static Func`2<ArrayBuffer, LineIndex> myCachedLineIndexFactory;
    public int ActionsCount { get; }
    public ManagedDocumentBase ManagedDocument { get; }
    public DocumentChangeInfo(ManagedDocumentBase managedDocument, DocumentChangeManager documentChangeManager, IShellLocks locks);
    private static DocumentChangeInfo();
    public int get_ActionsCount();
    [CompilerGeneratedAttribute]
public ManagedDocumentBase get_ManagedDocument();
    public void PushDocumentChange(DocumentChange documentChange);
    private void ApplyChange(DocumentChange documentChange);
    public void Rollback(DocumentTransaction documentTransaction);
    public void MergeChanges(DocumentChangeInfo infoToMerge);
    public TextRange PlayChanges(TextRange rangeBeforeTransaction, bool isGreedyToLeft, bool isGreedyToRight, bool reallyGreedy, int changesCountWhenCreated);
    public IEnumerable`1<DocumentChange> ApplyChanges(ManagedDocumentBase document, bool optimizeChangesOnCommit);
    private IEnumerable`1<DocumentChange> OptimizedApplyChanges(ManagedDocumentBase document);
    public IBuffer GetBufferUnderTransaction();
    public LineIndex GetLineIndex();
    [PureAttribute]
public List`1<DocumentChange> GetRollbackChanges();
}
public class JetBrains.DocumentModel.Transactions.DocumentModificationMap : object {
    private List`1<RangePair> myMap;
    public TextRange MaxChangedRange { get; }
    public int OptimizedChangesCount { get; }
    public IEnumerable`1<RangePair> ReverseRanges { get; }
    public void Add(TextRange oldRange, TextRange newRange, TextModificationSide modificationSide);
    public void Finish(IBuffer oldBuffer, IBuffer newBuffer);
    private static RangePair OptimizePairFromLeft(RangePair pair, IBuffer oldBuffer, IBuffer newBuffer);
    private static RangePair OptimizePairFromRight(RangePair pair, IBuffer oldBuffer, IBuffer newBuffer);
    private int HandleInIn(TextRange oldRange, TextRange newRange, int seg1, int seg2, TextModificationSide modificationSide);
    private static TextModificationSide ComposeModificationSides(TextModificationSide side1, TextModificationSide side2);
    private int HandleInOut(TextRange oldRange, TextRange newRange, int seg1, int seg2);
    private int HandleOutIn(TextRange oldRange, TextRange newRange, int seg1, int seg2);
    private int HandleOutOut(TextRange oldRange, TextRange newRange, int seg1, int seg2, TextModificationSide modificationSide);
    private bool FindStartPoint(int offset, Int32& segment);
    private bool FindEndPoint(int offset, Int32& segment);
    private void ShiftSegments(int index, int delta);
    public TextRange get_MaxChangedRange();
    public int get_OptimizedChangesCount();
    [IteratorStateMachineAttribute("JetBrains.DocumentModel.Transactions.DocumentModificationMap/<get_ReverseRanges>d__19")]
public IEnumerable`1<RangePair> get_ReverseRanges();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.DocumentModel.Transactions.DocumentTransaction : object {
    protected Dictionary`2<ManagedDocumentBase, DocumentChangeInfo> DirtyDocuments;
    protected IShellLocks Locks;
    private UITaskExecutor myTaskExecutor;
    private DocumentSettings myDocumentSettings;
    private HashSet`1<IDocument> myAffectedDocuments;
    private List`1<DocumentChange> myExternalChanges;
    private DocumentChangeManager myDocumentChangeManager;
    private ICommandProcessor myCommandProcessor;
    private IRunningDocuments myRunningDocuments;
    private LifetimeDefinition myLifetimeDefinition;
    private bool myOptimizeChangesOnCommit;
    [CompilerGeneratedAttribute]
private DocumentTransactionManager <Manager>k__BackingField;
    [CompilerGeneratedAttribute]
private OneToListMap`2<IDocument, IRangeMarkerUnderTransaction> <RangeMarkers>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DocumentTransaction <ParentTransaction>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <CommandName>k__BackingField;
    [CompilerGeneratedAttribute]
private State <CurrentState>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExpectChangesFromEnsureWritable>k__BackingField;
    protected IList`1<IDocument> AllAffectedDocuments { get; }
    public DocumentTransactionManager Manager { get; }
    public OneToListMap`2<IDocument, IRangeMarkerUnderTransaction> RangeMarkers { get; }
    [NullableAttribute("2")]
public DocumentTransaction ParentTransaction { get; }
    [NullableAttribute("2")]
public string CommandName { get; }
    public State CurrentState { get; public set; }
    public bool IsOpen { get; }
    public bool IsFinished { get; }
    public bool IsFinalizing { get; }
    public bool IsCommitting { get; }
    public bool IsCommitted { get; }
    public bool IsRollingBack { get; }
    public bool ExpectChangesFromEnsureWritable { get; private set; }
    protected Lifetime Lifetime { get; }
    protected DocumentTransaction(DocumentTransactionManager manager, DocumentTransaction parentTransaction, IShellLocks locks, DocumentSettings documentSettings, UITaskExecutor taskExecutor, string commandName, bool optimizeChangesOnCommit, DocumentChangeManager documentChangeManager, ICommandProcessor commandProcessor, IRunningDocuments runningDocuments);
    protected IList`1<IDocument> get_AllAffectedDocuments();
    [CompilerGeneratedAttribute]
public DocumentTransactionManager get_Manager();
    [CompilerGeneratedAttribute]
public OneToListMap`2<IDocument, IRangeMarkerUnderTransaction> get_RangeMarkers();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public DocumentTransaction get_ParentTransaction();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_CommandName();
    [CompilerGeneratedAttribute]
public State get_CurrentState();
    [CompilerGeneratedAttribute]
public void set_CurrentState(State value);
    public bool get_IsOpen();
    public bool get_IsFinished();
    public bool get_IsFinalizing();
    public bool get_IsCommitting();
    public bool get_IsCommitted();
    public bool get_IsRollingBack();
    [CompilerGeneratedAttribute]
public bool get_ExpectChangesFromEnsureWritable();
    [CompilerGeneratedAttribute]
private void set_ExpectChangesFromEnsureWritable(bool value);
    protected Lifetime get_Lifetime();
    public DocumentTransactionCommitResult Commit(IProgressIndicator progressIndicator);
    private DocumentTransactionCommitResult RollbackWithExternalChanges(EnsureWritableResult result, string message);
    [MustDisposeResourceAttribute]
protected abstract virtual ModificationCookie CreateEnsureWritableCookie(IList`1& affectedDocuments);
    protected virtual void MergeChanges(DocumentTransaction childTransaction);
    public DocumentTransactionRollbackResult Rollback();
    [MustUseReturnValueAttribute]
public Dictionary`2<IDocument, List`1<DocumentChange>> GetCurrentRollbackChanges();
    private void AfterRollback(DocumentTransactionResult documentTransactionResult);
    private void AfterCommit(DocumentTransactionResult documentTransactionResult);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertRangeMarkersValidAfterTransaction();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void CheckParentTransactionRangeMarkers();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertRangeMarkersValid();
    protected virtual DocumentTransactionRollbackResult DoRollback();
    private void DoApplyExternalChanges();
    [MustUseReturnValueAttribute]
protected virtual IReadOnlyCollection`1<DocumentChange> DoCommit(IDictionary`2<ManagedDocumentBase, DocumentChangeInfo> dirtyDocuments, IProgressIndicator progressIndicator);
    public void PushDocumentChange(DocumentChange documentChange);
    public TextRange PlayChanges(TextRange rangeBeforeTransaction, ManagedDocumentBase document, bool isGreedyToLeft, bool isGreedyToRight, bool reallyGreedy, int changesCountWhenCreated);
    public IBuffer TryGetBuffer(ManagedDocumentBase managedDocumentBase);
    public LineIndex TryGetLineIndex(ManagedDocumentBase managedDocumentBase);
    [PureAttribute]
public bool HasDirtyDocumentsButNotThisOne(IDocument document);
    public abstract virtual IRangeMarker CreateRangeMarker(TextRange range, ManagedDocumentBase document);
    protected void RegisterRangeMarker(IDocument document, IRangeMarkerUnderTransaction rangeMarkerUnderTransaction);
    public int GetActionsCount(ManagedDocumentBase document);
    public void HandleExternalChange(DocumentChange documentChange);
    private void ResetTransaction(IRangeMarkerUnderTransaction rangeMarker);
    private void MoveRangeMarkersToNewTransaction(IDocument document, IRangeMarkerUnderTransaction rangeMarker, DocumentTransaction fromTransaction, int changesCountToAdd);
    protected void MoveRangeMarkersFromTransaction(IRangeMarkerUnderTransaction rangeMarker);
    internal void PlayChangesBack(IRangeMarkerUnderTransaction rangeMarker, DocumentChange rollbackChange, int index, int newDocumentLength);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.DocumentModel.Transactions.DocumentTransactionAction : object {
    [CompilerGeneratedAttribute]
private IShellLocks <locks>P;
    [CompilerGeneratedAttribute]
private DocumentChangeManager <documentChangeManager>P;
    [CompilerGeneratedAttribute]
private DocumentChange <DocumentChange>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OldText>k__BackingField;
    public DocumentChange DocumentChange { get; }
    public string OldText { get; }
    public DocumentTransactionAction(DocumentChange documentChange, string oldText, IShellLocks locks, DocumentChangeManager documentChangeManager);
    [CompilerGeneratedAttribute]
public DocumentChange get_DocumentChange();
    [CompilerGeneratedAttribute]
public string get_OldText();
    public void RollBack(ArrayBuffer buffer, int index, DocumentTransaction projectDocumentTransaction);
    [PureAttribute]
public DocumentChange ToRollbackChange();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.DocumentModel.Transactions.DocumentTransactionCommitResult : DocumentTransactionResult {
    public static DocumentTransactionCommitResult EmptySuccess;
    public DocumentTransactionCommitResult(IList`1<IDocument> committedDocuments, EnsureWritableResult ensureWritableResult, string ensureWritableMessage, bool successful);
    public DocumentTransactionCommitResult(IList`1<IDocument> committedDocuments, EnsureWritableResult ensureWritableResult, string ensureWritableMessage, bool successful, IEnumerable`1<DocumentChange> changes);
    private static DocumentTransactionCommitResult();
}
internal class JetBrains.DocumentModel.Transactions.DocumentTransactionCookie : object {
    private DocumentTransactionManager myManager;
    private DefaultAction myDefaultAction;
    private IProgressIndicator myProgressIndicator;
    private bool myIsDisposed;
    public DocumentTransactionCookie(DocumentTransactionManager manager, DefaultAction defaultAction, string commandName);
    public DocumentTransactionCookie(DocumentTransactionManager manager, DefaultAction defaultAction, string commandName, bool optimizeChangesOnCommit, IProgressIndicator progressIndicator);
    public sealed virtual void Dispose();
    public sealed virtual TransactionCommitResult Commit(IProgressIndicator progressIndicator);
    public sealed virtual void Rollback();
}
public abstract class JetBrains.DocumentModel.Transactions.DocumentTransactionManager : object {
    protected IShellLocks Locks;
    protected DocumentSettings DocumentSettings;
    protected UITaskExecutor UITaskExecutor;
    private LazyForkedContentModelData`1<Stack`1<DocumentTransaction>> myActiveTransactions;
    public ISimpleSignal TransactionStarted;
    public ISimpleSignal BeforeTransactionCommit;
    public ISignal`1<DocumentTransactionResult> AfterTransactionCommit;
    public DocumentTransaction CurrentTransaction { get; }
    public bool IsOuterCurrentTransaction { get; }
    private Stack`1<DocumentTransaction> ActiveTransactions { get; }
    protected DocumentTransactionManager(Lifetime lifetime, IShellLocks locks, DocumentSettings documentSettings, UITaskExecutor uiTaskExecutor);
    public sealed virtual DocumentTransaction get_CurrentTransaction();
    public bool get_IsOuterCurrentTransaction();
    private Stack`1<DocumentTransaction> get_ActiveTransactions();
    public ITransactionCookie CreateTransactionCookie(DefaultAction defaultAction, string commandName);
    public ITransactionCookie CreateTransactionCookie(DefaultAction defaultAction, string commandName, bool optimizeChangesOnCommit, IProgressIndicator progressIndicator);
    public bool DoTransaction(string commandName, Func`1<bool> handler);
    public void StartTransaction(string commandName, bool optimizeChangesOnCommit);
    protected abstract virtual DocumentTransaction CreateTransaction(DocumentTransaction parentTransaction, string commandName, bool optimizeChangesOnCommit);
    public virtual DocumentTransactionCommitResult CommitTransaction(IProgressIndicator progressIndicator);
    protected virtual DocumentTransactionCommitResult OnOuterTransactionCommitted(DocumentTransactionCommitResult documentTransactionCommitResult);
    protected virtual void SaveDocumentsAfterModification(DocumentTransactionCommitResult documentTransactionCommitResult);
    protected virtual void SaveDocumentAfterModification(IDocument document, bool forceSaveOpenDocuments);
    protected virtual void SetActiveTransaction(DocumentTransaction pop);
    [NotNullAttribute]
public DocumentTransactionRollbackResult RollbackTransaction();
    public sealed virtual TextRange PlayChanges(TextRange rangeBeforeTransaction, ManagedDocumentBase document, bool isGreedyToLeft, bool isGreedyToRight, bool reallyGreedy);
    public TextRange PlayChanges(TextRange rangeBeforeTransaction, ManagedDocumentBase document, bool isGreedyToLeft, bool isGreedyToRight, bool reallyGreedy, DocumentTransaction documentTransaction, int changesCountWhenCreated);
    public sealed virtual LineIndex GetLineIndex(ManagedDocumentBase managedDocumentBase);
    public sealed virtual IBuffer GetBuffer(ManagedDocumentBase managedDocumentBase);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertNotUnderTransaction(string text);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertUnderTransaction(string text);
    public abstract virtual IRangeMarker CreateRangeMarker(ManagedDocumentBase document, TextRange range);
    public void AssertNotCommittingOrRollingBackTransaction();
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.DocumentModel.Transactions.DocumentTransactionResult : TransactionCommitResult {
    [CompilerGeneratedAttribute]
private IList`1<IDocument> <Documents>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<DocumentChange> <Changes>k__BackingField;
    public IList`1<IDocument> Documents { get; }
    [MemberNotNullWhenAttribute("True", "Changes")]
public bool Successful { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<DocumentChange> Changes { get; }
    protected DocumentTransactionResult(IList`1<IDocument> documents, EnsureWritableResult ensureWritableResult, string ensureWritableMessage, bool successful);
    protected DocumentTransactionResult(IList`1<IDocument> documents, EnsureWritableResult ensureWritableResult, string ensureWritableMessage, bool successful, IEnumerable`1<DocumentChange> changes);
    [CompilerGeneratedAttribute]
public IList`1<IDocument> get_Documents();
    [MemberNotNullWhenAttribute("True", "Changes")]
public bool get_Successful();
    [CompilerGeneratedAttribute]
public IEnumerable`1<DocumentChange> get_Changes();
}
public class JetBrains.DocumentModel.Transactions.DocumentTransactionRollbackResult : DocumentTransactionResult {
    [NullableContextAttribute("1")]
public DocumentTransactionRollbackResult(IList`1<IDocument> affectedDocuments);
}
public static class JetBrains.DocumentModel.Transactions.DocumentTransactionUtil : object {
    [NotNullAttribute]
public static DocumentChange GetOptimizedChange(DocumentChange documentChange, string oldRangeText);
    public static Pair`2<TextRange, string> GetOptimizedChange(TextRange textRange, string newText, string oldRangeText);
    private static bool OptimizedChange(string oldText, string newText, int oldLen, int startOffset, Int32& updatedLength, TextModificationSide& modificationSide, Int32& updatedStartOffset, String& newUpdatedText);
    public static TextRange GetRootRange(string baseStr, string str);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.DocumentModel.Transactions.DummyDocumentTransactionManager : object {
    [NullableAttribute("2")]
public DocumentTransaction CurrentTransaction { get; }
    [NullableContextAttribute("2")]
public sealed virtual DocumentTransaction get_CurrentTransaction();
    public sealed virtual IRangeMarker CreateRangeMarker(ManagedDocumentBase document, TextRange range);
    public sealed virtual LineIndex GetLineIndex(ManagedDocumentBase managedDocumentBase);
    public sealed virtual IBuffer GetBuffer(ManagedDocumentBase managedDocumentBase);
    public sealed virtual TextRange PlayChanges(TextRange rangeBeforeTransaction, ManagedDocumentBase document, bool isGreedyToLeft, bool isGreedyToRight, bool reallyGreedy);
}
public interface JetBrains.DocumentModel.Transactions.IDocumentTransactionManager {
    [CanBeNullAttribute]
public DocumentTransaction CurrentTransaction { get; }
    public abstract virtual DocumentTransaction get_CurrentTransaction();
    [NotNullAttribute]
public abstract virtual IRangeMarker CreateRangeMarker(ManagedDocumentBase document, TextRange range);
    [CanBeNullAttribute]
public abstract virtual LineIndex GetLineIndex(ManagedDocumentBase managedDocumentBase);
    [CanBeNullAttribute]
public abstract virtual IBuffer GetBuffer(ManagedDocumentBase managedDocumentBase);
    public abstract virtual TextRange PlayChanges(TextRange rangeBeforeTransaction, ManagedDocumentBase document, bool isGreedyToLeft, bool isGreedyToRight, bool reallyGreedy);
}
[NullableContextAttribute("1")]
public interface JetBrains.DocumentModel.Transactions.IRangeMarkerUnderTransaction {
    public abstract virtual void MoveToTransaction(DocumentTransaction fromTransaction, DocumentTransaction toTransaction, int changesCountToAdd);
    public abstract virtual void MoveFromTransaction(DocumentTransaction documentTransaction);
    public abstract virtual void ResetTransaction(DocumentTransaction documentTransaction);
    public abstract virtual void PlayChangesBack(DocumentTransaction documentTransaction, DocumentChange rollbackChange, int index, int newDocumentLength);
    public abstract virtual void AssertIsMovedFrom(DocumentTransaction documentTransaction);
    public abstract virtual void AssertIsInTransaction(DocumentTransaction documentTransaction);
    public abstract virtual void Unregister();
}
[ShellComponentAttribute("16")]
[DerivedComponentsInstantiationRequirementAttribute("0")]
public class JetBrains.DocumentModel.UndoManager : object {
    private static ILogger ourLog;
    private Signal`1<Unit> myOnLongLivingClose;
    [CompilerGeneratedAttribute]
private Reasons`1<string> <OpenedLongLivingUndoUnit>k__BackingField;
    public ISource`1<Unit> OnLongLivingClose { get; }
    public Reasons`1<string> OpenedLongLivingUndoUnit { get; }
    private static UndoManager();
    public ISource`1<Unit> get_OnLongLivingClose();
    [CompilerGeneratedAttribute]
public Reasons`1<string> get_OpenedLongLivingUndoUnit();
    public virtual void CloseLongLivingUndoUnits();
    public virtual IDisposable UsingUndoUnit(IDocument document, string changeName);
    public virtual IDisposable UsingGlobalUndoUnit(IDocument document, string changeName);
}
[ZoneMarkerAttribute]
public class JetBrains.DocumentModel.ZoneMarker : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
