public enum JetBrains.IDE.CloseTextControlSaveOptions : Enum {
    public int value__;
    public static CloseTextControlSaveOptions NoSave;
    public static CloseTextControlSaveOptions SaveIfDirty;
    public static CloseTextControlSaveOptions PromptSave;
}
public enum JetBrains.IDE.FileView : Enum {
    public int value__;
    public static FileView Code;
    public static FileView Debugging;
    public static FileView Designer;
    public static FileView Primary;
    public static FileView TextView;
    public static FileView UserChooseView;
}
[IsReadOnlyAttribute]
public class JetBrains.IDE.OpenFileOptions : ValueType {
    [CompilerGeneratedAttribute]
private TabActivation <Activation>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TargetFrameworkId <TargetFrameworkId>k__BackingField;
    [CompilerGeneratedAttribute]
private TabOptions <TabOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private FileView <FileView>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Nullable`1<ValueTuple`2<ImmutableArray`1<DocOffsetAndVirtualRange>, ModificationStamp>> <SelectionAndCaret>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FireAndForget>k__BackingField;
    public static OpenFileOptions DefaultActivate;
    public static OpenFileOptions DefaultNoActivate;
    public static OpenFileOptions NormalActivate;
    public static OpenFileOptions NormalNoActivate;
    public static OpenFileOptions ProvisionalActivate;
    public TabActivation Activation { get; public set; }
    [NullableAttribute("2")]
public TargetFrameworkId TargetFrameworkId { get; public set; }
    public TabOptions TabOptions { get; public set; }
    public FileView FileView { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Nullable`1<ValueTuple`2<ImmutableArray`1<DocOffsetAndVirtualRange>, ModificationStamp>> SelectionAndCaret { get; public set; }
    public bool FireAndForget { get; public set; }
    public OpenFileOptions(TabActivation Activation, TargetFrameworkId TargetFrameworkId, TabOptions TabOptions, FileView FileView, Nullable`1<ValueTuple`2<ImmutableArray`1<DocOffsetAndVirtualRange>, ModificationStamp>> SelectionAndCaret, bool FireAndForget);
    private static OpenFileOptions();
    [CompilerGeneratedAttribute]
public TabActivation get_Activation();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Activation(TabActivation value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TargetFrameworkId get_TargetFrameworkId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TargetFrameworkId(TargetFrameworkId value);
    [CompilerGeneratedAttribute]
public TabOptions get_TabOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TabOptions(TabOptions value);
    [CompilerGeneratedAttribute]
public FileView get_FileView();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FileView(FileView value);
    [CompilerGeneratedAttribute]
public Nullable`1<ValueTuple`2<ImmutableArray`1<DocOffsetAndVirtualRange>, ModificationStamp>> get_SelectionAndCaret();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SelectionAndCaret(Nullable`1<ValueTuple`2<ImmutableArray`1<DocOffsetAndVirtualRange>, ModificationStamp>> value);
    [CompilerGeneratedAttribute]
public bool get_FireAndForget();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FireAndForget(bool value);
    public OpenFileOptions WithActivation(TabActivation activation);
    public OpenFileOptions WithCaretPosition(DocOffsetAndVirtual offset);
    public OpenFileOptions WithMultiSelection(ImmutableArray`1<DocOffsetAndVirtualRange> ranges);
    public OpenFileOptions WithSelection(DocOffsetAndVirtualRange range);
    [NullableContextAttribute("2")]
public OpenFileOptions WithTargetFramework(TargetFrameworkId targetFrameworkId);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(OpenFileOptions left, OpenFileOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(OpenFileOptions left, OpenFileOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(OpenFileOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(TabActivation& Activation, TargetFrameworkId& TargetFrameworkId, TabOptions& TabOptions, FileView& FileView, Nullable`1& SelectionAndCaret, Boolean& FireAndForget);
}
public interface JetBrains.IDE.Output.IOutputLoggerIdeSettingsProvider {
    public bool ShowOutputWindowOnBuildStart { get; }
    public abstract virtual bool get_ShowOutputWindowOnBuildStart();
}
public interface JetBrains.IDE.Output.IOutputLoggerSettingsProvider {
    [NotNullAttribute]
public IProperty`1<bool> LogToOutput { get; }
    public abstract virtual IProperty`1<bool> get_LogToOutput();
}
public enum JetBrains.IDE.Output.JetConsoleColor : Enum {
    public int value__;
    public static JetConsoleColor None;
    public static JetConsoleColor Black;
    public static JetConsoleColor DarkBlue;
    public static JetConsoleColor DarkGreen;
    public static JetConsoleColor DarkCyan;
    public static JetConsoleColor DarkRed;
    public static JetConsoleColor DarkMagenta;
    public static JetConsoleColor DarkYellow;
    public static JetConsoleColor Gray;
    public static JetConsoleColor DarkGray;
    public static JetConsoleColor Blue;
    public static JetConsoleColor Green;
    public static JetConsoleColor Cyan;
    public static JetConsoleColor Red;
    public static JetConsoleColor Magenta;
    public static JetConsoleColor Yellow;
    public static JetConsoleColor White;
}
[ShellComponentAttribute("16")]
[DerivedComponentsInstantiationRequirementAttribute("0")]
public class JetBrains.IDE.Output.OutputLoggerIdeSettingsProviderStub : object {
    public bool ShowOutputWindowOnBuildStart { get; }
    public virtual bool get_ShowOutputWindowOnBuildStart();
}
[ShellComponentAttribute("10")]
public class JetBrains.IDE.Output.OutputLoggerSettingsProviderStub : object {
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <LogToOutput>k__BackingField;
    public IProperty`1<bool> LogToOutput { get; }
    public OutputLoggerSettingsProviderStub(Lifetime lifetime);
    [CompilerGeneratedAttribute]
public virtual IProperty`1<bool> get_LogToOutput();
}
public enum JetBrains.IDE.TabActivation : Enum {
    public int value__;
    public static TabActivation None;
    public static TabActivation Focused;
    public static TabActivation Visible;
}
[FlagsAttribute]
public enum JetBrains.IDE.TabOptions : Enum {
    public int value__;
    public static TabOptions NormalTab;
    public static TabOptions ProvisionTab;
    public static TabOptions Default;
    public static TabOptions PeekTab;
    public static TabOptions RespectTargetFramework;
}
public enum JetBrains.TextControl.CaretVisualPlacement : Enum {
    public int value__;
    public static CaretVisualPlacement DontScrollIfVisible;
    public static CaretVisualPlacement Generic;
    public static CaretVisualPlacement DirectionalUp;
    public static CaretVisualPlacement DirectionalDown;
}
public class JetBrains.TextControl.Data.DefaultRangeableSet`1 : object {
    [NotNullAttribute]
public static IRangeableSetFactory`2<TRangeable, DefaultRangeableSet`1<TRangeable>> Factory;
    private HybridDistinctCollection`1<TRangeable> mySet;
    public bool IsEmpty { get; }
    private DefaultRangeableSet`1(DefaultRangeableSet`1<TRangeable> other);
    private static DefaultRangeableSet`1();
    public sealed virtual void Add(TRangeable rangeable);
    public sealed virtual void Remove(TRangeable rangeable);
    public sealed virtual IEnumerator`1<TRangeable> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Contains(TRangeable rangeable);
    public sealed virtual bool get_IsEmpty();
    public sealed virtual void AddAllValidTo(ICollection`1<TRangeable> target);
    public virtual string ToString();
}
public interface JetBrains.TextControl.Data.IRangeable {
    public TextRange Range { get; }
    public DocumentRange DocumentRange { get; }
    public bool IsValid { get; }
    public IDocument Document { get; }
    public abstract virtual TextRange get_Range();
    public abstract virtual DocumentRange get_DocumentRange();
    public abstract virtual bool get_IsValid();
    public abstract virtual IDocument get_Document();
}
public interface JetBrains.TextControl.Data.IRangeableContainer`1 {
    public abstract virtual void Add(TRangeable rangeable);
    public abstract virtual void Remove(TRangeable rangeable);
    public abstract virtual void RemoveAll();
    public abstract virtual bool Contains(TRangeable rangeable);
    public abstract virtual void BeforeDocumentChange(DocumentChange args);
    public abstract virtual void OnDocumentChange(DocumentChange args);
    public abstract virtual IRangeIterator`1<TRangeable> Iterate();
    public abstract virtual IRangeIterator`1<TRangeable> Iterate(DocOffset documentOffset);
    public abstract virtual IEnumerable`1<TRangeable> GetAllInRange(TextRange range);
    public abstract virtual IEnumerable`1<TRangeable> GetAllOverRange(TextRange range);
    [CompilerGeneratedAttribute]
public abstract virtual void add_RemovedOnDocumentChange(Action`1<LocalList`1<TRangeable>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_RemovedOnDocumentChange(Action`1<LocalList`1<TRangeable>> value);
}
public interface JetBrains.TextControl.Data.IRangeableSet`1 {
    public bool IsEmpty { get; }
    public abstract virtual void Add(TRangeable rangeable);
    public abstract virtual void Remove(TRangeable rangeable);
    public abstract virtual bool Contains(TRangeable rangeable);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual void AddAllValidTo(ICollection`1<TRangeable> target);
}
public interface JetBrains.TextControl.Data.IRangeableSetFactory`2 {
    [PureAttribute]
[NotNullAttribute]
public abstract virtual TSet CreateEmpty();
    [PureAttribute]
[NotNullAttribute]
public abstract virtual TSet CreateCopy(TSet set);
    [PureAttribute]
public abstract virtual bool Compare(TSet s1, TSet s2);
}
public interface JetBrains.TextControl.Data.IRangeIterator`1 {
    public abstract virtual bool Valid();
    public abstract virtual bool Next();
    public abstract virtual bool Prev();
    public abstract virtual TextRange GetRange();
    public abstract virtual IRangeableSet`1<TRangeable> GetRangeableSet();
}
[IsReadOnlyAttribute]
[ValueSerializerAttribute("JetBrains.Util.Reflection.SimpleValueSerializer`1<JetBrains.TextControl.DocOffset>")]
[TypeConverterAttribute("JetBrains.Util.Reflection.SimpleTypeConverter`1<JetBrains.TextControl.DocOffset>")]
public class JetBrains.TextControl.DocOffset : ValueType {
    private int Offset;
    public static DocOffset I;
    public static DocOffset MaxValue;
    public static DocOffset MinValue;
    public static DocOffset O;
    [NotNullAttribute]
public static DocOffsetComparer Comparer;
    private DocOffset(int offset);
    public DocOffset(string text);
    private static DocOffset();
    [PureAttribute]
public static DocOffset Abs(DocOffset a);
    [PureAttribute]
public static DocOffset Max(DocOffset a, DocOffset b);
    [PureAttribute]
public static DocOffset Min(DocOffset a, DocOffset b);
    [PureAttribute]
public static DocOffset Parse(string s);
    [PureAttribute]
public static DocOffset Parse(string s, NumberStyles style);
    public static bool TryParse(string s, DocOffset& result);
    public static DocOffset op_Addition(DocOffset a, DocOffset b);
    public static DocOffset op_Addition(DocOffset a, int delta);
    public static DocOffset op_Decrement(DocOffset a);
    public static double op_Division(DocOffset a, DocOffset b);
    public static DocOffset op_Division(DocOffset a, int b);
    public static bool op_Equality(DocOffset left, DocOffset right);
    public static int op_Explicit(DocOffset other);
    public static DocOffset op_Explicit(int other);
    public static UInt32 op_Explicit(DocOffset other);
    public static DocOffset op_Explicit(UInt32 other);
    public static double op_Explicit(DocOffset other);
    public static bool op_GreaterThan(DocOffset a, DocOffset b);
    public static bool op_GreaterThanOrEqual(DocOffset a, DocOffset b);
    public static DocOffset op_Increment(DocOffset a);
    public static bool op_Inequality(DocOffset left, DocOffset right);
    public static DocOffset op_LeftShift(DocOffset a, int b);
    public static bool op_LessThan(DocOffset a, DocOffset b);
    public static bool op_LessThanOrEqual(DocOffset a, DocOffset b);
    public static DocOffset op_Multiply(DocOffset a, int b);
    public static DocOffset op_Multiply(int a, DocOffset b);
    public static DocOffset op_RightShift(DocOffset a, int b);
    public static DocOffset op_Subtraction(DocOffset a, DocOffset b);
    public static DocOffset op_Subtraction(DocOffset a, int delta);
    [PureAttribute]
public DocOffset Limited(DocOffset minInclusive, DocOffset maxExclusive);
    [PureAttribute]
public DocOffset Minus1();
    [PureAttribute]
public DocOffset Plus1();
    [NotNullAttribute]
[PureAttribute]
public string ToString(string format);
    [NotNullAttribute]
[PureAttribute]
public string ToString(string format, IFormatProvider provider);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual int CompareTo(DocOffset other);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public sealed virtual bool Equals(DocOffset other);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
}
[IsReadOnlyAttribute]
public class JetBrains.TextControl.DocOffsetAndVirtual : ValueType {
    private int myNeutralVirtualDelta;
    private DocOffset myOffset;
    public Int32`1<DocColumn> DocVirtualDelta { get; }
    public bool IsInVirtualSpace { get; }
    public DocOffset Offset { get; }
    public Int32`1<TextControlColumn> TextControlVirtualDelta { get; }
    public DocOffsetAndVirtual(DocOffset offset, Int32`1<TextControlColumn> virtualDelta);
    public DocOffsetAndVirtual(DocOffset offset, Int32`1<DocColumn> virtualDelta);
    public DocOffsetAndVirtual(DocOffset offset, int virtualDelta);
    public DocOffsetAndVirtual(DocOffset& offset);
    public Int32`1<DocColumn> get_DocVirtualDelta();
    public bool get_IsInVirtualSpace();
    public DocOffset get_Offset();
    public Int32`1<TextControlColumn> get_TextControlVirtualDelta();
    public static DocOffsetAndVirtual Max(DocOffsetAndVirtual l1, DocOffsetAndVirtual l2);
    public static DocOffsetAndVirtual Min(DocOffsetAndVirtual l1, DocOffsetAndVirtual l2);
    [PureAttribute]
public DocOffsetAndVirtual Limited(DocOffset minInclusive, DocOffset maxExclusive);
    public static bool op_Equality(DocOffsetAndVirtual left, DocOffsetAndVirtual right);
    public static bool op_Inequality(DocOffsetAndVirtual left, DocOffsetAndVirtual right);
    public static DocOffsetAndVirtual op_Implicit(DocOffset offset);
    public static DocOffset op_Explicit(DocOffsetAndVirtual doav);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(DocOffsetAndVirtual other);
    public sealed virtual int CompareTo(DocOffsetAndVirtual other);
}
public class JetBrains.TextControl.DocOffsetComparer : object {
    [NotNullAttribute]
public static DocOffsetComparer Default;
    private static DocOffsetComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<JetBrains.TextControl.DocOffset>.Compare(DocOffset x, DocOffset y);
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<JetBrains.TextControl.DocOffset>.Equals(DocOffset x, DocOffset y);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<JetBrains.TextControl.DocOffset>.GetHashCode(DocOffset obj);
}
[ExtensionAttribute]
public static class JetBrains.TextControl.DocOffsetEx : object {
    [ExtensionAttribute]
[PureAttribute]
public static DocumentOffset AsDocumentOffset(DocOffset offset, IDocument document);
    [ExtensionAttribute]
[PureAttribute]
public static TextRange AsEmptyRange(DocOffset offset);
    [ExtensionAttribute]
[PureAttribute]
public static DocOffset AtLeast(DocOffset offset, DocOffset minimum);
    [ExtensionAttribute]
[PureAttribute]
public static DocOffset AtMost(DocOffset offset, DocOffset maximum);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsOrTouches(TextRange range, DocOffset offset);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsCharIndex(TextRange range, DocOffset offset);
    [ExtensionAttribute]
[PureAttribute]
public static DocOffset DocOffset(DocumentOffset documentOffset);
    [ExtensionAttribute]
[PureAttribute]
public static DocOffset EndDocOffset(TextRange range);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentCoords GetCoordsByOffset(IDocument document, DocOffset offset);
    [ExtensionAttribute]
[PureAttribute]
public static DocOffset GetDocOffsetByCoords(IDocument document, DocumentCoords coords);
    [ExtensionAttribute]
[PureAttribute]
public static DocOffset GetLineEndDocOffsetNoLineBreak(IDocument document, Int32`1<DocLine> line);
    [ExtensionAttribute]
[PureAttribute]
public static DocOffset GetLineEndDocOffsetWithLineBreak(IDocument document, Int32`1<DocLine> line);
    [ExtensionAttribute]
[PureAttribute]
public static DocOffset GetLineStartDocOffset(IDocument document, Int32`1<DocLine> line);
    [ExtensionAttribute]
[PureAttribute]
public static DocOffset GetMaxOffset(IDocument document);
    [ExtensionAttribute]
[PureAttribute]
public static DocOffset GetMinOffset(IDocument document);
    [ExtensionAttribute]
public static void InsertText(IDocument document, DocOffset offset, string text, TextModificationSide modificationSide);
    [ExtensionAttribute]
[PureAttribute]
public static TextRange RangeNormalized(DocOffset offset, DocOffset another);
    [ExtensionAttribute]
[PureAttribute]
public static TextRange RangeOfLength(DocOffset start, int length);
    [ExtensionAttribute]
[PureAttribute]
public static TextRange RangeTo(DocOffset start, DocOffset end);
    [ExtensionAttribute]
[PureAttribute]
public static DocOffset StartDocOffset(TextRange range);
    [ExtensionAttribute]
[PureAttribute]
public static DocOffset StartDocOffset(DocumentChange docchange);
}
[IsReadOnlyAttribute]
public class JetBrains.TextControl.DocumentMarkup.Adornments.AdornmentData : ValueType {
    public static AdornmentData New;
    public AdornmentFlags Flags;
    public AdornmentKind Kind;
    [CanBeNullAttribute]
public IconId Icon;
    public AdornmentPlacement Placement;
    [CanBeNullAttribute]
public Nullable`1<InterLineAdornmentProperties> InterLineProperties;
    public PushToHintMode Mode;
    [CanBeNullAttribute]
public RichText Text;
    public TextRange TextRange;
    public int WidthInCharacters;
    public DocOffset ParentStartOffset;
    public string ReplacedText;
    public AdornmentData(RichText text, IconId icon, AdornmentFlags flags, AdornmentPlacement placement, PushToHintMode mode, AdornmentKind kind);
    public AdornmentData(RichText text, IconId icon, AdornmentFlags flags, AdornmentPlacement placement, PushToHintMode mode, TextRange textRange, string replacedText, int widthInCharacters, DocOffset parentStartOffset, Nullable`1<InterLineAdornmentProperties> interLineProperties, AdornmentKind kind);
    private static AdornmentData();
    public sealed virtual int CompareTo(AdornmentData other);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual bool Equals(AdornmentData other);
    public virtual bool Equals(object obj);
    public bool Equals(AdornmentData other, Func`3<IconId, IconId, bool> iconEquals);
    public virtual int GetHashCode();
    [UsedImplicitlyAttribute]
public static AdornmentData Read(SerializationCtx ctx, UnsafeReader unreader);
    public AdornmentData WithProperties(InterLineAdornmentProperties properties);
    public AdornmentData WithFlags(AdornmentFlags flags);
    public AdornmentData WithIcon(IconId icon);
    public AdornmentData WithPlacement(AdornmentPlacement placement);
    public AdornmentData WithMode(PushToHintMode mode);
    public AdornmentData WithText(RichText text);
    [UsedImplicitlyAttribute]
public static void Write(SerializationCtx ctx, UnsafeWriter unwriter, AdornmentData value);
}
[FlagsAttribute]
public enum JetBrains.TextControl.DocumentMarkup.Adornments.AdornmentFlags : Enum {
    public int value__;
    public static AdornmentFlags None;
    public static AdornmentFlags HasContextMenu;
    public static AdornmentFlags IsNavigable;
    public static AdornmentFlags HasSelectionRange;
    public static AdornmentFlags Transparent;
    public static AdornmentFlags Whitespace;
    public static AdornmentFlags IsCustomAdornment;
    public static AdornmentFlags TransparentBackground;
    public static AdornmentFlags IsCtrlNotRequiredForNavigation;
}
public enum JetBrains.TextControl.DocumentMarkup.Adornments.AdornmentIconDockingPosition : Enum {
    public int value__;
    public static AdornmentIconDockingPosition LeftCenter;
    public static AdornmentIconDockingPosition LeftTop;
    public static AdornmentIconDockingPosition LeftBottom;
    public static AdornmentIconDockingPosition TopLeft;
    public static AdornmentIconDockingPosition BottomLeft;
}
public enum JetBrains.TextControl.DocumentMarkup.Adornments.AdornmentKind : Enum {
    public int value__;
    public static AdornmentKind Default;
    public static AdornmentKind InplaceAISuggestion;
}
[IsReadOnlyAttribute]
public class JetBrains.TextControl.DocumentMarkup.Adornments.AdornmentPlacement : ValueType {
    public static AdornmentPlacement DefaultAfterPrevChar;
    public static AdornmentPlacement DefaultBeforeThisChar;
    public static AdornmentPlacement VirtualCaretAfterLastIntra;
    public static AdornmentPlacement VirtualCaretBeforeFirstIntra;
    public static AdornmentPlacement VirtualCaretMiddle;
    [CompilerGeneratedAttribute]
private InterLinePosition <InterLinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private AdornmentPosition <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Priority>k__BackingField;
    [ObsoleteAttribute("Use AdornmentPosition")]
public InterLinePosition InterLinePosition { get; public set; }
    public AdornmentPosition Position { get; public set; }
    public double Priority { get; public set; }
    [ObsoleteAttribute("Use constructor with priority and position specification.")]
public AdornmentPlacement(double Priority, InterLinePosition InterLinePosition);
    [ObsoleteAttribute("Use constructor with priority and position specification.")]
public AdornmentPlacement(double priority);
    public AdornmentPlacement(double priority, AdornmentPosition position);
    private static AdornmentPlacement();
    [CompilerGeneratedAttribute]
public InterLinePosition get_InterLinePosition();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InterLinePosition(InterLinePosition value);
    [CompilerGeneratedAttribute]
public AdornmentPosition get_Position();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Position(AdornmentPosition value);
    [CompilerGeneratedAttribute]
public double get_Priority();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Priority(double value);
    public bool IsPreceding();
    public sealed virtual int CompareTo(AdornmentPlacement other);
    public sealed virtual int CompareTo(object obj);
    public static bool op_GreaterThan(AdornmentPlacement left, AdornmentPlacement right);
    public static bool op_GreaterThanOrEqual(AdornmentPlacement left, AdornmentPlacement right);
    public static bool op_LessThan(AdornmentPlacement left, AdornmentPlacement right);
    public static bool op_LessThanOrEqual(AdornmentPlacement left, AdornmentPlacement right);
    [UsedImplicitlyAttribute]
public static AdornmentPlacement Read(SerializationCtx ctx, UnsafeReader unreader);
    [UsedImplicitlyAttribute]
public static void Write(SerializationCtx ctx, UnsafeWriter unwriter, AdornmentPlacement value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(AdornmentPlacement left, AdornmentPlacement right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(AdornmentPlacement left, AdornmentPlacement right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(AdornmentPlacement other);
}
public enum JetBrains.TextControl.DocumentMarkup.Adornments.AdornmentPosition : Enum {
    public int value__;
    public static AdornmentPosition INLINE;
    public static AdornmentPosition AFTER_LINE_END;
    public static AdornmentPosition ABOVE_LINE;
    public static AdornmentPosition BELOW_LINE;
}
public abstract class JetBrains.TextControl.DocumentMarkup.Adornments.AdornmentsTransportBase : RdReflectionBindableBase {
    public RdReflectRequestResponse`2<AdornmentHighlighter, RichTextBlock> BwdGetTooltip;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public RdReflectRequestResponse`2<ValueTuple`5<AdornmentHighlighter, MouseButton, KeyboardModifiers, int, RdReflectInProcessBlackBox`1<PopupWindowContextSource>>, MouseDownOrClickTransportSession> BwdOnMouseDown;
    public RdReflectCollectionEvents`1<Session> BwdSessions;
    public RdReflectProperty`1<double> FwdTextScaleFactor;
}
public interface JetBrains.TextControl.DocumentMarkup.Adornments.IAdornmentDataModel {
    public AdornmentData Data { get; }
    [CanBeNullAttribute]
public IPresentableItem ContextMenuTitle { get; }
    [CanBeNullAttribute]
public IEnumerable`1<BulbMenuItem> ContextMenuItems { get; }
    public Nullable`1<TextRange> SelectionRange { get; }
    public abstract virtual AdornmentData get_Data();
    public abstract virtual IPresentableItem get_ContextMenuTitle();
    public abstract virtual IEnumerable`1<BulbMenuItem> get_ContextMenuItems();
    public abstract virtual void ExecuteNavigation(PopupWindowContextSource popupWindowContextSource);
    public abstract virtual Nullable`1<TextRange> get_SelectionRange();
}
public interface JetBrains.TextControl.DocumentMarkup.Adornments.ICodeCompletionPopupWindowFilter {
    public abstract virtual bool IsCodeCompletionPopupWindow(object rawControl);
}
public enum JetBrains.TextControl.DocumentMarkup.Adornments.InterLineAdornments.InterLineAdornmentIndentStrategy : Enum {
    public int value__;
    public static InterLineAdornmentIndentStrategy ATTACH_TO_LEADING_LINE_CHARACTER;
    public static InterLineAdornmentIndentStrategy INDENT_SPECIFIED_CHARACTERS_NUMBER;
}
[IsReadOnlyAttribute]
public class JetBrains.TextControl.DocumentMarkup.Adornments.InterLineAdornments.InterLineAdornmentProperties : ValueType {
    public static InterLineAdornmentProperties New;
    [CompilerGeneratedAttribute]
private byte <ExtraLinesAbove>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <ExtraLinesBelow>k__BackingField;
    [CompilerGeneratedAttribute]
private InterLineAdornmentIndentStrategy <IndentStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndentWidthInCharacters>k__BackingField;
    [CompilerGeneratedAttribute]
private AdornmentIconDockingPosition <IconDockingPosition>k__BackingField;
    private double myIconSizeScaleFactor;
    public byte ExtraLinesAbove { get; public set; }
    public byte ExtraLinesBelow { get; public set; }
    public InterLineAdornmentIndentStrategy IndentStrategy { get; public set; }
    public int IndentWidthInCharacters { get; public set; }
    public AdornmentIconDockingPosition IconDockingPosition { get; public set; }
    public double IconSizeScaleFactor { get; public set; }
    public InterLineAdornmentProperties(byte extraLinesAbove, byte extraLinesBelow, InterLineAdornmentIndentStrategy indentStrategy, int indentWidthInCharacters, AdornmentIconDockingPosition iconDockingPosition, double iconSizeScaleFactor);
    private static InterLineAdornmentProperties();
    [CompilerGeneratedAttribute]
public byte get_ExtraLinesAbove();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExtraLinesAbove(byte value);
    [CompilerGeneratedAttribute]
public byte get_ExtraLinesBelow();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExtraLinesBelow(byte value);
    [CompilerGeneratedAttribute]
public InterLineAdornmentIndentStrategy get_IndentStrategy();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IndentStrategy(InterLineAdornmentIndentStrategy value);
    [CompilerGeneratedAttribute]
public int get_IndentWidthInCharacters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IndentWidthInCharacters(int value);
    [CompilerGeneratedAttribute]
public AdornmentIconDockingPosition get_IconDockingPosition();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IconDockingPosition(AdornmentIconDockingPosition value);
    public double get_IconSizeScaleFactor();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IconSizeScaleFactor(double value);
    public sealed virtual int CompareTo(InterLineAdornmentProperties other);
    [UsedImplicitlyAttribute]
public static InterLineAdornmentProperties Read(SerializationCtx ctx, UnsafeReader unreader);
    [UsedImplicitlyAttribute]
public static void Write(SerializationCtx ctx, UnsafeWriter unwriter, InterLineAdornmentProperties value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(InterLineAdornmentProperties left, InterLineAdornmentProperties right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(InterLineAdornmentProperties left, InterLineAdornmentProperties right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InterLineAdornmentProperties other);
}
[SettingsKeyAttribute("JetBrains.Application.Settings.WellKnownRootKeys.EnvironmentSettings", "ReSharper interline adornments settings")]
public class JetBrains.TextControl.DocumentMarkup.Adornments.InterLineAdornments.InterLineAdornmentSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.TextControl.Resources.Strings", "InterLineHintFontSizeScaleSettingDescription")]
public double ScaleFactor;
}
[RdModelAttribute]
public class JetBrains.TextControl.DocumentMarkup.Adornments.InterLineAdornments.InterLineAdornmentsTransport : AdornmentsTransportBase {
    public static PropertyId`1<InterLineAdornmentsTransport> PropertyBagId;
    private static InterLineAdornmentsTransport();
}
[ShellComponentAttribute("16")]
public class JetBrains.TextControl.DocumentMarkup.Adornments.InterLineAdornments.InterlineAdornmentSupportChecker : object {
    public bool InterlineHintsSupported { get; }
    public virtual bool get_InterlineHintsSupported();
}
[IsReadOnlyAttribute]
[ObsoleteAttribute("Use InterLineAdornmentProperties")]
public class JetBrains.TextControl.DocumentMarkup.Adornments.InterLineAdornments.InterLinePosition : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsAboveLine>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <ExtraLinesAbove>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <ExtraLinesBelow>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <IndentWidthInCharacters>k__BackingField;
    [CompilerGeneratedAttribute]
private AdornmentIconDockingPosition <IconDockingPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private double <IconSizeScaleFactor>k__BackingField;
    public static InterLinePosition Default;
    public bool IsAboveLine { get; public set; }
    public byte ExtraLinesAbove { get; public set; }
    public byte ExtraLinesBelow { get; public set; }
    public Nullable`1<int> IndentWidthInCharacters { get; public set; }
    public AdornmentIconDockingPosition IconDockingPosition { get; public set; }
    public double IconSizeScaleFactor { get; public set; }
    public InterLinePosition(bool IsAboveLine, byte ExtraLinesAbove, byte ExtraLinesBelow, Nullable`1<int> IndentWidthInCharacters, AdornmentIconDockingPosition IconDockingPosition, double IconSizeScaleFactor);
    private static InterLinePosition();
    [CompilerGeneratedAttribute]
public bool get_IsAboveLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsAboveLine(bool value);
    [CompilerGeneratedAttribute]
public byte get_ExtraLinesAbove();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExtraLinesAbove(byte value);
    [CompilerGeneratedAttribute]
public byte get_ExtraLinesBelow();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExtraLinesBelow(byte value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_IndentWidthInCharacters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IndentWidthInCharacters(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public AdornmentIconDockingPosition get_IconDockingPosition();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IconDockingPosition(AdornmentIconDockingPosition value);
    [CompilerGeneratedAttribute]
public double get_IconSizeScaleFactor();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IconSizeScaleFactor(double value);
    public sealed virtual int CompareTo(InterLinePosition other);
    [UsedImplicitlyAttribute]
public static InterLinePosition Read(SerializationCtx ctx, UnsafeReader unreader);
    [UsedImplicitlyAttribute]
public static void Write(SerializationCtx ctx, UnsafeWriter unwriter, InterLinePosition value);
    public InterLineAdornmentProperties ToProperties();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(InterLinePosition left, InterLinePosition right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(InterLinePosition left, InterLinePosition right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InterLinePosition other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Boolean& IsAboveLine, Byte& ExtraLinesAbove, Byte& ExtraLinesBelow, Nullable`1& IndentWidthInCharacters, AdornmentIconDockingPosition& IconDockingPosition, Double& IconSizeScaleFactor);
}
[ExtensionAttribute]
public static class JetBrains.TextControl.DocumentMarkup.Adornments.IntraTextAdornments.AdornmentHighlighterEx : object {
    [ExtensionAttribute]
public static IntraTextPosition IntraTextPosition(AdornmentHighlighter thіs);
}
public static class JetBrains.TextControl.DocumentMarkup.Adornments.IntraTextAdornments.Careting.CaretIntraMoveHelpers : object {
    public static Nullable`1<AdornmentPlacement> TryMoveCaretBetweenSameChars(IntraTextPosition caretIntraPos, ImmutableArray`1<AdornmentHighlighter> highlighters, bool isRightwards, ILogger logger);
}
[IsReadOnlyAttribute]
public class JetBrains.TextControl.DocumentMarkup.Adornments.IntraTextAdornments.Careting.IntraTextPosition : ValueType {
    [CompilerGeneratedAttribute]
private DocOffset <RealDocOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private AdornmentPlacement <IntraPlacement>k__BackingField;
    public DocOffset RealDocOffset { get; public set; }
    public AdornmentPlacement IntraPlacement { get; public set; }
    public IntraTextPosition(DocOffset RealDocOffset, AdornmentPlacement IntraPlacement);
    [CompilerGeneratedAttribute]
public DocOffset get_RealDocOffset();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RealDocOffset(DocOffset value);
    [CompilerGeneratedAttribute]
public AdornmentPlacement get_IntraPlacement();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IntraPlacement(AdornmentPlacement value);
    public IntraTextPosition WithIntraPlacement(AdornmentPlacement intraplacement);
    public IntraTextPosition WithRealDocOffset(DocOffset realdocoffs);
    private sealed virtual override int System.IComparable<JetBrains.TextControl.DocumentMarkup.Adornments.IntraTextAdornments.Careting.IntraTextPosition>.CompareTo(IntraTextPosition other);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(IntraTextPosition left, IntraTextPosition right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(IntraTextPosition left, IntraTextPosition right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(IntraTextPosition other);
    [CompilerGeneratedAttribute]
public void Deconstruct(DocOffset& RealDocOffset, AdornmentPlacement& IntraPlacement);
}
[SettingsKeyAttribute("JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.InlayHintsSettings", "JetBrains.Application.Resources.Strings", "ReSharperGeneralInlayHintsSettingsSettingDescription")]
public class JetBrains.TextControl.DocumentMarkup.Adornments.IntraTextAdornments.GeneralInlayHintsOptions : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.Application.Resources.Strings", "WhetherToEnableTheEntireInfrastructureOfInlayHintsSettingDescription")]
public bool EnableInlayHints;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.Application.Resources.Strings", "WhetherToBindThePressAndHoldOfTheCtrlKeyToPushToHintSettingDescription")]
public bool EnablePushToHint;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.Application.Resources.Strings", "DefaultVisibilityModeOfInlayHintsSettingDescription")]
public PushToHintMode DefaultMode;
}
[SettingsKeyAttribute("JetBrains.Application.Settings.WellKnownRootKeys.EnvironmentSettings", "ReSharper intra text adornments settings")]
public class JetBrains.TextControl.DocumentMarkup.Adornments.IntraTextAdornments.IntraTextAdornmentSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.TextControl.Resources.Strings", "AlignAdornmentTextBaseline_Text")]
public bool AlignBaseline;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.TextControl.Resources.Strings", "InlineHintFontSizeScaleSettingDescription")]
public double ScaleFactor;
}
[RdModelAttribute]
public class JetBrains.TextControl.DocumentMarkup.Adornments.IntraTextAdornments.IntraTextAdornmentsTransport : AdornmentsTransportBase {
    public static PropertyId`1<IntraTextAdornmentsTransport> PropertyBagId;
    public RdReflectProperty`1<bool> FwdIsAlignBaseline;
    private static IntraTextAdornmentsTransport();
}
public enum JetBrains.TextControl.DocumentMarkup.Adornments.PushToHintMode : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Default")]
public static PushToHintMode Default;
    [LocalizedDescriptionAttribute("Show Always")]
public static PushToHintMode Always;
    [LocalizedDescriptionAttribute("Push-to-Hint")]
public static PushToHintMode PushToShowHints;
    [LocalizedDescriptionAttribute("Never Show")]
public static PushToHintMode Never;
}
[SettingsKeyAttribute("JetBrains.Application.Settings.WellKnownRootKeys.EnvironmentSettings", "ReSharper Push-to-Hint related settings")]
public class JetBrains.TextControl.DocumentMarkup.Adornments.PushToHintSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.TextControl.Resources.Strings", "PushToHintLongTapDurationInMilliseconds_Text")]
public int PushToHintLongTapDuration;
}
public enum JetBrains.TextControl.DocumentMarkup.AreaType : Enum {
    public int value__;
    public static AreaType EXACT_RANGE;
    public static AreaType LINES_IN_RANGE;
}
[IsReadOnlyAttribute]
public class JetBrains.TextControl.DocumentMarkup.CustomizedHighlighterAttributes : ValueType {
    public JetRgbaColor Color;
    public JetRgbaColor BackgroundColor;
    public Nullable`1<double> ForegroundOpacity;
    public Nullable`1<double> BackgroundOpacity;
    public EffectType EffectType;
    public double EffectThickness;
    public StringSource FontFamilyName;
    public JetFontStyles FontStyle;
    public double FontSize;
    public CustomizedHighlighterAttributes(JetRgbaColor foregroundColor, JetRgbaColor backgroundColor, Nullable`1<double> foregroundOpacity, Nullable`1<double> backgroundOpacity, EffectType effectType, double effectThickness, StringSource fontFamilyName, JetFontStyles fontStyle, double fontSize);
}
[IsReadOnlyAttribute]
public class JetBrains.TextControl.DocumentMarkup.Effect : ValueType {
    public static Effect EMPTY;
    [CompilerGeneratedAttribute]
private EffectType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private JetRgbaColor <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private JetRgbaColor <FillColor>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Thickness>k__BackingField;
    public EffectType Type { get; }
    public JetRgbaColor Color { get; }
    public JetRgbaColor FillColor { get; }
    public double Thickness { get; }
    public Effect(EffectType type);
    public Effect(EffectType type, JetRgbaColor color);
    public Effect(EffectType type, JetRgbaColor color, JetRgbaColor fillColor, double thickness);
    private static Effect();
    [CompilerGeneratedAttribute]
public EffectType get_Type();
    [CompilerGeneratedAttribute]
public JetRgbaColor get_Color();
    [CompilerGeneratedAttribute]
public JetRgbaColor get_FillColor();
    [CompilerGeneratedAttribute]
public double get_Thickness();
    public static bool op_Equality(Effect l, Effect r);
    public static bool op_Inequality(Effect l, Effect r);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static double GetDefaultThicknessForEffect(EffectType type);
    public static Effect FromHighlighterAttributes(HighlighterAttributes attrs, bool isDark);
}
public enum JetBrains.TextControl.DocumentMarkup.EffectType : Enum {
    public int value__;
    public static EffectType NONE;
    public static EffectType HIGHLIGHT_BELOW_TEXT_MARKER;
    public static EffectType HIGHLIGHT_ABOVE_TEXT_MARKER;
    public static EffectType TEXT;
    public static EffectType WAVE;
    public static EffectType SOLID_UNDERLINE;
    public static EffectType DOTTED_OUTLINE;
    public static EffectType SOLID_OUTLINE;
    public static EffectType DOTTED_UNDERLINE;
    public static EffectType GUTTER_MARK;
    public static EffectType ERROR_STRIPE_MARK;
    public static EffectType FOLDING;
    public static EffectType LINE_MARKER;
    public static EffectType INTRA_TEXT_ADORNMENT;
    public static EffectType INTER_LINE_ADORNMENT;
    public static EffectType METHOD_SEPARATOR;
    public static EffectType VIRTUAL_INDENT;
}
[IsReadOnlyAttribute]
public class JetBrains.TextControl.DocumentMarkup.ErrorStripeAttributes : ValueType {
    public static ErrorStripeAttributes DoNotShow;
    [CompilerGeneratedAttribute]
private string <ErrorStripeColorHighlighterAttributeId>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorStripeMarkerKind <MarkerKind>k__BackingField;
    [CanBeNullAttribute]
public string ErrorStripeColorHighlighterAttributeId { get; }
    public Nullable`1<OWORD> ErrorStripeColorHighlighterAttributeIdHash { get; }
    public bool IsShowingMarkerOnErrorStripe { get; }
    public ErrorStripeMarkerKind MarkerKind { get; }
    public ErrorStripeAttributes(ErrorStripeMarkerKind kind, string idErrorStripeColorHighlighterAttribute);
    private static ErrorStripeAttributes();
    [CompilerGeneratedAttribute]
public string get_ErrorStripeColorHighlighterAttributeId();
    public Nullable`1<OWORD> get_ErrorStripeColorHighlighterAttributeIdHash();
    public bool get_IsShowingMarkerOnErrorStripe();
    [CompilerGeneratedAttribute]
public ErrorStripeMarkerKind get_MarkerKind();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ErrorStripeAttributes attr1, ErrorStripeAttributes attr2);
    public static bool op_Inequality(ErrorStripeAttributes attr1, ErrorStripeAttributes attr2);
}
[FlagsAttribute]
public enum JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerCategories : Enum {
    public int value__;
    public static ErrorStripeMarkerCategories Info;
    public static ErrorStripeMarkerCategories CodeAnalysis;
    public static ErrorStripeMarkerCategories Usage;
    public static ErrorStripeMarkerCategories Any;
}
public enum JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerKind : Enum {
    public int value__;
    public static ErrorStripeMarkerKind Info;
    public static ErrorStripeMarkerKind Suggestion;
    public static ErrorStripeMarkerKind Warning;
    public static ErrorStripeMarkerKind Error;
    public static ErrorStripeMarkerKind Usage;
}
public class JetBrains.TextControl.DocumentMarkup.FCustomizeHighlighter : MulticastDelegate {
    public FCustomizeHighlighter(object object, IntPtr method);
    public virtual CustomizedHighlighterAttributes Invoke(OWORD highlighterIdHash);
    public virtual IAsyncResult BeginInvoke(OWORD highlighterIdHash, AsyncCallback callback, object object);
    public virtual CustomizedHighlighterAttributes EndInvoke(IAsyncResult result);
}
[RdModelAttribute]
public class JetBrains.TextControl.DocumentMarkup.GutterMarksTransport : RdReflectionBindableBase {
    public static PropertyId`1<GutterMarksTransport> PropertyBagId;
    public RdReflectRequestResponse`2<LineRequest, TooltipResponse> BwdGetTooltip;
    public RdReflectCollectionEvents`1<GutterMarksInLinesSession> BwdGutterMarksInLinesSessions;
    public RdReflectRequestResponse`2<MouseDownRequest, MouseDownOrClickTransportSession> BwdOnMouseDown;
    public RdReflectProperty`1<ImmutableArray`1<TextRange>> BwdMouseHoverGutterMarks;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public RdCall`2<ValueTuple`3<DocOffsetAndVirtual, ModificationStamp, JetThickness>, RdAnchoringRect> FwdTmpTryGetGutterMarkAnchoringRect;
    public RdReflectProperty`1<bool> IsJetActionMarginMode;
    private static GutterMarksTransport();
}
public enum JetBrains.TextControl.DocumentMarkup.HighContrastMode : Enum {
    public int value__;
    public static HighContrastMode Neutral;
    public static HighContrastMode SameAsLight;
    public static HighContrastMode SameAsDark;
    public static HighContrastMode Automatic;
    public static HighContrastMode None;
}
[RdModelAttribute]
public class JetBrains.TextControl.DocumentMarkup.HighlighterAdornmentsAndClassificationsTransport : RdReflectionBindableBase {
    public static PropertyId`1<HighlighterAdornmentsAndClassificationsTransport> PropertyBagId;
    public RdReflectCollectionEvents`1<Session> BwdSessions;
    private static HighlighterAdornmentsAndClassificationsTransport();
}
[ExtensionAttribute]
public static class JetBrains.TextControl.DocumentMarkup.HighlighterAttributeIdHash : object {
    public static OWORD GetAttributeIdHashCode(string sAttributeId);
    [ExtensionAttribute]
public static OWORD GetAttributeIdHashCode(IHighlighter highlighter);
    public static OWORD GetAttributeIdHashCode(StringSource& sAttributeId);
    public static OWORD GetAttributeIdHashCode(ReadOnlySpan`1<char> sAttributeId);
}
public class JetBrains.TextControl.DocumentMarkup.HighlighterAttributes : object {
    private static Func`2<HighlighterAttributes, string> myFactoryFontFamily;
    public static JetRgbaColor UNDEFINED_COLOR;
    public static double UNDEFINED_FONT_SIZE;
    public static int UNDEFINED_FONT_STYLE;
    public static HighlighterAttributes UNDEFINED;
    private StringSource myFontFamilyName;
    private LocalLazy`2<string, HighlighterAttributes> myFontFamily;
    [CompilerGeneratedAttribute]
private int <FontStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FontSize>k__BackingField;
    [CompilerGeneratedAttribute]
private JetRgbaColor <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private JetRgbaColor <BackgroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private JetRgbaColor <DarkColor>k__BackingField;
    [CompilerGeneratedAttribute]
private JetRgbaColor <DarkBackgroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <ForegroundOpacity>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <BackgroundOpacity>k__BackingField;
    [CompilerGeneratedAttribute]
private EffectType <EffectType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <EffectThickness>k__BackingField;
    public StringSource FontFamilyName { get; }
    [CanBeNullAttribute]
public string FontFamily { get; }
    public int FontStyle { get; }
    public double FontSize { get; }
    public JetRgbaColor Color { get; }
    public JetRgbaColor BackgroundColor { get; }
    public JetRgbaColor DarkColor { get; }
    public JetRgbaColor DarkBackgroundColor { get; }
    public Nullable`1<double> ForegroundOpacity { get; }
    public Nullable`1<double> BackgroundOpacity { get; }
    public EffectType EffectType { get; }
    public Nullable`1<double> EffectThickness { get; }
    public HighlighterAttributes(HighlighterAttributes other);
    public HighlighterAttributes(JetRgbaColor color, JetRgbaColor backgroundColor);
    public HighlighterAttributes(JetRgbaColor color);
    public HighlighterAttributes(StringSource fontFamily, FontStyle fontStyle, double fontSizeEmDip, JetRgbaColor color, JetRgbaColor backgroundColor, EffectType effectType, Nullable`1<double> effectThickness, Nullable`1<double> opacityFore, Nullable`1<double> opacityBack, Nullable`1<JetRgbaColor> darkColor, Nullable`1<JetRgbaColor> darkBackgroundColor);
    public HighlighterAttributes(EffectType effectType, JetRgbaColor color, Nullable`1<JetRgbaColor> backgroundColor, double thickness);
    private static HighlighterAttributes();
    public StringSource get_FontFamilyName();
    public string get_FontFamily();
    [CompilerGeneratedAttribute]
public int get_FontStyle();
    [CompilerGeneratedAttribute]
public double get_FontSize();
    [CompilerGeneratedAttribute]
public JetRgbaColor get_Color();
    [CompilerGeneratedAttribute]
public JetRgbaColor get_BackgroundColor();
    [CompilerGeneratedAttribute]
public JetRgbaColor get_DarkColor();
    [CompilerGeneratedAttribute]
public JetRgbaColor get_DarkBackgroundColor();
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_ForegroundOpacity();
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_BackgroundOpacity();
    [CompilerGeneratedAttribute]
public EffectType get_EffectType();
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_EffectThickness();
    public HighlighterAttributes Merge(HighlighterAttributes other);
    public bool IsFontDefined();
    public bool IsAnyAttributeDefined();
    public static HighlighterAttributes FromBackgroundColor(JetRgbaColor backgroundColor);
    public static HighlighterAttributes FromPartAttribute(PartCatalogAttribute attribute);
}
public class JetBrains.TextControl.DocumentMarkup.HighlighterCustomizationUtil : object {
    public static CustomizedHighlighterAttributes ApplyTheming(ITheming theming, HighlighterAttributes attrs);
}
public enum JetBrains.TextControl.DocumentMarkup.HighlighterLayer : Enum {
    public int value__;
    public static HighlighterLayer CARET_ROW;
    public static HighlighterLayer SYNTAX;
    public static HighlighterLayer ADDITIONAL_SYNTAX;
    public static HighlighterLayer WARNING;
    public static HighlighterLayer DEADCODE;
    public static HighlighterLayer ERROR;
    public static HighlighterLayer SELECTION;
}
[IsReadOnlyAttribute]
public class JetBrains.TextControl.DocumentMarkup.HighlightersSnapshot`1 : ValueType {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TTransportItem> <Highlighters>k__BackingField;
    [CompilerGeneratedAttribute]
private ModificationStamp <DocumentModificationStamp>k__BackingField;
    public ImmutableArray`1<TTransportItem> Highlighters { get; public set; }
    public ModificationStamp DocumentModificationStamp { get; public set; }
    public static HighlightersSnapshot`1<TTransportItem> Empty { get; }
    public HighlightersSnapshot`1(ImmutableArray`1<TTransportItem> Highlighters, ModificationStamp DocumentModificationStamp);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TTransportItem> get_Highlighters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Highlighters(ImmutableArray`1<TTransportItem> value);
    [CompilerGeneratedAttribute]
public ModificationStamp get_DocumentModificationStamp();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DocumentModificationStamp(ModificationStamp value);
    public static HighlightersSnapshot`1<TTransportItem> get_Empty();
    public sealed virtual bool Equals(HighlightersSnapshot`1<TTransportItem> other);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(HighlightersSnapshot`1<TTransportItem> left, HighlightersSnapshot`1<TTransportItem> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(HighlightersSnapshot`1<TTransportItem> left, HighlightersSnapshot`1<TTransportItem> right);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public void Deconstruct(ImmutableArray`1& Highlighters, ModificationStamp& DocumentModificationStamp);
}
public enum JetBrains.TextControl.DocumentMarkup.HighlighterTooltipKind : Enum {
    public int value__;
    public static HighlighterTooltipKind TextEditor;
    public static HighlighterTooltipKind ErrorStripe;
    public static HighlighterTooltipKind StatusBar;
    public static HighlighterTooltipKind GutterMark;
    public static HighlighterTooltipKind QuickDoc;
    public static HighlighterTooltipKind GutterMarkBulbMenu;
}
[ShellComponentAttribute("16")]
public class JetBrains.TextControl.DocumentMarkup.HighlightingAttributeRegistry : object {
    private ILogger myLogger;
    private Lifetime myLifetime;
    private IPartCatalogSet myCatalogset;
    private IComponentContainer myContainer;
    private Lazy`1<Dictionary`2<StringSource, HighlighterData>> myMapIdToData;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<ValueTuple`2[]> mySortedIdHashes;
    public HighlightingAttributeRegistry(Lifetime lifetime, ShellPartCatalogSet catalogset, IComponentContainer container, ILogger logger);
    protected HighlightingAttributeRegistry(Lifetime lifetime, IPartCatalogSet catalogset, IComponentContainer container, ILogger logger);
    [CanBeNullAttribute]
private HighlighterData TryGetHighlighterData(string attributeId);
    public sealed virtual HighlighterAttributes GetAttributes(string id);
    public sealed virtual ErrorStripeAttributes GetErrorStripeAttributes(string id);
    public sealed virtual IGutterMarkType GetGutterMark(string id);
    public sealed virtual Nullable`1<HighlighterLayer> GetLayer(string id);
    public sealed virtual bool IsNotRecyclable(string id);
    public bool IsTransmitUpdates(string id);
    private sealed virtual override bool JetBrains.TextControl.DocumentMarkup.IHighlightingAttributeRegistry.IsDefined(string id);
    public sealed virtual string GetAttributeIdByHashCode(OWORD highlighterAttributeIdHash);
    public sealed virtual Nullable`1<VsPredefinedClassificationType> TryGetVsBaseClassificationType(string id);
    private Dictionary`2<StringSource, HighlighterData> LazyCreateMapIdToData();
    private ValueTuple`2[] LazyCreateSortedIdHashes();
}
public interface JetBrains.TextControl.DocumentMarkup.IGutterMarkHoverHandler {
    public abstract virtual void OnHover(Lifetime lifetime);
}
public interface JetBrains.TextControl.DocumentMarkup.IGutterMarkInfo {
    [NotNullAttribute]
public IconId IconId { get; }
    [CanBeNullAttribute]
public IAnchor Priority { get; }
    [NotNullAttribute]
public RichTextBlock RichText { get; }
    public abstract virtual IconId get_IconId();
    public abstract virtual IAnchor get_Priority();
    public abstract virtual RichTextBlock get_RichText();
    [CanBeNullAttribute]
public abstract virtual IEnumerable`1<BulbMenuItem> GetBulbMenuItems();
    [CanBeNullAttribute]
public abstract virtual IGutterMarkHoverHandler GetHoverHandler();
}
public interface JetBrains.TextControl.DocumentMarkup.IGutterMarkType {
    [CanBeNullAttribute]
[GuardAttribute("2")]
public abstract virtual IGutterMarkInfo GetGutterMarkInfo(IHighlighter highlighter);
}
public interface JetBrains.TextControl.DocumentMarkup.IHighlighter {
    public HighlighterAttributes Attributes { get; }
    public string Key { get; }
    public Nullable`1<HighlighterLayer> Layer { get; }
    public AreaType AreaType { get; }
    [CanBeNullAttribute]
public string AttributeId { get; }
    public ErrorStripeAttributes ErrorStripeAttributes { get; }
    [CanBeNullAttribute]
public IAdornmentDataModel AdornmentDataModel { get; }
    [CanBeNullAttribute]
public object UserData { get; public set; }
    [CanBeNullAttribute]
public IGutterMarkType GutterMarkType { get; }
    public abstract virtual HighlighterAttributes get_Attributes();
    public abstract virtual string get_Key();
    public abstract virtual Nullable`1<HighlighterLayer> get_Layer();
    public abstract virtual AreaType get_AreaType();
    public abstract virtual string get_AttributeId();
    public abstract virtual ErrorStripeAttributes get_ErrorStripeAttributes();
    [CanBeNullAttribute]
[GuardAttribute("1")]
public abstract virtual RichTextBlock TryGetTooltip(HighlighterTooltipKind where);
    public abstract virtual bool HasTooltip(HighlighterTooltipKind where);
    public abstract virtual IAdornmentDataModel get_AdornmentDataModel();
    public abstract virtual object get_UserData();
    public abstract virtual void set_UserData(object value);
    public abstract virtual IGutterMarkType get_GutterMarkType();
}
[DerivedComponentsInstantiationRequirementAttribute("1")]
public interface JetBrains.TextControl.DocumentMarkup.IHighlightingAttributeRegistry {
    [NotNullAttribute]
public abstract virtual HighlighterAttributes GetAttributes(string id);
    [CanBeNullAttribute]
public abstract virtual IGutterMarkType GetGutterMark(string id);
    public abstract virtual ErrorStripeAttributes GetErrorStripeAttributes(string id);
    public abstract virtual Nullable`1<HighlighterLayer> GetLayer(string id);
    public abstract virtual bool IsNotRecyclable(string id);
    public abstract virtual bool IsDefined(string id);
    [NotNullAttribute]
public abstract virtual string GetAttributeIdByHashCode(OWORD highlighterAttributeIdHash);
    public abstract virtual Nullable`1<VsPredefinedClassificationType> TryGetVsBaseClassificationType(string id);
}
[SettingsKeyAttribute("JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.InlayHintsSettings", "ReSharper General Inlay Hints settings")]
public class JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.GeneralVirtualIndentingSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Fix alignment for Inlay Hints")]
public bool FixAlignmentForInlayHints;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Enable Virtual Formatter")]
public bool EnableVirtualIndenting;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Use dedicated settings for Virtual Formatter")]
public bool UseVirtualIndentSettings;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Use content-dependent configuration (.editorconfig, etc) when applying virtual formatting")]
public bool UseContextDependantConfiguration;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Show real whitespaces on top of virtual")]
public ShowRealWhitespaces ShowRealWhitespaces;
}
[SettingsKeyAttribute("JetBrains.Application.Settings.WellKnownRootKeys.EnvironmentSettings", "JetBrains.Application.Resources.Strings", "InlayHintSettingsGenerallyShouldNotBeSharedWithTheSolutionWithinATeamSettingDescription")]
public class JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.InlayHintsSettings : object {
}
public enum JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.ShowRealWhitespaces : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("When the caret is near")]
public static ShowRealWhitespaces NearCaret;
    [LocalizedDescriptionAttribute("Never")]
public static ShowRealWhitespaces Never;
    [LocalizedDescriptionAttribute("Always")]
public static ShowRealWhitespaces Always;
}
public enum JetBrains.TextControl.DocumentMarkup.PaletteColorIndex : Enum {
    public UInt32 value__;
    public static PaletteColorIndex GenericTextForeground;
    public static PaletteColorIndex GenericTextBackground;
    public static PaletteColorIndex PaletteBlack;
    public static PaletteColorIndex PaletteWhite;
    public static PaletteColorIndex PaletteMaroon;
    public static PaletteColorIndex PaletteDarkGreen;
    public static PaletteColorIndex PaletteBrown;
    public static PaletteColorIndex PaletteDarkBlue;
    public static PaletteColorIndex PalettePurple;
    public static PaletteColorIndex PaletteAquamarine;
    public static PaletteColorIndex PaletteLightGray;
    public static PaletteColorIndex PaletteDarkGray;
    public static PaletteColorIndex PaletteRed;
    public static PaletteColorIndex PaletteGreen;
    public static PaletteColorIndex PaletteYellow;
    public static PaletteColorIndex PaletteBlue;
    public static PaletteColorIndex PaletteMagenta;
    public static PaletteColorIndex PaletteCyan;
    public static PaletteColorIndex SelectedTextForeground;
    public static PaletteColorIndex SelectedTextBackground;
    public static PaletteColorIndex InactiveSelectionForeground;
    public static PaletteColorIndex InactiveSelectionBackground;
    public static PaletteColorIndex IndicatorMarginBackground;
    public static PaletteColorIndex PlainTextForeground;
    public static PaletteColorIndex PlainTextBackground;
}
public enum JetBrains.TextControl.DocumentMarkup.PushToHintState : Enum {
    public int value__;
    public static PushToHintState Disabled;
    public static PushToHintState DisabledWhileHolding;
    public static PushToHintState EnabledWhileHolding;
    public static PushToHintState EnabledPermanently;
}
[ExtensionAttribute]
public static class JetBrains.TextControl.DocumentMarkup.PushToHintStateEx : object {
    [ExtensionAttribute]
public static bool IsEnabled(PushToHintState state);
}
[AttributeUsageAttribute("4")]
public class JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute : PartAttribute {
    private int myFontStyle;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private HighlighterLayer <Layer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FontFamily>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FontEmSizeInDip>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ForegroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BackgroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DarkForegroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DarkBackgroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ForegroundOpacity>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BackgroundOpacity>k__BackingField;
    [CompilerGeneratedAttribute]
private EffectType <EffectType>k__BackingField;
    [CompilerGeneratedAttribute]
private double <EffectThickness>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorStripeMarkerKind <ErrorStripeKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorStripeColorHighlighterAttributeId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RiderPresentableName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RiderPresentableNameResourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RiderPresentableNameResourceName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NotRecyclable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TransmitUpdates>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FallbackAttributeId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RiderReplaceWith>k__BackingField;
    [CompilerGeneratedAttribute]
private VsGenerateDefinition <VsGenerateClassificationDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VsPresentableName>k__BackingField;
    [CompilerGeneratedAttribute]
private VsPredefinedClassificationType <VsBaseClassificationType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VsUseInheritedColors>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <VsCustomOrderAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <VsCustomOrderBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GroupId>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <GutterMarkType>k__BackingField;
    private static ConcurrentDictionary`2<StringSource, Nullable`1<JetRgbaColor>> mapNameToColorCache;
    [CompilerGeneratedAttribute]
private PaletteColorIndex <HighContrastForeground>k__BackingField;
    [CompilerGeneratedAttribute]
private PaletteColorIndex <HighContrastBackground>k__BackingField;
    [CompilerGeneratedAttribute]
private HighContrastMode <HighContrastForegroundMode>k__BackingField;
    [CompilerGeneratedAttribute]
private HighContrastMode <HighContrastBackgroundMode>k__BackingField;
    public string Id { get; private set; }
    public HighlighterLayer Layer { get; public set; }
    public string FontFamily { get; public set; }
    public FontStyle FontStyle { get; public set; }
    public double FontEmSizeInDip { get; public set; }
    public string ForegroundColor { get; public set; }
    public string BackgroundColor { get; public set; }
    public string DarkForegroundColor { get; public set; }
    public string DarkBackgroundColor { get; public set; }
    public double ForegroundOpacity { get; public set; }
    public double BackgroundOpacity { get; public set; }
    public EffectType EffectType { get; public set; }
    public double EffectThickness { get; public set; }
    [ObsoleteAttribute("EffectColor is not used anymore. Please use ForegroundColor, DarkForegroundColor, BackgroundColor and DarkBackgroundColor to define effect colors.")]
public string EffectColor { get; public set; }
    public ErrorStripeMarkerKind ErrorStripeKind { get; public set; }
    [CanBeNullAttribute]
public string ErrorStripeColorHighlighterAttributeId { get; public set; }
    public string RiderPresentableName { get; public set; }
    public Type RiderPresentableNameResourceType { get; public set; }
    public string RiderPresentableNameResourceName { get; public set; }
    public bool NotRecyclable { get; public set; }
    public bool TransmitUpdates { get; public set; }
    public string FallbackAttributeId { get; public set; }
    public string RiderReplaceWith { get; public set; }
    public VsGenerateDefinition VsGenerateClassificationDefinition { get; public set; }
    public string VsPresentableName { get; public set; }
    public VsPredefinedClassificationType VsBaseClassificationType { get; public set; }
    public bool VsUseInheritedColors { get; public set; }
    public String[] VsCustomOrderAfter { get; public set; }
    public String[] VsCustomOrderBefore { get; public set; }
    public string GroupId { get; public set; }
    public Type GutterMarkType { get; public set; }
    public PaletteColorIndex HighContrastForeground { get; public set; }
    public PaletteColorIndex HighContrastBackground { get; public set; }
    public HighContrastMode HighContrastForegroundMode { get; public set; }
    public HighContrastMode HighContrastBackgroundMode { get; public set; }
    public RegisterHighlighterAttribute(string Id);
    private static RegisterHighlighterAttribute();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    [CompilerGeneratedAttribute]
public HighlighterLayer get_Layer();
    [CompilerGeneratedAttribute]
public void set_Layer(HighlighterLayer value);
    [CompilerGeneratedAttribute]
public string get_FontFamily();
    [CompilerGeneratedAttribute]
public void set_FontFamily(string value);
    public FontStyle get_FontStyle();
    public void set_FontStyle(FontStyle value);
    [CompilerGeneratedAttribute]
public double get_FontEmSizeInDip();
    [CompilerGeneratedAttribute]
public void set_FontEmSizeInDip(double value);
    [CompilerGeneratedAttribute]
public string get_ForegroundColor();
    [CompilerGeneratedAttribute]
public void set_ForegroundColor(string value);
    [CompilerGeneratedAttribute]
public string get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(string value);
    [CompilerGeneratedAttribute]
public string get_DarkForegroundColor();
    [CompilerGeneratedAttribute]
public void set_DarkForegroundColor(string value);
    [CompilerGeneratedAttribute]
public string get_DarkBackgroundColor();
    [CompilerGeneratedAttribute]
public void set_DarkBackgroundColor(string value);
    [CompilerGeneratedAttribute]
public double get_ForegroundOpacity();
    [CompilerGeneratedAttribute]
public void set_ForegroundOpacity(double value);
    [CompilerGeneratedAttribute]
public double get_BackgroundOpacity();
    [CompilerGeneratedAttribute]
public void set_BackgroundOpacity(double value);
    [CompilerGeneratedAttribute]
public EffectType get_EffectType();
    [CompilerGeneratedAttribute]
public void set_EffectType(EffectType value);
    [CompilerGeneratedAttribute]
public double get_EffectThickness();
    [CompilerGeneratedAttribute]
public void set_EffectThickness(double value);
    public string get_EffectColor();
    public void set_EffectColor(string value);
    [CompilerGeneratedAttribute]
public ErrorStripeMarkerKind get_ErrorStripeKind();
    [CompilerGeneratedAttribute]
public void set_ErrorStripeKind(ErrorStripeMarkerKind value);
    [CompilerGeneratedAttribute]
public string get_ErrorStripeColorHighlighterAttributeId();
    [CompilerGeneratedAttribute]
public void set_ErrorStripeColorHighlighterAttributeId(string value);
    [CompilerGeneratedAttribute]
public string get_RiderPresentableName();
    [CompilerGeneratedAttribute]
public void set_RiderPresentableName(string value);
    [CompilerGeneratedAttribute]
public Type get_RiderPresentableNameResourceType();
    [CompilerGeneratedAttribute]
public void set_RiderPresentableNameResourceType(Type value);
    [CompilerGeneratedAttribute]
public string get_RiderPresentableNameResourceName();
    [CompilerGeneratedAttribute]
public void set_RiderPresentableNameResourceName(string value);
    [CompilerGeneratedAttribute]
public bool get_NotRecyclable();
    [CompilerGeneratedAttribute]
public void set_NotRecyclable(bool value);
    [CompilerGeneratedAttribute]
public bool get_TransmitUpdates();
    [CompilerGeneratedAttribute]
public void set_TransmitUpdates(bool value);
    [CompilerGeneratedAttribute]
public string get_FallbackAttributeId();
    [CompilerGeneratedAttribute]
public void set_FallbackAttributeId(string value);
    [CompilerGeneratedAttribute]
public string get_RiderReplaceWith();
    [CompilerGeneratedAttribute]
public void set_RiderReplaceWith(string value);
    [CompilerGeneratedAttribute]
public VsGenerateDefinition get_VsGenerateClassificationDefinition();
    [CompilerGeneratedAttribute]
public void set_VsGenerateClassificationDefinition(VsGenerateDefinition value);
    [CompilerGeneratedAttribute]
public string get_VsPresentableName();
    [CompilerGeneratedAttribute]
public void set_VsPresentableName(string value);
    [CompilerGeneratedAttribute]
public VsPredefinedClassificationType get_VsBaseClassificationType();
    [CompilerGeneratedAttribute]
public void set_VsBaseClassificationType(VsPredefinedClassificationType value);
    [CompilerGeneratedAttribute]
public bool get_VsUseInheritedColors();
    [CompilerGeneratedAttribute]
public void set_VsUseInheritedColors(bool value);
    [CompilerGeneratedAttribute]
public String[] get_VsCustomOrderAfter();
    [CompilerGeneratedAttribute]
public void set_VsCustomOrderAfter(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_VsCustomOrderBefore();
    [CompilerGeneratedAttribute]
public void set_VsCustomOrderBefore(String[] value);
    [CompilerGeneratedAttribute]
public string get_GroupId();
    [CompilerGeneratedAttribute]
public void set_GroupId(string value);
    [CompilerGeneratedAttribute]
public Type get_GutterMarkType();
    [CompilerGeneratedAttribute]
public void set_GutterMarkType(Type value);
    public static IGutterMarkType CreateGutterMark(Lifetime lifetime, string id, Type gutterMarkType, IComponentContainer containerForFactoring);
    public static JetRgbaColor ColorOfStringOrDefault(Nullable`1<StringSource> maybeColor);
    public static Nullable`1<JetRgbaColor> TryGetColorOfString(Nullable`1<StringSource> maybeColor);
    public static Nullable`1<JetRgbaColor> ColorOfString(StringSource ssColor, Nullable`1<JetRgbaColor> ifNull);
    public static Nullable`1<JetRgbaColor> FromWebColor(StringSource color);
    [CompilerGeneratedAttribute]
public PaletteColorIndex get_HighContrastForeground();
    [CompilerGeneratedAttribute]
public void set_HighContrastForeground(PaletteColorIndex value);
    [CompilerGeneratedAttribute]
public PaletteColorIndex get_HighContrastBackground();
    [CompilerGeneratedAttribute]
public void set_HighContrastBackground(PaletteColorIndex value);
    [CompilerGeneratedAttribute]
public HighContrastMode get_HighContrastForegroundMode();
    [CompilerGeneratedAttribute]
public void set_HighContrastForegroundMode(HighContrastMode value);
    [CompilerGeneratedAttribute]
public HighContrastMode get_HighContrastBackgroundMode();
    [CompilerGeneratedAttribute]
public void set_HighContrastBackgroundMode(HighContrastMode value);
    [NotNullAttribute]
public static string InferHighlighterAttributeIdFromMarkedClassName(Type typeofHighlighterAttributeMarkedClass);
}
public static class JetBrains.TextControl.DocumentMarkup.VisualStudio.VsCodeAnalysisClassificationTypeNames : object {
    public static string Comment;
    public static string ExcludedCode;
    public static string Identifier;
    public static string Keyword;
    public static string ControlKeyword;
    public static string NumericLiteral;
    public static string Operator;
    public static string OperatorOverloaded;
    public static string PreprocessorKeyword;
    public static string StringLiteral;
    public static string WhiteSpace;
    public static string Text;
    public static string ReassignedVariable;
    public static string StaticSymbol;
    public static string PreprocessorText;
    public static string Punctuation;
    public static string VerbatimStringLiteral;
    public static string StringEscapeCharacter;
    public static string ClassName;
    public static string RecordClassName;
    public static string DelegateName;
    public static string EnumName;
    public static string InterfaceName;
    public static string ModuleName;
    public static string StructName;
    public static string RecordStructName;
    public static string TypeParameterName;
    public static string FieldName;
    public static string EnumMemberName;
    public static string ConstantName;
    public static string LocalName;
    public static string ParameterName;
    public static string MethodName;
    public static string ExtensionMethodName;
    public static string PropertyName;
    public static string EventName;
    public static string NamespaceName;
    public static string LabelName;
    public static string XmlDocCommentAttributeName;
    public static string XmlDocCommentAttributeQuotes;
    public static string XmlDocCommentAttributeValue;
    public static string XmlDocCommentCDataSection;
    public static string XmlDocCommentComment;
    public static string XmlDocCommentDelimiter;
    public static string XmlDocCommentEntityReference;
    public static string XmlDocCommentName;
    public static string XmlDocCommentProcessingInstruction;
    public static string XmlDocCommentText;
    public static string XmlLiteralAttributeName;
    public static string XmlLiteralAttributeQuotes;
    public static string XmlLiteralAttributeValue;
    public static string XmlLiteralCDataSection;
    public static string XmlLiteralComment;
    public static string XmlLiteralDelimiter;
    public static string XmlLiteralEmbeddedExpression;
    public static string XmlLiteralEntityReference;
    public static string XmlLiteralName;
    public static string XmlLiteralProcessingInstruction;
    public static string XmlLiteralText;
    public static string RegexComment;
    public static string RegexCharacterClass;
    public static string RegexAnchor;
    public static string RegexQuantifier;
    public static string RegexGrouping;
    public static string RegexAlternation;
    public static string RegexText;
    public static string RegexSelfEscapedCharacter;
    public static string RegexOtherEscape;
    public static string JsonComment;
    public static string JsonNumber;
    public static string JsonString;
    public static string JsonKeyword;
    public static string JsonText;
    public static string JsonOperator;
    public static string JsonPunctuation;
    public static string JsonArray;
    public static string JsonObject;
    public static string JsonPropertyName;
    public static string JsonConstructorName;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<string> <AdditiveTypeNames>k__BackingField;
    public static ImmutableArray`1<string> AdditiveTypeNames { get; }
    private static VsCodeAnalysisClassificationTypeNames();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<string> get_AdditiveTypeNames();
}
public enum JetBrains.TextControl.DocumentMarkup.VisualStudio.VsGenerateDefinition : Enum {
    public int value__;
    public static VsGenerateDefinition None;
    public static VsGenerateDefinition VisibleClassification;
    public static VsGenerateDefinition HiddenClassification;
}
public enum JetBrains.TextControl.DocumentMarkup.VisualStudio.VsPredefinedClassificationType : Enum {
    public int value__;
    public static VsPredefinedClassificationType DontCare;
    public static VsPredefinedClassificationType Text;
    public static VsPredefinedClassificationType Comment;
    public static VsPredefinedClassificationType Identifier;
    public static VsPredefinedClassificationType Keyword;
    public static VsPredefinedClassificationType WhiteSpace;
    public static VsPredefinedClassificationType Operator;
    public static VsPredefinedClassificationType Literal;
    public static VsPredefinedClassificationType String;
    public static VsPredefinedClassificationType Character;
    public static VsPredefinedClassificationType Number;
    public static VsPredefinedClassificationType Other;
    public static VsPredefinedClassificationType ExcludedCode;
    public static VsPredefinedClassificationType PreprocessorKeyword;
    public static VsPredefinedClassificationType SymbolDefinition;
    public static VsPredefinedClassificationType SymbolReference;
    public static VsPredefinedClassificationType NaturalLanguage;
    public static VsPredefinedClassificationType FormalLanguage;
    public static VsPredefinedClassificationType Punctuation;
}
public static class JetBrains.TextControl.DocumentMarkup.VisualStudio.VsWellKnownHighlighterAttributeIds : object {
    public static string KEYWORD;
    public static string STRING;
    public static string NUMBER;
    public static string COMMENT;
    public static string TEXT;
    public static string FormalLanguage;
}
[RdModelAttribute]
public class JetBrains.TextControl.ErrorStripe.ErrorStripeIndicatorTransport : RdWireableBase {
    private static PropertyId`1<Guid> FwdTmpTryGetPopupWindowContextTransactionReusePropertyId;
    public RdReflectRequestResponse`2<Missing, PresentableItemBlock> BwdGetTooltip;
    public RdReflectRequestResponse`2<KeyboardModifiers, MouseDownOrClickTransportSession> BwdOnMouseLeftButtonDownOrClick;
    public RdReflectRequestResponse`2<KeyboardModifiers, MouseDownOrClickTransportSession> BwdOnMouseRightButtonDownOrClick;
    public RdReflectSyncCall`2<Missing, RdReflectInProcessBlackBox`1<PopupWindowContextSource>> FwdTmpTryGetPopupWindowContext;
    [NotNullAttribute]
[ItemNotNullAttribute]
public RdReflectProperty`1<IconId> Icon;
    public double Priority;
    [NotNullAttribute]
public RdReflectPropertyBag PropertyBag;
    public ErrorStripeIndicatorTransport(double priority);
    private ErrorStripeIndicatorTransport(double priority, RdReflectRequestResponse`2<Missing, PresentableItemBlock> bwdGetTooltip, RdReflectRequestResponse`2<KeyboardModifiers, MouseDownOrClickTransportSession> bwdOnMouseLeftButtonDownOrClick, RdReflectRequestResponse`2<KeyboardModifiers, MouseDownOrClickTransportSession> bwdOnMouseRightButtonDownOrClick, RdReflectSyncCall`2<Missing, RdReflectInProcessBlackBox`1<PopupWindowContextSource>> fwdTmpTryGetPopupWindowContext, RdReflectProperty`1<IconId> icon, RdReflectPropertyBag propertyBag);
    private static ErrorStripeIndicatorTransport();
    public TransactionReuseKey MakeSyncCallsTransactionReuseKey();
    [UsedImplicitlyAttribute]
public static ErrorStripeIndicatorTransport Read(SerializationCtx ctx, UnsafeReader unreader);
    [UsedImplicitlyAttribute]
public static void Write(SerializationCtx ctx, UnsafeWriter unwriter, ErrorStripeIndicatorTransport value);
    protected virtual void OnBindNested(Lifetime lifetime);
    protected virtual void OnPreBindNested(Lifetime lifetime);
}
public enum JetBrains.TextControl.ErrorStripe.ErrorStripeLayout : Enum {
    public int value__;
    public static ErrorStripeLayout NoErrorStripe;
    public static ErrorStripeLayout Original;
    public static ErrorStripeLayout Vs12EnhancedScrollbar;
}
[SettingsKeyAttribute("JetBrains.Application.Settings.WellKnownRootKeys.EnvironmentSettings", "JetBrains.TextControl.Resources.Strings", "ErrorStripeSettingsSettingDescription")]
public class JetBrains.TextControl.ErrorStripe.ErrorStripeSettings : object {
    [ObsoleteAttribute]
[SettingsEntryAttribute]
public AnchorStyles ErrorStripeAnchoring;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.TextControl.Resources.Strings", "ErrorStripeLayoutStyleSettingDescription")]
public ErrorStripeLayout ErrorStripeLayout;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.TextControl.Resources.Strings", "OverviewErrorStripeMarginWidthSettingDescription")]
public ErrorStripeWidth ErrorStripeWidth;
    [ObsoleteAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.TextControl.Resources.Strings", "ShowHighlightersViewportRangeSettingDescription")]
public bool RenderHighlightersViewportRange;
}
[RdModelAttribute]
public class JetBrains.TextControl.ErrorStripe.ErrorStripeTransport : RdReflectionBindableBase {
    public RdReflectProperty`1<bool> HasSkippedHighlighters;
    public RdReflectCollectionEvents`1<ErrorStripeIndicatorTransport> Indicators;
    public RdReflectProperty`1<ErrorStripeLayout> LayoutSetting;
    public MarkerBarTransport MarkerBar;
    public RdReflectProperty`1<ErrorStripeWidth> WidthSettings;
}
public enum JetBrains.TextControl.ErrorStripe.ErrorStripeWidth : Enum {
    public int value__;
    public static ErrorStripeWidth Narrow;
    public static ErrorStripeWidth Medium;
    public static ErrorStripeWidth Wide;
}
[ZoneMarkerAttribute]
public class JetBrains.TextControl.IDE.ZoneMarker : object {
}
public interface JetBrains.TextControl.ITextControlOptions {
    public TextControlOverridableOption`1<bool> HighlightCurrentLine { get; }
    public TextControlOverridableOption`1<bool> HorizontalScrollbar { get; }
    public TextControlOverridableOption`1<int> IndentSize { get; }
    public TextControlOverridableOption`1<bool> IsVirtualSpaceEnabled { get; }
    public TextControlOverridableOption`1<bool> LineNumbers { get; }
    public TextControlOverridableOption`1<bool> HideAllMargins { get; }
    public TextControlOverridableOption`1<bool> HideContextMenu { get; }
    public TextControlOverridableOption`1<bool> ReadOnly { get; }
    public TextControlOverridableOption`1<int> TabSize { get; }
    public TextControlOverridableOption`1<bool> UseTabs { get; }
    public TextControlOverridableOption`1<bool> VerticalScrollbar { get; }
    public TextControlOverridableOption`1<bool> WhiteSpaces { get; }
    public TextControlOverridableOption`1<bool> WordWrap { get; }
    public TextControlOverridableOption`1<bool> ZoomControl { get; }
    public TextControlOverridableOption`1<double> ZoomLevel { get; }
    public TextControlOverridableOption`1<VerticalScrollbarMode> VerticalScrollbarMode { get; }
    public TextControlOverridableOption`1<bool> FileHealthIndicator { get; }
    public TextControlOverridableOption`1<bool> EditingContextMargin { get; }
    public TextControlOverridableOption`1<bool> ShowErrorsOnVerticalScrollBar { get; }
    public abstract virtual TextControlOverridableOption`1<bool> get_HighlightCurrentLine();
    public abstract virtual TextControlOverridableOption`1<bool> get_HorizontalScrollbar();
    public abstract virtual TextControlOverridableOption`1<int> get_IndentSize();
    public abstract virtual TextControlOverridableOption`1<bool> get_IsVirtualSpaceEnabled();
    public abstract virtual TextControlOverridableOption`1<bool> get_LineNumbers();
    public abstract virtual TextControlOverridableOption`1<bool> get_HideAllMargins();
    public abstract virtual TextControlOverridableOption`1<bool> get_HideContextMenu();
    public abstract virtual TextControlOverridableOption`1<bool> get_ReadOnly();
    public abstract virtual TextControlOverridableOption`1<int> get_TabSize();
    public abstract virtual TextControlOverridableOption`1<bool> get_UseTabs();
    public abstract virtual TextControlOverridableOption`1<bool> get_VerticalScrollbar();
    public abstract virtual TextControlOverridableOption`1<bool> get_WhiteSpaces();
    public abstract virtual TextControlOverridableOption`1<bool> get_WordWrap();
    public abstract virtual TextControlOverridableOption`1<bool> get_ZoomControl();
    public abstract virtual TextControlOverridableOption`1<double> get_ZoomLevel();
    public abstract virtual TextControlOverridableOption`1<VerticalScrollbarMode> get_VerticalScrollbarMode();
    public abstract virtual TextControlOverridableOption`1<bool> get_FileHealthIndicator();
    public abstract virtual TextControlOverridableOption`1<bool> get_EditingContextMargin();
    public abstract virtual TextControlOverridableOption`1<bool> get_ShowErrorsOnVerticalScrollBar();
}
public interface JetBrains.TextControl.ITextControlSchemeManager {
    public JetFont FontAttributes { get; }
    public JetRgbaColor ReadonlyBackground { get; }
    public JetRgbaColor CodeEditorBackground { get; }
    public JetRgbaColor CodeEditorForeground { get; }
    public JetRgbaColor CommentColor { get; }
    public JetRgbaColor PreprocessorKeywordColor { get; }
    public JetRgbaColor KeywordColor { get; }
    public JetRgbaColor StringColor { get; }
    public JetRgbaColor MethodColor { get; }
    public JetRgbaColor ParameterColor { get; }
    public JetRgbaColor TypeColor { get; }
    public ISimpleSignal ColorsChanged { get; }
    public abstract virtual JetFont get_FontAttributes();
    public abstract virtual JetRgbaColor get_ReadonlyBackground();
    public abstract virtual JetRgbaColor get_CodeEditorBackground();
    public abstract virtual JetRgbaColor get_CodeEditorForeground();
    public abstract virtual JetRgbaColor get_CommentColor();
    public abstract virtual JetRgbaColor get_PreprocessorKeywordColor();
    public abstract virtual JetRgbaColor get_KeywordColor();
    public abstract virtual JetRgbaColor get_StringColor();
    public abstract virtual JetRgbaColor get_MethodColor();
    public abstract virtual JetRgbaColor get_ParameterColor();
    public abstract virtual JetRgbaColor get_TypeColor();
    public abstract virtual ISimpleSignal get_ColorsChanged();
    public abstract virtual TextControlPreferences GetDefaultPreferences();
}
[ZoneDefinitionAttribute]
public interface JetBrains.TextControl.ITextControlsProtocolZone {
}
[ShellComponentAttribute("16")]
public class JetBrains.TextControl.JetActionMargin.BulbIndicatorSettings : object {
    private ISettingsStore mySettingsStore;
    public BulbIndicatorSettings(ISettingsStore settingsStore);
    public sealed virtual ContextActionsIndication GetContextActionsIndicationKind();
}
public enum JetBrains.TextControl.JetActionMargin.ContextActionsIndication : Enum {
    public int value__;
    public static ContextActionsIndication BulbIndicator;
    public static ContextActionsIndication GutterMark;
    public static ContextActionsIndication NoIndication;
}
[SettingsKeyAttribute("JetBrains.Application.Settings.WellKnownRootKeys.EnvironmentSettings", "JetBrains.TextControl.Resources.Strings", "ReSharperGutterMarginSettingsSettingDescription")]
public class JetBrains.TextControl.JetActionMargin.GutterMarginSettingsKey : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.TextControl.Resources.Strings", "ContextActionsIndicationSettingDescription")]
public ContextActionsIndication ContextActionsIndication;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.TextControl.Resources.Strings", "UseGutterMarginSettingDescription")]
public bool UseGutterMargin;
    public static IProperty`1<bool> BindLivePropertyForUseGutterMargin(Lifetime lifetime, ContextRange range, ISettingsStore store, IThreading threading);
}
public interface JetBrains.TextControl.JetActionMargin.IBulbIndicatorSettings {
    public abstract virtual ContextActionsIndication GetContextActionsIndicationKind();
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.TextControl.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string ContextActionsIndicationSettingDescription { get; }
    public static string Copy_Text { get; }
    public static string Cut_Text { get; }
    public static string ErrorStripeLayoutStyleSettingDescription { get; }
    public static string ErrorStripePositionSettingDescription { get; }
    public static string ErrorStripeSettingsSettingDescription { get; }
    public static string GotoNextCodeAnalysisHighlightingActionText { get; }
    public static string GotoNextHighlightedUsageActionText { get; }
    public static string GotoNextHighlightingActionText { get; }
    public static string GotoPreviousCodeAnalysisHighlightingActionText { get; }
    public static string GotoPreviousHighlightedUsageActionText { get; }
    public static string GotoPreviousHighlightingActionText { get; }
    public static string InlineHintFontSizeScaleSettingDescription { get; }
    public static string InterLineHintFontSizeScaleSettingDescription { get; }
    public static string OverviewErrorStripeMarginWidthSettingDescription { get; }
    public static string Paste_Text { get; }
    public static string PushToHintLongTapDurationInMilliseconds_Text { get; }
    public static string Redo_Text { get; }
    public static string ReSharperGutterMarginSettingsSettingDescription { get; }
    public static string SelectAll_Text { get; }
    public static string ShowHighlightersViewportRangeSettingDescription { get; }
    public static string TextEditorSettingsSettingDescription { get; }
    public static string Undo_Text { get; }
    public static string UseGutterMarginSettingDescription { get; }
    public static string AlignAdornmentTextBaseline_Text { get; }
    public static string WhetherToHighlightCurrentLineInTextEditorSettingDescription { get; }
    public static string GotoNextHighlightedUsage_Text { get; }
    public static string GotoNextErrorWarningOrSuggestion_Text { get; }
    public static string GotoNextHighlighting_Text { get; }
    public static string GotoPreviousHighlightedUsage_Text { get; }
    public static string GotoPreviousErrorWarningOrSuggestion_Text { get; }
    public static string GotoPreviousHighlighting_Text { get; }
    public static string GotoNext__Text { get; }
    public static string GotoPrevious__Text { get; }
    public static string HighlightedUsage_Text { get; }
    public static string Error_Text { get; }
    public static string Warning_Text { get; }
    public static string Suggestion_Text { get; }
    public static string Highlighting_Text { get; }
    public static string Default_Description_Text { get; }
    public static string NeverShow_Description_Text { get; }
    public static string PushToHint_Description_Text { get; }
    public static string ShowAlways_Description_Text { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get_ContextActionsIndicationSettingDescription();
    public static string get_Copy_Text();
    public static string get_Cut_Text();
    public static string get_ErrorStripeLayoutStyleSettingDescription();
    public static string get_ErrorStripePositionSettingDescription();
    public static string get_ErrorStripeSettingsSettingDescription();
    public static string get_GotoNextCodeAnalysisHighlightingActionText();
    public static string get_GotoNextHighlightedUsageActionText();
    public static string get_GotoNextHighlightingActionText();
    public static string get_GotoPreviousCodeAnalysisHighlightingActionText();
    public static string get_GotoPreviousHighlightedUsageActionText();
    public static string get_GotoPreviousHighlightingActionText();
    public static string get_InlineHintFontSizeScaleSettingDescription();
    public static string get_InterLineHintFontSizeScaleSettingDescription();
    public static string get_OverviewErrorStripeMarginWidthSettingDescription();
    public static string get_Paste_Text();
    public static string get_PushToHintLongTapDurationInMilliseconds_Text();
    public static string get_Redo_Text();
    public static string get_ReSharperGutterMarginSettingsSettingDescription();
    public static string get_SelectAll_Text();
    public static string get_ShowHighlightersViewportRangeSettingDescription();
    public static string get_TextEditorSettingsSettingDescription();
    public static string get_Undo_Text();
    public static string get_UseGutterMarginSettingDescription();
    public static string get_AlignAdornmentTextBaseline_Text();
    public static string get_WhetherToHighlightCurrentLineInTextEditorSettingDescription();
    public static string get_GotoNextHighlightedUsage_Text();
    public static string get_GotoNextErrorWarningOrSuggestion_Text();
    public static string get_GotoNextHighlighting_Text();
    public static string get_GotoPreviousHighlightedUsage_Text();
    public static string get_GotoPreviousErrorWarningOrSuggestion_Text();
    public static string get_GotoPreviousHighlighting_Text();
    public static string get_GotoNext__Text();
    public static string get_GotoPrevious__Text();
    public static string get_HighlightedUsage_Text();
    public static string get_Error_Text();
    public static string get_Warning_Text();
    public static string get_Suggestion_Text();
    public static string get_Highlighting_Text();
    public static string get_Default_Description_Text();
    public static string get_NeverShow_Description_Text();
    public static string get_PushToHint_Description_Text();
    public static string get_ShowAlways_Description_Text();
}
[IsReadOnlyAttribute]
public class JetBrains.TextControl.RunningTextControlId : ValueType {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private RunningDocumentId <DocumentId>k__BackingField;
    public int Id { get; }
    public RunningDocumentId DocumentId { get; }
    public RunningTextControlId(int id, RunningDocumentId documentId);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public RunningDocumentId get_DocumentId();
    public bool IsValid();
    public bool IsInvalid();
    public bool Equals(RunningTextControlId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(RunningTextControlId x, RunningTextControlId y);
    public static bool op_Inequality(RunningTextControlId x, RunningTextControlId y);
    public virtual string ToString();
}
public enum JetBrains.TextControl.SelectionEnd : Enum {
    public int value__;
    public static SelectionEnd Active;
    public static SelectionEnd Anchor;
}
public class JetBrains.TextControl.TextControlAutomation : AAutomation {
    public ICollectionEvents`1<RunningTextControlId> ConnectedTextControls;
    public RunningDocumentId DocumentId;
    public TextControlAutomationFlags Flags;
    public WindowFrame Frame;
    public TextControlHostedIn HostedIn;
    public TextControlPreferences Preferences;
    public Nullable`1<RunningTextControlId> UserCreatedTextControl;
    public static Factory New { get; }
    public TextControlAutomation(RunningDocumentId docid, Nullable`1<RunningTextControlId> userCreatedTextControl, TextControlHostedIn hostedIn, TextControlPreferences preferences, WindowFrame frame, TextControlAutomationFlags flags);
    public static Factory get_New();
}
[FlagsAttribute]
public enum JetBrains.TextControl.TextControlAutomationFlags : Enum {
    public int value__;
    public static TextControlAutomationFlags WantsTabNavigation;
    public static TextControlAutomationFlags AllowMultipleViewsWithUserDefinedTextControl;
}
public class JetBrains.TextControl.TextControlColumn : ValueType {
}
public enum JetBrains.TextControl.TextControlHostedIn : Enum {
    public int value__;
    public static TextControlHostedIn VsToolWindow;
    public static TextControlHostedIn WinFormsNonmodal;
    public static TextControlHostedIn WinFormsModal;
    public static TextControlHostedIn WpfNonmodal;
    public static TextControlHostedIn WpfModal;
}
public class JetBrains.TextControl.TextControlLine : ValueType {
}
[IsReadOnlyAttribute]
public class JetBrains.TextControl.TextControlLineColumn : ValueType {
    public Int32`1<TextControlColumn> Column;
    public Int32`1<TextControlLine> Line;
    public TextControlLineColumn(Int32`1<TextControlLine> line, Int32`1<TextControlColumn> column);
    public static TextControlLineColumn Max(TextControlLineColumn left, TextControlLineColumn right);
    public static TextControlLineColumn Min(TextControlLineColumn left, TextControlLineColumn right);
    public static bool op_Equality(TextControlLineColumn left, TextControlLineColumn right);
    public static bool op_GreaterThan(TextControlLineColumn left, TextControlLineColumn right);
    public static bool op_GreaterThanOrEqual(TextControlLineColumn left, TextControlLineColumn right);
    public static bool op_Inequality(TextControlLineColumn left, TextControlLineColumn right);
    public static bool op_LessThan(TextControlLineColumn left, TextControlLineColumn right);
    public static bool op_LessThanOrEqual(TextControlLineColumn left, TextControlLineColumn right);
    public TextControlLineColumn GetStartOfRow();
    public TextControlLineColumn OffsetHorizontally(Int32`1<TextControlColumn> nColumnDelta);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(TextControlLineColumn other);
}
[IsReadOnlyAttribute]
public class JetBrains.TextControl.TextControlLineColumnRange : ValueType {
    public TextControlLineColumn End;
    public TextControlLineColumn Start;
    public TextControlLineColumnRange(TextControlLineColumn startPosition, TextControlLineColumn endPosition);
    public TextControlLineColumnRange(Int32`1<TextControlLine> startLine, Int32`1<TextControlColumn> startColumn, Int32`1<TextControlLine> endLine, Int32`1<TextControlColumn> endColumn);
    public TextControlLineColumnRange(TextControlLineColumn pos);
    public static bool op_Equality(TextControlLineColumnRange left, TextControlLineColumnRange right);
    public static bool op_Inequality(TextControlLineColumnRange left, TextControlLineColumnRange right);
    public bool Contains(TextControlLineColumn pos);
    public bool ContainsLine(Int32`1<TextControlLine> line);
    public TextControlLineColumnRange ToNormalized();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(TextControlLineColumnRange other);
}
public class JetBrains.TextControl.TextControlOpenFileDescriptor : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <DocumentOffset>k__BackingField;
    public Nullable`1<int> DocumentOffset { get; }
    public TextControlOpenFileDescriptor(Nullable`1<int> documentOffset);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_DocumentOffset();
}
public static class JetBrains.TextControl.TextControlOptionsBinding : object {
    public static void BindOurPreferencesToOurOptions(Lifetime lifetime, TextControlPreferences preferences, ITextControlOptions options);
}
[RdModelAttribute]
public class JetBrains.TextControl.TextControlOverridableOption`1 : RdWireableBase {
    private LocalLazy`2<IProperty`1<TPrimitive>, TextControlOverridableOption`1<TPrimitive>> myEffective;
    public RdReflectProperty`1<TPrimitive> Original;
    public RdReflectProperty`1<Nullable`1<TPrimitive>> Override;
    public IProperty`1<TPrimitive> Effective { get; }
    public TextControlOverridableOption`1(PropertyId`1<TPrimitive> id, TPrimitive original, Nullable`1<TPrimitive> override);
    public IProperty`1<TPrimitive> get_Effective();
    [UsedImplicitlyAttribute]
public static TextControlOverridableOption`1<TPrimitive> Read(SerializationCtx ctx, UnsafeReader unreader, CtxReadDelegate`1<TPrimitive> _, CtxWriteDelegate`1<TPrimitive> __);
    public virtual string ToString();
    [UsedImplicitlyAttribute]
public static void Write(SerializationCtx ctx, UnsafeWriter unwriter, TextControlOverridableOption`1<TPrimitive> value);
    protected virtual void OnBindNested(Lifetime lifetime);
    protected virtual void OnPreBindNested(Lifetime lifetime);
}
public class JetBrains.TextControl.TextControlPreferences : object {
    [NotNullAttribute]
public IProperty`1<Nullable`1<bool>> HighlightCurrentLine;
    [NotNullAttribute]
public IProperty`1<Nullable`1<bool>> WrapLongLines;
    [NotNullAttribute]
public IProperty`1<Nullable`1<bool>> ShowWhiteSpaces;
    [NotNullAttribute]
public IProperty`1<Nullable`1<bool>> ShowLineNumbers;
    [NotNullAttribute]
public IProperty`1<Nullable`1<bool>> ShowHorizontalScrollbar;
    [NotNullAttribute]
public IProperty`1<Nullable`1<bool>> ShowVerticalScrollbar;
    [NotNullAttribute]
public IProperty`1<Nullable`1<VerticalScrollbarMode>> VerticalScrollbarMode;
    [NotNullAttribute]
public IProperty`1<Nullable`1<bool>> ShowZoomControl;
    [NotNullAttribute]
public IProperty`1<Nullable`1<double>> ZoomLevel;
    [NotNullAttribute]
public IProperty`1<Nullable`1<bool>> ShowFileHealthIndicator;
    [NotNullAttribute]
public IProperty`1<Nullable`1<bool>> ShowEditingContextMargin;
    [NotNullAttribute]
public IProperty`1<Nullable`1<bool>> DisableUndo;
    [NotNullAttribute]
public IProperty`1<Nullable`1<bool>> ReadOnly;
    [NotNullAttribute]
public IProperty`1<Nullable`1<bool>> AdjustHeightToContent;
    [NotNullAttribute]
public IProperty`1<Brush> Background;
    [NotNullAttribute]
public IProperty`1<Nullable`1<bool>> HideAllMargins;
    [NotNullAttribute]
public IProperty`1<Nullable`1<bool>> HideContextMenu;
    [NotNullAttribute]
public static TextControlPreferences OverridePreferencesLive(Lifetime lifetime, TextControlPreferences low, TextControlPreferences high);
}
[ShellComponentAttribute("10")]
public class JetBrains.TextControl.TextControlSchemeManager : object {
    private Lifetime myLifetime;
    private FontsManager myFontsManager;
    private ISettingsStore mySettingsStore;
    private SimpleSignal myColorsChanged;
    private TextControlPreferences myDefaultPreferences;
    public ISimpleSignal ColorsChanged { get; }
    public JetFont FontAttributes { get; }
    public JetRgbaColor ReadonlyBackground { get; }
    public JetRgbaColor CodeEditorBackground { get; }
    public JetRgbaColor CodeEditorForeground { get; }
    public JetRgbaColor CommentColor { get; }
    public JetRgbaColor PreprocessorKeywordColor { get; }
    public JetRgbaColor KeywordColor { get; }
    public JetRgbaColor StringColor { get; }
    public JetRgbaColor MethodColor { get; }
    public JetRgbaColor ParameterColor { get; }
    public JetRgbaColor TypeColor { get; }
    public TextControlSchemeManager(Lifetime lifetime, FontsManager fontsman, IColorThemeManager themeManager, ISettingsStore settingsStore);
    public sealed virtual ISimpleSignal get_ColorsChanged();
    public virtual TextControlPreferences GetDefaultPreferences();
    public virtual JetFont get_FontAttributes();
    public virtual JetRgbaColor get_ReadonlyBackground();
    public virtual JetRgbaColor get_CodeEditorBackground();
    public virtual JetRgbaColor get_CodeEditorForeground();
    public virtual JetRgbaColor get_CommentColor();
    public virtual JetRgbaColor get_PreprocessorKeywordColor();
    public virtual JetRgbaColor get_KeywordColor();
    public virtual JetRgbaColor get_StringColor();
    public virtual JetRgbaColor get_MethodColor();
    public virtual JetRgbaColor get_ParameterColor();
    public virtual JetRgbaColor get_TypeColor();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0(ColorTheme _);
}
public enum JetBrains.TextControl.TextControlScrollType : Enum {
    public int value__;
    public static TextControlScrollType DontCare;
    public static TextControlScrollType CenterInView;
    public static TextControlScrollType TopOfView;
    public static TextControlScrollType UpperHalf;
    public static TextControlScrollType LowerHalf;
    public static TextControlScrollType Smart;
    public static TextControlScrollType SmartDirectionalUp;
    public static TextControlScrollType SmartDirectionalDown;
}
public class JetBrains.TextControl.TextControlSelectionHelper : object {
    public static DocOffsetAndVirtualRange GetAnchorToActiveSpanForContinuousSelection(IList`1<DocOffsetAndVirtualRange> ranges);
}
[SettingsKeyAttribute("JetBrains.Application.Settings.WellKnownRootKeys.EnvironmentSettings", "JetBrains.TextControl.Resources.Strings", "TextEditorSettingsSettingDescription")]
public class JetBrains.TextControl.TextControlSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.TextControl.Resources.Strings", "WhetherToHighlightCurrentLineInTextEditorSettingDescription")]
public bool HighlightCurrentLine;
}
[RdModelAttribute]
[RdTypeAttribute]
public class JetBrains.TextControl.TextControlsManagement.TextControlTransportRoot : RdReflectionBindableBase {
    [NotNullAttribute]
public RdReflectPropertyBag PropertyBag;
    public RdReflectDictionaryEvents`2<RunningTextControlId, TransportTextControl> TransportTextControls;
}
[IsReadOnlyAttribute]
public class JetBrains.TextControl.Transport.DocOffsetAndVirtualRange : ValueType {
    public DocOffsetAndVirtual End;
    public DocOffsetAndVirtual Start;
    public DocOffsetAndVirtualRange(DocOffsetAndVirtual start, DocOffsetAndVirtual end);
    public FrugalLocalList`1<DocOffsetAndVirtual> GetRangeEnds();
    public static DocOffsetAndVirtualRange op_Implicit(TextRange rangeNonVirt);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.TextControl.Transport.DocOffsetAndVirtualRangeEx : object {
    [ExtensionAttribute]
public static TextRange ToNonVirtualRange(DocOffsetAndVirtualRange rangeVirt);
    [ExtensionAttribute]
public static TextRange ToNonVirtualRangeNormalized(DocOffsetAndVirtualRange rangeVirt);
}
[RdExtAttribute]
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.TextControl.Transport.RunningTransportTextControls : RdShellExtReflectionBindable {
    public RdReflectDictionaryEvents`2<RunningTextControlId, TransportTextControl> RunningTextControls;
    public TransportTextControl SampleTc;
    public UProperty`1<RdReflectSignal`1<int>> PropWithSig;
    public UProperty`1<HighlighterTransport> Prop;
    [CompilerGeneratedAttribute]
private RdReflectSignal`1<string> <Say>k__BackingField;
    [CompilerGeneratedAttribute]
private RdReflectSimpleSignal <Tick>k__BackingField;
    [CompilerGeneratedAttribute]
private RdReflectDictionaryEvents`2<int, string> <Map>k__BackingField;
    public RdReflectSignal`1<string> Say { get; }
    public RdReflectSimpleSignal Tick { get; }
    public RdReflectDictionaryEvents`2<int, string> Map { get; }
    public RunningTransportTextControls(Lifetime lifetime, IRdShell rd);
    [CompilerGeneratedAttribute]
public RdReflectSignal`1<string> get_Say();
    [CompilerGeneratedAttribute]
public RdReflectSimpleSignal get_Tick();
    [CompilerGeneratedAttribute]
public RdReflectDictionaryEvents`2<int, string> get_Map();
}
[IsReadOnlyAttribute]
public class JetBrains.TextControl.Transport.ScrollingRequest : ValueType {
    public ModificationStamp ModificationStamp;
    public DocOffsetAndVirtual Position;
    public TextControlScrollType ScrollType;
    public ScrollingRequest(DocOffsetAndVirtual position, ModificationStamp stamp, TextControlScrollType scrolltype);
    public sealed virtual bool Equals(ScrollingRequest other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ScrollingRequest left, ScrollingRequest right);
    public static bool op_Inequality(ScrollingRequest left, ScrollingRequest right);
}
public enum JetBrains.TextControl.Transport.TextControlActiveState : Enum {
    public int value__;
    public static TextControlActiveState Invisible;
    public static TextControlActiveState Visible;
    public static TextControlActiveState CurrentFrame;
    public static TextControlActiveState Focused;
}
[RdModelAttribute]
public class JetBrains.TextControl.Transport.TextControlOptions : RdReflectionBindableBase {
    public static int DefaultTabIndentSize;
    public TextControlOverridableOption`1<bool> FileHealthIndicator;
    public TextControlOverridableOption`1<bool> EditingContextMargin;
    public TextControlOverridableOption`1<bool> HighlightCurrentLine;
    public TextControlOverridableOption`1<bool> HorizontalScrollbar;
    public TextControlOverridableOption`1<int> IndentSize;
    public TextControlOverridableOption`1<bool> IsVirtualSpaceEnabled;
    public TextControlOverridableOption`1<bool> LineNumbers;
    public TextControlOverridableOption`1<bool> ReadOnly;
    public TextControlOverridableOption`1<bool> ShowErrorsOnVerticalScrollBar;
    public TextControlOverridableOption`1<int> TabSize;
    public TextControlOverridableOption`1<bool> UseTabs;
    public TextControlOverridableOption`1<bool> VerticalScrollbar;
    public TextControlOverridableOption`1<VerticalScrollbarMode> VerticalScrollbarMode;
    public TextControlOverridableOption`1<bool> WhiteSpaces;
    public TextControlOverridableOption`1<bool> WordWrap;
    public TextControlOverridableOption`1<bool> ZoomControl;
    public TextControlOverridableOption`1<double> ZoomLevel;
    public TextControlOverridableOption`1<bool> HideAllMargins;
    public TextControlOverridableOption`1<bool> HideContextMenu;
    private TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.FileHealthIndicator { get; }
    private TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.EditingContextMargin { get; }
    private TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.HighlightCurrentLine { get; }
    private TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.HorizontalScrollbar { get; }
    private TextControlOverridableOption`1<int> JetBrains.TextControl.ITextControlOptions.IndentSize { get; }
    private TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.IsVirtualSpaceEnabled { get; }
    private TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.LineNumbers { get; }
    private TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.ReadOnly { get; }
    private TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.ShowErrorsOnVerticalScrollBar { get; }
    private TextControlOverridableOption`1<int> JetBrains.TextControl.ITextControlOptions.TabSize { get; }
    private TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.UseTabs { get; }
    private TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.VerticalScrollbar { get; }
    private TextControlOverridableOption`1<VerticalScrollbarMode> JetBrains.TextControl.ITextControlOptions.VerticalScrollbarMode { get; }
    private TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.WhiteSpaces { get; }
    private TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.WordWrap { get; }
    private TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.ZoomControl { get; }
    private TextControlOverridableOption`1<double> JetBrains.TextControl.ITextControlOptions.ZoomLevel { get; }
    private TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.HideAllMargins { get; }
    private TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.HideContextMenu { get; }
    private static TextControlOptions();
    private sealed virtual override TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.get_FileHealthIndicator();
    private sealed virtual override TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.get_EditingContextMargin();
    private sealed virtual override TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.get_HighlightCurrentLine();
    private sealed virtual override TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.get_HorizontalScrollbar();
    private sealed virtual override TextControlOverridableOption`1<int> JetBrains.TextControl.ITextControlOptions.get_IndentSize();
    private sealed virtual override TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.get_IsVirtualSpaceEnabled();
    private sealed virtual override TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.get_LineNumbers();
    private sealed virtual override TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.get_ReadOnly();
    private sealed virtual override TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.get_ShowErrorsOnVerticalScrollBar();
    private sealed virtual override TextControlOverridableOption`1<int> JetBrains.TextControl.ITextControlOptions.get_TabSize();
    private sealed virtual override TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.get_UseTabs();
    private sealed virtual override TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.get_VerticalScrollbar();
    private sealed virtual override TextControlOverridableOption`1<VerticalScrollbarMode> JetBrains.TextControl.ITextControlOptions.get_VerticalScrollbarMode();
    private sealed virtual override TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.get_WhiteSpaces();
    private sealed virtual override TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.get_WordWrap();
    private sealed virtual override TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.get_ZoomControl();
    private sealed virtual override TextControlOverridableOption`1<double> JetBrains.TextControl.ITextControlOptions.get_ZoomLevel();
    private sealed virtual override TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.get_HideAllMargins();
    private sealed virtual override TextControlOverridableOption`1<bool> JetBrains.TextControl.ITextControlOptions.get_HideContextMenu();
}
[RdModelAttribute]
public class JetBrains.TextControl.Transport.TransportTextControl : RdReflectionBindableBase {
    public static TransactionReuseKey TmpAllSyncCallsTransactionReuseKey;
    public RdReflectProperty`1<DocOffsetAndVirtualRange[]> AwdSelection;
    [NotNullAttribute]
public RdReflectProperty`1<TextControlActiveState> BwdActiveState;
    [NotNullAttribute]
public RdReflectSyncCall`2<string, Missing> BwdExecuteActionHandlers;
    [NotNullAttribute]
public RdReflectSyncCall`2<char, Missing> BwdExecuteTypingHandlers;
    [NotNullAttribute]
public RdReflectProperty`1<ImmutableArray`1<TextRange>> BwdLargerCollapsedRegions;
    [NotNullAttribute]
public RdReflectProperty`1<TransportTextControlMouseAndModifierKeys> BwdMouseAndModifierKeys;
    [NotNullAttribute]
public RdReflectProperty`1<TextRange> BwdViewportRange;
    [NotNullAttribute]
public ErrorStripeTransport ErrorStripe;
    [NotNullAttribute]
public RdReflectDictionaryEvents`2<GuidIndex, string> FwdBatchUpdateRequests;
    [NotNullAttribute]
public RdReflectSyncCall`2<string, Missing> FwdEmulateAction;
    [NotNullAttribute]
public RdReflectRequestResponse`2<char, Missing> FwdEmulateTypingRequestResponse;
    [NotNullAttribute]
public RdReflectSyncCall`2<char, Missing> FwdEmulateTypingSync;
    [NotNullAttribute]
public RdReflectSimpleSignal FwdEnsureVisibleCaret;
    [NotNullAttribute]
public RdReflectSyncCall`2<Missing, Missing> FwdExecuteFinalActionHandler;
    public RdReflectSyncCall`2<Missing, Missing> FwdExecuteFinalTypingHandler;
    [NotNullAttribute]
public RdReflectSyncCall`2<Missing, Missing> FwdFillVirtualSpaceUntilCaret;
    public RdReflectSimpleSignal FwdFocus;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
public RdReflectProperty`1<ValueTuple`2<ScrollingRequest, Guid>> FwdScrollTo;
    [NotNullAttribute]
public RdReflectSimpleSignal FwdShow;
    public RdCall`2<Unit, RdAnchoringRect> FwdTmpCreateViewportAnchor;
    [NotNullAttribute]
public RdReflectSyncCall`2<Missing, RdReflectInProcessBlackBox`1<WindowFrame>> FwdTmpGetWindowFrame;
    [NotNullAttribute]
public RdCall`2<DocOffsetAndVirtual, Nullable`1<JetPhysicalRect>> FwdTmpOffsetToScreenPixels;
    public RdCall`2<JetPhysicalPoint, Nullable`1<DocOffsetAndVirtual>> FwdTmpScreenPixelsToOffset;
    public TextControlOptions Options;
    [NotNullAttribute]
public RdReflectPropertyBag PropertyBag;
    private static TransportTextControl();
}
[IsReadOnlyAttribute]
public class JetBrains.TextControl.Transport.TransportTextControlMouseAndModifierKeys : ValueType {
    [CompilerGeneratedAttribute]
private KeyStateMasks <KeysAndButtons>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JetPhysicalPoint> <ViewportPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DocOffsetAndVirtual> <DocumentPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ClickCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMouseOutsideTextExtent>k__BackingField;
    public KeyStateMasks KeysAndButtons { get; public set; }
    public Nullable`1<JetPhysicalPoint> ViewportPosition { get; public set; }
    public Nullable`1<DocOffsetAndVirtual> DocumentPosition { get; public set; }
    public UInt32 ClickCount { get; public set; }
    public bool IsMouseOutsideTextExtent { get; public set; }
    public TransportTextControlMouseAndModifierKeys(KeyStateMasks KeysAndButtons, Nullable`1<JetPhysicalPoint> ViewportPosition, Nullable`1<DocOffsetAndVirtual> DocumentPosition, UInt32 ClickCount, bool IsMouseOutsideTextExtent);
    [CompilerGeneratedAttribute]
public KeyStateMasks get_KeysAndButtons();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_KeysAndButtons(KeyStateMasks value);
    [CompilerGeneratedAttribute]
public Nullable`1<JetPhysicalPoint> get_ViewportPosition();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ViewportPosition(Nullable`1<JetPhysicalPoint> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DocOffsetAndVirtual> get_DocumentPosition();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DocumentPosition(Nullable`1<DocOffsetAndVirtual> value);
    [CompilerGeneratedAttribute]
public UInt32 get_ClickCount();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ClickCount(UInt32 value);
    [CompilerGeneratedAttribute]
public bool get_IsMouseOutsideTextExtent();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsMouseOutsideTextExtent(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TransportTextControlMouseAndModifierKeys left, TransportTextControlMouseAndModifierKeys right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TransportTextControlMouseAndModifierKeys left, TransportTextControlMouseAndModifierKeys right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TransportTextControlMouseAndModifierKeys other);
    [CompilerGeneratedAttribute]
public void Deconstruct(KeyStateMasks& KeysAndButtons, Nullable`1& ViewportPosition, Nullable`1& DocumentPosition, UInt32& ClickCount, Boolean& IsMouseOutsideTextExtent);
}
[FlagsAttribute]
public enum JetBrains.TextControl.VerticalScrollbarMode : Enum {
    public int value__;
    public static VerticalScrollbarMode Simple;
    public static VerticalScrollbarMode ShowAnnotations;
    public static VerticalScrollbarMode ShowChanges;
    public static VerticalScrollbarMode ShowMarks;
    public static VerticalScrollbarMode ShowErrors;
    public static VerticalScrollbarMode ShowCaretPosition;
    public static VerticalScrollbarMode UseMapMode;
    public static VerticalScrollbarMode ShowSourceImage;
    public static VerticalScrollbarMode ShowPreviewTooltip;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
