internal static class JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.BuildRefactoringModelUtil : object {
    [NotNullAttribute]
[PureAttribute]
public static ClrChangeSignatureModel Build(IParametersOwner parametersOwner, ISubstitution substitution, SignatureChange change);
}
public class JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.ChangeSignatureInfo : object {
    public IDeclaration Declaration;
    public RestoreSignatureInfo RestoreSignatureInfo;
    public SignatureChange SignatureChange;
    private IList`1<SignatureData> mySignatures;
    private bool myHasBaseMember;
    private DocumentRange JetBrains.ReSharper.InplaceRefactorings.IRefactoringInfo.AvailableInRange { get; }
    public string ContextActionTitle { get; }
    public ChangeSignatureInfo(IDeclaration declaration, bool hasBaseMember, IList`1<SignatureData> signatures, RestoreSignatureInfo restoreSignatureInfo);
    public bool MakesSenseToRunRefactoring();
    private sealed virtual override DocumentRange JetBrains.ReSharper.InplaceRefactorings.IRefactoringInfo.get_AvailableInRange();
    public sealed virtual IRefactoringWorkflow CreateRefactoringWorkflow();
    public sealed virtual string get_ContextActionTitle();
    public StringBuilder DumpSignatures(PsiLanguageType language);
}
internal static class JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.ChangeSignatureUtil : object {
    public static SignatureChange GetChangesBetweenSignatures(SignatureData oldSignature, SignatureData newSignature);
    private static int FindUniqueRenamedParameter(SignatureData oldSignature, SignatureData newSignature);
    private static int FindParameterIndex(ParameterData[] parameters, string name);
}
internal class JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.EditSignatureState : object {
    [NotNullAttribute]
private State myOwnerState;
    private bool myStartSignatureIsOk;
    private bool myHasBaseMember;
    [CanBeNullAttribute]
private SmartDeclarationPointer`1<IDeclaration> myDeclarationPointer;
    private SignatureKind mySignatureKind;
    [CanBeNullAttribute]
private List`1<SignatureData> mySignatures;
    private bool myIsEditingSignature;
    [CanBeNullAttribute]
private RestoreSignatureInfo myRestoreSignatureInfo;
    [CanBeNullAttribute]
private IRangeMarker mySignatureRange;
    [CanBeNullAttribute]
private List`1<IRangeMarker> myUsingListRanges;
    private bool myHadMeaningfulChanges;
    public bool IsEditingSignature { get; }
    private IDocument Document { get; }
    private ISolution Solution { get; }
    public EditSignatureState(State ownerState);
    public sealed virtual void Reset();
    public bool get_IsEditingSignature();
    public sealed virtual void OnBeforeDocumentChange(DocumentChange change, bool isPsiInSync);
    public sealed virtual void OnBeforeFirstPsiChange(ITreeNode changedElement);
    public sealed virtual void OnDocumentChange(DocumentChange change);
    private static IDeclaration GetDeclarationByChange(DocumentChange change, ISolution solution);
    private static IDeclaration GetDeclarationByChange(TreeTextRange treeRange, IFile psiFile);
    private static IDeclaration GetDeclarationByPsiChange(ITreeNode changedNode);
    private static IDeclaration GetDeclarationByNode(ITreeNode changedNode, Nullable`1<TreeTextRange> changedRange);
    public sealed virtual TextRange GetRangeToHighlight();
    [CanBeNullAttribute]
public ChangeSignatureInfo ToChangeSignatureInfo();
    private void SaveSignature(IDeclaration declaration);
    public static bool HasBaseMember(IDeclaration declaration);
    private IDocument get_Document();
    private ISolution get_Solution();
}
public class JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.InplaceChangeSignatureWorkflow : RefactoringWorkflowBase {
    private SmartDeclarationPointer`1<IDeclaration> myOriginalDeclarationPointer;
    private RestoreSignatureInfo myRestoreSignatureInfo;
    private ChangeSignatureRefactoring myRefactoring;
    private InplaceChangeSignaturePage myPage;
    private string mySignatureTextToRestore;
    [CompilerGeneratedAttribute]
private SignatureChange <SignatureChange>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrChangeSignatureModel <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private IChangeSignatureTestData <Data>k__BackingField;
    public string ActionId { get; }
    public IconId Icon { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public SignatureChange SignatureChange { get; }
    public ClrChangeSignatureModel Model { get; private set; }
    public string Title { get; }
    public IConflictSearcher ConflictSearcher { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public bool HasUI { get; }
    public HelpId HelpKeyword { get; }
    public IChangeSignatureTestData Data { get; public set; }
    public InplaceChangeSignatureWorkflow(ISolution solution, ChangeSignatureInfo info);
    public virtual string get_ActionId();
    public virtual IconId get_Icon();
    public virtual RefactoringActionGroup get_ActionGroup();
    [CompilerGeneratedAttribute]
public SignatureChange get_SignatureChange();
    [CompilerGeneratedAttribute]
public ClrChangeSignatureModel get_Model();
    [CompilerGeneratedAttribute]
private void set_Model(ClrChangeSignatureModel value);
    public virtual string get_Title();
    public virtual IConflictSearcher get_ConflictSearcher();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool Initialize(IDataContext context);
    public void RunActionWithOriginalSignature(Action`1<IDeclaredElement> action);
    public virtual bool get_HasUI();
    public virtual HelpId get_HelpKeyword();
    public virtual bool PreExecute(IProgressIndicator taskExecutorCreator);
    public virtual bool Execute(IProgressIndicator progressIndicator);
    [CompilerGeneratedAttribute]
public IChangeSignatureTestData get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(IChangeSignatureTestData value);
    public virtual bool PostExecute(IProgressIndicator pi);
    private IDeclaration RevertSignatureToOld(IDeclaration declaration);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private bool <PostExecute>b__40_0();
}
public interface JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.IVisualizationModelLanguageHelper {
    public bool ParameterTypeBeforeName { get; }
    public string ParameterTypeAndNameSeparator { get; }
    public bool ReturnTypeFirst { get; }
    public string ReturnTypeSeparator { get; }
    public bool SkipVoidReturnType { get; }
    public bool SkipEmptyParameterList { get; }
    public abstract virtual string StartKeyword(SignatureData signature);
    public abstract virtual bool get_ParameterTypeBeforeName();
    public abstract virtual string get_ParameterTypeAndNameSeparator();
    public abstract virtual string ParameterModifierText(ParameterKind kind, bool isParams, bool isVarArg, bool isThis);
    public abstract virtual bool get_ReturnTypeFirst();
    public abstract virtual string get_ReturnTypeSeparator();
    public abstract virtual bool get_SkipVoidReturnType();
    public abstract virtual bool get_SkipEmptyParameterList();
}
internal static class JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.ParameterArrowsOptimization : object {
    public static Boolean[] Optimize(SignatureChange change);
    private static void RestoreArrowsInSwaps(Boolean[] arrowsToDraw, Nullable`1[] parameterChanges);
    private static bool IsSwap(Nullable`1[] parameterChanges, int index1);
    private static int FromNewParameterIndex(SignatureChange change, int newIndex);
    private static Int32[] FindBestIncreasingSubsequence(Int32[] sequence, Comparison`1<Int32[]> comparison);
    private static void FindBestIncreasingSubsequence(Int32[] sequence, Comparison`1<Int32[]> comparison, Int32[][] endIndexToBestSubsequence, int endIndex);
    private static bool IsBetter(Int32[] subsequence1, Int32[] subsequence2, Comparison`1<Int32[]> comparison);
    private static int CalcTotalArrowsLength(Int32[] origins, Int32[] oldToNew);
}
public class JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.ParameterData : object {
    public string Name;
    public ParameterKind Kind;
    public bool IsParams;
    public bool IsVarArg;
    public bool IsThis;
    private ITypePointer myTypePointer;
    public DefaultValue DefaultValue;
    public IType Type { get; }
    public ParameterData(IType type, string name, ParameterKind kind, bool isParams, bool isVarArg, bool isThis, DefaultValue defaultValue);
    public IParameterValue GetDefaultValue(PsiLanguageType type);
    public IType get_Type();
    public bool IsValid();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string TestDump(PsiLanguageType language);
}
public class JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.RefactoringPage.Arrow : object {
    public Item SourceItem;
    public Item TargetItem;
    public Arrow(Item sourceItem, Item targetItem);
}
internal class JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.RefactoringPage.ClrInplaceChangeSignaturePageBehaviour : object {
    private InplaceChangeSignatureWorkflow myWorkflow;
    private PsiLanguageType myLanguage;
    public ClrInplaceChangeSignaturePageBehaviour(InplaceChangeSignatureWorkflow workflow, PsiLanguageType language);
    public sealed virtual VisualizationModel BuildVisualizationCanvas();
    public sealed virtual bool ShouldShowHierarchyUpdateDescription();
    [CanBeNullAttribute]
public sealed virtual IRefactoringPage CommitRefactoringPage(IProgressIndicator pi);
    public sealed virtual bool IsModelValid();
}
public class JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.RefactoringPage.CompositeItem : Item {
    public IList`1<Item> SubItems;
    public CompositeItem(ChangeSignatureState state, IList`1<Item> subItems);
    public virtual void TestDump(TextWriter builder);
}
public interface JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.RefactoringPage.IInplaceChangeSignaturePageBehaviour {
    public abstract virtual VisualizationModel BuildVisualizationCanvas();
    public abstract virtual bool ShouldShowHierarchyUpdateDescription();
    public abstract virtual IRefactoringPage CommitRefactoringPage(IProgressIndicator pi);
    public abstract virtual bool IsModelValid();
}
public class JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.RefactoringPage.InplaceChangeSignaturePage : SingleBeRefactoringPage {
    private IInplaceChangeSignaturePageBehaviour myBehaviour;
    private ApplyChangeSignatureModel myModel;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Title { get; }
    public string Description { get; protected set; }
    public InplaceChangeSignaturePage(IInplaceChangeSignaturePageBehaviour behaviour, Lifetime lifetime);
    public virtual string get_Title();
    private List`1<ChangeSignatureArrows> MakeArrows(ICollection`1<Arrow> arrows, HashMap`2<Item, int> itemToId);
    private List`1<ChangeSignatureItem> MakeItem(CompositeItem signature, HashMap`2<Item, int> itemToId);
    private void TransformItem(Item item, List`1<ChangeSignatureItem> result, HashMap`2<Item, int> itemToId);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    public virtual IRefactoringPage Commit(IProgressIndicator pi);
    public virtual BeControl GetPageContent();
    public virtual bool RefreshContents(IProgressIndicator progressIndicator);
}
public abstract class JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.RefactoringPage.Item : object {
    public ChangeSignatureState State;
    protected Item(ChangeSignatureState state);
    public abstract virtual void TestDump(TextWriter builder);
}
public class JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.RefactoringPage.LeafItem : Item {
    public string Text;
    public bool HasChanged;
    public bool IsBold;
    public LeafItem(string text, ChangeSignatureState state);
    public virtual void TestDump(TextWriter builder);
}
public class JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.RefactoringPage.VisualizationModel : AAutomation {
    public CompositeItem OldSignature;
    public CompositeItem NewSignature;
    public ICollection`1<Arrow> Arrows;
    public VisualizationModel(CompositeItem oldSignature, CompositeItem newSignature, ICollection`1<Arrow> arrows);
    public void TestDump(TextWriter builder);
    private static void BuildText(TextWriter builder, Item item);
    private static string CalcLocationString(Item item, CompositeItem container);
}
internal class JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.RefactoringPage.VisualizationModelBuilder : object {
    private SignatureChange myChange;
    private PsiLanguageType myLanguage;
    private SignatureData myOldSignature;
    private SignatureData myNewSignature;
    private IVisualizationModelLanguageHelper myLanguageHelper;
    private List`1<Item> myOldItems;
    private List`1<Item> myNewItems;
    private List`1<Arrow> myArrows;
    public VisualizationModelBuilder(SignatureChange change, PsiLanguageType language);
    public VisualizationModel BuildModel();
    private void AddType();
    private void AddName();
    private void AddParameters();
    private static Boolean[] CalcHiddenParameters(ParameterChangeSignatureState[] states);
    private static void AddParameterItems(CompositeItem[] items, Boolean[] hidden, List`1<Item> list);
    private CompositeItem BuildParameterItem(ParameterData data, LeafItem& kindItem, LeafItem& typeItem, LeafItem& nameItem);
    private string PresentType(IType type);
}
public class JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.RestoreSignatureInfo : object {
    private ITypePointer myTypePointer;
    private string myName;
    private string myParametersText;
    public RestoreSignatureInfo(IDeclaration declaration);
    public void RestoreSignature(IDeclaration declaration);
    private static TreeTextRange GetParameterListRange(IDeclaration declaration);
}
public class JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.SignatureChange : object {
    [CompilerGeneratedAttribute]
private SignatureData <OldSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureData <NewSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1[] <ParameterChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<NewParameter> <NewParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    private ITypePointer myNewReturnTypePointer;
    public SignatureData OldSignature { get; }
    public SignatureData NewSignature { get; }
    public Nullable`1[] ParameterChanges { get; }
    public ICollection`1<NewParameter> NewParameters { get; }
    public string NewName { get; }
    public IType NewReturnType { get; }
    public SignatureChange(SignatureData oldSignature, SignatureData newSignature, Nullable`1[] parameterChanges, ICollection`1<NewParameter> newParameters, string newName, IType newReturnType);
    [CompilerGeneratedAttribute]
public SignatureData get_OldSignature();
    [CompilerGeneratedAttribute]
public SignatureData get_NewSignature();
    [CompilerGeneratedAttribute]
public Nullable`1[] get_ParameterChanges();
    [CompilerGeneratedAttribute]
public ICollection`1<NewParameter> get_NewParameters();
    [CompilerGeneratedAttribute]
public string get_NewName();
    public IType get_NewReturnType();
    private void Check();
    public void TestDump(TextWriter writer, PsiLanguageType language);
    public static SignatureChange op_Addition(SignatureChange change1, SignatureChange change2);
    public bool MakesSenseToRunRefactoring(bool isMethodVirtual);
}
public class JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.SignatureData : object {
    public SignatureKind Kind;
    public string Name;
    public ParameterData[] Parameters;
    private ITypePointer myTypePointer;
    public bool IsCorrect;
    public IType Type { get; }
    public SignatureData(SignatureKind kind, string name, ParameterData[] parameters, IType type, bool isCorrect);
    public IType get_Type();
    public static SignatureData Build(IDeclaration declaration, IParametersOwner parametersOwner);
    [PureAttribute]
public static bool IsCorrectParametersOwner(IDeclaration declaration, IParametersOwner parametersOwner);
    public bool IsValid();
    public static bool CheckNoErrorElements(IDeclaration declaration);
    private static bool ContainsErrorElements(ITreeNode node, TreeTextRange nodeRange, TreeTextRange inRange);
    private static bool CheckNoDuplicatedParameters(IParametersOwner parametersOwner);
    private static bool CheckAllResolved(IParametersOwner parametersOwner);
    public bool Equals(SignatureData signature);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string TestDump(PsiLanguageType language);
}
public enum JetBrains.ReSharper.InplaceRefactorings.ChangeSignature.SignatureKind : Enum {
    public int value__;
    public static SignatureKind METHOD;
    public static SignatureKind CONSTRUCTOR;
    public static SignatureKind PROPERTY;
    public static SignatureKind INDEXER;
}
internal class JetBrains.ReSharper.InplaceRefactorings.ChangeType.EditTypeState : object {
    [NotNullAttribute]
private State myOwnerState;
    private bool myStartTypeIsOk;
    [CanBeNullAttribute]
private SmartDeclarationPointer`1<ITypeOwnerDeclaration> myDeclarationPointer;
    private DeclaredElementType myDeclarationKind;
    [CanBeNullAttribute]
private List`1<TypeEditPoint> myTypeEditPoints;
    [CanBeNullAttribute]
private IRangeMarker myTypeRange;
    [CanBeNullAttribute]
private List`1<IRangeMarker> myUsingListRanges;
    private bool myHadMeaningfulChanges;
    [NotNullAttribute]
private IDocument Document { get; }
    [NotNullAttribute]
private ISolution Solution { get; }
    public EditTypeState(State ownerState);
    private IDocument get_Document();
    private ISolution get_Solution();
    public sealed virtual void Reset();
    public sealed virtual void OnBeforeDocumentChange(DocumentChange change, bool isPsiInSync);
    public sealed virtual void OnBeforeFirstPsiChange(ITreeNode changedElement);
    public sealed virtual void OnDocumentChange(DocumentChange change);
    public sealed virtual TextRange GetRangeToHighlight();
    [CanBeNullAttribute]
public IRefactoringInfo ToChangeTypeInfo();
    private void SaveTypeEditPoint(ITypeOwnerDeclaration declaration);
    [CanBeNullAttribute]
[PureAttribute]
private static ITypeOwnerDeclaration GetDeclarationByDocumentChange(DocumentChange change, ISolution solution);
    [CanBeNullAttribute]
[PureAttribute]
private static ITypeOwnerDeclaration GetDeclarationByChange(TreeTextRange treeRange, IFile psiFile);
    [CanBeNullAttribute]
[PureAttribute]
private static ITypeOwnerDeclaration GetDeclarationByPsiChange(ITreeNode changedNode);
    [CanBeNullAttribute]
[PureAttribute]
private static ITypeOwnerDeclaration GetDeclarationByChangedNode(ITreeNode changedNode, Nullable`1<TreeTextRange> changedRange);
}
public interface JetBrains.ReSharper.InplaceRefactorings.ChangeType.IInplaceChangeTypeHelper {
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual ITypeOwnerDeclaration GetDeclarationByChangedNode(ITreeNode changedNode, Nullable`1<TreeTextRange> changedRange);
    [PureAttribute]
public abstract virtual TreeTextRange GetTypeRange(ITypeOwnerDeclaration declaration);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IRefactoringInfo TryCreateChangeTypeInfo(ITypeOwnerDeclaration declaration, IReadOnlyList`1<TypeEditPoint> typeEditPoints);
}
public class JetBrains.ReSharper.InplaceRefactorings.ChangeType.TypeEditPoint : object {
    [CompilerGeneratedAttribute]
private DeclaredElementType <OwnerElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOk>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypePointer <TypePointer>k__BackingField;
    [NotNullAttribute]
public DeclaredElementType OwnerElementType { get; }
    public bool IsOk { get; }
    [CanBeNullAttribute]
public ITypePointer TypePointer { get; }
    [CanBeNullAttribute]
public IType Type { get; }
    public TypeEditPoint(DeclaredElementType ownerElementType, IType type, bool isOk);
    [CompilerGeneratedAttribute]
public DeclaredElementType get_OwnerElementType();
    [CompilerGeneratedAttribute]
public bool get_IsOk();
    [CompilerGeneratedAttribute]
public ITypePointer get_TypePointer();
    public IType get_Type();
    [NotNullAttribute]
[PureAttribute]
public static TypeEditPoint Build(ITypeOwnerDeclaration declaration, IDeclaredElement declaredElement);
    public bool IsValid();
    public bool Equals(TypeEditPoint other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string TestDump(PsiLanguageType language);
}
[SolutionComponentAttribute("10")]
internal class JetBrains.ReSharper.InplaceRefactorings.CutCopyPaste.CopyPasteManager : object {
    [NotNullAttribute]
private ISolution mySolution;
    [NotNullAttribute]
private InplaceRefactoringsHighlightingManager myHighlightingManager;
    [NotNullAttribute]
private DocumentManager myDocumentManager;
    [NotNullAttribute]
private IPsiFiles myPsiFiles;
    [NotNullAttribute]
private Clipboard myClipboard;
    [CanBeNullAttribute]
private IRangeMarker myPastedMembersRange;
    [CanBeNullAttribute]
private ITreeNodePointer`1<ITypeDeclaration> myPastedMembersSourceTypePointer;
    private DateTime myLastCutEndTime;
    [CompilerGeneratedAttribute]
private PastedCodeRefsInfo <PastedCodeRefsInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ImportsForPastedCodeInProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPasteInProgress>k__BackingField;
    private SequentialLifetimes myCutOrCopyInfoLifetime;
    private CutOrCopyInfo myCutOrCopyInfo;
    public PastedCodeRefsInfo PastedCodeRefsInfo { get; private set; }
    public bool ImportsForPastedCodeInProgress { get; public set; }
    public bool IsPasteInProgress { get; private set; }
    public CopyPasteManager(Lifetime lifetime, ISolution solution, ClipboardManager clipboardManager, InplaceRefactoringsHighlightingManager highlightingManager, DocumentManager documentManager, ChangeManager changeManager, IPsiFiles psiFiles, Clipboard clipboard);
    [CompilerGeneratedAttribute]
public PastedCodeRefsInfo get_PastedCodeRefsInfo();
    [CompilerGeneratedAttribute]
private void set_PastedCodeRefsInfo(PastedCodeRefsInfo value);
    [CompilerGeneratedAttribute]
public bool get_ImportsForPastedCodeInProgress();
    [CompilerGeneratedAttribute]
public void set_ImportsForPastedCodeInProgress(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPasteInProgress();
    [CompilerGeneratedAttribute]
private void set_IsPasteInProgress(bool value);
    [NotNullAttribute]
public static CopyPasteManager GetInstance(ISolution solution);
    private void DoCopy(IDataContext context, DelegateExecute nextExecute);
    private void DoCut(IDataContext context, DelegateExecute nextExecute);
    private void DoCopyOrCut(IDataContext context, bool isCut, DelegateExecute nextExecute);
    [CanBeNullAttribute]
private static ReferencesData BuildReferencesData(IProjectFile projectFile, DocumentRange documentRange);
    private static bool CanMoveMembers(IList`1<ITypeMemberDeclaration> members, ISolution solution);
    private void DoPaste(IDataContext context, DelegateExecute nextExecute);
    [CanBeNullAttribute]
public IRefactoringInfo GetRefactoringInfo();
    [CanBeNullAttribute]
private IRefactoringInfo GetRefactoringInfoInternal();
    private void OnChange(ChangeEventArgs args);
    private void OnBeforeDocumentChanged(DocumentChange change);
    public void ClearPastedInfo();
    [CompilerGeneratedAttribute]
private void <DoCopyOrCut>b__27_1();
    [CompilerGeneratedAttribute]
private void <DoPaste>b__30_0();
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.InplaceRefactorings.CutCopyPaste.CopyPasteUtil : object {
    [CanBeNullAttribute]
public static IList`1<ITypeMemberDeclaration> MembersInRange(DocumentRange documentRange, IPsiSourceFile sourceFile, ITypeDeclaration& typeDeclaration);
    [CanBeNullAttribute]
private static IList`1<ITypeMemberDeclaration> MembersInRange(TreeTextRange range, ITypeDeclaration typeDeclaration);
    private static Locator`1<ITypeMemberDeclaration> CreateLocator(TreeTextRange range, bool searchFirst);
    private static Relation CalcMemberAndRangeRelation(ITypeMemberDeclaration declaration, TreeTextRange range);
    [ExtensionAttribute]
public static IEnumerable`1<IReference> EnumerateRefs(IProjectFile projectFile, DocumentRange documentRange);
    private static void CollectReferencesInRange(List`1<IReference> list, ITreeNode node, TreeTextRange treeTextRange, bool checkRange);
}
internal class JetBrains.ReSharper.InplaceRefactorings.CutCopyPaste.DummyReferenceData : ReferenceData {
    public DummyReferenceData(string referenceName);
    public virtual IDeclaredElement FindTarget(IPsiModule sourceModule, object context);
    public virtual NeedToBind NeedToBindInPastedCode(IReference reference, IDeclaredElement target);
}
public abstract class JetBrains.ReSharper.InplaceRefactorings.CutCopyPaste.ExtensionMethodImportOnPasteProviderBase : object {
    protected abstract virtual bool IsYourReference(IReference reference);
    protected abstract virtual ExtensionMethodReferenceData CreateReferenceData(string referenceName, IMethod targetExtensionMethod);
    public sealed virtual ReferenceData CreateReferenceData(IReference reference, ResolveResultWithInfo resolveResult);
}
public interface JetBrains.ReSharper.InplaceRefactorings.CutCopyPaste.IImportOnPasteProvider {
    [CanBeNullAttribute]
public abstract virtual ReferenceData CreateReferenceData(IReference reference, ResolveResultWithInfo resolveResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ContextActionAttribute]
public class JetBrains.ReSharper.InplaceRefactorings.CutCopyPaste.ImportsForPastedContextAction : object {
    [CompilerGeneratedAttribute]
private LanguageIndependentContextActionDataProvider <provider>P;
    private string JetBrains.ReSharper.Feature.Services.Bulbs.IPopupBulbAction.PopupMenuCaption { get; }
    [NullableAttribute("2")]
private string JetBrains.ReSharper.Feature.Services.Bulbs.IPopupBulbAction.PopupKey { get; }
    private Anchoring2D[] JetBrains.ReSharper.Feature.Services.Bulbs.IPopupBulbAction.PopupAnchorings { get; }
    private string JetBrains.ReSharper.Feature.Services.Bulbs.IBulbAction.Text { get; }
    public ImportsForPastedContextAction(LanguageIndependentContextActionDataProvider provider);
    public sealed virtual bool IsAvailable(IUserDataHolder cache);
    public sealed virtual IEnumerable`1<IBulbAction> CreateBulbActions();
    public sealed virtual IEnumerable`1<IntentionAction> CreateBulbItems();
    private sealed virtual override string JetBrains.ReSharper.Feature.Services.Bulbs.IPopupBulbAction.get_PopupMenuCaption();
    [NullableContextAttribute("2")]
private sealed virtual override string JetBrains.ReSharper.Feature.Services.Bulbs.IPopupBulbAction.get_PopupKey();
    private sealed virtual override Anchoring2D[] JetBrains.ReSharper.Feature.Services.Bulbs.IPopupBulbAction.get_PopupAnchorings();
    private sealed virtual override void JetBrains.ReSharper.Feature.Services.Bulbs.IPopupBulbAction.OnPopupShown(Lifetime showingLifetime);
    private sealed virtual override void JetBrains.ReSharper.Feature.Services.Bulbs.IPopupBulbAction.FillMenuItemDescriptor(IBulbAction key, IMenuItemDescriptor descriptor);
    private sealed virtual override string JetBrains.ReSharper.Feature.Services.Bulbs.IBulbAction.get_Text();
    private sealed virtual override void JetBrains.ReSharper.Feature.Services.Bulbs.IBulbAction.Execute(ISolution solution, ITextControl textControl);
    private static void BindRefs(IEnumerable`1<Tuple`3<IReference, IDeclaredElement, ReferenceData>> tuples, IPsiServices psiServices);
}
[SolutionComponentAttribute("16")]
internal class JetBrains.ReSharper.InplaceRefactorings.CutCopyPaste.NamespaceImportOnPasteProvider : object {
    public sealed virtual ReferenceData CreateReferenceData(IReference reference, ResolveResultWithInfo resolveResult);
}
public class JetBrains.ReSharper.InplaceRefactorings.CutCopyPaste.PastedCodeRefsInfo : object {
    [CompilerGeneratedAttribute]
private DocumentRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Tuple`3<IReference, IDeclaredElement, ReferenceData>> <Refs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public DocumentRange Range { get; }
    public List`1<Tuple`3<IReference, IDeclaredElement, ReferenceData>> Refs { get; }
    public string Text { get; }
    public PastedCodeRefsInfo(DocumentRange range, List`1<Tuple`3<IReference, IDeclaredElement, ReferenceData>> refs, string text);
    [CompilerGeneratedAttribute]
public DocumentRange get_Range();
    [CompilerGeneratedAttribute]
public List`1<Tuple`3<IReference, IDeclaredElement, ReferenceData>> get_Refs();
    [CompilerGeneratedAttribute]
public string get_Text();
}
[SolutionComponentAttribute("16")]
internal class JetBrains.ReSharper.InplaceRefactorings.CutCopyPaste.PathImportOnPasteProvider : object {
    public sealed virtual ReferenceData CreateReferenceData(IReference reference, ResolveResultWithInfo resolveResult);
}
public abstract class JetBrains.ReSharper.InplaceRefactorings.CutCopyPaste.ReferenceData : object {
    [CompilerGeneratedAttribute]
private string <ReferenceName>k__BackingField;
    public string ReferenceName { get; private set; }
    protected ReferenceData(string referenceName);
    [CompilerGeneratedAttribute]
public string get_ReferenceName();
    [CompilerGeneratedAttribute]
private void set_ReferenceName(string value);
    public abstract virtual IDeclaredElement FindTarget(IPsiModule sourceModule, object context);
    public virtual NeedToBind NeedToBindInPastedCode(IReference reference, IDeclaredElement target);
    public virtual bool BindReference(IReference reference, IDeclaredElement target);
}
internal class JetBrains.ReSharper.InplaceRefactorings.CutCopyPaste.ReferencesData : object {
    [CompilerGeneratedAttribute]
private List`1<ReferenceData> <Refs>k__BackingField;
    public List`1<ReferenceData> Refs { get; private set; }
    public ReferencesData(List`1<ReferenceData> refs);
    [CompilerGeneratedAttribute]
public List`1<ReferenceData> get_Refs();
    [CompilerGeneratedAttribute]
private void set_Refs(List`1<ReferenceData> value);
}
[SolutionComponentAttribute("16")]
internal class JetBrains.ReSharper.InplaceRefactorings.CutCopyPaste.TypeImportOnPasteProvider : object {
    public sealed virtual ReferenceData CreateReferenceData(IReference reference, ResolveResultWithInfo resolveResult);
}
public class JetBrains.ReSharper.InplaceRefactorings.CutCopyPaste.TypeReferenceData : ReferenceData {
    [NotNullAttribute]
private string myTargetTypeClrName;
    [NotNullAttribute]
private string myTargetModuleName;
    public TypeReferenceData(string referenceName, string targetTypeClrName, string targetModuleName);
    public virtual bool BindReference(IReference reference, IDeclaredElement target);
    public virtual IDeclaredElement FindTarget(IPsiModule sourceModule, object context);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.InplaceRefactorings.CutCopyPaste.TypeReferenceData/<GetSelfAndReferencedModules>d__5")]
[NotNullAttribute]
private static IEnumerable`1<IPsiModule> GetSelfAndReferencedModules(IPsiModule sourceModule);
}
[ContextActionAttribute]
public class JetBrains.ReSharper.InplaceRefactorings.DoInplaceRefactoringContextAction : DoInplaceRefactoringContextActionBase {
    public DoInplaceRefactoringContextAction(LanguageIndependentContextActionDataProvider provider);
    protected virtual IRefactoringInfo GetRefactoringInfo(InplaceRefactoringsManager manager, IPsiSourceFile sourceFile, DocumentRange selectionRange);
}
public abstract class JetBrains.ReSharper.InplaceRefactorings.DoInplaceRefactoringContextActionBase : object {
    [NotNullAttribute]
private LanguageIndependentContextActionDataProvider myDataProvider;
    protected DoInplaceRefactoringContextActionBase(LanguageIndependentContextActionDataProvider provider);
    [CanBeNullAttribute]
protected abstract virtual IRefactoringInfo GetRefactoringInfo(InplaceRefactoringsManager manager, IPsiSourceFile sourceFile, DocumentRange selectionRange);
    [CanBeNullAttribute]
protected IRefactoringInfo GetRefactoringInfo();
    public sealed virtual IEnumerable`1<IntentionAction> CreateBulbItems();
    public sealed virtual bool IsAvailable(IUserDataHolder cache);
}
[ContextActionAttribute]
public class JetBrains.ReSharper.InplaceRefactorings.DoInplaceRefactoringPopupContextAction : DoInplaceRefactoringContextActionBase {
    private string JetBrains.ReSharper.Feature.Services.Bulbs.IPopupBulbAction.PopupMenuCaption { get; }
    private string JetBrains.ReSharper.Feature.Services.Bulbs.IPopupBulbAction.PopupKey { get; }
    private Anchoring2D[] JetBrains.ReSharper.Feature.Services.Bulbs.IPopupBulbAction.PopupAnchorings { get; }
    private string Text { get; }
    public DoInplaceRefactoringPopupContextAction(LanguageIndependentContextActionDataProvider provider);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.InplaceRefactorings.DoInplaceRefactoringPopupContextAction/<CreateBulbActions>d__1")]
public sealed virtual IEnumerable`1<IBulbAction> CreateBulbActions();
    protected virtual IRefactoringInfo GetRefactoringInfo(InplaceRefactoringsManager manager, IPsiSourceFile sourceFile, DocumentRange selectionRange);
    private sealed virtual override string JetBrains.ReSharper.Feature.Services.Bulbs.IPopupBulbAction.get_PopupMenuCaption();
    private sealed virtual override string JetBrains.ReSharper.Feature.Services.Bulbs.IPopupBulbAction.get_PopupKey();
    private sealed virtual override Anchoring2D[] JetBrains.ReSharper.Feature.Services.Bulbs.IPopupBulbAction.get_PopupAnchorings();
    private sealed virtual override void JetBrains.ReSharper.Feature.Services.Bulbs.IPopupBulbAction.OnPopupShown(Lifetime showingLifetime);
    private sealed virtual override void JetBrains.ReSharper.Feature.Services.Bulbs.IPopupBulbAction.FillMenuItemDescriptor(IBulbAction key, IMenuItemDescriptor descriptor);
    private string get_Text();
}
internal class JetBrains.ReSharper.InplaceRefactorings.FileEditHandler : object {
    private IDocument myDocument;
    private InplaceRefactoringsHighlightingManager myHighlightingManager;
    private State myState;
    public IDocument Document { get; }
    public FileEditHandler(IPsiSourceFile sourceFile, IDocument document);
    public void Dispose();
    public IDocument get_Document();
    public IRefactoringInfo GetRefactoringInfo();
    public ChangeSignatureInfo GetChangeSignatureInfoNoChecks();
    public void OnBeforeDocumentChange(DocumentChange change);
    public void OnBeforePsiChange(ITreeNode changedElement);
    public void OnDocumentChange(DocumentChange change);
    private void UpdateHighlighting();
}
internal interface JetBrains.ReSharper.InplaceRefactorings.IInplaceEditState {
    public abstract virtual void OnBeforeDocumentChange(DocumentChange change, bool isPsiInSync);
    public abstract virtual void OnBeforeFirstPsiChange(ITreeNode changedElement);
    public abstract virtual void OnDocumentChange(DocumentChange change);
    [PureAttribute]
public abstract virtual TextRange GetRangeToHighlight();
    public abstract virtual void Reset();
}
public interface JetBrains.ReSharper.InplaceRefactorings.IInplaceRefactoringsLanguageSpecifics {
    public IVisualizationModelLanguageHelper VisualizationModelLanguageHelper { get; }
    public abstract virtual IEnumerable`1<DocumentRange> UsingListRanges(IFile file);
    public abstract virtual IVisualizationModelLanguageHelper get_VisualizationModelLanguageHelper();
    public abstract virtual SignatureKind GetSignatureKind(IDeclaration declaration);
    public abstract virtual bool IsInplaceRenameAvailable(IDeclaredElement declaredElement);
}
[RegisterHighlighterAttribute("ReSharper Name or Signature Changed")]
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.InplaceRefactorings.InplaceRefactoringsHighlightingManager : object {
    public static string ENTITY_EDITED_ATTRIBUTE_ID;
    protected static string ENTITY_EDITED_HIGHLIGHTER_KEY;
    private Lifetime myLifetime;
    [NotNullAttribute]
private DocumentManager myDocumentManager;
    [NotNullAttribute]
private IThreading myThreading;
    [NotNullAttribute]
private EscapeHandler myEscapeHandler;
    [CanBeNullAttribute]
private object myMarkerOwner;
    [CanBeNullAttribute]
protected IRangeMarker Marker;
    [CanBeNullAttribute]
protected IDocument DocumentWithHighlighter;
    protected DocumentRange RangeToHideMarker;
    public InplaceRefactoringsHighlightingManager(Lifetime lifetime, DocumentManager documentManager, IActionManager actionManager, IThreading threading);
    public static InplaceRefactoringsHighlightingManager GetInstance(ISolution solution);
    public IEnumerable`1<IHighlighter> GetHighlightersForTests(ITextControl textControl);
    public virtual void SetHighlighter(DocumentRange documentRange, object owner, bool handleEscape);
    private void UpdateHighlighter();
    protected static void SynchronizeHighlighter(IDocument document, string highlighterKey, string attributeId, HighlighterLayer layer, TextRange range);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.InplaceRefactorings.InplaceRefactoringsManager : object {
    private ISolution mySolution;
    private FileEditHandler myFileEditHandler;
    private IDocument myActiveDocument;
    private ITextControlManager myTextControlManager;
    private DocumentManager myDocumentManager;
    public InplaceRefactoringsManager(ISolution solution, ChangeManager changeManager, ITextControlManager textControlManager, DocumentManager documentManager, IPsiFiles psiFiles);
    [NotNullAttribute]
public static InplaceRefactoringsManager GetInstance(ISolution solution);
    internal ChangeSignatureInfo GetChangeSignatureInfoNoChecks();
    [CanBeNullAttribute]
public IRefactoringInfo GetRefactoringAvailable(IPsiSourceFile sourceFile, DocumentRange selectionRange);
    public IRefactoringInfo GetPopupRefactoringAvailable(IPsiSourceFile sourceFile, DocumentRange selectionRange);
    private static bool IsAvailable(IRefactoringInfo info, IPsiSourceFile sourceFile, DocumentRange selectionRange);
    private sealed virtual override void System.IDisposable.Dispose();
    public void Reset();
    private void OnActiveTextControlChanged();
    private void OnBeforeDocumentChanged(DocumentChange change);
    private void BeforePsiChanged(ITreeNode changedElement);
    private void CreateFileEditHandlerIfNeeded();
    private bool ShouldIgnoreDocumentChange(DocumentChange documentChange);
    private bool IsDocumentChangeFromSourceGeneratedDocument(DocumentChange documentChange);
    private bool IsDocumentChangeFromSharedDocument(DocumentChange documentChange);
    private void OnChange(ChangeEventArgs args);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.InplaceRefactorings.InplaceRefactoringsServices : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IInplaceChangeSignatureHelper GetInplaceChangeSignatureHelper(ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IInplaceChangeTypeHelper GetInplaceChangeTypeHelper(ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IInplaceMoveStaticMembersHelper GetInplaceMoveStaticMembersHelper(ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IInplaceRefactoringsLanguageSpecifics GetInplaceRefactoringsLanguageSpecifics(ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
private static T GetService(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static TreeTextRange GetSignatureRange(IDeclaration declaration);
    [ExtensionAttribute]
[PureAttribute]
public static TreeTextRange GetTypeRange(ITypeOwnerDeclaration declaration);
    [ExtensionAttribute]
[PureAttribute]
public static bool EndsWithErrorElement(ITreeNode node);
}
public interface JetBrains.ReSharper.InplaceRefactorings.IRefactoringInfo {
    public DocumentRange AvailableInRange { get; }
    public string ContextActionTitle { get; }
    public abstract virtual DocumentRange get_AvailableInRange();
    public abstract virtual string get_ContextActionTitle();
    [NotNullAttribute]
public abstract virtual IRefactoringWorkflow CreateRefactoringWorkflow();
}
public interface JetBrains.ReSharper.InplaceRefactorings.MoveStaticMembers.IInplaceMoveStaticMembersHelper {
    public abstract virtual ITypeMemberDeclaration AddMemberDeclaration(ITypeDeclaration typeDeclaration, ITypeMemberDeclaration memberDeclaration);
    public abstract virtual ITypeMemberDeclaration ReplaceMemberDeclaration(ITypeMemberDeclaration oldDeclaration, ITypeMemberDeclaration newDeclaration);
    public abstract virtual void DeleteMemberDeclaration(ITypeMemberDeclaration memberDeclaration);
}
internal class JetBrains.ReSharper.InplaceRefactorings.MoveStaticMembers.InplaceMoveStaticMembersWorkflow : MoveStaticMembersWorkflow {
    private IInplaceMoveStaticMembersHelper myLanguageHelper;
    private SmartDeclarationPointer`1<ITypeDeclaration> mySourceTypeDeclarationPointer;
    private List`1<Tuple`2<SmartDeclarationPointer`1<ITypeMemberDeclaration>, string>> myMemberDeclarationsAndOriginalNames;
    private HashSet`1<ITypeMember> myDummyMembersSet;
    private Key`1<ITypeMemberDeclaration> myOriginalDeclInDummyKey;
    public InplaceMoveStaticMembersWorkflow(ISolution solution, MoveStaticMembersInfo info, string actionId);
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool Initialize(IDataContext context);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool PostExecute(IProgressIndicator pi);
    private bool CreateDummyMembers();
    private void ReplaceMembersWithMovedDummies();
    [CompilerGeneratedAttribute]
private void <CreateRefactoring>b__9_0();
}
internal class JetBrains.ReSharper.InplaceRefactorings.MoveStaticMembers.MoveStaticMembersInfo : object {
    private DocumentRange myPastedCodeRange;
    private ICollection`1<ITypeMemberDeclaration> myMemberDeclarations;
    private ITypeDeclaration mySourceTypeDeclaration;
    private ITypeDeclaration myTargetTypeDeclaration;
    private DocumentRange JetBrains.ReSharper.InplaceRefactorings.IRefactoringInfo.AvailableInRange { get; }
    private string JetBrains.ReSharper.InplaceRefactorings.IRefactoringInfo.ContextActionTitle { get; }
    public ITypeDeclaration SourceTypeDeclaration { get; }
    public ITypeDeclaration TargetTypeDeclaration { get; }
    public IEnumerable`1<ITypeMemberDeclaration> MemberDeclarations { get; }
    public MoveStaticMembersInfo(DocumentRange pastedCodeRange, ITypeDeclaration sourceTypeDeclaration, ITypeDeclaration targetTypeDeclaration, ICollection`1<ITypeMemberDeclaration> memberDeclarations);
    private sealed virtual override DocumentRange JetBrains.ReSharper.InplaceRefactorings.IRefactoringInfo.get_AvailableInRange();
    private sealed virtual override string JetBrains.ReSharper.InplaceRefactorings.IRefactoringInfo.get_ContextActionTitle();
    private sealed virtual override IRefactoringWorkflow JetBrains.ReSharper.InplaceRefactorings.IRefactoringInfo.CreateRefactoringWorkflow();
    public ITypeDeclaration get_SourceTypeDeclaration();
    public ITypeDeclaration get_TargetTypeDeclaration();
    public IEnumerable`1<ITypeMemberDeclaration> get_MemberDeclarations();
}
internal static class JetBrains.ReSharper.InplaceRefactorings.MoveStaticMembers.MoveStaticMembersUtil : object {
}
internal class JetBrains.ReSharper.InplaceRefactorings.Rename.EditNameState : object {
    private State myOwnerState;
    private SmartDeclarationPointer`1<IDeclaration> myDeclarationPointer;
    private IDeclaredElementPointer`1<IDeclaredElement> myElementPointer;
    private IReferencePointer myReferencePointer;
    private string myInitalElementName;
    private string myInitalNameText;
    private DocumentChange myLastChange;
    private string myLastChangeRemovedText;
    [NotNullAttribute]
private RenameIdentifierMarker myNameEditedMarker;
    private Func`1<string> myNewNameGetter;
    private ISolution Solution { get; }
    public EditNameState(State ownerState);
    private ISolution get_Solution();
    public RenameInfo ToRenameInfo();
    public sealed virtual void Reset();
    public sealed virtual void OnBeforeDocumentChange(DocumentChange change, bool isPsiInSync);
    private void UpdateStateBeforeDocumentChange(DocumentChange change);
    public sealed virtual void OnBeforeFirstPsiChange(ITreeNode changedElement);
    public sealed virtual void OnDocumentChange(DocumentChange change);
    public sealed virtual TextRange GetRangeToHighlight();
    private DocumentRange GetNameRangeByChange(DocumentChange change, IReference& reference, IDeclaredElement& declaredElement, IDeclaration& declaration, PsiLanguageType& language, Func`2& elementPointerFactory, Func`1& newNameGetter);
    private IDeclaration FindDeclarationToRename(DocumentRange documentRange);
    private static IDeclaration FindDeclarationToRename(DocumentRange documentRange, ISolution solution);
    private IReference FindReferenceToRename(DocumentRange documentRange);
    [NotNullAttribute]
public static IReference[] FindFilteredReferencesAt(ITreeNode node, TreeTextRange treeTextRange, Func`2<ITreeNode, bool> suggestRenameTreeNode);
    [CompilerGeneratedAttribute]
private IDeclaredElementPointer`1<IDeclaredElement> <GetNameRangeByChange>b__20_0(RenameIdentifierMarker marker);
    [CompilerGeneratedAttribute]
private string <GetNameRangeByChange>b__20_1();
}
public class JetBrains.ReSharper.InplaceRefactorings.Rename.InplaceRenameTupleComponentWorkflow : RenameTupleComponentWorkflow {
    [NotNullAttribute]
private Func`1<bool> myRestoreNameAction;
    public InplaceRenameTupleComponentWorkflow(ISolution solution, string newName, Func`1<bool> restoreNameAction);
    public virtual bool Initialize(IDataContext context);
}
public class JetBrains.ReSharper.InplaceRefactorings.Rename.InplaceRenameWorkflow : RenameWorkflow {
    private IDeclaredElement myElement;
    private string myNewName;
    private Func`1<bool> myRestoreNameAction;
    private SmartDeclarationPointer`1<IDeclaration> myDeclarationPointer;
    private CustomRenameModel myModel;
    public InplaceRenameWorkflow(ISolution solution, IDeclaredElement element, string newName, Func`1<bool> restoreNameAction, IDeclaration declaration, string actionId);
    public virtual bool Initialize(IDataContext context);
    public virtual bool PostExecute(IProgressIndicator pi);
    public virtual bool IsAvailable(IDataContext context);
}
internal class JetBrains.ReSharper.InplaceRefactorings.Rename.RenameIdentifierMarker : object {
    public static RenameIdentifierMarker InvalidMarker;
    private IDocument myDocument;
    private TextRange myRange;
    private LanguageService myLanguageService;
    private ISolution mySolution;
    public TextRange Range { get; }
    public DocumentRange DocumentRange { get; }
    public RenameIdentifierMarker(IDocument document, TextRange range, LanguageService languageService, ISolution solution);
    private static RenameIdentifierMarker();
    public void OnDocumentChange(object sender, EventArgs`1<DocumentChange> args);
    public bool IsValid();
    public TextRange get_Range();
    public DocumentRange get_DocumentRange();
    public bool IsName(string text);
}
internal class JetBrains.ReSharper.InplaceRefactorings.Rename.RenameInfo : object {
    [NotNullAttribute]
private IDeclaredElement myElement;
    [NotNullAttribute]
private string myNewName;
    [NotNullAttribute]
private Func`1<bool> myRestoreNameAction;
    [CanBeNullAttribute]
private IDeclaration myDeclaration;
    [CompilerGeneratedAttribute]
private DocumentRange <AvailableInRange>k__BackingField;
    public DocumentRange AvailableInRange { get; }
    public string ContextActionTitle { get; }
    public RenameInfo(DocumentRange nameRange, IDeclaredElement element, IDeclaration declaration, string newName, Func`1<bool> restoreNameAction);
    [CompilerGeneratedAttribute]
public sealed virtual DocumentRange get_AvailableInRange();
    public sealed virtual IRefactoringWorkflow CreateRefactoringWorkflow();
    public sealed virtual string get_ContextActionTitle();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.KnownLanguage", "16")]
internal class JetBrains.ReSharper.InplaceRefactorings.Rename.RenameItemsProvider : ItemsProviderOfSpecificContext`1<IClrSpecificCodeCompletionContext> {
    public bool IsDynamic { get; }
    protected virtual bool AddLookupItems(IClrSpecificCodeCompletionContext context, IItemsCollector collector);
    public virtual bool get_IsDynamic();
    protected virtual bool IsAvailable(IClrSpecificCodeCompletionContext context);
}
internal class JetBrains.ReSharper.InplaceRefactorings.Rename.RenameLookupItem : object {
    private ITreeNode myNode;
    private LookupItemPlacement myPlacement;
    private IRangeMarker myMarker;
    public LookupItemPlacement Placement { get; public set; }
    public IconId Image { get; }
    public RichText DisplayName { get; }
    public RichText DisplayTypeName { get; }
    public bool CanShrink { get; }
    public bool IsDynamic { get; }
    public bool IgnoreSoftOnSpace { get; public set; }
    public bool IsStable { get; public set; }
    public int Identity { get; }
    public RenameLookupItem(ITreeNode node);
    public sealed virtual LookupItemPlacement get_Placement();
    public void set_Placement(LookupItemPlacement value);
    public sealed virtual bool AcceptIfOnlyMatched(LookupItemAcceptanceContext itemAcceptanceContext);
    public sealed virtual MatchingResult Match(PrefixMatcher prefixMatcher);
    public sealed virtual void Accept(ITextControl textControl, DocumentRange nameRange, LookupItemInsertType insertType, Suffix suffix, ISolution solution, bool keepCaretStill);
    public sealed virtual IconId get_Image();
    public sealed virtual RichText get_DisplayName();
    public sealed virtual RichText get_DisplayTypeName();
    public sealed virtual DocumentRange GetVisualReplaceRange(DocumentRange nameRange);
    public sealed virtual bool get_CanShrink();
    public sealed virtual bool Shrink();
    public sealed virtual void Unshrink();
    public sealed virtual bool get_IsDynamic();
    public sealed virtual bool get_IgnoreSoftOnSpace();
    public void set_IgnoreSoftOnSpace(bool value);
    public bool get_IsStable();
    public void set_IsStable(bool value);
    public sealed virtual int get_Identity();
}
public class JetBrains.ReSharper.InplaceRefactorings.Resources.RefactoringsInplaceThemedIcons : object {
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.ReSharper.InplaceRefactorings.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string CHangeSignature_Text { get; }
    public static string ReviewSignatureChanges_Text { get; }
    public static string PressNextToUpdateUsagesAndMethodsIn_Text { get; }
    public static string PressNextToUpdateUsagesToReflectThe_Text { get; }
    public static string ImportTypesForPastedCode_Text { get; }
    public static string ApplyChangeSignatureRefactoring_Text { get; }
    public static string ApplyMoveRefactoring_Text { get; }
    public static string ApplyRenameRefactoring_Text { get; }
    public static string ApplyInPlaceRefactoringContextAction_Description { get; }
    public static string ApplyInPlaceRefactoringContextAction_Name { get; }
    public static string ApplyInPlaceRefactoringPopupContextAction_Description { get; }
    public static string ApplyInPlaceRefactoringPopupContextAction_Name { get; }
    public static string ImportTypesForPastedCodeContextAction_Description { get; }
    public static string ImportTypesForPastedCodeContextAction_Name { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get_CHangeSignature_Text();
    public static string get_ReviewSignatureChanges_Text();
    public static string get_PressNextToUpdateUsagesAndMethodsIn_Text();
    public static string get_PressNextToUpdateUsagesToReflectThe_Text();
    public static string get_ImportTypesForPastedCode_Text();
    public static string get_ApplyChangeSignatureRefactoring_Text();
    public static string get_ApplyMoveRefactoring_Text();
    public static string get_ApplyRenameRefactoring_Text();
    public static string get_ApplyInPlaceRefactoringContextAction_Description();
    public static string get_ApplyInPlaceRefactoringContextAction_Name();
    public static string get_ApplyInPlaceRefactoringPopupContextAction_Description();
    public static string get_ApplyInPlaceRefactoringPopupContextAction_Name();
    public static string get_ImportTypesForPastedCodeContextAction_Description();
    public static string get_ImportTypesForPastedCodeContextAction_Name();
}
internal class JetBrains.ReSharper.InplaceRefactorings.State : object {
    [NotNullAttribute]
private ISolution mySolution;
    [NotNullAttribute]
public EditSignatureState EditSignatureState;
    [NotNullAttribute]
public EditNameState EditNameState;
    [NotNullAttribute]
public EditTypeState EditTypeState;
    private bool myHadPsiChanges;
    [CompilerGeneratedAttribute]
private IDocument <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    [NotNullAttribute]
public IDocument Document { get; }
    [NotNullAttribute]
public IPsiSourceFile SourceFile { get; }
    [NotNullAttribute]
public ISolution Solution { get; }
    public bool IsPsiInSync { get; }
    public State(IDocument document, IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
public IDocument get_Document();
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_SourceFile();
    public ISolution get_Solution();
    public bool get_IsPsiInSync();
    public void OnBeforeDocumentChange(DocumentChange change);
    public void OnBeforePsiChange(ITreeNode changedElement);
    public void OnDocumentChange(DocumentChange change);
    public TextRange GetRangeToHighlight();
    [CanBeNullAttribute]
public IRefactoringInfo GetRefactoringInfo();
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.InplaceRefactorings.Util : object {
    [ExtensionAttribute]
public static bool HasDuplicatedSignature(IDeclaration declaration);
    public static List`1<IRangeMarker> BuildUsingListMarkers(IFile file, IDocument document);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.InplaceRefactorings.ZoneMarker : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
