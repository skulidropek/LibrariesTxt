[SettingsKeyAttribute("JetBrains.ReSharper.Feature.Services.CodeCompletion.Settings.AutopopupEnabledSettingsKey", "JetBrains.ReSharper.Psi.Asm.Resources.Strings", "Asm_Setting_Description")]
public class JetBrains.ReSharper.Psi.Asm.CodeCompletion.AsmAutopopupEnabledSettingsKey : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Asm.Resources.Strings", "AsmAutopopup_Setting_OnIdentifierItemDescription")]
public AutopopupType OnIdent;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Asm.Resources.Strings", "AsmAutopopup_Setting_OnLabelDeclarationItemDescription")]
public AutopopupType OnLabelDeclaration;
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Asm.CodeCompletion.AsmCodeCompletionManager : LanguageSpecificCodeCompletionManager {
    public PsiLanguageType PsiLanguage { get; }
    public AsmCodeCompletionManager(CodeCompletionSettingsService codeCompletionSettings);
    public virtual SettingsScalarEntry GetSettingsEntry(ISettingsSchema settingsSchema);
    public virtual PsiLanguageType get_PsiLanguage();
}
[SettingsKeyAttribute("JetBrains.ReSharper.Feature.Services.CodeCompletion.Settings.IntelliSenseCompletingCharactersSettingsKey", "JetBrains.ReSharper.Psi.Asm.Resources.Strings", "Asm_Setting_Description")]
public class JetBrains.ReSharper.Psi.Asm.CodeCompletion.AsmCompletingCharactersSettingsKey : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Asm.Resources.Strings", "AsmCharsProvider_Setting_CompleteOnSpace")]
public bool CompleteOnSpace;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Asm.Resources.Strings", "AsmCharsProvider_Setting_NonCompletingCharacters")]
public string NonCompletingCharacters;
}
[IntellisensePartAttribute("16")]
internal class JetBrains.ReSharper.Psi.Asm.CodeCompletion.AsmCompletionCharsProviderWithSetting : CompletingCharsProviderWithSetting`2<AsmSpecificCodeCompletionContext, AsmCompletingCharactersSettingsKey> {
    protected virtual Expression`1<Func`2<AsmCompletingCharactersSettingsKey, bool>> GetCompleteOnSpaceSettingKey();
    protected virtual Expression`1<Func`2<AsmCompletingCharactersSettingsKey, string>> GetNonCompletingCharactersSettingKey();
    protected virtual bool IsApplicable(AsmSpecificCodeCompletionContext context);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Asm.CodeCompletion.AsmCompletionRanks : Enum {
    public byte value__;
    public static AsmCompletionRanks LocalEntity;
    public static AsmCompletionRanks GlobalEntity;
    public static AsmCompletionRanks Keyword;
    public static AsmCompletionRanks LowPriorityKeyword;
    public static AsmCompletionRanks UnderscoredKeyword;
    public static AsmCompletionRanks Text;
    public static AsmCompletionRanks HighPriority;
    public static AsmCompletionRanks NormalPriority;
    public static AsmCompletionRanks LowPriority;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Asm.CodeCompletion.AsmCompletionRanksEx : object {
    [ExtensionAttribute]
public static ulong ToRelevance(AsmCompletionRanks completionRank);
    [ExtensionAttribute]
public static AsmCompletionRanks WithPriority(AsmCompletionRanks completionRank, AsmCompletionRanks priority);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Asm.CodeCompletion.AutoCompletionStrategy.AsmAutomaticStrategyOnIdentifier : object {
    private SettingsScalarEntry mySettingsScalarEntry;
    public PsiLanguageType Language { get; }
    public bool ForceHideCompletion { get; }
    public AsmAutomaticStrategyOnIdentifier(ISettingsStore settingsStore);
    public sealed virtual AutopopupType IsEnabledInSettings(IContextBoundSettingsStore settingsStore, ITextControl textControl);
    public sealed virtual bool AcceptTyping(char c, ITextControl textControl, IContextBoundSettingsStore settingsStore);
    public sealed virtual bool ProcessSubsequentTyping(char c, ITextControl textControl);
    public sealed virtual bool AcceptsFile(IFile file, ITextControl textControl);
    public sealed virtual PsiLanguageType get_Language();
    public sealed virtual bool get_ForceHideCompletion();
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Asm.CodeCompletion.AutoCompletionStrategy.AsmAutomaticStrategyOnLabelDeclaration : object {
    private SettingsScalarEntry mySettingsScalarEntry;
    public PsiLanguageType Language { get; }
    public bool ForceHideCompletion { get; }
    public AsmAutomaticStrategyOnLabelDeclaration(ISettingsStore settingsStore);
    public sealed virtual AutopopupType IsEnabledInSettings(IContextBoundSettingsStore settingsStore, ITextControl textControl);
    public sealed virtual bool AcceptTyping(char c, ITextControl textControl, IContextBoundSettingsStore settingsStore);
    public sealed virtual bool ProcessSubsequentTyping(char c, ITextControl textControl);
    public sealed virtual bool AcceptsFile(IFile file, ITextControl textControl);
    public sealed virtual PsiLanguageType get_Language();
    public sealed virtual bool get_ForceHideCompletion();
}
internal static class JetBrains.ReSharper.Psi.Asm.CodeCompletion.AutoCompletionStrategy.AsmAutomaticStrategyUtils : object {
    public static TokenInfo GetTokenInfoUnderCaret(AsmFile file, ITextControl textControl);
    public static bool IsIdentifierLike(TokenInfo tokenInfo);
    public static bool IsLabelDeclaration(TokenInfo tokenInfo);
}
[IntellisensePartAttribute("16")]
public class JetBrains.ReSharper.Psi.Asm.CodeCompletion.Context.AsmCodeCompletionContextProvider : CodeCompletionContextProviderBase {
    public virtual bool IsApplicable(CodeCompletionContext context);
    public virtual ISpecificCodeCompletionContext GetCompletionContext(CodeCompletionContext context);
    private static bool CheckAvailability(ITreeNode node, TreeTextRange offsetRange);
}
internal static class JetBrains.ReSharper.Psi.Asm.CodeCompletion.Context.AsmCompletionContextAnalyzer : object {
    public static bool IsAtStartOfLine(ITreeNode parent, AsmTokenNodeType nodeType, ITreeNode leftSibling);
    public static bool IsAfterTimesDirective(ITreeNode parent, AsmTokenNodeType nodeType, ITreeNode leftSibling);
    public static bool IsAtPrefix(ITreeNode parent, AsmTokenNodeType nodeType, ITreeNode leftSibling);
    public static bool IsAtInstruction(ITreeNode parent, AsmTokenNodeType nodeType, ITreeNode leftSibling);
    public static bool IsAtPseudoInstruction(ITreeNode parent, AsmTokenNodeType nodeType, ITreeNode leftSibling);
    public static bool IsAtInstructionArgument(ITreeNode node, AsmTokenNodeType nodeType, Boolean& isPseudoInstruction);
    public static IEnumerable`1<string> GetPrefixesBefore(ITreeNode node);
    public static List`1<IAsmInstructionArgument> GetInstructionArgumentsBefore(ITreeNode node);
    [CanBeNullAttribute]
public static TAsmInstruction FindAsmInstructionNode(ITreeNode node, ITreeNode& instructionNodeChild);
}
internal class JetBrains.ReSharper.Psi.Asm.CodeCompletion.Context.AsmSpecificCodeCompletionContext : SpecificCodeCompletionContext {
    public ITreeNode NodeUnderCaret;
    public TextLookupRanges ItemTextLookupRanges;
    public AsmLanguageDialect LanguageDialect;
    public string ContextId { get; }
    public AsmSpecificCodeCompletionContext(CodeCompletionContext basicContext);
    private TextLookupRanges ComputeTextLookupRanges();
    private ITreeNode FindNodeUnderCaret();
    public virtual string get_ContextId();
}
[SettingsKeyAttribute("JetBrains.ReSharper.Feature.Services.CodeCompletion.Settings.IntellisenseEnabledSettingsKey", "JetBrains.ReSharper.Psi.Asm.Resources.Strings", "AsmAutopopup_Setting_OverrideVSIntelliSense")]
public class JetBrains.ReSharper.Psi.Asm.CodeCompletion.IntellisenseEnabledSettingAsm : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Asm.Resources.Strings", "Asm_Setting_Description")]
public bool IntellisenseEnabled;
}
internal class JetBrains.ReSharper.Psi.Asm.CodeCompletion.LookupItem.AsmKeywordLookupItem : AsmLookupItemBase {
    private Data myData;
    private bool myGrayed;
    public IconId Image { get; }
    public string Text { get; public set; }
    private AsmKeywordLookupItem(AsmSpecificCodeCompletionContext context, Data data, AsmCompletionRanks completionRank);
    public AsmKeywordLookupItem(AsmSpecificCodeCompletionContext context, Data data);
    public AsmKeywordLookupItem(AsmSpecificCodeCompletionContext context, Data data, AsmCompletionRanks rankPriority, bool grayed);
    public virtual MatchingResult Match(PrefixMatcher prefixMatcher);
    protected virtual void AcceptedCompletionPostActions(ITextControl textControl, DocumentRange nameRange, Suffix suffix, bool isAutomaticCompletion);
    protected virtual RichText GetDisplayName();
    public virtual IconId get_Image();
    public sealed virtual string get_Text();
    public sealed virtual void set_Text(string value);
}
[SolutionComponentAttribute("16")]
internal class JetBrains.ReSharper.Psi.Asm.CodeCompletion.LookupItem.AsmKeywordLookupItemCache : object {
    private Dictionary`2<KeywordCacheKey, Dictionary`2<string, Data>> myCache;
    private PsiIconManager myIconManager;
    private static HashSet`1<string> ourCommonKeywords;
    public AsmKeywordLookupItemCache(PsiIconManager iconManager);
    private static AsmKeywordLookupItemCache();
    private Dictionary`2<string, Data> GenerateKeywordCache(AsmDeclaredElementType declaredElementType, ICollection`1<KeywordType> keywordTypes, KeywordCacheKey cacheKey, AsmCompletionRanks completionRank);
    private IReadOnlyDictionary`2<string, Data> GetKeywordCache(AsmDeclaredElementType declaredElementType, ICollection`1<KeywordType> keywordTypes, KeywordCacheKey cacheKey, AsmCompletionRanks completionRank);
    private IReadOnlyDictionary`2<string, Data> GetKeywordCache(AsmDeclaredElementType declaredElementType, KeywordCacheKey cacheKey, AsmCompletionRanks completionRank);
    public IReadOnlyDictionary`2<string, Data> GetConstantKeywordCache(AsmKeywordSet keywordSet);
    public IReadOnlyDictionary`2<string, Data> GetDirectiveKeywordCache(AsmKeywordSet keywordSet);
    public IReadOnlyDictionary`2<string, Data> GetInstructionKeywordCache(AsmKeywordSet keywordSet);
    public IReadOnlyDictionary`2<string, Data> GetPrefixKeywordCache(AsmKeywordSet keywordSet);
    public IReadOnlyDictionary`2<string, Data> GetRegisterKeywordCache(AsmKeywordSet keywordSet);
    public IReadOnlyDictionary`2<string, Data> GetSegmentRegisterKeywordCache(AsmKeywordSet keywordSet);
    public IReadOnlyDictionary`2<string, Data> GetSizeKeywordCache(AsmKeywordSet keywordSet);
}
internal class JetBrains.ReSharper.Psi.Asm.CodeCompletion.LookupItem.AsmLabelLookupItem : AsmLookupItemBase {
    [CompilerGeneratedAttribute]
private IconId <Image>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private RichText <DisplayTypeName>k__BackingField;
    private bool myIsLocal;
    public IconId Image { get; }
    public string Text { get; public set; }
    public RichText DisplayTypeName { get; public set; }
    public AsmLabelLookupItem(AsmSpecificCodeCompletionContext context, string text, RichText displayTypeName);
    public AsmLabelLookupItem(AsmSpecificCodeCompletionContext context, string text, string displayTypeName);
    protected virtual RichText GetDisplayName();
    public virtual MatchingResult Match(PrefixMatcher prefixMatcher);
    public void SetRankPriority(AsmCompletionRanks priority);
    [CompilerGeneratedAttribute]
public virtual IconId get_Image();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Text();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Text(string value);
    [CompilerGeneratedAttribute]
public sealed virtual RichText get_DisplayTypeName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DisplayTypeName(RichText value);
}
internal abstract class JetBrains.ReSharper.Psi.Asm.CodeCompletion.LookupItem.AsmLookupItemBase : CppNoHotspotsLookupItem {
    protected AsmSpecificCodeCompletionContext Context;
    protected AsmCompletionRanks CompletionRank;
    protected AsmLookupItemBase(AsmSpecificCodeCompletionContext context);
    public virtual void Accept(ITextControl textControl, DocumentRange nameRange, LookupItemInsertType insertType, Suffix suffix, ISolution solution, bool keepCaretStill);
    private bool AcceptCompletion(Suffix suffix, bool isAutomaticCompletion);
    protected virtual void AcceptedCompletionPostActions(ITextControl textControl, DocumentRange nameRange, Suffix suffix, bool isAutomaticCompletion);
    protected void UpdatePlacement();
}
internal class JetBrains.ReSharper.Psi.Asm.CodeCompletion.LookupItem.AsmTextLookupItem : AsmLookupItemBase {
    [CompilerGeneratedAttribute]
private IconId <Image>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public IconId Image { get; }
    public string Text { get; public set; }
    public AsmTextLookupItem(AsmSpecificCodeCompletionContext context, string text);
    [CompilerGeneratedAttribute]
public virtual IconId get_Image();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Text();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Text(string value);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.Asm.Language.AsmLanguage", "16")]
internal class JetBrains.ReSharper.Psi.Asm.CodeCompletion.Provider.AsmConstantProvider : ItemsProviderOfSpecificContext`1<AsmSpecificCodeCompletionContext> {
    protected virtual bool IsAvailable(AsmSpecificCodeCompletionContext context);
    protected virtual bool AddLookupItems(AsmSpecificCodeCompletionContext context, IItemsCollector collector);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.Asm.Language.AsmLanguage", "16")]
internal class JetBrains.ReSharper.Psi.Asm.CodeCompletion.Provider.AsmDirectiveProvider : ItemsProviderOfSpecificContext`1<AsmSpecificCodeCompletionContext> {
    private static HashSet`1<string> ourAllowedDirectivesAfterStartOfLine;
    private static AsmDirectiveProvider();
    protected virtual bool IsAvailable(AsmSpecificCodeCompletionContext context);
    protected virtual bool AddLookupItems(AsmSpecificCodeCompletionContext context, IItemsCollector collector);
    private static IEnumerable`1<Data> ComputeAllowedPrefixes(AsmSpecificCodeCompletionContext context);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.Asm.Language.AsmLanguage", "16")]
internal class JetBrains.ReSharper.Psi.Asm.CodeCompletion.Provider.AsmInstructionProvider : ItemsProviderOfSpecificContext`1<AsmSpecificCodeCompletionContext> {
    protected virtual bool IsAvailable(AsmSpecificCodeCompletionContext context);
    protected virtual bool AddLookupItems(AsmSpecificCodeCompletionContext context, IItemsCollector collector);
    private static IEnumerable`1<Data> ComputeAllowedInstructionsFromPrefixes(AsmSpecificCodeCompletionContext context, IReadOnlyDictionary`2<string, Data> instructionsCache);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.Asm.Language.AsmLanguage", "16")]
internal class JetBrains.ReSharper.Psi.Asm.CodeCompletion.Provider.AsmLabelProvider : ItemsProviderOfSpecificContext`1<AsmSpecificCodeCompletionContext> {
    protected virtual bool IsAvailable(AsmSpecificCodeCompletionContext context);
    protected virtual bool AddLookupItems(AsmSpecificCodeCompletionContext context, IItemsCollector collector);
    private static IEnumerable`1<AsmLabelLookupItem> GenerateLabelLookupItemList(AsmSpecificCodeCompletionContext context);
    [CanBeNullAttribute]
private static string GetDisplayTypeNameForLabel(CppSmallList`1<IAsmLabelDefinition> labels);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.Asm.Language.AsmLanguage", "16")]
internal class JetBrains.ReSharper.Psi.Asm.CodeCompletion.Provider.AsmPrefixProvider : ItemsProviderOfSpecificContext`1<AsmSpecificCodeCompletionContext> {
    protected virtual bool IsAvailable(AsmSpecificCodeCompletionContext context);
    protected virtual bool AddLookupItems(AsmSpecificCodeCompletionContext context, IItemsCollector collector);
    private static IEnumerable`1<Data> ComputeAllowedPrefixes(AsmSpecificCodeCompletionContext context, IReadOnlyDictionary`2<string, Data> prefixesCache);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.Asm.Language.AsmLanguage", "16")]
internal class JetBrains.ReSharper.Psi.Asm.CodeCompletion.Provider.AsmRegisterProvider : ItemsProviderOfSpecificContext`1<AsmSpecificCodeCompletionContext> {
    protected virtual bool IsAvailable(AsmSpecificCodeCompletionContext context);
    protected virtual bool AddLookupItems(AsmSpecificCodeCompletionContext context, IItemsCollector collector);
    private static IEnumerable`1<Data> ComputeAllowedRegisters(AsmSpecificCodeCompletionContext context);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.Asm.Language.AsmLanguage", "16")]
internal class JetBrains.ReSharper.Psi.Asm.CodeCompletion.Provider.AsmSectionNameProvider : ItemsProviderOfSpecificContext`1<AsmSpecificCodeCompletionContext> {
    private static List`1<string> ourWellKnownSectionNames;
    private static AsmSectionNameProvider();
    protected virtual bool IsAvailable(AsmSpecificCodeCompletionContext context);
    protected virtual bool AddLookupItems(AsmSpecificCodeCompletionContext context, IItemsCollector collector);
    protected virtual LookupFocusBehaviour GetLookupFocusBehaviour(AsmSpecificCodeCompletionContext context);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.Asm.Language.AsmLanguage", "16")]
internal class JetBrains.ReSharper.Psi.Asm.CodeCompletion.Provider.AsmSegWrtProvider : ItemsProviderOfSpecificContext`1<AsmSpecificCodeCompletionContext> {
    private Data mySegItemData;
    private Data myWrtItemData;
    public AsmSegWrtProvider(PsiIconManager iconManager);
    protected virtual bool IsAvailable(AsmSpecificCodeCompletionContext context);
    protected virtual bool AddLookupItems(AsmSpecificCodeCompletionContext context, IItemsCollector collector);
    private void AddSegKeyword(AsmSpecificCodeCompletionContext context, IItemsCollector collector, ITreeNode nodeUnderCaret);
    private void AddWrtKeyword(AsmSpecificCodeCompletionContext context, IItemsCollector collector, ITreeNode nodeUnderCaret);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.Asm.Language.AsmLanguage", "16")]
internal class JetBrains.ReSharper.Psi.Asm.CodeCompletion.Provider.AsmSizeModifierProvider : ItemsProviderOfSpecificContext`1<AsmSpecificCodeCompletionContext> {
    private Data myStrictItemData;
    public AsmSizeModifierProvider(PsiIconManager iconManager);
    protected virtual bool IsAvailable(AsmSpecificCodeCompletionContext context);
    protected virtual bool AddLookupItems(AsmSpecificCodeCompletionContext context, IItemsCollector collector);
    private static void AddSizeKeywords(AsmSpecificCodeCompletionContext context, IItemsCollector collector);
    private void AddStrictKeyword(AsmSpecificCodeCompletionContext context, IItemsCollector collector);
}
[ContainsContextConsumerAttribute]
public class JetBrains.ReSharper.Psi.Asm.ContextHighlighters.AsmRegisterContextHighlighter : ContextHighlighterBase {
    [NotNullAttribute]
private AsmRegister myRegister;
    private static string HIGHLIGHTING_ID;
    internal AsmRegisterContextHighlighter(AsmRegister register);
    [CanBeNullAttribute]
[AsyncContextConsumerAttribute]
public static Action ProcessContext(Lifetime lifetime, HighlightingProlongedLifetime prolongedLifetime, IPsiDocumentRangeView psiDocumentRangeView);
    private static bool IsAvailable(IPsiSourceFile psiSourceFile);
    protected virtual void CollectHighlightings(IPsiDocumentRangeView psiDocumentRangeView, HighlightingsConsumer consumer);
    private static Nullable`1<AsmRegister> GetSelectedRegister(PsiFileView psiView);
}
[ContainsContextConsumerAttribute]
public class JetBrains.ReSharper.Psi.Asm.ContextHighlighters.AsmUsagesContextHighlighter : ContextHighlighterBase {
    [NotNullAttribute]
private IDeclaredElement myDeclaredElement;
    private static string HIGHLIGHTING_ID;
    internal AsmUsagesContextHighlighter(IDeclaredElement declaredElement);
    [CanBeNullAttribute]
[AsyncContextConsumerAttribute]
public static Action ProcessContext(Lifetime lifetime, HighlightingProlongedLifetime prolongedLifetime, IPsiDocumentRangeView psiDocumentRangeView);
    private static bool IsAvailable(IPsiSourceFile psiSourceFile);
    protected virtual void CollectHighlightings(IPsiDocumentRangeView psiDocumentRangeView, HighlightingsConsumer consumer);
    private static IDeclaredElement GetDeclaredElement(PsiFileView psiView);
    private static IDeclaredElement GetDeclaredElement(ITokenNode tokenNode);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.Asm.Language.AsmLanguage", "16")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.AsmDaemonBehaviour : object {
    public bool CanShowErrorBox { get; }
    public bool RunInSolutionAnalysis { get; }
    public bool RunInFindCodeIssues { get; }
    public virtual ErrorStripeRequestWithDescription InitialErrorStripe(IPsiSourceFile sourceFile);
    public virtual bool get_CanShowErrorBox();
    public virtual bool get_RunInSolutionAnalysis();
    public virtual bool get_RunInFindCodeIssues();
}
[RegisterStaticHighlightingsGroupAttribute("JetBrains.ReSharper.Psi.Asm.Resources.Strings", "AssemblerErrors_Text", "True")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup : object {
}
[DaemonStageAttribute("16")]
internal class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmErrorHighlightingStage : object {
    public sealed virtual IEnumerable`1<IDaemonStageProcess> CreateProcess(IDaemonProcess process, IContextBoundSettingsStore settings, DaemonProcessKind processKind);
    private IDaemonStageProcess CreateProcessForFile(IDaemonProcess process, IContextBoundSettingsStore settings, DaemonProcessKind processKind, AsmFile file);
}
[HighlightingSourceAttribute]
internal class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmErrorHighlightingStageProcess : object {
    [CompilerGeneratedAttribute]
private IDaemonProcess <DaemonProcess>k__BackingField;
    private IContextBoundSettingsStore mySettings;
    private AsmFile myFile;
    public IDaemonProcess DaemonProcess { get; }
    public AsmErrorHighlightingStageProcess(IDaemonProcess process, IContextBoundSettingsStore settings, AsmFile file);
    public sealed virtual void Execute(Action`1<DaemonStageResult> committer);
    private AsmOperandSize GetAllowedOperandSizeOfArgument(AsmStatement stmt);
    private bool IsArgumentCombinationIncorrect(InstructionGroup instructionGroup, IAsmInstructionArgument firstArgument, int numberOfArguments);
    private AsmOperandSize SizeOfLargestRegister(Value value);
    private bool IsOverflowInsideMemoryAccess(AsmStatement stmt, ITreeNode sizeKeywordInsideMemoryAccess, AsmIndirectionInstructionArgument argument, AsmOperandSize sizeKeywordOperandSize);
    private void ProcessArgumentsOfInstruction(IAsmInstruction instruction, DefaultHighlightingConsumer consumer);
    private void ProcessIndirectionInstructionArgument(AsmIndirectionInstructionArgument indirection, DefaultHighlightingConsumer consumer);
    private void ProcessInstruction(IAsmInstruction instruction, DefaultHighlightingConsumer consumer);
    private void ProcessProcessorModeDirective(AsmProcessorModeDirective processorModeDirective, DefaultHighlightingConsumer consumer);
    private void ProcessStatement(AsmStatement stmt, DefaultHighlightingConsumer consumer);
    private void ProcessParserError(ParserErrorInfo parserError, DefaultHighlightingConsumer consumer);
    private void ProcessLabel(AsmLabelDefinition label, DefaultHighlightingConsumer consumer);
    private string GetErrorMessage(ParserErrorKind errorKind);
    private void HighlightExprCalculationErrorsAndWarnings(IAsmExpr expr, DefaultHighlightingConsumer consumer);
    private void HighlightInvalidArgumentsCombination(ITreeNode instructionName, ArgumentCombinationType combinationType, IAsmInstructionArgument firstArgument, int numberOfArguments, DefaultHighlightingConsumer consumer);
    private void HighlightSizeKeywordsAndOverflowCheck(IAsmInstructionArgument firstArgument, DefaultHighlightingConsumer consumer);
    private bool TryHighlightMemoryAccessContainsInvalidRegistersOperandSize(AsmIndirectionInstructionArgument argument, AsmStatement stmt, DefaultHighlightingConsumer consumer);
    private bool TryHighlightMemoryAccessContainsOperandSizeErrors(AsmIndirectionInstructionArgument argument, DefaultHighlightingConsumer consumer);
    private bool TryHighlightAllSizeKeywordsAreIdentical(ITreeNode sizeKeyword, AsmOperandSize operandSizeToCompareWith, DefaultHighlightingConsumer consumer);
    private bool TryHighlight64BitOperandsIn32BitMode(IAsmInstruction instruction, IAsmInstructionArgument firstArgument, DefaultHighlightingConsumer consumer);
    private bool TryHighlightOperandSizeCanNotBeDerivedErrorOnSingleMemoryAccess(IAsmInstruction instruction, IAsmInstructionArgument argument, DefaultHighlightingConsumer consumer);
    private void TryHighlightOperandSizeMismatchOnBinaryInstruction(IAsmInstruction instruction, IAsmInstructionArgument firstArgument, DefaultHighlightingConsumer consumer);
    private void TryHighlightInvalidOperandSizeMov(IAsmInstruction instruction, IAsmInstructionArgument firstArgument, DefaultHighlightingConsumer consumer);
    private void TryHighlightInvalidOperandSizeMovzxMovsx(IAsmInstruction instruction, IAsmInstructionArgument firstArgument, DefaultHighlightingConsumer consumer, bool zeroExtension);
    private void TryHighlightInvalidOperandSizeMovsxd(IAsmInstruction instruction, IAsmInstructionArgument firstArgument, DefaultHighlightingConsumer consumer);
    private void TryHighlightInvalidOperandSizeImul(IAsmInstruction instruction, IAsmInstructionArgument firstArgument, DefaultHighlightingConsumer consumer);
    private void TryHighlightInvalidOperandSizeCmpxchg8b(IAsmInstructionArgument firstArgument, DefaultHighlightingConsumer consumer);
    private void TryHighlightInvalidOperandSizeShl(IAsmInstruction instruction, IAsmInstructionArgument firstArgument, DefaultHighlightingConsumer consumer);
    private void TryHighlightInvalidOperandSizeShld(IAsmInstruction instruction, IAsmInstructionArgument firstArgument, DefaultHighlightingConsumer consumer);
    private void TryHighlightInvalidArgumentsOperandSize(IAsmInstruction instruction, InstructionGroup instructionGroup, IAsmInstructionArgument firstArgument, int numberOfArguments, DefaultHighlightingConsumer consumer);
    private bool TryHighlightAddressSizeErrors(IAsmInstructionArgument firstArgument, DefaultHighlightingConsumer consumer);
    private bool TryHighlightRipRelativeAddressingPlacementErrors(IAsmInstructionArgument firstArgument, DefaultHighlightingConsumer consumer);
    private bool TryHighlightArgumentsErrorsFromCachedInfo(IAsmInstructionArgument firstArgument, DefaultHighlightingConsumer consumer);
    [CompilerGeneratedAttribute]
public sealed virtual IDaemonProcess get_DaemonProcess();
}
[StaticSeverityHighlightingAttribute("5", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmArgumentIsSupposedToBeError : object {
    private ITreeNode myInstructionName;
    private ITreeNode myArgument;
    private string myMessage;
    private string myArgumentIndex;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmArgumentIsSupposedToBeError(ITreeNode instructionName, ITreeNode argument, string message, int argumentIndex);
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
}
[StaticSeverityHighlightingAttribute("5", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmExprCalculationError : object {
    private DocumentRange myErrorRange;
    private string myErrorMessage;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmExprCalculationError(ExprCachedInfo cache);
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
}
[StaticSeverityHighlightingAttribute("4", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmExprCalculationWarning : object {
    private DocumentRange myErrorRange;
    private string myErrorMessage;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmExprCalculationWarning(ExprCachedInfo cache);
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
}
[StaticSeverityHighlightingAttribute("5", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmFirstArgumentMustBeRegisterError : object {
    private static string MESSAGE;
    private ITreeNode myInstructionName;
    private ITreeNode myArgument;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmFirstArgumentMustBeRegisterError(ITreeNode instructionName, ITreeNode argument);
    private static AsmFirstArgumentMustBeRegisterError();
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
}
[StaticSeverityHighlightingAttribute("5", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmInstructionMovsxdRequires32BitSourceError : object {
    private IAsmInstructionArgument myInstructionArgument;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmInstructionMovsxdRequires32BitSourceError(IAsmInstructionArgument instructionArgument);
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
}
[StaticSeverityHighlightingAttribute("5", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmInstructionMovsxdRequires64BitDestinationError : object {
    private IAsmInstructionArgument myInstructionArgument;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmInstructionMovsxdRequires64BitDestinationError(IAsmInstructionArgument instructionArgument);
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
}
[StaticSeverityHighlightingAttribute("5", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmInstructionMovzxDoesntAllowExtension32To64Error : object {
    private ITokenNode myInstructionName;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmInstructionMovzxDoesntAllowExtension32To64Error(ITokenNode instructionName);
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
}
[StaticSeverityHighlightingAttribute("5", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmInstructionRequiresDestinationLargerThanSourceError : object {
    private ITokenNode myInstructionName;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmInstructionRequiresDestinationLargerThanSourceError(ITokenNode instructionName);
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
}
[StaticSeverityHighlightingAttribute("5", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmInvalidCombinationOfArgumentsError : object {
    private static string MESSAGE;
    private static Dictionary`2<AsmOperandType, string> ArgumentTypeToString;
    private ITreeNode myInstructionName;
    private string myArgumentsCombination;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmInvalidCombinationOfArgumentsError(ITreeNode instructionName, AsmOperandType[] argumentsCombinations);
    private static AsmInvalidCombinationOfArgumentsError();
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
}
[StaticSeverityHighlightingAttribute("5", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmInvalidNumberOfOperandsError : object {
    private ITreeNode myInstructionName;
    private int myActualNumberOfArguments;
    private DocumentRange myDocumentRange;
    private InstructionGroup myInstructionGroup;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmInvalidNumberOfOperandsError(DocumentRange documentRange, InstructionGroup instructionGroup, ITreeNode instructionName, int actualNumberOfArguments);
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
    private static string ComputeFormatString(InstructionGroup g, int actualNumberOfArguments);
}
[StaticSeverityHighlightingAttribute("5", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmInvalidOperandSizeError : object {
    private ITreeNode myErrorNode;
    private string myError;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmInvalidOperandSizeError(ITreeNode errorNode, OperandSizeErrorOrWarningOrDeadCode error, AsmOperandSize operandSizeSupposedToBe, AsmOperandSize currentOperandSize);
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
}
[StaticSeverityHighlightingAttribute("4", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmInvalidOperandSizeWarning : object {
    private ITreeNode myErrorNode;
    private string myError;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmInvalidOperandSizeWarning(ITreeNode errorNode, OperandSizeErrorOrWarningOrDeadCode warning, AsmOperandSize operandSizeSupposedToBe);
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
}
[StaticSeverityHighlightingAttribute("5", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmInvalidProcessorModeDirectiveError : object {
    private ITreeNode myErrorNode;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmInvalidProcessorModeDirectiveError(ITreeNode errorNode);
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
}
[StaticSeverityHighlightingAttribute("5", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmLabelRedefinitionError : object {
    private static string MESSAGE;
    private AsmLabelDefinition myLabelDefinition;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmLabelRedefinitionError(AsmLabelDefinition labelDefinition);
    private static AsmLabelRedefinitionError();
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
}
[StaticSeverityHighlightingAttribute("5", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmMemoryAccessError : object {
    private DocumentRange myErrorRange;
    private string myErrorMessage;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmMemoryAccessError(MemoryAccessCachedInfo cache);
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
}
[StaticSeverityHighlightingAttribute("1", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmOperandSizeDeadCodeHighlighting : object {
    private ITreeNode myErrorNode;
    private string myError;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmOperandSizeDeadCodeHighlighting(ITreeNode node, OperandSizeErrorOrWarningOrDeadCode deadCode);
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
}
[StaticSeverityHighlightingAttribute("5", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmParserError : object {
    private DocumentRange myDocumentRange;
    private string myErrorMessage;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmParserError(DocumentRange documentRange, string errorMessage);
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
}
[StaticSeverityHighlightingAttribute("5", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmPtrKeywordNotAllowedError : object {
    private static string MESSAGE;
    private ITokenNode myKeywordNode;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmPtrKeywordNotAllowedError(ITokenNode keywordNode);
    private static AsmPtrKeywordNotAllowedError();
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
}
[StaticSeverityHighlightingAttribute("5", "JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.AsmCompilerErrorGroup")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.ErrorHighlightingStage.Errors.AsmRipRelativeAddressingPlacementError : object {
    private static string OUTSIDE_INDIRECTION_ARGUMENT_MESSAGE;
    private static string OUTSIDE_INDIRECTION_BRACKETS_MESSAGE;
    private ITokenNode myKeywordNode;
    private Kind myErrorKind;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    internal AsmRipRelativeAddressingPlacementError(ITokenNode keywordNode, Kind errorKind);
    private static AsmRipRelativeAddressingPlacementError();
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual bool IsValid();
}
internal static class JetBrains.ReSharper.Psi.Asm.Daemon.IdentifierHighlightingStage.AsmHighlightingAttributeIds : object {
    public static string LABEL;
    public static string REGISTER;
    public static string INSTRUCTION;
    public static string PREFIX;
    public static string SIZE_KEYWORD;
    public static string STRING;
    public static string NUMBER;
    public static string DATA_PSEUDO_INSTRUCTION;
    public static string CONSTANT_LABEL;
    public static string EQU_PSEUDO_INSTRUCTION;
    public static string SINGLE_LINE_COMMENT;
    public static string DIRECTIVE;
    public static string UNRESOLVED_IDENTIFIER;
    public static string CONSTANT_KEYWORD;
    public static string KEYWORD;
    public static string VARIABLE;
}
[RegisterHighlighterAttribute("ReSharper Assembler Label")]
[RegisterHighlighterAttribute("ReSharper Assembler Unresolved Identifier")]
[RegisterHighlighterAttribute("ReSharper Assembler Register")]
[RegisterHighlighterAttribute("ReSharper Assembler Instruction")]
[RegisterHighlighterAttribute("ReSharper Assembler Prefix")]
[RegisterHighlighterAttribute("ReSharper Assembler Word Size Keyword")]
[RegisterHighlighterAttribute("ReSharper Assembler String Literal")]
[RegisterHighlighterAttribute("ReSharper Assembler Numeric Literal")]
[RegisterHighlighterAttribute("ReSharper Assembler Comment")]
[RegisterHighlighterAttribute("ReSharper Assembler Data Pseudo Instruction")]
[RegisterHighlighterAttribute("ReSharper Assembler Equ Pseudo Instruction")]
[RegisterHighlighterAttribute("ReSharper Assembler Constant Label")]
[RegisterHighlighterAttribute("ReSharper Assembler Directive")]
[RegisterHighlighterAttribute("ReSharper Assembler Constant Keyword")]
[RegisterHighlighterAttribute("ReSharper Assembler Keyword")]
[RegisterHighlighterAttribute("ReSharper Assembler Variable")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.IdentifierHighlightingStage.AsmHighlightingAttributeRegistration : object {
}
[DaemonTooltipProviderAttribute("JetBrains.ReSharper.Psi.Asm.Daemon.IdentifierHighlightingStage.AsmIdentifierTooltipProvider")]
[StaticSeverityHighlightingAttribute("1", "JetBrains.ReSharper.Feature.Services.Daemon.HighlightingGroupIds/IdentifierHighlightings")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.IdentifierHighlightingStage.AsmIdentifierHighlighting : object {
    private DocumentRange myRange;
    [CompilerGeneratedAttribute]
private string <AttributeId>k__BackingField;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    public string AttributeId { get; }
    public AsmIdentifierHighlighting(string attributeId, DocumentRange range);
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    [CompilerGeneratedAttribute]
public sealed virtual string get_AttributeId();
    public sealed virtual bool IsValid();
    public sealed virtual DocumentRange CalculateRange();
}
[DaemonStageAttribute("16")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.IdentifierHighlightingStage.AsmIdentifierHighlightingStage : object {
    public sealed virtual IEnumerable`1<IDaemonStageProcess> CreateProcess(IDaemonProcess process, IContextBoundSettingsStore settings, DaemonProcessKind processKind);
    private IDaemonStageProcess CreateProcessForFile(IDaemonProcess process, IContextBoundSettingsStore settings, DaemonProcessKind processKind, AsmFile file);
}
[HighlightingSourceAttribute]
internal class JetBrains.ReSharper.Psi.Asm.Daemon.IdentifierHighlightingStage.AsmIdentifierHighlightingStageProcess : object {
    [CompilerGeneratedAttribute]
private IDaemonProcess <DaemonProcess>k__BackingField;
    private IContextBoundSettingsStore mySettings;
    private AsmFile myFile;
    public IDaemonProcess DaemonProcess { get; }
    public AsmIdentifierHighlightingStageProcess(IDaemonProcess process, IContextBoundSettingsStore settings, AsmFile file);
    public sealed virtual void Execute(Action`1<DaemonStageResult> committer);
    private void ProcessStatement(AsmStatement stmt, DefaultHighlightingConsumer consumer);
    private void HighlightBranch(ITreeNode node, DefaultHighlightingConsumer consumer);
    private string GetHighlightingForIdentifier(AsmIdentifierTokenNode token);
    private void ProcessLabel(AsmLabelDefinition label, DefaultHighlightingConsumer consumer);
    private bool TryGetHighlightForIdentifier(ITokenNode token, String& highlighting);
    private bool TryHighlightToken(ITokenNode token, DefaultHighlightingConsumer consumer);
    [CompilerGeneratedAttribute]
public sealed virtual IDaemonProcess get_DaemonProcess();
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Asm.Daemon.IdentifierHighlightingStage.AsmIdentifierTooltipProvider : IdentifierTooltipProvider`1<AsmLanguage> {
    public AsmIdentifierTooltipProvider(ISolution solution, IDeclaredElementDescriptionPresenter presenter, Lifetime lifetime, DeclaredElementPresenterTextStylesService textStylesService, IIdentifierTooltipSuppressor identifierTooltipSuppressor);
    protected virtual bool ShouldShowTooltip(IHighlighter highlighter);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.Asm.Language.AsmLanguage", "16")]
public class JetBrains.ReSharper.Psi.Asm.Debugger.AsmExpressionEvaluationInfoProvider : object {
    public sealed virtual EvaluationExpressionInfo FindExpression(IFile psiFile, DocumentRange range, EvaluationMode evaluationMode, IFile evaluationPointFile, DocumentOffset evaluationPointOffset, bool promoteToInvocation);
    public sealed virtual IEnumerable`1<EvaluationExpressionInfo> FindExpressions(IFile psiFile, DocumentRange range);
}
internal static class JetBrains.ReSharper.Psi.Asm.Debugger.AsmInstructionOperandUsage : object {
    private static AsmOperandUsageKind[] WO;
    private static AsmOperandUsageKind[] WO_RO;
    private static AsmOperandUsageKind[] WO_NU;
    private static AsmOperandUsageKind[] WO_RO_RO;
    private static Dictionary`2<MapKey, AsmOperandUsageKind[]> ourInstructionToOperandUsageKinds;
    private static AsmInstructionOperandUsage();
    public static AsmOperandUsageKind[] GetOperandUsage(AsmInstruction instruction);
    private static AsmOperandUsageKind[] GetUnknown(int nargs);
    private static bool IsZeroingIdiom(AsmInstruction instruction);
}
internal enum JetBrains.ReSharper.Psi.Asm.Debugger.AsmOperandUsageKind : Enum {
    public int value__;
    public static AsmOperandUsageKind READ_ONLY;
    public static AsmOperandUsageKind WRITE_ONLY;
    public static AsmOperandUsageKind RW;
    public static AsmOperandUsageKind NOT_USED;
}
public class JetBrains.ReSharper.Psi.Asm.Debugger.AsmValuesOfInterestCollector : object {
    private int myInitialLineNb;
    private int myCurrentLineNb;
    private HashSet`1<CollectedRegister> myCollectedRegisters;
    private List`1<CollectedMemoryAccess> myCollectedMemoryAccesses;
    private Nullable`1<CurrentConditionalInstruction> myCurrentConditionalInstruction;
    public static void CollectValues(AsmFile file, DocumentOffset offset, Flags cpuFlags, Int32& currentLineNb, HashSet`1& collectedRegisters, List`1& collectedMemoryAccesses, Nullable`1& currentConditionalInstruction);
    private void CollectValuesFor(AsmFile file, DocumentOffset offset, Flags cpuFlags);
    private void ProcessInstruction(AsmInstruction asmInstruction, AsmProcessorMode processorMode, Flags cpuFlags);
    private void ProcessConditionalInstruction(AsmInstruction instruction, Flags cpuFlags);
    private void ProcessInstructionArgument(AsmExprInstructionArgument instructionArgument, AsmOperandUsageKind usageKind);
    private void ProcessIndirectionInstructionArgument(AsmIndirectionInstructionArgument instructionArgument, AsmOperandUsageKind usageKind);
    private void ProcessImplicitRegistersInInstruction(AsmInstruction asmInstruction, AsmProcessorMode processorMode);
    private void AddImplicitRegisters(ImplicitRegister[] registers);
    private void AddCollectedRegister(AsmRegister register, AsmOperandUsageKind usageKind);
}
public class JetBrains.ReSharper.Psi.Asm.Language.AsmFilteringLexer : FilteringLexer {
    public AsmFilteringLexer(ILexer lexer);
    protected virtual bool Skip(TokenNodeType tt);
}
public enum JetBrains.ReSharper.Psi.Asm.Language.AsmKeywordSet : Enum {
    public int value__;
    public static AsmKeywordSet Nasm;
    public static AsmKeywordSet LldbDisassembly;
    public static AsmKeywordSet Polyglot;
}
[LanguageDefinitionAttribute("ASM")]
public class JetBrains.ReSharper.Psi.Asm.Language.AsmLanguage : UnmanagedKnownLanguage {
    [CompilerGeneratedAttribute]
private static AsmLanguage <Instance>k__BackingField;
    [CanBeNullAttribute]
[UsedImplicitlyAttribute]
public static AsmLanguage Instance { get; public set; }
    public PsiLanguageCategories SupportedCategories { get; }
    protected AsmLanguage(string name);
    protected AsmLanguage(string name, string presentableName);
    [CompilerGeneratedAttribute]
public static AsmLanguage get_Instance();
    [CompilerGeneratedAttribute]
public static void set_Instance(AsmLanguage value);
    public virtual PsiLanguageCategories get_SupportedCategories();
}
public class JetBrains.ReSharper.Psi.Asm.Language.AsmLanguageDialect : object {
    public AsmPtrKeywordMode PtrKeywordMode;
    public bool AllowFunctionSignaturesInLabels;
    public AsmProcessorMode DefaultProcessorMode;
    public AsmRipRelativeAddressingSyntax RipRelativeAddressingSyntax;
    public AsmKeywordSet KeywordSet;
    public static AsmLanguageDialect CreateForNasm(AsmProcessorMode defaultProcessorMode);
    public static AsmLanguageDialect CreateForLldbDisassembly(AsmProcessorMode defaultProcessorMode);
    public static AsmLanguageDialect CreatePolyglot();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.Asm.Language.AsmLanguage", "16")]
public class JetBrains.ReSharper.Psi.Asm.Language.AsmLanguageService : LanguageService {
    public static Key`1<AsmLanguageDialect> LANGUAGE_DIALECT_KEY;
    public bool IsCaseSensitive { get; }
    public ILanguageCacheProvider CacheProvider { get; }
    public bool SupportTypeMemberCache { get; }
    public ITypePresenter TypePresenter { get; }
    public bool ParticipatesInClrCaches { get; }
    public bool SandboxFilesParticipateInICache { get; }
    public AsmLanguageService(AsmLanguage language, IConstantValueService constantValueService);
    private static AsmLanguageService();
    public virtual bool get_IsCaseSensitive();
    public virtual IEnumerable`1<ITypeDeclaration> FindTypeDeclarations(IFile file);
    public virtual ILanguageCacheProvider get_CacheProvider();
    public virtual bool get_SupportTypeMemberCache();
    public virtual ITypePresenter get_TypePresenter();
    public virtual bool get_ParticipatesInClrCaches();
    public virtual bool get_SandboxFilesParticipateInICache();
    public virtual ILexerFactory GetPrimaryLexerFactory();
    public virtual ILexer CreateFilteringLexer(ILexer lexer);
    public virtual bool IsValidName(DeclaredElementType elementType, string name);
    public virtual IParser CreateParser(ILexer lexer, IPsiModule module, IPsiSourceFile sourceFile);
}
public class JetBrains.ReSharper.Psi.Asm.Language.AsmLexerFactory : object {
    public sealed virtual ILexer CreateLexer(IBuffer buffer);
}
public enum JetBrains.ReSharper.Psi.Asm.Language.AsmProcessorMode : Enum {
    public int value__;
    public static AsmProcessorMode Bits16;
    public static AsmProcessorMode Bits32;
    public static AsmProcessorMode Bits64;
    public static AsmProcessorMode BitsUndefined;
}
[ProjectFileTypeAttribute("JetBrains.ReSharper.Psi.Asm.ProjectModel.AsmProjectFileType", "16")]
public class JetBrains.ReSharper.Psi.Asm.Language.AsmProjectFileLanguageService : object {
    private AsmProjectFileType myAsmProjectFileType;
    public ProjectFileType LanguageType { get; }
    public IconId Icon { get; }
    public AsmProjectFileLanguageService(AsmProjectFileType projectFileType);
    public sealed virtual ProjectFileType get_LanguageType();
    public sealed virtual IconId get_Icon();
    public sealed virtual IPsiSourceFileProperties GetPsiProperties(IProjectFile projectFile, IPsiSourceFile sourceFile, IsCompileService isCompileService);
    public sealed virtual PsiLanguageType GetPsiLanguageType(IProjectFile projectFile);
    public sealed virtual PsiLanguageType GetPsiLanguageType(IPsiSourceFile sourceFile);
    public sealed virtual PsiLanguageType GetPsiLanguageType(ProjectFileType languageType);
    public sealed virtual ILexerFactory GetMixedLexerFactory(ISolution solution, IBuffer buffer, IPsiSourceFile sourceFile);
    public sealed virtual PreProcessingDirective[] GetPreprocessorDefines(IProject project, TargetFrameworkId targetFrameworkId);
}
public enum JetBrains.ReSharper.Psi.Asm.Language.AsmPtrKeywordMode : Enum {
    public int value__;
    public static AsmPtrKeywordMode Forbid;
    public static AsmPtrKeywordMode Allow;
    public static AsmPtrKeywordMode Requires;
}
public enum JetBrains.ReSharper.Psi.Asm.Language.AsmRipRelativeAddressingSyntax : Enum {
    public int value__;
    public static AsmRipRelativeAddressingSyntax Register;
    public static AsmRipRelativeAddressingSyntax NasmLike;
}
internal class JetBrains.ReSharper.Psi.Asm.Language.DeclaredElements.AsmDeclaredElementPresenter : object {
    public static AsmDeclaredElementPresenter INSTANCE;
    private static AsmDeclaredElementPresenter();
    public sealed virtual RichText Format(DeclaredElementPresenterStyle style, IDeclaredElement element, ISubstitution substitution, DeclaredElementPresenterMarking& marking);
    public sealed virtual string Format(ParameterKind parameterKind);
    public sealed virtual string Format(AccessRights accessRights);
    public sealed virtual string GetEntityKind(IDeclaredElement declaredElement);
}
internal class JetBrains.ReSharper.Psi.Asm.Language.DeclaredElements.AsmDeclaredElementType : DeclaredElementType {
    private IconId myIcon;
    [CompilerGeneratedAttribute]
private string <PresentableName>k__BackingField;
    public string PresentableName { get; }
    protected IDeclaredElementPresenter DefaultPresenter { get; }
    public AsmDeclaredElementType(string name, IconId icon);
    public virtual IconId GetImage();
    public virtual bool IsPresentable(PsiLanguageType language);
    [CompilerGeneratedAttribute]
public virtual string get_PresentableName();
    protected virtual IDeclaredElementPresenter get_DefaultPresenter();
}
internal static class JetBrains.ReSharper.Psi.Asm.Language.DeclaredElements.AsmDeclaredElementTypes : object {
    public static AsmDeclaredElementType INSTRUCTION;
    public static AsmDeclaredElementType DIRECTIVE;
    public static AsmDeclaredElementType LABEL;
    public static AsmDeclaredElementType LOCAL_LABEL;
    public static AsmDeclaredElementType PREFIX;
    public static AsmDeclaredElementType CONSTANT;
    public static AsmDeclaredElementType SIZE_SPECIFIER;
    public static AsmDeclaredElementType REGISTER;
    private static AsmDeclaredElementTypes();
}
internal class JetBrains.ReSharper.Psi.Asm.Language.DeclaredElements.AsmLabelDeclaredElement : object {
    public IPsiSourceFile PsiFile;
    public string Name;
    public string ProcName;
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public AsmLabelDeclaredElement(IPsiSourceFile psiFile, string name, string procName);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
}
internal class JetBrains.ReSharper.Psi.Asm.Language.NullParser : object {
    public static NullParser Instance;
    private static NullParser();
    public sealed virtual IFile ParseFile();
}
internal class JetBrains.ReSharper.Psi.Asm.Parsing.AsmCompositeNodeType : CompositeNodeType {
    public virtual CompositeElement Create();
}
internal class JetBrains.ReSharper.Psi.Asm.Parsing.AsmCompositeNodeTypes : object {
    public static AsmCompositeNodeType FILE;
    public static AsmCompositeNodeType STATEMENT;
    public static AsmCompositeNodeType LABEL_DEFINITION;
    public static AsmCompositeNodeType RECOVERY_JUNK;
    public static AsmCompositeNodeType CONDITIONAL_EXPR;
    public static AsmCompositeNodeType PAREN_EXPR;
    public static AsmCompositeNodeType UNARY_EXPR;
    public static AsmCompositeNodeType BINARY_EXPR;
    public static AsmCompositeNodeType DUP_EXPR;
    public static AsmCompositeNodeType SEGMENT_OVERRIDE;
    public static AsmCompositeNodeType INSTRUCTION;
    public static AsmCompositeNodeType TIMES_DIRECTIVE;
    public static AsmCompositeNodeType GLOBAL_DIRECTIVE;
    public static AsmCompositeNodeType SECTION_DIRECTIVE;
    public static AsmCompositeNodeType EXTERN_DIRECTIVE;
    public static AsmCompositeNodeType ABSOLUTE_DIRECTIVE;
    public static AsmCompositeNodeType REQUIRED_DIRECTIVE;
    public static AsmCompositeNodeType COMMON_DIRECTIVE;
    public static AsmCompositeNodeType STATIC_DIRECTIVE;
    public static AsmCompositeNodeType PUBLIC_DIRECTIVE;
    public static AsmCompositeNodeType PROCESSOR_MODE_DIRECTIVE;
    public static AsmCompositeNodeType PROC_DIRECTIVE;
    public static AsmCompositeNodeType ENDP_DIRECTIVE;
    public static AsmCompositeNodeType MASM_DOT_SEGMENT_DIRECTIVE;
    public static AsmCompositeNodeType END_DIRECTIVE;
    public static AsmCompositeNodeType EQU_PSEUDO_INSTRUCTION;
    public static AsmCompositeNodeType DATA_PSEUDO_INSTRUCTION;
    public static AsmCompositeNodeType EXPR_INSTRUCTION_ARGUMENT;
    public static AsmCompositeNodeType INDIRECTION_INSTRUCTION_ARGUMENT;
    public static AsmCompositeNodeType PAREN_LIST;
    public static AsmCompositeNodeType SYMBOL_SPECIFICATION;
    public static AsmCompositeNodeType DEMANGLED_NAME;
    private static AsmCompositeNodeTypes();
}
internal class JetBrains.ReSharper.Psi.Asm.Parsing.AsmExprTokenNode : AsmGenericTokenNode {
    private CppCachedReference`1<ExprCachedInfo> myCache;
    public bool ContainsRegister { get; }
    public ExprCachedInfo CachedInfo { get; }
    public AsmExprTokenNode(NodeType nodeType, string text);
    public sealed virtual bool get_ContainsRegister();
    public sealed virtual ExprCachedInfo get_CachedInfo();
}
internal class JetBrains.ReSharper.Psi.Asm.Parsing.AsmGenericTokenNode : AsmTokenNodeBase {
    private NodeType myNodeType;
    private string myText;
    public NodeType NodeType { get; }
    public AsmGenericTokenNode(NodeType nodeType, string text);
    public virtual string GetText();
    public virtual NodeType get_NodeType();
}
internal class JetBrains.ReSharper.Psi.Asm.Parsing.AsmIdentifierTokenNode : AsmTokenNodeBase {
    private string myText;
    private Reference modreq(System.Runtime.CompilerServices.IsVolatile) myReference;
    private CppCachedReference`1<ExprCachedInfo> myCache;
    public NodeType NodeType { get; }
    public bool ContainsRegister { get; }
    public ExprCachedInfo CachedInfo { get; }
    public AsmIdentifierTokenNode(string text);
    public virtual string GetText();
    public virtual NodeType get_NodeType();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual bool get_ContainsRegister();
    public sealed virtual ExprCachedInfo get_CachedInfo();
}
internal class JetBrains.ReSharper.Psi.Asm.Parsing.AsmKeywords : object {
    private static Dictionary`2<string, KeywordType> ourNasmKeywords;
    private static Dictionary`2<string, KeywordType> ourLldbDisassemblyKeywords;
    private static Dictionary`2<string, KeywordType> ourPolyglotKeywords;
    public static HashSet`1<KeywordType> AsmInstructionKeywordTypes;
    public static HashSet`1<KeywordType> AsmDirectiveKeywordTypes;
    private static AsmKeywords();
    private static Dictionary`2<string, KeywordType> ComputeKeywords(AsmKeywordSet keywordSet);
    private static void AddNasmSpecificKeywords(Dictionary`2<string, KeywordType> result);
    private static void AddLldbDisassemblySpecificKeywords(Dictionary`2<string, KeywordType> result);
    public static Dictionary`2<string, KeywordType> GetKeywords(AsmKeywordSet keywordSet);
    public static Dictionary`2<string, KeywordType> GetKeywords(AsmLanguageDialect dialect);
}
public class JetBrains.ReSharper.Psi.Asm.Parsing.AsmLexer : object {
    private TokenNodeType myCurrentTokenType;
    private int myTokenStart;
    private int myTokenEnd;
    private int myBufferEnd;
    private IBuffer myBuffer;
    private string myBufferText;
    public AsmLexerState CurrentPosition { get; public set; }
    private object JetBrains.ReSharper.Psi.Parsing.ILexer.CurrentPosition { get; private set; }
    public TokenNodeType TokenType { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public IBuffer Buffer { get; }
    public AsmLexer(IBuffer buffer);
    public sealed virtual void Start();
    public sealed virtual void Advance();
    private void LocateToken();
    public sealed virtual AsmLexerState get_CurrentPosition();
    public sealed virtual void set_CurrentPosition(AsmLexerState value);
    private sealed virtual override object JetBrains.ReSharper.Psi.Parsing.ILexer.get_CurrentPosition();
    private sealed virtual override void JetBrains.ReSharper.Psi.Parsing.ILexer.set_CurrentPosition(object value);
    public sealed virtual TokenNodeType get_TokenType();
    public sealed virtual int get_TokenStart();
    public sealed virtual int get_TokenEnd();
    public sealed virtual IBuffer get_Buffer();
    private static bool IsIdentifierTrail(char c);
    private static bool IsNumberTrail(char c);
    private static bool IsDigit(char c);
    private static bool IsBeforePlusMinus(char c);
    private static bool IsPlusMinus(char current, char previous);
    private int CountBackslashes();
}
public class JetBrains.ReSharper.Psi.Asm.Parsing.AsmLexerState : ValueType {
    public TokenNodeType CurrentTokenType;
    public int TokenStart;
    public int TokenEnd;
}
internal class JetBrains.ReSharper.Psi.Asm.Parsing.AsmNewLineNode : AsmTokenNodeBase {
    private string myText;
    public NodeType NodeType { get; }
    public bool IsNewLine { get; }
    public AsmNewLineNode(string text);
    public virtual string GetText();
    public virtual NodeType get_NodeType();
    public sealed virtual bool get_IsNewLine();
}
internal class JetBrains.ReSharper.Psi.Asm.Parsing.AsmNodeTypeCounter : object {
    private static int ourTokenTypeCounter;
    private static AsmNodeTypeCounter();
    public static int IncIndex();
}
internal class JetBrains.ReSharper.Psi.Asm.Parsing.AsmParser : object {
    private ILexer myLexer;
    private IPsiSourceFile mySourceFile;
    public AsmParser(ILexer lexer, IPsiSourceFile sourceFile);
    public sealed virtual IFile ParseFile();
    private AsmLanguageDialect ComputeLanguageDialect();
}
internal class JetBrains.ReSharper.Psi.Asm.Parsing.AsmParsing : object {
    public static AsmTokenNodeType[] BinaryOperators;
    public static AsmTokenNodeType[] UnaryOperators;
    public static KeywordType[] UseDirectives;
    private List`1<ParserErrorInfo> myErrors;
    private PsiBuilder myPsiBuilder;
    private AsmLanguageDialect myDialect;
    private Dictionary`2<string, KeywordType> myKeywords;
    private KeywordType myLastKeywordTypeOfIdentifier;
    public AsmParsing(PsiBuilder psiBuilder, AsmLanguageDialect dialect);
    private static AsmParsing();
    public void ParseFile();
    public List`1<ParserErrorInfo> GetErrors();
    private void RawAdvance();
    private void ResolveKeyword();
    private void Advance();
    private void AlterToken(AsmTokenNodeType newTokenType);
    private AsmTokenNodeType Tt();
    private string TokenText();
    private int GetCurrentLexeme();
    private TokenNodeType NextTt();
    private void SkipWhitespace();
    private bool IsLabel();
    private bool IsSpecifiedKeyword(KeywordType type);
    private bool IsSpecifiedKeyword(KeywordType[] types);
    private void ParseSimpleInstruction();
    private void ParseTimesDirective();
    private void ParseSectionDirective();
    private void ParseStatement();
    private void ParseInstruction();
    private void ParseEmptyDirective();
    private void ParseLabel();
    private void MarkError(ParserErrorKind errorKind);
    private void ParseDirectiveWithVariablesArgument();
    private void ParseCommonDirectiveArgument();
    private void ParseCommonDirective();
    private void ParseDirectiveWithVariables();
    private void ParseArguments();
    private void ParseDataPseudoInstructionArguments();
    private bool IsPtrKeyword();
    private void ParsePtrKeyword();
    private void ParseSizeKeywordsAndSegmentPrefixes();
    private bool ParseSizeKeywords();
    private bool IsSegmentOverride();
    private void ParseSegmentOverride();
    private void ParseArgument();
    private void ParseExprOrDup();
    private void ParseDataPseudoInstructionArgument();
    private void ParseParList();
    private void ParseLeafExpr();
    private void ParseConditionalExpr();
    private bool IsUnaryOperator();
    private bool IsBinaryOperator(AsmOperatorPrecedence precedence);
    private void ParseUnaryExpr();
    private void ParseUnaryOperator();
    private void ParseBinaryOperator();
    private void ParseBinaryExpr(AsmOperatorPrecedence currentPrecedence);
    private bool IsNewLine(TokenNodeType tt);
}
internal abstract class JetBrains.ReSharper.Psi.Asm.Parsing.AsmTokenNodeBase : LeafElementBase {
    public PsiLanguageType Language { get; }
    public virtual int GetTextLength();
    public virtual StringBuilder GetText(StringBuilder to);
    public virtual IBuffer GetTextAsBuffer();
    public virtual bool IsFiltered();
    public virtual PsiLanguageType get_Language();
    public virtual TokenNodeType GetTokenType();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Asm.Parsing.AsmTokenNodeType : TokenNodeType {
    [CompilerGeneratedAttribute]
private AsmOperatorPrecedence <Precedence>k__BackingField;
    public bool IsWhitespace { get; }
    public bool IsComment { get; }
    public bool IsStringLiteral { get; }
    public bool IsConstantLiteral { get; }
    public bool IsIdentifier { get; }
    public AsmOperatorPrecedence Precedence { get; }
    public bool IsUnaryOperator { get; }
    public bool IsKeyword { get; }
    public string TokenRepresentation { get; }
    public AsmTokenNodeType(string debugDescription, AsmOperatorPrecedence operatorPrecedence);
    public virtual bool get_IsWhitespace();
    public virtual bool get_IsComment();
    public virtual bool get_IsStringLiteral();
    public virtual bool get_IsConstantLiteral();
    public virtual bool get_IsIdentifier();
    [CompilerGeneratedAttribute]
public AsmOperatorPrecedence get_Precedence();
    public bool get_IsUnaryOperator();
    public virtual bool get_IsKeyword();
    public virtual string get_TokenRepresentation();
    public virtual LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
}
public class JetBrains.ReSharper.Psi.Asm.Parsing.AsmTokenNodeTypes : object {
    public static AsmTokenNodeType UNKNOWN_TOKEN;
    public static AsmTokenNodeType WHITE_SPACE;
    public static AsmTokenNodeType NEW_LINE;
    public static AsmTokenNodeType SINGLE_LINE_COMMENT;
    public static AsmTokenNodeType IDENTIFIER;
    public static AsmTokenNodeType INSTRUCTION;
    public static AsmTokenNodeType REGISTER;
    public static AsmTokenNodeType PREFIX;
    public static AsmTokenNodeType LABEL_DEFINITION_NAME;
    public static AsmTokenNodeType SECTION_NAME;
    public static AsmTokenNodeType DIRECTIVE_NAME;
    public static AsmTokenNodeType VARIABLE;
    public static AsmTokenNodeType SIZE_KEYWORD;
    public static AsmTokenNodeType PTR_KEYWORD;
    public static AsmTokenNodeType STRICT_KEYWORD;
    public static AsmTokenNodeType WRT_KEYWORD;
    public static AsmTokenNodeType SEG_KEYWORD;
    public static AsmTokenNodeType RIP_RELATIVE_SPECIFIER;
    public static AsmTokenNodeType COMMA;
    public static AsmTokenNodeType DOLLAR;
    public static AsmTokenNodeType DOUBLE_DOLLAR;
    public static AsmTokenNodeType PLUS;
    public static AsmTokenNodeType MINUS;
    public static AsmTokenNodeType ASTERISK;
    public static AsmTokenNodeType SLASH;
    public static AsmTokenNodeType DOUBLE_SLASH;
    public static AsmTokenNodeType TICK;
    public static AsmTokenNodeType XOR;
    public static AsmTokenNodeType AMPERSAND;
    public static AsmTokenNodeType AND;
    public static AsmTokenNodeType LBRACKET;
    public static AsmTokenNodeType RBRACKET;
    public static AsmTokenNodeType LPAR;
    public static AsmTokenNodeType RPAR;
    public static AsmTokenNodeType LBRACE;
    public static AsmTokenNodeType RBRACE;
    public static AsmTokenNodeType COLON;
    public static AsmTokenNodeType TILDE;
    public static AsmTokenNodeType EXCLAMATION_POINT;
    public static AsmTokenNodeType QUESTION_MARK;
    public static AsmTokenNodeType STICK;
    public static AsmTokenNodeType OR;
    public static AsmTokenNodeType SHIFT_LEFT;
    public static AsmTokenNodeType SHIFT_RIGHT;
    public static AsmTokenNodeType SHIFT_LEFT_LEFT;
    public static AsmTokenNodeType SHIFT_RIGHT_RIGHT;
    public static AsmTokenNodeType PERCENT;
    public static AsmTokenNodeType DOUBLE_PERCENT;
    public static AsmTokenNodeType NUMERIC_LITERAL;
    public static AsmTokenNodeType STRING_LITERAL;
    public static AsmTokenNodeType LESS;
    public static AsmTokenNodeType GREATER;
    public static AsmTokenNodeType LESS_OR_EQUAL;
    public static AsmTokenNodeType GREATER_OR_EQUAL;
    public static AsmTokenNodeType EQUAL;
    public static AsmTokenNodeType NOT_EQUAL;
    private static AsmTokenNodeTypes();
}
internal class JetBrains.ReSharper.Psi.Asm.Parsing.AsmVariableNode : AsmTokenNodeBase {
    private string myText;
    public IDeclaredElement DeclaredElement { get; }
    public string DeclaredName { get; }
    public NodeType NodeType { get; }
    public AsmVariableNode(string text);
    public virtual string GetText();
    public string GetFullName();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual void SetName(string name);
    public sealed virtual TreeTextRange GetNameRange();
    public sealed virtual bool IsSynthetic();
    public sealed virtual IDeclaredElement get_DeclaredElement();
    public sealed virtual string get_DeclaredName();
    public virtual NodeType get_NodeType();
}
internal class JetBrains.ReSharper.Psi.Asm.Parsing.AsmWhitespaceNode : AsmTokenNodeBase {
    private string myText;
    public NodeType NodeType { get; }
    public bool IsNewLine { get; }
    public AsmWhitespaceNode(string text);
    public virtual string GetText();
    public virtual NodeType get_NodeType();
    public sealed virtual bool get_IsNewLine();
}
public class JetBrains.ReSharper.Psi.Asm.Parsing.ParserErrorInfo : object {
    public int Offset;
    public ParserErrorKind Kind;
}
[ProjectFileTypeDefinitionAttribute("ASM")]
public class JetBrains.ReSharper.Psi.Asm.ProjectModel.AsmProjectFileType : KnownProjectFileType {
    public static string Name;
    private static String[] EXTENSIONS;
    [CompilerGeneratedAttribute]
private static AsmProjectFileType <Instance>k__BackingField;
    [CanBeNullAttribute]
[UsedImplicitlyAttribute]
public static AsmProjectFileType Instance { get; private set; }
    protected AsmProjectFileType(string name);
    protected AsmProjectFileType(string name, string presentableName);
    private static AsmProjectFileType();
    [CompilerGeneratedAttribute]
public static AsmProjectFileType get_Instance();
    [CompilerGeneratedAttribute]
private static void set_Instance(AsmProjectFileType value);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.ReSharper.Psi.Asm.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string AsmDeclaredElement_PresentableName_Instruction { get; }
    public static string AsmDeclaredElement_PresentableName_Directive { get; }
    public static string AsmDeclaredElement_PresentableName_Label { get; }
    public static string AsmDeclaredElement_PresentableName_LocalLabel { get; }
    public static string AsmDeclaredElement_PresentableName_Prefix { get; }
    public static string AsmDeclaredElement_PresentableName_Constant { get; }
    public static string AsmDeclaredElement_PresentableName_SizeSpecifier { get; }
    public static string AsmDeclaredElement_PresentableName_Register { get; }
    public static string AsmHighlighterPresentableName_Label { get; }
    public static string AsmHighlighterPresentableName_UnresolvedIdentifier { get; }
    public static string AsmHighlighterPresentableName_Register { get; }
    public static string AsmHighlighterPresentableName_Instruction { get; }
    public static string AsmHighlighterPresentableName_Prefix { get; }
    public static string AsmHighlighterPresentableName_SizeKeyword { get; }
    public static string AsmHighlighterPresentableName_String { get; }
    public static string AsmHighlighterPresentableName_Number { get; }
    public static string AsmHighlighterPresentableName_SingleLineComment { get; }
    public static string AsmHighlighterPresentableName_DataPseudoInstruction { get; }
    public static string AsmHighlighterPresentableName_EquPseudoInstruction { get; }
    public static string AsmHighlighterPresentableName_ConstantLabel { get; }
    public static string AsmHighlighterPresentableName_Directive { get; }
    public static string AsmHighlighterPresentableName_ConstantKeyword { get; }
    public static string AsmHighlighterPresentableName_Keyword { get; }
    public static string AsmHighlighterPresentableName_Variable { get; }
    public static string AsmParserError_ExpectedColon { get; }
    public static string AsmParserError_ExpectedComma { get; }
    public static string AsmParserError_ExpectedInstruction { get; }
    public static string AsmParserError_ExpectedInstructionOperand { get; }
    public static string AsmParserError_ExpectedNewLine { get; }
    public static string AsmParserError_ExpectedNumericLiteral { get; }
    public static string AsmParserError_ExpectedRBracket { get; }
    public static string AsmParserError_ExpectedRPar { get; }
    public static string AsmParserError_ExpectedLPar { get; }
    public static string AsmParserError_ExpectedIdentifier { get; }
    public static string AsmInvalidNumberOfOperandsError_0Singular { get; }
    public static string AsmInvalidNumberOfOperandsError_0Plural { get; }
    public static string AsmInvalidNumberOfOperandsError_1Plural { get; }
    public static string AsmInvalidNumberOfOperandsError_2Singular { get; }
    public static string AsmInvalidNumberOfOperandsError_2Plural { get; }
    public static string AsmInvalidNumberOfOperandsError_01Plural { get; }
    public static string AsmInvalidNumberOfOperandsError_12Plural { get; }
    public static string AsmInvalidNumberOfOperandsError_123Plural { get; }
    public static string AsmFirstArgumentMustBeRegisterError_Text { get; }
    public static string AsmArgumentIsSupposedToBeError_Gpr { get; }
    public static string AsmArgumentIsSupposedToBeError_GprOrMem { get; }
    public static string AsmArgumentIsSupposedToBeError_GprOrMemOrImm { get; }
    public static string AsmArgumentIsSupposedToBeError_GprOrSegOrMem { get; }
    public static string AsmArgumentIsSupposedToBeError_GprOrSegOrMemOrImm { get; }
    public static string AsmArgumentIsSupposedToBeError_Imm { get; }
    public static string AsmArgumentIsSupposedToBeError_Mem { get; }
    public static string AsmArgumentIsSupposedToBeError_AlAxEaxRegister { get; }
    public static string AsmArgumentIsSupposedToBeError_ClRegisterOrImm { get; }
    public static string AsmArgumentIsSupposedToBeError_DxRegisterOrImm { get; }
    public static string AsmInvalidCombinationOfArgumentsError_Text { get; }
    public static string AsmInvalidCombinationOfArgumentsError_GeneralRegister { get; }
    public static string AsmInvalidCombinationOfArgumentsError_MemoryAccess { get; }
    public static string AsmInvalidCombinationOfArgumentsError_SegmentRegister { get; }
    public static string AsmInvalidCombinationOfArgumentsError_Immediate { get; }
    public static string AsmInstructionRequiresDestinationLargerThanSourceError_Text { get; }
    public static string AsmInstructionMovsxdRequires64BitDestinationError_Text { get; }
    public static string AsmInstructionMovsxdRequires32BitSourceError_Text { get; }
    public static string AsmInstructionMovzxDoesntAllowExtension32To64Error_Text { get; }
    public static string AsmLabelRedefinitionError_MultipleDefinitionsOfLabel { get; }
    public static string AsmPtrKeywordNotAllowedError_MemoryAccessesMustHaveNoPtrKeyword { get; }
    public static string AsmAutopopup_Setting_OverrideVSIntelliSense { get; }
    public static string Asm_Setting_Description { get; }
    public static string AsmAutopopup_Setting_OnIdentifierItemDescription { get; }
    public static string AsmAutopopup_Setting_OnLabelDeclarationItemDescription { get; }
    public static string AsmCharsProvider_Setting_CompleteOnSpace { get; }
    public static string AsmCharsProvider_Setting_NonCompletingCharacters { get; }
    public static string AsmCharsProvider_Setting_EnterAction { get; }
    public static string AsmCharsProvider_Setting_TabAction { get; }
    public static string AsmExprCalculationError_OperationCanBeUsedOnlyWithConstantExpressions { get; }
    public static string AsmExprCalculationError_LeftHandSideOfConditionalExprMustBeConstantExpression { get; }
    public static string AsmExprCalculationError_InvalidRegister { get; }
    public static string AsmExprCalculationError_FloatingNumber { get; }
    public static string AsmExprCalculationError_InvalidNumberBinary { get; }
    public static string AsmExprCalculationError_InvalidNumberOctal { get; }
    public static string AsmExprCalculationError_InvalidNumberDecimal { get; }
    public static string AsmExprCalculationError_InvalidNumberHexadecimal { get; }
    public static string AsmExprCalculationError_DivisionByZero { get; }
    public static string AsmExprCalculationError_ImpossibleValueForCalculation { get; }
    public static string AsmExprCalculationError_QuotationMarkExpected { get; }
    public static string AsmExprCalculationWarning_InvalidStringLiteral { get; }
    public static string AsmExprCalculationWarning_NumericConstantIsTooLarge { get; }
    public static string AsmMemoryAccessError_XSP_RegisterCanNotBeUsedInMemoryAccess { get; }
    public static string AsmMemoryAccessError_InvalidFormOfMemoryAccessWithCalculatedExpr { get; }
    public static string AsmMemoryAccessError_InvalidFormOfMemoryAccess { get; }
    public static string AsmMemoryAccessError_InvalidCombinationOfRegisters { get; }
    public static string AsmProcessorModeError_InvalidProcessorModeDirective { get; }
    public static string AsmOperandSizeError_OperandSizeCanNotBeDerivedFromOperands { get; }
    public static string AsmOperandSizeError_DifferentOperandSizesOfOperands { get; }
    public static string AsmOperandSizeError_OperandSizeGreaterThanProcessorModeOfStatement { get; }
    public static string AsmOperandSizeDeadCode_RedundantSizeSpecification { get; }
    public static string AsmOperandSizeWarning_SizeSpecificationWillBeIgnored { get; }
    public static string AsmOperandSizeWarning_OverflowInImmediateValue { get; }
    public static string AsmOperandSizeError_InvalidSizeKeywordInMemoryAccessWithSpecification { get; }
    public static string AsmOperandSizeError_InvalidSizeKeywordInMemoryAccess { get; }
    public static string AsmOperandSizeError_SizeOfRegistersInMemoryAccessGreaterThenProcessorModeOfStatement { get; }
    public static string AsmRipRelativeAddressingPlacementError_MustBePlacedInMemoryAccess { get; }
    public static string AsmRipRelativeAddressingPlacementError_MustBePlacedInsideBrackets { get; }
    public static string AssemblerErrors_Text { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get_AsmDeclaredElement_PresentableName_Instruction();
    public static string get_AsmDeclaredElement_PresentableName_Directive();
    public static string get_AsmDeclaredElement_PresentableName_Label();
    public static string get_AsmDeclaredElement_PresentableName_LocalLabel();
    public static string get_AsmDeclaredElement_PresentableName_Prefix();
    public static string get_AsmDeclaredElement_PresentableName_Constant();
    public static string get_AsmDeclaredElement_PresentableName_SizeSpecifier();
    public static string get_AsmDeclaredElement_PresentableName_Register();
    public static string get_AsmHighlighterPresentableName_Label();
    public static string get_AsmHighlighterPresentableName_UnresolvedIdentifier();
    public static string get_AsmHighlighterPresentableName_Register();
    public static string get_AsmHighlighterPresentableName_Instruction();
    public static string get_AsmHighlighterPresentableName_Prefix();
    public static string get_AsmHighlighterPresentableName_SizeKeyword();
    public static string get_AsmHighlighterPresentableName_String();
    public static string get_AsmHighlighterPresentableName_Number();
    public static string get_AsmHighlighterPresentableName_SingleLineComment();
    public static string get_AsmHighlighterPresentableName_DataPseudoInstruction();
    public static string get_AsmHighlighterPresentableName_EquPseudoInstruction();
    public static string get_AsmHighlighterPresentableName_ConstantLabel();
    public static string get_AsmHighlighterPresentableName_Directive();
    public static string get_AsmHighlighterPresentableName_ConstantKeyword();
    public static string get_AsmHighlighterPresentableName_Keyword();
    public static string get_AsmHighlighterPresentableName_Variable();
    public static string get_AsmParserError_ExpectedColon();
    public static string get_AsmParserError_ExpectedComma();
    public static string get_AsmParserError_ExpectedInstruction();
    public static string get_AsmParserError_ExpectedInstructionOperand();
    public static string get_AsmParserError_ExpectedNewLine();
    public static string get_AsmParserError_ExpectedNumericLiteral();
    public static string get_AsmParserError_ExpectedRBracket();
    public static string get_AsmParserError_ExpectedRPar();
    public static string get_AsmParserError_ExpectedLPar();
    public static string get_AsmParserError_ExpectedIdentifier();
    public static string get_AsmInvalidNumberOfOperandsError_0Singular();
    public static string get_AsmInvalidNumberOfOperandsError_0Plural();
    public static string get_AsmInvalidNumberOfOperandsError_1Plural();
    public static string get_AsmInvalidNumberOfOperandsError_2Singular();
    public static string get_AsmInvalidNumberOfOperandsError_2Plural();
    public static string get_AsmInvalidNumberOfOperandsError_01Plural();
    public static string get_AsmInvalidNumberOfOperandsError_12Plural();
    public static string get_AsmInvalidNumberOfOperandsError_123Plural();
    public static string get_AsmFirstArgumentMustBeRegisterError_Text();
    public static string get_AsmArgumentIsSupposedToBeError_Gpr();
    public static string get_AsmArgumentIsSupposedToBeError_GprOrMem();
    public static string get_AsmArgumentIsSupposedToBeError_GprOrMemOrImm();
    public static string get_AsmArgumentIsSupposedToBeError_GprOrSegOrMem();
    public static string get_AsmArgumentIsSupposedToBeError_GprOrSegOrMemOrImm();
    public static string get_AsmArgumentIsSupposedToBeError_Imm();
    public static string get_AsmArgumentIsSupposedToBeError_Mem();
    public static string get_AsmArgumentIsSupposedToBeError_AlAxEaxRegister();
    public static string get_AsmArgumentIsSupposedToBeError_ClRegisterOrImm();
    public static string get_AsmArgumentIsSupposedToBeError_DxRegisterOrImm();
    public static string get_AsmInvalidCombinationOfArgumentsError_Text();
    public static string get_AsmInvalidCombinationOfArgumentsError_GeneralRegister();
    public static string get_AsmInvalidCombinationOfArgumentsError_MemoryAccess();
    public static string get_AsmInvalidCombinationOfArgumentsError_SegmentRegister();
    public static string get_AsmInvalidCombinationOfArgumentsError_Immediate();
    public static string get_AsmInstructionRequiresDestinationLargerThanSourceError_Text();
    public static string get_AsmInstructionMovsxdRequires64BitDestinationError_Text();
    public static string get_AsmInstructionMovsxdRequires32BitSourceError_Text();
    public static string get_AsmInstructionMovzxDoesntAllowExtension32To64Error_Text();
    public static string get_AsmLabelRedefinitionError_MultipleDefinitionsOfLabel();
    public static string get_AsmPtrKeywordNotAllowedError_MemoryAccessesMustHaveNoPtrKeyword();
    public static string get_AsmAutopopup_Setting_OverrideVSIntelliSense();
    public static string get_Asm_Setting_Description();
    public static string get_AsmAutopopup_Setting_OnIdentifierItemDescription();
    public static string get_AsmAutopopup_Setting_OnLabelDeclarationItemDescription();
    public static string get_AsmCharsProvider_Setting_CompleteOnSpace();
    public static string get_AsmCharsProvider_Setting_NonCompletingCharacters();
    public static string get_AsmCharsProvider_Setting_EnterAction();
    public static string get_AsmCharsProvider_Setting_TabAction();
    public static string get_AsmExprCalculationError_OperationCanBeUsedOnlyWithConstantExpressions();
    public static string get_AsmExprCalculationError_LeftHandSideOfConditionalExprMustBeConstantExpression();
    public static string get_AsmExprCalculationError_InvalidRegister();
    public static string get_AsmExprCalculationError_FloatingNumber();
    public static string get_AsmExprCalculationError_InvalidNumberBinary();
    public static string get_AsmExprCalculationError_InvalidNumberOctal();
    public static string get_AsmExprCalculationError_InvalidNumberDecimal();
    public static string get_AsmExprCalculationError_InvalidNumberHexadecimal();
    public static string get_AsmExprCalculationError_DivisionByZero();
    public static string get_AsmExprCalculationError_ImpossibleValueForCalculation();
    public static string get_AsmExprCalculationError_QuotationMarkExpected();
    public static string get_AsmExprCalculationWarning_InvalidStringLiteral();
    public static string get_AsmExprCalculationWarning_NumericConstantIsTooLarge();
    public static string get_AsmMemoryAccessError_XSP_RegisterCanNotBeUsedInMemoryAccess();
    public static string get_AsmMemoryAccessError_InvalidFormOfMemoryAccessWithCalculatedExpr();
    public static string get_AsmMemoryAccessError_InvalidFormOfMemoryAccess();
    public static string get_AsmMemoryAccessError_InvalidCombinationOfRegisters();
    public static string get_AsmProcessorModeError_InvalidProcessorModeDirective();
    public static string get_AsmOperandSizeError_OperandSizeCanNotBeDerivedFromOperands();
    public static string get_AsmOperandSizeError_DifferentOperandSizesOfOperands();
    public static string get_AsmOperandSizeError_OperandSizeGreaterThanProcessorModeOfStatement();
    public static string get_AsmOperandSizeDeadCode_RedundantSizeSpecification();
    public static string get_AsmOperandSizeWarning_SizeSpecificationWillBeIgnored();
    public static string get_AsmOperandSizeWarning_OverflowInImmediateValue();
    public static string get_AsmOperandSizeError_InvalidSizeKeywordInMemoryAccessWithSpecification();
    public static string get_AsmOperandSizeError_InvalidSizeKeywordInMemoryAccess();
    public static string get_AsmOperandSizeError_SizeOfRegistersInMemoryAccessGreaterThenProcessorModeOfStatement();
    public static string get_AsmRipRelativeAddressingPlacementError_MustBePlacedInMemoryAccess();
    public static string get_AsmRipRelativeAddressingPlacementError_MustBePlacedInsideBrackets();
    public static string get_AssemblerErrors_Text();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.Asm.Language.AsmLanguage", "16")]
public class JetBrains.ReSharper.Psi.Asm.SelectEmbracingConstruct.AsmSelectEmbracingConstructProvider : object {
    public sealed virtual bool IsAvailable(IPsiSourceFile sourceFile);
    private ITreeNode FindNodeAt(IFile file, TreeTextRange treeTextRange);
    public sealed virtual ISelectedRange GetSelectedRange(IPsiSourceFile sourceFile, DocumentRange documentRange);
}
internal class JetBrains.ReSharper.Psi.Asm.SelectEmbracingConstruct.AsmTextRangeSelection : object {
    [CompilerGeneratedAttribute]
private DocumentRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtendToTheWholeLinePolicy <ExtendToWholeLine>k__BackingField;
    public DocumentRange Range { get; }
    public ISelectedRange Parent { get; }
    public ExtendToTheWholeLinePolicy ExtendToWholeLine { get; }
    public AsmTextRangeSelection(DocumentRange range, ExtendToTheWholeLinePolicy policy);
    [CompilerGeneratedAttribute]
public sealed virtual DocumentRange get_Range();
    public sealed virtual ISelectedRange get_Parent();
    [CompilerGeneratedAttribute]
public sealed virtual ExtendToTheWholeLinePolicy get_ExtendToWholeLine();
    public sealed virtual ITreeRange TryGetTreeRange();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmAbsoluteDirective : CompositeElement {
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public ITokenNode Name { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public sealed virtual ITokenNode get_Name();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmBinaryExpr : CompositeElement {
    private CppCachedReference`1<ExprCachedInfo> myCache;
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public IAsmExpr FirstChildExpr { get; }
    public bool ContainsRegister { get; }
    public ExprCachedInfo CachedInfo { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public IAsmExpr get_FirstChildExpr();
    public sealed virtual bool get_ContainsRegister();
    public sealed virtual ExprCachedInfo get_CachedInfo();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmCommonDirective : AsmExternLikeDirectiveImpl {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmConditionalExpr : CompositeElement {
    private CppCachedReference`1<ExprCachedInfo> myCache;
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public IAsmExpr FirstChildExpr { get; }
    public bool ContainsRegister { get; }
    public ExprCachedInfo CachedInfo { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public IAsmExpr get_FirstChildExpr();
    public sealed virtual bool get_ContainsRegister();
    public sealed virtual ExprCachedInfo get_CachedInfo();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmDataPseudoInstruction : CompositeElement {
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public ITokenNode Name { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public sealed virtual ITokenNode get_Name();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmDemangledName : CompositeElement {
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmDupExpr : CompositeElement {
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmEndDirective : CompositeElement {
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public ITokenNode Name { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public sealed virtual ITokenNode get_Name();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmEndpDirective : CompositeElement {
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public ITokenNode Name { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public sealed virtual ITokenNode get_Name();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmEquPseudoInstruction : CompositeElement {
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public ITokenNode Name { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public sealed virtual ITokenNode get_Name();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmExprInstructionArgument : CompositeElement {
    private CppCachedValue`1<AsmOperandSize> myOperandSizeCache;
    private CppCachedValue`1<AsmOperandType> myTypeCache;
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public IAsmExpr Expr { get; }
    public AsmOperandType Type { get; }
    public AsmOperandSize OperandSize { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public IAsmExpr get_Expr();
    public sealed virtual AsmOperandType get_Type();
    public sealed virtual AsmOperandSize get_OperandSize();
    private AsmOperandSize ComputeOperandSize();
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Asm.Tree.AsmExprInstructionArgumentExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<AsmRegister> TryGetRegister(AsmExprInstructionArgument argument);
    [ExtensionAttribute]
public static Nullable`1<AsmRegister> TryGetRegister(IAsmInstructionArgument argument);
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmExternDirective : AsmExternLikeDirectiveImpl {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
internal abstract class JetBrains.ReSharper.Psi.Asm.Tree.AsmExternLikeDirectiveImpl : CompositeElement {
    public PsiLanguageType Language { get; }
    public ITokenNode Name { get; }
    public CppList`1<AsmVariableNode> VariableNames { get; }
    public virtual PsiLanguageType get_Language();
    public sealed virtual ITokenNode get_Name();
    public CppList`1<AsmVariableNode> get_VariableNames();
}
public class JetBrains.ReSharper.Psi.Asm.Tree.AsmFile : FileElementBase {
    private AsmFileCache myLabelCache;
    private bool myStatementOperandSizesAreSet;
    [CompilerGeneratedAttribute]
private List`1<ParserErrorInfo> <ParserErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private AsmLanguageDialect <Dialect>k__BackingField;
    public NodeType NodeType { get; }
    public List`1<ParserErrorInfo> ParserErrors { get; public set; }
    public AsmLanguageDialect Dialect { get; public set; }
    public PsiLanguageType Language { get; }
    public virtual NodeType get_NodeType();
    [CompilerGeneratedAttribute]
public List`1<ParserErrorInfo> get_ParserErrors();
    [CompilerGeneratedAttribute]
public void set_ParserErrors(List`1<ParserErrorInfo> value);
    [CompilerGeneratedAttribute]
public AsmLanguageDialect get_Dialect();
    [CompilerGeneratedAttribute]
public void set_Dialect(AsmLanguageDialect value);
    public virtual PsiLanguageType get_Language();
    internal AsmFileCache GetLabelsCache();
    private AsmFileCache BuildLabelsCache();
    public void AssertStatementProcessorModesAreSet();
    public void CalculateStatementProcessorModes();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmFileCache : object {
    public Dictionary`2<string, CppSmallList`1<IAsmLabelDefinition>> NameToLabels;
    public Dictionary`2<AsmStatement, AsmLabelDefinition> StatementToGlobalLabel;
    public Dictionary`2<AsmStatement, AsmProcDirective> StatementToProcDirective;
}
internal static class JetBrains.ReSharper.Psi.Asm.Tree.AsmFileNavigator : object {
    public static AsmFile GetByStatement(AsmStatement statement);
    public static AsmFile GetByLabelDefinition(AsmLabelDefinition labelDefinition);
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmGlobalDirective : AsmExternLikeDirectiveImpl {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmIndirectionInstructionArgument : CompositeElement {
    private CppCachedReference`1<MemoryAccessCachedInfo> myCachedInfo;
    private CppCachedValue`1<AsmOperandSize> myCalculatedOperandSizeCache;
    private Int64[] myAllowedIndexRegisterCoefficients;
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public ITokenNode PtrKeyword { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode FirstAddressSizeKeyword { get; }
    public ITokenNode FirstAddressRipRelativeSpecifier { get; }
    public AsmSegmentOverride FirstAddressSegmentOverride { get; }
    public IAsmExpr AddressExpr { get; }
    public AsmOperandType Type { get; }
    public MemoryAccessCachedInfo CachedInfo { get; }
    public AsmOperandSize OperandSize { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public ITokenNode get_PtrKeyword();
    public ITokenNode get_LBracket();
    public ITokenNode get_FirstAddressSizeKeyword();
    public ITokenNode get_FirstAddressRipRelativeSpecifier();
    public AsmSegmentOverride get_FirstAddressSegmentOverride();
    public IAsmExpr get_AddressExpr();
    public sealed virtual AsmOperandType get_Type();
    public MemoryAccessCachedInfo get_CachedInfo();
    public sealed virtual AsmOperandSize get_OperandSize();
    private bool IsEspOrRspRegister(AsmGprNumberForMemoryAccess reg);
    private ITreeNode FindEspOrRspInBinaryExpr(AsmBinaryExpr binaryExpr);
    private ITreeNode FindEspOrRspInConditionalExpr(AsmConditionalExpr conditionalExpr);
    private ITreeNode FindEspOrRspRegister(IAsmExpr expr);
    private void AppendRegisterToTheStringRepresentation(StringBuilder sb, long coefficient, AsmGprNumberForMemoryAccess register);
    private string StringRepresentationOfMemoryAccess(Int64[] coefficients, int numberOfRegisters);
    private MemoryAccessCachedInfo GetCorrectInvalidFormOfMemoryAccessError(int numberOfRegisters, Int64[] coefficients);
    private AddressSize ComputeAddressSize(Int64[] coefficients);
    private MemoryAccessCachedInfo ComputeMemoryAccessCachedInfo();
    private MemoryAccessCachedInfo ComputeMemoryAccessCachedInfoFor32Bit(Int64[] coefficients, long offset);
    private MemoryAccessCachedInfo ComputeMemoryAccessCachedInfoFor16Bit(Int64[] coefficients, long offset);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Asm.Tree.AsmIndirectionInstructionArgumentExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<AsmRegisterNumber> GetSegmentRegister(AsmIndirectionInstructionArgument indirection);
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmInstruction : CompositeElement {
    private static NodeType[] ourArgumentTypes;
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public ITokenNode Name { get; }
    public IAsmInstructionArgument FirstArgument { get; }
    public ITokenNode FirstPrefix { get; }
    private static AsmInstruction();
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public sealed virtual ITokenNode get_Name();
    public IAsmInstructionArgument get_FirstArgument();
    public ITokenNode get_FirstPrefix();
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Asm.Tree.AsmInstructionArgumentNavigator : object {
    [ExtensionAttribute]
public static IAsmInstructionArgument NextArgument(IAsmInstructionArgument argument);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Asm.Tree.AsmInstructionExtensions : object {
    [ExtensionAttribute]
public static int ComputeNumberOfArguments(AsmInstruction instruction);
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmInstructionNavigator : object {
    public static AsmInstruction GetByArgument(IAsmInstructionArgument argument);
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmLabelDefinition : CompositeElement {
    private static NodeType[] NameNodeTypes;
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public ITreeNode Name { get; }
    public ITokenNode Colon { get; }
    public IDeclaredElement DeclaredElement { get; }
    public string DeclaredName { get; }
    private static AsmLabelDefinition();
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public ITreeNode get_Name();
    public ITokenNode get_Colon();
    public string GetFullName();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual void SetName(string name);
    public sealed virtual TreeTextRange GetNameRange();
    public sealed virtual bool IsSynthetic();
    public sealed virtual IDeclaredElement get_DeclaredElement();
    public sealed virtual string get_DeclaredName();
}
internal static class JetBrains.ReSharper.Psi.Asm.Tree.AsmLabelDefinitionNavigator : object {
    public static AsmLabelDefinition GetByName(ITokenNode nameNode);
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmMasmDotSegmentDirective : CompositeElement {
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public ITokenNode Name { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public sealed virtual ITokenNode get_Name();
}
public enum JetBrains.ReSharper.Psi.Asm.Tree.AsmOperandSize : Enum {
    public int value__;
    public static AsmOperandSize Bits8;
    public static AsmOperandSize Bits16;
    public static AsmOperandSize Bits32;
    public static AsmOperandSize Bits64;
    public static AsmOperandSize Bits80;
    public static AsmOperandSize Bits128;
    public static AsmOperandSize Bits256;
    public static AsmOperandSize Bits512;
    public static AsmOperandSize BitsUndefined;
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmParenExpr : CompositeElement {
    private CppCachedReference`1<ExprCachedInfo> myCache;
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public IAsmExpr FirstChildExpr { get; }
    public bool ContainsRegister { get; }
    public ExprCachedInfo CachedInfo { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public IAsmExpr get_FirstChildExpr();
    public sealed virtual bool get_ContainsRegister();
    public sealed virtual ExprCachedInfo get_CachedInfo();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmParenList : CompositeElement {
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmProcDirective : CompositeElement {
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public ITokenNode Name { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public sealed virtual ITokenNode get_Name();
    public string GetName();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmProcessorModeDirective : CompositeElement {
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public ITokenNode Name { get; }
    public ITokenNode Value { get; }
    public AsmProcessorMode DeclaredProcessorMode { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public sealed virtual ITokenNode get_Name();
    public ITokenNode get_Value();
    public AsmProcessorMode get_DeclaredProcessorMode();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmPublicDirective : AsmExternLikeDirectiveImpl {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmRecoveryJunk : CompositeElement {
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmRequiredDirective : AsmExternLikeDirectiveImpl {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmSectionDirective : CompositeElement {
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public ITokenNode Name { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public sealed virtual ITokenNode get_Name();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmSegmentOverride : CompositeElement {
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public ITokenNode SegmentToken { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public ITokenNode get_SegmentToken();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmStatement : CompositeElement {
    private static NodeType[] InstructionTypes;
    private AsmProcessorMode myProcessorMode;
    public AsmLabelDefinition Label { get; }
    public IAsmInstruction Instruction { get; }
    public bool ContainsRecoveryJunk { get; }
    public CppList`1<AsmVariableNode> VariableNames { get; }
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public AsmProcessorMode ProcessorMode { get; public set; }
    private static AsmStatement();
    public AsmLabelDefinition get_Label();
    public IAsmInstruction get_Instruction();
    public bool get_ContainsRecoveryJunk();
    public CppList`1<AsmVariableNode> get_VariableNames();
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public AsmProcessorMode get_ProcessorMode();
    public void set_ProcessorMode(AsmProcessorMode value);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
private void AssertProcessorModeIsSet();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmStatementNavigator : object {
    public static AsmStatement GetByLabelDefinition(AsmLabelDefinition label);
    public static AsmStatement GetByInstruction(IAsmInstruction instruction);
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmStaticDirective : AsmExternLikeDirectiveImpl {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmSymbolSpecification : CompositeElement {
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmTimesDirective : CompositeElement {
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public ITokenNode Name { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public sealed virtual ITokenNode get_Name();
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Asm.Tree.AsmTreeNodeExtensions : object {
    public static NodeType[] Exprs;
    public static NodeType[] LeafNodes;
    private static AsmTreeNodeExtensions();
    [ExtensionAttribute]
public static T FindChildByType(ITreeNode node, NodeType[] childType, int childIndex);
    [ExtensionAttribute]
private static void FindChildrenByTypeRecursivelyImpl(ITreeNode node, NodeType childType, List`1<T> results);
    [ExtensionAttribute]
public static List`1<T> FindChildrenByTypeRecursively(ITreeNode node, NodeType childType);
    [ExtensionAttribute]
public static T FindChildByType(ITreeNode node, NodeType childType, int childIndex);
    [ExtensionAttribute]
public static ITokenNode GetFirstSizeKeyword(IAsmInstructionArgument node);
    [ExtensionAttribute]
public static AsmSegmentOverride GetFirstSegmentOverride(IAsmInstructionArgument node);
    [ExtensionAttribute]
public static CppList`1<T> FindChildrenByType(ITreeNode node, NodeType childType);
    public static string GetIdentifierText(ITreeNode nameNode);
    public static string GetFullLabelName(ITreeNode nameNode);
    [ExtensionAttribute]
public static IAsmExpr NextExpr(IAsmExpr expr);
    [ExtensionAttribute]
public static bool FindContainingNodeAndChildOf(ITreeNode source, TTreeNode& parent, ITreeNode& child);
    [ExtensionAttribute]
public static ITokenNode NextSizeKeyword(ITreeNode node);
    [ExtensionAttribute]
public static AsmSegmentOverride NextSegmentOverride(ITreeNode node);
    [ExtensionAttribute]
public static ITokenNode NextPrefix(ITokenNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITokenNode GetFirstOperandRipRelativeSpecifier(IAsmInstructionArgument node);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITokenNode NextRipRelativeSpecifier(ITreeNode node);
    [ExtensionAttribute]
public static AsmLanguageDialect GetLanguageDialect(ITreeNode node);
    [ExtensionAttribute]
public static IAsmExpr GetExprThroughParens(IAsmExpr expr);
}
internal class JetBrains.ReSharper.Psi.Asm.Tree.AsmUnaryExpr : CompositeElement {
    private CppCachedReference`1<ExprCachedInfo> myCache;
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public ITokenNode OperatorNode { get; }
    public IAsmExpr FirstChildExpr { get; }
    public bool ContainsRegister { get; }
    public ExprCachedInfo CachedInfo { get; }
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public ITokenNode get_OperatorNode();
    public IAsmExpr get_FirstChildExpr();
    public sealed virtual bool get_ContainsRegister();
    public sealed virtual ExprCachedInfo get_CachedInfo();
}
internal interface JetBrains.ReSharper.Psi.Asm.Tree.IAsmDataPseudoInstructionExpr {
}
internal interface JetBrains.ReSharper.Psi.Asm.Tree.IAsmExpr {
    public bool ContainsRegister { get; }
    public ExprCachedInfo CachedInfo { get; }
    public abstract virtual bool get_ContainsRegister();
    public abstract virtual ExprCachedInfo get_CachedInfo();
}
internal interface JetBrains.ReSharper.Psi.Asm.Tree.IAsmInstruction {
    public ITokenNode Name { get; }
    public abstract virtual ITokenNode get_Name();
}
internal interface JetBrains.ReSharper.Psi.Asm.Tree.IAsmInstructionArgument {
    public AsmOperandType Type { get; }
    public AsmOperandSize OperandSize { get; }
    public abstract virtual AsmOperandType get_Type();
    public abstract virtual AsmOperandSize get_OperandSize();
}
internal interface JetBrains.ReSharper.Psi.Asm.Tree.IAsmLabelDefinition {
}
internal interface JetBrains.ReSharper.Psi.Asm.Tree.IAsmPseudoInstruction {
}
public enum JetBrains.ReSharper.Psi.Asm.Tree.OperandSizeErrorOrWarningOrDeadCode : Enum {
    public int value__;
    public static OperandSizeErrorOrWarningOrDeadCode OperandSizeCanNotBeDerivedFromArguments;
    public static OperandSizeErrorOrWarningOrDeadCode DifferentOperandSizesOfArguments;
    public static OperandSizeErrorOrWarningOrDeadCode ArgumentOperandSizeGreaterThanProcessorModeOfStatement;
    public static OperandSizeErrorOrWarningOrDeadCode SizeSpecificationWillBeIgnored;
    public static OperandSizeErrorOrWarningOrDeadCode RedundantSizeSpecification;
    public static OperandSizeErrorOrWarningOrDeadCode OverflowInImmediateValue;
    public static OperandSizeErrorOrWarningOrDeadCode InvalidSizeKeywordInMemoryAccess;
    public static OperandSizeErrorOrWarningOrDeadCode InvalidSizeKeywordInMemoryAccessWithSpecification;
    public static OperandSizeErrorOrWarningOrDeadCode OperandSizeOfRegistersInMemoryAccessGreaterThenOperandSizeOfStatement;
}
public static class JetBrains.ReSharper.Psi.Asm.Util.AsmArgumentsUtil : object {
    public static Dictionary`2<string, AsmOperandSize> AsmSizeKeywordToOperandSizeDictionary;
    public static Dictionary`2<AsmOperandSize, int> AsmOperandSizeToInt;
    private static AsmArgumentsUtil();
    public static AsmGprNumberForMemoryAccess GetGprNumber(ITreeNode node);
    public static AsmOperandSize GetOperandSizeOfImmediateValue(long value);
    public static AsmOperandSize ProcessorModeToOperandSize(AsmProcessorMode mode);
    internal static ValueTuple`2<ITreeNode, int> FindNumericConstant(IAsmExpr expr);
    private static ValueTuple`2<ITreeNode, int> FindNumericConstantInBinaryExpr(AsmBinaryExpr binaryExpr);
    private static ValueTuple`2<ITreeNode, int> FindEspOrRspInConditionalExpr(AsmConditionalExpr conditionalExpr);
}
public static class JetBrains.ReSharper.Psi.Asm.Util.AsmConditionalInstructions : object {
    public static Dictionary`2<string, ConditionalInstruction> NameToConditionalInstruction;
    private static AsmConditionalInstructions();
}
internal static class JetBrains.ReSharper.Psi.Asm.Util.AsmExprCalculation : object {
    public static Dictionary`2<char, long> EscapeSequencesToAsciiCode;
    private static AsmExprCalculation();
    private static ExprCachedInfo CalculateBinaryOperation(ITreeNode operationNode, Value operand1, Value operand2);
    private static bool HasNonAsciiChars(string str);
    private static ExprCachedInfo ProcessUnaryExpr(AsmUnaryExpr expr);
    private static ExprCachedInfo ProcessConditionalExpr(AsmConditionalExpr conditionalExpr);
    private static NumberBase GetBaseByChar(char c);
    private static bool IsCorrectDigit(char digit, NumberBase numberBase);
    private static ExprCachedInfo GetNumericLiteralError(AsmExprTokenNode token, int index, NumberBase numberBase);
    private static ValueTuple`3<NumberBase, int, int> ComputeNumberBase(string numericLiteral);
    private static ExprCachedInfo ParseNumericLiteral(AsmExprTokenNode token);
    private static bool IsQuotationMarkOnTheEnd(string stringLiteral);
    private static ExprCachedInfo GetValueFromStringLiteral(AsmExprTokenNode token);
    private static ExprCachedInfo GetValueFromExprTokenNode(AsmExprTokenNode token);
    private static ExprCachedInfo ProcessLinearValue(ITreeNode lastOperator, Value lhs, Value rhs);
    private static ExprCachedInfo ProcessScalarValue(ITreeNode lastOperator, Value lhs, Value rhs);
    private static ExprCachedInfo ProcessBinaryExpr(AsmBinaryExpr expr);
    public static ExprCachedInfo ComputeExpressionCachedInfo(IAsmExpr expr, CppCachedReference`1& cache);
}
public static class JetBrains.ReSharper.Psi.Asm.Util.AsmFlags : object {
    public static Dictionary`2<string, Flags> MnemonicToFlag;
    private static AsmFlags();
}
internal static class JetBrains.ReSharper.Psi.Asm.Util.AsmInstructionImplicitRegisters : object {
    private static ImplicitRegister[] AL_AH_RW;
    private static ImplicitRegister[] DX_READ_ONLY;
    private static ImplicitRegister[] AX_DX_RW;
    private static ImplicitRegister[] AX_RW_DX_WRITE_ONLY;
    private static ImplicitRegister[] CX_RW;
    private static ImplicitRegister[] SI_DI_RW;
    private static ImplicitRegister[] SI_RW;
    private static ImplicitRegister[] DI_RW;
    private static ImplicitRegister[] SI_RW_AX_WRITE_ONLY;
    private static ImplicitRegister[] DI_RW_AX_READ_ONLY;
    private static ImplicitRegister[] SP_BP_RW;
    private static ImplicitRegister[] SP_RW;
    private static ImplicitRegister[] BX_READ_ONLY;
    private static ImplicitRegister[] RAX_RDX_RW;
    private static ImplicitRegister[] RAX_RW_RDX_WRITE_ONLY;
    private static ImplicitRegister[] RCX_RW;
    private static ImplicitRegister[] RSI_RDI_RW;
    private static ImplicitRegister[] RSI_RW;
    private static ImplicitRegister[] RDI_RW;
    private static ImplicitRegister[] RSI_RW_RAX_WRITE_ONLY;
    private static ImplicitRegister[] RDI_RW_RAX_READ_ONLY;
    private static ImplicitRegister[] RSP_RBP_RW;
    private static ImplicitRegister[] RSP_RW;
    private static ImplicitRegister[] RBX_READ_ONLY;
    private static ImplicitRegister[] EAX_EDX_RW;
    private static ImplicitRegister[] EAX_RW_EDX_WRITE_ONLY;
    private static ImplicitRegister[] ECX_RW;
    private static ImplicitRegister[] ESI_EDI_RW;
    private static ImplicitRegister[] ESI_RW;
    private static ImplicitRegister[] EDI_RW;
    private static ImplicitRegister[] ESI_RW_EAX_WRITE_ONLY;
    private static ImplicitRegister[] EDI_RW_EAX_READ_ONLY;
    private static ImplicitRegister[] ESP_EBP_RW;
    private static ImplicitRegister[] ESP_RW;
    private static ImplicitRegister[] EBX_READ_ONLY;
    public static Dictionary`2<string, ImplicitRegister[]> NameToRegisters;
    public static Dictionary`2<string, ImplicitRegister[]> NameTo16BitRegisters;
    public static Dictionary`2<string, ImplicitRegister[]> NameTo32BitRegisters;
    public static Dictionary`2<string, ImplicitRegister[]> NameTo64BitRegisters;
    private static AsmInstructionImplicitRegisters();
}
internal class JetBrains.ReSharper.Psi.Asm.Util.AsmInstructions : object {
    public static int NumberOfPatternOperandTypes;
    public static Dictionary`2<PatternOperandType, IEnumerable`1<string>> ArgumentTypeToRegisters;
    private static PatternOperandType[][] ourCmovArguments;
    public static Dictionary`2<ArgumentCombinationType, PatternOperandType[][]> AsmArgumentCombinations;
    public static Dictionary`2<string, InstructionGroup> AsmInstructionGroup;
    private static AsmInstructions();
    internal static bool Match(PatternOperandType required, IAsmInstructionArgument actualArg);
}
internal static class JetBrains.ReSharper.Psi.Asm.Util.AsmLabelsUtil : object {
    public static bool IsLocalLabelName(string labelName);
}
internal enum JetBrains.ReSharper.Psi.Asm.Util.AsmOperandType : Enum {
    public int value__;
    public static AsmOperandType GeneralRegister;
    public static AsmOperandType SegmentRegister;
    public static AsmOperandType MemoryAccess;
    public static AsmOperandType Immediate;
    public static AsmOperandType NonIdentified;
}
internal class JetBrains.ReSharper.Psi.Asm.Util.AsmPrefix : ValueType {
    public AsmPrefixGroup Group;
    public AsmPrefix(AsmPrefixGroup group);
}
internal static class JetBrains.ReSharper.Psi.Asm.Util.AsmPrefixes : object {
    public static Dictionary`2<string, AsmPrefix> NameToPrefix;
    public static Dictionary`2<AsmPrefixGroup, String[]> PrefixAllowedInstructions;
    private static AsmPrefixes();
}
[FlagsAttribute]
internal enum JetBrains.ReSharper.Psi.Asm.Util.AsmPrefixGroup : Enum {
    public byte value__;
    public static AsmPrefixGroup LOCK;
    public static AsmPrefixGroup REPEAT_STRING;
    public static AsmPrefixGroup REPEAT_STRING_OP;
    public static AsmPrefixGroup REPEAT_STRING_CMP;
    public static AsmPrefixGroup OPERAND_SIZE;
    public static AsmPrefixGroup ADDRESS_SIZE;
}
internal static class JetBrains.ReSharper.Psi.Asm.Util.AsmPsiSourceFileUtils : object {
    public static AsmFile GetAsmFile(IPsiSourceFile sourceFile);
}
public class JetBrains.ReSharper.Psi.Asm.Util.AsmRegister : ValueType {
    [CompilerGeneratedAttribute]
private AsmRegisterGroup <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private AsmRegisterNumber <Number>k__BackingField;
    [CompilerGeneratedAttribute]
private AsmRegisterPart <Part>k__BackingField;
    public AsmRegisterGroup Group { get; public set; }
    public AsmRegisterNumber Number { get; public set; }
    public AsmRegisterPart Part { get; public set; }
    public AsmRegister(AsmRegisterGroup Group, AsmRegisterNumber Number, AsmRegisterPart Part);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public AsmRegisterGroup get_Group();
    [CompilerGeneratedAttribute]
public void set_Group(AsmRegisterGroup value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public AsmRegisterNumber get_Number();
    [CompilerGeneratedAttribute]
public void set_Number(AsmRegisterNumber value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public AsmRegisterPart get_Part();
    [CompilerGeneratedAttribute]
public void set_Part(AsmRegisterPart value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(AsmRegister left, AsmRegister right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(AsmRegister left, AsmRegister right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(AsmRegister other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(AsmRegisterGroup& Group, AsmRegisterNumber& Number, AsmRegisterPart& Part);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Asm.Util.AsmRegisterExtensions : object {
    [ExtensionAttribute]
public static AsmOperandSize ComputeOperandSize(AsmRegister register);
    [ExtensionAttribute]
public static string SegmentRegisterAsString(AsmRegisterNumber regNum);
}
public enum JetBrains.ReSharper.Psi.Asm.Util.AsmRegisterGroup : Enum {
    public byte value__;
    public static AsmRegisterGroup GENERAL_PURPOSE;
    public static AsmRegisterGroup VECTOR;
    public static AsmRegisterGroup MASK;
    public static AsmRegisterGroup SEGMENT;
    public static AsmRegisterGroup X87;
    public static AsmRegisterGroup MMX;
    public static AsmRegisterGroup CONTROL;
    public static AsmRegisterGroup DEBUG;
    public static AsmRegisterGroup TEST;
    public static AsmRegisterGroup BOUND;
    public static AsmRegisterGroup TILE;
    public static AsmRegisterGroup RIP;
}
public enum JetBrains.ReSharper.Psi.Asm.Util.AsmRegisterNumber : Enum {
    public byte value__;
    public static AsmRegisterNumber RAX;
    public static AsmRegisterNumber RCX;
    public static AsmRegisterNumber RDX;
    public static AsmRegisterNumber RBX;
    public static AsmRegisterNumber RSP;
    public static AsmRegisterNumber RBP;
    public static AsmRegisterNumber RSI;
    public static AsmRegisterNumber RDI;
    public static AsmRegisterNumber R8;
    public static AsmRegisterNumber R9;
    public static AsmRegisterNumber R10;
    public static AsmRegisterNumber R11;
    public static AsmRegisterNumber R12;
    public static AsmRegisterNumber R13;
    public static AsmRegisterNumber R14;
    public static AsmRegisterNumber R15;
    public static AsmRegisterNumber ZMM0;
    public static AsmRegisterNumber ZMM1;
    public static AsmRegisterNumber ZMM2;
    public static AsmRegisterNumber ZMM3;
    public static AsmRegisterNumber ZMM4;
    public static AsmRegisterNumber ZMM5;
    public static AsmRegisterNumber ZMM6;
    public static AsmRegisterNumber ZMM7;
    public static AsmRegisterNumber ZMM8;
    public static AsmRegisterNumber ZMM9;
    public static AsmRegisterNumber ZMM10;
    public static AsmRegisterNumber ZMM11;
    public static AsmRegisterNumber ZMM12;
    public static AsmRegisterNumber ZMM13;
    public static AsmRegisterNumber ZMM14;
    public static AsmRegisterNumber ZMM15;
    public static AsmRegisterNumber ZMM16;
    public static AsmRegisterNumber ZMM17;
    public static AsmRegisterNumber ZMM18;
    public static AsmRegisterNumber ZMM19;
    public static AsmRegisterNumber ZMM20;
    public static AsmRegisterNumber ZMM21;
    public static AsmRegisterNumber ZMM22;
    public static AsmRegisterNumber ZMM23;
    public static AsmRegisterNumber ZMM24;
    public static AsmRegisterNumber ZMM25;
    public static AsmRegisterNumber ZMM26;
    public static AsmRegisterNumber ZMM27;
    public static AsmRegisterNumber ZMM28;
    public static AsmRegisterNumber ZMM29;
    public static AsmRegisterNumber ZMM30;
    public static AsmRegisterNumber ZMM31;
    public static AsmRegisterNumber K0;
    public static AsmRegisterNumber K1;
    public static AsmRegisterNumber K2;
    public static AsmRegisterNumber K3;
    public static AsmRegisterNumber K4;
    public static AsmRegisterNumber K5;
    public static AsmRegisterNumber K6;
    public static AsmRegisterNumber K7;
    public static AsmRegisterNumber ES;
    public static AsmRegisterNumber CS;
    public static AsmRegisterNumber SS;
    public static AsmRegisterNumber DS;
    public static AsmRegisterNumber FS;
    public static AsmRegisterNumber GS;
    public static AsmRegisterNumber SEGR6;
    public static AsmRegisterNumber SEGR7;
    public static AsmRegisterNumber ST0;
    public static AsmRegisterNumber ST1;
    public static AsmRegisterNumber ST2;
    public static AsmRegisterNumber ST3;
    public static AsmRegisterNumber ST4;
    public static AsmRegisterNumber ST5;
    public static AsmRegisterNumber ST6;
    public static AsmRegisterNumber ST7;
    public static AsmRegisterNumber CR0;
    public static AsmRegisterNumber CR1;
    public static AsmRegisterNumber CR2;
    public static AsmRegisterNumber CR3;
    public static AsmRegisterNumber CR4;
    public static AsmRegisterNumber CR5;
    public static AsmRegisterNumber CR6;
    public static AsmRegisterNumber CR7;
    public static AsmRegisterNumber CR8;
    public static AsmRegisterNumber CR9;
    public static AsmRegisterNumber CR10;
    public static AsmRegisterNumber CR11;
    public static AsmRegisterNumber CR12;
    public static AsmRegisterNumber CR13;
    public static AsmRegisterNumber CR14;
    public static AsmRegisterNumber CR15;
    public static AsmRegisterNumber DR0;
    public static AsmRegisterNumber DR1;
    public static AsmRegisterNumber DR2;
    public static AsmRegisterNumber DR3;
    public static AsmRegisterNumber DR4;
    public static AsmRegisterNumber DR5;
    public static AsmRegisterNumber DR6;
    public static AsmRegisterNumber DR7;
    public static AsmRegisterNumber DR8;
    public static AsmRegisterNumber DR9;
    public static AsmRegisterNumber DR10;
    public static AsmRegisterNumber DR11;
    public static AsmRegisterNumber DR12;
    public static AsmRegisterNumber DR13;
    public static AsmRegisterNumber DR14;
    public static AsmRegisterNumber DR15;
    public static AsmRegisterNumber TR0;
    public static AsmRegisterNumber TR1;
    public static AsmRegisterNumber TR2;
    public static AsmRegisterNumber TR3;
    public static AsmRegisterNumber TR4;
    public static AsmRegisterNumber TR5;
    public static AsmRegisterNumber TR6;
    public static AsmRegisterNumber TR7;
    public static AsmRegisterNumber BND0;
    public static AsmRegisterNumber BND1;
    public static AsmRegisterNumber BND2;
    public static AsmRegisterNumber BND3;
    public static AsmRegisterNumber TMM0;
    public static AsmRegisterNumber TMM1;
    public static AsmRegisterNumber TMM2;
    public static AsmRegisterNumber TMM3;
    public static AsmRegisterNumber TMM4;
    public static AsmRegisterNumber TMM5;
    public static AsmRegisterNumber TMM6;
    public static AsmRegisterNumber TMM7;
    public static AsmRegisterNumber RIP;
}
public enum JetBrains.ReSharper.Psi.Asm.Util.AsmRegisterPart : Enum {
    public byte value__;
    public static AsmRegisterPart WHOLE_REGISTER;
    public static AsmRegisterPart GENERAL_PURPOSE_32;
    public static AsmRegisterPart GENERAL_PURPOSE_16;
    public static AsmRegisterPart GENERAL_PURPOSE_8;
    public static AsmRegisterPart GENERAL_PURPOSE_8_HIGH;
    public static AsmRegisterPart VECTOR_256;
    public static AsmRegisterPart VECTOR_128;
}
public static class JetBrains.ReSharper.Psi.Asm.Util.AsmRegisters : object {
    public static AsmRegister RAX;
    public static AsmRegister RCX;
    public static AsmRegister RDX;
    public static AsmRegister RBX;
    public static AsmRegister RSP;
    public static AsmRegister RBP;
    public static AsmRegister RSI;
    public static AsmRegister RDI;
    public static AsmRegister R8;
    public static AsmRegister R9;
    public static AsmRegister R10;
    public static AsmRegister R11;
    public static AsmRegister R12;
    public static AsmRegister R13;
    public static AsmRegister R14;
    public static AsmRegister R15;
    public static AsmRegister EAX;
    public static AsmRegister ECX;
    public static AsmRegister EDX;
    public static AsmRegister EBX;
    public static AsmRegister ESP;
    public static AsmRegister EBP;
    public static AsmRegister ESI;
    public static AsmRegister EDI;
    public static AsmRegister R8D;
    public static AsmRegister R9D;
    public static AsmRegister R10D;
    public static AsmRegister R11D;
    public static AsmRegister R12D;
    public static AsmRegister R13D;
    public static AsmRegister R14D;
    public static AsmRegister R15D;
    public static AsmRegister AX;
    public static AsmRegister CX;
    public static AsmRegister DX;
    public static AsmRegister BX;
    public static AsmRegister SP;
    public static AsmRegister BP;
    public static AsmRegister SI;
    public static AsmRegister DI;
    public static AsmRegister R8W;
    public static AsmRegister R9W;
    public static AsmRegister R10W;
    public static AsmRegister R11W;
    public static AsmRegister R12W;
    public static AsmRegister R13W;
    public static AsmRegister R14W;
    public static AsmRegister R15W;
    public static AsmRegister AL;
    public static AsmRegister CL;
    public static AsmRegister DL;
    public static AsmRegister BL;
    public static AsmRegister SPL;
    public static AsmRegister BPL;
    public static AsmRegister SIL;
    public static AsmRegister DIL;
    public static AsmRegister R8B;
    public static AsmRegister R9B;
    public static AsmRegister R10B;
    public static AsmRegister R11B;
    public static AsmRegister R12B;
    public static AsmRegister R13B;
    public static AsmRegister R14B;
    public static AsmRegister R15B;
    public static AsmRegister AH;
    public static AsmRegister CH;
    public static AsmRegister DH;
    public static AsmRegister BH;
    public static AsmRegister ZMM0;
    public static AsmRegister ZMM1;
    public static AsmRegister ZMM2;
    public static AsmRegister ZMM3;
    public static AsmRegister ZMM4;
    public static AsmRegister ZMM5;
    public static AsmRegister ZMM6;
    public static AsmRegister ZMM7;
    public static AsmRegister ZMM8;
    public static AsmRegister ZMM9;
    public static AsmRegister ZMM10;
    public static AsmRegister ZMM11;
    public static AsmRegister ZMM12;
    public static AsmRegister ZMM13;
    public static AsmRegister ZMM14;
    public static AsmRegister ZMM15;
    public static AsmRegister ZMM16;
    public static AsmRegister ZMM17;
    public static AsmRegister ZMM18;
    public static AsmRegister ZMM19;
    public static AsmRegister ZMM20;
    public static AsmRegister ZMM21;
    public static AsmRegister ZMM22;
    public static AsmRegister ZMM23;
    public static AsmRegister ZMM24;
    public static AsmRegister ZMM25;
    public static AsmRegister ZMM26;
    public static AsmRegister ZMM27;
    public static AsmRegister ZMM28;
    public static AsmRegister ZMM29;
    public static AsmRegister ZMM30;
    public static AsmRegister ZMM31;
    public static AsmRegister YMM0;
    public static AsmRegister YMM1;
    public static AsmRegister YMM2;
    public static AsmRegister YMM3;
    public static AsmRegister YMM4;
    public static AsmRegister YMM5;
    public static AsmRegister YMM6;
    public static AsmRegister YMM7;
    public static AsmRegister YMM8;
    public static AsmRegister YMM9;
    public static AsmRegister YMM10;
    public static AsmRegister YMM11;
    public static AsmRegister YMM12;
    public static AsmRegister YMM13;
    public static AsmRegister YMM14;
    public static AsmRegister YMM15;
    public static AsmRegister YMM16;
    public static AsmRegister YMM17;
    public static AsmRegister YMM18;
    public static AsmRegister YMM19;
    public static AsmRegister YMM20;
    public static AsmRegister YMM21;
    public static AsmRegister YMM22;
    public static AsmRegister YMM23;
    public static AsmRegister YMM24;
    public static AsmRegister YMM25;
    public static AsmRegister YMM26;
    public static AsmRegister YMM27;
    public static AsmRegister YMM28;
    public static AsmRegister YMM29;
    public static AsmRegister YMM30;
    public static AsmRegister YMM31;
    public static AsmRegister XMM0;
    public static AsmRegister XMM1;
    public static AsmRegister XMM2;
    public static AsmRegister XMM3;
    public static AsmRegister XMM4;
    public static AsmRegister XMM5;
    public static AsmRegister XMM6;
    public static AsmRegister XMM7;
    public static AsmRegister XMM8;
    public static AsmRegister XMM9;
    public static AsmRegister XMM10;
    public static AsmRegister XMM11;
    public static AsmRegister XMM12;
    public static AsmRegister XMM13;
    public static AsmRegister XMM14;
    public static AsmRegister XMM15;
    public static AsmRegister XMM16;
    public static AsmRegister XMM17;
    public static AsmRegister XMM18;
    public static AsmRegister XMM19;
    public static AsmRegister XMM20;
    public static AsmRegister XMM21;
    public static AsmRegister XMM22;
    public static AsmRegister XMM23;
    public static AsmRegister XMM24;
    public static AsmRegister XMM25;
    public static AsmRegister XMM26;
    public static AsmRegister XMM27;
    public static AsmRegister XMM28;
    public static AsmRegister XMM29;
    public static AsmRegister XMM30;
    public static AsmRegister XMM31;
    public static AsmRegister K0;
    public static AsmRegister K1;
    public static AsmRegister K2;
    public static AsmRegister K3;
    public static AsmRegister K4;
    public static AsmRegister K5;
    public static AsmRegister K6;
    public static AsmRegister K7;
    public static AsmRegister ES;
    public static AsmRegister CS;
    public static AsmRegister SS;
    public static AsmRegister DS;
    public static AsmRegister FS;
    public static AsmRegister GS;
    public static AsmRegister SEGR6;
    public static AsmRegister SEGR7;
    public static AsmRegister ST0;
    public static AsmRegister ST1;
    public static AsmRegister ST2;
    public static AsmRegister ST3;
    public static AsmRegister ST4;
    public static AsmRegister ST5;
    public static AsmRegister ST6;
    public static AsmRegister ST7;
    public static AsmRegister MM0;
    public static AsmRegister MM1;
    public static AsmRegister MM2;
    public static AsmRegister MM3;
    public static AsmRegister MM4;
    public static AsmRegister MM5;
    public static AsmRegister MM6;
    public static AsmRegister MM7;
    public static AsmRegister CR0;
    public static AsmRegister CR1;
    public static AsmRegister CR2;
    public static AsmRegister CR3;
    public static AsmRegister CR4;
    public static AsmRegister CR5;
    public static AsmRegister CR6;
    public static AsmRegister CR7;
    public static AsmRegister CR8;
    public static AsmRegister CR9;
    public static AsmRegister CR10;
    public static AsmRegister CR11;
    public static AsmRegister CR12;
    public static AsmRegister CR13;
    public static AsmRegister CR14;
    public static AsmRegister CR15;
    public static AsmRegister DR0;
    public static AsmRegister DR1;
    public static AsmRegister DR2;
    public static AsmRegister DR3;
    public static AsmRegister DR4;
    public static AsmRegister DR5;
    public static AsmRegister DR6;
    public static AsmRegister DR7;
    public static AsmRegister DR8;
    public static AsmRegister DR9;
    public static AsmRegister DR10;
    public static AsmRegister DR11;
    public static AsmRegister DR12;
    public static AsmRegister DR13;
    public static AsmRegister DR14;
    public static AsmRegister DR15;
    public static AsmRegister TR0;
    public static AsmRegister TR1;
    public static AsmRegister TR2;
    public static AsmRegister TR3;
    public static AsmRegister TR4;
    public static AsmRegister TR5;
    public static AsmRegister TR6;
    public static AsmRegister TR7;
    public static AsmRegister BND0;
    public static AsmRegister BND1;
    public static AsmRegister BND2;
    public static AsmRegister BND3;
    public static AsmRegister TMM0;
    public static AsmRegister TMM1;
    public static AsmRegister TMM2;
    public static AsmRegister TMM3;
    public static AsmRegister TMM4;
    public static AsmRegister TMM5;
    public static AsmRegister TMM6;
    public static AsmRegister TMM7;
    public static AsmRegister RIP;
    public static AsmRegister EIP;
    public static AsmRegister IP;
    public static Dictionary`2<string, AsmRegister> NameToRegister;
    private static AsmRegisters();
    public static AsmRegister Parse(string name);
    public static bool Alias(AsmRegister a, AsmRegister b);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Psi.Asm.ZoneMarker : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
