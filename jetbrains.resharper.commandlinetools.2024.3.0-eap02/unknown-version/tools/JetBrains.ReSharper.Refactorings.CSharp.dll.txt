public class JetBrains.ReSharper.Refactorings.CSharp.Anotype2DeclaredType.CsAnonymous2Declared : Anonymous2Declared {
    private Anonymous2DeclaredDataModel myDataModel;
    public CsAnonymous2Declared(Anonymous2DeclaredWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IList`1<ITreeNode> SearchForAnonymousTypes(SubProgressIndicator pi);
    [CanBeNullAttribute]
public virtual ITypeElement CreateClassDeclaration(IList`1<ITypeParameter> usedTypeParameters, ISubstitution& substitution);
    private TClassLikeDeclaration PlaceTypeDeclaration(ITreeNode creationElement, TClassLikeDeclaration newTypeDeclaration);
    private void TryChangeReference(Func`1<bool> action);
    public virtual void ChangeReference(ITreeNode element, ITypeElement targetType, ISubstitution substitution);
    public virtual IList`1<ITypeParameter> GetUsagedTypeParameters();
    [NotNullAttribute]
private IClassLikeDeclaration CreateAndPlaceTypeDeclaration(IAnonymousObjectCreationExpression creationElement, CSharpElementFactory factory);
    [NotNullAttribute]
private IClassLikeDeclaration CreateClassWithMutableProperties(IAnonymousObjectCreationExpression creationElement, ISubstitution& substitution, IList`1<ITypeParameter> usedTypeParameters);
    [NotNullAttribute]
private IClassLikeDeclaration CreateClassWithGetOnlyProperties(IAnonymousObjectCreationExpression creationElement, ISubstitution& substitution, IList`1<ITypeParameter> usedTypeParameters);
    private void AddMethodDeclarations(IAnonymousObjectCreationExpression creationElement, IClassLikeDeclaration classLikeDeclaration, CSharpElementFactory factory, Dictionary`2<IType, ITypeParameter> usedTypeParameters);
    private void AddEqualsMethodDeclaration(IClassLikeDeclaration classLikeDeclaration, CSharpElementFactory factory, Dictionary`2<IType, ITypeParameter> usedTypeParameters, ITypeElement namedType);
    private static void AddGetHashCodeMethodDeclaration(IClassLikeDeclaration classLikeDeclaration, CSharpElementFactory factory, ITypeElement namedType);
    [NotNullAttribute]
private static string FormatTypeParameters(Dictionary`2<IType, ITypeParameter> parameters);
    private static void AddToStringMethodDeclaration(CSharpElementFactory factory, IClassLikeDeclaration classLikeDeclaration, IAnonymousObjectCreationExpression creationElement);
    [NotNullAttribute]
private static ICSharpStatement CreateToStringInterpolation(CSharpElementFactory factory, IAnonymousObjectCreationExpression creationElement);
    private static void CreateToStringWithStringBuilder(CSharpElementFactory factory, IClassLikeDeclaration typeDeclaration, IAnonymousObjectCreationExpression creationElement, IBlock bodyBlock);
    [NotNullAttribute]
private static Dictionary`2<IType, ITypeParameter> AddTypeParameters(ICSharpTypeDeclaration typeDeclaration, ISubstitution& substitution, IList`1<ITypeParameter> usedTypeParameters);
    private static bool SearchUp(ITypeParameter parameter, ICSharpTypeDeclaration decl);
    [NotNullAttribute]
private static string GetParameterName(string first, HashSet`1<string> parameters, IPsiSourceFile sourceFile);
    [NotNullAttribute]
private static string GetFieldName(string first, HashSet`1<string> names, IPsiSourceFile sourceFile);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.CSharp.Resources.Strings", "ChangeNullabilityActionText")]
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeNullability.ChangeNullabilityAction : ExtensibleRefactoringAction`1<ChangeNullabilityWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeNullability.ChangeNullabilityContext : UserDataHolder {
    [CompilerGeneratedAttribute]
private IPsiServices <PsiServices>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeChangesTree <EstimatedTypeChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private PostActionsRegistry <PostActions>k__BackingField;
    [CompilerGeneratedAttribute]
private IRefactoringDriver <Driver>k__BackingField;
    public IPsiServices PsiServices { get; }
    public TypeChangePropagationMode TypeChangePropagationMode { get; }
    public TypeChangesTree EstimatedTypeChanges { get; }
    public PostActionsRegistry PostActions { get; }
    public IRefactoringDriver Driver { get; }
    public ChangeNullabilityContext(IPsiServices psiServices, IRefactoringDriver driver, TypeChangesTree estimatedTypeChanges);
    [CompilerGeneratedAttribute]
public sealed virtual IPsiServices get_PsiServices();
    public sealed virtual TypeChangePropagationMode get_TypeChangePropagationMode();
    [CompilerGeneratedAttribute]
public sealed virtual TypeChangesTree get_EstimatedTypeChanges();
    [CompilerGeneratedAttribute]
public sealed virtual PostActionsRegistry get_PostActions();
    [CompilerGeneratedAttribute]
public sealed virtual IRefactoringDriver get_Driver();
    public sealed virtual object GetStateBeforeChange(IEnumerable`1<ITreeNode> scopes);
    public sealed virtual void FixStateAfterChange(object stateBeforeChange, IProgressIndicator progress);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ChangeNullability.ChangeNullabilityOfDeclaredElementsNode : object {
    [NotNullAttribute]
private IEnumerable`1<IDeclaredElement> myDeclaredElements;
    [NotNullAttribute]
private ITreeNode myContext;
    public ChangeNullabilityOfDeclaredElementsNode(IEnumerable`1<IDeclaredElement> declaredElements, ITreeNode context);
    public sealed virtual bool IsAvailable(ChangeNullabilityContext context);
    public sealed virtual IReadOnlyList`1<IChangeNode`1<ChangeNullabilityContext>> Apply(ChangeNullabilityContext context, IProgressIndicator progress);
    [CanBeNullAttribute]
public static IReadOnlyList`1<IChangeTypeTarget> TryGetChangeTargets(IEnumerable`1<IDeclaredElement> declaredElements, ITreeNode context);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ChangeNullability.ChangeNullabilityOfExpressionNode : object {
    [NotNullAttribute]
private ICSharpExpression myExpression;
    public ChangeNullabilityOfExpressionNode(ICSharpExpression expression);
    public sealed virtual bool IsAvailable(ChangeNullabilityContext context);
    public sealed virtual IReadOnlyList`1<IChangeNode`1<ChangeNullabilityContext>> Apply(ChangeNullabilityContext context, IProgressIndicator progress);
    [CanBeNullAttribute]
public static IReadOnlyList`1<IChangeTypeTarget> TryGetChangeTargets(ICSharpExpression expression);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeNullability.ChangeNullabilityPropagationUtil : TypeChangePropagationUtil {
    [CanBeNullAttribute]
private ChangeNullabilityContext myContext;
    public ChangeNullabilityPropagationUtil(ChangeNullabilityContext context);
    protected virtual DeclaredElementChangeTypeTarget TryCreateChangeTarget(IDeclaredElement declaredElement, IType newType);
    protected virtual ExpressionChangeTypeTarget TryCreateChangeTarget(ICSharpExpression expression, IType newType);
    [PureAttribute]
public static bool HasSingleNullabilityDifference(IType oldType, IType newType);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeNullability.ChangeNullabilityPropagationUtilProvider : object {
    public sealed virtual TypeChangePropagationUtil Get(ChangeNullabilityContext context);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeNullability.ChangeNullabilityRefactoring : object {
    [NotNullAttribute]
private ChangeNullabilityWorkflow myWorkflow;
    [NotNullAttribute]
private IRefactoringDriver myDriver;
    [CompilerGeneratedAttribute]
private TypeChangesTree <EstimationRunResult>k__BackingField;
    [CanBeNullAttribute]
public TypeChangesTree EstimationRunResult { get; private set; }
    public ChangeNullabilityRefactoring(ChangeNullabilityWorkflow workflow, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public TypeChangesTree get_EstimationRunResult();
    [CompilerGeneratedAttribute]
private void set_EstimationRunResult(TypeChangesTree value);
    public sealed virtual bool Execute(IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeNullability.ChangeNullabilityWorkflow : DrivenRefactoringWorkflow {
    [NotNullAttribute]
private IPsiServices myPsiServices;
    private IReadOnlyList`1<IChangeTypeTarget> myInitialChangeTargets;
    [CompilerGeneratedAttribute]
private ITreeNodePointer`1<ICSharpExpression> <InitialExpressionPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IDeclaredElementPointer`1<IDeclaredElement>> <DeclaredElementPointers>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNodePointer`1<ITreeNode> <DeclaredElementContextPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeChangesTree <EstimatedTypeChanges>k__BackingField;
    [CanBeNullAttribute]
public ITreeNodePointer`1<ICSharpExpression> InitialExpressionPointer { get; }
    [CanBeNullAttribute]
public IEnumerable`1<IDeclaredElementPointer`1<IDeclaredElement>> DeclaredElementPointers { get; private set; }
    [CanBeNullAttribute]
public ITreeNodePointer`1<ITreeNode> DeclaredElementContextPointer { get; private set; }
    [CanBeNullAttribute]
public TypeChangesTree EstimatedTypeChanges { get; private set; }
    public string Title { get; }
    public bool MightModifyManyDocuments { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public HelpId HelpKeyword { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public ChangeNullabilityWorkflow(ISolution solution, string actionId);
    public ChangeNullabilityWorkflow(ICSharpExpression expression);
    public ChangeNullabilityWorkflow(IEnumerable`1<IDeclaredElement> typeMembers, ITreeNode membersContext);
    [CompilerGeneratedAttribute]
public ITreeNodePointer`1<ICSharpExpression> get_InitialExpressionPointer();
    [CompilerGeneratedAttribute]
public IEnumerable`1<IDeclaredElementPointer`1<IDeclaredElement>> get_DeclaredElementPointers();
    [CompilerGeneratedAttribute]
private void set_DeclaredElementPointers(IEnumerable`1<IDeclaredElementPointer`1<IDeclaredElement>> value);
    [CompilerGeneratedAttribute]
public ITreeNodePointer`1<ITreeNode> get_DeclaredElementContextPointer();
    [CompilerGeneratedAttribute]
private void set_DeclaredElementContextPointer(ITreeNodePointer`1<ITreeNode> value);
    [CompilerGeneratedAttribute]
public TypeChangesTree get_EstimatedTypeChanges();
    [CompilerGeneratedAttribute]
private void set_EstimatedTypeChanges(TypeChangesTree value);
    public virtual string get_Title();
    public virtual bool get_MightModifyManyDocuments();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual HelpId get_HelpKeyword();
    public virtual RefactoringActionGroup get_ActionGroup();
    public bool IsAvailable();
    [CanBeNullAttribute]
[PureAttribute]
public virtual IChangeNode`1<ChangeNullabilityContext> GetInitialChangeNode();
    public IEnumerable`1<ValueTuple`2<IDeclaredElement, IType>> GetInitialChanges();
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool Initialize(IDataContext context);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    [CanBeNullAttribute]
private IRefactoringPage GetReviewTypeChangesPage(IProgressIndicator progressIndicator);
    [CanBeNullAttribute]
[PureAttribute]
private TypeChangesTree EstimateTypeChanges(IProgressIndicator progressIndicator);
}
[RefactoringWorkflowProviderAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeNullability.ChangeNullabilityWorkflowProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeSignature.CSharpArgumentsOwnerUsage : SignatureUsage`1<ICSharpArgument> {
    [CompilerGeneratedAttribute]
private ICSharpArgumentsOwner <context>P;
    private bool myWasNamed;
    public CSharpArgumentsOwnerUsage(ICSharpArgumentsOwner context, ClrChangeSignatureModel model, RebindableReference rebindableReference);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.CSharp.ChangeSignature.CSharpArgumentsOwnerUsage/<GetUpdateReferenceConflicts>d__3")]
public virtual IEnumerable`1<IConflict> GetUpdateReferenceConflicts();
    protected virtual bool TryGetItem(int index, ICSharpArgument& item);
    protected virtual ITreeNode CopyItemForParameter(ITreeNode item, ClrChangeSignatureParameter parameter);
    protected virtual void RemoveItem(ICSharpArgument item);
    protected virtual ArgumentLikeInfo CreateItemForParameter(ClrChangeSignatureParameter parameter, bool isRecursivePass);
    protected virtual ICSharpArgument ReplaceItemBy(ICSharpArgument item, ICSharpArgument newItem, ClrChangeSignatureParameter parameter);
    protected virtual ICSharpArgument AddItemAfter(ICSharpArgument item, ICSharpArgument anchor, ClrChangeSignatureParameter parameter);
    private static ICSharpArgument MakeNamedIfNeeded(ICSharpArgument oldArgument, bool wasNamed, ChangeSignatureParameter parameter);
    [CompilerGeneratedAttribute]
internal static bool <ReplaceItemBy>g__ParameterIsOptionalAndShouldBeNamed|8_0(ClrChangeSignatureParameter parameter);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeSignature.CSharpCallPreviewProvider : object {
    public sealed virtual IArgumentsOwner GetCallPreview(IArgumentsOwner call, ClrChangeSignatureParameter parameter, object argumentValue, bool addFake);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeSignature.CSharpChangeSignature : ChangeSignature {
    private static Key`1<object> ourImplicitReferenceKey;
    public CSharpChangeSignature(PsiLanguageType language);
    private static CSharpChangeSignature();
    public virtual bool IsAvailable(IParametersOwner owner);
    public virtual ClrChangeSignatureModel CreateModel(IParametersOwner owner, IProgressIndicator progressIndicator);
    public virtual ClrChangeSignatureModel CreateModel(IParametersOwner parametersOwner, ChangeSignatureFixNode fix, IProgressIndicator progressIndicator);
    protected virtual void ChangeDefaultConstructor(IConstructor constructor, ClrChangeSignatureModel model, List`1<ArgumentLikeInfo> postActions);
    public virtual void ChangeReference(ClrChangeSignatureModel changeSignatureModel, RebindableReference rebindableReference, List`1<ArgumentLikeInfo> postActionsList);
    public virtual void ProcessImplicitReferences(IDeclaration declaration, Action`1<IReference> action);
    public virtual void MaterializeReferenceIfNeeded(RebindableReference rebindableReference, ClrChangeSignatureModel model);
    public virtual void ChangeDeclaration(IDeclaration declaration, IList`1<IDeclaration> parameterDeclarations, ClrChangeSignatureModel changeSignatureModel, ISubstitution substitution, List`1<ArgumentLikeInfo> postActionsList);
    private static void FixTypeParameterConstraints(ICSharpParametersOwnerDeclaration declarationWithParameters);
    private static string GetName(IXmlTag tag);
    public virtual void CreateProxy(ClrChangeSignatureModel changeSignatureModel, List`1<ArgumentLikeInfo> postActionsList);
    public virtual IParametersOwner AddDefaultConstructorDeclaration(IConstructor defaultConstructor);
    public virtual ISignatureUsage CreateSignatureUsage(ClrChangeSignatureModel changeSignatureModel, RebindableReference rebindableReference);
    public virtual IParameterDeclaration CreateParameterDeclaration(IPsiModule module, string name, IType type, ParameterKind parameterKind, bool isParams, bool isVarArg, IDeclaration originalDeclaration, bool isThis, IParameterValue defaultValue, ClrChangeSignatureModel model);
    public virtual bool IsExtensionCallReference(IReference reference);
    public virtual Dictionary`2<int, int> GetArgumentToParameterMapping(IReference reference, bool isExtensionCall, IArgumentsOwner owner);
    public virtual IExpression CreateExpression(string text, ITreeNode context);
    public virtual IExpression CreateReferenceExpression(string name, ITreeNode context);
    public virtual IExpression CreateThisExpression(ITreeNode context);
    public virtual IExpression TryCreateDiscardExpression(ITreeNode context);
    public virtual void BindReferenceExpression(IExpression expression, IDeclaredElement element);
    public virtual bool IsLocalEqualToFieldOrAutoProperty(ITypeMember fieldOrProperty, IDeclaredElement local, ITreeNode place);
    public virtual ILocalVariable DeclareLocalOutVariable(string variableName, IType variableType, IExpression& beforeExpression, IElementsSet elementsToKeep);
    private static bool HasAssignments(IDeclaredElement element, ISearchDomain searchDomain, IReference skipReference);
    private static IAssignmentExpression FindAssignmentOfLocalToFieldOrProperty(IDeclaredElement fieldOrProperty, IDeclaredElement local, ICSharpStatement aboveStatement);
    [CompilerGeneratedAttribute]
internal static OverridableMemberInstance <FixTypeParameterConstraints>g__FindSuperMethodInstance|11_0(<>c__DisplayClass11_0& );
    [CompilerGeneratedAttribute]
internal static void <GetArgumentToParameterMapping>g__GenerateIdentityArgumentInfos|18_0(int count, <>c__DisplayClass18_0& );
}
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeSignature.CSharpChangeSignatureModel : ClrChangeSignatureModel {
    private CSharpLanguageLevel myLanguageLevel;
    private CSharpLanguageLevel myLatestSupportedLanguageLevel;
    internal CSharpChangeSignatureModel(IParametersOwner parametersOwner, bool isClone, IProgressIndicator progressIndicator);
    internal CSharpChangeSignatureModel(IParametersOwner parametersOwner, bool isClone, ChangeSignatureFixNode fix, IProgressIndicator progressIndicator);
    protected virtual bool Contains(IDeclaration declaration, ITreeNode refElement);
    public virtual string PresentType(IType value, PsiLanguageType psiLanguageType, ITreeNode treeNode);
    public virtual bool CanMoveDown(int index);
    public virtual bool IsDefaultValueApplicable(DefaultParameterChoice defaultParameterChoice, ChangeSignatureParameter clrParameter);
    public virtual bool IsDefaultValueRequired(ChangeSignatureParameter parameter);
    public virtual bool CanChangeType();
    public virtual bool CanChangeSignature();
    protected virtual bool IsUnsafeType(IType type);
    [CanBeNullAttribute]
public virtual string PresentDefaultValue(IParameter value);
    public virtual string GetDefaultValue(ChangeSignatureParameter parameter);
    public virtual bool CanHaveParameters();
    public virtual bool CanChangeName();
    protected virtual ClrChangeSignatureParameter CreateNewInstance(int index);
    public virtual IList`1<IDeclaration> BuildParameters(IParametersOwner parametersOwner, ISubstitution substitution);
    public virtual string GetParameterModifierString(ParameterKind kind, bool isParams, bool isVarArg, bool isThis);
    public virtual string GetParameterKindDescription(ParameterKind kind, bool nullIfNotSupported, bool isParams, bool isVarArg, bool isThis, bool isOptional);
    public virtual string GetPreview();
    public virtual bool ConflictsWithOtherInstance(TypeMemberInstance typeMemberInstance);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeSignature.CSharpMethodGroupUsage : object {
    [CompilerGeneratedAttribute]
private IReferenceExpression <context>P;
    [CompilerGeneratedAttribute]
private ClrChangeSignatureModel <clrChangeSignatureModel>P;
    [CompilerGeneratedAttribute]
private RebindableReference <rebindableReference>P;
    public CSharpMethodGroupUsage(IReferenceExpression context, ClrChangeSignatureModel clrChangeSignatureModel, RebindableReference rebindableReference);
    public sealed virtual IEnumerable`1<IConflict> GetUpdateReferenceConflicts();
    public sealed virtual bool TryUpdateSignatureUsage(List`1<ArgumentLikeInfo> postActionsList);
    public sealed virtual ISignatureUsage TryConvertToSimplerUsage();
}
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeSignature.DeconstructionPatternClauseUsage : SignatureUsage`1<ISubpattern> {
    [CompilerGeneratedAttribute]
private IDeconstructionPatternClause <context>P;
    private HashSet`1<string> myPickedNames;
    public DeconstructionPatternClauseUsage(IDeconstructionPatternClause context, ClrChangeSignatureModel model, RebindableReference rebindableReference);
    protected virtual bool TryGetItem(int index, ISubpattern& item);
    protected virtual ITreeNode CopyItemForParameter(ITreeNode item, ClrChangeSignatureParameter parameter);
    protected virtual void RemoveItem(ISubpattern item);
    protected virtual ArgumentLikeInfo CreateItemForParameter(ClrChangeSignatureParameter parameter, bool isRecursivePass);
    protected virtual ISubpattern AddItemAfter(ISubpattern item, ISubpattern anchor, ClrChangeSignatureParameter parameter);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.CSharp.ChangeSignature.DeconstructionPatternClauseUsage/<GetUpdateReferenceConflicts>d__8")]
public virtual IEnumerable`1<IConflict> GetUpdateReferenceConflicts();
    public virtual bool TryUpdateSignatureUsage(List`1<ArgumentLikeInfo> postActionsList);
    public virtual ISignatureUsage TryConvertToSimplerUsage();
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ChangeSignature.Impl.TypeSuggestion : object {
    private IType[] myTypes;
    public IType[] Types { get; }
    public TypeSuggestion(string typeName, ITreeNode context);
    public IType[] get_Types();
    [NotNullAttribute]
private static ITypePointer ReplaceScalarType(ITypePointer pointer, IType type);
    [NotNullAttribute]
private static IDeclaredType[] SuggestTypes(IPsiServices psiServices, string name);
    private ITypeUsage CreateTypeUsageNode(string typeName, ITreeNode context);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeSignature.Impl.TypeSuggestions : object {
    private Hashtable myTypes;
    private Hashtable mySuggestions;
    private ITreeNode myContext;
    public String[] Types { get; }
    public TypeSuggestions(ITreeNode context);
    public String[] get_Types();
    public void AddUnknownTypeName(string typeName);
    public IType GetType(string typeName);
    public void MapType(string typeName, IType type);
    public IType[] GetSuggestions(string typeName);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeSignature.ParenthesizedVariableDesignationUsage : SignatureUsage`1<IVariableDesignation> {
    [CompilerGeneratedAttribute]
private IParenthesizedVariableDesignation <context>P;
    private HashSet`1<string> myPickedNames;
    public ParenthesizedVariableDesignationUsage(IParenthesizedVariableDesignation context, ClrChangeSignatureModel model, RebindableReference rebindableReference);
    protected virtual bool TryGetItem(int index, IVariableDesignation& item);
    protected virtual IVariableDesignation AddItemAfter(IVariableDesignation item, IVariableDesignation anchor, ClrChangeSignatureParameter parameter);
    protected virtual void RemoveItem(IVariableDesignation item);
    protected virtual ArgumentLikeInfo CreateItemForParameter(ClrChangeSignatureParameter parameter, bool isRecursivePass);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.CSharp.ChangeSignature.ParenthesizedVariableDesignationUsage/<GetUpdateReferenceConflicts>d__7")]
public virtual IEnumerable`1<IConflict> GetUpdateReferenceConflicts();
    public virtual bool TryUpdateSignatureUsage(List`1<ArgumentLikeInfo> postActionsList);
    public virtual ISignatureUsage TryConvertToSimplerUsage();
    private DeconstructionPatternClauseUsage ConvertToPatternClause(IVarDeconstructionPattern deconstructionPattern);
    private TupleExpressionUsage ConvertToTupleExpression(IDeclarationExpression declarationExpression, IParenthesizedVariableDesignation rootParenthesizedDesignation);
    [CanBeNullAttribute]
private IDeconstructionPatternClause ReplaceChildrenDesignationsAndGetNewContextNode(CSharpElementFactory factory, IDeconstructionPatternClause pattern, TreeNodeEnumerable`1<IVariableDesignation> designations);
    [CanBeNullAttribute]
private ITupleExpression ReplaceChildrenDesignationsAndGetNewContextNode(CSharpElementFactory factory, ITupleExpression tupleExpression, TreeNodeEnumerable`1<IVariableDesignation> designations);
    private CSharpArgumentsOwnerUsage ConvertToArgumentsOwner(IParenthesizedVariableDesignation parenthesizedVariableDesignation);
    private static IAssignmentExpression ConvertNestedDeconstructionToAssignmentExpression(CSharpElementFactory factory, T oldDesignation, ITypeElement type, ICSharpExpression expression, T& newDesignation);
    [CompilerGeneratedAttribute]
private ICSharpExpression <ConvertToArgumentsOwner>g__CreateOutArgumentFromDesignation|14_0(int argumentIndex, <>c__DisplayClass14_0& );
}
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeSignature.TupleExpressionUsage : SignatureUsage`1<ITupleComponent> {
    [CompilerGeneratedAttribute]
private ITupleExpression <context>P;
    [CompilerGeneratedAttribute]
private RebindableReference <rebindableReference>P;
    private HashSet`1<string> myPickedNames;
    private PureAnnotationProvider PureAnnotationProvider { get; }
    public TupleExpressionUsage(ITupleExpression context, ClrChangeSignatureModel model, RebindableReference rebindableReference);
    private PureAnnotationProvider get_PureAnnotationProvider();
    protected virtual bool TryGetItem(int index, ITupleComponent& item);
    protected virtual void RemoveItem(ITupleComponent item);
    protected virtual ArgumentLikeInfo CreateItemForParameter(ClrChangeSignatureParameter parameter, bool isRecursivePass);
    protected virtual ITupleComponent AddItemAfter(ITupleComponent item, ITupleComponent anchor, ClrChangeSignatureParameter parameter);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.CSharp.ChangeSignature.TupleExpressionUsage/<GetUpdateReferenceConflicts>d__10")]
public virtual IEnumerable`1<IConflict> GetUpdateReferenceConflicts();
    public virtual bool TryUpdateSignatureUsage(List`1<ArgumentLikeInfo> postActionsList);
    private static void BreakTuplesAssignmentChainIfNeeded(ITupleExpression& tupleExpression, RebindableReference rebindableReference);
    public virtual ISignatureUsage TryConvertToSimplerUsage();
    private static IDeclarationExpression CreateDeclarationExpression(CSharpElementFactory factory, ITypeElement typeElement, ITreeNode context, string defaultName, String& declarationName);
    [CompilerGeneratedAttribute]
internal static bool <GetUpdateReferenceConflicts>g__IsChainingAssignmentsExpressionStatement|10_1(ICSharpExpression deconstructionExpression);
    [CompilerGeneratedAttribute]
internal static ITupleExpression <BreakTuplesAssignmentChainIfNeeded>g__BreakTuplesAssignmentChainCompilation|12_0(ITupleExpression tupleExpression, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
internal static void <BreakTuplesAssignmentChainIfNeeded>g__DeclareVariablesInsteadOfDiscards|12_1(CSharpElementFactory factory, ITreeNode context);
    [CompilerGeneratedAttribute]
internal static ITupleExpression <BreakTuplesAssignmentChainIfNeeded>g__BreakTuplesAssignmentChainToStatements|12_2(ITupleExpression tupleExpression, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
private bool <TryConvertToSimplerUsage>g__TryFixUpcastingDeconstructionOrRemovedParameters|13_0(int argumentIndex, ICSharpExpression& argumentValue, <>c__DisplayClass13_0& );
    [CompilerGeneratedAttribute]
private bool <TryConvertToSimplerUsage>g__IsParameterRemovedOrItsTypeStrictlyMatchesWithOriginal|13_1(int parameterIndex, IDeclaredElement declaredElement, <>c__DisplayClass13_0& );
    [CompilerGeneratedAttribute]
private IDeclarationExpression <TryConvertToSimplerUsage>g__CreateVariableDeclarationExpression|13_2(String& name, <>c__DisplayClass13_0& );
}
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeStaticness.CSharpMakeStatic : MakeStatic {
    private InlineHelper myInlineHelper;
    public InlineHelper InlineHelper { get; }
    public CSharpMakeStatic(MakeStaticWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void BindTo(IReference reference, IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual void Qualify(ITreeNode node, IParameter parameter);
    public virtual void AddArgumentAndBind(IReference reference, IDeclaredElement declaredElement, ISubstitution substitution, DisposableMarker marker);
    public virtual void SetStatic(IDeclaration declaration);
    public virtual IParameter AddParameter(IDeclaration declaration, IType type, string name);
    public virtual int ReferencesToThis(IExpression expression);
    public virtual InlineHelper get_InlineHelper();
    public virtual void Replace(ITreeNode node, string name);
    public virtual void CallInline(IReference reference, CallSiteContext context, IntroduceParameterInlineCallInfo info, IList`1<string> lambdaParameterNames);
    public virtual void FixOtherArguments(IReference reference, Dictionary`2<int, InlinedArgumentInfo> inlinedArgumentInfos);
    public virtual IReference ConvertMethodGroupToLambda(IReference reference, IList`1<IParameter> inlinedMethodInfo);
    public virtual void AddArgument(IReference reference, string name);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeStaticness.CSharpMakeStaticHelper : object {
    public bool IsLanguageSupported { get; }
    public sealed virtual bool get_IsLanguageSupported();
    public sealed virtual bool CheckElement(IDeclaredElement declaredElement, ITypeElement& containingTypeElement);
    public sealed virtual string GetTitle();
    public sealed virtual void CollectUsages(ThisUsagesCollector collector, IParametersOwnerDeclaration parametersOwnerDeclaration, IPsiServices psiServices);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeType.ChangeExpressionTypeNode`1 : object {
    [NotNullAttribute]
private ITreeNodePointer`1<ICSharpExpression> myExpressionPointer;
    [NotNullAttribute]
private ITypePointer myNewTypePointer;
    [NotNullAttribute]
private object myStateBeforeChange;
    private ChangeExpressionTypeNode`1(ICSharpExpression expression, IType newType, object stateBeforeChange);
    public static void Add(ChangeNodesCollector`1<TContext> collector, ICSharpExpression expression, IType newType, TContext context, IProgressIndicator progress);
    public sealed virtual bool IsAvailable(TContext context);
    public sealed virtual IReadOnlyList`1<IChangeNode`1<TContext>> Apply(TContext context, IProgressIndicator progress);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeType.ChangeExpressionTypeVisitor : TreeNodeVisitor`1<IType> {
    [NotNullAttribute]
private TypeChangePropagationUtil myTypeChangePropagationUtil;
    private bool myAllowModifications;
    [CompilerGeneratedAttribute]
private List`1<IChangeTypeTarget> <ChangeTypeTargets>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Action> <PostActions>k__BackingField;
    [NotNullAttribute]
public List`1<IChangeTypeTarget> ChangeTypeTargets { get; }
    [NotNullAttribute]
public List`1<Action> PostActions { get; }
    public ChangeExpressionTypeVisitor(TypeChangePropagationUtil typeChangePropagationUtil, bool allowModifications);
    [CompilerGeneratedAttribute]
public List`1<IChangeTypeTarget> get_ChangeTypeTargets();
    [CompilerGeneratedAttribute]
public List`1<Action> get_PostActions();
    public virtual void VisitObjectCreationExpression(IObjectCreationExpression objectCreationExpression, IType newType);
    private void ProcessObjectInitializer(IObjectCreationExpression objectCreationExpression, IDeclaredType newCreatedType);
    public virtual void VisitArrayCreationExpression(IArrayCreationExpression arrayCreationExpression, IType newType);
    public virtual void VisitCastExpression(ICastExpression castExpression, IType newType);
    public virtual void VisitAsExpression(IAsExpression asExpression, IType newType);
    private void ChangeTypeUsage(ITypeUsage typeUsage, IType newType);
    public virtual void VisitTupleExpression(ITupleExpression tupleExpression, IType newType);
    public virtual void VisitParenthesizedExpression(IParenthesizedExpression parenthesizedExpression, IType newType);
    public virtual void VisitReferenceExpression(IReferenceExpression referenceExpression, IType newType);
    public virtual void VisitInvocationExpression(IInvocationExpression invocationExpression, IType newType);
    public virtual void VisitElementAccessExpression(IElementAccessExpression elementAccessExpression, IType newType);
    public virtual void VisitLambdaExpression(ILambdaExpression lambdaExpression, IType newType);
    private void ProcessValue(ICSharpExpression valueExpression, IType newType);
    public virtual void VisitConditionalTernaryExpression(IConditionalTernaryExpression conditionalTernaryExpression, IType newType);
    public virtual void VisitSwitchExpression(ISwitchExpression switchExpression, IType newType);
    public virtual void VisitNullCoalescingExpression(INullCoalescingExpression nullCoalescingExpression, IType newType);
    public virtual void VisitRefExpression(IRefExpression refExpression, IType newType);
    public virtual void VisitAwaitExpression(IAwaitExpression awaitExpression, IType newType);
    [CompilerGeneratedAttribute]
private void <VisitArrayCreationExpression>g__AddRecoverImplicitnessPostAction|11_0(IArrayInitializer arrayInitializer, IType expectedElementType);
    [CompilerGeneratedAttribute]
private void <VisitArrayCreationExpression>g__ProcessArrayInitializer|11_1(IArrayInitializer arrayInitializer, IArrayType type);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeType.ChangeReturnValuePropagationsProvider : DummyChangeTypePropagationsProvider {
    public virtual void AddFromDeclaredElement(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType oldType, IType newType, TContext context, IProgressIndicator progress);
    [CanBeNullAttribute]
[PureAttribute]
private static IType GetExpectedReturnValueType(ICSharpDeclaration declaration, IType newReturnType);
    private static CSharpCodeBody GetCodeBody(ICSharpDeclaration declaration);
    [CompilerGeneratedAttribute]
internal static void <AddFromDeclaredElement>g__ProcessReturnValue|0_0(ICSharpExpression returnValue, IType oldReturnValueType, IType newReturnValueType, IProgressIndicator returnValueProgress, <>c__DisplayClass0_0`1& );
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeType.ChangeSetterValueVariablePropagationsProvider : DummyChangeTypePropagationsProvider {
    public virtual void AddFromDeclaredElement(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType oldType, IType newType, TContext context, IProgressIndicator progress);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.CSharp.ChangeType.ChangeTypeTargetExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<IChangeNode`1<TContext>> GetChangeTypeNodes(IReadOnlyList`1<IChangeTypeTarget> changeTypeTargets, TContext context, IProgressIndicator progress);
    [ExtensionAttribute]
public static void AddChangeTypeTargets(ChangeNodesCollector`1<TContext> collector, IReadOnlyList`1<IChangeTypeTarget> changeTypeTargets, TContext context, IProgressIndicator progress);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeType.ChangeVariableInitializerPropagationsProvider : DummyChangeTypePropagationsProvider {
    public virtual void AddFromDeclaredElement(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType oldType, IType newType, TContext context, IProgressIndicator progress);
    [CompilerGeneratedAttribute]
internal static void <AddFromDeclaredElement>g__CollectExpressionChanges|0_0(IVariableInitializer variableInitializer, IType oldVariableType, IType newVariableType, IProgressIndicator subProgress, <>c__DisplayClass0_0`1& );
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.CSharp.ChangeType.CodeBodyExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<ICSharpExpression> CollectReturnValues(CSharpCodeBody codeBody);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeType.CSharpChangeScopeHelper : ChangeScopeHelper {
    public virtual ITreeNode GetContainingMemberDeclarationOrTopLevelCodeOrFile(ITreeNode node);
    [CanBeNullAttribute]
[PureAttribute]
public static ITreeNode GetContainingMemberDeclarationOrTopLevelCodeOrFile(ICSharpTreeNode node);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeType.CSharpChangeTypeHelper : ChangeTypeHelper {
    public virtual void ChangeType(IDeclaration declaration, IType newType, TContext context);
    public virtual IType GetTypeWithActualNullability(ILocalVariable localVariable);
    private static void FixConstraintsForOverrideOrExplicitImplementation(IMethodDeclaration methodDeclaration);
    public static Action CreateRestoreVarAction(ILocalVariableDeclaration localVariableDeclaration, IType newType);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeType.DeclaredElementChangeTypeTarget : object {
    [CompilerGeneratedAttribute]
private IDeclaredElement <DeclaredElement>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <OldType>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <NewType>k__BackingField;
    [NotNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    public IType OldType { get; }
    public IType NewType { get; }
    public DeclaredElementChangeTypeTarget(IDeclaredElement declaredElement, IType newType);
    [CompilerGeneratedAttribute]
public IDeclaredElement get_DeclaredElement();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_OldType();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_NewType();
    public sealed virtual void AddChangeTypeNodes(ChangeNodesCollector`1<TContext> collector, TContext context, IProgressIndicator progress);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeType.DecontructionParameterDestinationPropagationsProvider : DummyChangeTypePropagationsProvider {
    public virtual void AddFromParameterUsage(ChangeNodesCollector`1<TContext> collector, IParameter parameter, IType oldType, IType newType, IReference parametersOwnerReference, TContext context, IProgressIndicator progress);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeType.ExpressionChangeTypeTarget : object {
    [CompilerGeneratedAttribute]
private ICSharpExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <OldType>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <NewType>k__BackingField;
    [NotNullAttribute]
public ICSharpExpression Expression { get; }
    public IType OldType { get; }
    public IType NewType { get; }
    public ExpressionChangeTypeTarget(ICSharpExpression expression, IType newType);
    [CompilerGeneratedAttribute]
public ICSharpExpression get_Expression();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_OldType();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_NewType();
    public sealed virtual void AddChangeTypeNodes(ChangeNodesCollector`1<TContext> collector, TContext context, IProgressIndicator progress);
}
public interface JetBrains.ReSharper.Refactorings.CSharp.ChangeType.IChangeTypeTarget {
    [NotNullAttribute]
public IType OldType { get; }
    [NotNullAttribute]
public IType NewType { get; }
    public abstract virtual IType get_OldType();
    public abstract virtual IType get_NewType();
    public abstract virtual void AddChangeTypeNodes(ChangeNodesCollector`1<TContext> collector, TContext context, IProgressIndicator progress);
}
public interface JetBrains.ReSharper.Refactorings.CSharp.ChangeType.ITypeChangePropagationUtilProvider`1 {
    [NotNullAttribute]
public abstract virtual TypeChangePropagationUtil Get(TContext context);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeType.ParameterOriginPropagationsProvider : DummyChangeTypePropagationsProvider {
    public virtual void AddFromParameterUsage(ChangeNodesCollector`1<TContext> collector, IParameter parameter, IType oldType, IType newType, IReference parametersOwnerReference, TContext context, IProgressIndicator progress);
    [PureAttribute]
private static ValueTuple`2<ICSharpArgument, CSharpParameterInstance> FindParameterMatch(ICSharpArgumentsOwner argumentsOwner, IParameter parameter);
    [PureAttribute]
private static ValueTuple`2<ICSharpArgument, CSharpParameterInstance> FindParameterMatch(ICSharpInvocationInfo argumentsOwner, IParameter parameter);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.CSharp.ChangeType.ProcessedExpressionsContextExtension : object {
    [NotNullAttribute]
private static Key`1<HashSet`1<ICSharpExpression>> ourInProcessExpressionsKey;
    private static ProcessedExpressionsContextExtension();
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static bool AddInProcessExpression(IChangeContext context, ICSharpExpression expression);
}
public static class JetBrains.ReSharper.Refactorings.CSharp.ChangeType.TupleComponentUtil : object {
    public static Action CreateRestoreImplicitComponentNamePostAction(ITupleComponent tupleComponent);
    [PureAttribute]
private static bool CanOmitTupleComponentName(ITupleComponent tupleComponent);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeType.TypeChangePropagationUtil : object {
    [NotNullAttribute]
private HashSet`1<ITreeNode> myRequestedOrigins;
    [NotNullAttribute]
private HashSet`1<ITreeNode> myRequestedDestinations;
    private bool myHaveProperNrtState;
    private bool myIsRootCall;
    [PureAttribute]
[CanBeNullAttribute]
protected virtual DeclaredElementChangeTypeTarget TryCreateChangeTarget(IDeclaredElement declaredElement, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
protected virtual ExpressionChangeTypeTarget TryCreateChangeTarget(ICSharpExpression expression, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
protected IReadOnlyList`1<IChangeTypeTarget> TryCreateChangeTargets(IDeclaredElement declaredElement, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
protected IReadOnlyList`1<IChangeTypeTarget> TryCreateChangeTargets(ICSharpExpression expression, IType newType);
    [PureAttribute]
public static bool CanChangeElement(IDeclaredElement declaredElement);
    private void EnsureNullableAnalysisIsFinished(ICSharpTreeNode node);
    [PureAttribute]
[CanBeNullAttribute]
public IReadOnlyList`1<IChangeTypeTarget> TryGetOriginChangeTargets(ICSharpExpression expression, IType newType);
    [MustUseReturnValueAttribute]
private bool ShouldChangeExpressionType(ICSharpExpression expression, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
public IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationChangeTargets(ICSharpExpression expression, IType newType);
    private void AdjustNewOriginTypeToNullabilityFlowState(ICSharpExpression expression, IType& newType);
    private void AdjustNewDestinationTypeToNullabilityFlowState(ICSharpExpression expression, IType& newType);
    [CanBeNullAttribute]
[PureAttribute]
public IReadOnlyList`1<IChangeTypeTarget> TryGetOriginChangeTargets(IPropertyPatternClause patternClause, IType newType);
    [CanBeNullAttribute]
[PureAttribute]
public IReadOnlyList`1<IChangeTypeTarget> TryGetOriginChangeTargets(IDeconstructionPatternClause patternClause, IType newType);
    [CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetFromPattern(IPattern pattern, IType newType);
    [CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetFromSwitchExpressionArm(IPattern pattern, IType newType);
    [CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetFromSwitchCaseLabel(IPattern pattern, IType newType);
    [CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetFromIsExpression(IPattern pattern, IType newType);
    [CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetFromSubpattern(IPattern pattern, IType newType);
    [CanBeNullAttribute]
public IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationChangeTargets(IPattern pattern, IType newType);
    [CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetFromLambdaParameter(ILocalRegularParameterDeclaration parameterDeclaration, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
protected virtual IReadOnlyList`1<IChangeTypeTarget> TryGetFromValue(ICSharpExpression expression, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationFromDefaultParameterValue(ICSharpExpression expression, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationFromQualifier(ICSharpExpression qualifierExpression, IType newQualifierType);
    [MustUseReturnValueAttribute]
private bool TryAddChangeTargetsForArgumentsWithNewSubstitution(LocalList`1& results, ICSharpArgumentsOwner argumentsOwner, ISubstitution referenceSubstitution, ISubstitution newSubstitution, IParameter matchingParameterToSkip);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetFromElementAccess(IElementAccessExpression elementAccessExpression, IType newType);
    [CanBeNullAttribute]
[PureAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetFromLambdaExpression(ILambdaExpression lambdaExpression, IType newType);
    [CanBeNullAttribute]
[PureAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetFromInvocation(IInvocationExpression invocationExpression, IType newType);
    [CanBeNullAttribute]
[PureAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryChangeGenericInvocationWithoutQualifier(IInvocationExpression invocationExpression, IDeclaredElement declaredElement, ISubstitution currentSubstitution, IType newReturnType);
    [CanBeNullAttribute]
[PureAttribute]
private IReadOnlyList`1<IChangeTypeTarget> CreateTargetFromInvocationParameterWithoutQualifier(IInvocationExpression invocationExpression, IParameter changedParameter, IType newParameterType);
    [NotNullAttribute]
[PureAttribute]
private static IType MakeTypeNullableIfHasConditionalAccess(IType type, IConditionalAccessExpression conditionalAccessExpression);
    [NotNullAttribute]
[PureAttribute]
private static IType MakeTypeNotNullableIfHasConditionalAccess(IType type, IConditionalAccessExpression conditionalAccessExpression);
    [CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryChangeGenericMethodInvocationQualifierWithNewSubstitution(ICSharpExpression qualifier, IParametersOwner parametersOwner, ISubstitution originalSubstitution, IType returnOrParameterType, IType newType);
    [CanBeNullAttribute]
[PureAttribute]
private IReadOnlyList`1<IChangeTypeTarget> CreateTargetFromInvocationParameter(IInvocationExpression invocationExpression, IParameter parameter, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetChangeTargetsWithNewSubstitution(ICSharpExpression genericTypeOwnerExpression, Dictionary`2<ITypeParameter, IType> newSubstitution);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryChangeGenericQualifier(IReferenceExpression referenceExpression, IDeclaredElement declaredElement, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetOriginFromConditionalExpression(ICSharpExpression expression, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationFromConditionalExpressionThenOrElseBranch(ICSharpExpression expression, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetOriginFromSwitchExpression(ICSharpExpression expression, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationFromSwitchExpression(ICSharpExpression expression, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetOriginFromNullCoalescingExpression(ICSharpExpression expression, IType newType);
    [CanBeNullAttribute]
[PureAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationFromNullCoalescingExpression(ICSharpExpression expression, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationFromExpressionInitializer(ICSharpExpression expression, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetOriginFromAssignmentDestination(ICSharpExpression destination, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetOriginFromTupleComponent(ICSharpExpression expression, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetOriginFromArgument(ICSharpExpression expression, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationFromArgument(ICSharpExpression argumentValue, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationFromExtensionMethodQualifier(ICSharpExpression qualifier, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetFromParameterOfGenericInvocation(ICSharpArgument argument, IParameter parameter, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationFromIndexerInitializer(ICSharpExpression expression, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationFromMemberInitializer(ICSharpExpression expression, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationFromArrayInitializer(ICSharpExpression elementValue, IType newElementType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationFromReturnValue(ICSharpExpression expression, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationFromLambdaExpression(ILambdaExpression lambdaExpression, IType newReturnType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetOriginFromForeachCollection(ICSharpExpression itemExpression, IType newItemType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationFromForeachCollection(ICSharpExpression collectionExpression, IType newCollectionType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationOfDeclarationExpression(IDeclarationExpression declarationExpression, IType oldType, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationOfVariableDesignation(IVariableDesignation variableDesignation, IType oldType, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationOfDeconstructionTuple(ITupleExpression deconstructionTuple, IType oldType, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetOriginFromAwait(ICSharpExpression expression, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationFromAwait(ICSharpExpression expression, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationFromRefExpression(ICSharpExpression expression, IType newType);
    [PureAttribute]
private static VariableDesignationUnwrapResult TryUnwrapVariableDesignation(IVariableDesignation variableDesignation, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationFromAssignmentSource(ICSharpExpression expression, IType newType);
    [PureAttribute]
[CanBeNullAttribute]
private IReadOnlyList`1<IChangeTypeTarget> TryGetDestinationFromOperatorArgument(ICSharpExpression expression, IType newType);
    [NotNullAttribute]
public IReadOnlyList`1<Action> PropagateTypeToExpression(ICSharpExpression expression, IType newType);
    [NotNullAttribute]
public IReadOnlyList`1<IChangeTypeTarget> CollectPropagatedChanges(ICSharpExpression expression, IType newType);
    [CanBeNullAttribute]
[PureAttribute]
public IType TryAdjustNewTypeToOriginalType(IType originalDestinationType, IType originalSourceType, IType newSourceType);
    [PureAttribute]
public bool IsGoodTypeConversion(IType originalDestinationType, IType originalSourceType);
    [NotNullAttribute]
[PureAttribute]
public virtual IType AdjustNewTypeToOriginalType(IType currentType, IType newType);
    [CompilerGeneratedAttribute]
internal static IType <TryChangeGenericMethodInvocationQualifierWithNewSubstitution>g__GetInvocationReceiverType|35_0(IParametersOwner parametersOwner);
    [CompilerGeneratedAttribute]
private void <TryGetDestinationOfVariableDesignation>g__Process|60_0(IVariableDesignation designation, IType oldDesignationType, IType newDesignationType, <>c__DisplayClass60_0& );
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<IType, IParameter> <TryUnwrapVariableDesignation>g__ProcessDeconstructReference|66_0(IDeconstructionReference deconstructionReference, int componentIndex, IType newComponentType);
    [CompilerGeneratedAttribute]
internal static IDeclaredType <TryUnwrapVariableDesignation>g__TryGetNewTupleType|66_1(DecoratedType`1<TupleTypeDecoration> tupleType, int componentIndex, IType newComponentType);
    [CompilerGeneratedAttribute]
internal static VariableDesignationUnwrapResult <TryUnwrapVariableDesignation>g__TryGetByTupleComponent|66_2(ICSharpExpression expression, IType newType);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.CSharp.ChangeType.TypeChangePropagationUtilProvider : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static TypeChangePropagationUtil GetTypeChangePropagationUtil(TContext context);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.ChangeType.UsageOriginDestinationPropagationsProvider : DummyChangeTypePropagationsProvider {
    public virtual void AddFromDeclaredElement(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType oldType, IType newType, TContext context, IProgressIndicator progress);
    public virtual void AddFromUsage(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType oldType, IType newType, IReference reference, TContext context, IProgressIndicator progress);
    private static void AddFromSourceExpression(ChangeNodesCollector`1<TContext> collector, ICSharpExpression expression, IType newType, bool shouldFindOriginTargets, TContext context, IProgressIndicator progress);
}
public abstract class JetBrains.ReSharper.Refactorings.CSharp.Common.CSharpTypeHierarchyBuilderBase : object {
    [NotNullAttribute]
protected ICSharpTypeDeclaration CreateDeclarationsChain(CSharpElementFactory elementFactory, ITypeDeclaration typeDeclaration, Int32& depth);
    [NotNullAttribute]
protected static ITypeDeclaration FindLeafDeclaration(ITypeDeclaration topmosTypeDeclaration, int depth);
    protected static void SetPartialModifier(ICSharpTypeDeclaration typeDeclaration);
    [NotNullAttribute]
protected static IClassLikeDeclaration CreateNewTypePart(CSharpElementFactory elementFactory, ICSharpTypeDeclaration typeDeclaration);
    [NotNullAttribute]
protected abstract virtual ICSharpTypeDeclaration AddTypeDeclaration(IClassLikeDeclaration leafDeclaration);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Common.CsProperty2FunctionDeclarationProcessor : Property2FunctionDeclarationProcessor`1<IMethodDeclaration> {
    public CsProperty2FunctionDeclarationProcessor(Property2FunctionDataModel property2FunctionDataModel);
    protected virtual IProperty PreProcessProperty(IProperty property);
    protected virtual IProperty CreateFieldForAutoProperty(IProperty property);
    [NotNullAttribute]
private static IProperty ConvertSemiAutoPropertyToExplicitField(IProperty property);
    [NotNullAttribute]
private static IClassMemberDeclaration GetDeclaration(IProperty property);
    protected virtual void FixCommentToGetter(IDocCommentBlockOwner owner);
    protected virtual void FixCommentToSetter(IDocCommentBlockOwner owner);
    protected virtual void RemoveBaseDeclaration(IProperty property);
    protected virtual IMethodDeclaration AddAccessor(IMethodDeclaration newDeclaration, IProperty property);
    protected virtual void RemoveSetter(IProperty property);
    protected virtual void RemoveGetter(IProperty property);
    protected virtual string GetterPattern(bool isAbstract, bool isInterface);
    protected virtual string SetterPattern(bool isAbstract, bool isInterface, IProperty property);
    public static IMethodDeclaration CreateAccessorDeclaration(bool withBody, IProperty property, IAccessor accessor, string accessorName, string accessorTemplate);
    private static AttributeTargets GetTargetFromAttributeUsageAttribute(IAttributesOwner attributeClass);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Common.CsProperty2FunctionReferencesProcessor : Property2FunctionReferencesProcessor {
    public CsProperty2FunctionReferencesProcessor(Property2FunctionBase refactoring, Property2FunctionWorkflow workflow);
    private static bool AnalyzeReference(IExpression expression, ICSharpExpression& csExpression, ICSharpArgument[]& arguments, ICSharpExpression& qualifierExpression, IType& type, Boolean& conditionalAccess);
    public virtual bool ReplaceWriteProperty(IExpression expression, IReference reference);
    public virtual void ReplaceReadOccurrence(IExpression expression);
    public virtual bool ReplaceReadWriteOccurrence(IReference reference, IExpression expression);
    private ICSharpExpression CreateGetterExpression(ICSharpArgument[] args, ITreeNode context, ICSharpExpression qualifier, bool conditionalAccess);
    [NotNullAttribute]
private static ICSharpExpression PatchWithArguments(IInvocationExpression expression, IEnumerable`1<ICSharpArgument> args);
    private ICSharpExpression CreateSetterExpression(ICSharpArgument[] args, CSharpElementFactory factory, ICSharpExpression value, ICSharpExpression qualifier);
    private ICSharpExpression TransformAssignmentExpression(ICSharpExpression qualifierExpression, ICSharpArgument[] arguments, IAssignmentExpression assignmentExpression, CSharpElementFactory factory);
    private ICSharpExpression TransformPrefixExpression(ICSharpExpression qualifierExpression, ICSharpArgument[] arguments, IPrefixOperatorExpression prefixOperatorExpression, CSharpElementFactory factory);
    private ICSharpExpression TransformPostfixExpression(ICSharpExpression qualifierExpression, ICSharpArgument[] arguments, IPostfixOperatorExpression postfixOperatorExpression, CSharpElementFactory factory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CSharp.Constructor2FactoryMethod.CSharpConstructorToFactoryMethod : ConstructorToFactoryMethodBase {
    public CSharpConstructorToFactoryMethod(Constructor2FactoryMethodWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool IsBaseConstructorInitializer(ITreeNode constructorUsageNode);
    public virtual ITypeMember CreateFactoryMethodDeclaration(ITypeElement targetTypeElement, IConstructor constructorToCall, string factoryMethodName);
    public virtual ITypeMember CreateSingleInstanceMemberDeclaration(ITypeElement targetTypeElement, IConstructor constructorToCall, string instancePropertyName);
    public virtual void ApplyCodeStyle(ITypeMember typeMember);
    public virtual void ConvertUsage(ITypeMember factoryMember, IReference reference);
    private bool TryConvertInitOnlyPropertiesToSetters(ICreationExpressionInitializer creationInitializer, IReference reference);
    public virtual void TryAbstractMemberWithoutUsages(ITypeMember factoryMember);
    public virtual string GetModifiersString(IParameter parameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CSharp.ConstructorToPrimary.ConstructorToPrimaryExecutor : object {
    private ITypeElementWithPrimaryConstructor myTypeElement;
    private IClassLikeDeclaration myTargetTypeDeclaration;
    [NullableAttribute("2")]
private IConstructor mySelectedConstructor;
    private IRefactoringDriver myDriver;
    private Dictionary`2<IConstructor, ClassInitializationInfo> myInitializationInfo;
    public ConstructorToPrimaryExecutor(ITypeElementWithPrimaryConstructor typeElement, IClassLikeDeclaration targetTypeDeclaration, IConstructor selectedConstructor, IRefactoringDriver driver);
    public sealed virtual bool Execute(IProgressIndicator pi);
    private bool BuildInitializationInfosFromConstructorDeclarations();
    [CompilerGeneratedAttribute]
private ClassInitializationInfo <Execute>b__6_0(IConstructor ctor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CSharp.ConstructorToPrimary.ConstructorToPrimaryWorkflow : DrivenRefactoringWorkflow {
    [NullableAttribute("2")]
private ITypeElementWithPrimaryConstructor myTargetTypeElement;
    [NullableAttribute("2")]
private IClassLikeDeclaration myTargetTypeDeclaration;
    [NullableAttribute("2")]
private IConstructor mySelectedConstructor;
    public HelpId HelpKeyword { get; }
    [NullableAttribute("2")]
public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public ConstructorToPrimaryWorkflow(ISolution solution, string actionId);
    public virtual HelpId get_HelpKeyword();
    [NullableContextAttribute("2")]
public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual bool IsAvailable(IDataContext context);
    [PureAttribute]
public static bool IsAvailableFor(IConstructor constructor);
    [NullableContextAttribute("2")]
[PureAttribute]
public static bool IsAvailableFor(ITypeElement typeElement);
    public virtual bool Initialize(IDataContext context);
    [NullableContextAttribute("2")]
[PureAttribute]
private static ITypeElementWithPrimaryConstructor TryFindTargetType(IDataContext dataContext, IConstructor& selectedConstructor);
    [NullableContextAttribute("2")]
[PureAttribute]
private static IClassLikeDeclaration TryChooseTargetDeclaration(ITypeElement targetTypeElement, IPsiSourceFile sourceFile);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Convert.CsConvert : ConvertTypeBase`2<IClassMemberDeclaration, IClassLikeDeclaration> {
    private Dictionary`2<IClassLikeDeclaration, IClassLikeDeclaration> myPartsMap;
    public bool AllImplementationsAreExplicit { get; }
    public CsConvert(IRefactoringDriver driver);
    public virtual bool get_AllImplementationsAreExplicit();
    public virtual void ReplaceMembers(IClass clsss);
    public virtual void CreateClassDeclaration(IInterface interface);
    private void Decorate(ITypeElement toElement, IClassLikeDeclaration fromDeclaration, IClassLikeDeclaration toDeclaration);
    protected virtual void AddSuperInterface(ITypeDeclaration to, IDeclaredType newSuprtType);
    public virtual void RemoveDeclaration(IOverridableMember member);
    public virtual void MakePublicOverride(IOverridableMember member, IDeclaredType declTypeToRemove);
    public virtual void RemoveInterface(ITypeElement implementor, IInterface interfaceToRemove);
    public virtual void AddInterface(ITypeElement typeElement, IExplicitImplementation interfaceToAdd);
    public virtual void ImplementsMembersAbstract();
    protected virtual void Privatizate(IClassMemberDeclaration newDecl);
    public virtual void FixSignature(ITypeElement implementor, IInterface interface);
    public virtual bool ProcessOverridableMember(IOverridableMember overridable, IProgressIndicator pi);
    public virtual void MakePublic(IOverridableMember member);
    public virtual bool MakeVirtual(IOverridableMember member);
    public virtual void ProcessOtherMember(ITypeMember member);
    protected virtual void MakePrivateImplementation(ElementInstancePointer pointer, IClassMemberDeclaration newDecl);
    protected virtual IEnumerable`1<IClassMemberDeclaration> MakeAbstractDeclaration(IClassLikeDeclaration classDecl, ElementInstancePointer pointer, int indexForVB, IEnumerable`1<IType> lsitOfTypes, bool makePrivate);
    protected virtual void MakeCallMoreGeneric(IClassLikeDeclaration classToAddNewDeclaration, ElementInstancePointer memberCaller, ElementInstancePointer memberCallee, IType type);
    protected virtual bool CanCallMoreGeneric(OverridableMemberInstance moreGenericInstance, OverridableMemberInstance lessGenericInstance, IClassLikeDeclaration classDecl);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Convert.InterfaceMembersCollector : InterfaceMembersCollectorBase {
    public InterfaceMembersCollector(bool keepAllExplicitlyImplemented);
    public static IList`1<ElementInstancePointer> GetInterfaceMembers(ITypeDeclaration typeDeclaration, bool keepAllNotExplicitlyImplemented);
    protected virtual bool IsPrimaryTypeMember(ITypeMember overridableMember);
    protected virtual void ProcessPrivateImplementations(IOverridableMember overridableMember, ISubstitution substitution, OverridableMemberInfo overridableMemberInfo, bool processingInheritedMembers);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.<IUsingInfo>F04A0F6A2FBD4BB369AF3CC6DB0106D737E7FC64995801F3A4564BCD9F4C23FB1__UsingInfoImplUtil : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToExternAliasQualifier(string externAlias);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.CSharp.Resources.Strings", "ConvertToGlobalUsing_Action_Text")]
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.ConvertToGlobalUsingAction : ExtensibleRefactoringAction`1<ConvertToGlobalUsingWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.ConvertToGlobalUsingAvailabilityData : object {
    [CompilerGeneratedAttribute]
private IProjectPsiModule <ProjectPsiModule>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IUsingInfo> <SelectedUsings>k__BackingField;
    public IProjectPsiModule ProjectPsiModule { get; }
    public IReadOnlyList`1<IUsingInfo> SelectedUsings { get; }
    public ConvertToGlobalUsingAvailabilityData(IProjectPsiModule projectPsiModule, IReadOnlyList`1<IUsingInfo> selectedUsings);
    [CompilerGeneratedAttribute]
public IProjectPsiModule get_ProjectPsiModule();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IUsingInfo> get_SelectedUsings();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.ConvertToGlobalUsingDataModel : object {
    private static string DefaultGlobalUsingsFileName;
    private ListEvents`1<UsingViewModel> myUsings;
    private List`1<IUsingInfoPointer> myInitialUsings;
    [CompilerGeneratedAttribute]
private IProjectPsiModule <ProjectPsiModule>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GlobalUsingsFileName>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IProjectFile <GlobalUsingsFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNewGlobalUsingsFile>k__BackingField;
    public IProjectPsiModule ProjectPsiModule { get; }
    public bool HasInitialSelection { get; }
    public ListEvents`1<UsingViewModel> Usings { get; }
    public string GlobalUsingsFileName { get; public set; }
    [NullableAttribute("2")]
public IProjectFile GlobalUsingsFile { get; public set; }
    public bool IsNewGlobalUsingsFile { get; public set; }
    public ConvertToGlobalUsingDataModel(IProjectPsiModule projectPsiModule, IReadOnlyList`1<IUsingInfo> initialUsings);
    [CompilerGeneratedAttribute]
public IProjectPsiModule get_ProjectPsiModule();
    public bool get_HasInitialSelection();
    public ListEvents`1<UsingViewModel> get_Usings();
    [CompilerGeneratedAttribute]
public string get_GlobalUsingsFileName();
    [CompilerGeneratedAttribute]
public void set_GlobalUsingsFileName(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IProjectFile get_GlobalUsingsFile();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_GlobalUsingsFile(IProjectFile value);
    [CompilerGeneratedAttribute]
public bool get_IsNewGlobalUsingsFile();
    [CompilerGeneratedAttribute]
public void set_IsNewGlobalUsingsFile(bool value);
    public bool HasValidUsings();
    public IReadOnlyList`1<IUsingInfo> GetUsingsFromInitialSelection();
    public IReadOnlyList`1<IUsingInfo> GetSelectedUsings();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.ConvertToGlobalUsingDataProvider : object {
    private ConvertToGlobalUsingAvailabilityData myAvailabilityData;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<string> myConflicts;
    public bool CanRegisterConflicts { get; }
    public ConvertToGlobalUsingDataProvider(List`1<IUsingDirective> usingDirectives, List`1<string> conflicts);
    public ConvertToGlobalUsingDataProvider(ConvertToGlobalUsingAvailabilityData availabilityData, List`1<string> conflicts);
    public sealed virtual ConvertToGlobalUsingAvailabilityData GetData();
    public sealed virtual void AddConflict(Conflict conflict);
    public sealed virtual bool get_CanRegisterConflicts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.ConvertToGlobalUsingPage : SingleBeRefactoringPage {
    private static string GlobalUsingsFileText;
    private ConvertToGlobalUsingDataModel myDataModel;
    private IconHostBase myIconHost;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Title { get; protected set; }
    public string Description { get; protected set; }
    public ConvertToGlobalUsingPage(Lifetime lifetime, ConvertToGlobalUsingDataModel dataModel);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    public virtual BeControl GetPageContent();
    private BeTreeGrid GetUsingsTreeGrid(IEnumerable`1<UsingViewModel> usings);
    public virtual bool RefreshContents(IProgressIndicator pi);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <GetPageContent>b__12_0(string fileName);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private List`1<BeControl> <GetUsingsTreeGrid>b__13_0(Lifetime itemLifetime, UsingViewModel usingViewModel, CheckBoxListNodeProperties properties);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.ConvertToGlobalUsingRefactoring : DrivenRefactoringBase`1<ConvertToGlobalUsingWorkflow> {
    public ConvertToGlobalUsingRefactoring(ConvertToGlobalUsingWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool Execute(IProgressIndicator pi);
    private bool ExtractGlobalUsing(IUsingInfo usingInfo, ICSharpFile file, IProgressIndicator progress);
    private IReadOnlyList`1<IUsingDirective> FindUsingDirectivesToRemove(IUsingInfo usingInfo, IProgressIndicator pi);
    private bool AddGlobalUsingDirective(IUsingDirective globalUsingDirective, ICSharpFile file);
    private bool RemoveUsingDirectives(IReadOnlyList`1<IUsingDirective> usingsToRemove, IUsingInfo usingInfo, string newAliasName, IProgressIndicator pi);
    private bool HasConflictsAfterUsingDirectiveRemoval(IPsiSourceFile sourceFile, IUsingInfo usingInfo);
    private static void RebindReferencesToRenamedAlias(IUsingAliasDirective usingAliasDirective, string newAliasName);
    private string CheckForGlobalAliasNameConflicts(UsingAliasInfo usingAliasInfo);
    private void CheckForConflictsWhenImportAddedToProjectFiles(IUsingInfo usingInfo, IUsingSymbolDirective usingSymbolDirective, IProgressIndicator progressIndicator);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.CSharp.Resources.Strings", "ConvertToGlobalUsings_Action_Text")]
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.ConvertToGlobalUsingsAction : ExtensibleRefactoringAction`1<ConvertToGlobalUsingWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.ConvertToGlobalUsingWorkflow : DrivenRefactoringWorkflow {
    [NullableAttribute("2")]
private ConvertToGlobalUsingDataModel myDataModel;
    [NullableAttribute("2")]
private IConvertToGlobalUsingDataProvider myDataProvider;
    public string Title { get; }
    public HelpId HelpKeyword { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public bool MightModifyManyDocuments { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public ConvertToGlobalUsingDataModel DataModel { get; }
    public ConvertToGlobalUsingWorkflow(ISolution solution, string actionId);
    public virtual string get_Title();
    public virtual HelpId get_HelpKeyword();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual bool get_MightModifyManyDocuments();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public ConvertToGlobalUsingDataModel get_DataModel();
    public void SetDataProvider(IConvertToGlobalUsingDataProvider dataProvider);
    public virtual bool Initialize(IDataContext context);
    public virtual bool IsAvailable(IDataContext context);
    private ConvertToGlobalUsingAvailabilityData TryGetAvailabilityData(IDataContext context);
    public static ConvertToGlobalUsingAvailabilityData TryGetAvailabilityDataFromSelection(IPsiView psiView);
    private static IProject GetSelectedProject(IDataContext context);
    private static bool AreGlobalUsingsAvailableForAllTargetFrameworks(IProject project);
    private IRefactoringPage GetPage(IProgressIndicator progressIndicator);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool PreExecute(IProgressIndicator pi);
    public void AddConflict(Conflict conflict);
    private static IProjectFile GetOrCreateGlobalUsingsFile(IProject project, string globalUsingsFileName, Boolean& isNewFile);
    private static void AddDocumentInitialContentText(IProjectFolder folder, IProjectFile projectFile);
}
[RefactoringWorkflowProviderAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.ConvertToGlobalUsingWorkflowProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.EquivalentUsingDirectivesSearcher : SearchDomainVisitorParallel {
    private IUsingInfo myUsingInfo;
    private bool myGlobalOnly;
    [NullableAttribute("2")]
private VirtualFileSystemPath myLocationToSkip;
    private List`1<IUsingDirective> myResult;
    private object mySyncRoot;
    private EquivalentUsingDirectivesSearcher(ISearchDomain searchDomain, IUsingInfo usingInfo, bool globalOnly, VirtualFileSystemPath locationToSkip, IProgressIndicator pi);
    public static IReadOnlyList`1<IUsingDirective> Find(IPsiModule psiModule, IUsingInfo usingInfo, bool globalOnly, VirtualFileSystemPath locationToSkip, IProgressIndicator pi);
    [PureAttribute]
private static ISearchDomain GetSearchDomain(IPsiModule psiModule, IUsingInfo usingInfo);
    private bool ProcessFile(ICSharpFile file);
    protected virtual bool ProcessProjectFile(IPsiSourceFile sourceFile);
    protected virtual bool ProcessAssembly(IPsiAssembly assembly);
    protected virtual bool ProcessElement(ITreeNode element);
    [PureAttribute]
private bool ShouldSkip(IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
private bool <ProcessFile>g__ProcessScope|8_0(ICSharpTypeAndNamespaceHolderDeclaration scope);
    [CompilerGeneratedAttribute]
private void <ProcessFile>g__ProcessUsingDirective|8_1(IUsingDirective usingDirective);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.IConvertToGlobalUsingDataProvider {
    public bool CanRegisterConflicts { get; }
    public abstract virtual ConvertToGlobalUsingAvailabilityData GetData();
    public abstract virtual void AddConflict(Conflict conflict);
    public abstract virtual bool get_CanRegisterConflicts();
}
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.ImportConflictSearcher : SearchDomainVisitor {
    private IUsingInfo myUsingInfo;
    private IProgressIndicator myProgressIndicator;
    private OneToListMap`2<ICSharpFile, Conflict> myConflictsByFiles;
    private object mySyncRoot;
    public bool ProcessingIsFinished { get; }
    private ImportConflictSearcher(IUsingInfo usingInfo, IProgressIndicator progressIndicator);
    [NotNullAttribute]
public static OneToListMap`2<ICSharpFile, Conflict> Find(IUsingInfo usingInfo, IUsingSymbolDirective usingSymbolDirective, IPsiModule psiModule, IProgressIndicator progressIndicator);
    public virtual bool get_ProcessingIsFinished();
    public virtual void VisitPsiSourceFile(IPsiSourceFile sourceFile);
    public virtual void VisitAssembly(IPsiAssembly assembly);
    public virtual void VisitElement(ITreeNode element);
    private void ProcessFile(ICSharpFile csharpFile);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.IUsingInfo {
    public bool IsStatic { get; }
    public bool IsAlias { get; }
    [NullableAttribute("2")]
public string ExternAlias { get; }
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsAlias();
    [NullableContextAttribute("2")]
public abstract virtual string get_ExternAlias();
    public abstract virtual bool IsValid();
    public abstract virtual IUsingInfoPointer CreatePointer();
    public abstract virtual IUsingDirective CreateUsingDirective(ITreeNode context);
}
[NullableContextAttribute("2")]
public interface JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.IUsingInfoPointer {
    public abstract virtual IUsingInfo Find();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.Statistics.ImportFrequencyInfo : ValueType {
    [CompilerGeneratedAttribute]
private int <NumberOfFilesContainingUsing>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalNumberOfFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInTopMostFrequent>k__BackingField;
    public int NumberOfFilesContainingUsing { get; public set; }
    public int TotalNumberOfFiles { get; public set; }
    public bool IsInTopMostFrequent { get; public set; }
    [CompilerGeneratedAttribute]
public int get_NumberOfFilesContainingUsing();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NumberOfFilesContainingUsing(int value);
    [CompilerGeneratedAttribute]
public int get_TotalNumberOfFiles();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TotalNumberOfFiles(int value);
    [CompilerGeneratedAttribute]
public bool get_IsInTopMostFrequent();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsInTopMostFrequent(bool value);
    public int ToPercentage();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ImportFrequencyInfo left, ImportFrequencyInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ImportFrequencyInfo left, ImportFrequencyInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ImportFrequencyInfo other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.Statistics.UsingStatisticsCalculator : object {
    public static IReadOnlyList`1<UsingStatisticsInfo> GetMostFrequentAndMandatory(IProjectPsiModule psiModule, IReadOnlyList`1<IUsingInfo> mandatoryUsings, int topCount, IProgressIndicator progressIndicator);
    private static Nullable`1<ImportedNamespaceName> TryGetImportedNamespaceName(IUsingSymbolDirective usingSymbolDirective, StringBuilder nameBuilder);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.Statistics.UsingStatisticsInfo : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IUsingInfo <Using>k__BackingField;
    [CompilerGeneratedAttribute]
private ImportFrequencyInfo <ImportFrequencyInfo>k__BackingField;
    [NullableAttribute("1")]
public IUsingInfo Using { get; public set; }
    public ImportFrequencyInfo ImportFrequencyInfo { get; public set; }
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IUsingInfo get_Using();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Using(IUsingInfo value);
    [CompilerGeneratedAttribute]
public ImportFrequencyInfo get_ImportFrequencyInfo();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ImportFrequencyInfo(ImportFrequencyInfo value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(UsingStatisticsInfo left, UsingStatisticsInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(UsingStatisticsInfo left, UsingStatisticsInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UsingStatisticsInfo other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.UsingAliasConflictSearcher : SearchDomainVisitor {
    private AliasedSymbol myAliasedSymbol;
    private string myAliasName;
    private List`1<IUsingAliasDirective> myConflictingDirectives;
    public bool ProcessingIsFinished { get; }
    private UsingAliasConflictSearcher(string aliasName, AliasedSymbol aliasedSymbol);
    public static IReadOnlyList`1<IUsingAliasDirective> Find(UsingAliasInfo usingAliasInfo, string aliasName, IPsiModule psiModule);
    public virtual bool get_ProcessingIsFinished();
    public virtual void VisitPsiSourceFile(IPsiSourceFile sourceFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.UsingAliasInfo : object {
    [CompilerGeneratedAttribute]
private string <AliasName>k__BackingField;
    [CompilerGeneratedAttribute]
private AliasedSymbol <AliasedSymbol>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ExternAlias>k__BackingField;
    public string AliasName { get; }
    public AliasedSymbol AliasedSymbol { get; }
    [NullableAttribute("2")]
public string ExternAlias { get; }
    public bool IsStatic { get; }
    public bool IsAlias { get; }
    public UsingAliasInfo(string aliasName, string externAlias, AliasedSymbol aliasedSymbol);
    [CompilerGeneratedAttribute]
public string get_AliasName();
    [CompilerGeneratedAttribute]
public AliasedSymbol get_AliasedSymbol();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ExternAlias();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool IsValid();
    public sealed virtual IUsingInfoPointer CreatePointer();
    public sealed virtual IUsingDirective CreateUsingDirective(ITreeNode context);
    public bool Equals(UsingAliasInfo other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IUsingInfo obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.UsingDirectiveHelper : object {
    public static IUsingDirective FindEquivalentUsing(ICSharpTypeAndNamespaceHolderDeclaration scope, IUsingDirective usingDirective);
    public static IUsingDirective FindEquivalentUsing(ICSharpTypeAndNamespaceHolderDeclaration scope, IUsingInfo usingInfo);
    public static IList`1<Conflict> GetImportConflicts(ICSharpTypeAndNamespaceHolderDeclaration scope, IUsingInfo usingInfo);
    public static void AddImportToScope(ICSharpTypeAndNamespaceHolderDeclaration scope, IUsingDirective usingDirective);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.UsingInfoUtil : object {
    public static IUsingInfo TryGetInfo(IUsingDirective usingDirective);
    [ExtensionAttribute]
public static bool IsEquivalentTo(IUsingInfo usingInfo, IUsingDirective usingDirective);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.UsingNamespaceInfo : object {
    [CompilerGeneratedAttribute]
private INamespace <ImportedNamespace>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ExternAlias>k__BackingField;
    public INamespace ImportedNamespace { get; }
    [NullableAttribute("2")]
public string ExternAlias { get; }
    public bool IsStatic { get; }
    public bool IsAlias { get; }
    public UsingNamespaceInfo(INamespace importedNamespace, string externAlias);
    [CompilerGeneratedAttribute]
public INamespace get_ImportedNamespace();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ExternAlias();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool IsValid();
    public sealed virtual IUsingInfoPointer CreatePointer();
    private sealed virtual override IUsingInfo JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.IUsingInfoPointer.Find();
    public sealed virtual IUsingDirective CreateUsingDirective(ITreeNode context);
    public bool Equals(UsingNamespaceInfo other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IUsingInfo obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.UsingStaticInfo : object {
    [CompilerGeneratedAttribute]
private DeclaredElementInstance`1<ITypeElement> <ImportedSymbol>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ExternAlias>k__BackingField;
    public DeclaredElementInstance`1<ITypeElement> ImportedSymbol { get; }
    [NullableAttribute("2")]
public string ExternAlias { get; }
    public bool IsStatic { get; }
    public bool IsAlias { get; }
    public UsingStaticInfo(DeclaredElementInstance`1<ITypeElement> importedSymbol, string externAlias);
    [CompilerGeneratedAttribute]
public DeclaredElementInstance`1<ITypeElement> get_ImportedSymbol();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ExternAlias();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool IsValid();
    public sealed virtual IUsingInfoPointer CreatePointer();
    public sealed virtual IUsingDirective CreateUsingDirective(ITreeNode context);
    public bool Equals(UsingStaticInfo other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IUsingInfo obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToGlobalUsing.UsingViewModel : object {
    private IUsingInfoPointer myPointer;
    [CompilerGeneratedAttribute]
private RichText <Text>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IconId <Icon>k__BackingField;
    [CompilerGeneratedAttribute]
private ImportFrequencyInfo <ImportFrequencyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFromInitialSelection>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <Selected>k__BackingField;
    public RichText Text { get; }
    [NullableAttribute("2")]
public IconId Icon { get; }
    public ImportFrequencyInfo ImportFrequencyInfo { get; }
    public bool IsFromInitialSelection { get; }
    public IProperty`1<bool> Selected { get; }
    public UsingViewModel(IUsingInfo usingInfo, ImportFrequencyInfo importFrequencyInfo, bool isFromInitialSelection);
    [CompilerGeneratedAttribute]
public RichText get_Text();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IconId get_Icon();
    [NullableContextAttribute("2")]
public IUsingInfo TryGetUsing();
    [CompilerGeneratedAttribute]
public ImportFrequencyInfo get_ImportFrequencyInfo();
    [CompilerGeneratedAttribute]
public bool get_IsFromInitialSelection();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_Selected();
    [PureAttribute]
public bool IsValid();
    private static ValueTuple`2<RichText, IconId> GetUsingTextAndIcon(IUsingInfo usingInfo);
    [CompilerGeneratedAttribute]
internal static void <GetUsingTextAndIcon>g__AppendElementPresentation|19_0(IDeclaredElement element, ISubstitution substitution, <>c__DisplayClass19_0& );
    [CompilerGeneratedAttribute]
internal static void <GetUsingTextAndIcon>g__AppendTypePresentation|19_1(IType type, <>c__DisplayClass19_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <GetUsingTextAndIcon>g__AppendExternAlias|19_2(string externAlias, <>c__DisplayClass19_0& );
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.CSharp.Resources.Strings", "ConvertToNonGlobalUsing_Action_Text")]
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToNonGlobalUsing.ConvertToNonGlobalUsingAction : ExtensibleRefactoringAction`1<ConvertToNonGlobalUsingWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToNonGlobalUsing.ConvertToNonGlobalUsingDataProvider : object {
    private IList`1<IUsingDirective> myUsingDirectives;
    public ConvertToNonGlobalUsingDataProvider(IEnumerable`1<IUsingDirective> usingDirectives);
    public sealed virtual IList`1<IUsingDirective> GetUsingDirectives();
}
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToNonGlobalUsing.ConvertToNonGlobalUsingRefactoring : DrivenRefactoringBase`1<ConvertToNonGlobalUsingWorkflow> {
    public ConvertToNonGlobalUsingRefactoring(ConvertToNonGlobalUsingWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool Execute(IProgressIndicator pi);
    [NotNullAttribute]
private static UsingDirectivesUsageFileMap GetUsingDirectivesUsageFileMap(ICollection`1<IUsingDirective> usingDirectives, IProgressIndicator pi);
    private static IEnumerable`1<IPsiModule> GetPsiModules(IUsingDirective usingDirective);
    private static void InlineGlobalUsingDirectives(ICollection`1<IUsingDirective> usingDirectives, UsingDirectivesUsageFileMap usagesMap, IProgressIndicator pi);
    private static void InlineGlobalUsingDirective(IUsingDirective usingDirective, UsingDirectivesUsageFileMap usagesMap, IProgressIndicator pi);
    [NotNullAttribute]
private static IReadOnlyList`1<IUsingDirective> FindUsingDirectivesToRemove(IUsingDirective usingDirective, IProgressIndicator pi);
    private static void AddImportToScope(ICSharpTypeAndNamespaceHolderDeclaration scope, IUsingDirective usingDirective);
    private static IList`1<ICSharpTypeAndNamespaceHolderDeclaration> GetImportScopes(IUsingDirective usingDirective, UsingDirectivesUsageFileMap usagesMap, ICSharpFile file);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToNonGlobalUsing.ConvertToNonGlobalUsingWorkflow : DrivenRefactoringWorkflow {
    private IConvertToNonGlobalUsingDataProvider myDataProvider;
    [CompilerGeneratedAttribute]
private IList`1<IUsingDirective> <UsingDirectives>k__BackingField;
    public string Title { get; }
    public HelpId HelpKeyword { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public IList`1<IUsingDirective> UsingDirectives { get; private set; }
    public ConvertToNonGlobalUsingWorkflow(ISolution solution, string actionId);
    public virtual string get_Title();
    public virtual HelpId get_HelpKeyword();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    [CompilerGeneratedAttribute]
public IList`1<IUsingDirective> get_UsingDirectives();
    [CompilerGeneratedAttribute]
private void set_UsingDirectives(IList`1<IUsingDirective> value);
    public virtual bool IsAvailable(IDataContext context);
    [NotNullAttribute]
private IEnumerable`1<IUsingDirective> GetSelectedUsingDirectives(IDataContext context);
    [NotNullAttribute]
public static IEnumerable`1<IUsingDirective> GetSelectedUsingDirectives(IPsiView psiView);
    public virtual bool Initialize(IDataContext context);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public void SetDataProvider(IConvertToNonGlobalUsingDataProvider dataProvider);
}
[RefactoringWorkflowProviderAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToNonGlobalUsing.ConvertToNonGlobalUsingWorkflowProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToNonGlobalUsing.GlobalUsingDirectiveFilesCollector : SearchDomainVisitor {
    [NotNullAttribute]
private HashSet`1<IUsingDirective> myUsingDirectivesSet;
    [NotNullAttribute]
private Dictionary`2<IUsingDirective, IUsingDirective> myUsingDirectivesMap;
    [NotNullAttribute]
private UsingDirectivesUsageFileMap myUsagesMap;
    public bool ProcessingIsFinished { get; }
    public GlobalUsingDirectiveFilesCollector(IEnumerable`1<IUsingDirective> usingDirectives);
    public virtual void VisitPsiSourceFile(IPsiSourceFile sourceFile);
    public virtual bool get_ProcessingIsFinished();
    public UsingDirectivesUsageFileMap GetUsagesMap();
}
public interface JetBrains.ReSharper.Refactorings.CSharp.ConvertToNonGlobalUsing.IConvertToNonGlobalUsingDataProvider {
    public abstract virtual IList`1<IUsingDirective> GetUsingDirectives();
}
public class JetBrains.ReSharper.Refactorings.CSharp.ConvertToNonGlobalUsing.UsingDirectivesUsageFileMap : object {
    [NotNullAttribute]
private Dictionary`2<IUsingDirective, Dictionary`2<ICSharpFile, IList`1<IReference>>> myUsages;
    public void AddUsages(IUsingDirective usingDirective, ICSharpFile file, IList`1<IReference> references);
    [NotNullAttribute]
public IEnumerable`1<ICSharpFile> GetFiles(IUsingDirective usingDirective);
    [NotNullAttribute]
public IEnumerable`1<IReference> GetFileUsages(IUsingDirective usingDirective, ICSharpFile file);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Refactorings.CSharp.CopyType.CSharpLanguageSpecificCopyType : CLRLanguageSpecificCopyTypeBase {
    public virtual bool IsAvailable(IDeclaration typeDeclaration);
    public virtual IDeclaration CreateCopy(IDeclaration typeDeclaration, IFile file, string qualifiedName, ITreeNode& alreadyCreatedScope);
    public virtual string GenerateFileName(IDeclaration typeDeclaration, string name);
    public virtual IConflictSearcher GetConflictSearcher(IDeclaredElement typeElement, string qualifiedName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CSharp.CSharpIntroduceVariableHelper : IntroduceVariableHelper {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual bool CheckAvailability(ITreeNode element);
    public virtual ITreeNode GetScope(ITreeNode element);
    public virtual bool CheckOccurrence(ITreeNode masterExpression, ITreeNode occurrence);
    public IReadOnlyList`1<IDeconstruction> GetAvailableDeconstructions(ITreeNode sourceExpression);
    public virtual bool AdditionalInitialization(IntroduceVariableWorkflow workflow, ITreeNode expression, IDataContext context);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.CSharp.CSharpRefactoringLanguageService : InternalRefactoringLanguageService {
    public RefactoringsHelper Helper { get; }
    public virtual RefactoringsHelper get_Helper();
    public virtual IMoveTypeToOuterScope MoveTypeToOuterScope(MoveTypeToOuterScopeRefactoring refactoring);
    public virtual IConvertRefactoring Property2Function(Property2FunctionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IConvertRefactoring Indexer2Function(Property2FunctionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IConvertRefactoring Function2Property(Function2PropertyWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IPullUp PullUpRefactoring(ISolution solution, IRefactoringDriver driver);
    public virtual IPushDown PushDownRefactoring(ISolution solution, IRefactoringDriver driver);
    public virtual IConvertRefactoring Function2Indexer(Function2PropertyWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IExtractSuperclass ExtractSuperclassRefactoring(ISolution solution, IRefactoringDriver driver);
    public virtual IExtractInterface ExtractInterfaceRefactoring(ISolution solution, IRefactoringDriver driver);
    public virtual IConvert CreateAbstract2Interface(Abstract2InterfaceWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IConvert CreateInterface2Abstract(Interface2AbstractWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual TransformParametersBase CreateTransformParameters(TransformParametersWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IntroduceVariableBase CreateIntroduceVariable(IntroduceLocalWorkflowBase workflow, ISolution solution, IRefactoringDriver driver);
    public virtual Static2ExtensionBase CreateStatic2Extension(Static2ExtensionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual ConstructorToFactoryMethodBase CreateConstructor2FactoryMethod(Constructor2FactoryMethodWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual UseBaseTypeBase CreateUseBaseType(UseBaseTypeWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual EncapsulateFieldBase CreateEncapsulateField(EncapsulateFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual MoveStaticMembers CreateMoveStaticMembers(MoveStaticMembersWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual MoveStaticMembersHelper CreateMoveStaticMembersHelper();
    public virtual Property2AutoBase CreateProperty2Auto(Property2AutoWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual Anonymous2Declared CreateAnonymous2Declared(Anonymous2DeclaredWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineMethod CreateInlineMethod(InlineMethodWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IntroduceParameterBase CreateIntroRefactoring(IntroduceParameterWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IntroduceFieldBase CreateIntroduceField(IntroduceFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineFieldBase CreateInlineField(InlineFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineVarBase CreateInlineVar(InlineVarWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineParameterBase CreateInlineParameter(InlineParameterWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual SafeDeleteBase CreateSafeDeleteBase(SafeDeleteWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual ParamsModifierConvertBase CreateParamsModifier(ParamsModifierWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineParameterHelper CreateInlineParameterHelper();
    public virtual IMakeStaticHelper CreateMakeStaticHelper();
    public virtual SafeDeleteHelperUnsupported CreateSafeDeleteHelper();
    public virtual AdjustNamespacesHelperBase CreateAdjustNamespaceHelper();
    public virtual MoveIntoMatchingFilesHelperBase CreateMoveIntoMatchingFilesHelper();
    public virtual MoveToFileHelperBase CreateMoveToFileHelper();
    public virtual MoveToFolderHelperBase CreateMoveToFolderHelper();
    public virtual MakeStatic CreateMakeStaticHelper(MakeStaticWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual MoveToNamespaceHelperBase CreateMoveToNamespaceHelper();
    public virtual IntroduceVariableHelper CreateIntroduceVariableHelper();
    public virtual ExtractClassHelper CreateExtractClassHelper(ExtractClassWorkflow workflow);
    public virtual ExtractClassRefactoringExec ExtractClassExec(ExtractClassWorkflow workflow, IRefactoringDriver driver);
    public virtual InlineClassHelper CreateInlineClassHelper(InlineClassWorkflow workflow);
    public virtual IInlineClassRefactoringExec InlineClassExec(InlineClassWorkflow workflow);
    public virtual MoveInstanceMethodHelper CreateMoveInstanceMethodHelper(MoveInstanceMethodWorkflow moveInstanceMethodWorkflow);
    public virtual InvertBoolHelper CreateInvertBoolHelper(InvertBoolWorkflow invertBoolWorkflow);
    public virtual IType2PartialHelper CreateType2Partial(Type2PartialWorkflow type2PartialWorkflow);
    public virtual IUnresolvedTypesChooser GetUnresolvedTypesChooser(ITreeNode context);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Refactorings.CSharp.CSharpRefactoringService : object {
    [NotNullAttribute]
public sealed virtual ILocalScope[] FindScopesByDeclaredElement(IDeclaredElement declaredElement);
    [CanBeNullAttribute]
private static ILocalScope GetBodyScope(ICSharpDeclaration declaration);
}
public class JetBrains.ReSharper.Refactorings.CSharp.CSharpRefactoringsHelper : RefactoringsHelper {
    [CompilerGeneratedAttribute]
private static CSharpRefactoringsHelper <Instance>k__BackingField;
    public static CSharpRefactoringsHelper Instance { get; }
    private static CSharpRefactoringsHelper();
    [CompilerGeneratedAttribute]
public static CSharpRefactoringsHelper get_Instance();
    public virtual bool IndexerIsPresented();
    public virtual bool ExtensionMethodsSupported(ITypeDeclaration typeDeclaration);
    public virtual IProperty2AutoChecker CreateProperty2AutoChecker();
    public virtual bool CheckAnonymous2Declared(IDataContext context, ITreeNode& objectCreationElement);
    public virtual bool CheckForIntroduceAccessible(ITreeNode expression, IParametersOwner parametersOwner);
    public virtual bool DeclarationHasBody(IDeclaredElement element);
    public virtual bool Function2PropertyAvailable(IMethod method);
    public virtual ITreeNode GetContainingLambda(ITreeNode expression);
    public virtual INamespaceRedundancyProblemFixer NamespaceRedundancyFileFixer(INamespace namespace, IFile file);
    public IntroduceParameterBase CreateIntroRefactoring(IntroduceParameterWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IExpression IntroParameterGetInitializer(ILocalVariable variable);
    public virtual bool CanUseExplicitly(IType type, ITreeNode context);
    public virtual IEnumerable`1<IDeclaredElement> GetLocals(IExpression expression, IParametersOwner owner);
    public virtual IDeclaredElement GetPrimaryQueryElement(IDeclaredElement variable);
    public virtual IConstructor TryGetPrimaryConstructor(ITypeElement typeElement);
    private bool IsLetVariable(IDeclaredElement element);
    public virtual bool IsPartialMethod(ITypeMember member);
    public virtual bool IsAsyncMethod(ITypeMember member);
    public virtual bool IsLocalFunction(IParametersOwner parametersOwner);
    public virtual bool IsValidMember(ITypeMember member);
    public virtual bool CanBeDefaultParameter(IExpression expression);
    public virtual bool CanHaveDefaultProperty();
    public virtual bool CanIntroduceVariableFrom(IExpression expression);
    public virtual bool CanIntroduceFieldFrom(IExpression expression);
    public virtual bool CanIntroduceFieldFrom(ILocalVariable localVariable);
    public virtual bool CanIntroduceFieldFrom(IParameter parameter);
    public virtual IType GetParameterType(IExpression selectedExpression);
    public virtual bool CanInlineVariable(IDeclaredElement declaredElement);
    [NotNullAttribute]
private static IType InferReturnTypeWithAsync(IAnonymousFunctionType anonymousFunctionType);
    [CanBeNullAttribute]
private static IType GetMatchingDeclaredType(ICSharpExpression expression);
    public virtual TMethod GetMainElement(TMethod parametersOwner);
    public virtual ITypeDeclaration GetTypeDeclarationForField(ITypeDeclaration typeDeclaration, Boolean& baseTypeChoosed);
    public virtual IntroduceFieldAnalyser CreateIntroFieldAnalyser();
    public virtual bool CanUseInstanceFields(ITreeNode element);
    public virtual bool ReferencesRangeVariables(IExpression expression);
    public virtual bool CanUseRecordType(ITreeNode context, bool requireInitOnlyMembers);
    public virtual ITreeNode GetStatementVisibleForAll(IReadOnlyList`1<IExpression> expressions);
    public virtual ITreeNode GetContainingStatementEnsureableNode(IReadOnlyList`1<IExpression> expressions);
    public virtual bool GetShouldBeConstant(IExpression expression);
    public virtual bool IsIterator(IDeclaration declaration);
    public virtual bool InitializerIsRecursive(IDeclaredElement element);
    public virtual IArgumentsOwner GetArgumentsOwner(IReference& reference, bool replaceMethodGroup);
    public virtual void SetNew(ITypeMemberDeclaration typeMember, bool isNew);
    public virtual bool IsNew(IDeclaration declaration);
    public virtual InlineVarAnalyserBase CreateInlineVarAnalyser(InlineVarWorkflow workflow);
    public virtual bool IsInvocationReference(IReference reference);
    [CanBeNullAttribute]
private static ITokenNode NewModifier(ICSharpModifiersOwnerDeclaration node);
    public virtual IReference RemoveQualification(IReference reference);
    public virtual bool IsNonQualifiedStaticMemberReference(IReference reference);
    public virtual IReference AddQualification(IReference reference);
    public virtual bool CanContainExtensionMethods(IClass classType, IMethod candidate);
    public virtual bool IsReferenceName(ITreeNode element);
    public virtual bool HasIndexerToFunction();
    public virtual bool CanExtractSuperclass(IDeclaration declaration);
    public virtual bool CanHaveAccessRights(AccessRights accessRights, ITreeNode element);
    public virtual bool CanSafelyBeMadeStatic(IMethod method);
    public virtual bool IsSupportedExtensionMethodQualifierParameterKind(IParameter parameter);
    public virtual IType GetITypeOrFunctionType(IExpressionType expressionType);
    public virtual bool CanBeParamsParameter(IParameter parameter);
    public virtual bool CanBeInlined(IDeclaredElement element);
    public virtual IReadOnlyList`1<IParametersOwnerDeclaration> GetIntroduceParameterCandidates(IExpression sourceExpression);
    public virtual IType GetVariableTypeWithEffectiveNullability(ILocalVariable variable);
    public virtual void EnsureNullableAnalysisIsFinished(IExpression expression);
    [CompilerGeneratedAttribute]
internal static bool <DeclarationHasBody>g__AllAccessorsHasBodies|9_0(IAccessorOwnerDeclaration accessorOwnerDeclaration);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ElementSearcherInSubquery : object {
    private SubQuerySelection mySelection;
    private ITreeNode myElement;
    private States myState;
    private bool myFound;
    public bool ProcessingIsFinished { get; }
    private ElementSearcherInSubquery(SubQuerySelection selection, ITreeNode element);
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
    public static bool Contains(SubQuerySelection selection, ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.CSharp.EncapsulateField.CSharpEncapsulateField : EncapsulateFieldBase {
    private bool myShouldReplaceInitWithSet;
    public CSharpEncapsulateField(EncapsulateFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IDeclaredElement CreatePropertyDeclaration(IDeclaredElement fieldElement);
    public virtual void RemoveFieldDeclaration(IDeclaredElement field);
    public virtual void EncapsulateReference(IReference reference, ReferenceAccessType accessType, IDeclaredElement field, IDeclaredElement property, EncapsulateFieldBase targetEncapsulateField, bool isExternalUsage);
    public virtual void FinishProcessingReferences(IDeclaredElement property, IDeclaredElement declaredElement);
    protected sealed virtual void ProcessReference(IReference reference, ReferenceAccessType accessType, IDeclaredElement property);
    [NotNullAttribute]
private IReference DoReplaceReference(IReference reference, IProperty property);
    [CanBeNullAttribute]
private IReference ReplaceReference(IReference reference, IProperty property, IDeclaredElement field, ReferenceAccessType accessType, bool isExternal);
    [CanBeNullAttribute]
private IReference TryRewriteReadWriteForPartialEncapsulation(IReference reference, IProperty property, IDeclaredElement field);
    [PureAttribute]
private ReferenceKind GetTargetPropertyReferenceKind();
    [PureAttribute]
private ReferenceAccessType ToReferenceAccessKind(ValueAccessClassification classification);
    public static void CheckFieldReplacementWithReadonlyRefProperty(IReference reference, ICSharpExpression usageExpression, IRefactoringDriver driver);
    private bool CheckPolymorphismConflicts(IReference reference, IProperty property, IAccessor accessor);
    private void EnsurePropertyWriteable(IProperty property, IDeclaredElement field, ITreeNode context);
    [CanBeNullAttribute]
private IReferenceExpressionReference ReplaceComplexReference(TExpression complexExpression, Func`3<TExpression, ICSharpExpression, ICSharpExpression> transform, IReferenceExpression fieldReferenceExpression, IProperty property, IDeclaredElement field);
    public virtual IDeclaredElement EnsureReadable(IDeclaredElement property, IDeclaredElement field);
    public virtual IDeclaredElement EnsureWriteable(IDeclaredElement property, IDeclaredElement field);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
private IReference <ReplaceReference>g__ReportAndBindToPropertyIfFieldWouldBeRemoved|8_0(string usageKind, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
private void <EnsurePropertyWriteable>g__ShouldReplaceInitWithSet|14_0(<>c__DisplayClass14_0& );
    [CompilerGeneratedAttribute]
internal static IReferenceExpression <ReplaceComplexReference>g__CreatePropertyExpression|15_0(IReferenceExpression referenceExpression, <>c__DisplayClass15_0`1& );
    [CompilerGeneratedAttribute]
internal static IAccessorDeclaration <EnsureReadable>g__CreateReadAccessor|16_0(<>c__DisplayClass16_0& );
    [CompilerGeneratedAttribute]
internal static IAccessorDeclaration <EnsureWriteable>g__CreateWriteAccessor|17_0(<>c__DisplayClass17_0& );
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.CSharp.EncapsulateField.CSharpEncapsulateFieldUtil : ClrEncapsulateFieldUtilBase {
    public virtual bool CanEncapsulateToAutoProperty(IDeclaredElement field);
    public virtual bool LanguageSupportsPrivateProtectedModifier(IDeclaredElement field);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractClass.CsExtractClassAnalyzer : ExtractClassAnalyzer {
    public virtual void LoadGraph(List`1<ExtractClassMemberNode> members);
    [CompilerGeneratedAttribute]
internal static void <LoadGraph>g__FillParents|0_0(ITreeNode expression, ExtractClassMemberNode typeMember, <>c__DisplayClass0_0& );
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractClass.CsExtractClassHelper : ExtractClassHelper {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual ITypeDeclaration InsertToNewFile(ITypeDeclaration declarationToInsert, ITypeDeclaration tagDeclaration, string targetNamespace, IProjectFile fileNearby);
    public virtual ExtractClassAnalyzer GetAnalyzer(ITypeElement owner, string namespaceName, VirtualFileSystemPath pathName, Lifetime lifetime);
    protected static JetHashSet`1<ITypeParameter> CollectParameters(JetHashSet`1<ITypeParameter> sourceTypeTypeParameters, ITypeElement source);
    protected static List`1<ITypeParameter> GetUsedTypeParameters(IClassLikeDeclaration sourceTypeDeclaration);
    public virtual ITypeDeclaration CreateTargetTypeElement(Dictionary`2& typeParams, ExtractClassWorkflow workflow);
    private static Dictionary`2<ITypeParameter, ITypeParameter> AddTypeParameters(IClassLikeDeclaration targetTypeDeclaration, IClassLikeDeclaration sourceTypeDeclaration, ExtractClassDataModel model);
    public virtual ITypeDeclaration InsertSibling(ITypeDeclaration declarationToInsert, ITypeDeclaration tagDeclaration);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractClass.CsExtractClassRefactoringExec : ExtractClassRefactoringExec {
    private ExtractClassDataModel myDataModel;
    public CsExtractClassRefactoringExec(ExtractClassWorkflow workflow, IRefactoringDriver driver);
    public virtual void AddField(ITypeElement sourceTypeElement, ITypeElement targetTypeElement);
    public virtual void AddProperties();
    public void AddAccessorsToProperty(IProperty property, IField field);
    public virtual void CreateConstructors();
    public virtual bool CutAndPaste(ResolveImagesRepository repository, Dictionary`2<ITypeParameter, ITypeParameter> createdTypeParametersMap, IProgressIndicator pi);
    public virtual void Rebind(IReference reference, ExtractClassMemberNode memberToRebind, IDeclaredElement propertyMember);
    private void RebindSupertypeMember(ICSharpTypeMemberDeclaration containingTypeMemberDeclaration, IReferenceExpression refExpression);
    private void RebindReferenceName(ExtractClassMemberNode memberToRebind, IReferenceName referenceName);
    public virtual void ResolveConflicts(IProgressIndicator subPi);
    private void ResolveThisConflict(MemberNode member);
    private static void ResolveReadonlyConflict(MemberNode member);
    private bool ResolveChangeAccessConflict(ExtractClassMemberNode member);
    public void ChangeAccessModifiers(IProperty property);
    public IPropertyDeclaration CreatePropertyDeclaration(ITypeDeclaration sourceTypeDeclaration, IType type, ITypeMemberDeclaration fieldDeclaration, bool addSetter, bool isStatic);
    private void AddThisParameter(IConstructorDeclaration targetConstructorDeclaration);
    public void AddConstructors();
    public void CreateConstructor(ConstructorNode constructorNode, bool insertThis);
    private void AddCall(CSharpElementFactory factory, ConstructorCall constructorCall, bool insertThis);
    private void AddParameter(CSharpElementFactory factory, IConstructorDeclaration targetConstructorDeclaration, IDeclaredElement parameter);
    public bool CreateDelegatingCopy(ExtractClassMemberNode member, ITypeMemberDeclaration memberDeclaration, IClassLikeDeclaration targetTypeDeclaration, ResolveImagesRepository repository);
    public void FixExtensionMethod(IMethodDeclaration targetMethodDeclaration);
    private static ISubstitution GetSubstitution(ITypeMemberDeclaration memberDeclaration, IClassMemberDeclaration newMemberDeclaration);
    private void RebindCopy(ITypeMemberDeclaration newMemberDeclaration, ISubstitution substitution);
    private static void CopyMethod(IClassMemberDeclaration targetClassMemberDeclaration, IMethodDeclaration sourceMethodDeclaration, IDeclaredElement caller);
    private void CopyProperty(ICSharpTypeMemberDeclaration targetClassMemberDeclaration, IDeclaredElement caller, ExtractClassMemberNode data, IProperty property);
    public virtual void CreateConstructors(ExtractClassDataModel dataModel);
    private void ProceedStatement(IStatement statement, List`1& parameters, ConstructorCall& constructorCall, List`1& possibleBody, string targetClassName, ExtractClassDataModel dataModel);
    public ReferenceResult ProcessReference(IExpression expression, ExtractClassDataModel modelAnalyzer);
    private void ProceedConstructorCopy(List`1<ConstructorNode> constructorInfos, ConstructorNode constructorNode);
    [CompilerGeneratedAttribute]
private bool <AddField>b__2_2(ExtractClassMemberNode member);
    [CompilerGeneratedAttribute]
private bool <AddField>b__2_3(IReference reference);
    [CompilerGeneratedAttribute]
private bool <AddProperties>b__3_1(IReference reference);
}
public enum JetBrains.ReSharper.Refactorings.CSharp.ExtractClass.ReferenceResult : Enum {
    public int value__;
    public static ReferenceResult Param;
    public static ReferenceResult Free;
    public static ReferenceResult Included;
    public static ReferenceResult Literal;
    public static ReferenceResult None;
}
internal static class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod.CSharpExtractMethodUtil : object {
    [PureAttribute]
public static bool CanBeStatic(ITreeRange treeRange);
    [PureAttribute]
public static bool CanBeInstance(ITreeNode node);
    public static IType PatchType(IType type, Dictionary`2<IType, ITypeParameter> type2Parameter, IPsiModule module);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.CSharpExtractLocalFunctionTargetSiteContext : object {
    [NotNullAttribute]
private IStatementPositionCandidate myPosition;
    [CanBeNullAttribute]
private string myPresentation;
    public bool IsLocalFunctionContext { get; }
    public bool PlaceBeforeAnchor { get; }
    public bool BaseTypeIsSelected { get; }
    public CSharpExtractLocalFunctionTargetSiteContext(IStatementPositionCandidate position, string presentation);
    public sealed virtual bool get_IsLocalFunctionContext();
    public sealed virtual bool get_PlaceBeforeAnchor();
    public sealed virtual bool get_BaseTypeIsSelected();
    public sealed virtual ICSharpTreeNode GetTargetSiteContext();
    public sealed virtual IDeclaration AddDeclaration(IDeclaration declaration);
    [NotNullAttribute]
[PureAttribute]
public static CSharpExtractLocalFunctionTargetSiteContext FromTopLevelCode(ITopLevelCode topLevelCode, ICodePositionPreviewProvider previewProvider);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IList`1<LocalFunctionScopeElement> CollectPossibleTargetContexts(ITreeRange source, ICodePositionPreviewProvider previewProvider);
    [NotNullAttribute]
public string Dump();
    [ContractAnnotationAttribute("parent: null => false")]
private static bool CouldBeLocalFunctionDeclarationSite(ICSharpTreeNode parent, ITreeRange source);
    [CompilerGeneratedAttribute]
internal static void <CollectPossibleTargetContexts>g__CreateScopes|12_0(ICSharpTreeNode anchor, ICSharpTreeNode descriptionPointer, ITreeRange sourceRange, IList`1<LocalFunctionScopeElement> results, ICodePositionPreviewProvider previewProvider);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.CSharpExtractMethodDataModel : object {
    [CompilerGeneratedAttribute]
private ICSharpExtractMethodControlFlowInspectionResult <AnalysisResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtractedEntityKind <ExtractedEntityKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MakeStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MakeVirtual>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessRights <AccessRights>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpExtractMethodTargetSiteContext <TargetSiteContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    public ICSharpExtractMethodControlFlowInspectionResult AnalysisResult { get; public set; }
    public ExtractedEntityKind ExtractedEntityKind { get; public set; }
    public bool MakeStatic { get; public set; }
    public bool MakeVirtual { get; public set; }
    public AccessRights AccessRights { get; public set; }
    public ICSharpExtractMethodTargetSiteContext TargetSiteContext { get; public set; }
    public string MethodName { get; public set; }
    [CompilerGeneratedAttribute]
public ICSharpExtractMethodControlFlowInspectionResult get_AnalysisResult();
    [CompilerGeneratedAttribute]
public void set_AnalysisResult(ICSharpExtractMethodControlFlowInspectionResult value);
    [CompilerGeneratedAttribute]
public ExtractedEntityKind get_ExtractedEntityKind();
    [CompilerGeneratedAttribute]
public void set_ExtractedEntityKind(ExtractedEntityKind value);
    [CompilerGeneratedAttribute]
public bool get_MakeStatic();
    [CompilerGeneratedAttribute]
public void set_MakeStatic(bool value);
    [CompilerGeneratedAttribute]
public bool get_MakeVirtual();
    [CompilerGeneratedAttribute]
public void set_MakeVirtual(bool value);
    [CompilerGeneratedAttribute]
public AccessRights get_AccessRights();
    [CompilerGeneratedAttribute]
public void set_AccessRights(AccessRights value);
    [CompilerGeneratedAttribute]
public ICSharpExtractMethodTargetSiteContext get_TargetSiteContext();
    [CompilerGeneratedAttribute]
public void set_TargetSiteContext(ICSharpExtractMethodTargetSiteContext value);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
public void set_MethodName(string value);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.CSharpExtractMethodLocalFunction : object {
    [NotNullAttribute]
private IDeclaredElementPointer`1<ILocalFunction> myLocalFunctionPointer;
    [CompilerGeneratedAttribute]
private CSharpExtractMethodLocalFunctionKind <Kind>k__BackingField;
    public CSharpExtractMethodLocalFunctionKind Kind { get; }
    public CSharpExtractMethodLocalFunction(ILocalFunction localFunction, CSharpExtractMethodLocalFunctionKind kind);
    [CompilerGeneratedAttribute]
public CSharpExtractMethodLocalFunctionKind get_Kind();
    [CanBeNullAttribute]
public ILocalFunction GetLocalFunction();
}
public enum JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.CSharpExtractMethodLocalFunctionKind : Enum {
    public int value__;
    public static CSharpExtractMethodLocalFunctionKind ExtractedCode;
    public static CSharpExtractMethodLocalFunctionKind RegularMethod;
}
public static class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.CSharpExtractMethodLogic : object {
    [CanBeNullAttribute]
public static CSharpExtractMethodWorkflowBase GetExtractMethodWorkflowForRange(ISolution solution, IFile psiFile, TreeTextRange selectedRange, DocumentRange documentSelection);
    public static bool IsRangeAcceptableForExtractMethod(ISolution solution, IFile psiFile, TreeTextRange selectedRange, DocumentRange documentSelection);
    [CanBeNullAttribute]
public static object TryFindRangeToExtract(IFile psiFile, TreeTextRange selectedRange, DocumentRange documentSelection);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.CSharpExtractMethodModel : ExtractMethodModel {
    private IExtractMethodWorkflow myWorkflow;
    private ITreeRange mySelectedRange;
    private ICSharpExtractMethodControlFlowInspectionResult myBaseAnalysisResult;
    private bool myDenyAdditionalStatements;
    [CanBeNullAttribute]
private INamesCollection myCollection;
    protected IPsiServices myPsiServices;
    [CompilerGeneratedAttribute]
private CSharpExtractMethodParameter <DefaultReturnParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpExtractMethodControlFlowInspectionResult <AnalysisResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpExtractMethodTargetSiteContext <TargetSiteContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LocalFunctionScopeElement> <PossibleLocalFunctionScopes>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtractedEntityKind <ExtractedEntityKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MakeStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MakeVirtual>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessRights <AccessRights>k__BackingField;
    [CompilerGeneratedAttribute]
private NamingPolicy <NamingPolicy>k__BackingField;
    public bool EnablePrivate { get; }
    public CSharpExtractMethodParameter DefaultReturnParameter { get; }
    public ICSharpExtractMethodControlFlowInspectionResult AnalysisResult { get; public set; }
    public ICSharpExtractMethodTargetSiteContext TargetSiteContext { get; public set; }
    [NotNullAttribute]
public IList`1<LocalFunctionScopeElement> PossibleLocalFunctionScopes { get; }
    public ExtractedEntityKind ExtractedEntityKind { get; }
    public bool MakeStatic { get; private set; }
    public bool MakeVirtual { get; private set; }
    public AccessRights AccessRights { get; private set; }
    public string Title { get; }
    public string Description { get; }
    public IReturnParameter ReturnParameter { get; public set; }
    [NotNullAttribute]
public NamingPolicy NamingPolicy { get; }
    public bool CanChangeName { get; }
    public bool CanChangeReturn { get; }
    public bool CanHaveParameters { get; }
    public CSharpExtractMethodModel(IExtractMethodWorkflow workflow, ICSharpExtractMethodControlFlowInspectionResult analysisResult, ITreeRange selectedRange, ICSharpExtractMethodTargetSiteContext targetSiteContext, IPsiSourceFile psiSourceFile, Lifetime lifetime, ExtractedEntityKind kind);
    public bool get_EnablePrivate();
    [CompilerGeneratedAttribute]
public CSharpExtractMethodParameter get_DefaultReturnParameter();
    [CompilerGeneratedAttribute]
public ICSharpExtractMethodControlFlowInspectionResult get_AnalysisResult();
    [CompilerGeneratedAttribute]
public void set_AnalysisResult(ICSharpExtractMethodControlFlowInspectionResult value);
    [CompilerGeneratedAttribute]
public ICSharpExtractMethodTargetSiteContext get_TargetSiteContext();
    [CompilerGeneratedAttribute]
public void set_TargetSiteContext(ICSharpExtractMethodTargetSiteContext value);
    [CompilerGeneratedAttribute]
public IList`1<LocalFunctionScopeElement> get_PossibleLocalFunctionScopes();
    [CompilerGeneratedAttribute]
public ExtractedEntityKind get_ExtractedEntityKind();
    [CompilerGeneratedAttribute]
public bool get_MakeStatic();
    [CompilerGeneratedAttribute]
private void set_MakeStatic(bool value);
    [CompilerGeneratedAttribute]
public bool get_MakeVirtual();
    [CompilerGeneratedAttribute]
private void set_MakeVirtual(bool value);
    [CompilerGeneratedAttribute]
public AccessRights get_AccessRights();
    [CompilerGeneratedAttribute]
private void set_AccessRights(AccessRights value);
    [NotNullAttribute]
private NamingPolicy GetNamingPolicy(NamedElementKinds& namedElementKinds);
    public virtual void InitializeNaming();
    public void RefineControlFlowAnalysis(ICSharpExtractMethodTargetSiteContext targetSiteContext);
    public virtual string get_Title();
    public virtual string get_Description();
    public virtual IReturnParameter get_ReturnParameter();
    public virtual void set_ReturnParameter(IReturnParameter value);
    [CompilerGeneratedAttribute]
public virtual NamingPolicy get_NamingPolicy();
    public virtual bool get_CanChangeName();
    public virtual bool get_CanChangeReturn();
    public virtual bool get_CanHaveParameters();
    public virtual BeGrid GetSpecificPresentation(Lifetime lifetime, Action update);
    public virtual string GetPreviewElement();
    [NotNullAttribute]
public LocalFunctionSignatureInfo GetLocalFunctionSignatureInfo(LocalFunctionScopeElement scope);
    public virtual IEnumerable`1<IReturnParameter> GetPossibleReturnParameters();
    public virtual IEnumerable`1<ParameterElement> GetPossibleParameters();
    public virtual String[] GetColumns();
}
public abstract class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.CSharpExtractMethodParameter : ParameterElement {
    private IProperty`1<string> myCoercedName;
    [CompilerGeneratedAttribute]
private CSharpExtractMethodParameterKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasDeclarationInside>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasUsagesOutside>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<NameRoot> <Roots>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeOwnerName>k__BackingField;
    public CSharpExtractMethodParameterKind Kind { get; public set; }
    public string CoercedName { get; public set; }
    public bool HasDeclarationInside { get; public set; }
    public bool HasDeclarationOutside { get; }
    public bool HasUsagesOutside { get; public set; }
    public IEnumerable`1<NameRoot> Roots { get; public set; }
    [UsedImplicitlyAttribute]
public string DisplayKind { get; }
    public bool IsForReturnValue { get; }
    public bool IsRenamed { get; }
    public VariableDeclarationKind DeclarationKind { get; }
    public bool IsUsingDeclarationVariable { get; }
    public string TypeOwnerName { get; public set; }
    [CompilerGeneratedAttribute]
public CSharpExtractMethodParameterKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(CSharpExtractMethodParameterKind value);
    public string get_CoercedName();
    public void set_CoercedName(string value);
    [CompilerGeneratedAttribute]
public bool get_HasDeclarationInside();
    [CompilerGeneratedAttribute]
public void set_HasDeclarationInside(bool value);
    public virtual bool get_HasDeclarationOutside();
    [CompilerGeneratedAttribute]
public bool get_HasUsagesOutside();
    [CompilerGeneratedAttribute]
public void set_HasUsagesOutside(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<NameRoot> get_Roots();
    [CompilerGeneratedAttribute]
public void set_Roots(IEnumerable`1<NameRoot> value);
    public string get_DisplayKind();
    public virtual bool get_IsForReturnValue();
    public bool get_IsRenamed();
    public virtual VariableDeclarationKind get_DeclarationKind();
    public bool get_IsUsingDeclarationVariable();
    [CompilerGeneratedAttribute]
public string get_TypeOwnerName();
    [CompilerGeneratedAttribute]
public void set_TypeOwnerName(string value);
    [NotNullAttribute]
public virtual IType GetParameterType(IPsiModule module, ICSharpExtractMethodControlFlowInspectionResult inspectionResult, ParameterKind kind);
    [NotNullAttribute]
public virtual IReadOnlyList`1<IType> GetAttributes(ITreeNode context, IType parameterType, ParameterKind kind);
    [NotNullAttribute]
protected abstract virtual IType GetParameterSourceType(IPsiModule module, ParameterKind kind, ITreeNode context);
    public virtual bool IsFieldLike();
    public virtual string Dump();
    public virtual void SuggestName(INamesCollection collection);
    [PureAttribute]
public List`1<ICSharpStatement> CreateUsingDeclarationStatement(ITreeNode context, CSharpElementFactory factory, string parameterName, List`1<string> usedNames);
    protected static void AddConfigureAwaitFalseIfNeeded(ITreeNode context, ICSharpStatement statement, List`1<string> usedNames);
    [NotNullAttribute]
public virtual ITreeNode GetCallSiteUniqueNameContext(ITreeRange extractedRange);
    [NotNullAttribute]
public virtual ExtractMethodReturnValue CreateReturnValue(CSharpElementFactory factory, ICSharpStatement originalStatement, ICSharpExtractMethodControlFlowInspectionResult inspector, bool isExitClassA);
    public virtual ICSharpStatement CreateAssignmentToReturnValue(ICSharpStatement statement);
    public virtual ICSharpExpression CreateArgumentValue(CSharpElementFactory factory);
    [NotNullAttribute]
[ItemNotNullAttribute]
public virtual IReadOnlyList`1<ICSharpStatement> AddCall(CSharpElementFactory factory, ICSharpExpression call, ICSharpExtractMethodControlFlowInspectionResult inspectionResult, ITreeNode context);
    [CanBeNullAttribute]
protected ICSharpStatement AddDefaultExit(CSharpElementFactory factory, ICSharpExtractMethodControlFlowInspectionResult inspectionResult);
    public virtual List`1<BeControl> GetLine(Lifetime lifetime, IPsiSourceFile psiSourceFile, Action previewUpdate);
    protected virtual BeControl GetKindDescriptions(Lifetime lifetime);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AddRange(TreeTextRange variableRange);
    public virtual bool IncludesParameter(CSharpExtractMethodParameter other);
    public virtual bool CanUseWithReturnValue(CSharpExtractMethodParameter returnValueParameter);
}
public enum JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.CSharpExtractMethodParameterKind : Enum {
    public int value__;
    public static CSharpExtractMethodParameterKind PassByValue;
    public static CSharpExtractMethodParameterKind ReturnOnly;
    public static CSharpExtractMethodParameterKind Return;
    public static CSharpExtractMethodParameterKind CanReturn;
    public static CSharpExtractMethodParameterKind PassThrough;
    public static CSharpExtractMethodParameterKind DoNotPass;
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.CSharpExtractMethodParameterWithVariable : CSharpExtractMethodParameter {
    private IDeclaredElementPointer`1<ITypeOwner> myTypeOwner;
    private VariableDeclarationKind myDeclarationKind;
    private bool myIsResolving;
    private ReturnedValueGroup myReachingValuesGroup;
    private ReturnedValueGroup myReturnValueGroup;
    private Nullable`1<bool> myRealIncluded;
    [CompilerGeneratedAttribute]
private Nullable`1<NullableAnnotation> <OutcomingEdgeAnnotation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<NullableAnnotation> <IncomingEdgeAnnotation>k__BackingField;
    public ITypeOwner TypeOwner { get; }
    public bool IsResolving { get; }
    public Nullable`1<NullableAnnotation> OutcomingEdgeAnnotation { get; public set; }
    public Nullable`1<NullableAnnotation> IncomingEdgeAnnotation { get; public set; }
    public VariableDeclarationKind DeclarationKind { get; }
    protected CSharpExtractMethodParameterWithVariable(ITypeOwner typeOwner, VariableDeclarationKind declarationKind);
    public ITypeOwner get_TypeOwner();
    public bool get_IsResolving();
    [CompilerGeneratedAttribute]
public Nullable`1<NullableAnnotation> get_OutcomingEdgeAnnotation();
    [CompilerGeneratedAttribute]
public void set_OutcomingEdgeAnnotation(Nullable`1<NullableAnnotation> value);
    [CompilerGeneratedAttribute]
public Nullable`1<NullableAnnotation> get_IncomingEdgeAnnotation();
    [CompilerGeneratedAttribute]
public void set_IncomingEdgeAnnotation(Nullable`1<NullableAnnotation> value);
    public virtual VariableDeclarationKind get_DeclarationKind();
    protected virtual IType GetParameterSourceType(IPsiModule module, ParameterKind kind, ITreeNode context);
    public virtual IReadOnlyList`1<IType> GetAttributes(ITreeNode context, IType parameterType, ParameterKind kind);
    public virtual bool IsFieldLike();
    public virtual string Dump();
    public virtual void SuggestName(INamesCollection collection);
    public virtual ExtractMethodReturnValue CreateReturnValue(CSharpElementFactory factory, ICSharpStatement originalStatement, ICSharpExtractMethodControlFlowInspectionResult inspector, bool isExitClassA);
    public virtual ICSharpExpression CreateArgumentValue(CSharpElementFactory factory);
    public virtual IReadOnlyList`1<ICSharpStatement> AddCall(CSharpElementFactory factory, ICSharpExpression call, ICSharpExtractMethodControlFlowInspectionResult inspectionResult, ITreeNode context);
    [NotNullAttribute]
public ICSharpStatement FixCallSiteControlFlow(CSharpElementFactory factory);
    public void UpdateIncludedByVisibility(bool visible);
    public void MakeParameterResolving(ReturnedValueGroup valueGroup, ReturnedValueGroup reachingValuesGroup);
    [CanBeNullAttribute]
public static CSharpExtractMethodParameterWithVariable Create(ITypeOwner typeOwner, VariableDeclarationKind declarationKind);
}
internal abstract class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.CSharpExtractMethodRefactoringBase : object {
    [NotNullAttribute]
private CSharpExtractMethodWorkflowBase myWorkflow;
    [NotNullAttribute]
private IRefactoringDriver myDriver;
    protected CSharpExtractMethodRefactoringBase(CSharpExtractMethodWorkflowBase workflow, IRefactoringDriver driver);
    public abstract virtual bool Execute(IProgressIndicator pi);
    protected virtual void ReportConflicts();
    protected void FixReadonlyMembersAccess();
    protected void ApplyCodeBodyStyle(IDeclaration declaration);
}
public abstract class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.CSharpExtractMethodRunner : object {
    private bool myIsPreview;
    private HashSet`1<string> myUnresolvedNameConflicts;
    protected Dictionary`2<CSharpExtractMethodParameter, IDeclaration> myCreatedDeclarations;
    protected IExtractMethodWorkflow myWorkflow;
    protected CSharpElementFactory myFactory;
    private ResolveImagesRepository myRepository;
    protected ICSharpExtractMethodControlFlowInspectionResult myInspectionResult;
    protected CSharpExtractMethodModel myModel;
    [CompilerGeneratedAttribute]
private bool <IsUnsafe>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    public bool IsUnsafe { get; protected set; }
    public bool IsAsync { get; protected set; }
    protected CSharpExtractMethodRunner(IExtractMethodWorkflow workflow, ICSharpExtractMethodControlFlowInspectionResult inspectionResult, bool isPreview);
    [CompilerGeneratedAttribute]
public bool get_IsUnsafe();
    [CompilerGeneratedAttribute]
protected void set_IsUnsafe(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAsync();
    [CompilerGeneratedAttribute]
protected void set_IsAsync(bool value);
    [NotNullAttribute]
protected IDeclaration CreateDeclarationInternal(ICSharpTreeNode context, IBlock& body);
    [NotNullAttribute]
private IClassMemberDeclaration CreatePropertyDeclaration(ITreeNode context, string name, IBlock& body, CSharpElementFactory factory, ITypeUsage usageNode, IReadOnlyList`1<IType> returnTypeAttributes);
    [NotNullAttribute]
private IClassMemberDeclaration CreateChainedConstructorDeclaration(ICSharpTreeNode context, IBlock& body, CSharpElementFactory factory);
    [NotNullAttribute]
private IBlock HandleMovedLocalFunctions(IBlock body);
    [CanBeNullAttribute]
private ILocalFunctionDeclaration MoveLocalFunctionToTargetScope(ILocalFunctionDeclaration localFunctionDeclaration);
    [NotNullAttribute]
private string GetNonConflictingNameForMovedLocalFunction(ILocalFunctionDeclaration movedDeclaration);
    [NotNullAttribute]
private IBlock CreateNestedScopeIfNecessary(IBlock body);
    [NotNullAttribute]
private IBlock AppendLocalFunctionsPreview(IBlock body);
    private IBlock CreateTryOrDisposeBlockForMethodBodyIfNeeded(IBlock body, ICSharpTreeNode context);
    private void DeclareParameters(IPsiModule module, CSharpElementFactory factory, ICSharpParametersOwnerDeclaration parametersOwnerDeclaration, ITreeNode context);
    private void DeclareAndInitVariables(IPsiModule module, CSharpElementFactory factory, IBlock block, ITreeNode context);
    private bool ShouldMakeParameter(CSharpExtractMethodParameter parameter);
    private bool ShouldDeclareVariable(CSharpExtractMethodParameter parameter);
    protected abstract virtual bool IsTopScope(ILocalScope scope);
    private ParameterKind GetKind(CSharpExtractMethodParameter parameter);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IReadOnlyList`1<ITypeParameter> Sort(HashSet`1<ITypeParameter> typeParameters);
    [NotNullAttribute]
private IType Substitute(IType type);
    public sealed virtual bool IsFromExtendsList(ITreeNode element);
    public sealed virtual bool IsReferenceName(ITreeNode element);
    public sealed virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public sealed virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public sealed virtual bool IsExternallyVisibleSymbol(IDeclaredElement element);
    protected void InitRepository();
    [NotNullAttribute]
[ItemNotNullAttribute]
protected IReadOnlyList`1<ICSharpStatement> CreateCallSite(IEnumerable`1<CSharpExtractMethodParameter> parameters, IDeclaration newDeclaration);
    [NotNullAttribute]
[ItemNotNullAttribute]
protected IReadOnlyList`1<ICSharpStatement> DeclareByRefParameters(IEnumerable`1<CSharpExtractMethodParameter> parameters, ITreeNode context, HashSet`1& outParametersToDeclare);
    [NotNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<ICSharpStatement> DeclareVariablesForOutParameters(IEnumerable`1<CSharpExtractMethodParameter> parameters, ITreeNode context);
    [NotNullAttribute]
protected ICSharpExpression CreateMethodCall(IDeclaration declaration, ICollection`1<CSharpExtractMethodParameter> declarationExpressions);
    protected void AddArguments(ICSharpArgumentsOwner call, ICollection`1<CSharpExtractMethodParameter> declarationExpressions);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.CSharpExtractMethodRunner/<ParametersToDeclare>d__45")]
[NotNullAttribute]
[ItemNotNullAttribute]
protected IEnumerable`1<CSharpExtractMethodParameter> ParametersToDeclare();
    [NotNullAttribute]
private ILocalFunctionDeclaration CreateLocalFunctionDeclaration(ICSharpTreeNode context, string name, ITypeUsage usageNode, IBlock& body, IReadOnlyList`1<IType> returnTypeAttributes);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.CSharpExtractMethodRunner/<CollectConstraintClauses>d__47")]
[NotNullAttribute]
[ItemNotNullAttribute]
private IEnumerable`1<ITypeParameterConstraintsClause> CollectConstraintClauses(IReadOnlyList`1<ITypeParameter> typeParameters);
    [NotNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<ITypeParameter> CollectTypeParametersForLocalFunction(ILocalFunctionDeclaration localFunctionDeclaration);
    [NotNullAttribute]
[ItemNotNullAttribute]
protected virtual IList`1<ICSharpStatement> CreateAssignmentsOnReturn(ICSharpStatement statementToReplace);
    protected void RebindRenamedElements(ITreeNode source);
    [NotNullAttribute]
private IDictionary`2<IDeclaredElement, IReferenceExpression> GetRebindedElementsMap();
    [NotNullAttribute]
[ItemNotNullAttribute]
protected IReadOnlyList`1<ICSharpStatement> ReplaceVariableDesignationWithAssignment(ISingleVariableDesignation singleVariableDesignation, ICSharpStatement rootStatement);
    private static bool CanMoveDeclarationsOutOfDeconstruction(ICSharpTreeNode root, JetHashSet`1<string> possibleNameConflicts);
    private static bool CanMoveDeclarationsOutOfDeconstruction(IVariableDesignation variableDesignation, JetHashSet`1<string> possibleNameConflicts);
    private bool IsRenameOnlyChange(ICSharpExpression rootExpression, ISingleVariableDesignation startNode);
    [CanBeNullAttribute]
private string GetNewNameForRenamedElement(IDeclaration declaration);
    [CompilerGeneratedAttribute]
internal static object <CreateTryOrDisposeBlockForMethodBodyIfNeeded>g__GetDisposeMethodOrName|25_0(IType parameterType, bool isAsync, <>c__DisplayClass25_0& );
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
internal static ITypeElement <DeclareParameters>g__ExtractUsingDeclarationNullabilityToPostConditionAnnotation|26_0(CSharpExtractMethodParameter parameter, IType& substitute, <>c__DisplayClass26_0& );
    [CompilerGeneratedAttribute]
private IResolveImagesLanguageSupport <InitRepository>b__39_0(PsiLanguageType language);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.CSharpExtractMethodTargetSiteContext : object {
    [NotNullAttribute]
protected ITreeNodePointer`1<IClassLikeDeclaration> TargetTreeElementPointer;
    [CanBeNullAttribute]
private ITreeNodePointer`1<IClassMemberDeclaration> myAnchorPointer;
    [CompilerGeneratedAttribute]
private bool <BaseTypeIsSelected>k__BackingField;
    public bool IsLocalFunctionContext { get; }
    public bool PlaceBeforeAnchor { get; }
    public bool BaseTypeIsSelected { get; }
    protected CSharpExtractMethodTargetSiteContext(IClassLikeDeclaration targetContainer, IClassMemberDeclaration anchor, bool baseTypeIsSelected);
    public sealed virtual bool get_IsLocalFunctionContext();
    public sealed virtual bool get_PlaceBeforeAnchor();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_BaseTypeIsSelected();
    public static ICSharpExtractMethodTargetSiteContext FindTargetSite(IClassMemberDeclaration owner);
    public sealed virtual ICSharpTreeNode GetTargetSiteContext();
    public virtual IDeclaration AddDeclaration(IDeclaration declaration);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.CSharpExtractMethodTargetSiteContextExtensions : object {
    [ExtensionAttribute]
[ContractAnnotationAttribute("declaredElement:null => false")]
public static bool IsVisibleInTargetContext(ICSharpExtractMethodTargetSiteContext context, IDeclaredElement declaredElement);
    [ExtensionAttribute]
public static bool IsUnsafeContext(ICSharpExtractMethodTargetSiteContext context);
    private static bool IsDeclaredInContextNode(ICSharpTreeNode targetSiteContext, IDeclaredElement declaredElement);
}
public abstract class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.CSharpExtractMethodWorkflowBase : DrivenRefactoringWorkflow {
    private ExtractMemberDataProvider myDataProvider;
    [CompilerGeneratedAttribute]
private bool <CanExtractProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanExtractChainedConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanExtractLocalFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpExtractMethodTargetSiteContext <TargetSiteContext>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpExtractMethodModel <Model>k__BackingField;
    public RefactoringActionGroup ActionGroup { get; }
    public bool CanExtractProperty { get; private set; }
    public bool CanExtractChainedConstructor { get; private set; }
    public bool CanExtractLocalFunction { get; private set; }
    public HelpId HelpKeyword { get; }
    [NotNullAttribute]
public ITreeRange SelectedRange { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public ICSharpExtractMethodTargetSiteContext TargetSiteContext { get; public set; }
    public CSharpExtractMethodModel Model { get; protected set; }
    protected CSharpExtractMethodWorkflowBase(ISolution solution, string actionId);
    public virtual RefactoringActionGroup get_ActionGroup();
    [CompilerGeneratedAttribute]
public bool get_CanExtractProperty();
    [CompilerGeneratedAttribute]
private void set_CanExtractProperty(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanExtractChainedConstructor();
    [CompilerGeneratedAttribute]
private void set_CanExtractChainedConstructor(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanExtractLocalFunction();
    [CompilerGeneratedAttribute]
private void set_CanExtractLocalFunction(bool value);
    public virtual HelpId get_HelpKeyword();
    public abstract virtual ITreeRange get_SelectedRange();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    [CompilerGeneratedAttribute]
public ICSharpExtractMethodTargetSiteContext get_TargetSiteContext();
    [CompilerGeneratedAttribute]
public void set_TargetSiteContext(ICSharpExtractMethodTargetSiteContext value);
    [CompilerGeneratedAttribute]
public sealed virtual CSharpExtractMethodModel get_Model();
    [CompilerGeneratedAttribute]
protected void set_Model(CSharpExtractMethodModel value);
    public abstract virtual ITreeNode CreatePreviewElement();
    public abstract virtual LocalFunctionSignatureInfo CreateSignaturePreviewElement(ICSharpExtractMethodControlFlowInspectionResult analysisResult);
    public sealed virtual IBlock PrepareBody(IBlock body, CSharpElementFactory factory);
    public virtual bool PreExecute(IProgressIndicator pi);
    public virtual bool Initialize(IDataContext context);
    [CanBeNullAttribute]
public abstract virtual ICSharpExtractMethodControlFlowInspectionResult AnalizeDataFlow();
    public string Dump();
    public virtual bool IsValid();
    private ExtractMethodPopupOccurrence[] GetOccurrences(ICSharpExtractMethodControlFlowInspectionResult analysisResult);
    private bool GetCanExtractLocalFunction(ICSharpExtractMethodControlFlowInspectionResult analysisResult);
    protected static bool IsSelectedWithSemicolon(ICSharpExpression expression, TextRange selectionRange);
    public void SetDataProvider(ExtractMemberDataProvider dataProvider);
    protected virtual bool GetCanExtractChainedConstructor(ICSharpExtractMethodControlFlowInspectionResult analysisResult);
    public static bool CanPassAsParameter(CSharpExtractMethodParameter parameter, CSharpExtractMethodParameter returnValueParameter, bool canHaveRefOutParameters);
    [CompilerGeneratedAttribute]
private IRefactoringPage <get_FirstPendingRefactoringPage>b__20_0(IProgressIndicator pi);
}
internal abstract class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.DeconstructionDeclarationRewriterBase : object {
    [NotNullAttribute]
protected IDictionary`2<string, string> RenameMap;
    [NotNullAttribute]
protected CSharpElementFactory ElementFactory;
    [CanBeNullAttribute]
protected ICSharpStatement DeclarationsAnchor;
    [NotNullAttribute]
protected IAssignmentExpression AssignmentExpression;
    [NotNullAttribute]
protected NamingManager NamingManager;
    [NotNullAttribute]
[ItemNotNullAttribute]
private JetHashSet`1<string> myCreatedDeclarations;
    [CompilerGeneratedAttribute]
private FactoryArgumentsBuilder <ArgumentsBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ICSharpStatement> <StatementsToAdd>k__BackingField;
    protected FactoryArgumentsBuilder ArgumentsBuilder { get; }
    protected IList`1<ICSharpStatement> StatementsToAdd { get; }
    protected DeconstructionDeclarationRewriterBase(JetHashSet`1<string> createdDeclarations, IAssignmentExpression assignmentExpression, ICSharpStatement declarationsAnchor, IDictionary`2<string, string> renameMap);
    [CompilerGeneratedAttribute]
protected FactoryArgumentsBuilder get_ArgumentsBuilder();
    [CompilerGeneratedAttribute]
protected IList`1<ICSharpStatement> get_StatementsToAdd();
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IReadOnlyList`1<ICSharpStatement> Rewrite(ICSharpExpression rootExpression);
    protected void ProcessDeclarationRecursive(ICSharpExpression rootExpression);
    protected virtual void ProcessDeclarationExpressionRecursive(IDeclarationExpression declarationExpression);
    protected void ProcessTupleExpression(ITupleExpression tupleExpression);
    private void ProcessVariableDesignation(IVariableDesignation variableDesignation);
    protected abstract virtual void ProcessNonConflictingDeclaration(ISingleVariableDesignation variableDesignation);
    protected abstract virtual void ProcessDiscardDesignation(ICSharpTreeNode discardNode);
    protected abstract virtual void HandleConflictingDeclaration(ISingleVariableDesignation variableDesignation);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.DeconstructionToAssignmentsRewriter : DeconstructionDeclarationRewriterBase {
    [NotNullAttribute]
private Dictionary`2<string, string> myIntroducedVariables;
    public DeconstructionToAssignmentsRewriter(JetHashSet`1<string> createdDeclarations, IAssignmentExpression assignmentExpression, ICSharpStatement declarationsAnchor, IDictionary`2<string, string> renameMap);
    public virtual IReadOnlyList`1<ICSharpStatement> Rewrite(ICSharpExpression rootExpression);
    protected virtual void ProcessDeclarationExpressionRecursive(IDeclarationExpression declarationExpression);
    protected virtual void ProcessDiscardDesignation(ICSharpTreeNode discardNode);
    protected virtual void HandleConflictingDeclaration(ISingleVariableDesignation variableDesignation);
    protected virtual void ProcessNonConflictingDeclaration(ISingleVariableDesignation variableDesignation);
    [CompilerGeneratedAttribute]
private string <Rewrite>b__2_0(string arg);
    [CompilerGeneratedAttribute]
private bool <HandleConflictingDeclaration>b__5_0(string x);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.DeconstructionToMixedWithAssignmentsRewriter : DeconstructionDeclarationRewriterBase {
    public DeconstructionToMixedWithAssignmentsRewriter(JetHashSet`1<string> createdDeclarations, IAssignmentExpression assignmentExpression, ICSharpStatement declarationsAnchor, IDictionary`2<string, string> renameMap);
    public virtual IReadOnlyList`1<ICSharpStatement> Rewrite(ICSharpExpression rootExpression);
    protected virtual void ProcessNonConflictingDeclaration(ISingleVariableDesignation variableDesignation);
    protected virtual void ProcessDiscardDesignation(ICSharpTreeNode discardNode);
    protected virtual void HandleConflictingDeclaration(ISingleVariableDesignation variableDesignation);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.DeconstructionToSeparateDeclarationsRewriter : DeconstructionDeclarationRewriterBase {
    public DeconstructionToSeparateDeclarationsRewriter(JetHashSet`1<string> createdDeclarations, IAssignmentExpression assignmentExpression, ICSharpStatement declarationsAnchor, IDictionary`2<string, string> renameMap);
    public virtual IReadOnlyList`1<ICSharpStatement> Rewrite(ICSharpExpression rootExpression);
    protected virtual void HandleConflictingDeclaration(ISingleVariableDesignation variableDesignation);
    protected virtual void ProcessNonConflictingDeclaration(ISingleVariableDesignation variableDesignation);
    protected virtual void ProcessDiscardDesignation(ICSharpTreeNode discardNode);
    private void CreateDeclarationStatement(IType variableType, string variableName);
}
public enum JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.ExtractedEntityKind : Enum {
    public int value__;
    public static ExtractedEntityKind Method;
    public static ExtractedEntityKind Property;
    public static ExtractedEntityKind ChainedConstructor;
    public static ExtractedEntityKind LocalFunction;
    public static ExtractedEntityKind MethodObject;
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.ExtractMemberDataProvider : object {
    [CompilerGeneratedAttribute]
private ExtractedEntityKind <EntityKind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LocalFunctionScopeIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReturnParameterIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeOptionalParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RenameParameters>k__BackingField;
    public ExtractedEntityKind EntityKind { get; protected set; }
    public int LocalFunctionScopeIndex { get; protected set; }
    public int ReturnParameterIndex { get; protected set; }
    public bool IncludeOptionalParameters { get; protected set; }
    public bool RenameParameters { get; protected set; }
    [CompilerGeneratedAttribute]
public ExtractedEntityKind get_EntityKind();
    [CompilerGeneratedAttribute]
protected void set_EntityKind(ExtractedEntityKind value);
    [CompilerGeneratedAttribute]
public int get_LocalFunctionScopeIndex();
    [CompilerGeneratedAttribute]
protected void set_LocalFunctionScopeIndex(int value);
    [CompilerGeneratedAttribute]
public int get_ReturnParameterIndex();
    [CompilerGeneratedAttribute]
protected void set_ReturnParameterIndex(int value);
    [CompilerGeneratedAttribute]
public bool get_IncludeOptionalParameters();
    [CompilerGeneratedAttribute]
protected void set_IncludeOptionalParameters(bool value);
    [CompilerGeneratedAttribute]
public bool get_RenameParameters();
    [CompilerGeneratedAttribute]
protected void set_RenameParameters(bool value);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.ExtractMethodLocalFunctionInfoEqualityComparer : object {
    public static IEqualityComparer`1<CSharpExtractMethodLocalFunction> Instance;
    private static ExtractMethodLocalFunctionInfoEqualityComparer();
    public sealed virtual bool Equals(CSharpExtractMethodLocalFunction x, CSharpExtractMethodLocalFunction y);
    public sealed virtual int GetHashCode(CSharpExtractMethodLocalFunction obj);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.ExtractMethodPopupOccurrence : SimplePopupOccurrence {
    [CompilerGeneratedAttribute]
private ExtractedEntityKind <EntityKind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LocalFunctionScopeIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeOptionalParameters>k__BackingField;
    public ExtractedEntityKind EntityKind { get; protected set; }
    public int LocalFunctionScopeIndex { get; protected set; }
    public bool IncludeOptionalParameters { get; protected set; }
    public ExtractMethodPopupOccurrence(string name, string description, ExtractedEntityKind method);
    [CompilerGeneratedAttribute]
public ExtractedEntityKind get_EntityKind();
    [CompilerGeneratedAttribute]
protected void set_EntityKind(ExtractedEntityKind value);
    [CompilerGeneratedAttribute]
public int get_LocalFunctionScopeIndex();
    [CompilerGeneratedAttribute]
protected void set_LocalFunctionScopeIndex(int value);
    [CompilerGeneratedAttribute]
public bool get_IncludeOptionalParameters();
    [CompilerGeneratedAttribute]
protected void set_IncludeOptionalParameters(bool value);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.ExtractMethodResult : object {
    [CompilerGeneratedAttribute]
private SmartDeclarationPointer`1<IDeclaration> <ResultDeclarationPointer>k__BackingField;
    [CanBeNullAttribute]
public SmartDeclarationPointer`1<IDeclaration> ResultDeclarationPointer { get; }
    public ExtractMethodResult(SmartDeclarationPointer`1<IDeclaration> resultDeclarationPointer);
    [CompilerGeneratedAttribute]
public SmartDeclarationPointer`1<IDeclaration> get_ResultDeclarationPointer();
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.ExtractMethodReturnValue : object {
    [CompilerGeneratedAttribute]
private ICSharpExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpStatement <Statement>k__BackingField;
    public static ExtractMethodReturnValue NoReturnValue;
    [CanBeNullAttribute]
public ICSharpExpression Expression { get; }
    [CanBeNullAttribute]
public ICSharpStatement Statement { get; }
    public ExtractMethodReturnValue(ICSharpExpression expression);
    public ExtractMethodReturnValue(ICSharpStatement statement);
    private static ExtractMethodReturnValue();
    [CompilerGeneratedAttribute]
public ICSharpExpression get_Expression();
    [CompilerGeneratedAttribute]
public ICSharpStatement get_Statement();
    [CanBeNullAttribute]
public ICSharpStatement CreateReturnStatement(CSharpElementFactory factory);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.ExtractMethodWorkflowEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static ISubstitution CreateSubstitution(CSharpExtractMethodModel model, ITypeParametersOwner typeParametersOwner);
}
public interface JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.ICSharpExtractMethodTargetSiteContext {
    public bool IsLocalFunctionContext { get; }
    public bool PlaceBeforeAnchor { get; }
    public bool BaseTypeIsSelected { get; }
    public abstract virtual bool get_IsLocalFunctionContext();
    public abstract virtual bool get_PlaceBeforeAnchor();
    public abstract virtual bool get_BaseTypeIsSelected();
    [CanBeNullAttribute]
public abstract virtual ICSharpTreeNode GetTargetSiteContext();
    [CanBeNullAttribute]
public abstract virtual IDeclaration AddDeclaration(IDeclaration declaration);
}
public interface JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.IExtractMethodWorkflow {
    public ISolution Solution { get; }
    public CSharpExtractMethodModel Model { get; }
    public abstract virtual ISolution get_Solution();
    public abstract virtual CSharpExtractMethodModel get_Model();
    public abstract virtual ITreeNode CreatePreviewElement();
    [NotNullAttribute]
public abstract virtual LocalFunctionSignatureInfo CreateSignaturePreviewElement(ICSharpExtractMethodControlFlowInspectionResult analysisResult);
    public abstract virtual IBlock PrepareBody(IBlock body, CSharpElementFactory factory);
}
public interface JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.IExtractMethodWorkflowWithResults {
    [CanBeNullAttribute]
public ExtractMethodResult Result { get; public set; }
    public abstract virtual ExtractMethodResult get_Result();
    public abstract virtual void set_Result(ExtractMethodResult value);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.LocalFunctionPositionPreviewProvider : object {
    private CSharpExtractMethodModel myModel;
    public bool EmptyLinesAround { get; }
    public LocalFunctionPositionPreviewProvider(CSharpExtractMethodModel model);
    public sealed virtual bool get_EmptyLinesAround();
    public sealed virtual IconId GetIcon(IStatementPositionCandidate candidate);
    public sealed virtual RichText GetPreview(IStatementPositionCandidate candidate);
    public sealed virtual RichText GetSingleLinePreview(IStatementPositionCandidate candidate);
    public sealed virtual RichText GetTooltip();
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.LocalFunctionPositionUnsupportedPreviewProvider : object {
    public bool EmptyLinesAround { get; }
    public sealed virtual IconId GetIcon(IStatementPositionCandidate candidate);
    public sealed virtual RichText GetPreview(IStatementPositionCandidate candidate);
    public sealed virtual RichText GetSingleLinePreview(IStatementPositionCandidate candidate);
    public sealed virtual RichText GetTooltip();
    public sealed virtual bool get_EmptyLinesAround();
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.LocalFunctionScopeElement : object {
    [CompilerGeneratedAttribute]
private IStatementPositionCandidate <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeNodeNode <TreeGridElement>k__BackingField;
    [CompilerGeneratedAttribute]
private RichText <TreeGridDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatementsOwnerScope>k__BackingField;
    public bool PlaceInFront { get; }
    [NotNullAttribute]
public IStatementPositionCandidate Position { get; }
    public TreeNodeNode TreeGridElement { get; }
    public RichText TreeGridDescription { get; }
    public bool IsStatementsOwnerScope { get; public set; }
    public LocalFunctionScopeElement(IStatementPositionCandidate position, ICSharpTreeNode treeGridDescriptionProvider);
    public bool get_PlaceInFront();
    [CompilerGeneratedAttribute]
public IStatementPositionCandidate get_Position();
    private sealed virtual override bool JetBrains.ReSharper.Feature.Services.EditorUIAdornment.ICodePositionCandidate.IsValid();
    public sealed virtual CodePositionPresentationData GetPresentationInfo(Nullable`1& lBrace, Nullable`1& rBrace);
    [CanBeNullAttribute]
public ICSharpTreeNode GetContextNode();
    [CompilerGeneratedAttribute]
public TreeNodeNode get_TreeGridElement();
    [CompilerGeneratedAttribute]
public RichText get_TreeGridDescription();
    [CompilerGeneratedAttribute]
public bool get_IsStatementsOwnerScope();
    [CompilerGeneratedAttribute]
public void set_IsStatementsOwnerScope(bool value);
    [NotNullAttribute]
private static string GetTreeGridPresentation(ICSharpTreeNode descriptionPointer, bool placeInside, bool placeInFront);
    [CompilerGeneratedAttribute]
internal static string <GetTreeGridPresentation>g__GetDescriptionPointerText|19_0(<>c__DisplayClass19_0& );
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.LocalFunctionSignatureInfo : object {
    [CanBeNullAttribute]
private ITreeNode myContext;
    [CanBeNullAttribute]
private ILocalFunctionDeclaration myDeclaration;
    [NotNullAttribute]
[ItemNotNullAttribute]
private IEnumerable`1<CSharpExtractMethodLocalFunction> myMovedLocalFunctions;
    public LocalFunctionSignatureInfo(ITreeNode context, ILocalFunctionDeclaration declaration, IEnumerable`1<CSharpExtractMethodLocalFunction> movedLocalFunctions);
    public bool IsValid();
    [NotNullAttribute]
public RichText GetSingleLineSignaturePreview();
    [NotNullAttribute]
public RichText GetSignaturePreview();
    private static void DumpSignature(RichText previewBuilder, ILocalFunctionDeclaration localFunctionDeclaration);
    private static void DumpTokensBetween(RichText previewBuilder, ITreeNode before, ITreeNode after);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.LocalFunctionsScopePage : SingleBeRefactoringPage {
    private CSharpExtractMethodModel myModel;
    private LocalFunctionScopeElement myResult;
    public static string ExtractMethodTargetScope;
    private EditorUICodePositionSelector`1<LocalFunctionScopeElement> myEditorUIPositionSelector;
    [CompilerGeneratedAttribute]
private EventHandler CommitEditorUIForm;
    [CompilerGeneratedAttribute]
private EventHandler CancelEditorUIForm;
    public string Description { get; }
    public string Title { get; }
    public string PageDescription { get; }
    public bool CanShowEditorUI { get; }
    public LocalFunctionsScopePage(CSharpExtractMethodModel model, Lifetime lifetime);
    public virtual string get_Description();
    public virtual string get_Title();
    public virtual string get_PageDescription();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CommitEditorUIForm(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CommitEditorUIForm(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CancelEditorUIForm(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CancelEditorUIForm(EventHandler value);
    public sealed virtual bool get_CanShowEditorUI();
    public sealed virtual void ShowEditorUI(Lifetime lifetime);
    public virtual BeControl GetPageContent();
    public virtual void Commit();
    [CompilerGeneratedAttribute]
private void <ShowEditorUI>b__19_0(PropertyChangedEventArgs`1<LocalFunctionScopeElement> arg);
    [CompilerGeneratedAttribute]
private void <ShowEditorUI>b__19_1();
    [CompilerGeneratedAttribute]
private void <ShowEditorUI>b__19_2();
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__20_0(LocalFunctionScopeElement v);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.UsingDeclarationVariableParameterPositionReverseComparer : object {
    [NullableContextAttribute("2")]
public sealed virtual int Compare(CSharpExtractMethodParameterWithVariable x, CSharpExtractMethodParameterWithVariable y);
}
public enum JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Common.VariableDeclarationKind : Enum {
    public int value__;
    public static VariableDeclarationKind External;
    public static VariableDeclarationKind LocalUsingDeclaration;
    public static VariableDeclarationKind LocalAwaitUsingDeclaration;
    public static VariableDeclarationKind Local;
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.Conflicts.DeclaredElementNameofConflict : NameofConflictInfo {
    [NotNullAttribute]
private IDeclaredElementPointer`1<IDeclaredElement> myDeclaredElementPointer;
    private ConflictSeverity myConflictSeverity;
    protected IDeclaredElement DeclaredElement { get; }
    protected ConflictSeverity Severity { get; }
    public DeclaredElementNameofConflict(IDeclaredElement declaredElement, ConflictSeverity severity, IEnumerable`1<ITreeNode> usages);
    protected virtual IDeclaredElement get_DeclaredElement();
    protected virtual ConflictSeverity get_Severity();
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.Conflicts.ExtractLocalFunctionWithOuterUsageConflict : LocalFunctionConflictInfo {
    public ExtractLocalFunctionWithOuterUsageConflict(ILocalFunction localFunction, IEnumerable`1<ITreeNode> usages);
    public virtual IReadOnlyList`1<LocalFunctionConflictResult> ResolveConflict(ITreeRange extractedRange, ICSharpExtractMethodTargetSiteContext targetSiteContext);
    protected virtual string GetConflictMessage(ILocalFunction localFunction);
}
public abstract class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.Conflicts.ExtractMethodConflictInfoBase : object {
    [NotNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<ITreeNodePointer`1<ITreeNode>> myUsages;
    protected ExtractMethodConflictInfoBase(IEnumerable`1<ITreeNode> usages);
    [NotNullAttribute]
[ItemNotNullAttribute]
protected IEnumerable`1<ITreeNode> GetUsages();
    [NotNullAttribute]
protected static string PresentDeclaredElement(IDeclaredElement declaredElement);
    [NotNullAttribute]
[ItemNotNullAttribute]
protected static IReadOnlyList`1<ITreeNodePointer`1<ITreeNode>> GetNodePointers(IEnumerable`1<ITreeNode> usages);
    [NotNullAttribute]
[ItemNotNullAttribute]
protected static IEnumerable`1<ITreeNode> FindNodes(IEnumerable`1<ITreeNodePointer`1<ITreeNode>> pointers);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.Conflicts.ExtractMethodControlFlowInspectionPatch : ValueType {
    [NotNullAttribute]
public IReadOnlyDictionary`2<ITypeOwner, CSharpExtractMethodParameter> ParametersFromVariables;
    [NotNullAttribute]
[ItemNotNullAttribute]
public HashSet`1<ITypeParameter> UsedTypeParameters;
    [NotNullAttribute]
public OneToSetMap`2<string, ITypeOwner> UsedNames;
    public bool CanBeStatic;
    public bool CanBeInstance;
    public ExtractMethodControlFlowInspectionPatch(IReadOnlyDictionary`2<ITypeOwner, CSharpExtractMethodParameter> parametersFromVariables, HashSet`1<ITypeParameter> usedTypeParameters, OneToSetMap`2<string, ITypeOwner> usedNames, bool canBeStatic, bool canBeInstance);
}
public abstract class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.Conflicts.LocalFunctionConflictInfo : ExtractMethodConflictInfoBase {
    [NotNullAttribute]
private IDeclaredElementPointer`1<ILocalFunction> myLocalFunction;
    [CanBeNullAttribute]
public ILocalFunction DeclaredElement { get; }
    protected LocalFunctionConflictInfo(ILocalFunction localFunction, IEnumerable`1<ITreeNode> usages);
    public ILocalFunction get_DeclaredElement();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IReadOnlyList`1<LocalFunctionConflictResult> ResolveConflict(ITreeRange extractedRange, ICSharpExtractMethodTargetSiteContext targetSiteContext);
    public bool ContainsNode(ITreeNode treeNode);
    [NotNullAttribute]
protected abstract virtual string GetConflictMessage(ILocalFunction localFunction);
    [NotNullAttribute]
protected IReadOnlyList`1<LocalFunctionConflictResult> ReportUsageErrors();
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.Conflicts.LocalFunctionConflictResult : ValueType {
    [CanBeNullAttribute]
public IConflict Conflict;
    [CanBeNullAttribute]
public CSharpExtractMethodLocalFunction ExtractMethodLocalFunction;
    public Nullable`1<ExtractMethodControlFlowInspectionPatch> ControlFlowPatch;
    public LocalFunctionConflictResult(IConflict conflict, CSharpExtractMethodLocalFunction extractMethodLocalFunction, Nullable`1<ExtractMethodControlFlowInspectionPatch> controlFlowPatch);
}
public abstract class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.Conflicts.NameofConflictInfo : ExtractMethodConflictInfoBase {
    [CanBeNullAttribute]
protected IDeclaredElement DeclaredElement { get; }
    protected ConflictSeverity Severity { get; }
    protected NameofConflictInfo(IEnumerable`1<ITreeNode> usages);
    protected abstract virtual IDeclaredElement get_DeclaredElement();
    protected virtual ConflictSeverity get_Severity();
    protected virtual bool IsSolved(ICSharpExtractMethodControlFlowInspectionResult inspectionResult, ICSharpExtractMethodTargetSiteContext targetSiteContext);
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IConflict> GetAllConflicts(ICSharpExtractMethodControlFlowInspectionResult inspectionResult, ICSharpExtractMethodTargetSiteContext targetSiteContext);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.Conflicts.NestedOnlyLocalFunctionConflict : LocalFunctionConflictInfo {
    [NotNullAttribute]
private IDeclaration myOwnerDeclaration;
    [NotNullAttribute]
private ExtractMethodLocalFunctionInfo myInspectionResult;
    public NestedOnlyLocalFunctionConflict(IDeclaration ownerDeclaration, ExtractMethodLocalFunctionInfo inspectionResult, ILocalFunction localFunction);
    public virtual IReadOnlyList`1<LocalFunctionConflictResult> ResolveConflict(ITreeRange extractedRange, ICSharpExtractMethodTargetSiteContext targetSiteContext);
    protected virtual string GetConflictMessage(ILocalFunction localFunction);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.Conflicts.ParameterNameofConflict : NameofConflictInfo {
    [NotNullAttribute]
private CSharpExtractMethodParameterWithVariable myParameter;
    private bool myHasOuterUsages;
    protected ConflictSeverity Severity { get; }
    protected IDeclaredElement DeclaredElement { get; }
    public ParameterNameofConflict(CSharpExtractMethodParameterWithVariable parameter, IEnumerable`1<ITreeNode> usages, bool hasOuterUsages);
    protected virtual ConflictSeverity get_Severity();
    protected virtual bool IsSolved(ICSharpExtractMethodControlFlowInspectionResult inspectionResult, ICSharpExtractMethodTargetSiteContext targetSiteContext);
    protected virtual IDeclaredElement get_DeclaredElement();
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.Conflicts.RecursiveLocalFunctionConflict : LocalFunctionConflictInfo {
    public RecursiveLocalFunctionConflict(ILocalFunction localFunction, IEnumerable`1<ITreeNode> usages);
    public virtual IReadOnlyList`1<LocalFunctionConflictResult> ResolveConflict(ITreeRange extractedRange, ICSharpExtractMethodTargetSiteContext targetSiteContext);
    protected virtual string GetConflictMessage(ILocalFunction localFunction);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.Conflicts.SharedLocalFunctionConflict : LocalFunctionConflictInfo {
    [NotNullAttribute]
private ExtractMethodLocalFunctionInfo myInspectionResult;
    [NotNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<ITreeNodePointer`1<ITreeNode>> myOuterUsages;
    private bool myIsDeclaredInside;
    [CompilerGeneratedAttribute]
private bool <MustBeSharedFunction>k__BackingField;
    public bool MustBeSharedFunction { get; public set; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<LocalFunctionConflictInfo> LocalFunctionConflicts { get; }
    public SharedLocalFunctionConflict(ILocalFunction localFunction, ExtractMethodLocalFunctionInfo inspectionResult, IReadOnlyCollection`1<ITreeNode> outerUsages, IEnumerable`1<ITreeNode> innerUsages, bool isDeclaredInside);
    [CompilerGeneratedAttribute]
public bool get_MustBeSharedFunction();
    [CompilerGeneratedAttribute]
public void set_MustBeSharedFunction(bool value);
    public IReadOnlyList`1<LocalFunctionConflictInfo> get_LocalFunctionConflicts();
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<ITreeNode> GetOuterUsages();
    [CanBeNullAttribute]
public SharedLocalFunctionConflict FindNonExtractableDependency(ITreeRange extractedRange, ICSharpExtractMethodTargetSiteContext targetSiteContext, HashSet`1<SharedLocalFunctionConflict> processedFunctions);
    public virtual IReadOnlyList`1<LocalFunctionConflictResult> ResolveConflict(ITreeRange extractedRange, ICSharpExtractMethodTargetSiteContext targetSiteContext);
    [NotNullAttribute]
private IReadOnlyList`1<LocalFunctionConflictResult> ResolveAsMovedToExtractedCodeFunction(ITreeRange extractedRange, ICSharpExtractMethodTargetSiteContext targetSiteContext);
    [NotNullAttribute]
private IReadOnlyList`1<LocalFunctionConflictResult> ResolveAsSharedFunction(ICSharpExtractMethodTargetSiteContext targetSiteContext);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static HashSet`1<ILocalFunction> CollectLocalFunctionsGraphConvertibleToRegularMethods(ILocalFunction node, ICSharpExtractMethodTargetSiteContext targetSiteContext);
    private static bool IsProcessedNestedDeclaration(ILocalFunctionDeclaration nestedCallTargetDeclaration, HashSet`1<IDeclaredElement> processedDependencies);
    protected virtual string GetConflictMessage(ILocalFunction localFunction);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.CSharpExtractMethodControlFlowInspectionRefinedResult : object {
    [NotNullAttribute]
private ICSharpExtractMethodControlFlowInspectionResult myBaseResult;
    [NotNullAttribute]
private ITreeRange myTreeRange;
    [NotNullAttribute]
private Dictionary`2<ITypeOwner, CSharpExtractMethodParameter> myParametersFromVariables;
    [NotNullAttribute]
private OneToSetMap`2<string, ITypeOwner> myNamesReservedByLocalFunctions;
    [CompilerGeneratedAttribute]
private OneToSetMap`2<string, ITypeOwner> <UsedNames>k__BackingField;
    [CompilerGeneratedAttribute]
private OneToSetMap`2<CSharpExtractMethodParameter, CSharpExtractMethodParameterUsage> <ParameterUsagesOutside>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CSharpExtractMethodParameter> <ExtraReturnParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasNameConflictsWithMovedLocalFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpExtractMethodParameter <ReturnValueParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CSharpExtractMethodParameter> <AllParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<ITypeParameter> <UsedTypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<CSharpExtractMethodLocalFunction> <MovedLocalFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IConflict> <Conflicts>k__BackingField;
    public OneToSetMap`2<string, ITypeOwner> UsedNames { get; }
    public IList`1<IYieldStatement> YieldStatements { get; }
    public bool HasAwaits { get; }
    public IReadOnlyDictionary`2<ITypeOwner, CSharpExtractMethodParameter> ParametersFromVariables { get; }
    public ICSharpDeclaration OwnerDeclaration { get; }
    public bool HasMultipleExitsProblem { get; }
    public HashSet`1<ITypeParameter> AllTypeParameters { get; }
    public HashSet`1<IReferenceExpression> DirectLocalFunctionUsages { get; }
    public OneToSetMap`2<CSharpExtractMethodParameter, CSharpExtractMethodParameterUsage> ParameterUsagesOutside { get; }
    public bool HasFallthroughExit { get; }
    public IEnumerable`1<IField> ReadonlyFields { get; }
    public IEnumerable`1<IProperty> ReadonlyProperties { get; }
    public bool CanHaveRefOutParameters { get; }
    public HashSet`1<ICSharpStatement> ExitsClassA { get; }
    public HashSet`1<ICSharpStatement> ExitsClassB { get; }
    public bool HasMultipleEntries { get; }
    public IReadOnlyList`1<CSharpExtractMethodParameter> ExtraReturnParameters { get; private set; }
    public bool CanBeStatic { get; private set; }
    public bool CanBeInstance { get; private set; }
    public bool HasNameConflictsWithMovedLocalFunctions { get; private set; }
    public IReadOnlyList`1<LocalFunctionConflictInfo> LocalFunctionConflicts { get; }
    public CSharpExtractMethodParameter ReturnValueParameter { get; public set; }
    public IReadOnlyList`1<CSharpExtractMethodParameter> AllParameters { get; private set; }
    public HashSet`1<ITypeParameter> UsedTypeParameters { get; }
    public IReadOnlyList`1<NameofConflictInfo> NameofConflicts { get; }
    public IEnumerable`1<CSharpExtractMethodLocalFunction> MovedLocalFunctions { get; }
    public IReadOnlyList`1<IConflict> Conflicts { get; }
    public CSharpExtractMethodControlFlowInspectionRefinedResult(ICSharpExtractMethodControlFlowInspectionResult baseResult, ITreeRange treeRange, ICSharpExtractMethodTargetSiteContext targetSiteContext);
    private void CreateParameters(ICSharpExtractMethodTargetSiteContext targetSiteContext);
    [CompilerGeneratedAttribute]
public sealed virtual OneToSetMap`2<string, ITypeOwner> get_UsedNames();
    public sealed virtual IList`1<IYieldStatement> get_YieldStatements();
    public sealed virtual bool get_HasAwaits();
    public sealed virtual IReadOnlyDictionary`2<ITypeOwner, CSharpExtractMethodParameter> get_ParametersFromVariables();
    public sealed virtual ICSharpDeclaration get_OwnerDeclaration();
    public sealed virtual bool get_HasMultipleExitsProblem();
    public sealed virtual HashSet`1<ITypeParameter> get_AllTypeParameters();
    public sealed virtual HashSet`1<IReferenceExpression> get_DirectLocalFunctionUsages();
    [CompilerGeneratedAttribute]
public sealed virtual OneToSetMap`2<CSharpExtractMethodParameter, CSharpExtractMethodParameterUsage> get_ParameterUsagesOutside();
    public sealed virtual bool get_HasFallthroughExit();
    public sealed virtual IEnumerable`1<IField> get_ReadonlyFields();
    public sealed virtual IEnumerable`1<IProperty> get_ReadonlyProperties();
    public sealed virtual bool get_CanHaveRefOutParameters();
    public sealed virtual HashSet`1<ICSharpStatement> get_ExitsClassA();
    public sealed virtual HashSet`1<ICSharpStatement> get_ExitsClassB();
    public sealed virtual bool get_HasMultipleEntries();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<CSharpExtractMethodParameter> get_ExtraReturnParameters();
    [CompilerGeneratedAttribute]
private void set_ExtraReturnParameters(IReadOnlyList`1<CSharpExtractMethodParameter> value);
    public sealed virtual bool IsValid();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanBeStatic();
    [CompilerGeneratedAttribute]
private void set_CanBeStatic(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanBeInstance();
    [CompilerGeneratedAttribute]
private void set_CanBeInstance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasNameConflictsWithMovedLocalFunctions();
    [CompilerGeneratedAttribute]
private void set_HasNameConflictsWithMovedLocalFunctions(bool value);
    public sealed virtual IReadOnlyList`1<LocalFunctionConflictInfo> get_LocalFunctionConflicts();
    [CompilerGeneratedAttribute]
public sealed virtual CSharpExtractMethodParameter get_ReturnValueParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReturnValueParameter(CSharpExtractMethodParameter value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<CSharpExtractMethodParameter> get_AllParameters();
    [CompilerGeneratedAttribute]
private void set_AllParameters(IReadOnlyList`1<CSharpExtractMethodParameter> value);
    [CompilerGeneratedAttribute]
public sealed virtual HashSet`1<ITypeParameter> get_UsedTypeParameters();
    public sealed virtual IReadOnlyList`1<NameofConflictInfo> get_NameofConflicts();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<CSharpExtractMethodLocalFunction> get_MovedLocalFunctions();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IConflict> get_Conflicts();
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<CSharpExtractMethodLocalFunction> HandleLocalFunctionConflicts(ITreeRange treeRange, ICSharpExtractMethodTargetSiteContext targetSiteContext, IList`1<IConflict> conflicts);
    private void AppendToInspectionResult(LocalFunctionConflictInfo localFunctionConflict, ITreeRange extractedCodeTreeRange, ExtractMethodControlFlowInspectionPatch controlFlowPatch);
    private static CSharpExtractMethodParameterKind MergeParameterKinds(CSharpExtractMethodParameter originalParameter, CSharpExtractMethodParameter mergedExtractMethodParameter);
    public sealed virtual void CoerceParameterNames(ICSharpExtractMethodTargetSiteContext targetSiteContext);
    public sealed virtual void CoerceParameterNameForCallSite(IReadOnlyCollection`1<IDeclaration> createdDeclarations, ITreeRange extractedRange);
    [NotNullAttribute]
private string GetSourceParameterNameForCorrection(CSharpExtractMethodParameter parameter);
    private bool ShouldGenerateNewName(CSharpExtractMethodParameter parameter, OneToSetMap`2<string, CSharpExtractMethodParameter> disallowedNames, ICSharpExtractMethodTargetSiteContext targetSiteContext);
    private static bool CanParameterBeDeclaredInTargetContext(ICSharpExtractMethodTargetSiteContext context, ITypeOwner typeOwner);
    [NotNullAttribute]
private OneToSetMap`2<SharedLocalFunctionConflict, SharedLocalFunctionConflict> GetLocalFunctionGraph();
    private void AnalyseTransitiveLocalFunctionDependencies(OneToSetMap`2<SharedLocalFunctionConflict, SharedLocalFunctionConflict> graph, ITreeRange treeRange, ICSharpExtractMethodTargetSiteContext targetSiteContext, HashSet`1<SharedLocalFunctionConflict> allConflictingFunctions);
    private void AnalyseLocalFunctionCallGraph(OneToSetMap`2<SharedLocalFunctionConflict, SharedLocalFunctionConflict> graph, HashSet`1<SharedLocalFunctionConflict> allConflictingFunctions);
    private bool IsPartOfExtractionGraph(HashSet`1<SharedLocalFunctionConflict> allConflictingFunctions, ITreeNode treeNode);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static HashSet`1<SharedLocalFunctionConflict> CollectReachableSubgraph(OneToSetMap`2<SharedLocalFunctionConflict, SharedLocalFunctionConflict> extractedGraph, IEnumerable`1<SharedLocalFunctionConflict> roots);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static HashSet`1<SharedLocalFunctionConflict> ProcessSharedOnlyFunctions(OneToSetMap`2<SharedLocalFunctionConflict, SharedLocalFunctionConflict> graph, HashSet`1<SharedLocalFunctionConflict> sharedOnlyFunctions);
    private void ResolveLocalFunctionConflicts(IEnumerable`1<LocalFunctionConflictInfo> localFunctionConflicts, ITreeRange treeRange, ICSharpExtractMethodTargetSiteContext targetSiteContext, IList`1<IConflict> conflicts, HashSet`1<CSharpExtractMethodLocalFunction> movedLocalFunctions);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.CSharpExtractMethodControlFlowInspectionResultExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static string Dump(ICSharpExtractMethodControlFlowInspectionResult result);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.CSharpExtractMethodControlFlowInspector : ExtractMethodControlFlowInspectorBase`2<ITypeOwner, CSharpExtractMethodInspectionContext> {
    private ReturnedValueGroup myReturnValueGroup;
    private bool myCanReturnOneValue;
    private bool myHasReturnsWithValues;
    private int myNonReturnExitsCount;
    private ITreeNode myGraphOwner;
    private ITreeRange myTreeRange;
    private ICSharpControlFlowGraph myGraph;
    [NotNullAttribute]
private Dictionary`2<ITypeOwner, CSharpExtractMethodParameter> myParameters;
    [NotNullAttribute]
private List`1<CSharpExtractMethodParameter> myExtraReturnParameters;
    private bool myIsExpression;
    private ITreeNodePointer`1<ICSharpDeclaration> myOwnerDeclarationPointer;
    private ITreeNodePointer`1<ITreeNode> myGraphOwnerPointer;
    [CompilerGeneratedAttribute]
private OneToSetMap`2<string, ITypeOwner> <UsedNames>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IYieldStatement> <YieldStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasAwaits>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpExtractMethodParameter <ReturnValueParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpDeclaration <OwnerDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtractMethodLocalFunctionAnalysis <LocalFunctionAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMultipleEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMultipleExitsProblem>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<ICSharpStatement> <ExitsClassA>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<ICSharpStatement> <ExitsClassB>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExitsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private OneToSetMap`2<CSharpExtractMethodParameter, CSharpExtractMethodParameterUsage> <ParameterUsagesOutside>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasFallthroughExit>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<IReferenceExpression> <DirectLocalFunctionUsages>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<ITypeParameter> <AllTypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<ITypeParameter> <UsedTypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IField> <ReadonlyFields>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IProperty> <ReadonlyProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<NameofConflictInfo> <NameofConflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<LocalFunctionConflictInfo> <LocalFunctionConflicts>k__BackingField;
    private OneToSetMap`2<ILocalFunction, IReferenceExpression> myInnerLocalFunctionUsages;
    private OneToSetMap`2<ILocalFunction, IReferenceExpression> myOuterLocalFunctionUsages;
    private OneToSetMap`2<IDeclaredElement, ITreeNode> myInnerNameofUsages;
    private OneToSetMap`2<IDeclaredElement, ITreeNode> myOuterNameofUsages;
    private bool myPrimaryParameterUsagesAreCaptures;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CSharpExtractMethodParameter> <AllParameters>k__BackingField;
    public OneToSetMap`2<string, ITypeOwner> UsedNames { get; }
    public IList`1<IYieldStatement> YieldStatements { get; }
    public bool HasAwaits { get; private set; }
    public CSharpExtractMethodParameter ReturnValueParameter { get; public set; }
    public ICSharpDeclaration OwnerDeclaration { get; private set; }
    [NotNullAttribute]
internal ExtractMethodLocalFunctionAnalysis LocalFunctionAnalysis { get; }
    public bool HasMultipleEntries { get; private set; }
    public bool HasNameConflictsWithMovedLocalFunctions { get; }
    public bool HasMultipleExitsProblem { get; private set; }
    public bool CanBeStatic { get; private set; }
    public bool CanBeInstance { get; private set; }
    public HashSet`1<ICSharpStatement> ExitsClassA { get; }
    public HashSet`1<ICSharpStatement> ExitsClassB { get; }
    public int ExitsCount { get; private set; }
    public OneToSetMap`2<CSharpExtractMethodParameter, CSharpExtractMethodParameterUsage> ParameterUsagesOutside { get; }
    public bool HasFallthroughExit { get; private set; }
    public HashSet`1<IReferenceExpression> DirectLocalFunctionUsages { get; }
    public HashSet`1<ITypeParameter> AllTypeParameters { get; }
    public HashSet`1<ITypeParameter> UsedTypeParameters { get; }
    public IEnumerable`1<IField> ReadonlyFields { get; private set; }
    public IEnumerable`1<IProperty> ReadonlyProperties { get; private set; }
    public IReadOnlyList`1<NameofConflictInfo> NameofConflicts { get; private set; }
    public IReadOnlyList`1<LocalFunctionConflictInfo> LocalFunctionConflicts { get; private set; }
    public bool CanHaveRefOutParameters { get; }
    public IReadOnlyDictionary`2<ITypeOwner, CSharpExtractMethodParameter> ParametersFromVariables { get; }
    public IReadOnlyList`1<CSharpExtractMethodParameter> AllParameters { get; private set; }
    public IReadOnlyList`1<CSharpExtractMethodParameter> ExtraReturnParameters { get; }
    public IEnumerable`1<CSharpExtractMethodLocalFunction> MovedLocalFunctions { get; }
    public IReadOnlyList`1<IConflict> Conflicts { get; }
    private CSharpExtractMethodControlFlowInspector(ITreeRange treeRange, ICSharpControlFlowGraph graph, ITreeNode graphOwner, bool isExpression, ExtractMethodLocalFunctionAnalysis localFunctionAnalysis);
    [CompilerGeneratedAttribute]
public sealed virtual OneToSetMap`2<string, ITypeOwner> get_UsedNames();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IYieldStatement> get_YieldStatements();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasAwaits();
    [CompilerGeneratedAttribute]
private void set_HasAwaits(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual CSharpExtractMethodParameter get_ReturnValueParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReturnValueParameter(CSharpExtractMethodParameter value);
    [CompilerGeneratedAttribute]
public sealed virtual ICSharpDeclaration get_OwnerDeclaration();
    [CompilerGeneratedAttribute]
private void set_OwnerDeclaration(ICSharpDeclaration value);
    [CompilerGeneratedAttribute]
internal ExtractMethodLocalFunctionAnalysis get_LocalFunctionAnalysis();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasMultipleEntries();
    [CompilerGeneratedAttribute]
private void set_HasMultipleEntries(bool value);
    public sealed virtual bool get_HasNameConflictsWithMovedLocalFunctions();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasMultipleExitsProblem();
    [CompilerGeneratedAttribute]
private void set_HasMultipleExitsProblem(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanBeStatic();
    [CompilerGeneratedAttribute]
private void set_CanBeStatic(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanBeInstance();
    [CompilerGeneratedAttribute]
private void set_CanBeInstance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual HashSet`1<ICSharpStatement> get_ExitsClassA();
    [CompilerGeneratedAttribute]
public sealed virtual HashSet`1<ICSharpStatement> get_ExitsClassB();
    [CompilerGeneratedAttribute]
public int get_ExitsCount();
    [CompilerGeneratedAttribute]
private void set_ExitsCount(int value);
    [CompilerGeneratedAttribute]
public sealed virtual OneToSetMap`2<CSharpExtractMethodParameter, CSharpExtractMethodParameterUsage> get_ParameterUsagesOutside();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasFallthroughExit();
    [CompilerGeneratedAttribute]
private void set_HasFallthroughExit(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual HashSet`1<IReferenceExpression> get_DirectLocalFunctionUsages();
    [CompilerGeneratedAttribute]
public sealed virtual HashSet`1<ITypeParameter> get_AllTypeParameters();
    [CompilerGeneratedAttribute]
public sealed virtual HashSet`1<ITypeParameter> get_UsedTypeParameters();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<IField> get_ReadonlyFields();
    [CompilerGeneratedAttribute]
private void set_ReadonlyFields(IEnumerable`1<IField> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<IProperty> get_ReadonlyProperties();
    [CompilerGeneratedAttribute]
private void set_ReadonlyProperties(IEnumerable`1<IProperty> value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<NameofConflictInfo> get_NameofConflicts();
    [CompilerGeneratedAttribute]
private void set_NameofConflicts(IReadOnlyList`1<NameofConflictInfo> value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<LocalFunctionConflictInfo> get_LocalFunctionConflicts();
    [CompilerGeneratedAttribute]
private void set_LocalFunctionConflicts(IReadOnlyList`1<LocalFunctionConflictInfo> value);
    public sealed virtual bool get_CanHaveRefOutParameters();
    public sealed virtual IReadOnlyDictionary`2<ITypeOwner, CSharpExtractMethodParameter> get_ParametersFromVariables();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<CSharpExtractMethodParameter> get_AllParameters();
    [CompilerGeneratedAttribute]
private void set_AllParameters(IReadOnlyList`1<CSharpExtractMethodParameter> value);
    public sealed virtual IReadOnlyList`1<CSharpExtractMethodParameter> get_ExtraReturnParameters();
    public sealed virtual IEnumerable`1<CSharpExtractMethodLocalFunction> get_MovedLocalFunctions();
    public sealed virtual IReadOnlyList`1<IConflict> get_Conflicts();
    [CanBeNullAttribute]
public static ICSharpExtractMethodControlFlowInspectionResult Analyze(ITreeRange treeRange, bool isExpression, CSharpExtractMethodParameter fixedReturnParameter);
    [CanBeNullAttribute]
public static CSharpExtractMethodControlFlowInspector CreateClosureInspector(CSharpExtractMethodControlFlowInspector context, ICSharpClosure declaration);
    public void Analyze(CSharpExtractMethodParameter fixedReturnParameter);
    private void AnalyseNullableAnnotations();
    private void AnalyseExitsAndEntries(CSharpExtractMethodParameter fixedReturnParameter);
    private void AnalyseLocalFunctionsUsage();
    [NotNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<ITreeNode> GetOuterUsages(ILocalFunction localFunction);
    private void AnalyseNameofConflicts();
    protected virtual void InspectLeafNode(IControlFlowElement element, ITreeNode sourceElement, CSharpExtractMethodInspectionContext context);
    private void RegisterVariables();
    private void RegisterVariablesFromClosure(ICSharpClosure cSharpClosure, IStatementsOwner topMostStatementsOwner);
    private void RegisterReferencedVariables(ITreeNode node, IStatementsOwner topMostStatementsOwner);
    private void RegisterVariable(ITypeOwner typeOwner, IStatementsOwner topMostStatementsOwner);
    private VariableDeclarationKind GetDeclarationKind(IDeclaredElement declaredElement, IStatementsOwner topMostStatementsOwner);
    private void RegisterReadAndWriteUsages();
    private void RegisterTypeParameters();
    private void CopyInnerUsages(CSharpExtractMethodControlFlowInspector usagesSource);
    [NotNullAttribute]
private static ICSharpExpression FindActualWriteUsageSource(ICSharpExpression writtenExpression);
    private static bool ShouldRegisterNameofArgumentUsage(IDeclaredElement declaredElement, IReferenceExpression referenceExpression);
    private void ScanTypeParameters(ITreeNode node);
    private void AddTypeParametersUsagesFromType(IType type);
    protected virtual ITreeNode FindControlFlowOwner(ITreeNode context);
    protected virtual bool IsUsageFromDelegateClosure(ITreeNode controlFlowOwner);
    private void AnalyseStaticness();
    private void PrepareParameters();
    private void AddUsageInfoForParameters(OneToSetMap`2<ITreeNode, ITypeOwner> usages, bool isInside, bool isDelegateClosureUsages);
    protected virtual bool CanReturnOutside(ITypeOwner typeOwner);
    public void SuggestNames();
    private void AnalyseExitsAndEntries();
    private bool AnalyseIteratorFunctionReturns();
    [CanBeNullAttribute]
private IParametersOwner GetContainingIterator();
    [CanBeNullAttribute]
private CSharpExtractMethodParameter GetOutParameter(ICSharpExpression expression);
    private bool TryChooseCorrelatingValue(IList`1<IControlFlowEdge> outcomingEdges, ReturnedValueGroup returnValueGroup);
    [CanBeNullAttribute]
private static ICSharpExpression GetValueOfWriteUsage(ITreeNode treeNode);
    private static bool IsReturn(IControlFlowEdge edge);
    private void AddReturn(ITreeNode sourceElement, ITreeNode defaultExitPoint, ITreeNode exitPoint);
    private int GetExitsCount();
    private int GetNonReturnExitsCount();
    [CanBeNullAttribute]
private ITreeNode GetExitElement(IControlFlowEdge edge);
    private static bool HasReturnExitToNull(ICSharpControlFlowElement element);
    [CanBeNullAttribute]
private static ITreeNode GetTargetSourceElement(ICSharpControlFlowElement element);
    [CanBeNullAttribute]
private static ITreeNode GetTargetSourceElement(ICSharpControlFlowElement element, Boolean& isExitThroughFinally);
    private void ChooseBestReturnValue();
    [CanBeNullAttribute]
private CSharpExtractMethodParameter ChooseParameterByKind(CSharpExtractMethodParameterKind kind);
    private static bool IsFromRefOutParameter(CSharpExtractMethodParameter parameter);
    private static ReturnedValueGroup GetGroup(List`1<ICSharpExpression> values);
    private void BuildParameters();
    [NotNullAttribute]
private IEnumerable`1<ITreeNode> GetReachingWriteUsages(IControlFlowEdge edge, ITypeOwner key);
    protected virtual ITreeNode GetDeclaration(ITypeOwner typeOwner);
    [NotNullAttribute]
private IType GetOwnerReturnValueType(IReadOnlyList`1<IReturnStatement> reachableOwnerReturns);
    public sealed virtual bool IsValid();
    public sealed virtual void CoerceParameterNames(ICSharpExtractMethodTargetSiteContext targetSiteContext);
    public sealed virtual void CoerceParameterNameForCallSite(IReadOnlyCollection`1<IDeclaration> createdDeclarations, ITreeRange extractedRange);
    [CompilerGeneratedAttribute]
private void <AddTypeParametersUsagesFromType>b__133_0(IDeclaredType declaredType);
    [CompilerGeneratedAttribute]
private bool <AnalyseIteratorFunctionReturns>b__142_2(IControlFlowEdge x);
    [CompilerGeneratedAttribute]
private bool <AnalyseIteratorFunctionReturns>b__142_3(IYieldStatement st);
    [CompilerGeneratedAttribute]
private bool <AnalyseIteratorFunctionReturns>b__142_5(IControlFlowElement leafElement);
    [CompilerGeneratedAttribute]
private bool <AnalyseIteratorFunctionReturns>b__142_6(IControlFlowEdge entr);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.CSharpExtractMethodInspectionContext : ExtractMethodInspectionContextBase {
    [CompilerGeneratedAttribute]
private HashSet`1<IYieldStatement> <YieldStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<IAwaitExpression> <AwaitExpressions>k__BackingField;
    [NotNullAttribute]
public HashSet`1<IYieldStatement> YieldStatements { get; }
    [NotNullAttribute]
public HashSet`1<IAwaitExpression> AwaitExpressions { get; }
    public CSharpExtractMethodInspectionContext(CSharpExtractMethodInspectionContext other);
    public CSharpExtractMethodInspectionContext(IList`1<CSharpExtractMethodInspectionContext> contexts);
    [CompilerGeneratedAttribute]
public HashSet`1<IYieldStatement> get_YieldStatements();
    [CompilerGeneratedAttribute]
public HashSet`1<IAwaitExpression> get_AwaitExpressions();
    protected virtual ExtractMethodInspectionContextBase CloneSelf();
    [NotNullAttribute]
public CSharpExtractMethodInspectionContext Yield(IYieldStatement yieldStatement);
    [NotNullAttribute]
public CSharpExtractMethodInspectionContext Await(IAwaitExpression awaitExpression);
    [NotNullAttribute]
public CSharpExtractMethodInspectionContext RemoveYield();
    public virtual bool Equals(ExtractMethodInspectionContextBase other);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.CSharpExtractMethodInspectionContextFactory : object {
    [NotNullAttribute]
public static CSharpExtractMethodInspectionContextFactory Instance;
    public CSharpExtractMethodInspectionContext InitialContext { get; }
    private static CSharpExtractMethodInspectionContextFactory();
    public sealed virtual CSharpExtractMethodInspectionContext get_InitialContext();
    public sealed virtual CSharpExtractMethodInspectionContext CloneContext(CSharpExtractMethodInspectionContext context);
    public sealed virtual CSharpExtractMethodInspectionContext Merge(IList`1<CSharpExtractMethodInspectionContext> contexts);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.CSharpExtractMethodParameterComparer : object {
    [NotNullAttribute]
private CSharpExtractMethodParameter myReturnValueParameter;
    public CSharpExtractMethodParameterComparer(CSharpExtractMethodParameter returnValueParameter);
    public sealed virtual int Compare(CSharpExtractMethodParameter x, CSharpExtractMethodParameter y);
    private int GetValue(CSharpExtractMethodParameter p);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.CSharpExtractMethodParameterUsage : ValueType {
    [NotNullAttribute]
private ITreeNodePointer`1<ITreeNode> myUsagePointer;
    [CompilerGeneratedAttribute]
private bool <IsDelegateClosureUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInside>k__BackingField;
    public bool IsDelegateClosureUsage { get; }
    public bool IsInside { get; }
    public bool IsOutside { get; }
    [CanBeNullAttribute]
public ITreeNode Node { get; }
    public CSharpExtractMethodParameterUsage(ITreeNode usage, bool isInside, bool isDelegateClosureUsage);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsDelegateClosureUsage();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsInside();
    public bool get_IsOutside();
    public ITreeNode get_Node();
    public sealed virtual bool Equals(CSharpExtractMethodParameterUsage other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.ExtractMethodLocalFunctionAnalysis : LocalFunctionAnalysis`3<ExtractMethodLocalFunctionInfo, ExtractMethodLocalFunctionDataCollector, CSharpExtractMethodControlFlowInspector> {
    protected ExtractMethodLocalFunctionInfo RecursiveInfo { get; }
    protected ExtractMethodLocalFunctionInfo EmptyInfo { get; }
    protected virtual ExtractMethodLocalFunctionInfo get_RecursiveInfo();
    protected virtual ExtractMethodLocalFunctionInfo get_EmptyInfo();
    protected virtual ExtractMethodLocalFunctionDataCollector CreateLocalFunctionDataCollector(ILocalFunction localFunction);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.ExtractMethodLocalFunctionDataCollector : object {
    [CompilerGeneratedAttribute]
private ILocalFunction <LocalFunction>k__BackingField;
    public ILocalFunction LocalFunction { get; }
    public ExtractMethodLocalFunctionDataCollector(ILocalFunction localFunction);
    [CompilerGeneratedAttribute]
public sealed virtual ILocalFunction get_LocalFunction();
    public sealed virtual ExtractMethodLocalFunctionInfo RunLocalFunctionDataCollection(ILocalFunctionDeclaration declaration, CSharpExtractMethodControlFlowInspector context);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.ExtractMethodLocalFunctionInfo : object {
    [NotNullAttribute]
public static ExtractMethodLocalFunctionInfo EmptyInfo;
    [CompilerGeneratedAttribute]
private CSharpExtractMethodControlFlowInspector <Inspector>k__BackingField;
    [CompilerGeneratedAttribute]
private OneToSetMap`2<string, ITypeOwner> <UsedNames>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<ITypeParameter> <UsedTypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<ITypeOwner, CSharpExtractMethodParameter> <Parameters>k__BackingField;
    [CanBeNullAttribute]
public CSharpExtractMethodControlFlowInspector Inspector { get; }
    private bool CanBeStatic { get; }
    private bool CanBeInstance { get; }
    [NotNullAttribute]
private OneToSetMap`2<string, ITypeOwner> UsedNames { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public HashSet`1<ITypeParameter> UsedTypeParameters { get; }
    [NotNullAttribute]
public IReadOnlyDictionary`2<ITypeOwner, CSharpExtractMethodParameter> Parameters { get; }
    [NotNullAttribute]
public IReadOnlyList`1<LocalFunctionConflictInfo> LocalFunctionConflicts { get; }
    public ExtractMethodLocalFunctionInfo(CSharpExtractMethodControlFlowInspector inspector);
    private static ExtractMethodLocalFunctionInfo();
    [CompilerGeneratedAttribute]
public CSharpExtractMethodControlFlowInspector get_Inspector();
    private bool get_CanBeStatic();
    private bool get_CanBeInstance();
    [CompilerGeneratedAttribute]
private OneToSetMap`2<string, ITypeOwner> get_UsedNames();
    [CompilerGeneratedAttribute]
public HashSet`1<ITypeParameter> get_UsedTypeParameters();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<ITypeOwner, CSharpExtractMethodParameter> get_Parameters();
    public IReadOnlyList`1<LocalFunctionConflictInfo> get_LocalFunctionConflicts();
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<ITypeOwner> GetDefinitelyAssignedVariables();
    [NotNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<ExtractMethodLocalFunctionInfo> CollectAllReferencedLocalFunctions();
    public Nullable`1<ExtractMethodControlFlowInspectionPatch> TryGetControlFlowInspectionPatchForLocalFunction(ITreeRange extractedRange);
}
public interface JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.ICSharpExtractMethodControlFlowInspectionResult {
    public OneToSetMap`2<string, ITypeOwner> UsedNames { get; }
    public IList`1<IYieldStatement> YieldStatements { get; }
    public bool HasAwaits { get; }
    public CSharpExtractMethodParameter ReturnValueParameter { get; public set; }
    public ICSharpDeclaration OwnerDeclaration { get; }
    public bool HasMultipleExitsProblem { get; }
    public IReadOnlyList`1<CSharpExtractMethodParameter> AllParameters { get; }
    [NotNullAttribute]
public IReadOnlyDictionary`2<ITypeOwner, CSharpExtractMethodParameter> ParametersFromVariables { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public HashSet`1<ITypeParameter> AllTypeParameters { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public HashSet`1<ITypeParameter> UsedTypeParameters { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public HashSet`1<IReferenceExpression> DirectLocalFunctionUsages { get; }
    [NotNullAttribute]
public OneToSetMap`2<CSharpExtractMethodParameter, CSharpExtractMethodParameterUsage> ParameterUsagesOutside { get; }
    public bool HasFallthroughExit { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IField> ReadonlyFields { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IProperty> ReadonlyProperties { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<NameofConflictInfo> NameofConflicts { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<LocalFunctionConflictInfo> LocalFunctionConflicts { get; }
    public bool CanHaveRefOutParameters { get; }
    [NotNullAttribute]
public HashSet`1<ICSharpStatement> ExitsClassA { get; }
    [NotNullAttribute]
public HashSet`1<ICSharpStatement> ExitsClassB { get; }
    [NotNullAttribute]
public IReadOnlyList`1<CSharpExtractMethodParameter> ExtraReturnParameters { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<CSharpExtractMethodLocalFunction> MovedLocalFunctions { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<IConflict> Conflicts { get; }
    public bool CanBeStatic { get; }
    public bool CanBeInstance { get; }
    public bool HasMultipleEntries { get; }
    public bool HasNameConflictsWithMovedLocalFunctions { get; }
    public abstract virtual OneToSetMap`2<string, ITypeOwner> get_UsedNames();
    public abstract virtual IList`1<IYieldStatement> get_YieldStatements();
    public abstract virtual bool get_HasAwaits();
    public abstract virtual CSharpExtractMethodParameter get_ReturnValueParameter();
    public abstract virtual void set_ReturnValueParameter(CSharpExtractMethodParameter value);
    public abstract virtual ICSharpDeclaration get_OwnerDeclaration();
    public abstract virtual bool get_HasMultipleExitsProblem();
    public abstract virtual IReadOnlyList`1<CSharpExtractMethodParameter> get_AllParameters();
    public abstract virtual IReadOnlyDictionary`2<ITypeOwner, CSharpExtractMethodParameter> get_ParametersFromVariables();
    public abstract virtual HashSet`1<ITypeParameter> get_AllTypeParameters();
    public abstract virtual HashSet`1<ITypeParameter> get_UsedTypeParameters();
    public abstract virtual HashSet`1<IReferenceExpression> get_DirectLocalFunctionUsages();
    public abstract virtual OneToSetMap`2<CSharpExtractMethodParameter, CSharpExtractMethodParameterUsage> get_ParameterUsagesOutside();
    public abstract virtual bool get_HasFallthroughExit();
    public abstract virtual IEnumerable`1<IField> get_ReadonlyFields();
    public abstract virtual IEnumerable`1<IProperty> get_ReadonlyProperties();
    public abstract virtual IReadOnlyList`1<NameofConflictInfo> get_NameofConflicts();
    public abstract virtual IReadOnlyList`1<LocalFunctionConflictInfo> get_LocalFunctionConflicts();
    public abstract virtual bool get_CanHaveRefOutParameters();
    public abstract virtual HashSet`1<ICSharpStatement> get_ExitsClassA();
    public abstract virtual HashSet`1<ICSharpStatement> get_ExitsClassB();
    public abstract virtual IReadOnlyList`1<CSharpExtractMethodParameter> get_ExtraReturnParameters();
    public abstract virtual IEnumerable`1<CSharpExtractMethodLocalFunction> get_MovedLocalFunctions();
    public abstract virtual IReadOnlyList`1<IConflict> get_Conflicts();
    public abstract virtual bool get_CanBeStatic();
    public abstract virtual bool get_CanBeInstance();
    public abstract virtual bool get_HasMultipleEntries();
    public abstract virtual bool get_HasNameConflictsWithMovedLocalFunctions();
    public abstract virtual bool IsValid();
    public abstract virtual void CoerceParameterNames(ICSharpExtractMethodTargetSiteContext targetSiteContext);
    public abstract virtual void CoerceParameterNameForCallSite(IReadOnlyCollection`1<IDeclaration> createdDeclarations, ITreeRange extractedRange);
}
public enum JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.ControlFlow.ReturnedValueGroup : Enum {
    public int value__;
    public static ReturnedValueGroup NoGroup;
    public static ReturnedValueGroup True;
    public static ReturnedValueGroup False;
    public static ReturnedValueGroup NotNull;
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.FromExpression.CSharpExtractMethodFromExpressionProvider : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.FromExpression.CSharpExtractMethodFromExpressionProvider/<CreateWorkflow>d__0")]
public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.FromExpression.CSharpExtractMethodFromExpressionRefactoring : CSharpExtractMethodRefactoringBase {
    [NotNullAttribute]
private CSharpExtractMethodFromExpressionWorkflow myWorkflow;
    [NotNullAttribute]
private ISolution mySolution;
    public CSharpExtractMethodFromExpressionRefactoring(CSharpExtractMethodFromExpressionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool Execute(IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.FromExpression.CSharpExtractMethodFromExpressionWorkflow : CSharpExtractMethodWorkflowBase {
    private ITreeNodePointer`1<ICSharpExpression> myExpressionPointer;
    [CompilerGeneratedAttribute]
private ExtractMethodResult <Result>k__BackingField;
    [CanBeNullAttribute]
public ICSharpExpression Expression { get; private set; }
    public ITreeRange SelectedRange { get; }
    public ExtractMethodResult Result { get; public set; }
    public CSharpExtractMethodFromExpressionWorkflow(ISolution solution, string actionId);
    public ICSharpExpression get_Expression();
    private void set_Expression(ICSharpExpression value);
    public virtual ITreeRange get_SelectedRange();
    [CompilerGeneratedAttribute]
public sealed virtual ExtractMethodResult get_Result();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Result(ExtractMethodResult value);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual ITreeNode CreatePreviewElement();
    public virtual LocalFunctionSignatureInfo CreateSignaturePreviewElement(ICSharpExtractMethodControlFlowInspectionResult analysisResult);
    public virtual bool IsValid();
    public virtual bool IsAvailable(IDataContext context);
    public bool IsAvailable(ICSharpExpression expression);
    public virtual ICSharpExtractMethodControlFlowInspectionResult AnalizeDataFlow();
    [PureAttribute]
private static bool CanExtractMethodFrom(ICSharpExpression expression);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.FromExpression.CSharpExtractMethodRunnerFromExpression : CSharpExtractMethodRunner {
    private ICSharpExpression myExpression;
    public CSharpExtractMethodRunnerFromExpression(CSharpExtractMethodWorkflowBase workflow, ICSharpExtractMethodControlFlowInspectionResult inspectionResult, ICSharpExpression expression, bool isPreview);
    [NotNullAttribute]
public IDeclaration CreateSignaturePreviewElement();
    public IDeclaration CreateDeclaration();
    private void CreateBodyStatements(IBlock body);
    private void CreateExpressionParameterReturn(CSharpExtractMethodParameterReturnExpression expressionParameter, IBlock body);
    private void CreateReturnStatement(CSharpExtractMethodParameter returnValueParameter, IBlock body);
    public void ReplaceExpression(IDeclaration newDeclaration);
    [CanBeNullAttribute]
private static ICSharpExpression AppendCallSiteStatements(ICSharpExpression expression, IReadOnlyList`1& callSiteStatements);
    protected virtual bool IsTopScope(ILocalScope scope);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.FromStatements.CSharpExtractMethodFromStatementsProvider : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.FromStatements.CSharpExtractMethodFromStatementsProvider/<CreateWorkflow>d__0")]
public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.FromStatements.CSharpExtractMethodFromStatementsRefactoring : CSharpExtractMethodRefactoringBase {
    [NotNullAttribute]
private CSharpExtractMethodFromStatementsWorkflow myWorkflow;
    [NotNullAttribute]
private ISolution mySolution;
    [NotNullAttribute]
private IRefactoringDriver myDriver;
    public CSharpExtractMethodFromStatementsRefactoring(CSharpExtractMethodFromStatementsWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool Execute(IProgressIndicator pi);
    protected virtual void ReportConflicts();
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.FromStatements.CSharpExtractMethodFromStatementsWorkflow : CSharpExtractMethodWorkflowBase {
    [CanBeNullAttribute]
private IRangeMarker myDocumentRangeMarker;
    [CompilerGeneratedAttribute]
private ExtractMethodResult <Result>k__BackingField;
    public ITreeRange SelectedRange { get; }
    [CanBeNullAttribute]
public ICSharpStatementsRange StatementsRange { get; private set; }
    public ExtractMethodResult Result { get; public set; }
    public CSharpExtractMethodFromStatementsWorkflow(ISolution solution, string actionId);
    public virtual ITreeRange get_SelectedRange();
    public ICSharpStatementsRange get_StatementsRange();
    private void set_StatementsRange(ICSharpStatementsRange value);
    [CompilerGeneratedAttribute]
public sealed virtual ExtractMethodResult get_Result();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Result(ExtractMethodResult value);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual ITreeNode CreatePreviewElement();
    public virtual LocalFunctionSignatureInfo CreateSignaturePreviewElement(ICSharpExtractMethodControlFlowInspectionResult analysisResult);
    public virtual bool IsValid();
    protected virtual bool GetCanExtractChainedConstructor(ICSharpExtractMethodControlFlowInspectionResult analysisResult);
    public virtual bool IsAvailable(IDataContext context);
    public bool IsAvailable(ICSharpStatementsRange statementsRange);
    public virtual ICSharpExtractMethodControlFlowInspectionResult AnalizeDataFlow();
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.FromStatements.CSharpExtractMethodRunnerFromStatements : CSharpExtractMethodRunner {
    private ICSharpStatementsRange myStatements;
    public CSharpExtractMethodRunnerFromStatements(IExtractMethodWorkflow workflow, ICSharpExtractMethodControlFlowInspectionResult inspectionResult, ICSharpStatementsRange statements, bool isPreview);
    [NotNullAttribute]
public IDeclaration CreateSignaturePreviewElement();
    public IDeclaration CreateDeclaration();
    private ICSharpStatement CreateMethodReturnStatement(ICSharpStatement originalStatement, bool isExitClassA);
    [NotNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<ITreeNode> Transform(ITreeNode treeNode);
    private void RenameLocalVariableDeclaration(IMultipleDeclarationMember declaration);
    private void ReplaceLocalVariableDeclarationWithAssignment(IMultipleDeclarationMember declaration, ICSharpStatement copyStatement, List`1<ITreeNode> results, IReadOnlyList`1<ITreeNode> declarationsToRemove);
    protected virtual IList`1<ICSharpStatement> CreateAssignmentsOnReturn(ICSharpStatement statementToReplace);
    private void TransformReturn(ICSharpStatement copyStatement, ICSharpStatement statementToReplace, List`1<ITreeNode> ret, bool isExitClassA);
    [CanBeNullAttribute]
private ICSharpStatement GetAssignmentToReturnValue(ICSharpStatement statement);
    public void UpdateCallSite(CSharpElementFactory factory, IDeclaration newDeclaration);
    private void UpdateConstructor(CSharpElementFactory factory);
    protected virtual bool IsTopScope(ILocalScope scope);
    [NotNullAttribute]
private ICSharpStatementsRange AdjustStatementsRange(ICSharpStatementsRange statementsRange);
    private bool IsMovedLocalFunctionDeclaration(IStatement statement);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Parameters.CSharpExtractMethodParameterFromLambdaParameter : CSharpExtractMethodParameterWithVariable {
    private bool myIsRefOutParameter;
    public CSharpExtractMethodParameterFromLambdaParameter(IParameter parameter, VariableDeclarationKind declarationKind);
    public virtual bool IsFieldLike();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Parameters.CSharpExtractMethodParameterFromLocalVariable : CSharpExtractMethodParameterWithVariable {
    public CSharpExtractMethodParameterFromLocalVariable(ILocalVariable localVariable, VariableDeclarationKind declarationKind);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Parameters.CSharpExtractMethodParameterFromOwnerParameter : CSharpExtractMethodParameterWithVariable {
    private bool myIsRefOutParameter;
    public CSharpExtractMethodParameterFromOwnerParameter(IParameter localVariable, VariableDeclarationKind declarationKind);
    public virtual bool IsFieldLike();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Parameters.CSharpExtractMethodParameterFromQueryDeclaredElement : CSharpExtractMethodParameterWithVariable {
    public CSharpExtractMethodParameterFromQueryDeclaredElement(IQueryDeclaredElement localVariable, VariableDeclarationKind declarationKind);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Parameters.CSharpExtractMethodParameterInstantBool : CSharpExtractMethodParameter {
    private CSharpExtractMethodParameter myExtraReturnParameter;
    public bool HasDeclarationOutside { get; }
    public CSharpExtractMethodParameterInstantBool(CSharpExtractMethodParameter extraReturnParameter);
    public virtual bool get_HasDeclarationOutside();
    protected virtual IType GetParameterSourceType(IPsiModule module, ParameterKind kind, ITreeNode context);
    public virtual string ToString();
    public virtual string Dump();
    public virtual void SuggestName(INamesCollection collection);
    public virtual ExtractMethodReturnValue CreateReturnValue(CSharpElementFactory factory, ICSharpStatement originalStatement, ICSharpExtractMethodControlFlowInspectionResult inspector, bool isExitClassA);
    public virtual IReadOnlyList`1<ICSharpStatement> AddCall(CSharpElementFactory factory, ICSharpExpression call, ICSharpExtractMethodControlFlowInspectionResult inspectionResult, ITreeNode context);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Parameters.CSharpExtractMethodParameterReturnExpression : CSharpExtractMethodParameter {
    private ITreeNodePointer`1<ICSharpExpression> myExpressionPointer;
    [CanBeNullAttribute]
public ICSharpExpression Expression { get; }
    public bool HasDeclarationOutside { get; }
    public CSharpExtractMethodParameterReturnExpression(ICSharpExpression expression);
    public ICSharpExpression get_Expression();
    public virtual bool get_HasDeclarationOutside();
    protected virtual IType GetParameterSourceType(IPsiModule module, ParameterKind kind, ITreeNode context);
    public virtual string ToString();
    public virtual string Dump();
    public virtual void SuggestName(INamesCollection collection);
    public virtual ExtractMethodReturnValue CreateReturnValue(CSharpElementFactory factory, ICSharpStatement originalStatement, ICSharpExtractMethodControlFlowInspectionResult inspector, bool isExitClassA);
    public virtual IReadOnlyList`1<ICSharpStatement> AddCall(CSharpElementFactory factory, ICSharpExpression call, ICSharpExtractMethodControlFlowInspectionResult inspectionResult, ITreeNode context);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Parameters.CSharpExtractMethodParameterReturnValue : CSharpExtractMethodParameter {
    private IType myType;
    private IEnumerable`1<ITreeNodePointer`1<ICSharpExpression>> myExpressionsForNaming;
    public bool HasDeclarationOutside { get; }
    public bool IsForReturnValue { get; }
    public CSharpExtractMethodParameterReturnValue(IType type, IEnumerable`1<ICSharpExpression> expressionsForNaming, CSharpExtractMethodParameterKind kind);
    public virtual bool get_HasDeclarationOutside();
    public virtual bool get_IsForReturnValue();
    protected virtual IType GetParameterSourceType(IPsiModule module, ParameterKind kind, ITreeNode context);
    public virtual string ToString();
    public virtual string Dump();
    public virtual void SuggestName(INamesCollection collection);
    public virtual ExtractMethodReturnValue CreateReturnValue(CSharpElementFactory factory, ICSharpStatement originalStatement, ICSharpExtractMethodControlFlowInspectionResult inspector, bool isExitClassA);
    public virtual ICSharpStatement CreateAssignmentToReturnValue(ICSharpStatement statement);
    public virtual IReadOnlyList`1<ICSharpStatement> AddCall(CSharpElementFactory factory, ICSharpExpression call, ICSharpExtractMethodControlFlowInspectionResult inspectionResult, ITreeNode context);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Parameters.CSharpExtractMethodParameterReturnValueConditional : CSharpExtractMethodParameter {
    private ReturnedValueGroup myReturnValueGroup;
    private IType myType;
    private IEnumerable`1<ITreeNodePointer`1<ICSharpExpression>> myExpressionsForNaming;
    private ITreeNodePointer`1<ICSharpStatement> myFallThroughExit;
    public bool HasDeclarationOutside { get; }
    public bool IsForReturnValue { get; }
    public CSharpExtractMethodParameterReturnValueConditional(ReturnedValueGroup returnValueGroup, IType type, IEnumerable`1<ICSharpExpression> expressionsForNaming, ICSharpStatement fallThroughExit);
    public virtual bool get_HasDeclarationOutside();
    public virtual bool get_IsForReturnValue();
    public virtual string ToString();
    protected virtual IType GetParameterSourceType(IPsiModule module, ParameterKind kind, ITreeNode context);
    public virtual string Dump();
    public virtual void SuggestName(INamesCollection collection);
    public virtual ExtractMethodReturnValue CreateReturnValue(CSharpElementFactory factory, ICSharpStatement originalStatement, ICSharpExtractMethodControlFlowInspectionResult inspector, bool isExitClassA);
    public virtual IReadOnlyList`1<ICSharpStatement> AddCall(CSharpElementFactory factory, ICSharpExpression call, ICSharpExtractMethodControlFlowInspectionResult inspectionResult, ITreeNode context);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Parameters.CSharpExtractMethodParameterTrueWhenReturns : CSharpExtractMethodParameter {
    [CanBeNullAttribute]
private CSharpExtractMethodParameter mySimpleReturn;
    public CSharpExtractMethodParameterTrueWhenReturns(CSharpExtractMethodParameter simpleReturn);
    public virtual string ToString();
    protected virtual IType GetParameterSourceType(IPsiModule module, ParameterKind kind, ITreeNode context);
    public virtual string Dump();
    public virtual void SuggestName(INamesCollection collection);
    public virtual ExtractMethodReturnValue CreateReturnValue(CSharpElementFactory factory, ICSharpStatement originalStatement, ICSharpExtractMethodControlFlowInspectionResult inspector, bool isExitClassA);
    public virtual ICSharpExpression CreateArgumentValue(CSharpElementFactory factory);
    public virtual IReadOnlyList`1<ICSharpStatement> AddCall(CSharpElementFactory factory, ICSharpExpression call, ICSharpExtractMethodControlFlowInspectionResult inspectionResult, ITreeNode context);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Parameters.CSharpExtractMethodParameterTupleReturn : CSharpExtractMethodParameter {
    public bool HasDeclarationOutside { get; }
    public virtual bool get_HasDeclarationOutside();
    public bool IsSingleComponent(ICSharpExtractMethodControlFlowInspectionResult inspectionResult, CSharpExtractMethodParameter other);
    public virtual bool IncludesParameter(CSharpExtractMethodParameter other);
    public virtual IType GetParameterType(IPsiModule module, ICSharpExtractMethodControlFlowInspectionResult inspectionResult, ParameterKind kind);
    protected virtual IType GetParameterSourceType(IPsiModule module, ParameterKind kind, ITreeNode context);
    public virtual ExtractMethodReturnValue CreateReturnValue(CSharpElementFactory factory, ICSharpStatement originalStatement, ICSharpExtractMethodControlFlowInspectionResult inspector, bool isExitClassA);
    public virtual IReadOnlyList`1<ICSharpStatement> AddCall(CSharpElementFactory factory, ICSharpExpression call, ICSharpExtractMethodControlFlowInspectionResult inspectionResult, ITreeNode context);
    public virtual string ToString();
    public virtual string Dump();
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Parameters.CSharpExtractMethodParameterVoidReturn : CSharpExtractMethodParameter {
    [CanBeNullAttribute]
private ITreeNodePointer`1<ICSharpDeclaration> myOwnerDeclarationPointer;
    public bool HasDeclarationOutside { get; }
    public CSharpExtractMethodParameterVoidReturn(ICSharpDeclaration ownerDeclaration);
    public virtual bool get_HasDeclarationOutside();
    public virtual string ToString();
    protected virtual IType GetParameterSourceType(IPsiModule module, ParameterKind kind, ITreeNode context);
    public virtual string Dump();
    public virtual bool CanUseWithReturnValue(CSharpExtractMethodParameter returnValueParameter);
    public virtual void SuggestName(INamesCollection collection);
    public virtual ExtractMethodReturnValue CreateReturnValue(CSharpElementFactory factory, ICSharpStatement originalStatement, ICSharpExtractMethodControlFlowInspectionResult inspector, bool isExitClassA);
    public virtual IReadOnlyList`1<ICSharpStatement> AddCall(CSharpElementFactory factory, ICSharpExpression call, ICSharpExtractMethodControlFlowInspectionResult inspectionResult, ITreeNode context);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Parameters.CSharpExtractMethodParameterYieldOneValueWithReturn : CSharpExtractMethodParameter {
    private IType myType;
    private IEnumerable`1<ITreeNodePointer`1<ICSharpExpression>> myExpressionsForNaming;
    public bool HasDeclarationOutside { get; }
    public CSharpExtractMethodParameterYieldOneValueWithReturn(IType type, IEnumerable`1<ICSharpExpression> expressionsForNaming);
    public virtual bool get_HasDeclarationOutside();
    public virtual string ToString();
    protected virtual IType GetParameterSourceType(IPsiModule module, ParameterKind kind, ITreeNode context);
    public virtual string Dump();
    public virtual void SuggestName(INamesCollection collection);
    public virtual ICSharpExpression CreateArgumentValue(CSharpElementFactory factory);
    public virtual IReadOnlyList`1<ICSharpStatement> AddCall(CSharpElementFactory factory, ICSharpExpression call, ICSharpExtractMethodControlFlowInspectionResult inspectionResult, ITreeNode context);
    public virtual bool CanUseWithReturnValue(CSharpExtractMethodParameter returnValueParameter);
    public virtual ExtractMethodReturnValue CreateReturnValue(CSharpElementFactory factory, ICSharpStatement originalStatement, ICSharpExtractMethodControlFlowInspectionResult inspector, bool isExitClassA);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ExtractMethod2.Parameters.CSharpExtractMethodParameterYieldReturnValue : CSharpExtractMethodParameter {
    private IType myType;
    public bool HasDeclarationOutside { get; }
    public CSharpExtractMethodParameterYieldReturnValue(IType type);
    public virtual bool get_HasDeclarationOutside();
    protected virtual IType GetParameterSourceType(IPsiModule module, ParameterKind kind, ITreeNode context);
    public virtual string ToString();
    public virtual string Dump();
    public virtual void SuggestName(INamesCollection collection);
    public virtual ITreeNode GetCallSiteUniqueNameContext(ITreeRange extractedRange);
    public virtual IReadOnlyList`1<ICSharpStatement> AddCall(CSharpElementFactory factory, ICSharpExpression call, ICSharpExtractMethodControlFlowInspectionResult inspectionResult, ITreeNode context);
    public virtual bool CanUseWithReturnValue(CSharpExtractMethodParameter returnValueParameter);
    public virtual ExtractMethodReturnValue CreateReturnValue(CSharpElementFactory factory, ICSharpStatement originalStatement, ICSharpExtractMethodControlFlowInspectionResult inspector, bool isExitClassA);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Function2Indexer.CsFunction2Indexer : CsFunction2Property {
    public CsFunction2Indexer(Function2PropertyWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    protected virtual void ProcessMethod(IDeclaredElement element);
    protected virtual void RenameParameter(IMethod method, IProperty existingProperty);
    protected virtual IEnumerable`1<ITypeMember> GetMembers(ITypeElement containingType, IMethod method);
    protected virtual PropertySearchResultBase TestPropertyParameters(IProperty property);
    public virtual void CheckConflictWithProperty(IProperty property, IDeclaredElement existingDeclaration, bool isBase, bool isInheritor);
    public virtual bool InitialValidate();
    protected virtual ICSharpExpression CreateGetterExpression(ICSharpExpression qualifierExpression, IInvocationExpression invocationExpression, bool conditionalAccess);
    protected virtual ICSharpExpression CreateExpressionForSetter(ICSharpExpression qualifier, ICSharpExpression expression, IInvocationExpression invocationExpression);
    protected virtual void CheckConflictWithClassName(ITypeElement element);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Function2Property.CsFunction2Property : Function2PropertyBase {
    private bool myIsGetter;
    public CsFunction2Property(Function2PropertyWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    protected virtual void ProcessMethod(IDeclaredElement element);
    private static void TransferAttributes(IMethodDeclaration methodDeclaration, IPropertyDeclaration propertyDeclaration, IAccessorDeclaration accessorDeclaration);
    private static void UpdateComment(ICSharpDocCommentBlock comment);
    public virtual void CheckConflictWithMethod(IMethod method, IDeclaredElement existingDeclaration, bool isBase, bool isInheritor);
    protected virtual void CheckConflictWithClassName(ITypeElement element);
    protected void CheckGenericParameters();
    public virtual bool InitialValidate();
    public virtual void ExecuteReferencesRefactoring(IReference reference);
    protected virtual ICSharpExpression CreateExpressionForSetter(ICSharpExpression qualifier, ICSharpExpression expression, IInvocationExpression invocationExpression);
    [CanBeNullAttribute]
private ICSharpExpression CreateArrayExpressionForParams(IInvocationExpression invocationExpression, IMethod method);
    private string GetRankFormatted();
    protected virtual ICSharpExpression CreateGetterExpression(ICSharpExpression qualifierExpression, IInvocationExpression invocationExpression, bool conditionalAccess);
    protected virtual PropertySearchResultBase TestPropertyParameters(IProperty property);
    protected virtual bool CheckExplicitImplementationList(IOverridableMember accessor, IMethod method);
    public virtual void CheckConflictWithProperty(IProperty property, IDeclaredElement existingDeclaration, bool isBase, bool isInheritor);
    protected virtual bool AreEquals(string name1, string name2);
    protected IAccessorDeclaration TransferToAccessor(IMethodDeclaration methodDeclaration, bool inInterface, CSharpElementFactory factory, TPropertyLikeDeclaration propertyLikeDeclaration);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Helpers.CSharpNamespaceRedundancyFileFixer : object {
    private INamespace myNamespace;
    private string myShortName;
    private IProjectFile myProjectFile;
    private IList`1<IUsingDirective> myIncorrectUsingDirectives;
    public bool IsEmpty { get; }
    public IProjectFile ProjectFile { get; }
    public CSharpNamespaceRedundancyFileFixer(INamespace namespace, IFile file);
    private IList`1<IUsingDirective> FindUsings(ICSharpFile file);
    private void ProcessHolder(ICSharpTypeAndNamespaceHolderDeclaration file, IList`1& result);
    public sealed virtual bool get_IsEmpty();
    public sealed virtual IProjectFile get_ProjectFile();
    public sealed virtual void FixUsages();
}
public class JetBrains.ReSharper.Refactorings.CSharp.Indexer2Function.CsIndexer2Function : Indexer2FunctionBase {
    public CsIndexer2Function(Property2FunctionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    protected virtual void CheckConflictWithClassName(ITypeElement element);
    public virtual void ExecuteDeclarationRefactoring(IDeclaredElement propertyOrMethod, IProgressIndicator pi);
    protected virtual bool AreEquals(string name1, string name2);
    protected virtual bool SkipIndexerReference(IReference reference);
    public virtual bool TryNewTypeDeclaration(IndexersSearchData data, IReference reference);
}
public static class JetBrains.ReSharper.Refactorings.CSharp.Inline.ArgUtil.CSharpArgumentsUtil : object {
    [NotNullAttribute]
public static ArgumentFromParameter GetArgumentFromParameter(IParameter parameter, IParametersOwner parametersOwner, ICSharpArgumentsOwner argumentsOwner);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Inline.CodeTransformers.CSharpInlinedCodeTransformHelper : object {
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<IDeclaredElement> myCreatedDeclarationExpressionVariables;
    [CompilerGeneratedAttribute]
private CallSiteContext <CallSiteContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <TargetContext>k__BackingField;
    public CallSiteContext CallSiteContext { get; }
    public ITreeNode TargetContext { get; public set; }
    public CSharpInlinedCodeTransformHelper(CallSiteContext callSiteContext);
    [CompilerGeneratedAttribute]
public CallSiteContext get_CallSiteContext();
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_TargetContext();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TargetContext(ITreeNode value);
    public sealed virtual ITreeNode ChangeName(ITreeNode element, string name);
    public sealed virtual ITreeNode AddActionReplaceWithDefaultParamValue(IReferenceExpression expression, IParameter parameter);
    public sealed virtual ITreeNode AddActionReplaceParameterWithArgumentExpression(IReferenceExpression expression, IParameter parameter, InlinedArgumentInfo info, ArgumentFromParameter argumentFromParameter);
    public sealed virtual ITreeNode AddActionReplaceExpressionWithTemp(IExpression expression, string tempVariableName);
    public sealed virtual ITreeNode ReplaceByQualifier(IReferenceExpression expression, IQualifierOwnerCallInfo info);
    public sealed virtual ITreeNode AddActionSetQualifier(IReferenceExpression expression, IQualifierOwnerCallInfo info);
    public sealed virtual bool IsExtensionMethod(IReferenceExpression expression);
    public static ICSharpExpression EnCastExpressionToArray(List`1<IArgument> args, CallSiteContext context, ICSharpTreeNode typeUsageContext);
    [MustUseReturnValueAttribute]
public static ICSharpExpression EnCastExpression(IType castType, ICSharpExpression expression, CallSiteContext context, ICSharpTreeNode typeUsageContext);
    [NotNullAttribute]
private ITreeNode ReplaceOutParameterWithDeclarationExpressionArgument(IParameter parameter, IReferenceExpression expression, IDeclarationExpression declarationExpression, ISingleVariableDesignation singleVariableDesignation);
    [CompilerGeneratedAttribute]
private ITreeNode <AddActionReplaceParameterWithArgumentExpression>g__ReplaceExpressionWithInlinedCast|11_0(ICSharpExpression castedArgument, <>c__DisplayClass11_0& );
    [CompilerGeneratedAttribute]
private bool <ReplaceOutParameterWithDeclarationExpressionArgument>g__PreferVarForDeclarationExpression|18_0(IType assignmentSourceType, IType& explicitType, <>c__DisplayClass18_0& );
}
public class JetBrains.ReSharper.Refactorings.CSharp.Inline.CodeTransformers.CSharpInlinedPropertyCodeTransformer : InlinedPropertyCodeTransformerBase`1<IReferenceExpression> {
    public CSharpInlinedPropertyCodeTransformer(ITreeNode expression, InlinedParameterCallSiteInfo inlinedCallInfo, CallSiteContext context);
    protected virtual void TransformElement(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Inline.CodeTransformers.CSharpInlinedTypeOwnerInitializerTransformer : InlinedTypeOwnerInitializerTransformerBase`1<IReferenceExpression> {
    private CSharpElementFactory myFactory;
    public CSharpInlinedTypeOwnerInitializerTransformer(ITreeNode expression, InlineTypeOwnerInitializerCallInfo inlinedCallInfo, CallSiteContext context);
    protected virtual void TransformElement(ITreeNode element);
    protected ITreeNode AddActionReplaceExpressionWithTemp(IExpression expression, IDeclaredElement newTempName);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Inline.CodeTransformers.CSharpInlineMethodCodeTransformer : InlineMethodCodeTransformerBase`2<IReferenceExpression, IReturnStatement> {
    private IRefactoringDriver myRefactoringDriver;
    private CSharpElementFactory myFactory;
    public CSharpInlineMethodCodeTransformer(IRefactoringDriver refactoringDriver, ITreeNode expression, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context);
    protected virtual void TransformElement(ITreeNode element);
    private ITreeNode TransformUsingDeclaration(IDeclarationStatement declarationStatement, UsingDeclarationKind usingDeclarationKind);
    [NotNullAttribute]
private HashSet`1<ILocalFunction> CollectLocalFunctionsToMoveToOuterScope(IStatementsOwner statementsOwner, ICSharpStatementsRange statementsRangeToEnblock);
    protected virtual ITreeNode AddActionReplaceReturnWithAssignmentToTemp(IReturnStatement returnStatement);
    protected virtual ITreeNode AddActionRemoveReturn(IReturnStatement returnStatement);
    protected virtual ITreeNode ReplaceReturnWithAssignment(IReturnStatement returnStatement);
    protected virtual bool IsSetterParameter(IParameter parameter);
    protected virtual ITreeNode FixReturnReferenceKindForCallSite(IReturnStatement returnStatement);
    protected virtual ITreeNode AddActionReplaceExpressionWithAssignedExpression(IReferenceExpression expression);
    protected virtual ITreeNode ReplaceByQualifier(IReferenceExpression expression, InlineMethodCallInfo info);
    private void AddSwitchBreakIfRequired(IReturnStatement returnStatement);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Inline.CodeTransformers.CSharpIntroduceParameterCodeTransformer : IntroduceParameterCodeTransformerBase`1<IReferenceExpression> {
    public CSharpIntroduceParameterCodeTransformer(ITreeNode expression, IntroduceParameterInlineCallInfo inlinedCallInfo, CallSiteContext context);
    protected virtual void TransformElement(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Inline.CSharpInlineHelper : InlineHelper {
    public CSharpInlineHelper(IRefactoringDriver driver);
    public virtual bool CanReplaceUsageWithDeclaration(IParameter parameter, IDictionary`2<ArgumentFromParameter, InlinedArgumentInfo> argument2Info);
    private static bool CanReplaceExpressionWithDeclaration(ICSharpExpression expression, IDictionary`2<ArgumentFromParameter, InlinedArgumentInfo> argument2Info);
    public virtual bool CanIntroduceVariables(IExpression expression);
    public virtual bool CanHaveSideEffects(IExpression expression);
    public virtual void ReplaceTypeParameter(IReference reference, ITypeParameter parameter, ISubstitution substitution);
    public virtual IExpression GetQualifierExpression(IReference reference);
    public virtual IExpression GetConditionalAccessQualifier(IReference reference);
    public virtual Dictionary`2<ArgumentFromParameter, InlinedArgumentInfo> GetArgument2Infos(IReference reference, Dictionary`2<IParameter, ArgumentFromParameter> parameter2argument, Dictionary`2<int, IParameter> inlinedMethodParameterInfos);
    public virtual bool CanHaveSideEffects(IArgument argument);
    public virtual bool CanIntroduceRefTempVariable(IParameter parameter, IExpression expression);
    public virtual bool ContainsRefAssignmentDestinations(IReadOnlyList`1<IExpression> expressions);
    public virtual Dictionary`2<IParameter, ArgumentFromParameter> GetParameter2Argument(IReference reference, IParametersOwner parametersOwner);
    public virtual IDeclaredElement SplitDeclarationAndInitializer(IDeclaredElement declaredElement);
    public virtual IDeclaredElement InsertReturnValueTempVariable(InlineMethodCallInfo inlineMethodCallInfo, IType returnType, IReference reference, CallSiteContext context);
    public virtual IDeclaredElement InsertTempVariableForAssignedValue(IExpression assignedExpression, IReference reference, CallSiteContext context, ReferenceIdentitySaver referenceIdentitySaver);
    public virtual IDeclaredElement InsertTempForQualifier(IExpression qualifierExpression, IReference reference, CallSiteContext context, ReferenceIdentitySaver saver, ReferenceKind referenceKind);
    public virtual IDeclaredElement InsertTempForArgument(IParameter parameter, InlinedArgumentInfo argumentInfo, IReference reference, CallSiteContext context, ReferenceIdentitySaver saver, ArgumentFromParameter argumentFromParameter);
    [CanBeNullAttribute]
public static IStatementsOwner EnBlock(IReference reference, ICSharpStatement& tag, ReferenceIdentitySaver referenceIdentitySaver);
    public virtual IArgumentsOwner GetArgumentOwner(IReference& reference, bool replaceMethodGroup);
    [CanBeNullAttribute]
public static IArgumentsOwner GetArgumentOwnerOfReference(IReference reference);
    [NotNullAttribute]
private static IDeclarationStatement CreateVariableDeclarationStatement(CallSiteContext callSiteContext, ICSharpExpression newExpression, ICSharpTreeNode contextNode, string suggestName, IExpressionType expressionType, ReferenceKind referenceKind);
    public virtual void RemoveCastFromElement(ITreeNode element);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.CSharp.Inline.CSharpInlineHelper/<AllNotQualifiableReferences>d__23")]
public virtual IEnumerable`1<IReference> AllNotQualifiableReferences(IReference reference);
    public virtual ITreeNode GetContainingStatement(ITreeNode element);
    public virtual ITreeNode GetContainingFunctionLikeElement(ITreeNode treeNode);
    public virtual bool ShouldIntroduceVariableForExpression(IExpression expression, ITreeNode body, IDeclaredElement inlinedBodyOwner, IReadOnlyList`1<IExpression> references);
    public virtual bool IsUsingVariable(IReference reference, String& message);
    private static bool ReorderedExpressionsArePure(ICSharpTreeNode methodBody, ICSharpExpression singleAccessExpression);
    private static bool IsAccessFromClosure(IDeclaredElement inlinedBodyOwner, ICSharpExpression accessExpression);
    [CompilerGeneratedAttribute]
internal static bool <CanReplaceExpressionWithDeclaration>g__ShouldReplaceAllComponentsWithDeclarations|2_0(ITupleExpression tupleExpression, <>c__DisplayClass2_0& );
}
public class JetBrains.ReSharper.Refactorings.CSharp.Inline.CSharpInlineMethod : InlineMethod {
    private InlineHelper myInlineHelper;
    private InlineMethodDataModel myDataModel;
    public InlineHelper InlineHelper { get; }
    public CSharpInlineMethod(InlineMethodWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineHelper get_InlineHelper();
    public virtual ITreeNode GetBody(IDeclaredElement element);
    public virtual ITreeNode GetContainingStatement(ITreeNode element);
    public virtual void ReplaceMethodGroup(IReference reference, CallSiteContext context, InlineMethodCallInfo inlinedCallInfo);
    public virtual ITreeNode GetContextForNaming(IReference reference);
    public virtual IList`1<IReference> TransformReference(IReference reference);
    public virtual bool GetIsPropertyInitializer(IReference reference);
    public virtual bool IsReturnStatementOnly(IDeclaredElement element, IExpression& returnedExpression, ITreeNode& blockOfStatements);
    public virtual bool CanIntroduceStatementsBefore(IReference reference);
    public virtual bool IsFromExpressionBody(IReference reference);
    public virtual bool ReplaceCall(IReference reference, ITreeNode returnedExpression, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context);
    [CanBeNullAttribute]
private ICSharpExpression FindExpressionToReplace(IReference reference, InlineMethodCallInfo inlinedCallInfo);
    public virtual bool HasTopLevelUsingDeclarations(ITreeNode body);
    private bool ReplaceCallWithThrowExpression(IReference reference, ICSharpExpression expressionToReplace, IThrowExpression throwExpression, CallSiteContext context);
    private static void RemoveOriginalExpression(ICSharpExpression expressionToReplace);
    private static ICSharpStatement CreateVariableDeclarationStatement(ICSharpExpression newExpression, ITreeNode contextNode, String& name, string suggestName, IType variableType);
    public virtual bool ReplaceStatement(IReference& reference, ITreeNode container, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context, bool replaceOriginal);
    public virtual void ReplaceConditionalAccess(IReference& reference, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context);
    public virtual bool IsReturned(IReference reference, InlinedElementKinds inlinedElementKind);
    public virtual bool IsLastStatement(IReference reference);
    public virtual bool IsLastStatementInScope(IReference reference);
    public virtual AssignmentInfo FindContainingAssignment(InlinedElementKinds inlinedElementKind, IReference reference);
    [CanBeNullAttribute]
private static ICSharpExpression GetUsageExpression(InlinedElementKinds inlinedElementKind, IReference reference);
    public virtual IReadOnlyList`1<IExpression> GetExpressionsReferencingThis(ITreeNode methodBody);
    public virtual bool AllReturnsAreLast(IDeclaredElement element);
    public virtual bool GetIsDestinationOfAssignment(IReference reference, IExpression& assignmentSource);
    public virtual bool GetUsedAsDelegate(InlinedMethodInfo info, IReference reference);
    public virtual bool IsPartOfConditionalAccessChain(IReference reference);
    public virtual bool Ignore(IReference reference);
    public virtual void ConvertExpressionToStatement(IReference& reference);
    public virtual bool IsCollectionInitializer(IReference reference);
    public virtual bool IsDeconstruction(IReference reference);
    public virtual bool CanInlineAsExpression(IReference reference, InlineMethodCallInfo inlinedCallInfo);
    private bool ExpressionIsInTryFinallyBlock(ITreeNode treeNode);
    public virtual IType FindRealReturnType(IParametersOwner parametersOwner, ITreeNode context);
    public virtual bool FindIsAsync(IParametersOwner parametersOwner);
    public virtual InlinedReferenceContext InspectReferenceContext(ITreeNode treeNode);
    public virtual bool EnsureContextRequirements(IReference reference, InlineMethodCallInfo inlinedCallInfo);
    [CanBeNullAttribute]
private ITreeNode PatchElement(ITreeNode element, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context, ITreeNode namingContext);
    private static bool IsReturnStatementOnlyInternal(ITreeNode body, IExpression& returnedExpression, ITreeNode& blockOfStatements);
    [CompilerGeneratedAttribute]
internal static bool <ReplaceCall>g__IsVoidLambdaExpressionBody|14_0(ICSharpExpression cSharpExpression);
    [CompilerGeneratedAttribute]
internal static bool <ReplaceCall>g__IsVoidReturnExpressionBody|14_1(ICSharpExpression cSharpExpression);
    [CompilerGeneratedAttribute]
internal static bool <FindExpressionToReplace>g__IsAnyTaskType|15_0(ITypeElement typeElement);
    [CompilerGeneratedAttribute]
internal static IReference <ReplaceConditionalAccess>g__FindReference|21_0(ICSharpExpression expression);
    [CompilerGeneratedAttribute]
internal static bool <EnsureContextRequirements>g__InlinedCodeHasAwaitExpressions|41_0(<>c__DisplayClass41_0& );
}
public static class JetBrains.ReSharper.Refactorings.CSharp.Inline.CSharpInlineMethodUtil : object {
    [CanBeNullAttribute]
public static IReference ConvertMethodGroup(IReference reference, IRefactoringDriver driver, IList`1<IParameter> parameters);
}
public static class JetBrains.ReSharper.Refactorings.CSharp.Inline.ReturnProblemAnalyser : object {
    public static void EnsureAllReturnStatementsAreLast(ICSharpStatement statement);
    public static bool AllReturnStatementsAreLast(IBlock block);
    private static ReturnAnalysisResult InspectStatement(ICSharpStatement statement);
    private static ReturnAnalysisResult InspectStatementsCollection(TreeNodeCollection`1<ICSharpStatement> statements);
    private static bool IsSwitchStatementWithoutDefaultCase(ICSharpStatement cSharpStatement);
    [CanBeNullAttribute]
private static IIfStatement FindIfStatementWithoutElse(ICSharpStatement rootStatement);
    private static bool HasGotoCaseStatements(ISwitchStatement switchStatement);
    private static bool HasBreakStatements(ICSharpStatement statement);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Inline.ThisReferencesFinder : object {
    [NotNullAttribute]
[ItemNotNullAttribute]
private List`1<ICSharpExpression> myReferences;
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<ICSharpExpression> References { get; }
    public int ReferencesCount { get; }
    public bool HasOneReference { get; }
    public bool HasReferences { get; }
    public bool ProcessingIsFinished { get; }
    public ThisReferencesFinder(ITreeNode element);
    public IReadOnlyList`1<ICSharpExpression> get_References();
    public int get_ReferencesCount();
    public bool get_HasOneReference();
    public bool get_HasReferences();
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
    [CompilerGeneratedAttribute]
internal static bool <ProcessBeforeInterior>g__IsInstanceMemberReference|13_0(IReferenceExpression referenceExpression);
}
public class JetBrains.ReSharper.Refactorings.CSharp.InlineClass.CsInlineClassAnalyzer : InlineClassAnalyzer {
    public CsInlineClassAnalyzer(InlineClassWorkflow inlineClassWorkflow, ITypeOwner element, ITypeElement owner);
    protected virtual void InitializeMembers(ITypeOwner element, ITypeElement owner);
    protected virtual void AddMemberInfo(ITypeMember member);
    protected virtual void FillTargetTypeElements();
    public virtual void Analyze();
    private IDeclaredElement GetDelegationMethod(ITypeMember member);
    private IDeclaredElement GetMethod(IMethodDeclaration methodDeclaration);
    protected ITypeMember GetBackingElement(IPropertyDeclaration propertyDeclaration);
    private IDeclaredElement GetProperty(ITypeMember member);
    private IDeclaredElement GetBackingProperty(ITypeMember member);
    private void AnalyzeUsages(MemberInfo memberInfo);
    [CompilerGeneratedAttribute]
private bool <AnalyzeUsages>b__10_0(IReference reference);
}
public class JetBrains.ReSharper.Refactorings.CSharp.InlineClass.CsInlineClassHelper : InlineClassHelper {
    public virtual InlineClassAnalyzer GetAnalyzer(InlineClassWorkflow inlineClassWorkflow, ITypeOwner element, ITypeElement owner);
}
public class JetBrains.ReSharper.Refactorings.CSharp.InlineClass.CsInlineClassRefactoringExec : object {
    [CompilerGeneratedAttribute]
private InlineClassWorkflow <Workflow>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <PsiModule>k__BackingField;
    [CompilerGeneratedAttribute]
private ResolveImagesRepository <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private IRefactoringDriver <RefactoringDriver>k__BackingField;
    public InlineClassWorkflow Workflow { get; public set; }
    public IPsiModule PsiModule { get; public set; }
    public ResolveImagesRepository Repository { get; }
    public IRefactoringDriver RefactoringDriver { get; public set; }
    public CsInlineClassRefactoringExec(InlineClassWorkflow workflow);
    [CompilerGeneratedAttribute]
public InlineClassWorkflow get_Workflow();
    [CompilerGeneratedAttribute]
public void set_Workflow(InlineClassWorkflow value);
    [CompilerGeneratedAttribute]
public IPsiModule get_PsiModule();
    [CompilerGeneratedAttribute]
public void set_PsiModule(IPsiModule value);
    [CompilerGeneratedAttribute]
public ResolveImagesRepository get_Repository();
    [CompilerGeneratedAttribute]
public IRefactoringDriver get_RefactoringDriver();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RefactoringDriver(IRefactoringDriver value);
    public sealed virtual void CutAndPaste(IProgressIndicator subPi);
    public sealed virtual void Rebind(IProgressIndicator subPi);
    public void ProceedConstructor(Dictionary`2<IParameterDeclaration, IArgument> parameters2Arguments, IConstructorDeclaration ctor);
    private void RemoveUnusedElements();
    private IClassMemberDeclaration GetClassMemberDeclaration(ITypeOwner declaredElement);
    private void RebindTargetElementMemberUsages();
    private void ProceedTargetObjectCreation(IAssignmentExpression containingAssignmentExpression);
    private void RebindSourceClassReferencesInsideTargetClass();
    private void RebindTargetMembersEverywhere();
    private void RebindTargetMembersInsideSourceClass();
    private void ProceedDelegation(MemberInfo member);
}
public class JetBrains.ReSharper.Refactorings.CSharp.InlineField.CSharpInlineField : InlineFieldBase {
    [CanBeNullAttribute]
private InlineHelper myInlineHelper;
    [NotNullAttribute]
public InlineHelper InlineHelper { get; }
    public CSharpInlineField(InlineFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineHelper get_InlineHelper();
    public static bool IsInitializationOfField(IReference reference, IField field, IExpression& initializer);
    public virtual IExpression GetInitializerExpression(IReference reference);
    public virtual IExpression GetInitializerExpression(IField field);
    public virtual bool GetCanUseRefOut(IExpression expression);
    public virtual bool CanInlineReference(IReference reference);
    public virtual bool HasSideEffects(IExpression expression);
    public virtual string InsertTempVariable(ITreeNode tag, string name, IExpression expression);
    public virtual void ReplaceExpression(IReference reference, string localName);
    public virtual bool ThisIsUsed(IExpression expression);
    public virtual bool Ignore(IReference reference);
    public virtual void ProcessReferenceWithContext(IReference reference, CallSiteContext context, InlineTypeOwnerInitializerCallInfo info);
    public virtual void RemoveAssignment(IReference reference);
    public virtual void RemoveField(IDeclaration declaration);
}
public class JetBrains.ReSharper.Refactorings.CSharp.InlineField.CSharpInlineFieldInspectionContextFactory : object {
    public InlineFieldInspectionContext InitialContext { get; }
    public sealed virtual InlineFieldInspectionContext get_InitialContext();
    public sealed virtual InlineFieldInspectionContext CloneContext(InlineFieldInspectionContext context);
    public sealed virtual InlineFieldInspectionContext Merge(IList`1<InlineFieldInspectionContext> contexts);
}
public class JetBrains.ReSharper.Refactorings.CSharp.InlineField.CSharpInlineFieldInspector : RDInspectorOfVariable`1<InlineFieldInspectionContext> {
    private InlineFieldRefactoring myExecuter;
    public CSharpInlineFieldInspector(ControlFlowGraph controlFlowGraph, InlineFieldRefactoring executer);
    protected virtual bool CustomInspection(IControlFlowElement controlFlowElement, InlineFieldInspectionContext context, ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.CSharp.InlineParameter.CSharpInlineParameter : InlineParameterBase {
    private InlineHelper myInlineHelper;
    public InlineHelper InlineHelper { get; }
    public CSharpInlineParameter(InlineParameterWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineHelper get_InlineHelper();
    public virtual void ReplaceDeclarations(IParametersOwner parametersOwner);
    public virtual IExpression ReplaceWithThis(IExpression expression);
    public virtual void RemoveArguments(IArgumentsOwner owner, List`1<IArgument> arguments);
    public virtual void ReplaceBody(CallSiteContext context, InlinedParameterCallSiteInfo info, IParametersOwner owner, ITreeNode body, InlineParameterEngine engine);
    private static void ReplaceDeclarations(IEnumerable`1<IDeclaration> declarations);
    public virtual IParametersOwnerDeclaration CreateNewDeclaration(IParametersOwner owner);
    public virtual IParameter AddParameter(IDeclaration declaration, IParameter parameter);
    public virtual IArgumentsOwner CreateArgumentsOwner(IParametersOwner parametersOwner);
    protected virtual IArgumentsOwner CreateCallToMethod(IMethod method);
    protected virtual IArgumentsOwner CreateCallToConstructor(IConstructor constructor);
    [NotNullAttribute]
private static IArgumentsOwner CreateCallToLocalFunction(IParametersOwner parametersOwner);
    public virtual void AddArgumentFromParameter(IArgumentsOwner argumentsOwner, IParameter parameter, ParameterKind kind);
    public virtual IExpression ReplaceExpression(T expression, string name);
    public virtual void AddArgumentFromExpression(IArgumentsOwner argumentsOwner, IExpression expression);
    public virtual IParametersOwnerDeclaration AddDeclarationToFile(IParametersOwnerDeclaration newParametersOwnerDeclaration, IParametersOwner parametersOwner);
    public virtual IArgument CreateArgument(ITreeNode expression);
    public virtual void ReplaceArguments(IArgumentsOwner owner, List`1<IArgument> arguments);
    public virtual void AddArgument(IArgumentsOwner owner, IArgument copy);
    [NotNullAttribute]
private static IParametersOwnerDeclaration AddLocalFunctionDeclaration(IParametersOwner parametersOwner, ILocalFunctionDeclaration newLocalFunctionDeclaration);
}
public class JetBrains.ReSharper.Refactorings.CSharp.InlineParameter.CSharpInlineParameterHelper : InlineParameterHelper {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual IParametersOwner GetCalledMember(IArgumentsOwner owner);
    public virtual IExpression GetQualifier(IArgumentsOwner owner, Boolean& hasThisQualifier);
    public virtual ITreeNode GetContextOfParameterOwner(IParametersOwner owner);
    public virtual IExpression GetArgumentValue(IArgument argument);
    public virtual IReference GetReference(IArgumentsOwner argumentsOwner);
    public virtual ITreeNode ReplaceThisReferences(ITreeNode element, IDeclaredType type, ReferenceIdentitySaver saver, Key`1<string> key, Boolean& hasUnresolvedThis, bool hasThisQualifier);
    public virtual IExpression CreateThisExpression(IPsiModule project);
    public virtual IExpression GetInvocation(ITreeNode element);
    public virtual ITreeNode Qualify(ITreeNode element, string name, IEnumerable`1<ParameterOwnerUsageUpdater> updaters, SuggestedParameterNode thisSuggestion);
    private static bool MatchQualifier(IExpression expression, Action`1<IExpression> update);
    public virtual bool IsThisExpression(IArgument argument);
    public virtual IArgumentsOwner CopyArgumentsOwner(IArgumentsOwner owner);
    public virtual bool IsAnonymousMethod(IParametersOwner parametersOwner);
}
public class JetBrains.ReSharper.Refactorings.CSharp.InlineVar.CSharpInlineVar : InlineVarBase {
    private InlineHelper myInlineHelper;
    public InlineHelper InlineHelper { get; }
    public CSharpInlineVar(InlineVarWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineHelper get_InlineHelper();
    public virtual bool Ignore(IReference reference);
    public virtual void ProcessReferenceWithContext(IReference reference, CallSiteContext context, InlineTypeOwnerInitializerCallInfo info);
    public virtual void RemoveVariableDeclaration(IDeclaration declaration);
    public virtual void RemoveAssignment(ITreeNode expression);
}
public class JetBrains.ReSharper.Refactorings.CSharp.InlineVar.CSharpInlineVarAnalyser : InlineVarAnalyserBase {
    private List`1<IReference> myReferences;
    [CompilerGeneratedAttribute]
private bool <InlineAll>k__BackingField;
    private IExpression myExpression;
    private IAssignmentExpression myAssignmentExpression;
    private IVariableInitializer myInitialiler;
    private IExpression myExpressionInitializer;
    public bool InlineAll { get; public set; }
    public List`1<IReference> References { get; }
    public ITreeNode Expression { get; }
    public ITreeNode AssignmentExpression { get; }
    public CSharpInlineVarAnalyser(InlineVarWorkflow workflow);
    [CompilerGeneratedAttribute]
public virtual bool get_InlineAll();
    [CompilerGeneratedAttribute]
public virtual void set_InlineAll(bool value);
    public virtual List`1<IReference> get_References();
    public virtual ITreeNode get_Expression();
    public virtual ITreeNode get_AssignmentExpression();
    public virtual Pair`2<bool, string> Run(IDeclaredElement variable, ITreeNode element, IList`1<IReference> references);
}
public class JetBrains.ReSharper.Refactorings.CSharp.InlineVar.CSharpInlineVarContextFactory : object {
    public InlineVarContext InitialContext { get; }
    public sealed virtual InlineVarContext get_InitialContext();
    public sealed virtual InlineVarContext CloneContext(InlineVarContext context);
    public sealed virtual InlineVarContext Merge(IList`1<InlineVarContext> contexts);
}
public class JetBrains.ReSharper.Refactorings.CSharp.InlineVar.CSharpInlineVarInspector : RDInspectorOfVariable`1<InlineVarContext> {
    private IAssignmentExpression myAssignmentExpression;
    public CSharpInlineVarInspector(ControlFlowGraph controlFlowGraph, IAssignmentExpression assignmentExpression, ITypeOwner variable);
    protected virtual bool CustomInspection(IControlFlowElement controlFlowElement, InlineVarContext context, ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.CSharp.InplaceRefactorings.ChangeNullabilityInfo : object {
    [CompilerGeneratedAttribute]
private ITypeOwnerDeclaration <Declaration>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypePointer <OldTypePointer>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypePointer <NewTypePointer>k__BackingField;
    [NotNullAttribute]
public ITypeOwnerDeclaration Declaration { get; }
    [NotNullAttribute]
public ITypePointer OldTypePointer { get; }
    [NotNullAttribute]
public ITypePointer NewTypePointer { get; }
    private DocumentRange JetBrains.ReSharper.InplaceRefactorings.IRefactoringInfo.AvailableInRange { get; }
    public string ContextActionTitle { get; }
    public ChangeNullabilityInfo(ITypeOwnerDeclaration declaration, ITypePointer oldTypePointer, ITypePointer newTypePointer);
    [CompilerGeneratedAttribute]
public ITypeOwnerDeclaration get_Declaration();
    [CompilerGeneratedAttribute]
public ITypePointer get_OldTypePointer();
    [CompilerGeneratedAttribute]
public ITypePointer get_NewTypePointer();
    private sealed virtual override DocumentRange JetBrains.ReSharper.InplaceRefactorings.IRefactoringInfo.get_AvailableInRange();
    public sealed virtual IRefactoringWorkflow CreateRefactoringWorkflow();
    public sealed virtual string get_ContextActionTitle();
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.InplaceRefactorings.CSharpExtensionMethodOnPasteProvider : ExtensionMethodImportOnPasteProviderBase {
    protected virtual bool IsYourReference(IReference reference);
    protected virtual ExtensionMethodReferenceData CreateReferenceData(string referenceName, IMethod targetExtensionMethod);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[DerivedComponentsInstantiationRequirementAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CSharp.InplaceRefactorings.CSharpInplaceChangeSignatureHelper : object {
    public IVisualizationModelLanguageHelper VisualizationModelLanguageHelper { get; }
    public virtual TreeTextRange GetSignatureRange(IDeclaration declaration);
    public sealed virtual TreeTextRange GetParameterListRange(IDeclaration declaration);
    public sealed virtual bool IsValidConstructorName(ITypeMemberDeclaration constructorDeclaration, ITypeElement containingType);
    public sealed virtual string IsValidParametersOwner(IDeclaration initialDeclaration, string text);
    public IVisualizationModelLanguageHelper get_VisualizationModelLanguageHelper();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.CSharp.InplaceRefactorings.CSharpInplaceChangeTypeHelper : object {
    public sealed virtual ITypeOwnerDeclaration GetDeclarationByChangedNode(ITreeNode changedNode, Nullable`1<TreeTextRange> changedRange);
    public sealed virtual TreeTextRange GetTypeRange(ITypeOwnerDeclaration declaration);
    public sealed virtual IRefactoringInfo TryCreateChangeTypeInfo(ITypeOwnerDeclaration declaration, IReadOnlyList`1<TypeEditPoint> typeEditPoints);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Refactorings.CSharp.InplaceRefactorings.CSharpInplaceMoveStaticMembersHelper : object {
    public sealed virtual ITypeMemberDeclaration AddMemberDeclaration(ITypeDeclaration typeDeclaration, ITypeMemberDeclaration memberDeclaration);
    public sealed virtual ITypeMemberDeclaration ReplaceMemberDeclaration(ITypeMemberDeclaration oldDeclaration, ITypeMemberDeclaration newDeclaration);
    public sealed virtual void DeleteMemberDeclaration(ITypeMemberDeclaration memberDeclaration);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Refactorings.CSharp.InplaceRefactorings.CSharpInplaceRefactoringsLanguageSpecifics : object {
    public IVisualizationModelLanguageHelper VisualizationModelLanguageHelper { get; }
    public sealed virtual IEnumerable`1<DocumentRange> UsingListRanges(IFile file);
    public sealed virtual IVisualizationModelLanguageHelper get_VisualizationModelLanguageHelper();
    public sealed virtual SignatureKind GetSignatureKind(IDeclaration declaration);
    public sealed virtual bool IsInplaceRenameAvailable(IDeclaredElement declaredElement);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.InplaceRefactorings.CSharpVisualizationModelLanguageHelper : object {
    public static CSharpVisualizationModelLanguageHelper Instance;
    public bool ParameterTypeBeforeName { get; }
    public string ParameterTypeAndNameSeparator { get; }
    public bool ReturnTypeFirst { get; }
    public string ReturnTypeSeparator { get; }
    public bool SkipVoidReturnType { get; }
    public bool SkipEmptyParameterList { get; }
    private static CSharpVisualizationModelLanguageHelper();
    public sealed virtual string StartKeyword(SignatureData signature);
    public sealed virtual bool get_ParameterTypeBeforeName();
    public sealed virtual string get_ParameterTypeAndNameSeparator();
    public sealed virtual string ParameterModifierText(ParameterKind kind, bool isParams, bool isVarArg, bool isThis);
    public sealed virtual bool get_ReturnTypeFirst();
    public sealed virtual string get_ReturnTypeSeparator();
    public sealed virtual bool get_SkipVoidReturnType();
    public sealed virtual bool get_SkipEmptyParameterList();
}
public class JetBrains.ReSharper.Refactorings.CSharp.InplaceRefactorings.InplaceChangeNullabilityWorkflow : ChangeNullabilityWorkflow {
    [NotNullAttribute]
private SmartDeclarationPointer`1<ITypeOwnerDeclaration> myDeclarationPointer;
    [NotNullAttribute]
private ITypePointer myOldTypePointer;
    [NotNullAttribute]
private ITypePointer myNewTypePointer;
    public string Title { get; }
    public InplaceChangeNullabilityWorkflow(ChangeNullabilityInfo changeNullabilityInfo);
    public virtual string get_Title();
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool Initialize(IDataContext context);
    public virtual bool PreExecute(IProgressIndicator pi);
    private bool RestoreOldType();
    public virtual IChangeNode`1<ChangeNullabilityContext> GetInitialChangeNode();
    public virtual bool PostExecute(IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.CSharp.IntroduceField.CSharpIntroduceFieldAnalyser : IntroduceFieldAnalyser {
    public virtual ITreeNode GetInitializer(ILocalVariable variable);
    public virtual bool CanBeConstant(ILocalVariable variable);
    public virtual bool IsFromConstructor(ILocalVariable variable, bool isStatic);
    public virtual bool IsFromConstructor(ITreeNode element, bool isStatic);
    public virtual ITreeNode GetBody(IDeclaration declaration);
    public virtual bool CanInitializeInlineFromPrimaryConstructor(IParameter parameter);
    public virtual bool HasInstanceConstructorsThatCantHaveBodies(ITypeElement typeElement);
    [CanBeNullAttribute]
public static ITreeNode GetBodyOfDeclaration(IDeclaration decl);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CSharp.IntroducePartOfString.IntroducePartOfStringRefactoring : IntroduceLocalRefactoring {
    private IntroducePartOfStringWorkflow Workflow { get; }
    protected string CanNotPerformActionText { get; }
    public IntroducePartOfStringRefactoring(IntroduceLocalWorkflowBase workflow, ISolution solution, IRefactoringDriver driver);
    private IntroducePartOfStringWorkflow get_Workflow();
    [NullableContextAttribute("2")]
protected virtual IntroduceVariableResult Execute();
    private static ICSharpExpression TransformExistingFormattingMethodCall(StringExpressionTokenSlice`1<ICSharpLiteralExpression> slice, IInvocationExpression formatMethodCall, ICSharpArgument argument, CSharpElementFactory factory);
    private static Nullable`1<ValueTuple`2<IInvocationExpression, ICSharpArgument>> TryGetExistingFormattingMethodCall(ICSharpLiteralExpression literalExpression);
    private static bool IsFormattingMethodCall(IMethod method, IList`1<ICSharpArgument> arguments, ICSharpArgument argument);
    protected virtual string get_CanNotPerformActionText();
    [CompilerGeneratedAttribute]
internal static ICSharpLiteralExpression <TransformExistingFormattingMethodCall>g__Replace|4_0(ICSharpLiteralExpression literalExpression, string oldValue, string newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CSharp.IntroducePartOfString.IntroducePartOfStringWorkflow : IntroduceLocalWorkflowBase {
    [CompilerGeneratedAttribute]
private TreeTextRange <SelectionTreeRange>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ICSharpExpression <OwnerExpression>k__BackingField;
    public TreeTextRange SelectionTreeRange { get; private set; }
    [NullableAttribute("2")]
public ICSharpExpression OwnerExpression { get; private set; }
    public string Title { get; }
    public IntroducePartOfStringWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public TreeTextRange get_SelectionTreeRange();
    [CompilerGeneratedAttribute]
private void set_SelectionTreeRange(TreeTextRange value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ICSharpExpression get_OwnerExpression();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_OwnerExpression(ICSharpExpression value);
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool Initialize(IDataContext context);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual string get_Title();
    private bool CanIntroducePartOfString(IStringLiteralOwner literalOwner);
}
[RefactoringWorkflowProviderAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.IntroducePartOfString.IntroducePartOfStringWorkflowProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.CSharp.IntroduceVariable.CSharpIntroduceVariable : IntroduceVariableBase {
    public CSharpIntroduceVariable(IntroduceLocalWorkflowBase workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IntroduceVariableResult Process(IntroduceVariableData introduceVariableData);
}
public class JetBrains.ReSharper.Refactorings.CSharp.IntroduceVariable.IntroduceSubqueryRefactoring : IntroduceLocalRefactoring {
    private IntroduceSubqueryWorkflow Workflow { get; }
    protected string CanNotPerformActionText { get; }
    public IntroduceSubqueryRefactoring(IntroduceSubqueryWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    private IntroduceSubqueryWorkflow get_Workflow();
    protected virtual IntroduceVariableResult Execute();
    public IntroduceVariableResult TransformSubQuery(SubQuerySelection selection);
    private static JetHashSet`1<IDeclaredElement> CollectAndMarkUsedVariables(SubQuerySelection selection, DisposableMarker qulifyExpressionMarker);
    private static IQueryClausesHolder FindLastHoler(IQueryExpression expression);
    private static void RemoveTail(IQueryExpression expression, ICSharpTreeNode clause, IQueryClause firstClause);
    private static IQueryContinuation RemoveHead1(IQueryExpression expression, IQueryClause firstClause);
    private static void RemoveHead(IQueryExpression expression, ICSharpTreeNode lastClause, bool isOpen, IQueryClause firstClause);
    private static void FixContinuation(IQueryContinuation continuation);
    protected virtual string get_CanNotPerformActionText();
}
public class JetBrains.ReSharper.Refactorings.CSharp.IntroduceVariable.IntroduceSubqueryWorkflow : IntroduceLocalWorkflowBase {
    [CompilerGeneratedAttribute]
private SubQuerySelection <SubQuerySelection>k__BackingField;
    public SubQuerySelection SubQuerySelection { get; private set; }
    public string Title { get; }
    public IntroduceSubqueryWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public SubQuerySelection get_SubQuerySelection();
    [CompilerGeneratedAttribute]
private void set_SubQuerySelection(SubQuerySelection value);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool Initialize(IDataContext context);
    [CanBeNullAttribute]
private ITreeNode GetContainingLambda(SubQuerySelection selection);
    private static bool Contains(SubQuerySelection selection, ITreeNode element);
    public virtual bool IsAvailable(IDataContext context);
    public virtual string get_Title();
    private static bool CanIntroduceSubQuery(SubQuerySelection selection);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.CSharp.IntroduceVariable.IntroduceSubqueryWorkflowProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
[PostfixTemplateAttribute("var", "Introduces variable for expression", "var x = expr;")]
public class JetBrains.ReSharper.Refactorings.CSharp.IntroduceVariable.IntroduceVariableTemplate : CSharpPostfixTemplate {
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    private static PostfixTemplateInfo Create(CSharpPostfixExpressionContext bestContext, bool availableInPreciseMode);
    private static bool IsConstructorInvocation(ICSharpExpression expression);
    private static bool IsItMattersToShowVar(CSharpPostfixExpressionContext context);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
    private static void ExecuteRefactoring(ITextControl textControl, ICSharpExpression expression, Action executeAfter);
}
public class JetBrains.ReSharper.Refactorings.CSharp.IntroduceVariable.SubQuerySelection : object {
    [CompilerGeneratedAttribute]
private IExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <LastSelectedClause>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <FirstSelectedClause>k__BackingField;
    public IExpression Expression { get; }
    public ITreeNode LastSelectedClause { get; }
    public ITreeNode FirstSelectedClause { get; }
    public SubQuerySelection(IExpression expression, ITreeNode clause, ITreeNode firstClause);
    [CompilerGeneratedAttribute]
public IExpression get_Expression();
    [CompilerGeneratedAttribute]
public ITreeNode get_LastSelectedClause();
    [CompilerGeneratedAttribute]
public ITreeNode get_FirstSelectedClause();
}
public class JetBrains.ReSharper.Refactorings.CSharp.IntroField.CSharpIntroduceField : IntroduceFieldBase {
    private IntroFieldData myWorkflowIntroFieldData;
    public CSharpIntroduceField(IntroduceFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IExpression GetInitializer(ILocalVariable variable);
    [NotNullAttribute]
public virtual IExpression CreateInitializer(ITypeOwner typeOwner, ITreeNode context);
    public virtual ITypeMember AddField(ITypeDeclaration typeDeclaration, IExpression initExpression, IList`1<ITreeNode> tags, object type);
    public virtual bool ReplaceVariableDeclaration(ILocalVariable variable, ITypeMember field, IExpression initializer);
    public virtual bool ReplaceUsages(IList`1<ITreeNode> expressions, ITypeMember field, ITreeNode initializer);
    public virtual void AddAssignment(IParameter parameter, ITypeMember member, IExpression expression);
}
public class JetBrains.ReSharper.Refactorings.CSharp.IntroParameter.CSharpIntroParameter : IntroduceParameterBase {
    private InlineHelper myInlineHelper;
    private IntroduceParameterDataModel myDataModel;
    public InlineHelper InlineHelper { get; }
    public CSharpIntroParameter(IntroduceParameterWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineHelper get_InlineHelper();
    public virtual bool ThisIsUsed(ITreeNode expression);
    public virtual void CallInline(IReference reference, CallSiteContext context, IntroduceParameterInlineCallInfo info, IList`1<string> lambdaParameterNames, int lastArgIndex);
    public virtual void FixOtherArguments(IReference reference, Dictionary`2<int, InlinedArgumentInfo> inlinedArgumentInfos);
    public virtual void RemoveArguments(IReference reference, IList`1<DeclaredElementNode> parametersToRemove);
    public virtual void AddParameter(IType type, string name, IDeclaration declaration, ISubstitution substitution, ITreeNode defaultValue);
    public virtual void ReplaceExpression(ITreeNode element);
    public virtual IReference AddBaseClause(IDeclaredElement element);
    public virtual void RemoveLocalVariable(ILocalVariable variable);
    private ICSharpExpression CreateNewParameterExpression(IPsiModule project);
    [CanBeNullAttribute]
private ICSharpParameterDeclaration CreateParameterDeclaration(CSharpElementFactory factory, IType type, string name, ICSharpParametersOwnerDeclaration ownerDeclaration, ISubstitution substitution, ITreeNode defaultValue);
}
public static class JetBrains.ReSharper.Refactorings.CSharp.IntroParameter.CSharpIntroParameterUtil : object {
    public static void CallInline(IReference reference, IntroduceParameterInlineCallInfo info, CallSiteContext context, ICollection`1<string> lambdaParameterNames, InlineHelper helper, int lastArgIndex, bool first, string parameterName);
    public static void FixOtherParameters(IReference reference, Dictionary`2<int, InlinedArgumentInfo> inlinedArgumentInfos);
    public static void RemoveArguments(IReference reference, IList`1<DeclaredElementNode> parametersToRemove);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.InvertBool.CsInvertBoolHelper : InvertBoolHelper {
    private static ICSharpExpression CreateLogicallyNegatedExpression(ICSharpExpression cSharpExpression);
    public virtual bool IsAvailable(IDeclaration declaration);
    public virtual void ProcessDeclaration(IDeclaration declaration, InvertBoolDataModel model);
    public virtual bool ProcessReference(IReference reference);
    private bool ProcessReadWriteReference(ITreeNode treeNode, IDeclaredElement element);
    private bool ProcessAssignmentExpression(IAssignmentExpression assignmentExpression, IDeclaredElement element);
    private bool ProcessReadReference(ITreeNode treeNode, IDeclaredElement element);
    private bool ProcessWriteReference(ITreeNode treeNode, IDeclaredElement declaredElement);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Refactorings.CSharp.MakeMethodNonStatic.CSharpMakeMethodNonStatic : object {
    public sealed virtual IDeclaredElement PatchDeclaration(IDeclaration declaration, int thisParameterIndex, bool createVar, ITypeElement newMethodOwner, IList`1<ITypeParameter> typeParams, IInterface interface, AccessRights accessRights, Dictionary`2<ITypeParameter, ITypeParameter> newToOldTypeParameters);
    public sealed virtual void RemoveDeclaration(IDeclaration methodDeclaration);
    public sealed virtual IDeclaration AddDeclaration(IDeclaration declaration, IDeclaration methodOwnerDeclaration, IRefactoringDriver driver);
    public sealed virtual bool Suitable(IDeclaration declaration);
    public sealed virtual void BindToThis(IReference reference);
    public sealed virtual void PatchRecursiveCall(ITreeNode referenceElement, int thisParameter, IRefactoringDriver driver);
    public sealed virtual void PatchMethodReference(IReference reference, ISubstitution substitution, Dictionary`2<ITypeParameter, ITypeParameter> newToOldTypeParametersMap, IList`1<ITypeParameter> methodTypeParams, IRefactoringDriver driver, int parameterIndex);
    private static void CheckConflicts(int thisParameterIndex, IReferenceExpression referenceExpression, IRefactoringDriver driver, IInvocationExpression invocationExpression);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Move.AdjustNamespaces.CSharpAdjustNamespaceHelper : AdjustNamespacesHelperBase {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual void FixFile(IFile file, string expectedNamespaceName, ResolveImagesRepository repository, List`1<IDeclaredElement> importedNamespaces);
    public virtual bool IsFromExtendsList(ITreeNode element);
    public virtual bool IsReferenceName(ITreeNode element);
    public virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public virtual IEnumerable`1<ITreeNode> GetUsingsFromFile(IFile file, IList`1<INamespace> namespaces);
    public virtual void RemoveUsing(ITreeNode element);
    public virtual IDeclaredElement GetImportedSymbolOfUsing(ITreeNode element);
    public virtual bool FileHasProblems(IFile file, string expectedNamespace);
    public virtual IReadOnlyList`1<ITypeDeclaration> GetTopLevelTypeDeclarations(IFile file);
    private static bool IsSuppressedCheckNamespace(ITreeNode node);
    private static bool HasDeclarationWithWrongNamespace(ICSharpTypeAndNamespaceHolderDeclaration holder, string expectedNamespace);
}
public static class JetBrains.ReSharper.Refactorings.CSharp.Move.Common.CSharpMoveUtil : object {
    public static ICSharpFile CopyFileAndFixNamespaces(ICSharpFile newFile, ICSharpFile oldFile, string expectedNamespaceName, IList`1<IDeclaredElement> importedNamespaces);
    private static void FixFileScopedNamespaces(ICSharpFile newFile);
    private static void CleanUsings(ICSharpTypeAndNamespaceHolderDeclaration holder);
    private static void AddUsings(ICSharpFile newFile, IList`1<IDeclaredElement> importedNamespaces, bool addImportsToDeepestScope);
    private static ICSharpTypeAndNamespaceHolderDeclaration StripNamespacesAndUsingsOff(ICSharpTypeAndNamespaceHolderDeclaration holder);
    private static void StripNamspaces(ICSharpTypeAndNamespaceHolderDeclaration holder, ICSharpNamespaceDeclaration declaration);
    public static IEnumerable`1<ITreeNode> GetUsingsFromFiles(IFile file, IList`1<INamespace> namespaces);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.CSharp.Move.Common.CSharpMoveUtil/<GetUsingsFromFile>d__7")]
private static IEnumerable`1<ITreeNode> GetUsingsFromFile(ICSharpTypeAndNamespaceHolderDeclaration holder, ICollection`1<INamespace> namespaces, ICollection`1<string> shortNames);
    public static void EnsurePreimportedNamespaces(ICSharpFile file);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Move.MoveToFile.CSharpMoveToFileHelper : MoveToFileHelperBase {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public virtual bool MoveDeclaration(IDeclaration declaration, ResolveImagesRepository repository, IFile file, MoveToFileWorkflow workflow, IRefactoringDriver driver);
    public virtual bool FileHasOtherDeclarations(IDeclaration declaration);
    public virtual bool IsFromExtendsList(ITreeNode element);
    public virtual bool IsReferenceName(ITreeNode element);
    private bool ScanForOtherDeclarations(ICSharpTypeAndNamespaceHolderDeclaration holder, IDeclaration declaration);
    public virtual bool AcceptTypeElement(IDeclaredElement typeElement);
    public virtual string GetDefaultFileName(IDeclaration declaration);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Move.MoveToFile.MoveToFileTypeHierarchyBuilder : CSharpTypeHierarchyBuilderBase {
    [NotNullAttribute]
private ITypeDeclaration myTypeDeclaration;
    public MoveToFileTypeHierarchyBuilder(ITypeDeclaration typeDeclaration);
    [NotNullAttribute]
public ITypeDeclaration MoveTypeDeclaration(ICSharpTypeAndNamespaceHolderDeclaration parent);
    protected virtual ICSharpTypeDeclaration AddTypeDeclaration(IClassLikeDeclaration leafDeclaration);
    private static void EnsureNullableContextPreserved(ICSharpTypeDeclaration originalDeclaration, ICSharpTypeDeclaration createdDeclaration);
    [CanBeNullAttribute]
private static ICSharpDeclaration FindNextDeclaration(ICSharpTypeDeclaration declaration);
    private static void EnsurePreprocessorConditionAndPragmaDirectivesPreserved(ICSharpTypeDeclaration originalDeclaration, ICSharpTypeDeclaration createdDeclaration);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IReadOnlyList`1<IPreprocessorDirective> CollectPreprocessorDirectivesIn(ICSharpFile file);
    private static IList`1<PreprocessorRegion> CollectMovedPreprocessorRegions(ICSharpFile containingFile, IReadOnlyList`1<IPreprocessorDirective> directives, ICSharpTypeDeclaration originalDeclaration);
    private static PragmaWarningState CollectPragmaDirectivesInRegion(IReadOnlyList`1<IPreprocessorDirective> directives, TreeTextRange range, Nullable`1<PragmaWarningState> initialState);
    [CanBeNullAttribute]
private static ITreeNode FindNextSignificantNode(ICSharpFile containingFile, ITreeNode anchor, Int32& newLinesCount);
    [NotNullAttribute]
public static ITreeRange CreateSingleDirectiveRange(IPreprocessorDirective directive);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.CSharp.Move.MoveToFile.MoveToFileTypeHierarchyBuilder/<RestorePragmaWarningState>d__12")]
[NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<IPreprocessorDirective> RestorePragmaWarningState(PragmaWarningState requiredState, PragmaWarningState currentState, ITreeNode context);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Move.MoveToFolder.CSharpMoveToFolderHelper : MoveToFolderHelperBase {
    public bool IsLanguageSupported { get; }
    public bool CanMoveSingleTypeDeclaration { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual bool get_CanMoveSingleTypeDeclaration();
    public virtual bool MoveSingleDeclaration(IDeclaration typeDeclaration, IFile targetFile, string expectedNamespaceName, ResolveImagesRepository repository, bool searchInRelatedFiles);
    public virtual bool MoveFewDeclarations(IFile sourceFile, IFile targetFile, bool fixNamespaces, string name, ResolveImagesRepository repository, IList`1<IDeclaration> children, bool searchInRelatedFiles);
    public virtual bool MoveWholeFile(MoveToFolderHierarchyProjectItem item, IFile sourceFile, IFile targetFile, bool fixNamespaces, string expectedNamespaceName, ResolveImagesRepository repository, bool searchInRelatedFiles);
    public virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public virtual IReadOnlyList`1<IDeclaration> GetTopLevelTypeDeclarations(IFile file);
    public virtual bool IsFromExtendsList(ITreeNode element);
    public virtual bool IsReferenceName(ITreeNode element);
    public virtual void RemoveUsing(ITreeNode element);
    public virtual IEnumerable`1<ITreeNode> GetUsingsFromFile(IFile file, IList`1<INamespace> namespaces);
    public virtual void MakePublic(IDeclaration declaration);
    public virtual string GetCanMoveToProjectFolderError(IProjectFolder projectFolder);
    public virtual bool DeclarationCanProvideName(IDeclaration declaration);
    private static bool RemoveDeclarationsInFiles(ICSharpTypeAndNamespaceHolderDeclaration sourceHolder, ICSharpTypeAndNamespaceHolderDeclaration targetHolder, IList`1<IDeclaration> children);
    private static void RemoveTypeDeclarationWithNamespaces(ICSharpTypeDeclaration declaration);
    private static void RemoveTypeDeclaration(ICSharpTypeDeclaration declaration);
    private static void RemoveNamespace(ICSharpNamespaceDeclaration sourceNamespace);
    private static ICSharpTypeAndNamespaceHolderDeclaration RemoveUsings(ICSharpTypeAndNamespaceHolderDeclaration holder);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Move.MoveToNamespace.CSharpMoveToNamespaceHelper : MoveToNamespaceHelperBase {
    public bool IsLanguageSupported { get; }
    public bool AllowEmptyNamespace { get; }
    public virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public virtual bool get_IsLanguageSupported();
    public virtual bool IsFromExtendsList(ITreeNode element);
    public virtual bool IsReferenceName(ITreeNode element);
    public virtual IEnumerable`1<ITreeNode> GetUsingsFromFile(IFile file, IList`1<INamespace> namespaces);
    public virtual void MovePrimaryDeclaration(IDeclaration typeDeclaration, string newNamespaceName, ResolveImagesRepository repository, IRefactoringDriver driver);
    private static void FixContainingHolderIfNeeded(ITypeAndNamespaceHolderDeclaration containingHolder);
    private static ICSharpTypeAndNamespaceHolderDeclaration GetNewTypeDeclarationHolder(ITypeDeclaration typeDeclaration, string namespaceName);
    public virtual void RemoveUsing(ITreeNode element);
    public virtual bool get_AllowEmptyNamespace();
}
public class JetBrains.ReSharper.Refactorings.CSharp.Move.MovoIntoMatchingFiles.CSharpMoveIntoMatchingFilesHelper : MoveIntoMatchingFilesHelperBase {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public virtual IReadOnlyList`1<IDeclaration> GetTopLevelTypeDeclarations(IFile file, Boolean& hasTopLevelCode);
    public virtual bool IsFromExtendsList(ITreeNode element);
    public virtual bool IsReferenceName(ITreeNode element);
    public virtual void MoveDeclarationFromFile(MovedDeclaration declaration, ResolveImagesRepository repository);
    public virtual ITreeNode GetOwnerNamespaceDeclaration(IDeclaration typeDeclaration);
    public virtual bool IsApplicable(IProjectFile file);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.MoveInstanceMethod.CsMoveInstanceMethodHelper : MoveInstanceMethodHelper {
    private MoveInstanceMethodWorkflow myWorkflow;
    private IParameter myThisParameter;
    public bool IsLanguageSupported { get; }
    public CsMoveInstanceMethodHelper(MoveInstanceMethodWorkflow workflow);
    public virtual bool get_IsLanguageSupported();
    public virtual MoveInstanceMethodModel GetModel(MoveInstanceMethodWorkflow moveInstanceMethodWorkflow, IMethod method, Lifetime lifetime);
    public virtual void Rebind(IProgressIndicator pi, MoveInstanceMethodDataModel model);
    public virtual void AddSourceElementParameter(MoveInstanceMethodDataModel model);
    public virtual void AddAdditionalElements(MoveInstanceMethodDataModel model);
    public virtual void ReplaceWithDelegation(IProgressIndicator pi, MoveInstanceMethodDataModel model);
    private bool AddQualifier(IReference reference, CSharpElementFactory factory, ICSharpExpression newQualifier, bool resetQualifier, MoveInstanceMethodDataModel model);
    public IPropertyDeclaration CreatePropertyDeclaration(ITypeDeclaration sourceTypeDeclaration, IType type, IFieldDeclaration fieldDeclaration);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.MoveInstanceMethod.CsMoveInstanceMethodModel : MoveInstanceMethodModel {
    public CsMoveInstanceMethodModel(IMethod method, Lifetime lifetime);
    public virtual bool AnalyzeDeclaration();
}
public class JetBrains.ReSharper.Refactorings.CSharp.MoveMembers.CsExtractInterface : CsPullUpBase {
    public CsExtractInterface(ISolution solution, IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.CSharp.MoveMembers.CSharpExtractSuperclass : CsPullUpBase {
    public CSharpExtractSuperclass(ISolution solution, IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.CSharp.MoveMembers.CSharpMoveMembersHelper : MoveMembersHelper {
    public CSharpMoveMembersHelper(IMoveMembersExecuter executer);
    public virtual IList`1<Pair`2<DeclaredElementNode, IDeclaration>> CutDeclarations(IEnumerable`1<DeclaredElementNode> memberInfos, SubProgressIndicator pi);
    public virtual ITypeDeclaration InsertSibling(ITypeDeclaration declarationToInsert, ITypeDeclaration tagDeclaration);
    public virtual ITypeDeclaration InsertToNewFile(ITypeDeclaration declarationToInsert, ITypeDeclaration tagDeclaration, string ns, IProjectFile fileNearby);
    public virtual void SetSuperclass(ITypeDeclaration sourceTypeDeclaration, ITypeElement newSuperTypeElement, ISubstitution substitution);
    public virtual void PasteDeclarations(IList`1<Pair`2<DeclaredElementNode, IDeclaration>> declarations, ITypeElement targetType, IProjectFile projectFile, ITypeDeclaration targetTypeDeclaration, SubProgressIndicator pi);
    private static void RemoveAttributes(IClassMemberDeclaration classMemberDeclaration);
    public virtual ITypeDeclaration CreateTargetTypeElement(string name, ITypeElement sourceType, List`1<ITypeParameter> parameters, bool createBaseType, bool preserveAccessRights);
    public virtual void AddBaseInterface(ITypeElement element, IDeclaredType info);
    public virtual void MakeTypeElementAbstract(ITypeElement element);
    public virtual void RemoveDeclaration(ITypeMember member);
    public virtual void MakeOverride(ITypeMember member);
    private static void MakeDeclarationOverride(IClassMemberDeclaration declaration);
    public virtual bool TryProcessMultiFieldForResolve(IRecursiveElementProcessor collector, IDeclaration declaration);
    public virtual void CheckConstructorReferenceConflict(IReference reference);
    public virtual void AddImplementsSpecification(IDeclaration decl, ITypeElement element, bool nameIsItem, IRefactoringDriver driver);
    public virtual void RemoveSuperType(ITypeDeclaration typeDeclaration, IDeclaredType type);
    public virtual IConstructor GetBaseConstructorDeclarationToInsert(IDeclaration declaration);
    public virtual void GenerateConstructors(ITypeElement targetType, ITypeDeclaration typeDeclaration, IDeclaredElementPointer`1<IConstructor> baseConstructor);
    private IEnumerable`1<IDeclaration> GetAbstractedDeclarations(IDeclaredElement declaredElement);
    private static void RemoveAccessorWithLessAccessibility(IClassMemberDeclaration declaration);
    private static void MakeDeclarationAbstract(ICSharpModifiersOwnerDeclaration classMemberDeclaration);
    private static void UpdateReferences(ReferenceIdentitySaver saver, IImageCollector executer, ITypeElement targetTypeElement, IProgressIndicator pi);
    private static void AddTypeParametersWithConstraints(ICSharpTypeDeclaration targetTypeDeclaration, ITypeElement sourceClass, List`1<ITypeParameter> sourceTypeParameters, IPsiModule psiModule);
}
public class JetBrains.ReSharper.Refactorings.CSharp.MoveMembers.CsPullUp : CsPullUpBase {
    public CsPullUp(ISolution solution, IRefactoringDriver driver);
}
public abstract class JetBrains.ReSharper.Refactorings.CSharp.MoveMembers.CsPullUpBase : PullUpBase {
    protected CsPullUpBase(ISolution solution, IRefactoringDriver driver);
    public virtual bool CheckConflictsWithTargetClassName(ITypeElement element, string name);
    public virtual bool IsInstanceSpecificEventAccess(IReference reference);
    public virtual MoveMembersHelper GetHelper();
}
public class JetBrains.ReSharper.Refactorings.CSharp.MoveMembers.CsPushDown : PushDownBase {
    public CsPushDown(ISolution solution, IRefactoringDriver driver);
    public virtual bool CheckConflictsWithTargetClassName(ITypeElement element, string name);
    public virtual bool IsInstanceSpecificEventAccess(IReference reference);
    public virtual MoveMembersHelper GetHelper();
}
internal class JetBrains.ReSharper.Refactorings.CSharp.MoveStaticMembers.CSharpMoveStaticMembers : MoveStaticMembers {
    private MoveStaticDataModel myDataModel;
    public CSharpMoveStaticMembers(MoveStaticMembersWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void RemoveOldDeclaration(IDeclaration declaration);
    public virtual Dictionary`2<ITypeParameter, ITypeParameter> PasteDeclaration(StaticMemberInfo memberInfo, ITypeMember& newTypeMember);
    public virtual void SetNotPartial(ITypeMember member);
    public virtual ITypeDeclaration CreateTypeDeclaration(IFile file);
    public virtual bool ReferenceShouldBeProcessed(IReference reference);
}
public class JetBrains.ReSharper.Refactorings.CSharp.MoveStaticMembers.CSharpMoveStaticMembersHelper : MoveStaticMembersHelper {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
}
public class JetBrains.ReSharper.Refactorings.CSharp.MoveTypeToOuterScope.CSharpMoveTypeToOuterScope : MoveTypeToOuterScopeBase`2<IProperTypeDeclaration, IClassLikeDeclaration> {
    public CSharpMoveTypeToOuterScope(MoveTypeToOuterScopeRefactoring refactoring);
    [CanBeNullAttribute]
protected static ITokenNode NewModifier(ICSharpModifiersOwnerDeclaration node);
    protected virtual void RemoveNewKeyword(IProperTypeDeclaration declaration);
    public virtual bool IsContextUnsafe(ITreeNode element);
    protected virtual IClassLikeDeclaration GetContainingTypeDeclaration(IProperTypeDeclaration declaration);
    protected virtual IProperTypeDeclaration CutDeclaration(IProperTypeDeclaration declaration);
    protected virtual IProperTypeDeclaration PasteDeclaration(IProperTypeDeclaration declarationCopy, IClassLikeDeclaration oldContainingDeclaration);
    protected static IList`1<ITypeParameterConstraintsClause> GetConstraintsFor(ITypeParameter typeParameter, IClassLikeDeclaration typeDeclaration);
    protected void DeclareTypeParameterWithConstraints(string name, IList`1<ITypeParameterConstraintsClause> constraints, IProperTypeDeclaration declaration);
    protected virtual AccessRights GetAccessRights(IProperTypeDeclaration typeDeclaration);
    protected virtual AccessRights GetAccessRights(IClassLikeDeclaration typeDeclaration);
    protected virtual void SetAccessRights(IProperTypeDeclaration typeDeclaration, AccessRights accessRights);
}
public class JetBrains.ReSharper.Refactorings.CSharp.ParamsModifier.CSharpParamsModifier : ParamsModifierConvertBase {
    public CSharpParamsModifier(ParamsModifierWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void ExecuteDeclarationRefactoring(IDeclaredElement declaredElement, IProgressIndicator progressIndicator);
    public virtual void ExecuteReferencesRefactoring(IReference reference);
    public virtual void ExecuteReferencesRebinding(IReference reference);
    private static bool TryGetArgumentsOwner(IReference reference, ICSharpArgumentsOwner& argumentsOwner);
}
internal static class JetBrains.ReSharper.Refactorings.CSharp.Properties.Workaround : object {
}
public class JetBrains.ReSharper.Refactorings.CSharp.Property2Auto.CSharpProperty2Auto : Property2AutoBase {
    private bool myShouldReplaceInitWithSet;
    public CSharpProperty2Auto(Property2AutoWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void TransformDeclaration();
    private static void FixAutoPropertyAccessor(IAccessorDeclaration accessorDeclaration);
    public static void MoveFieldInitializerToProperty(IClassMemberDeclaration fieldDeclaration, IPropertyDeclaration propertyDeclaration);
    public static void MoveFieldAttributesToProperty(IClassMemberDeclaration fieldDeclaration, IPropertyDeclaration autoPropertyDeclaration, IRefactoringDriver refactoringDriver);
    [PureAttribute]
private static bool AlreadyHasTheSameTrivialAttribute(IList`1<IAttributeInstance> existingInstances, IAttribute attribute);
    [PureAttribute]
[CanBeNullAttribute]
private static IDocCommentBlock TryFindFieldDocumentation(IClassMemberDeclaration declaration);
    private void EnsureHasAccessor(IProperty property, AccessorKind accessorKind);
    public static void CheckPolymorphicPropertyAccessorsIntroductionConflicts(IProperty property, IAccessor polymorphicAccessor, IRefactoringDriver refactoringDriver);
    public virtual void RemoveFieldDeclaration();
    public virtual void ExpandInitializerToAssignments();
    private bool PutInitializationToConstructors(ICSharpExpression initializerExpression, bool fieldIsStatic, Boolean& allOverwritten);
    [CanBeNullAttribute]
private static ICSharpExpression GetInitializerExpression(IDeclaration declaration);
    public virtual void BindUsage(IReference reference);
    public static void CheckFieldReplacementWithPropertyConflicts(IReference reference, ICSharpExpression usageExpression, IRefactoringDriver driver);
    public virtual void CheckAccessInStructConstructorDeclaration(IReference reference);
    public virtual void FinishBindingUsages();
    public static void CheckAccessInStructConstructorDeclaration(IReference reference, ITypeElement containingType, IRefactoringDriver refactoringDriver);
    [CompilerGeneratedAttribute]
internal static bool <MoveFieldAttributesToProperty>g__IsNullnessAnnotations|5_0(IAttributeInstance instance, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static AttributeTargets <MoveFieldAttributesToProperty>g__GetAttributeTarget|5_1(IAttributeInstance instance, <>c__DisplayClass5_0& );
}
public class JetBrains.ReSharper.Refactorings.CSharp.Property2Auto.CSharpProperty2AutoChecker : object {
    public sealed virtual bool IsPropertyWithBackingField(IProperty property, IField& backingField);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Property2Function.CsProperty2Function : Property2FunctionBase {
    public CsProperty2Function(Property2FunctionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    protected virtual bool AreEquals(string name1, string name2);
    protected virtual void CheckConflictWithClassName(ITypeElement element);
    public virtual void ReplaceReadOccurrence(IExpression expression);
    public virtual void ProcessProperty(IDeclaredElement propertyOrMethod);
    public virtual void TryMakeConflictForNotExpression(IReference reference);
    public virtual bool TryTransformMethodCall(IExpression expression);
}
[FixFactoryAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.CSharp.PushPullTool.Fixes.CsFixFactory : FixFactory {
    public int Priority { get; }
    public virtual int get_Priority();
    public virtual IEnumerable`1<FixNode> GetIndependentFixes(ProblemNode problemNode);
    private FixNode GetDefaultParameterFix(ClrChangeSignatureParameter parameter, CallProblemNode node);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.CSharp.PushPullTool.Fixes.CsFixFactory/<<GetIndependentFixes>g__CreateInstanceFixes|2_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<FixNode> <GetIndependentFixes>g__CreateInstanceFixes|2_0(CallProblemNode node, bool defaultParameterAllowed);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.CSharp.PushPullTool.Fixes.CsFixFactory/<<GetIndependentFixes>g__CreateLocalFixes|2_1>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<FixNode> <GetIndependentFixes>g__CreateLocalFixes|2_1(CallProblemNode node, bool defaultParameterAllowed);
    [CompilerGeneratedAttribute]
internal static bool <GetIndependentFixes>g__IsNullOrAccessibleFromAllDeclarations|2_2(ITypeMember typeMember, ITypeElement typeElement);
}
public class JetBrains.ReSharper.Refactorings.CSharp.PushPullTool.Fixes.DefaultParameterFixNode : ParameterFixNode {
    private DocOffset myOffset;
    protected string Text { get; }
    public DefaultParameterFixNode(CallProblemNode node, IParametersOwner callOwner, Lifetime lifetime);
    protected virtual string get_Text();
    public virtual void ExecuteWithoutTransaction();
    public virtual void PostExecute();
    protected virtual void Init();
    protected virtual int GetNewArgumentIndex();
    public virtual void CreateDescendantNodes(IDeclaredElement parametersOwner, IEnumerable`1<IReference> references);
    public virtual bool Rollback();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <PostExecute>b__5_0();
}
internal class JetBrains.ReSharper.Refactorings.CSharp.PushPullTool.Fixes.PullThroughCtorFix : ChangeSignatureFixNode {
    private bool myIsProtected;
    private bool myIsStatic;
    private ChangeSignatureParameter myParameter;
    private Dictionary`2<IDeclaredElement, ChangeSignatureParameter> myParameters;
    private Dictionary`2<IDeclaredElement, ClrChangeSignatureModel> myParentSignatureModels;
    private IDeclaredElementPointer`1<ITypeElement> myTypeElement;
    private TextStyle myBoldStyle;
    private TextStyle myRegularStyle;
    private IFieldDeclaration myFieldDeclaration;
    private string myFieldName;
    private IParameterDeclaration myParameterDeclaration;
    private string myParameterName;
    private RichText myTypeElementName;
    private IDeclaration myUniqueNameContext;
    private BeRichText myPresentation;
    public IDeclaredElement DeclaredElement { get; }
    public PullThroughCtorFix(CallProblemNode node, ITypeElement typeElement, Lifetime lifetime);
    public virtual IDeclaredElement get_DeclaredElement();
    private void LoadPresentation();
    private void CreateFieldDeclaration(IProgressIndicator pi);
    public virtual void CreateDescendantNodes(IDeclaredElement parametersOwner, IEnumerable`1<IReference> references);
    public virtual bool ExecuteUnderTransaction(IProgressIndicator pi);
    public virtual BeAbstractText GetPresentationText();
    public virtual ValueTuple`2<RichText, RichText> GetProblemFixedText();
    private void LoadParents(IProgressIndicator subPi);
    private void ExecuteParentRefactoring(IProgressIndicator pi);
    private void AddStatements();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <.ctor>b__17_0(bool b);
}
public class JetBrains.ReSharper.Refactorings.CSharp.PushPullTool.Fixes.UseDefaultFixNode : ChangeSignatureFixNode {
    private IDeclaredElementPointer`1<IDeclaredElement> myDeclaredElement;
    private RichText myValue;
    public IDeclaredElement DeclaredElement { get; }
    public UseDefaultFixNode(ProblemNode node, IDeclaredElement declaredElement, Lifetime lifetime);
    public virtual IDeclaredElement get_DeclaredElement();
    public virtual BeAbstractText GetPresentationText();
    public virtual ValueTuple`2<RichText, RichText> GetProblemFixedText();
    public virtual bool ExecuteUnderTransaction(IProgressIndicator pi);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Refactorings.CSharp.ReferenceCollectorOfQuerySelection : object {
    private SubQuerySelection mySelection;
    private List`1<IReference> myReferences;
    private States myState;
    public bool ProcessingIsFinished { get; }
    private ReferenceCollectorOfQuerySelection(SubQuerySelection selection);
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
    public static IList`1<IReference> GetSelectedReferences(SubQuerySelection selection);
    public static IList`1<IReference> GetNotSelectedReferences(SubQuerySelection selection);
}
[DerivedRenamesEvaluatorAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.Rename.ConstructorParameterRenameEvaluator : object {
    public bool SuggestedElementsHaveDerivedName { get; }
    public sealed virtual bool get_SuggestedElementsHaveDerivedName();
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<IDeclaredElement> CreateFromElement(IEnumerable`1<IDeclaredElement> initialElements, DerivedElement derivedElement, IProgressIndicator pi);
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<IDeclaredElement> CreateFromReference(IReference reference, IDeclaredElement declaredElement, IProgressIndicator pi);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <CreateFromElement>g__InspectArgumentList|2_1(ICSharpArgumentsOwner argumentsOwner, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static void <CreateFromReference>g__InspectPrimaryConstructorParameterInitializingMembers|3_0(<>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static void <CreateFromReference>g__InspectParameterPassedAsAnArgument|3_1(<>c__DisplayClass3_0& );
}
[ShellFeaturePartAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.Rename.CSharpAnonymousTypePropertyRenamesFactory : AtomicRenamesFactory {
    public virtual bool IsApplicable(IDeclaredElement declaredElement);
    public virtual RenameAvailabilityCheckResult CheckRenameAvailability(IDeclaredElement declaredElement);
    public virtual IEnumerable`1<AtomicRenameBase> CreateAtomicRenames(IDeclaredElement declaredElement, string newName, bool doNotAddBindingConflicts);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.Rename.CSharpIdentifierNamingProjection : object {
    public sealed virtual bool CheckNameIsValid(string name);
}
[ShellFeaturePartAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.CSharp.Rename.CSharpIdentifierNamingProjectionProvider : object {
    public sealed virtual INamingProjection GetProjection(IDeclaredElement element, IReference reference);
    public sealed virtual bool IsApplicable(IDeclaredElement element, IReference reference);
}
[RenamePartAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.Rename.CSharpPrimaryDeclaredElementForRenameProvider : object {
    public sealed virtual IDeclaredElement GetPrimaryDeclaredElement(IDeclaredElement declaredElement, IReference reference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ShellFeaturePartAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.Rename.CSharpRecordPositionalPropertyRenamesFactory : AtomicRenamesFactory {
    public virtual bool IsApplicable(IDeclaredElement declaredElement);
    public virtual RenameAvailabilityCheckResult CheckRenameAvailability(IDeclaredElement declaredElement);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.CSharp.Rename.CSharpRecordPositionalPropertyRenamesFactory/<CreateAtomicRenames>d__2")]
public virtual IEnumerable`1<AtomicRenameBase> CreateAtomicRenames(IDeclaredElement declaredElement, string newName, bool doNotAddBindingConflicts);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.CSharp.Rename.CSharpRenameHelper : RenameHelperBase {
    public bool IsLanguageSupported { get; }
    public virtual IList`1<IConflictSearcher> AdditionalConflictsSearchers(IDeclaredElement element, string newName);
    public virtual void AdditionalReferenceProcessing(IDeclaredElement newTarget, IReference reference, ICollection`1<IReference> newReferences);
    public virtual void JoinTransformAnonymous(IReference reference);
    public virtual bool IsAlias(IDeclaredElement element);
    public virtual IReference TransformProjectedInitializer(IReference reference);
    public virtual SuspiciousReferencesSearchProcessor CreateSuspiciousReferenceSearchProcessor(ITreeNode root, SuspiciousReferenceSearchContext context);
    public virtual DeclaredElementInstance GetSubst(IDeclaredElement element);
    public virtual IDeclaredElement UpdateSecondaryElement(IDeclaredElement element, IDeclaredElement newDeclaredElement);
    private static void ProcessAlias(IDeclaredElement newDeclaredElement, IReference newReference, IUsingAliasDirective usingAliasDirective, ICollection`1<IReference> newReferences);
    public virtual CustomRenameModel GetOptionsModel(IDeclaredElement primaryDeclaredElement, IReference reference, Lifetime lifetime);
    public virtual bool IsCheckResolvedTo(IReference newReference, IDeclaredElement newDeclaredElement);
    public virtual bool get_IsLanguageSupported();
    public virtual IEnumerable`1<IDeclaredElement> GetSecondaryElements(IDeclaredElement declaredElement, string newName);
    public virtual IEnumerable`1<IReference> GetCustomUsages(IDeclaredElement declaredElement);
    public virtual bool IsLocalRename(IDeclaredElement primevalDeclaredElement);
    public virtual void AddExtraNames(INamesCollection suggestion, IDeclaredElement declaredElement);
    public virtual IReference BindReferenceToNamespace(IReference reference, INamespace ns);
    private static bool IsNamespaceDeclarationReference(IReference reference);
    public virtual OneToSetMap`2<IDeclaredElementPointer`1<IDeclaredElement>, IReferencePointer> GetSuspiciousReferences(IDeclaredElement element);
    public virtual bool RenameInReferencesInThisLanguageFirst(PsiLanguageType psiLanguageType);
    public virtual IEnumerable`1<IReference> GetReferences(IGrouping`2<ITypeMemberDeclaration, IDeclaration> element);
    public virtual IEnumerable`1<IDeclaredElement> GetSecondaryElementsToInlineRename(IDeclaredElement declaredElement);
    public virtual bool ShouldSkipReferenceInRename(IReference reference);
}
[ShellFeaturePartAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.Rename.CSharpSpecificElementsRenamesFactory : AtomicRenamesFactory {
    public virtual bool IsApplicable(IDeclaredElement element);
    public virtual RenameAvailabilityCheckResult CheckRenameAvailability(IDeclaredElement element);
}
[DerivedRenamesEvaluatorAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.Rename.EventRenameEvaluator : object {
    public bool SuggestedElementsHaveDerivedName { get; }
    public sealed virtual bool get_SuggestedElementsHaveDerivedName();
    public sealed virtual IEnumerable`1<IDeclaredElement> CreateFromElement(IEnumerable`1<IDeclaredElement> initialElements, DerivedElement derivedElement, IProgressIndicator pi);
    public sealed virtual IEnumerable`1<IDeclaredElement> CreateFromReference(IReference reference, IDeclaredElement declaredElement, IProgressIndicator pi);
    [CanBeNullAttribute]
private static IMethod GetMethod(IReference reference, IDeclaredElement declaredElement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DerivedRenamesEvaluatorAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.Rename.FieldDerivedRenameEvaluator : object {
    public bool SuggestedElementsHaveDerivedName { get; }
    public sealed virtual bool get_SuggestedElementsHaveDerivedName();
    public sealed virtual IEnumerable`1<IDeclaredElement> CreateFromElement(IEnumerable`1<IDeclaredElement> initialElements, DerivedElement derivedElement, IProgressIndicator pi);
    public sealed virtual IEnumerable`1<IDeclaredElement> CreateFromReference(IReference reference, IDeclaredElement declaredElement, IProgressIndicator pi);
    [PureAttribute]
private static IProperty FindPropertyByBackingField(ICSharpExpression fieldUsageExpression);
    [PureAttribute]
public static IParametersOwner FindHandlerByEventSubscriptionOverField(ICSharpExpression fieldUsageExpression);
    [PureAttribute]
public static IParameter FromConstructorParameterAssignment(ICSharpExpression fieldUsageExpression);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Rename.Impl.CSharpAnonymousTypePropertyAtomicRename : AnonymousTypePropertyAtomicRenameBase {
    public CSharpAnonymousTypePropertyAtomicRename(IDeclaredElement originalElement, string newName);
    protected virtual IDeclaredElement SetName(IDeclaredElement element, string name);
    protected virtual int CompareReferencesOnMemberDeclarations(IReference r1, IReference r2);
}
[SolutionComponentAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.CSharp.Rename.Impl.CSharpRenameSuspiciousReferencesSearchService : SuspiciousReferencesSearchService {
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<string> GetPossibleReferenceNames(IDeclaredElement element, string newName);
}
[DerivedRenamesEvaluatorAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.Rename.PropertyDerivedRenameEvaluator : object {
    public bool SuggestedElementsHaveDerivedName { get; }
    public sealed virtual bool get_SuggestedElementsHaveDerivedName();
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<IDeclaredElement> CreateFromElement(IEnumerable`1<IDeclaredElement> initialElements, DerivedElement derivedElement, IProgressIndicator pi);
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<IDeclaredElement> CreateFromReference(IReference reference, IDeclaredElement declaredElement, IProgressIndicator pi);
}
[DerivedRenamesEvaluatorAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.CSharp.Rename.TypeDerivedRenamesEvaluator : object {
    public bool SuggestedElementsHaveDerivedName { get; }
    public sealed virtual bool get_SuggestedElementsHaveDerivedName();
    public sealed virtual IEnumerable`1<IDeclaredElement> CreateFromElement(IEnumerable`1<IDeclaredElement> initialElements, DerivedElement derivedElement, IProgressIndicator pi);
    public sealed virtual IEnumerable`1<IDeclaredElement> CreateFromReference(IReference reference, IDeclaredElement declaredElement, IProgressIndicator pi);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Refactorings.CSharp.RenameNamespace.CSharpRenameNamespace : object {
    public sealed virtual IEnumerable`1<INamespaceDeclarationUpdater> BuildNamespaceDeclarationUpdatersForFile(INamespace namespace, IFile file, string newName);
    public sealed virtual IConflictSearcher GetConflictSearcher(INamespace namespace, string name);
    public bool PreProcessReference(IReference reference, INamespace originalNamespace, string newName);
    private void ReplaceReferenceName(IReferenceName name, string prefix, string newName);
    private static IOwnerQualification GetOwnerQualification(IReferenceName name);
    public IDisposable TemporarilyDeclareNamespace(IFile file, string name);
    public IConflictSearcher GetConflictSearcher(ICollection`1<INamespaceDeclaration> namespaceDeclarations, ICollection`1<IReference> references, INamespace originalNamespace, string newName);
}
internal class JetBrains.ReSharper.Refactorings.CSharp.RenameNamespace.DeclarationUpdater : object {
    private ICSharpNamespaceDeclaration myNamespaceDeclaration;
    private QName myNewName;
    private ReferenceRebinder myRebinder;
    private ITreeNodePointer`1<ICSharpIdentifier> myDeclarationNamePointer;
    private IPsiServices myPsiServices;
    private QName myNewDeclarationName;
    public DeclarationUpdater(ICSharpNamespaceDeclaration namespaceDeclaration, string newName);
    public sealed virtual void PreProcess();
    public sealed virtual void SetNewName();
    public sealed virtual void RestoreReferences();
}
internal class JetBrains.ReSharper.Refactorings.CSharp.RenameNamespace.QualificationUpdater : object {
    private IReferenceName myReferenceName;
    private IOwnerQualification myOwnerQualification;
    private INamespace myNamespace;
    private QName myNewName;
    private ReferenceRebinder myRebinder;
    private ITreeNodePointer`1<ICSharpIdentifier> myNamespaceDeclarationNamePointer;
    private QName myNewDeclarationName;
    public QualificationUpdater(IReferenceName referenceName, IOwnerQualification ownerQualification, INamespace namespace, string newName);
    public sealed virtual void PreProcess();
    private static string BuildQualifiedName(IReferenceName referenceName);
    private static string Encode(string name);
    public sealed virtual void SetNewName();
    public sealed virtual void RestoreReferences();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.CSharp.RenameTupleComponent.CSharpInplaceRenameSpecifics : object {
    public sealed virtual bool SuggestRenameOnRenamingReference(IReference reference);
    public sealed virtual bool SuggestRenameOnRenamingTreeNode(TreeTextRange treeRange, ITreeNode node);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.CSharp.RenameTupleComponent.CSharpNamedTupleComponentSearcher : NamedTupleComponentSearcher {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.CSharp.RenameTupleComponent.CSharpNamedTupleComponentSearcher/<FindReferencesInScope>d__0")]
public virtual IEnumerable`1<IReference> FindReferencesInScope(string componentName, ITreeNode scope);
    [PureAttribute]
private static bool IsComponentNameIgnored(IReference reference, INamedTupleComponent namedTupleComponent);
    [CompilerGeneratedAttribute]
internal static bool <FindReferencesInScope>g__CheckReference|0_0(IReference reference, <>c__DisplayClass0_0& );
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.CSharp.RenameTupleComponent.CSharpRenameTupleComponentHelper : RenameTupleComponentHelper {
    public virtual bool CanRename(IReference reference);
    public virtual IChangeNode`1<RenameTupleComponentContext> TryCreateChangeNode(IReference reference, RenameTupleComponentContext context);
    public virtual IReference RenameReference(IReference reference, RenameTupleComponentContext context);
    public virtual IReference FixPossibleNameMismatch(IReference suspiciousReference, RenameTupleComponentContext context);
}
[SolutionFeaturePartAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.RenameTupleComponent.RecordDeconstructParameterTypeChangeProvider : DefaultChangeTypeNodesProvider {
    public virtual bool IsApplicable(IDeclaredElement declaredElement, IChangeContext context);
    public virtual void AddChangeNodes(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType newType, TContext context, IProgressIndicator progress);
}
[SolutionFeaturePartAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.RenameTupleComponent.RecordPositionalParameterTypeChangeProvider : DefaultChangeTypeNodesProvider {
    public virtual bool IsApplicable(IDeclaredElement declaredElement, IChangeContext context);
    public virtual void AddChangeNodes(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType newType, TContext context, IProgressIndicator progress);
}
[SolutionFeaturePartAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.RenameTupleComponent.RecordPropertyTypeChangeProvider : DefaultChangeTypeNodesProvider {
    public virtual bool IsApplicable(IDeclaredElement declaredElement, IChangeContext context);
    public virtual void AddChangeNodes(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType newType, TContext context, IProgressIndicator progress);
}
public class JetBrains.ReSharper.Refactorings.CSharp.RenameTupleComponent.RenameReferenceExpressionNode : object {
    [NotNullAttribute]
private ITreeNodePointer`1<IReferenceExpression> myReferenceExpressionPointer;
    public RenameReferenceExpressionNode(IReferenceExpression referenceExpression);
    public sealed virtual bool IsAvailable(RenameTupleComponentContext context);
    public sealed virtual IReadOnlyList`1<IChangeNode`1<RenameTupleComponentContext>> Apply(RenameTupleComponentContext context, IProgressIndicator progress);
    [CanBeNullAttribute]
public static IReadOnlyList`1<IChangeTypeTarget> TryGetChangeTargets(IReferenceExpression referenceExpression, INamedTupleComponent initialTupleComponent, INamedTupleComponent newTupleComponent);
}
public class JetBrains.ReSharper.Refactorings.CSharp.RenameTupleComponent.RenameTupleComponentNode : object {
    [NotNullAttribute]
private ITreeNodePointer`1<ITupleComponent> myTupleComponentPointer;
    public RenameTupleComponentNode(ITupleComponent tupleComponent);
    public sealed virtual bool IsAvailable(RenameTupleComponentContext context);
    public sealed virtual IReadOnlyList`1<IChangeNode`1<RenameTupleComponentContext>> Apply(RenameTupleComponentContext context, IProgressIndicator progress);
}
public class JetBrains.ReSharper.Refactorings.CSharp.RenameTupleComponent.RenameTupleTypeComponentNode : object {
    [NotNullAttribute]
private ITreeNodePointer`1<ITupleTypeComponent> myTupleTypeComponentPointer;
    public RenameTupleTypeComponentNode(ITupleTypeComponent tupleTypeComponent);
    public sealed virtual bool IsAvailable(RenameTupleComponentContext context);
    public sealed virtual IReadOnlyList`1<IChangeNode`1<RenameTupleComponentContext>> Apply(RenameTupleComponentContext context, IProgressIndicator progress);
    [CanBeNullAttribute]
private static ITypeUsage GetRootTypeUsage(ITupleTypeComponent tupleTypeComponent);
    [NotNullAttribute]
private static IType GetTypeAfterRename(ITupleTypeComponent tupleTypeComponent, ITypeUsage typeUsage, string newName);
}
public class JetBrains.ReSharper.Refactorings.CSharp.RenameTupleComponent.TupleComponentRenamePropagationUtil : TypeChangePropagationUtil {
    [NotNullAttribute]
private INamedTupleComponent myInitialTupleComponent;
    [NotNullAttribute]
private string myNewName;
    [CanBeNullAttribute]
private RenameTupleComponentContext myContext;
    public TupleComponentRenamePropagationUtil(RenameTupleComponentContext context);
    public TupleComponentRenamePropagationUtil(INamedTupleComponent initialTupleComponent, string newName);
    protected virtual DeclaredElementChangeTypeTarget TryCreateChangeTarget(IDeclaredElement declaredElement, IType newType);
    protected virtual ExpressionChangeTypeTarget TryCreateChangeTarget(ICSharpExpression expression, IType newType);
    [PureAttribute]
private ValueTuple`2<bool, IType> VerifyTypeChangeAndFixIfPossible(IType newType, IType oldType);
    protected virtual IReadOnlyList`1<IChangeTypeTarget> TryGetFromValue(ICSharpExpression expression, IType newType);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Refactorings.CSharp.RenameTupleComponent.TupleComponentRenamePropagationUtilProvider : object {
    public sealed virtual TypeChangePropagationUtil Get(RenameTupleComponentContext context);
}
public static class JetBrains.ReSharper.Refactorings.CSharp.RenameTupleComponent.TypeUsageChangeHelper : object {
    [NotNullAttribute]
public static IReadOnlyList`1<IChangeNode`1<TContext>> GetTypeUsageChanges(ITypeUsage typeUsage, IType newType, TContext context, IProgressIndicator progress);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.ReSharper.Refactorings.CSharp.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string CannotRenameIndexers_Text { get; }
    public static string TransformParameters_Conflict_CannotCreateVariable_Text { get; }
    public static string TransformParameters_Conflict_CannotCreateVariableOfType_Text { get; }
    public static string ConvertToGlobalUsing_DirectiveColumn_Text { get; }
    public static string ConvertToGlobalUsing_AddingGlobalUsingDirective_Text { get; }
    public static string ConvertToGlobalUsing_AnalyzingUsings_Text { get; }
    public static string ChangeNullabilityActionText { get; }
    public static string ConvertToGlobalUsing_CheckingConflicts_Text { get; }
    public static string ExtractMethod_PositionSelectorInlayHint_Text { get; }
    public static string ExtractMethod_PositionSelectorTooltip { get; }
    public static string ExtractMethod_MovedLocalFunctionHint { get; }
    public static string ExtractMethod_LocalFunctionSelector_EditorAdornment_Title { get; }
    public static string ExtractMethod_LocalFunctionSelector_EditorAdornment_Text { get; }
    public static string ExtractMethod_LocalFunctionSelector_EditorAdornment_NextButtonText { get; }
    public static string ExtractMethod_LocalFunctionSelector_EditorAdornment_MoveUpButtonTooltip { get; }
    public static string ExtractMethod_LocalFunctionSelector_EditorAdornment_MoveDownButtonTooltip { get; }
    public static string ExtractMethod_LocalFunctionSelector_EditorAdornment_CancelButtonTooltip { get; }
    public static string ConvertToGlobalUsing_FindingUsingDirectivesToRemove_Text { get; }
    public static string GlobalUsingDirectivesComment_Text { get; }
    public static string ConvertToGlobalUsing_StatisticsColumn_Text { get; }
    public static string ConvertToGlobalUsing_StatisticsTooltip_Text { get; }
    public static string ConvertToNonGlobalUsing_Action_Text { get; }
    public static string ConvertToNonGlobalUsing_Text { get; }
    public static string MaKeStatic_Text { get; }
    public static string ConvertToGlobalUsing_RemovingUsingDirectives_Text { get; }
    public static string ConvertToGlobalUsing_RemoveUsingDirective_X_Of_N_Text { get; }
    public static string ConvertToGlobalUsing_SelectedUsings_Text { get; }
    public static string ConvertToGlobalUsing_TopUsingsInProject_Text { get; }
    public static string Optional__Text { get; }
    public static string DelegateViaOverloading_CSharp8_Text { get; }
    public static string PropertyAccessorsCannotBeRenamed_Text { get; }
    public static string RecordTypeImplicitMemberCouldNotBeRenamed_Text { get; }
    public static string TypeCannotBeResolved_Text { get; }
    public static string TypeNameShouldnTBeEmpty_Text { get; }
    public static string UsingDeclarationConflict_Text { get; }
    public static string UsingStatisticsProcessor_ScanningFile_Text { get; }
    public static string VariableDoesnTHaveInitializer_Text { get; }
    public static string VariableDoesnTHaveDeclarationsInSource_Text { get; }
    public static string CannotRunControlFlowAnalysisFromThis_Text { get; }
    public static string AssignedValueHasNoReachableUsages_Text { get; }
    public static string VariableHasUnsupportedInitializer_Text { get; }
    public static string VariableHasUnsupportedUsageKind_Text { get; }
    public static string VariableHasWriteUsages_Text { get; }
    public static string CannotIntroduceVariableFromTheSelected_Text { get; }
    public static string CannotIntroduceVariable_Text { get; }
    public static string ApplyNullabilityChange_Text { get; }
    public static string MakeNullable_Text { get; }
    public static string InitOnlyProperty_WillBecomeMutable_Text { get; }
    public static string PropertyWithFieldKeywordWillBeTransformed_Text { get; }
    public static string UsageWillBeTransformedButTransformation_Text { get; }
    public static string CanTOverridePropertyWithAutoProperty_Text { get; }
    public static string Attribute0_OfTheFieldDeclarationCannot_Text { get; }
    public static string Attribute0_OfTheFieldDeclarationWill_Text { get; }
    public static string NewAccessorIntroductionInVirtual_Can_Text { get; }
    public static string AutoPropertyWillAlsoOverride__Text { get; }
    public static string NewAccessorIntroductionIsNotAllowed_Text { get; }
    public static string NewAccessorIntroductionIsNotAllowedInExplicitImplementation_Text { get; }
    public static string InitializerExpressionIsOverwritten_Text { get; }
    public static string Field0InitializerWillBeReplacedWith_Text { get; }
    public static string BackingField_AccessWillBecomePolymorphic_Text { get; }
    public static string InitOnlyPropertyWillBecomeMutableTo_Text { get; }
    public static string CapturedField_NameWillBeReplacedWith_Text { get; }
    public static string UsageOf_MayBeBrokenIfStructTypeWill_Text { get; }
    public static string UsageOf_MayBeBrokenMethodCallOver_Can_Text { get; }
    public static string UsageOf_MayBeBrokenIfStructTypeWill_Text2 { get; }
    public static string UsageOf_WillBeBrokenAccessedExpression_Text { get; }
    public static string ReplacementOfTheFieldWithAPropertyWould_Text { get; }
    public static string BackingFieldIsUsedFromThe1Structure_Text { get; }
    public static string UnableToRemovePrimaryConstructorOf__Text { get; }
    public static string RemovalOfExplicitlyImplemented_Will_Text { get; }
    public static string _WillBeReplacedWithBackingFieldProperty_Text { get; }
    public static string RemovalOfExplicitPositionalMemberFor_Rebind_Text { get; }
    public static string RemovalOfExplicitPositionalMemberFor_Introduce_Text { get; }
    public static string __MightBeImpliclyUsedByTheCompilerGenerated_Text { get; }
    public static string __MightBeImplicitlyUsedByTheDefault_Text { get; }
    public static string MemberRemovalWillIntroduceImplicitProperty_Text { get; }
    public static string _CannotBeMadePublicThereIsAConflicting_Text { get; }
    public static string ParameterWillBeReplacedWithLocalVariable_Text { get; }
    public static string UnableToRemoveTheAccessorFrom_Positional_Text { get; }
    public static string RemovingLastDeconstructionComponent_Text { get; }
    public static string UnableToRemove0DeconstructionUsage_Text { get; }
    public static string RemovingDeconstructionComponentWillBreakComponent_Text { get; }
    public static string RemovingDeconstructionComponentWillBreakPattern_Text { get; }
    public static string RemovingOutArgumentWillBreakUsagesOf_Text { get; }
    public static string RemovingOutArgumentOf0UsageMayCause_Text { get; }
    public static string InstantiationCannotBeTransformedInto_Collection_Text { get; }
    public static string InstantiationCannotBeTransformedInto_Object_Text { get; }
    public static string InstantiationValueIsIgnoredCodeWould_Text { get; }
    public static string InstantiationCannotBeTransformedInto_Text { get; }
    public static string RefactoringWillChangeInitAccessorOf_Text { get; }
    public static string UnableToPartiallyEncapsulateField0Usage_Text { get; }
    public static string CanTUpdate0_EncapsulatedFieldWillBe_Text { get; }
    public static string Usage_Text { get; }
    public static string NameUsage_Text { get; }
    public static string ReadWriteUsage_Text { get; }
    public static string WriteUsage_Text { get; }
    public static string ReadUsage_Text { get; }
    public static string CanTUpdate0_EncapsulatedFieldWonTBe_Text { get; }
    public static string UsageOf_MayBeBrokenIfStructTypeWill_MutateVariable_Text { get; }
    public static string UsageOf_MayBeBrokenMethodCallOver_Can_MutateVariable_Text { get; }
    public static string Field_AccessWillBecomePolymorphic_Text { get; }
    public static string UnableToAddGetAccessorTo__Text { get; }
    public static string UnableToAddSetAccessorTo__Text { get; }
    public static string _IsNotDeclaredAbstractBodyWillBeRemoved_Text { get; }
    public static string _CannotBePlacedInTheInterface_Text { get; }
    public static string IntroduceSingleVariable__Text { get; }
    public static string ReplaceInitialExpressionOnly_Text { get; }
    public static string DeconstructInto_TextPrefix { get; }
    public static string CreateDeconstructingDeclaration_Text { get; }
    public static string Member_HasNotEnoughAccess_Text { get; }
    public static string Property_HasNotEnoughAccess_Text { get; }
    public static string Property_OverridingBaseClassProperty_Text { get; }
    public static string MemberHas1UsageInObjectInitializer_Text { get; }
    public static string _NeedsWiderAccess_Text { get; }
    public static string NoValidQualifierCanBeCreatedFor0Usage_Text { get; }
    public static string _HasBaseClassUsage_Text { get; }
    public static string TargetFieldNameWasNotSpecified_Text { get; }
    public static string MethodIsUsedFor0Unsubscribing_Text { get; }
    public static string CannotInlineUsageUnder0NameofOperator_Text { get; }
    public static string CannotConstructDelegateParameterTypes_Text { get; }
    public static string CannotInline0Usage_Text { get; }
    public static string UsageRequiresAStatementWhichCannot_Text { get; }
    public static string ConfigureAwait0CallWillNotBeTransferred_Text { get; }
    public static string TaskReturnedFromTheAsync0CallWillNo_Text { get; }
    public static string BecauseThe0CallIsNotAwaitedTheInlined_Text { get; }
    public static string CannotUseThrowExpressionInTarget0Context_Text { get; }
    public static string UnsafeCodeIsNotAllowedInAsyncFunctions_Text { get; }
    public static string UnsafeCodeIsNotAllowedInIterators_Text { get; }
    public static string _0_WillBeMadeUnsafeInOrderToInlineUnsafe_Text { get; }
    public static string CannotInlineAsynchronousCodeInNonAsync_Text { get; }
    public static string ConvertToGlobalUsingPageTitle_Text { get; }
    public static string ConvertToGlobalUsingPageDescription_Text { get; }
    public static string _FileName_Text { get; }
    public static string AmbiguousDeclarationsFor_ReferenceWere_Text { get; }
    public static string ConflictingDeclaration_WasFoundAlias_Text { get; }
    public static string ConflictingAliasUsingDirective_WasFound_Text { get; }
    public static string AmbiguousReference_WasFoundWhichCan_Text { get; }
    public static string AmbiguousReference_WillBeUpdated_Text { get; }
    public static string ConvertToGlobalUsing_Action_Text { get; }
    public static string ConvertToGlobalUsing_Text { get; }
    public static string ConvertToGlobalUsings_Action_Text { get; }
    public static string ConvertToGlobalUsings_Text { get; }
    public static string _Visibility_Text { get; }
    public static string Make_static_Text { get; }
    public static string MakeV_irtual_Text { get; }
    public static string TheNameWillBeCoercedDueToAConflictWith_Text { get; }
    public static string TheExtractedCodeCannotHaveAnyRefOut_Text { get; }
    public static string SetterWillBeAddedFor___Text { get; }
    public static string __CannotBeAssignedInTheExtractedCode_Text { get; }
    public static string DeterminingSearchDomainFor__Text { get; }
    public static string SearchingForUsages_Text { get; }
    public static string Inlining__Text { get; }
    public static string DeterminingImportScopes_Text { get; }
    public static string SearchingGlobalUsingDirectives_Text { get; }
    public static string RemovingGlobalUsingDirectives_Text { get; }
    public static string AddingImport_Text { get; }
    public static string _ExtractMethod_Text { get; }
    public static string ExtractMethod_Text { get; }
    public static string CreateNewMethodDeclarationBelowTheCurrent_Text { get; }
    public static string ExtractProperty_Text { get; }
    public static string CreatePropertyDeclarationBelowTheCurrent_Text { get; }
    public static string ExtractChainedConstructor_Text { get; }
    public static string CreateConstructorToDelegateInitialization_Text { get; }
    public static string ExtractLocalFunction_Text { get; }
    public static string CreateLocalFunctionInsideTheCurrent_Text { get; }
    public static string ExtractMethodObject_Text { get; }
    public static string ForLocalFunctionPlacement_Text { get; }
    public static string SelectScope_Text { get; }
    public static string ChooseWhereToPlaceTheNewLocalFunction_Text { get; }
    public static string TheExtractedCodeCannotReferenceName_Text { get; }
    public static string TheExtractedCodeWillReferenceNewElement_Text { get; }
    public static string CannotMove__Text { get; }
    public static string _WillBeMovedToTheExtractedCodeAlongside_Text { get; }
    public static string _WillBeMovedToTargetScopeAsItIsUsed_Text { get; }
    public static string _WillBeConvertedToARegularMethodAsIt_Text { get; }
    public static string SourceFunctionCannotReference__Text { get; }
    public static string TheExtractedCodeCannotReference__Text { get; }
    public static string _HasUnresolvedTypeOfParametersMethod_Text { get; }
    public static string _CanTBeTransformedCorrectlyDueToLanguage_Text { get; }
    public static string Existing0AutoPropertyWillBeBroken_Text { get; }
    public static string MemberCanTHaveTheSameNameAsEnclosing_Text { get; }
    public static string GenericParametersCannotBeUsedIn0Method_Text { get; }
    public static string ReturnedValueOf0CallIsNotUsed_Text { get; }
    public static string _IsUsedWithUnpresentableType_Text { get; }
    public static string CannotIntroduceVariableForReturnValue_Text { get; }
    public static string CannotReplaceDeclarationExpressionVariable_Text { get; }
    public static string IntroducedRefTempVariableWillRequire_Text { get; }
    public static string CutDeclarations_Of__Text { get; }
    public static string StoringReferences_Text { get; }
    public static string PasteDeclarationsTo__Of__Text { get; }
    public static string OnlyAbstractDeclarationsCanBeMovedTo_Text { get; }
    public static string UpdatingReferences_Text { get; }
    public static string InstantiationOfTargetClass_WillBeBroken_Text { get; }
    public static string CCodeFilesShouldBeUnderAppCodeFolder_Text { get; }
    public static string NodeBecameInvalid_Text { get; }
    public static string CreateDefaultParameter_In___Text { get; }
    public static string CreateParameter_InPrimaryConstructor___Text { get; }
    public static string Parameter_CreatedIn___Text { get; }
    public static string TheExtractedCodeHasMultipleExits_Text { get; }
    public static string The_ConstantWillBeConvertedToARegular_Text { get; }
    public static string UsageOf_InConstantContextWillBecome_Text { get; }
    public static string ToConvert_PropertyShouldBeNamedItem_Text { get; }
    public static string ParameterOfMethodCanTHaveRefOrOutModifiers_Text { get; }
    public static string ThisUsage0CanTBeResolved_Text { get; }
    public static string ThereExistsSourceClassObjectCreation_Text { get; }
    public static string ThereIsAmbiguousConstructorReference_Text { get; }
    public static string CallerCannotBeNull_Text { get; }
    public static string FieldWillBeEncapsulated_Text { get; }
    public static string SignatureChangeConflictsWithSignature_Text { get; }
    public static string NullPassedAsInstanceParameter_Text { get; }
    public static string CannotAccessParameterType_InInstance_Text { get; }
    public static string FixCannotBeCreated_Text { get; }
    public static string Invalid_Text { get; }
    public static string DefaultParameterValueIsUsed__Text { get; }
    public static string InvalidValue_Text { get; }
    public static string UseDefaultParameterValue__Text { get; }
    public static string ProcessTupleComponent_Text { get; }
    public static string ProcessTupleTypeComponent_Text { get; }
    public static string ConditionalInvocationOfExtensionMethod_Text { get; }
    public static string CannonMakeClass_StaticInstanceConstructor_Text { get; }
    public static string FieldInitializerWillNotBeMovedFor__Text { get; }
    public static string TypeSystemFuncIsNotAvailable_Text { get; }
    public static string IntroducePartOfAQueryExpression_Text { get; }
    public static string IntroduceVariableForSubstring_Text { get; }
    public static string ChangeNullability_Text { get; }
    public static string _IsAMethodGroup_Text { get; }
    public static string UsagesOfLocalFunction0_WillBecomeInvalid_Text { get; }
    public static string TypeOfOutVariable_CannotBeUsedAtThe_Text { get; }
    public static string CannotReplaceNameofArgumentWithDefault_Text { get; }
    public static string CannotReplaceNameofArgumentWithArgument_Text { get; }
    public static string ExtractedCodeCannotReference_ForRecursive_Text { get; }
    public static string _CannotBeReferencedInSourceFunction_Text { get; }
    public static string CreateField_InType__Text { get; }
    public static string NewField_CreatedInType__Text { get; }
    public static string InvalidFieldName_Text { get; }
    public static string InvalidType_Text { get; }
    public static string Unknown_Text { get; }
    public static string None_Text { get; }
    public static string Optional_Text { get; }
    public static string AtTheBeginningOfTopLevelStatements_Text { get; }
    public static string AtTheBeginningOf__Text { get; }
    public static string AtTheEndOfTopLevelStatements_Text { get; }
    public static string AtTheEndOf__Text { get; }
    public static string BeforeTopLevelStatements_Text { get; }
    public static string Before__Text { get; }
    public static string AfterTopLevelStatements_Text { get; }
    public static string After__Text { get; }
    public static string Name_Column_Text { get; }
    public static string Modifier_Column_Text { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get_CannotRenameIndexers_Text();
    public static string get_TransformParameters_Conflict_CannotCreateVariable_Text();
    public static string get_TransformParameters_Conflict_CannotCreateVariableOfType_Text();
    public static string get_ConvertToGlobalUsing_DirectiveColumn_Text();
    public static string get_ConvertToGlobalUsing_AddingGlobalUsingDirective_Text();
    public static string get_ConvertToGlobalUsing_AnalyzingUsings_Text();
    public static string get_ChangeNullabilityActionText();
    public static string get_ConvertToGlobalUsing_CheckingConflicts_Text();
    public static string get_ExtractMethod_PositionSelectorInlayHint_Text();
    public static string get_ExtractMethod_PositionSelectorTooltip();
    public static string get_ExtractMethod_MovedLocalFunctionHint();
    public static string get_ExtractMethod_LocalFunctionSelector_EditorAdornment_Title();
    public static string get_ExtractMethod_LocalFunctionSelector_EditorAdornment_Text();
    public static string get_ExtractMethod_LocalFunctionSelector_EditorAdornment_NextButtonText();
    public static string get_ExtractMethod_LocalFunctionSelector_EditorAdornment_MoveUpButtonTooltip();
    public static string get_ExtractMethod_LocalFunctionSelector_EditorAdornment_MoveDownButtonTooltip();
    public static string get_ExtractMethod_LocalFunctionSelector_EditorAdornment_CancelButtonTooltip();
    public static string get_ConvertToGlobalUsing_FindingUsingDirectivesToRemove_Text();
    public static string get_GlobalUsingDirectivesComment_Text();
    public static string get_ConvertToGlobalUsing_StatisticsColumn_Text();
    public static string get_ConvertToGlobalUsing_StatisticsTooltip_Text();
    public static string get_ConvertToNonGlobalUsing_Action_Text();
    public static string get_ConvertToNonGlobalUsing_Text();
    public static string get_MaKeStatic_Text();
    public static string get_ConvertToGlobalUsing_RemovingUsingDirectives_Text();
    public static string get_ConvertToGlobalUsing_RemoveUsingDirective_X_Of_N_Text();
    public static string get_ConvertToGlobalUsing_SelectedUsings_Text();
    public static string get_ConvertToGlobalUsing_TopUsingsInProject_Text();
    public static string get_Optional__Text();
    public static string get_DelegateViaOverloading_CSharp8_Text();
    public static string get_PropertyAccessorsCannotBeRenamed_Text();
    public static string get_RecordTypeImplicitMemberCouldNotBeRenamed_Text();
    public static string get_TypeCannotBeResolved_Text();
    public static string get_TypeNameShouldnTBeEmpty_Text();
    public static string get_UsingDeclarationConflict_Text();
    public static string get_UsingStatisticsProcessor_ScanningFile_Text();
    public static string get_VariableDoesnTHaveInitializer_Text();
    public static string get_VariableDoesnTHaveDeclarationsInSource_Text();
    public static string get_CannotRunControlFlowAnalysisFromThis_Text();
    public static string get_AssignedValueHasNoReachableUsages_Text();
    public static string get_VariableHasUnsupportedInitializer_Text();
    public static string get_VariableHasUnsupportedUsageKind_Text();
    public static string get_VariableHasWriteUsages_Text();
    public static string get_CannotIntroduceVariableFromTheSelected_Text();
    public static string get_CannotIntroduceVariable_Text();
    public static string get_ApplyNullabilityChange_Text();
    public static string get_MakeNullable_Text();
    public static string get_InitOnlyProperty_WillBecomeMutable_Text();
    public static string get_PropertyWithFieldKeywordWillBeTransformed_Text();
    public static string get_UsageWillBeTransformedButTransformation_Text();
    public static string get_CanTOverridePropertyWithAutoProperty_Text();
    public static string get_Attribute0_OfTheFieldDeclarationCannot_Text();
    public static string get_Attribute0_OfTheFieldDeclarationWill_Text();
    public static string get_NewAccessorIntroductionInVirtual_Can_Text();
    public static string get_AutoPropertyWillAlsoOverride__Text();
    public static string get_NewAccessorIntroductionIsNotAllowed_Text();
    public static string get_NewAccessorIntroductionIsNotAllowedInExplicitImplementation_Text();
    public static string get_InitializerExpressionIsOverwritten_Text();
    public static string get_Field0InitializerWillBeReplacedWith_Text();
    public static string get_BackingField_AccessWillBecomePolymorphic_Text();
    public static string get_InitOnlyPropertyWillBecomeMutableTo_Text();
    public static string get_CapturedField_NameWillBeReplacedWith_Text();
    public static string get_UsageOf_MayBeBrokenIfStructTypeWill_Text();
    public static string get_UsageOf_MayBeBrokenMethodCallOver_Can_Text();
    public static string get_UsageOf_MayBeBrokenIfStructTypeWill_Text2();
    public static string get_UsageOf_WillBeBrokenAccessedExpression_Text();
    public static string get_ReplacementOfTheFieldWithAPropertyWould_Text();
    public static string get_BackingFieldIsUsedFromThe1Structure_Text();
    public static string get_UnableToRemovePrimaryConstructorOf__Text();
    public static string get_RemovalOfExplicitlyImplemented_Will_Text();
    public static string get__WillBeReplacedWithBackingFieldProperty_Text();
    public static string get_RemovalOfExplicitPositionalMemberFor_Rebind_Text();
    public static string get_RemovalOfExplicitPositionalMemberFor_Introduce_Text();
    public static string get___MightBeImpliclyUsedByTheCompilerGenerated_Text();
    public static string get___MightBeImplicitlyUsedByTheDefault_Text();
    public static string get_MemberRemovalWillIntroduceImplicitProperty_Text();
    public static string get__CannotBeMadePublicThereIsAConflicting_Text();
    public static string get_ParameterWillBeReplacedWithLocalVariable_Text();
    public static string get_UnableToRemoveTheAccessorFrom_Positional_Text();
    public static string get_RemovingLastDeconstructionComponent_Text();
    public static string get_UnableToRemove0DeconstructionUsage_Text();
    public static string get_RemovingDeconstructionComponentWillBreakComponent_Text();
    public static string get_RemovingDeconstructionComponentWillBreakPattern_Text();
    public static string get_RemovingOutArgumentWillBreakUsagesOf_Text();
    public static string get_RemovingOutArgumentOf0UsageMayCause_Text();
    public static string get_InstantiationCannotBeTransformedInto_Collection_Text();
    public static string get_InstantiationCannotBeTransformedInto_Object_Text();
    public static string get_InstantiationValueIsIgnoredCodeWould_Text();
    public static string get_InstantiationCannotBeTransformedInto_Text();
    public static string get_RefactoringWillChangeInitAccessorOf_Text();
    public static string get_UnableToPartiallyEncapsulateField0Usage_Text();
    public static string get_CanTUpdate0_EncapsulatedFieldWillBe_Text();
    public static string get_Usage_Text();
    public static string get_NameUsage_Text();
    public static string get_ReadWriteUsage_Text();
    public static string get_WriteUsage_Text();
    public static string get_ReadUsage_Text();
    public static string get_CanTUpdate0_EncapsulatedFieldWonTBe_Text();
    public static string get_UsageOf_MayBeBrokenIfStructTypeWill_MutateVariable_Text();
    public static string get_UsageOf_MayBeBrokenMethodCallOver_Can_MutateVariable_Text();
    public static string get_Field_AccessWillBecomePolymorphic_Text();
    public static string get_UnableToAddGetAccessorTo__Text();
    public static string get_UnableToAddSetAccessorTo__Text();
    public static string get__IsNotDeclaredAbstractBodyWillBeRemoved_Text();
    public static string get__CannotBePlacedInTheInterface_Text();
    public static string get_IntroduceSingleVariable__Text();
    public static string get_ReplaceInitialExpressionOnly_Text();
    public static string get_DeconstructInto_TextPrefix();
    public static string get_CreateDeconstructingDeclaration_Text();
    public static string get_Member_HasNotEnoughAccess_Text();
    public static string get_Property_HasNotEnoughAccess_Text();
    public static string get_Property_OverridingBaseClassProperty_Text();
    public static string get_MemberHas1UsageInObjectInitializer_Text();
    public static string get__NeedsWiderAccess_Text();
    public static string get_NoValidQualifierCanBeCreatedFor0Usage_Text();
    public static string get__HasBaseClassUsage_Text();
    public static string get_TargetFieldNameWasNotSpecified_Text();
    public static string get_MethodIsUsedFor0Unsubscribing_Text();
    public static string get_CannotInlineUsageUnder0NameofOperator_Text();
    public static string get_CannotConstructDelegateParameterTypes_Text();
    public static string get_CannotInline0Usage_Text();
    public static string get_UsageRequiresAStatementWhichCannot_Text();
    public static string get_ConfigureAwait0CallWillNotBeTransferred_Text();
    public static string get_TaskReturnedFromTheAsync0CallWillNo_Text();
    public static string get_BecauseThe0CallIsNotAwaitedTheInlined_Text();
    public static string get_CannotUseThrowExpressionInTarget0Context_Text();
    public static string get_UnsafeCodeIsNotAllowedInAsyncFunctions_Text();
    public static string get_UnsafeCodeIsNotAllowedInIterators_Text();
    public static string get__0_WillBeMadeUnsafeInOrderToInlineUnsafe_Text();
    public static string get_CannotInlineAsynchronousCodeInNonAsync_Text();
    public static string get_ConvertToGlobalUsingPageTitle_Text();
    public static string get_ConvertToGlobalUsingPageDescription_Text();
    public static string get__FileName_Text();
    public static string get_AmbiguousDeclarationsFor_ReferenceWere_Text();
    public static string get_ConflictingDeclaration_WasFoundAlias_Text();
    public static string get_ConflictingAliasUsingDirective_WasFound_Text();
    public static string get_AmbiguousReference_WasFoundWhichCan_Text();
    public static string get_AmbiguousReference_WillBeUpdated_Text();
    public static string get_ConvertToGlobalUsing_Action_Text();
    public static string get_ConvertToGlobalUsing_Text();
    public static string get_ConvertToGlobalUsings_Action_Text();
    public static string get_ConvertToGlobalUsings_Text();
    public static string get__Visibility_Text();
    public static string get_Make_static_Text();
    public static string get_MakeV_irtual_Text();
    public static string get_TheNameWillBeCoercedDueToAConflictWith_Text();
    public static string get_TheExtractedCodeCannotHaveAnyRefOut_Text();
    public static string get_SetterWillBeAddedFor___Text();
    public static string get___CannotBeAssignedInTheExtractedCode_Text();
    public static string get_DeterminingSearchDomainFor__Text();
    public static string get_SearchingForUsages_Text();
    public static string get_Inlining__Text();
    public static string get_DeterminingImportScopes_Text();
    public static string get_SearchingGlobalUsingDirectives_Text();
    public static string get_RemovingGlobalUsingDirectives_Text();
    public static string get_AddingImport_Text();
    public static string get__ExtractMethod_Text();
    public static string get_ExtractMethod_Text();
    public static string get_CreateNewMethodDeclarationBelowTheCurrent_Text();
    public static string get_ExtractProperty_Text();
    public static string get_CreatePropertyDeclarationBelowTheCurrent_Text();
    public static string get_ExtractChainedConstructor_Text();
    public static string get_CreateConstructorToDelegateInitialization_Text();
    public static string get_ExtractLocalFunction_Text();
    public static string get_CreateLocalFunctionInsideTheCurrent_Text();
    public static string get_ExtractMethodObject_Text();
    public static string get_ForLocalFunctionPlacement_Text();
    public static string get_SelectScope_Text();
    public static string get_ChooseWhereToPlaceTheNewLocalFunction_Text();
    public static string get_TheExtractedCodeCannotReferenceName_Text();
    public static string get_TheExtractedCodeWillReferenceNewElement_Text();
    public static string get_CannotMove__Text();
    public static string get__WillBeMovedToTheExtractedCodeAlongside_Text();
    public static string get__WillBeMovedToTargetScopeAsItIsUsed_Text();
    public static string get__WillBeConvertedToARegularMethodAsIt_Text();
    public static string get_SourceFunctionCannotReference__Text();
    public static string get_TheExtractedCodeCannotReference__Text();
    public static string get__HasUnresolvedTypeOfParametersMethod_Text();
    public static string get__CanTBeTransformedCorrectlyDueToLanguage_Text();
    public static string get_Existing0AutoPropertyWillBeBroken_Text();
    public static string get_MemberCanTHaveTheSameNameAsEnclosing_Text();
    public static string get_GenericParametersCannotBeUsedIn0Method_Text();
    public static string get_ReturnedValueOf0CallIsNotUsed_Text();
    public static string get__IsUsedWithUnpresentableType_Text();
    public static string get_CannotIntroduceVariableForReturnValue_Text();
    public static string get_CannotReplaceDeclarationExpressionVariable_Text();
    public static string get_IntroducedRefTempVariableWillRequire_Text();
    public static string get_CutDeclarations_Of__Text();
    public static string get_StoringReferences_Text();
    public static string get_PasteDeclarationsTo__Of__Text();
    public static string get_OnlyAbstractDeclarationsCanBeMovedTo_Text();
    public static string get_UpdatingReferences_Text();
    public static string get_InstantiationOfTargetClass_WillBeBroken_Text();
    public static string get_CCodeFilesShouldBeUnderAppCodeFolder_Text();
    public static string get_NodeBecameInvalid_Text();
    public static string get_CreateDefaultParameter_In___Text();
    public static string get_CreateParameter_InPrimaryConstructor___Text();
    public static string get_Parameter_CreatedIn___Text();
    public static string get_TheExtractedCodeHasMultipleExits_Text();
    public static string get_The_ConstantWillBeConvertedToARegular_Text();
    public static string get_UsageOf_InConstantContextWillBecome_Text();
    public static string get_ToConvert_PropertyShouldBeNamedItem_Text();
    public static string get_ParameterOfMethodCanTHaveRefOrOutModifiers_Text();
    public static string get_ThisUsage0CanTBeResolved_Text();
    public static string get_ThereExistsSourceClassObjectCreation_Text();
    public static string get_ThereIsAmbiguousConstructorReference_Text();
    public static string get_CallerCannotBeNull_Text();
    public static string get_FieldWillBeEncapsulated_Text();
    public static string get_SignatureChangeConflictsWithSignature_Text();
    public static string get_NullPassedAsInstanceParameter_Text();
    public static string get_CannotAccessParameterType_InInstance_Text();
    public static string get_FixCannotBeCreated_Text();
    public static string get_Invalid_Text();
    public static string get_DefaultParameterValueIsUsed__Text();
    public static string get_InvalidValue_Text();
    public static string get_UseDefaultParameterValue__Text();
    public static string get_ProcessTupleComponent_Text();
    public static string get_ProcessTupleTypeComponent_Text();
    public static string get_ConditionalInvocationOfExtensionMethod_Text();
    public static string get_CannonMakeClass_StaticInstanceConstructor_Text();
    public static string get_FieldInitializerWillNotBeMovedFor__Text();
    public static string get_TypeSystemFuncIsNotAvailable_Text();
    public static string get_IntroducePartOfAQueryExpression_Text();
    public static string get_IntroduceVariableForSubstring_Text();
    public static string get_ChangeNullability_Text();
    public static string get__IsAMethodGroup_Text();
    public static string get_UsagesOfLocalFunction0_WillBecomeInvalid_Text();
    public static string get_TypeOfOutVariable_CannotBeUsedAtThe_Text();
    public static string get_CannotReplaceNameofArgumentWithDefault_Text();
    public static string get_CannotReplaceNameofArgumentWithArgument_Text();
    public static string get_ExtractedCodeCannotReference_ForRecursive_Text();
    public static string get__CannotBeReferencedInSourceFunction_Text();
    public static string get_CreateField_InType__Text();
    public static string get_NewField_CreatedInType__Text();
    public static string get_InvalidFieldName_Text();
    public static string get_InvalidType_Text();
    public static string get_Unknown_Text();
    public static string get_None_Text();
    public static string get_Optional_Text();
    public static string get_AtTheBeginningOfTopLevelStatements_Text();
    public static string get_AtTheBeginningOf__Text();
    public static string get_AtTheEndOfTopLevelStatements_Text();
    public static string get_AtTheEndOf__Text();
    public static string get_BeforeTopLevelStatements_Text();
    public static string get_Before__Text();
    public static string get_AfterTopLevelStatements_Text();
    public static string get_After__Text();
    public static string get_Name_Column_Text();
    public static string get_Modifier_Column_Text();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.CSharp.SafeDeleteFolder.CSharpSafeDeleteFolderHelper : SafeDeleteFolderLanguageSpecific {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual IList`1<IDeclaredElement> GetExternalDeclaredElements(IFile file);
    private void ProcessTopClasses(ICSharpTypeAndNamespaceHolderDeclaration holder, List`1<ITypeElement> ret);
    public virtual IEnumerable`1<ITreeNode> GetUsingsFromFile(IFile file, IList`1<INamespace> namespaces);
    public virtual void RemoveUsing(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.CSharp.SafeDeleteTheSecond.CSharpSafeDelete : SafeDeleteBase {
    public CSharpSafeDelete(SafeDeleteWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void RemoveDeclaration(IDeclaration declaration);
    private void ReportExplicitMemberRemoval(IParameter parameter);
    private void CheckMemberOfEqualityOrToStringImplementations(ITypeMember typeMember, IDeclaredElement declaringElement);
    private void CheckQuasiImplementedPositionalPropertiesConflicts(ITypeMember typeMember);
    private static bool CanRemoveContainingTypeAndNamespaceHolder(ICSharpTypeAndNamespaceHolderDeclaration typeAndNamespaceHolder, ICSharpTypeAndNamespaceHolderDeclaration& containingHolder);
    private static bool CanRemoveFile(ICSharpFile file);
    public virtual void RemoveTypeParameterDeclaration(IDeclaration declaration);
    public virtual void MakeVirtual(IDeclaration declaration, bool sealedType);
    public virtual void SetBaseTypes(IDeclaration declaration, IDeclaredType baseClass, IList`1<IDeclaredType> allSuperTypes, ITypeElement baseElementToRemove);
    public virtual bool IsReferenceOnConstructor(IReference reference);
    public virtual bool RemoveCallToBaseMethod(IReference reference);
    public virtual bool ReplaceExplicitImplementation(IReference reference);
    public virtual void ReplaceExplicitImplementation(IDeclaration declaration);
    public virtual bool CanRemoveExpression(IExpression expression);
    public virtual bool RemoveExpression(IExpression expression);
    private Action TryRemoveExpression(IExpression expression);
    public virtual void ReplaceParameterWithLocalVariable(IDeclaration declaration);
    public virtual IList`1<IArgument> GetArgumentsToRemove(IReference reference, IParametersOwner owner, IParameter parameter);
    public virtual bool IsExtensionCall(IReference reference);
    public virtual bool IsMethodGroup(IReference reference);
    public virtual void RemoveImplicitAccessor(IAccessor accessor);
    public virtual bool RemoveInvocationStatement(IReference reference);
    public virtual void RemoveArgument(IReference reference, ArgumentRemover remover, PerReferenceData data);
    public virtual bool WillExistsAfterLastParameterRemoval(IParametersOwner parametersOwner);
    private void RemoveDeconstructionComponent(IReference reference, int componentIndex);
    private void RemoveOutArgument(ICSharpArgumentsOwner owner, ICSharpArgument argument);
    public virtual bool IsPartial(IMethod method);
    public virtual void TryRemoveNullChecking(IDeclaration declaration);
    public virtual bool RemoveReference(IReference reference);
    public virtual bool RemoveSubscription(IReference reference);
    public virtual bool IsSingleAndCallsToBase(IConstructor constructor);
    public virtual void SaveUnusedUsings(IFile file);
    public virtual void RemoveNewRedundantUsings(IFile file, HashSet`1<ITreeNode> oldUsings, IProgressIndicator progress);
    private static bool IsNullCheck(ICSharpStatement statement, IParameter parameter);
    [CompilerGeneratedAttribute]
internal static bool <CheckMemberOfEqualityOrToStringImplementations>g__StructTypeHasNonOverridenEqualityMembers|3_0(IStruct structType);
    [CompilerGeneratedAttribute]
internal static bool <CheckMemberOfEqualityOrToStringImplementations>g__RecordTypeHasImplicitMembersAccessingState|3_1(IRecord recordType);
    [CompilerGeneratedAttribute]
private void <ReplaceParameterWithLocalVariable>g__InsertVariableDeclaration|17_0(IExpressionBodyOwnerDeclaration bodyOwnerDeclaration, <>c__DisplayClass17_0& );
    [CompilerGeneratedAttribute]
private void <RemoveDeconstructionComponent>g__CheckUsedDeclaredVariable|25_0(ICSharpExpression expression);
    [CompilerGeneratedAttribute]
private void <RemoveDeconstructionComponent>g__CheckUsedPatternVariables|25_1(IPattern pattern);
    [CompilerGeneratedAttribute]
private void <RemoveDeconstructionComponent>g__CheckUsedDesignations|25_2(IVariableDesignation designation);
}
public class JetBrains.ReSharper.Refactorings.CSharp.SafeDeleteTheSecond.CSharpSafeDeleteHelper : SafeDeleteHelperUnsupported {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual bool CanBeRemoved(IDeclaredElement element);
    public virtual bool CanBeRemoved(IDeclaration declaration);
    public virtual bool IsBaseClassSpecifier(IReference reference);
    public virtual bool IsInterfaceImplementationSpecifier(IReference reference);
    public virtual IEnumerable`1<ITreeNode> GetUsingsFromFile(IFile file, IList`1<INamespace> namespaces);
    public virtual void RemoveUsing(ITreeNode element);
    public virtual IDeclaredElement GetActualElementToRemove(IDeclaredElement declaredElement);
    public virtual bool IsRemovableImplicitElement(IDeclaredElement declaredElement);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.CSharp.SafeDeleteTheSecond.CSharpSafeDeleteHelper/<GetDependentElementToRemove>d__10")]
public virtual IEnumerable`1<IDeclaredElement> GetDependentElementToRemove(IDeclaredElement declaredElement, IProgressIndicator pi);
    public virtual bool IsTypeDefinitelyNotAloneInFile(ITypeElement typeElement);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Static2Extension.CsStatic2Extension : Static2ExtensionBase {
    public CsStatic2Extension(Static2ExtensionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void MakeCallExtension(IReference reference);
    public virtual void MakeCallPlainStatic(IReference reference);
    [PureAttribute]
private ParameterKind GetThisParameterKind();
}
public class JetBrains.ReSharper.Refactorings.CSharp.TransformParameters.CsTransformParameters : TransformParametersBase {
    public static string TUPLE_METHOD_CREATE;
    [CompilerGeneratedAttribute]
private TransformParametersDataModel <DataModel>k__BackingField;
    public TransformParametersDataModel DataModel { get; public set; }
    public CsTransformParameters(TransformParametersWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public TransformParametersDataModel get_DataModel();
    [CompilerGeneratedAttribute]
public void set_DataModel(TransformParametersDataModel value);
    public virtual PreProcessedCall PreProcessCall(IReference reference);
    public virtual void FixUsage(PreProcessedCall call, string name);
    [CanBeNullAttribute]
private static ICSharpArgumentsOwner EnsureExpressionInStatementsOwner(ICSharpArgumentsOwner csArgumentsOwner, ICSharpStatement& containingStatement, IStatementsOwner& statementsOwner);
    private void ReplaceInvocation(PreProcessedCall call, ICSharpStatement markerStatement, IStatementsOwner statementsOwner, string name, ICSharpArgumentsOwner csArgumentsOwner);
    private void ProcessArguments(PreProcessedCall call, ICSharpArgumentsOwner csArgumentsOwner, ICSharpExpression expression, CSharpElementFactory factory);
    public void JoinDeclarationsAndAssignments(IDeclaration method, ICollection`1<IStatement> statementsToUse);
    private ICSharpExpression ReturnValueCreationExpression(IPsiModule module, IList`1<ICSharpExpression> parameters, ISubstitution substitution, ITypeEntity entity);
    [CanBeNullAttribute]
private ICSharpExpression ReturnValueCreationExpression(IPsiModule module, ICSharpExpression previousReturnExpr, IEnumerable`1<ICSharpExpression> outParamReferences, OutTypeInfo outTypeInfo, ISubstitution substitution);
    public virtual void TransformDeclaration(IParametersOwner method, IRefactoringDriver driver, ISubstitution substsOfOverrides);
    private void ProcessReturnStatements(IParametersOwner method, IBlock body, IParametersOwnerDeclaration declaration, CSharpElementFactory factory, List`1<IParameterDeclaration> outParameterDeclarations, ISubstitution substsOfOverrides);
    private void ProcessReturnType(IParametersOwnerDeclaration decl, ISubstitution substsOfOverrides);
    private void ProcessParameters(ISubstitution substsOfOverrides, IParametersOwnerDeclaration declaration);
    private ICSharpExpression ContainingExpression(ITreeNode expr);
    private bool ReferenceCanBeTransformed(ICSharpArgumentsOwner invocationExpression, ICSharpStatement& containingStatement);
    [CanBeNullAttribute]
private ICSharpExpression GetNewExpression(PreProcessedCall call, ICSharpArgumentsOwner owner, ISubstitution substitution, string name, CSharpElementFactory factory, ITypeEntity typeEntity, bool returnTypeIsSimpleType);
    public virtual bool IsPureRecursiveCall(IReference reference);
    private static void Transform(IReference reference, string property, IParameter parameter);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Type2Partial.CSharpType2PartialHelper : object {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual ITypeDeclaration AddNewTypePart(Type2PartialDataModel model, ITreeNode& formatRoot);
    public virtual string GetExtension();
    public virtual TreeTextRange AdjustSelectedRange(IFile psiFile, TreeTextRange treeTextRange, String& partName);
    public virtual bool IsAvailableForTypeElement(ITypeElement typeElement, IPsiSourceFile psiSourceFile);
    public virtual bool CanSuggestProjectFile(IProjectFile projectFile);
    [NotNullAttribute]
private static ICSharpTypeAndNamespaceHolderDeclaration GetCSharpTypeAndNamespaceHolderDeclaration(CSharpElementFactory elementFactory, INamespaceDeclaration typeNamespace, ICSharpTypeAndNamespaceHolderDeclaration namespaceHolder);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Type2Partial.CSharpType2PartialRegionUtil : object {
    public static void MoveMembersWithRegions(IClassLikeDeclaration typeDeclaration, Type2PartialDataModel model, IClassLikeDeclaration createdDeclaration);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IList`1<NodeMoveInfo> MovePreprocessingDirectives(ITypeDeclaration typeDeclaration, IList`1<IDeclaration> movedDeclarations);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IList`1<NodeMoveInfo> ProcessRegion(IStartRegion startRegion, Queue`1<ITreeNode> elements, JetHashSet`1<IDeclaration> selectedDeclarations, Boolean& canRemoveRegion);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Type2Partial.CSharpType2PartialTypeHierarchyBuilder : CSharpTypeHierarchyBuilderBase {
    [NotNullAttribute]
private Type2PartialDataModel myModel;
    [NotNullAttribute]
private IClassLikeDeclaration myClassLikeDeclaration;
    public CSharpType2PartialTypeHierarchyBuilder(Type2PartialDataModel model, IClassLikeDeclaration classLikeDeclaration);
    [NotNullAttribute]
public ITypeDeclaration AddTypePart(ICSharpTypeAndNamespaceHolderDeclaration parent, ITreeNode& formatRoot);
    protected virtual ICSharpTypeDeclaration AddTypeDeclaration(IClassLikeDeclaration leafDeclaration);
}
public class JetBrains.ReSharper.Refactorings.CSharp.UseBaseType.CsConstraintSearcherUtil : ConstraintSearcherUtil {
    private UseBaseTypeRefactoring myExecuter;
    private GraphBuilder Builder { get; }
    public CsConstraintSearcherUtil(UseBaseTypeRefactoring executer);
    private GraphBuilder get_Builder();
    public virtual bool TryFindTypeMemberConstraint(ITreeNode preparedElement, ITypeMember& memberCalled, ExpressionAccessType& memberAccessType);
    public virtual bool TryFindArgumentConstraint(ITreeNode preparedElement, IParameter& parameter);
    public virtual bool TryFindSimpleReturnConstraint(ITreeNode preparedElement, ITypeMember& returnFromMember);
    public virtual bool TryFindAssignmentConstraint(ITreeNode preparedElement, IDeclaredElement& assignmentDest);
    public virtual bool TryFindInitializerConstraint(ITreeNode preparedElement, IDeclaredElement& initializedElement);
    public virtual void ProcessUp(ITreeNode directlyUsedElement, TypeElementUsage usage);
    public void ProcessUsagesOfLocalVariable(ILocalVariable localVariable, TypeElementUsage usage);
    public virtual ITreeNode GetDirectlyUsedElement(ITreeNode element);
    public virtual bool TryFindExtensionMethodConstraint(ITreeNode treeNode, IParameter& extensionParameter);
    private static ICSharpExpression SkipParenthesis(ICSharpExpression castExpression);
}
public class JetBrains.ReSharper.Refactorings.CSharp.UseBaseType.CSharpTypeUsageSearcherUtil : TypeUsageSearcherUtil {
    public virtual bool TryFindTypeParameterOwner(IReference reference, ITreeNode& typeUsageElement, ITypeParameter& parameter);
    public virtual bool TryFindDelegateDeclaration(IReference reference, ITypeElement& delegateElement);
    public virtual bool TryFindChilidTypeElement(IReference reference, ITypeElement& childTypeElement);
    public virtual bool TryFindConstrainedParameter(IReference reference, ITypeParameter& parameter);
    public virtual int GetArrayRank(ITreeNode typUsageElement);
}
public class JetBrains.ReSharper.Refactorings.CSharp.UseBaseType.CsUseBaseType : UseBaseTypeBase {
    private CSharpTypeUsageSearcherUtil myTypeUsagesUtil;
    private CsConstraintSearcherUtil myConstraintsUtil;
    public bool MethodGroupTypeMatch { get; }
    public CsUseBaseType(UseBaseTypeWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool get_MethodGroupTypeMatch();
    public virtual IDeclaredElement[] GetDeclaredElements(IReference reference);
    public virtual bool CheckConstraintElement(IDeclaredElement element);
    public virtual TypeUsageSearcherUtil GetTypeUsageSearcherUtil();
    public virtual ConstraintSearcherUtil GetConstraintSearcherUtil();
    public virtual IDeclaredElement GetDelegateDeclaration(ITreeNode directlyUsedElement);
    public virtual IReference BindUsage(IReference reference);
    public virtual void CreateAnonymousDelegateDependency(IParametersOwner owner, Node node, int index, IParameter& delegateParameter);
    public virtual bool GetConstructedExpression(IReference reference, IExpression& expression);
    public virtual bool GetCastExpressionExpression(IReference reference, IExpression& expression);
    public virtual bool GetTypeOfExpression(IReference reference, IExpression& expression);
    public virtual bool GetIsExpression(IReference reference, IExpression& expression);
}
public static class JetBrains.ReSharper.Refactorings.CSharp.Util.ClassLikeDeclarationReplacer : object {
    public static Tag Replace(IClassLikeDeclaration declaration, IClassLikeDeclaration newDecl, ReplaceActions action);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.CSharp.Util.CsConstructionUtil : ConstructionUtil {
    public virtual ITypeElement AddClassBefore(string className, IDeclaration tag, bool topLevel, bool isClass);
    public virtual ITypeElement AddClassBeforeFromMember(string className, ITypeMember typeMember, bool topLevel, bool isClass);
    public virtual bool CanChangeAccessRights(IDeclaredElement declaredElement);
    public virtual void SetAccessRights(IDeclaredElement owner, AccessRights rights);
    public virtual IDeclaration AddTypeParameter(ITypeElement class, string name, ITypeParameter originalTypeParameter);
    public virtual ITypeParameter AddTypeParameter(IDeclaration declaration, string shortName);
    public virtual IDeclaration AddField(ITypeElement class, NameRoot name, IType type, IDeclaration tag, AccessRights accessRights, JetHashSet`1<string> namesSet);
    public virtual IDeclaration AddProperty(ITypeElement class, IDeclaration fieldDeclaration, NameRoot basicName, IDeclaration tag, bool isWritable, AccessRights accessRights, JetHashSet`1<string> namesSet);
    public virtual IDeclaration AddEmptyConstructor(ITypeElement class, IDeclaration tag);
    public virtual void InitElementInConstructor(IDeclaration constructorDecl, IDeclaration field, IParameter name);
    public virtual void InitElementInConstructor(IDeclaration constructorDecl, IDeclaration fieldDecl, string name, DefaultValue defaultValue);
    public virtual IParameter AddFirstParameter(IParametersOwner owner, string name, IDeclaredType type);
    public virtual IParameter AddLastParameter(IParametersOwner owner, string name, IType type);
    public virtual IDeclaration AddAutoProperty(ITypeElement class, IType type, NameRoot basicName, IDeclaration tag, bool isWritable, AccessRights accessRights, JetHashSet`1<string> namesSet);
    [CanBeNullAttribute]
private static IParameter AddParameter(IParametersOwner owner, string name, IType type, bool isFirst);
    public virtual void RemoveParameter(IParametersOwner owner, IParameter parameter);
    public virtual void ChangeToOrFromExtension(IMethod method, bool addThis, IRefactoringDriver driver);
    public virtual ITypeMember AddTypeMemberDeclaration(ITypeElement element, IDeclaration declaration, IDeclaration tag, bool after);
    public virtual bool TryProcessMultiDeclarationForResolve(IRecursiveElementProcessor processor, IDeclaration declaration);
    public static bool TryProcessMultiDeclarationForResolve(IDeclaration declaration, IRecursiveElementProcessor collector);
    public virtual void RemoveTypeMember(ITypeMemberDeclaration member);
    public virtual void RemoveFunction(IDeclaration element);
    protected virtual bool IsInCollection(JetHashSet`1<string> namesSet, string fieldName);
    protected virtual void AddToCollection(JetHashSet`1<string> namesSet, string fieldName);
    [CompilerGeneratedAttribute]
internal static ITypeMember <AddTypeMemberDeclaration>g__DoAddMember|17_0(IClassLikeDeclaration classLikeDeclaration, IClassMemberDeclaration anchor, <>c__DisplayClass17_0& );
}
public class JetBrains.ReSharper.Refactorings.CSharp.Util.CSharpAbstractor : object {
    private IMoveMembersExecuter myExecuter;
    private IPsiModule myPsiModule;
    public CSharpAbstractor(IMoveMembersExecuter executer, IPsiModule psiModule);
    [CanBeNullAttribute]
public TDeclaration MakeDeclaration(IDeclaration initialDeclaration, bool makeAbstract);
    [CanBeNullAttribute]
public TDeclaration MakeDeclaration(IDeclaredElement declaredElement, bool makeAbstract);
    [NotNullAttribute]
private TDeclaration MakeField(IField field);
    [NotNullAttribute]
private TDeclaration MakeEvent(IEvent event, bool makeAbstract);
    [NotNullAttribute]
private TDeclaration MakeIndexer(IProperty property, bool makeAbstract);
    [CanBeNullAttribute]
private TDeclaration MakeProperty(IProperty property, bool makeAbstract);
    [NotNullAttribute]
private TDeclaration MakeMethod(IMethod method, bool makeAbstract);
    [NotNullAttribute]
private IType GetType(IType type);
    private void AddParameters(IParametersOwner method, ICSharpParametersOwnerDeclaration targetDeclaration);
    private void AddDocComments(ITypeMember typeMember, IDeclaration declaration);
}
public static class JetBrains.ReSharper.Refactorings.CSharp.Util.CSharpDeclarationsUtil : object {
    [CanBeNullAttribute]
public static IReadOnlyList`1<ITypeDeclaration> GetTopLevelTypeDeclarations(IFile file, Boolean& hasTopLevelCode);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.CSharp.Util.CSharpDeclarationsUtil/<GetDeclarationsFromFile>d__1")]
private static IEnumerable`1<ITypeDeclaration> GetDeclarationsFromFile(ICSharpTypeAndNamespaceHolderDeclaration holder);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Refactorings.CSharp.Util.CSharpInstanceObjectUsageChecker : object {
    public sealed virtual InstanceObjectUsageResult GetCheckResult(ITreeNode element);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Refactorings.CSharp.Util.CSharpLanguageSpecificProjectFileHandler : object {
    public sealed virtual void InitializeEmptyFile(IFile file);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.CSharp.Util.CSharpRefactoringDataConstantsService : object {
    public sealed virtual bool IsNameNodeSelected(ITreeNode node, DocumentRange documentRange);
}
public static class JetBrains.ReSharper.Refactorings.CSharp.Util.CSharpUnusedUsingsUtil : object {
    public static void RemoveNewUnusedUsings(IFile file, HashSet`1<ITreeNode> oldUnusedUsings);
    private static void RemoveUsingDirective(IUsingDirective usingDirective);
    public static void AddFileToUsingSaver(UnusedUsingSaver saver, IFile file);
    [CompilerGeneratedAttribute]
internal static bool <RemoveNewUnusedUsings>g__IsResolved|0_0(IUsingDirective usingDirective);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Refactorings.CSharp.Util.MethodAccessChecker : AccessRightsChecker {
    protected virtual IAccessContext BuildAccessContext(IReference reference, ITypeElement targetType, ITypeMember& accessedElement, AccessRights accessRights);
}
public class JetBrains.ReSharper.Refactorings.CSharp.Util.MethodGroupTransformer : object {
    [NotNullAttribute]
public static IInvocationExpression ReplaceMethodGroupWithAnonymousFunction(ICSharpExpression referenceExpression, IList`1<OriginalParameter> parameters, ISubstitution substitution, string parameterNameToRemove);
    private static IList`1<string> BakeArgumentNames(ICSharpExpression referenceExpression, IList`1<OriginalParameter> parameters);
}
public static class JetBrains.ReSharper.Refactorings.CSharp.Util.QuerySelectionUtil : object {
    public static SubQuerySelection GetSelectedExpression(ISolution solution, ITextControl textControl);
    private static SubQuerySelection GetExpression(ISolution solution, ITextControl textControl, TextRange range);
    private static SubQuerySelection GetExpressionInRange(IFile file, DocumentRange range);
    private static IFile GetPsiFileFromDocument(ISolution solution, DocumentRange documentRange);
}
public abstract class JetBrains.ReSharper.Refactorings.CSharp.Util.RDInspectorOfVariable`1 : ControlFlowGraphInspector`1<TInspectorContext> {
    private ITypeOwner myElement;
    private JetHashSet`1<ITreeNode> myDelayedAssignments;
    protected RDInspectorOfVariable`1(ControlFlowGraph controlFlowGraph, ITypeOwner element, IControlFlowContextFactory`1<TInspectorContext> factory);
    protected virtual void InspectLeafElementAndSetContextToExits(IControlFlowElement controlFlowElement, TInspectorContext context);
    protected abstract virtual bool CustomInspection(IControlFlowElement controlFlowElement, TInspectorContext context, ITreeNode element);
}
public enum JetBrains.ReSharper.Refactorings.CSharp.Util.ReplaceActions : Enum {
    public int value__;
    public static ReplaceActions Replace;
    public static ReplaceActions PlaceBefore;
    public static ReplaceActions PlaceAfter;
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Refactorings.CSharp.ZoneMarker : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
