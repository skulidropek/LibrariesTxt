[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
public class NuGet.ProjectModel.AssetsLogMessage : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningLevel <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LibraryId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <TargetGraphs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumnNumber>k__BackingField;
    public LogLevel Level { get; }
    public NuGetLogCode Code { get; }
    public string Message { get; }
    public string ProjectPath { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    public string FilePath { get; public set; }
    public string LibraryId { get; public set; }
    public IReadOnlyList`1<string> TargetGraphs { get; public set; }
    public int StartLineNumber { get; public set; }
    public int StartColumnNumber { get; public set; }
    public int EndLineNumber { get; public set; }
    public int EndColumnNumber { get; public set; }
    public AssetsLogMessage(LogLevel logLevel, NuGetLogCode errorCode, string errorString, string targetGraph);
    public AssetsLogMessage(LogLevel logLevel, NuGetLogCode errorCode, string errorString);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual NuGetLogCode get_Code();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectPath();
    [CompilerGeneratedAttribute]
public void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual WarningLevel get_WarningLevel();
    [CompilerGeneratedAttribute]
public void set_WarningLevel(WarningLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LibraryId();
    [CompilerGeneratedAttribute]
public void set_LibraryId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_TargetGraphs();
    [CompilerGeneratedAttribute]
public void set_TargetGraphs(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartLineNumber();
    [CompilerGeneratedAttribute]
public void set_StartLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartColumnNumber();
    [CompilerGeneratedAttribute]
public void set_StartColumnNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndLineNumber();
    [CompilerGeneratedAttribute]
public void set_EndLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndColumnNumber();
    [CompilerGeneratedAttribute]
public void set_EndColumnNumber(int value);
    public static IAssetsLogMessage Create(IRestoreLogMessage logMessage);
    public sealed virtual bool Equals(IAssetsLogMessage other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class NuGet.ProjectModel.BuildAction : ValueType {
    private static ConcurrentDictionary`2<string, BuildAction> _knownBuildActions;
    public static BuildAction None;
    public static BuildAction Compile;
    public static BuildAction Content;
    public static BuildAction EmbeddedResource;
    public static BuildAction ApplicationDefinition;
    public static BuildAction Page;
    public static BuildAction Resource;
    public static BuildAction SplashScreen;
    public static BuildAction DesignData;
    public static BuildAction DesignDataWithDesignTimeCreatableTypes;
    public static BuildAction CodeAnalysisDictionary;
    public static BuildAction AndroidAsset;
    public static BuildAction AndroidResource;
    public static BuildAction BundleResource;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsKnown>k__BackingField;
    public string Value { get; }
    public bool IsKnown { get; }
    private BuildAction(string value, bool isKnown);
    private static BuildAction();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Value();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsKnown();
    public static BuildAction Parse(string value);
    public virtual string ToString();
    public sealed virtual bool Equals(BuildAction other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(BuildAction left, BuildAction right);
    public static bool op_Inequality(BuildAction left, BuildAction right);
    public virtual int GetHashCode();
    private static BuildAction Define(string name);
}
public class NuGet.ProjectModel.BuildOptions : object {
    [CompilerGeneratedAttribute]
private string <OutputName>k__BackingField;
    public string OutputName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_OutputName();
    [CompilerGeneratedAttribute]
public void set_OutputName(string value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BuildOptions other);
    public BuildOptions Clone();
}
public class NuGet.ProjectModel.CacheFile : object {
    internal static int CurrentVersion;
    [CompilerGeneratedAttribute]
private string <DgSpecHash>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <ExpectedPackageFilePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IAssetsLogMessage> <LogMessages>k__BackingField;
    public string DgSpecHash { get; }
    public int Version { get; public set; }
    public bool Success { get; public set; }
    public IList`1<string> ExpectedPackageFilePaths { get; public set; }
    [ObsoleteAttribute("File existence checks are a function of time not the cache file content.")]
public bool HasAnyMissingPackageFiles { get; public set; }
    public string ProjectFilePath { get; public set; }
    public IList`1<IAssetsLogMessage> LogMessages { get; public set; }
    public bool IsValid { get; }
    public CacheFile(string dgSpecHash);
    [CompilerGeneratedAttribute]
public string get_DgSpecHash();
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public void set_Success(bool value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_ExpectedPackageFilePaths();
    [CompilerGeneratedAttribute]
public void set_ExpectedPackageFilePaths(IList`1<string> value);
    public bool get_HasAnyMissingPackageFiles();
    public void set_HasAnyMissingPackageFiles(bool value);
    [CompilerGeneratedAttribute]
public string get_ProjectFilePath();
    [CompilerGeneratedAttribute]
public void set_ProjectFilePath(string value);
    [CompilerGeneratedAttribute]
public IList`1<IAssetsLogMessage> get_LogMessages();
    [CompilerGeneratedAttribute]
public void set_LogMessages(IList`1<IAssetsLogMessage> value);
    public bool get_IsValid();
    public sealed virtual bool Equals(CacheFile other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class NuGet.ProjectModel.CacheFileFormat : object {
    private static string VersionProperty;
    private static string DGSpecHashProperty;
    private static string SuccessProperty;
    private static string ExpectedPackageFilesProperty;
    private static string ProjectFilePathProperty;
    public static CacheFile Read(Stream stream, ILogger log, string path);
    private static CacheFile Read(TextReader reader, ILogger log, string path);
    public static void Write(string filePath, CacheFile lockFile);
    public static void Write(Stream stream, CacheFile cacheFile);
    private static void Write(TextWriter textWriter, CacheFile cacheFile);
    private static CacheFile ReadCacheFile(JObject cursor);
    private static JObject GetCacheFile(CacheFile cacheFile);
    private static string ReadString(JToken json);
    private static JToken WriteString(string item);
    private static int ReadInt(JToken json);
    private static JToken WriteInt(int item);
    private static bool ReadBool(JToken json);
    private static JToken WriteBool(bool item);
}
public class NuGet.ProjectModel.CentralTransitiveDependencyGroup : object {
    [CompilerGeneratedAttribute]
private string <FrameworkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<LibraryDependency> <TransitiveDependencies>k__BackingField;
    public string FrameworkName { get; }
    public IEnumerable`1<LibraryDependency> TransitiveDependencies { get; }
    public CentralTransitiveDependencyGroup(NuGetFramework framework, IEnumerable`1<LibraryDependency> transitiveDependencies);
    [CompilerGeneratedAttribute]
public string get_FrameworkName();
    [CompilerGeneratedAttribute]
public IEnumerable`1<LibraryDependency> get_TransitiveDependencies();
    public sealed virtual bool Equals(CentralTransitiveDependencyGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NuGet.ProjectModel.CircularMemoryStream : MemoryStream {
    private Byte[] _buffer;
    [CompilerGeneratedAttribute]
private EventHandler`1<ArraySegment`1<byte>> OnFlush;
    internal CircularMemoryStream(Byte[] buffer);
    [CompilerGeneratedAttribute]
internal void add_OnFlush(EventHandler`1<ArraySegment`1<byte>> value);
    [CompilerGeneratedAttribute]
internal void remove_OnFlush(EventHandler`1<ArraySegment`1<byte>> value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual void Flush();
    private void FlushIfFull();
}
public class NuGet.ProjectModel.DependencyGraphSpec : object {
    private static bool UseLegacyHashFunction;
    private static string DGSpecFileNameExtension;
    private SortedSet`1<string> _restore;
    private SortedDictionary`2<string, PackageSpec> _projects;
    private static int Version;
    private bool _isReadOnly;
    public IReadOnlyList`1<string> Restore { get; }
    public IReadOnlyList`1<PackageSpec> Projects { get; }
    public DependencyGraphSpec(bool isReadOnly);
    private static DependencyGraphSpec();
    public static string GetDGSpecFileName(string projectName);
    public IReadOnlyList`1<string> get_Restore();
    public IReadOnlyList`1<PackageSpec> get_Projects();
    public PackageSpec GetProjectSpec(string projectUniqueName);
    public IReadOnlyList`1<string> GetParents(string rootUniqueName);
    public DependencyGraphSpec WithProjectClosure(string projectUniqueName);
    public DependencyGraphSpec CreateFromClosure(string projectUniqueName, IReadOnlyList`1<PackageSpec> closure);
    public IReadOnlyList`1<PackageSpec> GetClosure(string rootUniqueName);
    private static IEnumerable`1<string> GetProjectReferenceNames(PackageSpec spec, SortedDictionary`2<string, PackageSpec> projectsByUniqueName);
    public void AddRestore(string projectUniqueName);
    public void AddProject(PackageSpec projectSpec);
    public static DependencyGraphSpec Union(IEnumerable`1<DependencyGraphSpec> dgSpecs);
    public static DependencyGraphSpec Load(string path);
    public void Save(string path);
    public void Save(Stream stream);
    public string GetHash();
    private void Write(IObjectWriter writer, bool hashing, Action`4<PackageSpec, IObjectWriter, bool, IEnvironmentVariableReader> writeAction);
    public static IReadOnlyList`1<PackageSpec> SortPackagesByDependencyOrder(IEnumerable`1<PackageSpec> packages);
    public DependencyGraphSpec WithoutRestores();
    public DependencyGraphSpec WithReplacedSpec(PackageSpec project);
    public DependencyGraphSpec WithPackageSpecs(IEnumerable`1<PackageSpec> packageSpecs);
    public DependencyGraphSpec WithoutTools();
    private static string GetPackageSpecId(PackageSpec spec);
    private static String[] GetPackageSpecDependencyIds(PackageSpec spec);
}
public class NuGet.ProjectModel.ExternalProjectReference : object {
    private PackageSpec _packageSpec;
    [CompilerGeneratedAttribute]
private string <UniqueName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <ExternalProjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectJsonPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSpecProjectName>k__BackingField;
    public string UniqueName { get; }
    public PackageSpec PackageSpec { get; }
    public IReadOnlyList`1<string> ExternalProjectReferences { get; }
    public string MSBuildProjectPath { get; }
    public string ProjectJsonPath { get; }
    public string PackageSpecProjectName { get; }
    public string ProjectName { get; }
    public ExternalProjectReference(string uniqueName, PackageSpec packageSpec, string msbuildProjectPath, IEnumerable`1<string> projectReferences);
    public ExternalProjectReference(string uniqueName, string packageSpecProjectName, string packageSpecPath, string msbuildProjectPath, IEnumerable`1<string> projectReferences);
    [CompilerGeneratedAttribute]
public string get_UniqueName();
    public PackageSpec get_PackageSpec();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_ExternalProjectReferences();
    [CompilerGeneratedAttribute]
public string get_MSBuildProjectPath();
    [CompilerGeneratedAttribute]
public string get_ProjectJsonPath();
    [CompilerGeneratedAttribute]
public string get_PackageSpecProjectName();
    public string get_ProjectName();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(ExternalProjectReference other);
    public sealed virtual int CompareTo(ExternalProjectReference other);
}
public class NuGet.ProjectModel.FileFormatException : Exception {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public string Path { get; private set; }
    public int Line { get; private set; }
    public int Column { get; private set; }
    public FileFormatException(string message);
    public FileFormatException(string message, Exception innerException);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
private void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
private void set_Column(int value);
    private FileFormatException WithFilePath(string path);
    private FileFormatException WithLineInfo(JsonReaderException exception);
    private FileFormatException WithLineInfo(int line, int column);
    private FileFormatException WithLineInfo(IJsonLineInfo lineInfo);
    public static FileFormatException Create(Exception exception, JToken value, string path);
    internal static FileFormatException Create(Exception exception, int line, int column, string path);
    internal static FileFormatException Create(Exception exception, string path);
    public static FileFormatException Create(string message, JToken value, string path);
    internal static FileFormatException Create(string message, int line, int column, string path);
    internal static FileFormatException Create(JsonReaderException exception, string path);
    internal static FileFormatException Create(string message, string path);
}
internal class NuGet.ProjectModel.FnvHash64Function : object {
    private ulong _hash;
    public sealed virtual void Update(Byte[] data, int offset, int count);
    public Byte[] GetHashBytes();
    public sealed virtual string GetHash();
    public sealed virtual void Dispose();
}
public class NuGet.ProjectModel.HashObjectWriter : object {
    private static int DefaultBufferSize;
    private Byte[] _buffer;
    private IHashFunction _hashFunc;
    private bool _isDisposed;
    private bool _isReadOnly;
    private int _nestLevel;
    private CircularMemoryStream _stream;
    private StreamWriter _streamWriter;
    private JsonTextWriter _writer;
    public HashObjectWriter(IHashFunction hashFunc);
    public sealed virtual void Dispose();
    public sealed virtual void WriteObjectStart();
    public sealed virtual void WriteObjectStart(string name);
    public sealed virtual void WriteObjectEnd();
    public sealed virtual void WriteNameValue(string name, int value);
    public sealed virtual void WriteNameValue(string name, bool value);
    public sealed virtual void WriteNameValue(string name, string value);
    public sealed virtual void WriteNameArray(string name, IEnumerable`1<string> values);
    public sealed virtual void WriteNonEmptyNameArray(string name, IEnumerable`1<string> values);
    public string GetHash();
    public sealed virtual void WriteArrayStart(string name);
    public sealed virtual void WriteArrayEnd();
    private void OnFlush(object sender, ArraySegment`1<byte> bytes);
    private void ThrowIfReadOnly();
    private void ThrowIfDisposed();
}
public interface NuGet.ProjectModel.IAssetsLogMessage {
    public LogLevel Level { get; }
    public NuGetLogCode Code { get; }
    public string Message { get; }
    public string ProjectPath { get; }
    public WarningLevel WarningLevel { get; }
    public string FilePath { get; }
    public int StartLineNumber { get; }
    public int StartColumnNumber { get; }
    public int EndLineNumber { get; }
    public int EndColumnNumber { get; }
    public string LibraryId { get; }
    public IReadOnlyList`1<string> TargetGraphs { get; }
    public abstract virtual LogLevel get_Level();
    public abstract virtual NuGetLogCode get_Code();
    public abstract virtual string get_Message();
    public abstract virtual string get_ProjectPath();
    public abstract virtual WarningLevel get_WarningLevel();
    public abstract virtual string get_FilePath();
    public abstract virtual int get_StartLineNumber();
    public abstract virtual int get_StartColumnNumber();
    public abstract virtual int get_EndLineNumber();
    public abstract virtual int get_EndColumnNumber();
    public abstract virtual string get_LibraryId();
    public abstract virtual IReadOnlyList`1<string> get_TargetGraphs();
}
public interface NuGet.ProjectModel.IExternalProjectReferenceProvider {
    public abstract virtual IReadOnlyList`1<ExternalProjectReference> GetReferences(string entryPointPath);
    public abstract virtual IReadOnlyList`1<ExternalProjectReference> GetEntryPoints();
}
public class NuGet.ProjectModel.IncludeExcludeFiles : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <IncludeFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <ExcludeFiles>k__BackingField;
    public IReadOnlyList`1<string> Include { get; public set; }
    public IReadOnlyList`1<string> Exclude { get; public set; }
    public IReadOnlyList`1<string> IncludeFiles { get; public set; }
    public IReadOnlyList`1<string> ExcludeFiles { get; public set; }
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Include();
    [CompilerGeneratedAttribute]
public void set_Include(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_IncludeFiles();
    [CompilerGeneratedAttribute]
public void set_IncludeFiles(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_ExcludeFiles();
    [CompilerGeneratedAttribute]
public void set_ExcludeFiles(IReadOnlyList`1<string> value);
    public bool HandleIncludeExcludeFiles(JObject jsonObject);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IncludeExcludeFiles other);
    public IncludeExcludeFiles Clone();
    private static bool TryGetStringEnumerableFromJArray(JToken token, IReadOnlyList`1& result);
}
internal interface NuGet.ProjectModel.IUtf8JsonStreamReaderConverter`1 {
    public abstract virtual T Read(Utf8JsonStreamReader& reader);
}
public static class NuGet.ProjectModel.JsonPackageSpecReader : object {
    private static Char[] DelimitedStringSeparators;
    private static Char[] VersionSeparators;
    private static char VersionSeparator;
    public static string RestoreOptions;
    public static string RestoreSettings;
    public static string HideWarningsAndErrors;
    public static string PackOptions;
    public static string PackageType;
    public static string Files;
    private static Byte[] AuthorsPropertyName;
    private static Byte[] BuildOptionsPropertyName;
    private static Byte[] ContentFilesPropertyName;
    private static Byte[] CopyrightPropertyName;
    private static Byte[] DependenciesPropertyName;
    private static Byte[] DescriptionPropertyName;
    private static Byte[] LanguagePropertyName;
    private static Byte[] PackIncludePropertyName;
    private static Byte[] PackOptionsPropertyName;
    private static Byte[] ScriptsPropertyName;
    private static Byte[] FrameworksPropertyName;
    private static Byte[] RestorePropertyName;
    private static Byte[] RuntimesPropertyName;
    private static Byte[] SupportsPropertyName;
    private static Byte[] TitlePropertyName;
    private static Byte[] VersionPropertyName;
    private static Byte[] OutputNamePropertyName;
    private static Byte[] AutoReferencedPropertyName;
    private static Byte[] ExcludePropertyName;
    private static Byte[] GeneratePathPropertyPropertyName;
    private static Byte[] IncludePropertyName;
    private static Byte[] NoWarnPropertyName;
    private static Byte[] SuppressParentPropertyName;
    private static Byte[] TargetPropertyName;
    private static Byte[] VersionOverridePropertyName;
    private static Byte[] VersionCentrallyManagedPropertyName;
    private static Byte[] AliasesPropertyName;
    private static Byte[] NamePropertyName;
    private static Byte[] PrivateAssetsPropertyName;
    private static Byte[] ExcludeFilesPropertyName;
    private static Byte[] IncludeFilesPropertyName;
    private static Byte[] CentralPackageVersionsManagementEnabledPropertyName;
    private static Byte[] CentralPackageVersionOverrideDisabledPropertyName;
    private static Byte[] CentralPackageTransitivePinningEnabledPropertyName;
    private static Byte[] ConfigFilePathsPropertyName;
    private static Byte[] CrossTargetingPropertyName;
    private static Byte[] FallbackFoldersPropertyName;
    private static Byte[] FilesPropertyName;
    private static Byte[] LegacyPackagesDirectoryPropertyName;
    private static Byte[] OriginalTargetFrameworksPropertyName;
    private static Byte[] OutputPathPropertyName;
    private static Byte[] PackagesConfigPathPropertyName;
    private static Byte[] PackagesPathPropertyName;
    private static Byte[] ProjectJsonPathPropertyName;
    private static Byte[] ProjectNamePropertyName;
    private static Byte[] ProjectPathPropertyName;
    private static Byte[] ProjectStylePropertyName;
    private static Byte[] ProjectUniqueNamePropertyName;
    private static Byte[] RestoreLockPropertiesPropertyName;
    private static Byte[] NuGetLockFilePathPropertyName;
    private static Byte[] RestoreLockedModePropertyName;
    private static Byte[] RestorePackagesWithLockFilePropertyName;
    private static Byte[] RestoreAuditPropertiesPropertyName;
    private static Byte[] EnableAuditPropertyName;
    private static Byte[] AuditLevelPropertyName;
    private static Byte[] AuditModePropertyName;
    private static Byte[] AuditSuppressionsPropertyName;
    private static Byte[] SkipContentFileWritePropertyName;
    private static Byte[] SourcesPropertyName;
    private static Byte[] ValidateRuntimeAssetsPropertyName;
    private static Byte[] WarningPropertiesPropertyName;
    private static Byte[] AllWarningsAsErrorsPropertyName;
    private static Byte[] WarnAsErrorPropertyName;
    private static Byte[] WarnNotAsErrorPropertyName;
    private static Byte[] ExcludeAssetsPropertyName;
    private static Byte[] IncludeAssetsPropertyName;
    private static Byte[] TargetAliasPropertyName;
    private static Byte[] AssetTargetFallbackPropertyName;
    private static Byte[] SecondaryFrameworkPropertyName;
    private static Byte[] CentralPackageVersionsPropertyName;
    private static Byte[] DownloadDependenciesPropertyName;
    private static Byte[] FrameworkAssembliesPropertyName;
    private static Byte[] FrameworkReferencesPropertyName;
    private static Byte[] ImportsPropertyName;
    private static Byte[] RuntimeIdentifierGraphPathPropertyName;
    private static Byte[] WarnPropertyName;
    private static Byte[] IconUrlPropertyName;
    private static Byte[] LicenseUrlPropertyName;
    private static Byte[] OwnersPropertyName;
    private static Byte[] PackageTypePropertyName;
    private static Byte[] ProjectUrlPropertyName;
    private static Byte[] ReleaseNotesPropertyName;
    private static Byte[] RequireLicenseAcceptancePropertyName;
    private static Byte[] SummaryPropertyName;
    private static Byte[] TagsPropertyName;
    private static Byte[] MappingsPropertyName;
    private static Byte[] HashTagImportPropertyName;
    private static Byte[] ProjectReferencesPropertyName;
    private static Byte[] EmptyStringPropertyName;
    private static Byte[] SdkAnalysisLevel;
    private static Byte[] UsingMicrosoftNETSdk;
    private static Byte[] UseLegacyDependencyResolverPropertyName;
    private static JsonPackageSpecReader();
    public static PackageSpec GetPackageSpec(string name, string packageSpecPath);
    public static PackageSpec GetPackageSpec(string json, string name, string packageSpecPath);
    public static PackageSpec GetPackageSpec(Stream stream, string name, string packageSpecPath, string snapshotValue);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release.")]
public static PackageSpec GetPackageSpec(JObject json);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release.")]
public static PackageSpec GetPackageSpec(JObject rawPackageSpec, string name, string packageSpecPath, string snapshotValue);
    [ObsoleteAttribute]
internal static PackageSpec GetPackageSpec(JsonTextReader jsonReader, string packageSpecPath);
    internal static PackageSpec GetPackageSpec(Stream stream, string name, string packageSpecPath, string snapshotValue, IEnvironmentVariableReader environmentVariableReader, bool bypassCache);
    [ObsoleteAttribute]
internal static PackageSpec GetPackageSpec(JsonTextReader jsonReader, string name, string packageSpecPath, IEnvironmentVariableReader environmentVariableReader, string snapshotValue);
    [ObsoleteAttribute]
private static PackageType CreatePackageType(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static void ReadBuildOptions(JsonTextReader jsonReader, PackageSpec packageSpec);
    [ObsoleteAttribute]
private static void ReadCentralPackageVersions(JsonTextReader jsonReader, IDictionary`2<string, CentralPackageVersion> centralPackageVersions, string filePath);
    [ObsoleteAttribute]
private static CompatibilityProfile ReadCompatibilityProfile(JsonTextReader jsonReader, string profileName);
    [IteratorStateMachineAttribute("NuGet.ProjectModel.JsonPackageSpecReader/<ReadCompatibilitySets>d__21")]
[ObsoleteAttribute]
private static IEnumerable`1<FrameworkRuntimePair> ReadCompatibilitySets(JsonTextReader jsonReader, string compatibilitySetName);
    [ObsoleteAttribute]
private static void ReadDependencies(JsonTextReader jsonReader, IList`1<LibraryDependency> results, string packageSpecPath, bool isGacOrFrameworkReference);
    [ObsoleteAttribute]
internal static void ReadCentralTransitiveDependencyGroup(JsonTextReader jsonReader, IList`1<LibraryDependency> results, string packageSpecPath);
    [ObsoleteAttribute]
private static void ReadDownloadDependencies(JsonTextReader jsonReader, IList`1<DownloadDependency> downloadDependencies, string packageSpecPath);
    [ObsoleteAttribute]
private static IReadOnlyList`1<string> ReadEnumerableOfString(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static void ReadFrameworkReferences(JsonTextReader jsonReader, ISet`1<FrameworkDependency> frameworkReferences, string packageSpecPath);
    [ObsoleteAttribute]
private static void ReadFrameworks(JsonTextReader jsonReader, PackageSpec packageSpec);
    [ObsoleteAttribute]
private static void ReadImports(PackageSpec packageSpec, JsonTextReader jsonReader, TargetFrameworkInformation targetFrameworkInformation);
    [ObsoleteAttribute]
private static void ReadMappings(JsonTextReader jsonReader, string mappingKey, IDictionary`2<string, IncludeExcludeFiles> mappings);
    [ObsoleteAttribute]
private static void ReadMSBuildMetadata(JsonTextReader jsonReader, PackageSpec packageSpec, IEnvironmentVariableReader environmentVariableReader);
    private static string ExtractMacro(string value, string userSettingsDirectory, bool useMacros);
    private static void ExtractMacros(List`1<string> paths, string userSettingsDirectory, bool useMacros);
    private static bool ReadNextTokenAsBoolOrFalse(JsonTextReader jsonReader, string filePath);
    [ObsoleteAttribute]
private static void ReadNuGetLogCodes(JsonTextReader jsonReader, HashSet`1<NuGetLogCode> hashCodes);
    private static IList`1<NuGetLogCode> ReadNuGetLogCodesList(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static void ReadPackageTypes(PackageSpec packageSpec, JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static void ReadPackInclude(JsonTextReader jsonReader, PackageSpec packageSpec);
    [ObsoleteAttribute]
private static void ReadPackOptions(JsonTextReader jsonReader, PackageSpec packageSpec, Boolean& isMappingsNull);
    [ObsoleteAttribute]
private static bool ReadPackOptionsFiles(PackageSpec packageSpec, JsonTextReader jsonReader, bool wasMappingsRead);
    [ObsoleteAttribute]
private static RuntimeDependencySet ReadRuntimeDependencySet(JsonTextReader jsonReader, string dependencySetName);
    [ObsoleteAttribute]
private static RuntimeDescription ReadRuntimeDescription(JsonTextReader jsonReader, string runtimeName);
    [ObsoleteAttribute]
private static List`1<RuntimeDescription> ReadRuntimes(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static void ReadScripts(JsonTextReader jsonReader, PackageSpec packageSpec);
    [ObsoleteAttribute]
private static String[] ReadStringArray(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static List`1<CompatibilityProfile> ReadSupports(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static LibraryDependencyTarget ReadTarget(JsonTextReader jsonReader, string packageSpecPath, LibraryDependencyTarget targetFlagsValue);
    [ObsoleteAttribute]
private static List`1<ProjectRestoreMetadataFrameworkInfo> ReadTargetFrameworks(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static void ReadTargetFrameworks(PackageSpec packageSpec, JsonTextReader jsonReader, Int32& frameworkLine, Int32& frameworkColumn);
    [ObsoleteAttribute]
private static void AddTargetFramework(PackageSpec packageSpec, NuGetFramework frameworkName, NuGetFramework secondaryFramework, TargetFrameworkInformation targetFrameworkInformation);
    [ObsoleteAttribute]
private static NuGetFramework GetDualCompatibilityFrameworkIfNeeded(NuGetFramework frameworkName, NuGetFramework secondaryFramework);
    [ObsoleteAttribute]
private static bool ValidateDependencyTarget(LibraryDependencyTarget targetValue);
    private static HashSet`1<string> ReadSuppressedAdvisories(JsonTextReader jsonReader);
    internal static PackageSpec GetPackageSpecUtf8JsonStreamReader(Stream stream, string name, string packageSpecPath, IEnvironmentVariableReader environmentVariableReader, string snapshotValue);
    internal static PackageSpec GetPackageSpec(Utf8JsonStreamReader& jsonReader, string name, string packageSpecPath, IEnvironmentVariableReader environmentVariableReader, string snapshotValue);
    internal static void ReadCentralTransitiveDependencyGroup(Utf8JsonStreamReader& jsonReader, IList`1& results, string packageSpecPath);
    private static LibraryDependency ReadLibraryDependency(Utf8JsonStreamReader& jsonReader, string packageSpecPath, string libraryName);
    private static void ReadCentralTransitiveDependencyGroupProperties(Utf8JsonStreamReader& jsonReader, LibraryIncludeFlags& dependencyIncludeFlagsValue, LibraryIncludeFlags& dependencyExcludeFlagsValue, LibraryIncludeFlags& suppressParentFlagsValue, String& dependencyVersionValue);
    private static void ReadDependencies(Utf8JsonStreamReader& jsonReader, IList`1<LibraryDependency> results, string packageSpecPath, bool isGacOrFrameworkReference);
    private static PackageType CreatePackageType(Utf8JsonStreamReader& jsonReader);
    [ObsoleteAttribute]
private static void ReadBuildOptions(Utf8JsonStreamReader& jsonReader, PackageSpec packageSpec);
    private static void ReadCentralPackageVersions(Utf8JsonStreamReader& jsonReader, IDictionary`2<string, CentralPackageVersion> centralPackageVersions, string filePath);
    private static CompatibilityProfile ReadCompatibilityProfile(Utf8JsonStreamReader& jsonReader, string profileName);
    [IteratorStateMachineAttribute("NuGet.ProjectModel.JsonPackageSpecReader/<ReadCompatibilitySets>d__155")]
private static IEnumerable`1<FrameworkRuntimePair> ReadCompatibilitySets(IReadOnlyList`1<string> values, string compatibilitySetName);
    private static void ReadDownloadDependencies(Utf8JsonStreamReader& jsonReader, IList`1<DownloadDependency> downloadDependencies, string packageSpecPath);
    private static void ReadFrameworkReferences(Utf8JsonStreamReader& jsonReader, ISet`1<FrameworkDependency> frameworkReferences, string packageSpecPath);
    private static void ReadFrameworks(Utf8JsonStreamReader& reader, PackageSpec packageSpec);
    private static void ReadImports(PackageSpec packageSpec, Utf8JsonStreamReader& jsonReader, TargetFrameworkInformation targetFrameworkInformation);
    private static void ReadMappings(Utf8JsonStreamReader& jsonReader, string mappingKey, IDictionary`2<string, IncludeExcludeFiles> mappings);
    private static void ReadMSBuildMetadata(Utf8JsonStreamReader& jsonReader, PackageSpec packageSpec, IEnvironmentVariableReader environmentVariableReader);
    private static void ReadNuGetLogCodes(Utf8JsonStreamReader& jsonReader, HashSet`1<NuGetLogCode> hashCodes);
    private static List`1<NuGetLogCode> ReadNuGetLogCodesList(Utf8JsonStreamReader& jsonReader);
    private static void ReadPackageTypes(PackageSpec packageSpec, Utf8JsonStreamReader& jsonReader);
    [ObsoleteAttribute]
private static void ReadPackInclude(Utf8JsonStreamReader& jsonReader, PackageSpec packageSpec);
    [ObsoleteAttribute]
private static void ReadPackOptions(Utf8JsonStreamReader& jsonReader, PackageSpec packageSpec, Boolean& isMappingsNull);
    [ObsoleteAttribute]
private static bool ReadPackOptionsFiles(PackageSpec packageSpec, Utf8JsonStreamReader& jsonReader, bool wasMappingsRead);
    private static RuntimeDependencySet ReadRuntimeDependencySet(Utf8JsonStreamReader& jsonReader, string dependencySetName);
    private static RuntimeDescription ReadRuntimeDescription(Utf8JsonStreamReader& jsonReader, string runtimeName);
    private static List`1<RuntimeDescription> ReadRuntimes(Utf8JsonStreamReader& jsonReader);
    [ObsoleteAttribute]
private static void ReadScripts(Utf8JsonStreamReader& jsonReader, PackageSpec packageSpec);
    private static List`1<CompatibilityProfile> ReadSupports(Utf8JsonStreamReader& jsonReader);
    private static LibraryDependencyTarget ReadTarget(Utf8JsonStreamReader& jsonReader, string packageSpecPath, LibraryDependencyTarget targetFlagsValue);
    private static List`1<ProjectRestoreMetadataFrameworkInfo> ReadTargetFrameworks(Utf8JsonStreamReader& jsonReader);
    private static void ReadTargetFrameworks(PackageSpec packageSpec, Utf8JsonStreamReader& jsonReader);
    private static HashSet`1<string> ReadSuppressedAdvisories(Utf8JsonStreamReader& jsonReader);
}
[ExtensionAttribute]
internal static class NuGet.ProjectModel.JsonTextReaderExtensions : object {
    private static Char[] DelimitedStringDelimiters;
    private static JsonTextReaderExtensions();
    [ExtensionAttribute]
internal static IReadOnlyList`1<string> ReadDelimitedString(JsonTextReader reader);
    [ExtensionAttribute]
internal static bool ReadNextToken(JsonTextReader reader);
    [ExtensionAttribute]
internal static string ReadNextTokenAsString(JsonTextReader reader);
    [ExtensionAttribute]
internal static bool ReadObject(JsonTextReader reader, Action`1<string> onProperty);
    [ExtensionAttribute]
internal static bool ReadObject(JsonTextReader reader, Action`1<string> onProperty, Int32& startObjectLine, Int32& startObjectColumn);
    [ExtensionAttribute]
internal static void ReadProperties(JsonTextReader reader, Action`1<string> onProperty);
    [ExtensionAttribute]
internal static List`1<string> ReadStringArrayAsList(JsonTextReader reader);
    [ExtensionAttribute]
internal static IReadOnlyList`1<string> ReadStringOrArrayOfStringsAsReadOnlyList(JsonTextReader reader);
    [ExtensionAttribute]
internal static IReadOnlyList`1<string> ReadStringArrayAsReadOnlyListFromArrayStart(JsonTextReader reader);
    [ExtensionAttribute]
private static string ReadTokenAsString(JsonTextReader reader);
}
internal static class NuGet.ProjectModel.JsonUtility : object {
    internal static string NUGET_EXPERIMENTAL_USE_NJ_FOR_FILE_PARSING;
    internal static Nullable`1<bool> UseNewtonsoftJson;
    internal static Char[] PathSplitChars;
    internal static JsonLoadSettings DefaultLoadSettings;
    private static JsonUtility();
    internal static JObject LoadJson(TextReader reader);
    internal static LockFile LoadJson(Stream stream, Utf8JsonStreamLockFileConverter converter, LockFileReadFlags flags);
    internal static PackageDependency ReadPackageDependency(string property, JToken json);
    internal static bool UseNewtonsoftJsonForParsing(IEnvironmentVariableReader environmentVariableReader, bool bypassCache);
    internal static JProperty WritePackageDependencyWithLegacyString(PackageDependency item);
    internal static void WritePackageDependencyWithLegacyString(JsonWriter writer, PackageDependency item);
    internal static JProperty WritePackageDependency(PackageDependency item);
    internal static void WritePackageDependency(JsonWriter writer, PackageDependency item);
    internal static TItem ReadProperty(JObject jObject, string propertyName);
    internal static IList`1<TItem> ReadObject(JObject jObject, Func`3<string, JToken, TItem> readItem);
    internal static JObject WriteObject(IEnumerable`1<TItem> items, Func`2<TItem, JProperty> writeItem);
    internal static void WriteObject(JsonWriter writer, IEnumerable`1<TItem> items, Action`2<JsonWriter, TItem> writeItem);
    internal static int ReadInt(JToken cursor, string property, int defaultValue);
    internal static JToken WriteString(string item);
}
[ExtensionAttribute]
public static class NuGet.ProjectModel.JTokenExtensions : object {
    [ExtensionAttribute]
public static T[] ValueAsArray(JToken jToken);
    [ExtensionAttribute]
public static T[] ValueAsArray(JToken jToken, string name);
    [ExtensionAttribute]
public static T GetValue(JToken token, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class NuGet.ProjectModel.LazyStringSplit : ValueType {
    private string _input;
    private char _delimiter;
    public LazyStringSplit(string input, char delimiter);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    [IteratorStateMachineAttribute("NuGet.ProjectModel.LazyStringSplit/<Select>d__6`1")]
public IEnumerable`1<T> Select(Func`2<string, T> func);
    public string First();
    [NullableContextAttribute("2")]
public string FirstOrDefault();
}
[ExtensionAttribute]
internal static class NuGet.ProjectModel.LazyStringSplitExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string FirstOrDefault(LazyStringSplit lazyStringSplit);
}
public class NuGet.ProjectModel.LockFile : object {
    public static NuGetFramework ToolFramework;
    public static char DirectorySeparatorChar;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ProjectFileDependencyGroup> <ProjectFileDependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileLibrary> <Libraries>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileTarget> <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileItem> <PackageFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IAssetsLogMessage> <LogMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSpec <PackageSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<CentralTransitiveDependencyGroup> <CentralTransitiveDependencyGroups>k__BackingField;
    public int Version { get; public set; }
    public string Path { get; public set; }
    public IList`1<ProjectFileDependencyGroup> ProjectFileDependencyGroups { get; public set; }
    public IList`1<LockFileLibrary> Libraries { get; public set; }
    public IList`1<LockFileTarget> Targets { get; public set; }
    public IList`1<LockFileItem> PackageFolders { get; public set; }
    public IList`1<IAssetsLogMessage> LogMessages { get; public set; }
    public PackageSpec PackageSpec { get; public set; }
    public IList`1<CentralTransitiveDependencyGroup> CentralTransitiveDependencyGroups { get; public set; }
    private static LockFile();
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public IList`1<ProjectFileDependencyGroup> get_ProjectFileDependencyGroups();
    [CompilerGeneratedAttribute]
public void set_ProjectFileDependencyGroups(IList`1<ProjectFileDependencyGroup> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileLibrary> get_Libraries();
    [CompilerGeneratedAttribute]
public void set_Libraries(IList`1<LockFileLibrary> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileTarget> get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(IList`1<LockFileTarget> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileItem> get_PackageFolders();
    [CompilerGeneratedAttribute]
public void set_PackageFolders(IList`1<LockFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<IAssetsLogMessage> get_LogMessages();
    [CompilerGeneratedAttribute]
public void set_LogMessages(IList`1<IAssetsLogMessage> value);
    [CompilerGeneratedAttribute]
public PackageSpec get_PackageSpec();
    [CompilerGeneratedAttribute]
public void set_PackageSpec(PackageSpec value);
    [CompilerGeneratedAttribute]
public IList`1<CentralTransitiveDependencyGroup> get_CentralTransitiveDependencyGroups();
    [CompilerGeneratedAttribute]
public void set_CentralTransitiveDependencyGroups(IList`1<CentralTransitiveDependencyGroup> value);
    public bool IsValidForPackageSpec(PackageSpec spec);
    public bool IsValidForPackageSpec(PackageSpec spec, int requestLockFileVersion);
    private bool ValidateDependencies(PackageSpec spec);
    public LockFileTarget GetTarget(NuGetFramework framework, string runtimeIdentifier);
    public LockFileTarget GetTarget(string frameworkAlias, string runtimeIdentifier);
    public LockFileLibrary GetLibrary(string name, NuGetVersion version);
    public sealed virtual bool Equals(LockFile other);
    private bool LogsEqual(IList`1<IAssetsLogMessage> otherLogMessages);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.ProjectModel.LockFileContentFile : LockFileItem {
    public static string BuildActionProperty;
    public static string CodeLanguageProperty;
    public static string PPOutputPathProperty;
    public static string OutputPathProperty;
    public static string CopyToOutputProperty;
    public string OutputPath { get; public set; }
    public string PPOutputPath { get; public set; }
    public BuildAction BuildAction { get; public set; }
    public string CodeLanguage { get; public set; }
    public bool CopyToOutput { get; public set; }
    public LockFileContentFile(string path);
    private static LockFileContentFile();
    public string get_OutputPath();
    public void set_OutputPath(string value);
    public string get_PPOutputPath();
    public void set_PPOutputPath(string value);
    public BuildAction get_BuildAction();
    public void set_BuildAction(BuildAction value);
    public string get_CodeLanguage();
    public void set_CodeLanguage(string value);
    public bool get_CopyToOutput();
    public void set_CopyToOutput(bool value);
}
public class NuGet.ProjectModel.LockFileDependency : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <ResolvedVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <RequestedVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageDependencyType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageDependency> <Dependencies>k__BackingField;
    public string Id { get; public set; }
    public NuGetVersion ResolvedVersion { get; public set; }
    public VersionRange RequestedVersion { get; public set; }
    public string ContentHash { get; public set; }
    public PackageDependencyType Type { get; public set; }
    public IList`1<PackageDependency> Dependencies { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_ResolvedVersion();
    [CompilerGeneratedAttribute]
public void set_ResolvedVersion(NuGetVersion value);
    [CompilerGeneratedAttribute]
public VersionRange get_RequestedVersion();
    [CompilerGeneratedAttribute]
public void set_RequestedVersion(VersionRange value);
    [CompilerGeneratedAttribute]
public string get_ContentHash();
    [CompilerGeneratedAttribute]
public void set_ContentHash(string value);
    [CompilerGeneratedAttribute]
public PackageDependencyType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(PackageDependencyType value);
    [CompilerGeneratedAttribute]
public IList`1<PackageDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<PackageDependency> value);
    public sealed virtual bool Equals(LockFileDependency other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.ProjectModel.LockFileDependencyIdVersionComparer : object {
    [CompilerGeneratedAttribute]
private static LockFileDependencyIdVersionComparer <Default>k__BackingField;
    public static LockFileDependencyIdVersionComparer Default { get; }
    private static LockFileDependencyIdVersionComparer();
    [CompilerGeneratedAttribute]
public static LockFileDependencyIdVersionComparer get_Default();
    public sealed virtual bool Equals(LockFileDependency x, LockFileDependency y);
    public sealed virtual int GetHashCode(LockFileDependency obj);
}
[ObsoleteAttribute("This is an unused class and will be removed in a future version.")]
public class NuGet.ProjectModel.LockFileDependencyProvider : object {
    private IDictionary`2<Tuple`2<NuGetFramework, string>, LockFileTargetLibrary> _targetLibraries;
    private IDictionary`2<Tuple`2<string, NuGetVersion>, LockFileLibrary> _libraries;
    public LockFileDependencyProvider(LockFile lockFile);
    public sealed virtual bool SupportsType(LibraryDependencyTarget libraryType);
    public sealed virtual Library GetLibrary(LibraryRange libraryRange, NuGetFramework targetFramework);
    private IList`1<LibraryDependency> GetDependencies(LockFileTargetLibrary library);
}
[ExtensionAttribute]
public static class NuGet.ProjectModel.LockFileExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<LockFileTarget> GetTargetGraphs(IAssetsLogMessage message, LockFile assetsFile);
    [ExtensionAttribute]
public static IEnumerable`1<LockFileTargetLibrary> GetTargetLibraries(IAssetsLogMessage message, LockFile assetsFile);
    [ExtensionAttribute]
public static LockFileTargetLibrary GetTargetLibrary(LockFileTarget target, string libraryId);
}
public class NuGet.ProjectModel.LockFileFormat : object {
    public static int Version;
    public static string LockFileName;
    public static string AssetsFileName;
    private static string VersionProperty;
    private static string LibrariesProperty;
    private static string TargetsProperty;
    private static string ProjectFileDependencyGroupsProperty;
    private static string ServicableProperty;
    private static string Sha512Property;
    private static string FilesProperty;
    private static string HasToolsProperty;
    private static string DependenciesProperty;
    private static string FrameworkAssembliesProperty;
    private static string RuntimeProperty;
    private static string CompileProperty;
    private static string NativeProperty;
    private static string BuildProperty;
    private static string BuildMultiTargetingProperty;
    private static string ContentFilesProperty;
    private static string RuntimeTargetsProperty;
    private static string ResourceProperty;
    private static string TypeProperty;
    private static string PathProperty;
    private static string MSBuildProjectProperty;
    private static string FrameworkProperty;
    private static string ToolsProperty;
    private static string PackageFoldersProperty;
    private static string PackageSpecProperty;
    internal static string LogsProperty;
    private static string EmbedProperty;
    private static string FrameworkReferencesProperty;
    private static string CentralTransitiveDependencyGroupsProperty;
    private static LockFileFormat();
    public LockFile Parse(string lockFileContent, string path);
    public LockFile Parse(string lockFileContent, ILogger log, string path);
    public LockFile Read(string filePath);
    public LockFile Read(string filePath, ILogger log);
    public LockFile Read(Stream stream, string path);
    public LockFile Read(Stream stream, ILogger log, string path);
    internal LockFile Read(Stream stream, ILogger log, string path, LockFileReadFlags flags);
    internal LockFile Read(Stream stream, ILogger log, string path, IEnvironmentVariableReader environmentVariableReader, bool bypassCache, LockFileReadFlags flags);
    [ObsoleteAttribute("This method is deprecated. Use Read(Stream, string) instead.")]
public LockFile Read(TextReader reader, string path);
    [ObsoleteAttribute("This method is deprecated. Use Read(Stream, ILogger, string) instead.")]
public LockFile Read(TextReader reader, ILogger log, string path);
    [ObsoleteAttribute("This method is deprecated. Use Read(Stream, string) instead.")]
internal LockFile Read(TextReader reader, ILogger log, string path, LockFileReadFlags flags);
    public void Write(string filePath, LockFile lockFile);
    public void Write(Stream stream, LockFile lockFile);
    public void Write(TextWriter textWriter, LockFile lockFile);
    public string Render(LockFile lockFile);
    private static LockFile Utf8JsonRead(Stream stream, ILogger log, string path, LockFileReadFlags flags);
    [ObsoleteAttribute]
private static LockFile ReadLockFile(JObject cursor, string path, LockFileReadFlags flags);
    private static void WriteLockFile(JsonWriter writer, IObjectWriter jsonObjectWriter, LockFile lockFile);
    private static LockFileLibrary ReadLibrary(string property, JToken json);
    private static void WriteLibrary(JsonWriter writer, LockFileLibrary library);
    private static void WriteTarget(JsonWriter writer, LockFileTarget target);
    private static LockFileTarget ReadTarget(string property, JToken json);
    private static void WriteLogMessage(JsonWriter writer, IAssetsLogMessage logMessage, string projectPath);
    private static IAssetsLogMessage ReadLogMessage(JObject json, string projectPath);
    internal static JArray WriteLogMessages(IEnumerable`1<IAssetsLogMessage> logMessages, string projectPath);
    internal static void WriteLogMessages(JsonWriter writer, IEnumerable`1<IAssetsLogMessage> logMessages, string projectPath);
    private static LockFileTargetLibrary ReadTargetLibrary(string property, JToken json);
    private static void WriteTargetLibrary(JsonWriter writer, LockFileTargetLibrary library);
    private static LockFileRuntimeTarget ReadRuntimeTarget(string property, JToken json);
    private static LockFileContentFile ReadContentFile(string property, JToken json);
    private static ProjectFileDependencyGroup ReadProjectFileDependencyGroup(string property, JToken json);
    private static PackageSpec ReadPackageSpec(JObject json);
    private static void WriteProjectFileDependencyGroup(JsonWriter writer, ProjectFileDependencyGroup frameworkInfo);
    private static LockFileItem ReadFileItem(string property, JToken json);
    private static T ReadFileItem(string property, JToken json, Func`2<string, T> factory);
    private static void WriteFileItem(JsonWriter writer, LockFileItem item);
    private static IList`1<TItem> ReadArray(JArray json, Func`2<JToken, TItem> readItem);
    internal static IList`1<IAssetsLogMessage> ReadLogMessageArray(JArray json, string projectPath);
    private static IList`1<string> ReadPathArray(JArray json);
    private static void WritePathArray(JsonWriter writer, string property, IEnumerable`1<string> items);
    internal static void WriteArray(JsonWriter writer, IEnumerable`1<string> values);
    private static bool ReadBool(JToken cursor, string property, bool defaultValue);
    private static string ReadString(JToken json);
    private static SemanticVersion ReadSemanticVersion(JToken json, string property);
    private static string GetPathWithForwardSlashes(string path);
    private static string GetPathWithBackSlashes(string path);
    private static void WriteCentralTransitiveDependencyGroup(IObjectWriter writer, IList`1<CentralTransitiveDependencyGroup> centralTransitiveDependencyGroups);
    [ObsoleteAttribute]
private static List`1<CentralTransitiveDependencyGroup> ReadProjectFileTransitiveDependencyGroup(JObject json, string path);
}
public class NuGet.ProjectModel.LockFileItem : object {
    public static string AliasesProperty;
    private static object PropertiesLock;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    private Dictionary`2<string, string> _properties;
    public string Path { get; }
    public IDictionary`2<string, string> Properties { get; }
    public LockFileItem(string path);
    private static LockFileItem();
    [CompilerGeneratedAttribute]
public string get_Path();
    public IDictionary`2<string, string> get_Properties();
    public virtual string ToString();
    public sealed virtual bool Equals(LockFileItem other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static LockFileItem op_Implicit(string path);
    protected string GetProperty(string name);
    protected void SetProperty(string name, string value);
}
public class NuGet.ProjectModel.LockFileLibrary : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServiceable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sha512>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildProject>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTools>k__BackingField;
    public string Name { get; public set; }
    public string Type { get; public set; }
    public NuGetVersion Version { get; public set; }
    public bool IsServiceable { get; public set; }
    public string Sha512 { get; public set; }
    public IList`1<string> Files { get; public set; }
    public string Path { get; public set; }
    public string MSBuildProject { get; public set; }
    public bool HasTools { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public bool get_IsServiceable();
    [CompilerGeneratedAttribute]
public void set_IsServiceable(bool value);
    [CompilerGeneratedAttribute]
public string get_Sha512();
    [CompilerGeneratedAttribute]
public void set_Sha512(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(IList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_MSBuildProject();
    [CompilerGeneratedAttribute]
public void set_MSBuildProject(string value);
    [CompilerGeneratedAttribute]
public bool get_HasTools();
    [CompilerGeneratedAttribute]
public void set_HasTools(bool value);
    public sealed virtual bool Equals(LockFileLibrary other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public LockFileLibrary Clone();
}
[FlagsAttribute]
public enum NuGet.ProjectModel.LockFileReadFlags : Enum {
    public int value__;
    public static LockFileReadFlags Libraries;
    public static LockFileReadFlags Targets;
    public static LockFileReadFlags ProjectFileDependencyGroups;
    public static LockFileReadFlags PackageFolders;
    public static LockFileReadFlags PackageSpec;
    public static LockFileReadFlags CentralTransitiveDependencyGroups;
    public static LockFileReadFlags LogMessages;
    public static LockFileReadFlags All;
}
public class NuGet.ProjectModel.LockFileRuntimeTarget : LockFileItem {
    public static string RidProperty;
    public static string AssetTypeProperty;
    public string Runtime { get; public set; }
    public string AssetType { get; public set; }
    public LockFileRuntimeTarget(string path);
    public LockFileRuntimeTarget(string path, string runtime, string assetType);
    private static LockFileRuntimeTarget();
    public string get_Runtime();
    public void set_Runtime(string value);
    public string get_AssetType();
    public void set_AssetType(string value);
}
public class NuGet.ProjectModel.LockFileTarget : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileTargetLibrary> <Libraries>k__BackingField;
    public NuGetFramework TargetFramework { get; public set; }
    public string RuntimeIdentifier { get; public set; }
    public string Name { get; }
    public IList`1<LockFileTargetLibrary> Libraries { get; public set; }
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(NuGetFramework value);
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public void set_RuntimeIdentifier(string value);
    public string get_Name();
    [CompilerGeneratedAttribute]
public IList`1<LockFileTargetLibrary> get_Libraries();
    [CompilerGeneratedAttribute]
public void set_Libraries(IList`1<LockFileTargetLibrary> value);
    public sealed virtual bool Equals(LockFileTarget other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.ProjectModel.LockFileTargetLibrary : object {
    private static PropertyKey DependenciesKey;
    private static PropertyKey FrameworkAssembliesKey;
    private static PropertyKey FrameworkReferencesKey;
    private static PropertyKey RuntimeAssembliesKey;
    private static PropertyKey ResourceAssembliesKey;
    private static PropertyKey CompileTimeAssembliesKey;
    private static PropertyKey NativeLibrariesKey;
    private static PropertyKey BuildKey;
    private static PropertyKey BuildMultiTargetingKey;
    private static PropertyKey ContentFilesKey;
    private static PropertyKey RuntimeTargetsKey;
    private static PropertyKey ToolsAssembliesKey;
    private static PropertyKey EmbedAssembliesKey;
    private static PropertyKey PackageTypeKey;
    private Dictionary`2<PropertyKey, object> _propertyValues;
    private bool _isFrozen;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Framework>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [NullableAttribute("2")]
public string Name { get; public set; }
    [NullableAttribute("2")]
public string Framework { get; public set; }
    [NullableAttribute("2")]
public NuGetVersion Version { get; public set; }
    [NullableAttribute("2")]
public string Type { get; public set; }
    public IList`1<PackageDependency> Dependencies { get; public set; }
    public IList`1<string> FrameworkAssemblies { get; public set; }
    public IList`1<string> FrameworkReferences { get; public set; }
    public IList`1<LockFileItem> RuntimeAssemblies { get; public set; }
    public IList`1<LockFileItem> ResourceAssemblies { get; public set; }
    public IList`1<LockFileItem> CompileTimeAssemblies { get; public set; }
    public IList`1<LockFileItem> NativeLibraries { get; public set; }
    public IList`1<LockFileItem> Build { get; public set; }
    public IList`1<LockFileItem> BuildMultiTargeting { get; public set; }
    public IList`1<LockFileContentFile> ContentFiles { get; public set; }
    public IList`1<LockFileRuntimeTarget> RuntimeTargets { get; public set; }
    public IList`1<LockFileItem> ToolsAssemblies { get; public set; }
    public IList`1<LockFileItem> EmbedAssemblies { get; public set; }
    public IList`1<PackageType> PackageType { get; public set; }
    private static LockFileTargetLibrary();
    private IList`1<T> GetListProperty(PropertyKey key);
    private void SetListProperty(PropertyKey key, IList`1<T> list);
    public void Freeze();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Name(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Framework();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Framework(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Type();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Type(string value);
    public IList`1<PackageDependency> get_Dependencies();
    public void set_Dependencies(IList`1<PackageDependency> value);
    public IList`1<string> get_FrameworkAssemblies();
    public void set_FrameworkAssemblies(IList`1<string> value);
    public IList`1<string> get_FrameworkReferences();
    public void set_FrameworkReferences(IList`1<string> value);
    public IList`1<LockFileItem> get_RuntimeAssemblies();
    public void set_RuntimeAssemblies(IList`1<LockFileItem> value);
    public IList`1<LockFileItem> get_ResourceAssemblies();
    public void set_ResourceAssemblies(IList`1<LockFileItem> value);
    public IList`1<LockFileItem> get_CompileTimeAssemblies();
    public void set_CompileTimeAssemblies(IList`1<LockFileItem> value);
    public IList`1<LockFileItem> get_NativeLibraries();
    public void set_NativeLibraries(IList`1<LockFileItem> value);
    public IList`1<LockFileItem> get_Build();
    public void set_Build(IList`1<LockFileItem> value);
    public IList`1<LockFileItem> get_BuildMultiTargeting();
    public void set_BuildMultiTargeting(IList`1<LockFileItem> value);
    public IList`1<LockFileContentFile> get_ContentFiles();
    public void set_ContentFiles(IList`1<LockFileContentFile> value);
    public IList`1<LockFileRuntimeTarget> get_RuntimeTargets();
    public void set_RuntimeTargets(IList`1<LockFileRuntimeTarget> value);
    public IList`1<LockFileItem> get_ToolsAssemblies();
    public void set_ToolsAssemblies(IList`1<LockFileItem> value);
    public IList`1<LockFileItem> get_EmbedAssemblies();
    public void set_EmbedAssemblies(IList`1<LockFileItem> value);
    public IList`1<PackageType> get_PackageType();
    public void set_PackageType(IList`1<PackageType> value);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(LockFileTargetLibrary other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private bool <Equals>g__IsListOrderedEqual|78_13(PropertyKey key, Func`2<T, string> accessor, IEqualityComparer`1<T> sequenceComparer, <>c__DisplayClass78_0& );
}
public static class NuGet.ProjectModel.LockFileUtilities : object {
    public static LockFile GetLockFile(string lockFilePath, ILogger logger);
    public static LockFile GetLockFile(string lockFilePath, ILogger logger, LockFileReadFlags flags);
}
public class NuGet.ProjectModel.LockFileValidationResult : object {
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <InvalidReasons>k__BackingField;
    public bool IsValid { get; }
    public IReadOnlyList`1<string> InvalidReasons { get; }
    public LockFileValidationResult(bool isValid, IReadOnlyList`1<string> invalidReasons);
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_InvalidReasons();
}
internal static class NuGet.ProjectModel.MacroStringsUtility : object {
    internal static string NUGET_ENABLE_EXPERIMENTAL_MACROS;
    internal static string UserMacro;
    internal static void ApplyMacros(IList`1<string> list, string macroValue, string macroName, StringComparison stringComparison);
    internal static void ExtractMacros(List`1<string> list, string macroValue, string macroName);
    internal static string ApplyMacro(string originalString, string macroValue, string macroName, StringComparison stringComparison);
    internal static string ExtractMacro(string originalString, string macroValue, string macroName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.ProjectModel.NoAllocNewLineStreamWriter : StreamWriter {
    private string _newLine;
    public string NewLine { get; public set; }
    public NoAllocNewLineStreamWriter(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen);
    public NoAllocNewLineStreamWriter(Stream stream);
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
}
public enum NuGet.ProjectModel.PackageDependencyType : Enum {
    public int value__;
    public static PackageDependencyType Direct;
    public static PackageDependencyType Transitive;
    public static PackageDependencyType Project;
    public static PackageDependencyType CentralTransitive;
}
public class NuGet.ProjectModel.PackagesConfigProjectRestoreMetadata : ProjectRestoreMetadata {
    [CompilerGeneratedAttribute]
private string <PackagesConfigPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryPath>k__BackingField;
    public string PackagesConfigPath { get; public set; }
    public string RepositoryPath { get; public set; }
    [CompilerGeneratedAttribute]
public string get_PackagesConfigPath();
    [CompilerGeneratedAttribute]
public void set_PackagesConfigPath(string value);
    [CompilerGeneratedAttribute]
public string get_RepositoryPath();
    [CompilerGeneratedAttribute]
public void set_RepositoryPath(string value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(PackagesConfigProjectRestoreMetadata obj);
    public virtual ProjectRestoreMetadata Clone();
}
public class NuGet.ProjectModel.PackagesLockFile : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackagesLockFileTarget> <Targets>k__BackingField;
    public int Version { get; public set; }
    public string Path { get; public set; }
    public IList`1<PackagesLockFileTarget> Targets { get; public set; }
    public PackagesLockFile(int version);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public IList`1<PackagesLockFileTarget> get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(IList`1<PackagesLockFileTarget> value);
    public sealed virtual bool Equals(PackagesLockFile other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class NuGet.ProjectModel.PackagesLockFileFormat : object {
    public static int Version;
    public static int PackagesLockFileVersion;
    public static string LockFileName;
    private static string VersionProperty;
    private static string ResolvedProperty;
    private static string RequestedProperty;
    private static string ContentHashProperty;
    private static string DependenciesProperty;
    private static string TypeProperty;
    private static PackagesLockFileFormat();
    public static PackagesLockFile Parse(string lockFileContent, string path);
    public static PackagesLockFile Parse(string lockFileContent, ILogger log, string path);
    public static PackagesLockFile Read(string filePath);
    public static PackagesLockFile Read(string filePath, ILogger log);
    public static PackagesLockFile Read(Stream stream, ILogger log, string path);
    public static PackagesLockFile Read(TextReader reader, ILogger log, string path);
    private static PackagesLockFile ReadLockFile(JObject cursor);
    public static string Render(PackagesLockFile lockFile);
    public static void Write(string filePath, PackagesLockFile lockFile);
    public static void Write(Stream stream, PackagesLockFile lockFile);
    public static void Write(TextWriter textWriter, PackagesLockFile lockFile);
    private static JObject WriteLockFile(PackagesLockFile lockFile);
    private static PackagesLockFileTarget ReadDependency(string property, JToken json);
    private static LockFileDependency ReadTargetDependency(string property, JToken json);
    private static JProperty WriteTarget(PackagesLockFileTarget target);
    private static JProperty WriteTargetDependency(LockFileDependency dependency);
}
public class NuGet.ProjectModel.PackagesLockFileTarget : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileDependency> <Dependencies>k__BackingField;
    public NuGetFramework TargetFramework { get; public set; }
    public string RuntimeIdentifier { get; public set; }
    public IList`1<LockFileDependency> Dependencies { get; public set; }
    public string Name { get; }
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(NuGetFramework value);
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public void set_RuntimeIdentifier(string value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<LockFileDependency> value);
    public string get_Name();
    public sealed virtual bool Equals(PackagesLockFileTarget other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static string GetNameString(NuGetFramework framework, string runtime);
}
public static class NuGet.ProjectModel.PackagesLockFileUtilities : object {
    public static bool IsNuGetLockFileEnabled(PackageSpec project);
    public static string GetNuGetLockFilePath(PackageSpec project);
    public static string GetNuGetLockFilePath(string baseDirectory, string projectName);
    [ObsoleteAttribute("This method is obsolete. Call IsLockFileValid instead.")]
public static bool IsLockFileStillValid(DependencyGraphSpec dgSpec, PackagesLockFile nuGetLockFile);
    public static LockFileValidationResult IsLockFileValid(DependencyGraphSpec dgSpec, PackagesLockFile nuGetLockFile);
    public static LockFileValidityWithMatchedResults IsLockFileStillValid(PackagesLockFile expected, PackagesLockFile actual);
    private static ValueTuple`2<bool, string> HasDirectPackageDependencyChanged(IEnumerable`1<LibraryDependency> newDependencies, IEnumerable`1<LockFileDependency> lockFileDependencies, NuGetFramework nuGetFramework);
    private static ValueTuple`2<bool, string> HasP2PDependencyChanged(IEnumerable`1<LibraryDependency> newDependencies, IEnumerable`1<ProjectRestoreReference> projectRestoreReferences, LockFileDependency projectDependency, DependencyGraphSpec dgSpec);
    private static ValueTuple`2<bool, string> HasProjectTransitiveDependencyChanged(IDictionary`2<string, CentralPackageVersion> centralPackageVersions, IList`1<LockFileDependency> lockFileCentralTransitiveDependencies, IList`1<LockFileDependency> lockTransitiveDependencies);
}
[DebuggerDisplayAttribute("{Name}")]
public class NuGet.ProjectModel.PackageSpec : object {
    public static string PackageSpecFileName;
    public static NuGetVersion DefaultVersion;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    private NuGetVersion _version;
    [CompilerGeneratedAttribute]
private bool <IsDefaultVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasVersionSnapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildOptions <BuildOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IEnumerable`1<string>> <Scripts>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <PackInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private PackOptions <PackOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LibraryDependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TargetFrameworkInformation> <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeGraph <RuntimeGraph>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectRestoreSettings <RestoreSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectRestoreMetadata <RestoreMetadata>k__BackingField;
    public string FilePath { get; public set; }
    public string BaseDirectory { get; }
    public string Name { get; public set; }
    public string Title { get; public set; }
    public NuGetVersion Version { get; public set; }
    [ObsoleteAttribute]
public bool IsDefaultVersion { get; public set; }
    [ObsoleteAttribute]
public bool HasVersionSnapshot { get; public set; }
    [ObsoleteAttribute]
public string Description { get; public set; }
    [ObsoleteAttribute]
public string Summary { get; public set; }
    [ObsoleteAttribute]
public string ReleaseNotes { get; public set; }
    [ObsoleteAttribute]
public String[] Authors { get; public set; }
    [ObsoleteAttribute]
public String[] Owners { get; public set; }
    [ObsoleteAttribute]
public string ProjectUrl { get; public set; }
    [ObsoleteAttribute]
public string IconUrl { get; public set; }
    [ObsoleteAttribute]
public string LicenseUrl { get; public set; }
    [ObsoleteAttribute]
public bool RequireLicenseAcceptance { get; public set; }
    [ObsoleteAttribute]
public string Copyright { get; public set; }
    [ObsoleteAttribute]
public string Language { get; public set; }
    [ObsoleteAttribute]
public BuildOptions BuildOptions { get; public set; }
    [ObsoleteAttribute]
public String[] Tags { get; public set; }
    [ObsoleteAttribute]
public IList`1<string> ContentFiles { get; public set; }
    [ObsoleteAttribute]
public IDictionary`2<string, IEnumerable`1<string>> Scripts { get; private set; }
    [ObsoleteAttribute]
public IDictionary`2<string, string> PackInclude { get; private set; }
    [ObsoleteAttribute]
public PackOptions PackOptions { get; public set; }
    public IList`1<LibraryDependency> Dependencies { get; public set; }
    public IList`1<TargetFrameworkInformation> TargetFrameworks { get; private set; }
    public RuntimeGraph RuntimeGraph { get; public set; }
    public ProjectRestoreSettings RestoreSettings { get; public set; }
    public ProjectRestoreMetadata RestoreMetadata { get; public set; }
    public PackageSpec(IList`1<TargetFrameworkInformation> frameworks);
    internal PackageSpec(IList`1<TargetFrameworkInformation> frameworks, IList`1<LibraryDependency> dependencies, RuntimeGraph runtimeGraph, ProjectRestoreSettings restoreSettings, String[] authors, String[] owners, String[] tags, IList`1<string> contentFiles, IDictionary`2<string, IEnumerable`1<string>> scripts, IDictionary`2<string, string> packInclude, PackOptions packOptions);
    private static PackageSpec();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    public string get_BaseDirectory();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    public NuGetVersion get_Version();
    public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public bool get_IsDefaultVersion();
    [CompilerGeneratedAttribute]
public void set_IsDefaultVersion(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasVersionSnapshot();
    [CompilerGeneratedAttribute]
public void set_HasVersionSnapshot(bool value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public String[] get_Authors();
    [CompilerGeneratedAttribute]
public void set_Authors(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_Owners();
    [CompilerGeneratedAttribute]
public void set_Owners(String[] value);
    [CompilerGeneratedAttribute]
public string get_ProjectUrl();
    [CompilerGeneratedAttribute]
public void set_ProjectUrl(string value);
    [CompilerGeneratedAttribute]
public string get_IconUrl();
    [CompilerGeneratedAttribute]
public void set_IconUrl(string value);
    [CompilerGeneratedAttribute]
public string get_LicenseUrl();
    [CompilerGeneratedAttribute]
public void set_LicenseUrl(string value);
    [CompilerGeneratedAttribute]
public bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public BuildOptions get_BuildOptions();
    [CompilerGeneratedAttribute]
public void set_BuildOptions(BuildOptions value);
    [CompilerGeneratedAttribute]
public String[] get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(String[] value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_ContentFiles();
    [CompilerGeneratedAttribute]
public void set_ContentFiles(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IEnumerable`1<string>> get_Scripts();
    [CompilerGeneratedAttribute]
private void set_Scripts(IDictionary`2<string, IEnumerable`1<string>> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_PackInclude();
    [CompilerGeneratedAttribute]
private void set_PackInclude(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public PackOptions get_PackOptions();
    [CompilerGeneratedAttribute]
public void set_PackOptions(PackOptions value);
    [CompilerGeneratedAttribute]
public IList`1<LibraryDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<LibraryDependency> value);
    [CompilerGeneratedAttribute]
public IList`1<TargetFrameworkInformation> get_TargetFrameworks();
    [CompilerGeneratedAttribute]
private void set_TargetFrameworks(IList`1<TargetFrameworkInformation> value);
    [CompilerGeneratedAttribute]
public RuntimeGraph get_RuntimeGraph();
    [CompilerGeneratedAttribute]
public void set_RuntimeGraph(RuntimeGraph value);
    [CompilerGeneratedAttribute]
public ProjectRestoreSettings get_RestoreSettings();
    [CompilerGeneratedAttribute]
public void set_RestoreSettings(ProjectRestoreSettings value);
    [CompilerGeneratedAttribute]
public ProjectRestoreMetadata get_RestoreMetadata();
    [CompilerGeneratedAttribute]
public void set_RestoreMetadata(ProjectRestoreMetadata value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(PackageSpec other);
    public PackageSpec Clone();
    private IDictionary`2<string, IEnumerable`1<string>> CloneScripts(IDictionary`2<string, IEnumerable`1<string>> toBeCloned);
}
[ExtensionAttribute]
public static class NuGet.ProjectModel.PackageSpecExtensions : object {
    [ExtensionAttribute]
public static TargetFrameworkInformation GetTargetFramework(PackageSpec project, NuGetFramework targetFramework);
    [ExtensionAttribute]
public static ProjectRestoreMetadataFrameworkInfo GetRestoreMetadataFramework(PackageSpec project, NuGetFramework targetFramework);
}
public static class NuGet.ProjectModel.PackageSpecOperations : object {
    public static void AddOrUpdateDependency(PackageSpec spec, PackageDependency dependency);
    public static void AddOrUpdateDependency(PackageSpec spec, PackageIdentity identity);
    public static bool HasPackage(PackageSpec spec, string packageId);
    public static void AddOrUpdateDependency(PackageSpec spec, PackageDependency dependency, IEnumerable`1<NuGetFramework> frameworksToAdd);
    public static void AddOrUpdateDependency(PackageSpec spec, PackageIdentity identity, IEnumerable`1<NuGetFramework> frameworksToAdd);
    public static void RemoveDependency(PackageSpec spec, string packageId);
    [IteratorStateMachineAttribute("NuGet.ProjectModel.PackageSpecOperations/<GetDependencyLists>d__6")]
private static IEnumerable`1<IList`1<LibraryDependency>> GetDependencyLists(PackageSpec spec, IEnumerable`1<NuGetFramework> frameworksToConsider, bool includeGenericDependencies);
    [IteratorStateMachineAttribute("NuGet.ProjectModel.PackageSpecOperations/<GetCentralPackageVersionLists>d__7")]
private static IEnumerable`1<IDictionary`2<string, CentralPackageVersion>> GetCentralPackageVersionLists(PackageSpec spec, IEnumerable`1<NuGetFramework> frameworksToConsider);
    private static List`1<LibraryDependency> GetExistingDependencies(PackageSpec spec, string packageId);
    private static void AddOrUpdateDependencyInDependencyList(PackageSpec spec, IList`1<LibraryDependency> list, string packageId, VersionRange range);
    private static void AddDependency(IList`1<LibraryDependency> list, string packageId, VersionRange range, bool centralPackageVersionsEnabled);
}
public class NuGet.ProjectModel.PackageSpecReferenceDependencyProvider : object {
    private Dictionary`2<string, ExternalProjectReference> _externalProjectsByPath;
    private Dictionary`2<string, ExternalProjectReference> _externalProjectsByUniqueName;
    private bool _useLegacyAssetTargetFallbackBehavior;
    private bool _useLegacyDependencyGraphResolution;
    public PackageSpecReferenceDependencyProvider(IEnumerable`1<ExternalProjectReference> externalProjects, ILogger logger);
    public PackageSpecReferenceDependencyProvider(IEnumerable`1<ExternalProjectReference> externalProjects, ILogger logger, bool useLegacyDependencyGraphResolution);
    internal PackageSpecReferenceDependencyProvider(IEnumerable`1<ExternalProjectReference> externalProjects, IEnvironmentVariableReader environmentVariableReader, bool useLegacyDependencyGraphResolution);
    public sealed virtual bool SupportsType(LibraryDependencyTarget libraryType);
    public sealed virtual Library GetLibrary(LibraryRange libraryRange, NuGetFramework targetFramework);
    private void AddLibraryProperties(Library library, PackageSpec packageSpec, NuGetFramework targetFramework);
    private List`1<LibraryDependency> GetDependenciesFromSpecRestoreMetadata(PackageSpec packageSpec, NuGetFramework targetFramework);
    private List`1<LibraryDependency> GetDependenciesFromExternalReference(ExternalProjectReference externalReference, PackageSpec packageSpec, NuGetFramework targetFramework);
    internal List`1<LibraryDependency> GetSpecDependencies(PackageSpec packageSpec, NuGetFramework targetFramework);
    private bool IsProject(LibraryDependency dependency);
    private List`1<ExternalProjectReference> GetChildReferences(ExternalProjectReference parent);
}
public static class NuGet.ProjectModel.PackageSpecUtility : object {
    public static NuGetVersion SpecifySnapshot(string version, string snapshotValue);
    public static bool IsSnapshotVersion(string version);
}
public class NuGet.ProjectModel.PackageSpecWriter : object {
    public static void Write(PackageSpec packageSpec, IObjectWriter writer);
    internal static void Write(PackageSpec packageSpec, IObjectWriter writer, bool hashing, IEnvironmentVariableReader environmentVariableReader);
    public static void WriteToFile(PackageSpec packageSpec, string filePath);
    private static bool IsMetadataValid(ProjectRestoreMetadata msbuildMetadata);
    private static void SetMSBuildMetadata(IObjectWriter writer, PackageSpec packageSpec, IEnvironmentVariableReader environmentVariableReader);
    private static string ApplyMacro(string value, string userSettingsDirectory, bool useMacros);
    private static void WriteMetadataBooleans(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void WriteNuGetLockFileProperties(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void WriteNuGetAuditProperties(IObjectWriter writer, RestoreAuditProperties auditProperties);
    private static void WriteMetadataTargetFrameworks(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void WriteMetadataFiles(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void WriteMetadataSources(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void SetWarningProperties(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    [ObsoleteAttribute]
private static void SetPackOptions(IObjectWriter writer, PackageSpec packageSpec);
    private static void SetDependencies(IObjectWriter writer, IList`1<LibraryDependency> libraryDependencies);
    internal static void SetDependencies(IObjectWriter writer, string name, IEnumerable`1<LibraryDependency> libraryDependencies);
    internal static void SetCentralTransitveDependencyGroup(IObjectWriter writer, string name, IEnumerable`1<LibraryDependency> libraryDependencies);
    private static void SetImports(IObjectWriter writer, IList`1<NuGetFramework> frameworks);
    private static void SetDownloadDependencies(IObjectWriter writer, IList`1<DownloadDependency> downloadDependencies);
    private static void SetFrameworks(IObjectWriter writer, IList`1<TargetFrameworkInformation> frameworks, bool hashing);
    private static NuGetFramework DeconstructFallbackFrameworks(NuGetFramework nuGetFramework);
    private static void SetFrameworkReferences(IObjectWriter writer, ISet`1<FrameworkDependency> frameworkReferences);
    private static void SetCentralDependencies(IObjectWriter writer, ICollection`1<CentralPackageVersion> centralPackageVersions, bool hashing);
    private static void SetValueIfTrue(IObjectWriter writer, string name, bool value);
    private static void SetValueIfFalse(IObjectWriter writer, string name, bool value);
    private static void SetValueIfNotNull(IObjectWriter writer, string name, string value);
    private static void SetValue(IObjectWriter writer, string name, string value);
    private static void SetArrayValue(IObjectWriter writer, string name, IEnumerable`1<string> values);
    private static void SetDictionaryValue(IObjectWriter writer, string name, IDictionary`2<string, string> values);
    private static void SetDictionaryValues(IObjectWriter writer, string name, IDictionary`2<string, IEnumerable`1<string>> values);
}
public class NuGet.ProjectModel.PackOptions : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageType> <PackageType>k__BackingField;
    [CompilerGeneratedAttribute]
private IncludeExcludeFiles <IncludeExcludeFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IncludeExcludeFiles> <Mappings>k__BackingField;
    public IReadOnlyList`1<PackageType> PackageType { get; public set; }
    public IncludeExcludeFiles IncludeExcludeFiles { get; public set; }
    public IDictionary`2<string, IncludeExcludeFiles> Mappings { get; public set; }
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageType> get_PackageType();
    [CompilerGeneratedAttribute]
public void set_PackageType(IReadOnlyList`1<PackageType> value);
    [CompilerGeneratedAttribute]
public IncludeExcludeFiles get_IncludeExcludeFiles();
    [CompilerGeneratedAttribute]
public void set_IncludeExcludeFiles(IncludeExcludeFiles value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IncludeExcludeFiles> get_Mappings();
    [CompilerGeneratedAttribute]
public void set_Mappings(IDictionary`2<string, IncludeExcludeFiles> value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PackOptions other);
    public PackOptions Clone();
}
public class NuGet.ProjectModel.ProjectFileDependencyGroup : object {
    [CompilerGeneratedAttribute]
private string <FrameworkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Dependencies>k__BackingField;
    public string FrameworkName { get; }
    public IEnumerable`1<string> Dependencies { get; }
    public ProjectFileDependencyGroup(string frameworkName, IEnumerable`1<string> dependencies);
    [CompilerGeneratedAttribute]
public string get_FrameworkName();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Dependencies();
    public sealed virtual bool Equals(ProjectFileDependencyGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.ProjectModel.ProjectLockFile.LockFileDependencyComparerWithoutContentHash : object {
    [CompilerGeneratedAttribute]
private static LockFileDependencyComparerWithoutContentHash <Default>k__BackingField;
    public static LockFileDependencyComparerWithoutContentHash Default { get; }
    private static LockFileDependencyComparerWithoutContentHash();
    [CompilerGeneratedAttribute]
public static LockFileDependencyComparerWithoutContentHash get_Default();
    public sealed virtual bool Equals(LockFileDependency x, LockFileDependency y);
    public sealed virtual int GetHashCode(LockFileDependency obj);
}
public class NuGet.ProjectModel.ProjectRestoreMetadata : object {
    [CompilerGeneratedAttribute]
private ProjectStyle <ProjectStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectJsonPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectUniqueName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageSource> <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <FallbackFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <ConfigFilePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ProjectRestoreMetadataFrameworkInfo> <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <OriginalTargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CrossTargeting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LegacyPackagesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ProjectRestoreMetadataFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateRuntimeAssets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipContentFileWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningProperties <ProjectWideWarningProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private RestoreLockProperties <RestoreLockProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CentralPackageVersionsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CentralPackageVersionOverrideDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CentralPackageFloatingVersionsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CentralPackageTransitivePinningEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private RestoreAuditProperties <RestoreAuditProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <SdkAnalysisLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsingMicrosoftNETSdk>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseLegacyDependencyResolver>k__BackingField;
    public ProjectStyle ProjectStyle { get; public set; }
    public string ProjectPath { get; public set; }
    public string ProjectJsonPath { get; public set; }
    public string OutputPath { get; public set; }
    public string ProjectName { get; public set; }
    public string ProjectUniqueName { get; public set; }
    public IList`1<PackageSource> Sources { get; public set; }
    public string PackagesPath { get; public set; }
    public string CacheFilePath { get; public set; }
    public IList`1<string> FallbackFolders { get; public set; }
    public IList`1<string> ConfigFilePaths { get; public set; }
    public IList`1<ProjectRestoreMetadataFrameworkInfo> TargetFrameworks { get; public set; }
    public IList`1<string> OriginalTargetFrameworks { get; public set; }
    public bool CrossTargeting { get; public set; }
    public bool LegacyPackagesDirectory { get; public set; }
    public IList`1<ProjectRestoreMetadataFile> Files { get; public set; }
    public bool ValidateRuntimeAssets { get; public set; }
    public bool SkipContentFileWrite { get; public set; }
    public WarningProperties ProjectWideWarningProperties { get; public set; }
    public RestoreLockProperties RestoreLockProperties { get; public set; }
    public bool CentralPackageVersionsEnabled { get; public set; }
    public bool CentralPackageVersionOverrideDisabled { get; public set; }
    public bool CentralPackageFloatingVersionsEnabled { get; public set; }
    public bool CentralPackageTransitivePinningEnabled { get; public set; }
    public RestoreAuditProperties RestoreAuditProperties { get; public set; }
    public NuGetVersion SdkAnalysisLevel { get; public set; }
    public bool UsingMicrosoftNETSdk { get; public set; }
    public bool UseLegacyDependencyResolver { get; public set; }
    [CompilerGeneratedAttribute]
public ProjectStyle get_ProjectStyle();
    [CompilerGeneratedAttribute]
public void set_ProjectStyle(ProjectStyle value);
    [CompilerGeneratedAttribute]
public string get_ProjectPath();
    [CompilerGeneratedAttribute]
public void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectJsonPath();
    [CompilerGeneratedAttribute]
public void set_ProjectJsonPath(string value);
    [CompilerGeneratedAttribute]
public string get_OutputPath();
    [CompilerGeneratedAttribute]
public void set_OutputPath(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectName();
    [CompilerGeneratedAttribute]
public void set_ProjectName(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectUniqueName();
    [CompilerGeneratedAttribute]
public void set_ProjectUniqueName(string value);
    [CompilerGeneratedAttribute]
public IList`1<PackageSource> get_Sources();
    [CompilerGeneratedAttribute]
public void set_Sources(IList`1<PackageSource> value);
    [CompilerGeneratedAttribute]
public string get_PackagesPath();
    [CompilerGeneratedAttribute]
public void set_PackagesPath(string value);
    [CompilerGeneratedAttribute]
public string get_CacheFilePath();
    [CompilerGeneratedAttribute]
public void set_CacheFilePath(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_FallbackFolders();
    [CompilerGeneratedAttribute]
public void set_FallbackFolders(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_ConfigFilePaths();
    [CompilerGeneratedAttribute]
public void set_ConfigFilePaths(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<ProjectRestoreMetadataFrameworkInfo> get_TargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworks(IList`1<ProjectRestoreMetadataFrameworkInfo> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_OriginalTargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_OriginalTargetFrameworks(IList`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_CrossTargeting();
    [CompilerGeneratedAttribute]
public void set_CrossTargeting(bool value);
    [CompilerGeneratedAttribute]
public bool get_LegacyPackagesDirectory();
    [CompilerGeneratedAttribute]
public void set_LegacyPackagesDirectory(bool value);
    [CompilerGeneratedAttribute]
public IList`1<ProjectRestoreMetadataFile> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(IList`1<ProjectRestoreMetadataFile> value);
    [CompilerGeneratedAttribute]
public bool get_ValidateRuntimeAssets();
    [CompilerGeneratedAttribute]
public void set_ValidateRuntimeAssets(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipContentFileWrite();
    [CompilerGeneratedAttribute]
public void set_SkipContentFileWrite(bool value);
    [CompilerGeneratedAttribute]
public WarningProperties get_ProjectWideWarningProperties();
    [CompilerGeneratedAttribute]
public void set_ProjectWideWarningProperties(WarningProperties value);
    [CompilerGeneratedAttribute]
public RestoreLockProperties get_RestoreLockProperties();
    [CompilerGeneratedAttribute]
public void set_RestoreLockProperties(RestoreLockProperties value);
    [CompilerGeneratedAttribute]
public bool get_CentralPackageVersionsEnabled();
    [CompilerGeneratedAttribute]
public void set_CentralPackageVersionsEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_CentralPackageVersionOverrideDisabled();
    [CompilerGeneratedAttribute]
public void set_CentralPackageVersionOverrideDisabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_CentralPackageFloatingVersionsEnabled();
    [CompilerGeneratedAttribute]
public void set_CentralPackageFloatingVersionsEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_CentralPackageTransitivePinningEnabled();
    [CompilerGeneratedAttribute]
public void set_CentralPackageTransitivePinningEnabled(bool value);
    [CompilerGeneratedAttribute]
public RestoreAuditProperties get_RestoreAuditProperties();
    [CompilerGeneratedAttribute]
public void set_RestoreAuditProperties(RestoreAuditProperties value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_SdkAnalysisLevel();
    [CompilerGeneratedAttribute]
public void set_SdkAnalysisLevel(NuGetVersion value);
    [CompilerGeneratedAttribute]
public bool get_UsingMicrosoftNETSdk();
    [CompilerGeneratedAttribute]
public void set_UsingMicrosoftNETSdk(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseLegacyDependencyResolver();
    [CompilerGeneratedAttribute]
public void set_UseLegacyDependencyResolver(bool value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProjectRestoreMetadata other);
    private HashSet`1<string> GetSources(IList`1<PackageSource> sources);
    public virtual ProjectRestoreMetadata Clone();
    protected void FillClone(ProjectRestoreMetadata clone);
}
public class NuGet.ProjectModel.ProjectRestoreMetadataFile : object {
    [CompilerGeneratedAttribute]
private string <PackagePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AbsolutePath>k__BackingField;
    public string PackagePath { get; }
    public string AbsolutePath { get; }
    public ProjectRestoreMetadataFile(string packagePath, string absolutePath);
    [CompilerGeneratedAttribute]
public string get_PackagePath();
    [CompilerGeneratedAttribute]
public string get_AbsolutePath();
    public sealed virtual bool Equals(ProjectRestoreMetadataFile other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int CompareTo(ProjectRestoreMetadataFile other);
    public ProjectRestoreMetadataFile Clone();
}
public class NuGet.ProjectModel.ProjectRestoreMetadataFrameworkInfo : object {
    [CompilerGeneratedAttribute]
private string <TargetAlias>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <FrameworkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ProjectRestoreReference> <ProjectReferences>k__BackingField;
    public string TargetAlias { get; public set; }
    public NuGetFramework FrameworkName { get; public set; }
    public IList`1<ProjectRestoreReference> ProjectReferences { get; public set; }
    public ProjectRestoreMetadataFrameworkInfo(NuGetFramework frameworkName);
    [CompilerGeneratedAttribute]
public string get_TargetAlias();
    [CompilerGeneratedAttribute]
public void set_TargetAlias(string value);
    [CompilerGeneratedAttribute]
public NuGetFramework get_FrameworkName();
    [CompilerGeneratedAttribute]
public void set_FrameworkName(NuGetFramework value);
    [CompilerGeneratedAttribute]
public IList`1<ProjectRestoreReference> get_ProjectReferences();
    [CompilerGeneratedAttribute]
public void set_ProjectReferences(IList`1<ProjectRestoreReference> value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProjectRestoreMetadataFrameworkInfo other);
    public ProjectRestoreMetadataFrameworkInfo Clone();
}
public class NuGet.ProjectModel.ProjectRestoreReference : object {
    [CompilerGeneratedAttribute]
private string <ProjectUniqueName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIncludeFlags <IncludeAssets>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIncludeFlags <ExcludeAssets>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIncludeFlags <PrivateAssets>k__BackingField;
    public string ProjectUniqueName { get; public set; }
    public string ProjectPath { get; public set; }
    public LibraryIncludeFlags IncludeAssets { get; public set; }
    public LibraryIncludeFlags ExcludeAssets { get; public set; }
    public LibraryIncludeFlags PrivateAssets { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ProjectUniqueName();
    [CompilerGeneratedAttribute]
public void set_ProjectUniqueName(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectPath();
    [CompilerGeneratedAttribute]
public void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public LibraryIncludeFlags get_IncludeAssets();
    [CompilerGeneratedAttribute]
public void set_IncludeAssets(LibraryIncludeFlags value);
    [CompilerGeneratedAttribute]
public LibraryIncludeFlags get_ExcludeAssets();
    [CompilerGeneratedAttribute]
public void set_ExcludeAssets(LibraryIncludeFlags value);
    [CompilerGeneratedAttribute]
public LibraryIncludeFlags get_PrivateAssets();
    [CompilerGeneratedAttribute]
public void set_PrivateAssets(LibraryIncludeFlags value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public sealed virtual bool Equals(ProjectRestoreReference other);
    public ProjectRestoreReference Clone();
}
public class NuGet.ProjectModel.ProjectRestoreSettings : object {
    [CompilerGeneratedAttribute]
private bool <HideWarningsAndErrors>k__BackingField;
    public bool HideWarningsAndErrors { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_HideWarningsAndErrors();
    [CompilerGeneratedAttribute]
public void set_HideWarningsAndErrors(bool value);
    public ProjectRestoreSettings Clone();
    public virtual bool Equals(object obj);
    public bool Equals(ProjectRestoreSettings other);
    public virtual int GetHashCode();
}
public enum NuGet.ProjectModel.ProjectStyle : Enum {
    public ushort value__;
    public static ProjectStyle Unknown;
    public static ProjectStyle ProjectJson;
    public static ProjectStyle PackageReference;
    public static ProjectStyle DotnetCliTool;
    public static ProjectStyle Standalone;
    public static ProjectStyle PackagesConfig;
    public static ProjectStyle DotnetToolReference;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NuGet.ProjectModel.RestoreAuditProperties : object {
    [CompilerGeneratedAttribute]
private string <EnableAudit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuditLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuditMode>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private HashSet`1<string> <SuppressedAdvisories>k__BackingField;
    public string EnableAudit { get; public set; }
    public string AuditLevel { get; public set; }
    public string AuditMode { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public HashSet`1<string> SuppressedAdvisories { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EnableAudit();
    [CompilerGeneratedAttribute]
public void set_EnableAudit(string value);
    [CompilerGeneratedAttribute]
public string get_AuditLevel();
    [CompilerGeneratedAttribute]
public void set_AuditLevel(string value);
    [CompilerGeneratedAttribute]
public string get_AuditMode();
    [CompilerGeneratedAttribute]
public void set_AuditMode(string value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_SuppressedAdvisories();
    [CompilerGeneratedAttribute]
public void set_SuppressedAdvisories(HashSet`1<string> value);
    public bool TryParseEnableAudit(Boolean& result);
    public bool TryParseAuditLevel(PackageVulnerabilitySeverity& result);
    public sealed virtual bool Equals(RestoreAuditProperties other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(RestoreAuditProperties x, RestoreAuditProperties y);
    public static bool op_Inequality(RestoreAuditProperties x, RestoreAuditProperties y);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
internal RestoreAuditProperties Clone();
}
public class NuGet.ProjectModel.RestoreLockProperties : object {
    [CompilerGeneratedAttribute]
private string <RestorePackagesWithLockFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NuGetLockFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RestoreLockedMode>k__BackingField;
    public string RestorePackagesWithLockFile { get; }
    public string NuGetLockFilePath { get; }
    public bool RestoreLockedMode { get; }
    public RestoreLockProperties(string restorePackagesWithLockFile, string nuGetLockFilePath, bool restoreLockedMode);
    [CompilerGeneratedAttribute]
public string get_RestorePackagesWithLockFile();
    [CompilerGeneratedAttribute]
public string get_NuGetLockFilePath();
    [CompilerGeneratedAttribute]
public bool get_RestoreLockedMode();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RestoreLockProperties other);
    public RestoreLockProperties Clone();
}
[ExtensionAttribute]
internal static class NuGet.ProjectModel.StringExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static ValueTuple`2<string, string> SplitInTwo(string s, char separator);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.ProjectModel.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentNullOrEmpty { get; }
    internal static string Invalid_AttributeValue { get; }
    internal static string InvalidDependencyTarget { get; }
    internal static string InvalidPackageType { get; }
    internal static string Log_ErrorReadingLockFile { get; }
    internal static string Log_ErrorReadingProjectJson { get; }
    internal static string Log_ErrorReadingProjectJsonWithLocation { get; }
    internal static string Log_InvalidImportFramework { get; }
    internal static string Log_ProblemReadingCacheFile { get; }
    internal static string MissingVersionOnDependency { get; }
    internal static string MissingVersionOnTool { get; }
    internal static string None { get; }
    internal static string PackagesLockFile_CentralPackageVersionRemoved { get; }
    internal static string PackagesLockFile_IncompatibleLockFileVersion { get; }
    internal static string PackagesLockFile_MismatchedTargetFrameworks { get; }
    internal static string PackagesLockFile_NewTargetFramework { get; }
    internal static string PackagesLockFile_PackageReferenceAdded { get; }
    internal static string PackagesLockFile_PackageReferencesHaveChanged { get; }
    internal static string PackagesLockFile_PackageReferenceVersionChanged { get; }
    internal static string PackagesLockFile_ProjectReferenceAdded { get; }
    internal static string PackagesLockFile_ProjectReferenceDependenciesHasChanged { get; }
    internal static string PackagesLockFile_ProjectReferenceHasNoCompatibleTargetFramework { get; }
    internal static string PackagesLockFile_ProjectReferencesHasChange { get; }
    internal static string PackagesLockFile_ProjectTransitiveDependencyChanged { get; }
    internal static string PackagesLockFile_ProjectTransitiveDependencyVersionChanged { get; }
    internal static string PackagesLockFile_RestoreMetadataMissingTfms { get; }
    internal static string PackagesLockFile_RuntimeIdentifiersChanged { get; }
    internal static string PackagesLockFile_UnableToLoadPackagespec { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgumentNullOrEmpty();
    internal static string get_Invalid_AttributeValue();
    internal static string get_InvalidDependencyTarget();
    internal static string get_InvalidPackageType();
    internal static string get_Log_ErrorReadingLockFile();
    internal static string get_Log_ErrorReadingProjectJson();
    internal static string get_Log_ErrorReadingProjectJsonWithLocation();
    internal static string get_Log_InvalidImportFramework();
    internal static string get_Log_ProblemReadingCacheFile();
    internal static string get_MissingVersionOnDependency();
    internal static string get_MissingVersionOnTool();
    internal static string get_None();
    internal static string get_PackagesLockFile_CentralPackageVersionRemoved();
    internal static string get_PackagesLockFile_IncompatibleLockFileVersion();
    internal static string get_PackagesLockFile_MismatchedTargetFrameworks();
    internal static string get_PackagesLockFile_NewTargetFramework();
    internal static string get_PackagesLockFile_PackageReferenceAdded();
    internal static string get_PackagesLockFile_PackageReferencesHaveChanged();
    internal static string get_PackagesLockFile_PackageReferenceVersionChanged();
    internal static string get_PackagesLockFile_ProjectReferenceAdded();
    internal static string get_PackagesLockFile_ProjectReferenceDependenciesHasChanged();
    internal static string get_PackagesLockFile_ProjectReferenceHasNoCompatibleTargetFramework();
    internal static string get_PackagesLockFile_ProjectReferencesHasChange();
    internal static string get_PackagesLockFile_ProjectTransitiveDependencyChanged();
    internal static string get_PackagesLockFile_ProjectTransitiveDependencyVersionChanged();
    internal static string get_PackagesLockFile_RestoreMetadataMissingTfms();
    internal static string get_PackagesLockFile_RuntimeIdentifiersChanged();
    internal static string get_PackagesLockFile_UnableToLoadPackagespec();
}
public class NuGet.ProjectModel.TargetFrameworkInformation : object {
    [CompilerGeneratedAttribute]
private string <TargetAlias>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <FrameworkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LibraryDependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NuGetFramework> <Imports>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AssetTargetFallback>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Warn>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DownloadDependency> <DownloadDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, CentralPackageVersion> <CentralPackageVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<FrameworkDependency> <FrameworkReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifierGraphPath>k__BackingField;
    public string TargetAlias { get; public set; }
    public NuGetFramework FrameworkName { get; public set; }
    public IList`1<LibraryDependency> Dependencies { get; public set; }
    public IList`1<NuGetFramework> Imports { get; public set; }
    public bool AssetTargetFallback { get; public set; }
    public bool Warn { get; public set; }
    public IList`1<DownloadDependency> DownloadDependencies { get; }
    public IDictionary`2<string, CentralPackageVersion> CentralPackageVersions { get; }
    public ISet`1<FrameworkDependency> FrameworkReferences { get; }
    public string RuntimeIdentifierGraphPath { get; public set; }
    internal TargetFrameworkInformation(TargetFrameworkInformation cloneFrom);
    [CompilerGeneratedAttribute]
public string get_TargetAlias();
    [CompilerGeneratedAttribute]
public void set_TargetAlias(string value);
    [CompilerGeneratedAttribute]
public NuGetFramework get_FrameworkName();
    [CompilerGeneratedAttribute]
public void set_FrameworkName(NuGetFramework value);
    [CompilerGeneratedAttribute]
public IList`1<LibraryDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<LibraryDependency> value);
    [CompilerGeneratedAttribute]
public IList`1<NuGetFramework> get_Imports();
    [CompilerGeneratedAttribute]
public void set_Imports(IList`1<NuGetFramework> value);
    [CompilerGeneratedAttribute]
public bool get_AssetTargetFallback();
    [CompilerGeneratedAttribute]
public void set_AssetTargetFallback(bool value);
    [CompilerGeneratedAttribute]
public bool get_Warn();
    [CompilerGeneratedAttribute]
public void set_Warn(bool value);
    [CompilerGeneratedAttribute]
public IList`1<DownloadDependency> get_DownloadDependencies();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, CentralPackageVersion> get_CentralPackageVersions();
    [CompilerGeneratedAttribute]
public ISet`1<FrameworkDependency> get_FrameworkReferences();
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifierGraphPath();
    [CompilerGeneratedAttribute]
public void set_RuntimeIdentifierGraphPath(string value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TargetFrameworkInformation other);
    public TargetFrameworkInformation Clone();
    [CompilerGeneratedAttribute]
internal static IList`1<T> <.ctor>g__CloneList|38_1(IList`1<T> source, Func`2<T, T> cloneFunc);
}
public class NuGet.ProjectModel.ToolPathResolver : object {
    private string _packagesDirectory;
    private bool _isLowercase;
    public ToolPathResolver(string packagesDirectory);
    public ToolPathResolver(string packagesDirectory, bool isLowercase);
    public string GetLockFilePath(string toolDirectory);
    public string GetLockFilePath(string packageId, NuGetVersion version, NuGetFramework framework);
    public string GetToolDirectoryPath(string packageId, NuGetVersion version, NuGetFramework framework);
    private string GetPackagesToolsBasePath();
    public string GetBestToolDirectoryPath(string packageId, VersionRange versionRange, NuGetFramework framework);
    private IEnumerable`1<NuGetVersion> GetAvailableToolVersions(string packageId);
}
[ExtensionAttribute]
internal static class NuGet.ProjectModel.Utf8JsonReaderExtensions : object {
    internal static Utf8JsonStreamLockFileConverter LockFileConverter;
    internal static Utf8JsonStreamLockFileItemConverter`1<LockFileItem> LockFileItemConverter;
    internal static Utf8JsonStreamLockFileItemConverter`1<LockFileContentFile> LockFileContentFileConverter;
    internal static Utf8JsonStreamLockFileItemConverter`1<LockFileRuntimeTarget> LockFileRuntimeTargetConverter;
    internal static Utf8JsonStreamLockFileTargetLibraryConverter LockFileTargetLibraryConverter;
    internal static Utf8JsonStreamLockFileLibraryConverter LockFileLibraryConverter;
    internal static Utf8JsonStreamLockFileTargetConverter LockFileTargetConverter;
    internal static Utf8JsonStreamProjectFileDependencyGroupConverter ProjectFileDepencencyGroupConverter;
    internal static Utf8JsonStreamIAssetsLogMessageConverter IAssetsLogMessageConverter;
    private static Utf8JsonReaderExtensions();
    [ExtensionAttribute]
internal static string ReadTokenAsString(Utf8JsonReader& reader);
    [ExtensionAttribute]
private static string ReadNumberAsString(Utf8JsonReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamIAssetsLogMessageConverter : object {
    private static Byte[] LevelPropertyName;
    private static Byte[] CodePropertyName;
    private static Byte[] WarningLevelPropertyName;
    private static Byte[] FilePathPropertyName;
    private static Byte[] StartLineNumberPropertyName;
    private static Byte[] StartColumnNumberPropertyName;
    private static Byte[] EndLineNumberPropertyName;
    private static Byte[] EndColumnNumberPropertyName;
    private static Byte[] MessagePropertyName;
    private static Byte[] LibraryIdPropertyName;
    private static Byte[] TargetGraphsPropertyName;
    private static Utf8JsonStreamIAssetsLogMessageConverter();
    public sealed virtual IAssetsLogMessage Read(Utf8JsonStreamReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamLockFileConverter : object {
    private static Byte[] VersionPropertyName;
    private static Byte[] LibrariesPropertyName;
    private static Byte[] TargetsPropertyName;
    private static Byte[] ProjectFileDependencyGroupsPropertyName;
    private static Byte[] PackageFoldersPropertyName;
    private static Byte[] ProjectPropertyName;
    private static Byte[] CentralTransitiveDependencyGroupsPropertyName;
    private static Byte[] LogsPropertyName;
    private static Utf8JsonStreamLockFileConverter();
    public sealed virtual LockFile Read(Utf8JsonStreamReader& reader);
    public LockFile Read(Utf8JsonStreamReader& reader, LockFileReadFlags flags);
}
internal class NuGet.ProjectModel.Utf8JsonStreamLockFileItemConverter`1 : object {
    private Func`2<string, T> _lockFileItemCreator;
    public Utf8JsonStreamLockFileItemConverter`1(Func`2<string, T> lockFileItemCreator);
    public sealed virtual T Read(Utf8JsonStreamReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamLockFileLibraryConverter : object {
    private static Byte[] Sha512PropertyName;
    private static Byte[] TypePropertyName;
    private static Byte[] PathPropertyName;
    private static Byte[] MsbuildProjectPropertyName;
    private static Byte[] ServicablePropertyName;
    private static Byte[] HasToolsPropertyName;
    private static Byte[] FilesPropertyName;
    private static Utf8JsonStreamLockFileLibraryConverter();
    public sealed virtual LockFileLibrary Read(Utf8JsonStreamReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamLockFileTargetConverter : object {
    public sealed virtual LockFileTarget Read(Utf8JsonStreamReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamLockFileTargetLibraryConverter : object {
    private static Byte[] TypePropertyName;
    private static Byte[] FrameworkPropertyName;
    private static Byte[] DependenciesPropertyName;
    private static Byte[] FrameworkAssembliesPropertyName;
    private static Byte[] RuntimePropertyName;
    private static Byte[] CompilePropertyName;
    private static Byte[] ResourcePropertyName;
    private static Byte[] NativePropertyName;
    private static Byte[] BuildPropertyName;
    private static Byte[] BuildMultiTargetingPropertyName;
    private static Byte[] ContentFilesPropertyName;
    private static Byte[] RuntimeTargetsPropertyName;
    private static Byte[] ToolsPropertyName;
    private static Byte[] EmbedPropertyName;
    private static Byte[] FrameworkReferencesPropertyName;
    private static Utf8JsonStreamLockFileTargetLibraryConverter();
    public sealed virtual LockFileTargetLibrary Read(Utf8JsonStreamReader& reader);
    private IList`1<PackageDependency> ReadPackageDependencyList(Utf8JsonStreamReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamProjectFileDependencyGroupConverter : object {
    public sealed virtual ProjectFileDependencyGroup Read(Utf8JsonStreamReader& reader);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class NuGet.ProjectModel.Utf8JsonStreamReader : ValueType {
    private static Char[] DelimitedStringDelimiters;
    private static Byte[] Utf8Bom;
    private static JsonReaderOptions DefaultJsonReaderOptions;
    private static int BufferSizeDefault;
    private static int MinBufferSize;
    private Utf8JsonReader _reader;
    private Stream _stream;
    private Byte[] _buffer;
    private bool _disposed;
    private ArrayPool`1<byte> _bufferPool;
    private int _bufferUsed;
    internal bool IsFinalBlock { get; }
    internal JsonTokenType TokenType { get; }
    internal Utf8JsonStreamReader(Stream stream, int bufferSize, ArrayPool`1<byte> arrayPool);
    private static Utf8JsonStreamReader();
    internal bool get_IsFinalBlock();
    internal JsonTokenType get_TokenType();
    internal bool ValueTextEquals(ReadOnlySpan`1<byte> utf8Text);
    internal bool TryGetInt32(Int32& value);
    internal string GetString();
    internal bool GetBoolean();
    internal int GetInt32();
    internal bool Read();
    internal void Skip();
    internal IList`1<T> ReadObjectAsList(IUtf8JsonStreamReaderConverter`1<T> streamReaderConverter);
    internal IList`1<T> ReadListOfObjects(IUtf8JsonStreamReaderConverter`1<T> streamReaderConverter);
    internal string ReadNextTokenAsString();
    internal IList`1<string> ReadStringArrayAsIList(IList`1<string> strings);
    internal IReadOnlyList`1<string> ReadDelimitedString();
    internal bool ReadNextTokenAsBoolOrFalse();
    internal bool ReadNextTokenAsBoolOrThrowAnException(Byte[] propertyName);
    internal IReadOnlyList`1<string> ReadNextStringOrArrayOfStringsAsReadOnlyList();
    internal IReadOnlyList`1<string> ReadStringArrayAsReadOnlyListFromArrayStart();
    private void GetMoreBytesFromStream();
    private void ReadStreamIntoBuffer(JsonReaderState jsonReaderState);
    public void Dispose();
    private void ThrowExceptionIfDisposed();
}
public class NuGet.ProjectModel.WarningProperties : object {
    [CompilerGeneratedAttribute]
private ISet`1<NuGetLogCode> <WarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<NuGetLogCode> <NoWarn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllWarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<NuGetLogCode> <WarningsNotAsErrors>k__BackingField;
    public ISet`1<NuGetLogCode> WarningsAsErrors { get; }
    public ISet`1<NuGetLogCode> NoWarn { get; }
    public bool AllWarningsAsErrors { get; public set; }
    public ISet`1<NuGetLogCode> WarningsNotAsErrors { get; }
    [ObsoleteAttribute("Use the constructor with 4 instead.")]
public WarningProperties(ISet`1<NuGetLogCode> warningsAsErrors, ISet`1<NuGetLogCode> noWarn, bool allWarningsAsErrors);
    public WarningProperties(ISet`1<NuGetLogCode> warningsAsErrors, ISet`1<NuGetLogCode> noWarn, bool allWarningsAsErrors, ISet`1<NuGetLogCode> warningsNotAsErrors);
    [CompilerGeneratedAttribute]
public ISet`1<NuGetLogCode> get_WarningsAsErrors();
    [CompilerGeneratedAttribute]
public ISet`1<NuGetLogCode> get_NoWarn();
    [CompilerGeneratedAttribute]
public bool get_AllWarningsAsErrors();
    [CompilerGeneratedAttribute]
public void set_AllWarningsAsErrors(bool value);
    [CompilerGeneratedAttribute]
public ISet`1<NuGetLogCode> get_WarningsNotAsErrors();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(WarningProperties other);
    public WarningProperties Clone();
    public static WarningProperties GetWarningProperties(string treatWarningsAsErrors, string warningsAsErrors, string noWarn, string warningsNotAsErrors);
    [ObsoleteAttribute]
public static WarningProperties GetWarningProperties(string treatWarningsAsErrors, string warningsAsErrors, string noWarn);
    public static WarningProperties GetWarningProperties(string treatWarningsAsErrors, IEnumerable`1<NuGetLogCode> warningsAsErrors, IEnumerable`1<NuGetLogCode> noWarn, IEnumerable`1<NuGetLogCode> warningsNotAsErrors);
    [ObsoleteAttribute]
public static WarningProperties GetWarningProperties(string treatWarningsAsErrors, IEnumerable`1<NuGetLogCode> warningsAsErrors, IEnumerable`1<NuGetLogCode> noWarn);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class NuGet.Shared.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
