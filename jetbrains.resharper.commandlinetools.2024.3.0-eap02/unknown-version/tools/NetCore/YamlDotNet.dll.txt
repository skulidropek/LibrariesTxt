public class YamlDotNet.Core.AnchorNotFoundException : YamlException {
    public AnchorNotFoundException(string message);
    public AnchorNotFoundException(Mark start, Mark end, string message);
    public AnchorNotFoundException(string message, Exception inner);
}
internal class YamlDotNet.Core.CharacterAnalyzer`1 : object {
    private TBuffer buffer;
    public TBuffer Buffer { get; }
    public bool EndOfInput { get; }
    public CharacterAnalyzer`1(TBuffer buffer);
    public TBuffer get_Buffer();
    public bool get_EndOfInput();
    public char Peek(int offset);
    public void Skip(int length);
    public bool IsAlphaNumericDashOrUnderscore(int offset);
    public bool IsAscii(int offset);
    public bool IsPrintable(int offset);
    public bool IsDigit(int offset);
    public int AsDigit(int offset);
    public bool IsHex(int offset);
    public int AsHex(int offset);
    public bool IsSpace(int offset);
    public bool IsZero(int offset);
    public bool IsTab(int offset);
    public bool IsWhite(int offset);
    public bool IsBreak(int offset);
    public bool IsCrLf(int offset);
    public bool IsBreakOrZero(int offset);
    public bool IsWhiteBreakOrZero(int offset);
    public bool Check(char expected, int offset);
    public bool Check(string expectedCharacters, int offset);
}
public static class YamlDotNet.Core.Constants : object {
    public static TagDirective[] DefaultTagDirectives;
    public static int MajorVersion;
    public static int MinorVersion;
    public static char HandleCharacter;
    public static string DefaultHandle;
    private static Constants();
}
public class YamlDotNet.Core.Cursor : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <LineOffset>k__BackingField;
    public int Index { get; public set; }
    public int Line { get; public set; }
    public int LineOffset { get; public set; }
    public Cursor(Cursor cursor);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_LineOffset();
    [CompilerGeneratedAttribute]
public void set_LineOffset(int value);
    public Mark Mark();
    public void Skip();
    public void SkipLineByOffset(int offset);
    public void ForceSkipLineAfterNonBreak();
}
public class YamlDotNet.Core.Emitter : object {
    private static int MinBestIndent;
    private static int MaxBestIndent;
    private static int MaxAliasLength;
    private static Regex uriReplacer;
    private TextWriter output;
    private bool outputUsesUnicodeEncoding;
    private bool isCanonical;
    private int bestIndent;
    private int bestWidth;
    private EmitterState state;
    private Stack`1<EmitterState> states;
    private Queue`1<ParsingEvent> events;
    private Stack`1<int> indents;
    private TagDirectiveCollection tagDirectives;
    private int indent;
    private int flowLevel;
    private bool isMappingContext;
    private bool isSimpleKeyContext;
    private bool isRootContext;
    private int column;
    private bool isWhitespace;
    private bool isIndentation;
    private bool isOpenEnded;
    private bool isDocumentEndWritten;
    private AnchorData anchorData;
    private TagData tagData;
    private ScalarData scalarData;
    public Emitter(TextWriter output);
    public Emitter(TextWriter output, int bestIndent);
    public Emitter(TextWriter output, int bestIndent, int bestWidth);
    public Emitter(TextWriter output, int bestIndent, int bestWidth, bool isCanonical);
    private static Emitter();
    public sealed virtual void Emit(ParsingEvent event);
    private bool NeedMoreEvents();
    private void AnalyzeEvent(ParsingEvent evt);
    private void AnalyzeAnchor(string anchor, bool isAlias);
    private void AnalyzeScalar(Scalar scalar);
    private bool ValueIsRepresentableInOutputEncoding(string value);
    private bool IsUnicode(Encoding encoding);
    private void AnalyzeTag(string tag);
    private void StateMachine(ParsingEvent evt);
    private void EmitComment(Comment comment);
    private void EmitStreamStart(ParsingEvent evt);
    private void EmitDocumentStart(ParsingEvent evt, bool isFirst);
    private TagDirectiveCollection NonDefaultTagsAmong(IEnumerable`1<TagDirective> tagCollection);
    private void AnalyzeVersionDirective(VersionDirective versionDirective);
    private static void AppendTagDirectiveTo(TagDirective value, bool allowDuplicates, TagDirectiveCollection tagDirectives);
    private void EmitDocumentContent(ParsingEvent evt);
    private void EmitNode(ParsingEvent evt, bool isRoot, bool isMapping, bool isSimpleKey);
    private void EmitAlias();
    private void EmitScalar(ParsingEvent evt);
    private void SelectScalarStyle(ParsingEvent evt);
    private void ProcessScalar();
    private void WritePlainScalar(string value, bool allowBreaks);
    private void WriteSingleQuotedScalar(string value, bool allowBreaks);
    private void WriteDoubleQuotedScalar(string value, bool allowBreaks);
    private void WriteLiteralScalar(string value);
    private void WriteFoldedScalar(string value);
    private static bool IsSpace(char character);
    private static bool IsBreak(char character, Char& breakChar);
    private static bool IsBlank(char character);
    private static bool IsPrintable(char character);
    private static bool IsHighSurrogate(char c);
    private static bool IsLowSurrogate(char c);
    private void EmitSequenceStart(ParsingEvent evt);
    private void EmitMappingStart(ParsingEvent evt);
    private void ProcessAnchor();
    private void ProcessTag();
    private void EmitDocumentEnd(ParsingEvent evt);
    private void EmitFlowSequenceItem(ParsingEvent evt, bool isFirst);
    private void EmitFlowMappingKey(ParsingEvent evt, bool isFirst);
    private void EmitFlowMappingValue(ParsingEvent evt, bool isSimple);
    private void EmitBlockSequenceItem(ParsingEvent evt, bool isFirst);
    private void EmitBlockMappingKey(ParsingEvent evt, bool isFirst);
    private void EmitBlockMappingValue(ParsingEvent evt, bool isSimple);
    private void IncreaseIndent(bool isFlow, bool isIndentless);
    private bool CheckEmptyDocument();
    private bool CheckSimpleKey();
    private int SafeStringLength(string value);
    private bool CheckEmptySequence();
    private bool CheckEmptyMapping();
    private void WriteBlockScalarHints(string value);
    private void WriteIndicator(string indicator, bool needWhitespace, bool whitespace, bool indentation);
    private void WriteIndent();
    private void WriteAnchor(string value);
    private void WriteTagHandle(string value);
    private void WriteTagContent(string value, bool needsWhitespace);
    private string UrlEncode(string text);
    private void Write(char value);
    private void Write(string value);
    private void WriteBreak(char breakCharacter);
}
internal enum YamlDotNet.Core.EmitterState : Enum {
    public int value__;
    public static EmitterState StreamStart;
    public static EmitterState StreamEnd;
    public static EmitterState FirstDocumentStart;
    public static EmitterState DocumentStart;
    public static EmitterState DocumentContent;
    public static EmitterState DocumentEnd;
    public static EmitterState FlowSequenceFirstItem;
    public static EmitterState FlowSequenceItem;
    public static EmitterState FlowMappingFirstKey;
    public static EmitterState FlowMappingKey;
    public static EmitterState FlowMappingSimpleValue;
    public static EmitterState FlowMappingValue;
    public static EmitterState BlockSequenceFirstItem;
    public static EmitterState BlockSequenceItem;
    public static EmitterState BlockMappingFirstKey;
    public static EmitterState BlockMappingKey;
    public static EmitterState BlockMappingSimpleValue;
    public static EmitterState BlockMappingValue;
}
public class YamlDotNet.Core.Events.AnchorAlias : ParsingEvent {
    private string value;
    internal EventType Type { get; }
    public string Value { get; }
    public AnchorAlias(string value, Mark start, Mark end);
    public AnchorAlias(string value);
    internal virtual EventType get_Type();
    public string get_Value();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
public class YamlDotNet.Core.Events.Comment : ParsingEvent {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <IsInline>k__BackingField;
    public string Value { get; private set; }
    public bool IsInline { get; private set; }
    internal EventType Type { get; }
    public Comment(string value, bool isInline);
    public Comment(string value, bool isInline, Mark start, Mark end);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    [CompilerGeneratedAttribute]
public bool get_IsInline();
    [CompilerGeneratedAttribute]
private void set_IsInline(bool value);
    internal virtual EventType get_Type();
    public virtual void Accept(IParsingEventVisitor visitor);
    public virtual string ToString();
}
public class YamlDotNet.Core.Events.DocumentEnd : ParsingEvent {
    private bool isImplicit;
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public bool IsImplicit { get; }
    public DocumentEnd(bool isImplicit, Mark start, Mark end);
    public DocumentEnd(bool isImplicit);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public bool get_IsImplicit();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
public class YamlDotNet.Core.Events.DocumentStart : ParsingEvent {
    private TagDirectiveCollection tags;
    private VersionDirective version;
    private bool isImplicit;
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public TagDirectiveCollection Tags { get; }
    public VersionDirective Version { get; }
    public bool IsImplicit { get; }
    public DocumentStart(VersionDirective version, TagDirectiveCollection tags, bool isImplicit, Mark start, Mark end);
    public DocumentStart(VersionDirective version, TagDirectiveCollection tags, bool isImplicit);
    public DocumentStart(Mark start, Mark end);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public TagDirectiveCollection get_Tags();
    public VersionDirective get_Version();
    public bool get_IsImplicit();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
internal enum YamlDotNet.Core.Events.EventType : Enum {
    public int value__;
    public static EventType None;
    public static EventType StreamStart;
    public static EventType StreamEnd;
    public static EventType DocumentStart;
    public static EventType DocumentEnd;
    public static EventType Alias;
    public static EventType Scalar;
    public static EventType SequenceStart;
    public static EventType SequenceEnd;
    public static EventType MappingStart;
    public static EventType MappingEnd;
    public static EventType Comment;
}
public interface YamlDotNet.Core.Events.IParsingEventVisitor {
    public abstract virtual void Visit(AnchorAlias e);
    public abstract virtual void Visit(StreamStart e);
    public abstract virtual void Visit(StreamEnd e);
    public abstract virtual void Visit(DocumentStart e);
    public abstract virtual void Visit(DocumentEnd e);
    public abstract virtual void Visit(Scalar e);
    public abstract virtual void Visit(SequenceStart e);
    public abstract virtual void Visit(SequenceEnd e);
    public abstract virtual void Visit(MappingStart e);
    public abstract virtual void Visit(MappingEnd e);
    public abstract virtual void Visit(Comment e);
}
public class YamlDotNet.Core.Events.MappingEnd : ParsingEvent {
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public MappingEnd(Mark start, Mark end);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
public class YamlDotNet.Core.Events.MappingStart : NodeEvent {
    private bool isImplicit;
    private MappingStyle style;
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public bool IsImplicit { get; }
    public bool IsCanonical { get; }
    public MappingStyle Style { get; }
    public MappingStart(string anchor, string tag, bool isImplicit, MappingStyle style, Mark start, Mark end);
    public MappingStart(string anchor, string tag, bool isImplicit, MappingStyle style);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public bool get_IsImplicit();
    public virtual bool get_IsCanonical();
    public MappingStyle get_Style();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
public enum YamlDotNet.Core.Events.MappingStyle : Enum {
    public int value__;
    public static MappingStyle Any;
    public static MappingStyle Block;
    public static MappingStyle Flow;
}
public abstract class YamlDotNet.Core.Events.NodeEvent : ParsingEvent {
    internal static Regex anchorValidator;
    private string anchor;
    private string tag;
    public string Anchor { get; }
    public string Tag { get; }
    public bool IsCanonical { get; }
    protected NodeEvent(string anchor, string tag, Mark start, Mark end);
    protected NodeEvent(string anchor, string tag);
    private static NodeEvent();
    public string get_Anchor();
    public string get_Tag();
    public abstract virtual bool get_IsCanonical();
}
public abstract class YamlDotNet.Core.Events.ParsingEvent : object {
    private Mark start;
    private Mark end;
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public Mark Start { get; }
    public Mark End { get; }
    internal ParsingEvent(Mark start, Mark end);
    public virtual int get_NestingIncrease();
    internal abstract virtual EventType get_Type();
    public Mark get_Start();
    public Mark get_End();
    public abstract virtual void Accept(IParsingEventVisitor visitor);
}
public class YamlDotNet.Core.Events.Scalar : NodeEvent {
    private string value;
    private ScalarStyle style;
    private bool isPlainImplicit;
    private bool isQuotedImplicit;
    internal EventType Type { get; }
    public string Value { get; }
    public ScalarStyle Style { get; }
    public bool IsPlainImplicit { get; }
    public bool IsQuotedImplicit { get; }
    public bool IsCanonical { get; }
    public Scalar(string anchor, string tag, string value, ScalarStyle style, bool isPlainImplicit, bool isQuotedImplicit, Mark start, Mark end);
    public Scalar(string anchor, string tag, string value, ScalarStyle style, bool isPlainImplicit, bool isQuotedImplicit);
    public Scalar(string value);
    public Scalar(string tag, string value);
    public Scalar(string anchor, string tag, string value);
    internal virtual EventType get_Type();
    public string get_Value();
    public ScalarStyle get_Style();
    public bool get_IsPlainImplicit();
    public bool get_IsQuotedImplicit();
    public virtual bool get_IsCanonical();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
public class YamlDotNet.Core.Events.SequenceEnd : ParsingEvent {
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public SequenceEnd(Mark start, Mark end);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
public class YamlDotNet.Core.Events.SequenceStart : NodeEvent {
    private bool isImplicit;
    private SequenceStyle style;
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public bool IsImplicit { get; }
    public bool IsCanonical { get; }
    public SequenceStyle Style { get; }
    public SequenceStart(string anchor, string tag, bool isImplicit, SequenceStyle style, Mark start, Mark end);
    public SequenceStart(string anchor, string tag, bool isImplicit, SequenceStyle style);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public bool get_IsImplicit();
    public virtual bool get_IsCanonical();
    public SequenceStyle get_Style();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
public enum YamlDotNet.Core.Events.SequenceStyle : Enum {
    public int value__;
    public static SequenceStyle Any;
    public static SequenceStyle Block;
    public static SequenceStyle Flow;
}
public class YamlDotNet.Core.Events.StreamEnd : ParsingEvent {
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public StreamEnd(Mark start, Mark end);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
public class YamlDotNet.Core.Events.StreamStart : ParsingEvent {
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public StreamStart(Mark start, Mark end);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
[DefaultMemberAttribute("Item")]
public class YamlDotNet.Core.FakeList`1 : object {
    private IEnumerator`1<T> collection;
    private int currentIndex;
    public T Item { get; }
    public FakeList`1(IEnumerator`1<T> collection);
    public FakeList`1(IEnumerable`1<T> collection);
    public T get_Item(int index);
}
public class YamlDotNet.Core.ForwardAnchorNotSupportedException : YamlException {
    public ForwardAnchorNotSupportedException(string message);
    public ForwardAnchorNotSupportedException(Mark start, Mark end, string message);
    public ForwardAnchorNotSupportedException(string message, Exception inner);
}
internal static class YamlDotNet.Core.HashCode : object {
    public static int CombineHashCodes(int h1, int h2);
}
public interface YamlDotNet.Core.IEmitter {
    public abstract virtual void Emit(ParsingEvent event);
}
internal interface YamlDotNet.Core.ILookAheadBuffer {
    public bool EndOfInput { get; }
    public abstract virtual bool get_EndOfInput();
    public abstract virtual char Peek(int offset);
    public abstract virtual void Skip(int length);
}
public class YamlDotNet.Core.InsertionQueue`1 : object {
    private IList`1<T> items;
    public int Count { get; }
    public int get_Count();
    public void Enqueue(T item);
    public T Dequeue();
    public void Insert(int index, T item);
}
public interface YamlDotNet.Core.IParser {
    public ParsingEvent Current { get; }
    public abstract virtual ParsingEvent get_Current();
    public abstract virtual bool MoveNext();
}
public interface YamlDotNet.Core.IScanner {
    public Mark CurrentPosition { get; }
    public Token Current { get; }
    public abstract virtual Mark get_CurrentPosition();
    public abstract virtual Token get_Current();
    public abstract virtual bool MoveNext();
    public abstract virtual bool MoveNextWithoutConsuming();
    public abstract virtual void ConsumeCurrent();
}
public class YamlDotNet.Core.LookAheadBuffer : object {
    private TextReader input;
    private Char[] buffer;
    private int firstIndex;
    private int count;
    private bool endOfInput;
    public bool EndOfInput { get; }
    public LookAheadBuffer(TextReader input, int capacity);
    public sealed virtual bool get_EndOfInput();
    private int GetIndexForOffset(int offset);
    public sealed virtual char Peek(int offset);
    public void Cache(int length);
    public sealed virtual void Skip(int length);
}
public class YamlDotNet.Core.Mark : object {
    public static Mark Empty;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <Column>k__BackingField;
    public int Index { get; private set; }
    public int Line { get; private set; }
    public int Column { get; private set; }
    public Mark(int index, int line, int column);
    private static Mark();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(int value);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
private void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
private void set_Column(int value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Mark other);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Mark other);
}
public class YamlDotNet.Core.MaximumRecursionLevelReachedException : YamlException {
    public MaximumRecursionLevelReachedException(string message);
    public MaximumRecursionLevelReachedException(Mark start, Mark end, string message);
    public MaximumRecursionLevelReachedException(string message, Exception inner);
}
public class YamlDotNet.Core.MergingParser : object {
    private ParsingEventCollection _events;
    private IParser _innerParser;
    private IEnumerator`1<LinkedListNode`1<ParsingEvent>> _iterator;
    private bool _merged;
    public ParsingEvent Current { get; }
    public MergingParser(IParser innerParser);
    public sealed virtual ParsingEvent get_Current();
    public sealed virtual bool MoveNext();
    private void Merge();
    private bool HandleMerge(LinkedListNode`1<ParsingEvent> node);
    private bool IsMergeToken(LinkedListNode`1<ParsingEvent> node);
    private bool HandleAnchorAlias(LinkedListNode`1<ParsingEvent> node);
    private bool HandleSequence(LinkedListNode`1<ParsingEvent> node);
    private IEnumerable`1<ParsingEvent> GetMappingEvents(string anchor);
}
public class YamlDotNet.Core.Parser : object {
    private Stack`1<ParserState> states;
    private TagDirectiveCollection tagDirectives;
    private ParserState state;
    private IScanner scanner;
    private ParsingEvent currentEvent;
    private Token currentToken;
    private EventQueue pendingEvents;
    public ParsingEvent Current { get; }
    public Parser(TextReader input);
    public Parser(IScanner scanner);
    private Token GetCurrentToken();
    public sealed virtual ParsingEvent get_Current();
    public sealed virtual bool MoveNext();
    private ParsingEvent StateMachine();
    private void Skip();
    private ParsingEvent ParseStreamStart();
    private ParsingEvent ParseDocumentStart(bool isImplicit);
    private VersionDirective ProcessDirectives(TagDirectiveCollection tags);
    private static void AddTagDirectives(TagDirectiveCollection directives, IEnumerable`1<TagDirective> source);
    private ParsingEvent ParseDocumentContent();
    private static ParsingEvent ProcessEmptyScalar(Mark position);
    private ParsingEvent ParseNode(bool isBlock, bool isIndentlessSequence);
    private ParsingEvent ParseDocumentEnd();
    private ParsingEvent ParseBlockSequenceEntry(bool isFirst);
    private ParsingEvent ParseIndentlessSequenceEntry();
    private ParsingEvent ParseBlockMappingKey(bool isFirst);
    private ParsingEvent ParseBlockMappingValue();
    private ParsingEvent ParseFlowSequenceEntry(bool isFirst);
    private ParsingEvent ParseFlowSequenceEntryMappingKey();
    private ParsingEvent ParseFlowSequenceEntryMappingValue();
    private ParsingEvent ParseFlowSequenceEntryMappingEnd();
    private ParsingEvent ParseFlowMappingKey(bool isFirst);
    private ParsingEvent ParseFlowMappingValue(bool isEmpty);
}
[ExtensionAttribute]
public static class YamlDotNet.Core.ParserExtensions : object {
    [ExtensionAttribute]
public static T Expect(IParser parser);
    [ExtensionAttribute]
public static bool Accept(IParser parser);
    [ExtensionAttribute]
public static T Allow(IParser parser);
    [ExtensionAttribute]
public static T Peek(IParser parser);
    [ExtensionAttribute]
public static void SkipThisAndNestedEvents(IParser parser);
}
internal enum YamlDotNet.Core.ParserState : Enum {
    public int value__;
    public static ParserState StreamStart;
    public static ParserState StreamEnd;
    public static ParserState ImplicitDocumentStart;
    public static ParserState DocumentStart;
    public static ParserState DocumentContent;
    public static ParserState DocumentEnd;
    public static ParserState BlockNode;
    public static ParserState BlockNodeOrIndentlessSequence;
    public static ParserState FlowNode;
    public static ParserState BlockSequenceFirstEntry;
    public static ParserState BlockSequenceEntry;
    public static ParserState IndentlessSequenceEntry;
    public static ParserState BlockMappingFirstKey;
    public static ParserState BlockMappingKey;
    public static ParserState BlockMappingValue;
    public static ParserState FlowSequenceFirstEntry;
    public static ParserState FlowSequenceEntry;
    public static ParserState FlowSequenceEntryMappingKey;
    public static ParserState FlowSequenceEntryMappingValue;
    public static ParserState FlowSequenceEntryMappingEnd;
    public static ParserState FlowMappingFirstKey;
    public static ParserState FlowMappingKey;
    public static ParserState FlowMappingValue;
    public static ParserState FlowMappingEmptyValue;
}
internal class YamlDotNet.Core.RecursionLevel : object {
    private int current;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <Maximum>k__BackingField;
    public int Maximum { get; private set; }
    public RecursionLevel(int maximum);
    [CompilerGeneratedAttribute]
public int get_Maximum();
    [CompilerGeneratedAttribute]
private void set_Maximum(int value);
    public void Increment();
    public bool TryIncrement();
    public void Decrement();
}
public enum YamlDotNet.Core.ScalarStyle : Enum {
    public int value__;
    public static ScalarStyle Any;
    public static ScalarStyle Plain;
    public static ScalarStyle SingleQuoted;
    public static ScalarStyle DoubleQuoted;
    public static ScalarStyle Literal;
    public static ScalarStyle Folded;
}
public class YamlDotNet.Core.Scanner : object {
    private static int MaxVersionNumberLength;
    private static int MaxBufferLength;
    private static IDictionary`2<char, char> simpleEscapeCodes;
    private Stack`1<int> indents;
    private InsertionQueue`1<Token> tokens;
    private Stack`1<SimpleKey> simpleKeys;
    private CharacterAnalyzer`1<LookAheadBuffer> analyzer;
    private Cursor cursor;
    private bool streamStartProduced;
    private bool streamEndProduced;
    private int indent;
    private bool simpleKeyAllowed;
    private int flowLevel;
    private int tokensParsed;
    private bool tokenAvailable;
    private Token previous;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <SkipComments>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Token <Current>k__BackingField;
    public bool SkipComments { get; private set; }
    public Token Current { get; private set; }
    public Mark CurrentPosition { get; }
    public Scanner(TextReader input, bool skipComments);
    private static Scanner();
    [CompilerGeneratedAttribute]
public bool get_SkipComments();
    [CompilerGeneratedAttribute]
private void set_SkipComments(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Token get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(Token value);
    public sealed virtual Mark get_CurrentPosition();
    public sealed virtual bool MoveNext();
    public sealed virtual bool MoveNextWithoutConsuming();
    public sealed virtual void ConsumeCurrent();
    private char ReadCurrentCharacter();
    private char ReadLine();
    private void FetchMoreTokens();
    private static bool StartsWith(StringBuilder what, char start);
    private void StaleSimpleKeys();
    private void FetchNextToken();
    private bool CheckWhiteSpace();
    private bool IsDocumentIndicator();
    private void Skip();
    private void SkipLine();
    private void ScanToNextToken();
    private void ProcessComment();
    private void FetchStreamStart();
    private void UnrollIndent(int column);
    private void FetchStreamEnd();
    private void FetchDirective();
    private Token ScanDirective();
    private void FetchDocumentIndicator(bool isStartToken);
    private void FetchFlowCollectionStart(bool isSequenceToken);
    private void IncreaseFlowLevel();
    private void FetchFlowCollectionEnd(bool isSequenceToken);
    private void DecreaseFlowLevel();
    private void FetchFlowEntry();
    private void FetchBlockEntry();
    private void FetchKey();
    private void FetchValue();
    private void RollIndent(int column, int number, bool isSequence, Mark position);
    private void FetchAnchor(bool isAlias);
    private Token ScanAnchor(bool isAlias);
    private void FetchTag();
    private Token ScanTag();
    private void FetchBlockScalar(bool isLiteral);
    private Token ScanBlockScalar(bool isLiteral);
    private int ScanBlockScalarBreaks(int currentIndent, StringBuilder breaks, Mark start, Mark& end);
    private void FetchFlowScalar(bool isSingleQuoted);
    private Token ScanFlowScalar(bool isSingleQuoted);
    private void FetchPlainScalar();
    private Token ScanPlainScalar();
    private void RemoveSimpleKey();
    private string ScanDirectiveName(Mark start);
    private void SkipWhitespaces();
    private Token ScanVersionDirectiveValue(Mark start);
    private Token ScanTagDirectiveValue(Mark start);
    private string ScanTagUri(string head, Mark start);
    private string ScanUriEscapes(Mark start);
    private string ScanTagHandle(bool isDirective, Mark start);
    private int ScanVersionDirectiveNumber(Mark start);
    private void SaveSimpleKey();
}
public class YamlDotNet.Core.SemanticErrorException : YamlException {
    public SemanticErrorException(string message);
    public SemanticErrorException(Mark start, Mark end, string message);
    public SemanticErrorException(string message, Exception inner);
}
internal class YamlDotNet.Core.SimpleKey : object {
    private Cursor cursor;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <IsPossible>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <IsRequired>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <TokenNumber>k__BackingField;
    public bool IsPossible { get; public set; }
    public bool IsRequired { get; private set; }
    public int TokenNumber { get; private set; }
    public int Index { get; }
    public int Line { get; }
    public int LineOffset { get; }
    public Mark Mark { get; }
    public SimpleKey(bool isPossible, bool isRequired, int tokenNumber, Cursor cursor);
    [CompilerGeneratedAttribute]
public bool get_IsPossible();
    [CompilerGeneratedAttribute]
public void set_IsPossible(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
private void set_IsRequired(bool value);
    [CompilerGeneratedAttribute]
public int get_TokenNumber();
    [CompilerGeneratedAttribute]
private void set_TokenNumber(int value);
    public int get_Index();
    public int get_Line();
    public int get_LineOffset();
    public Mark get_Mark();
}
internal class YamlDotNet.Core.StringLookAheadBuffer : object {
    private string value;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <Position>k__BackingField;
    public int Position { get; private set; }
    public int Length { get; }
    public bool EndOfInput { get; }
    public StringLookAheadBuffer(string value);
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
    public int get_Length();
    public sealed virtual bool get_EndOfInput();
    public sealed virtual char Peek(int offset);
    private bool IsOutside(int index);
    public sealed virtual void Skip(int length);
}
public class YamlDotNet.Core.SyntaxErrorException : YamlException {
    public SyntaxErrorException(string message);
    public SyntaxErrorException(Mark start, Mark end, string message);
    public SyntaxErrorException(string message, Exception inner);
}
public class YamlDotNet.Core.TagDirectiveCollection : KeyedCollection`2<string, TagDirective> {
    public TagDirectiveCollection(IEnumerable`1<TagDirective> tagDirectives);
    protected virtual string GetKeyForItem(TagDirective item);
    public bool Contains(TagDirective directive);
}
public class YamlDotNet.Core.Tokens.Anchor : Token {
    private string value;
    public string Value { get; }
    public Anchor(string value);
    public Anchor(string value, Mark start, Mark end);
    public string get_Value();
}
public class YamlDotNet.Core.Tokens.AnchorAlias : Token {
    private string value;
    public string Value { get; }
    public AnchorAlias(string value);
    public AnchorAlias(string value, Mark start, Mark end);
    public string get_Value();
}
public class YamlDotNet.Core.Tokens.BlockEnd : Token {
    public BlockEnd(Mark start, Mark end);
}
public class YamlDotNet.Core.Tokens.BlockEntry : Token {
    public BlockEntry(Mark start, Mark end);
}
public class YamlDotNet.Core.Tokens.BlockMappingStart : Token {
    public BlockMappingStart(Mark start, Mark end);
}
public class YamlDotNet.Core.Tokens.BlockSequenceStart : Token {
    public BlockSequenceStart(Mark start, Mark end);
}
public class YamlDotNet.Core.Tokens.Comment : Token {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <IsInline>k__BackingField;
    public string Value { get; private set; }
    public bool IsInline { get; private set; }
    public Comment(string value, bool isInline);
    public Comment(string value, bool isInline, Mark start, Mark end);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    [CompilerGeneratedAttribute]
public bool get_IsInline();
    [CompilerGeneratedAttribute]
private void set_IsInline(bool value);
}
public class YamlDotNet.Core.Tokens.DocumentEnd : Token {
    public DocumentEnd(Mark start, Mark end);
}
public class YamlDotNet.Core.Tokens.DocumentStart : Token {
    public DocumentStart(Mark start, Mark end);
}
public class YamlDotNet.Core.Tokens.FlowEntry : Token {
    public FlowEntry(Mark start, Mark end);
}
public class YamlDotNet.Core.Tokens.FlowMappingEnd : Token {
    public FlowMappingEnd(Mark start, Mark end);
}
public class YamlDotNet.Core.Tokens.FlowMappingStart : Token {
    public FlowMappingStart(Mark start, Mark end);
}
public class YamlDotNet.Core.Tokens.FlowSequenceEnd : Token {
    public FlowSequenceEnd(Mark start, Mark end);
}
public class YamlDotNet.Core.Tokens.FlowSequenceStart : Token {
    public FlowSequenceStart(Mark start, Mark end);
}
public class YamlDotNet.Core.Tokens.Key : Token {
    public Key(Mark start, Mark end);
}
public class YamlDotNet.Core.Tokens.Scalar : Token {
    private string value;
    private ScalarStyle style;
    public string Value { get; }
    public ScalarStyle Style { get; }
    public Scalar(string value);
    public Scalar(string value, ScalarStyle style);
    public Scalar(string value, ScalarStyle style, Mark start, Mark end);
    public string get_Value();
    public ScalarStyle get_Style();
}
public class YamlDotNet.Core.Tokens.StreamEnd : Token {
    public StreamEnd(Mark start, Mark end);
}
public class YamlDotNet.Core.Tokens.StreamStart : Token {
    public StreamStart(Mark start, Mark end);
}
public class YamlDotNet.Core.Tokens.Tag : Token {
    private string handle;
    private string suffix;
    public string Handle { get; }
    public string Suffix { get; }
    public Tag(string handle, string suffix);
    public Tag(string handle, string suffix, Mark start, Mark end);
    public string get_Handle();
    public string get_Suffix();
}
public class YamlDotNet.Core.Tokens.TagDirective : Token {
    private string handle;
    private string prefix;
    private static Regex tagHandleValidator;
    public string Handle { get; }
    public string Prefix { get; }
    public TagDirective(string handle, string prefix);
    public TagDirective(string handle, string prefix, Mark start, Mark end);
    private static TagDirective();
    public string get_Handle();
    public string get_Prefix();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public abstract class YamlDotNet.Core.Tokens.Token : object {
    private Mark start;
    private Mark end;
    public Mark Start { get; }
    public Mark End { get; }
    protected Token(Mark start, Mark end);
    public Mark get_Start();
    public Mark get_End();
}
public class YamlDotNet.Core.Tokens.Value : Token {
    public Value(Mark start, Mark end);
}
public class YamlDotNet.Core.Tokens.VersionDirective : Token {
    private Version version;
    public Version Version { get; }
    public VersionDirective(Version version);
    public VersionDirective(Version version, Mark start, Mark end);
    public Version get_Version();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class YamlDotNet.Core.Version : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <Major>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <Minor>k__BackingField;
    public int Major { get; private set; }
    public int Minor { get; private set; }
    public Version(int major, int minor);
    [CompilerGeneratedAttribute]
public int get_Major();
    [CompilerGeneratedAttribute]
private void set_Major(int value);
    [CompilerGeneratedAttribute]
public int get_Minor();
    [CompilerGeneratedAttribute]
private void set_Minor(int value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class YamlDotNet.Core.YamlException : Exception {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Mark <Start>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Mark <End>k__BackingField;
    public Mark Start { get; private set; }
    public Mark End { get; private set; }
    public YamlException(string message);
    public YamlException(Mark start, Mark end, string message);
    public YamlException(Mark start, Mark end, string message, Exception innerException);
    public YamlException(string message, Exception inner);
    [CompilerGeneratedAttribute]
public Mark get_Start();
    [CompilerGeneratedAttribute]
private void set_Start(Mark value);
    [CompilerGeneratedAttribute]
public Mark get_End();
    [CompilerGeneratedAttribute]
private void set_End(Mark value);
}
internal class YamlDotNet.CultureInfoAdapter : CultureInfo {
    private IFormatProvider _provider;
    public CultureInfoAdapter(CultureInfo baseCulture, IFormatProvider provider);
    public virtual object GetFormat(Type formatType);
}
[ExtensionAttribute]
public static class YamlDotNet.Helpers.ExpressionExtensions : object {
    [ExtensionAttribute]
public static PropertyInfo AsProperty(LambdaExpression propertyAccessor);
    private static TMemberInfo TryGetMemberExpression(LambdaExpression lambdaExpression);
}
[DefaultMemberAttribute("Item")]
internal class YamlDotNet.Helpers.GenericCollectionToNonGenericAdapter : object {
    private object genericCollection;
    private MethodInfo addMethod;
    private MethodInfo indexerSetter;
    private MethodInfo countGetter;
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public GenericCollectionToNonGenericAdapter(object genericCollection, Type genericCollectionType, Type genericListType);
    public sealed virtual int Add(object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object value);
    public sealed virtual int IndexOf(object value);
    public sealed virtual void Insert(int index, object value);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Remove(object value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual IEnumerator GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class YamlDotNet.Helpers.GenericDictionaryToNonGenericAdapter : object {
    private object genericDictionary;
    private Type genericDictionaryType;
    private MethodInfo indexerSetter;
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public GenericDictionaryToNonGenericAdapter(object genericDictionary, Type genericDictionaryType);
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection get_Keys();
    public sealed virtual void Remove(object key);
    public sealed virtual ICollection get_Values();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
internal static class YamlDotNet.PropertyInfoExtensions : object {
    [ExtensionAttribute]
public static object ReadValue(PropertyInfo property, object target);
}
[ExtensionAttribute]
internal static class YamlDotNet.ReflectionExtensions : object {
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool HasDefaultConstructor(Type type);
    [ExtensionAttribute]
public static bool IsAssignableFrom(Type type, Type source);
    [ExtensionAttribute]
public static bool IsAssignableFrom(Type type, TypeInfo source);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
public static bool IsDbNull(object value);
    [ExtensionAttribute]
public static Type[] GetGenericArguments(Type type);
    [ExtensionAttribute]
public static PropertyInfo GetPublicProperty(Type type, string name);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetPublicProperties(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetPublicStaticMethods(Type type);
    [ExtensionAttribute]
public static MethodInfo GetPublicStaticMethod(Type type, string name, Type[] parameterTypes);
    [ExtensionAttribute]
public static MethodInfo GetPublicInstanceMethod(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo GetGetMethod(PropertyInfo property);
    [ExtensionAttribute]
public static MethodInfo GetSetMethod(PropertyInfo property);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetInterfaces(Type type);
    [ExtensionAttribute]
public static Exception Unwrap(TargetInvocationException ex);
    [ExtensionAttribute]
public static bool IsInstanceOf(Type type, object o);
}
internal class YamlDotNet.RepresentationModel.DocumentLoadingState : object {
    private IDictionary`2<string, YamlNode> anchors;
    private IList`1<YamlNode> nodesWithUnresolvedAliases;
    public void AddAnchor(YamlNode node);
    public YamlNode GetNode(string anchor, bool throwException, Mark start, Mark end);
    public void AddNodeWithUnresolvedAliases(YamlNode node);
    public void ResolveAliases();
}
internal class YamlDotNet.RepresentationModel.EmitterState : object {
    private HashSet`1<string> emittedAnchors;
    public HashSet`1<string> EmittedAnchors { get; }
    public HashSet`1<string> get_EmittedAnchors();
}
public interface YamlDotNet.RepresentationModel.IYamlVisitor {
    public abstract virtual void Visit(YamlStream stream);
    public abstract virtual void Visit(YamlDocument document);
    public abstract virtual void Visit(YamlScalarNode scalar);
    public abstract virtual void Visit(YamlSequenceNode sequence);
    public abstract virtual void Visit(YamlMappingNode mapping);
}
internal class YamlDotNet.RepresentationModel.YamlAliasNode : YamlNode {
    public YamlNodeType NodeType { get; }
    internal YamlAliasNode(string anchor);
    internal virtual void ResolveAliases(DocumentLoadingState state);
    internal virtual void Emit(IEmitter emitter, EmitterState state);
    public virtual void Accept(IYamlVisitor visitor);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual string ToString(RecursionLevel level);
    [IteratorStateMachineAttribute("YamlDotNet.RepresentationModel.YamlAliasNode/<SafeAllNodes>d__7")]
internal virtual IEnumerable`1<YamlNode> SafeAllNodes(RecursionLevel level);
    public virtual YamlNodeType get_NodeType();
}
public class YamlDotNet.RepresentationModel.YamlDocument : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private YamlNode <RootNode>k__BackingField;
    public YamlNode RootNode { get; private set; }
    public IEnumerable`1<YamlNode> AllNodes { get; }
    public YamlDocument(YamlNode rootNode);
    public YamlDocument(string rootNode);
    internal YamlDocument(IParser parser);
    [CompilerGeneratedAttribute]
public YamlNode get_RootNode();
    [CompilerGeneratedAttribute]
private void set_RootNode(YamlNode value);
    private void AssignAnchors();
    internal void Save(IEmitter emitter, bool assignAnchors);
    public void Accept(IYamlVisitor visitor);
    public IEnumerable`1<YamlNode> get_AllNodes();
}
public class YamlDotNet.RepresentationModel.YamlMappingNode : YamlNode {
    private IDictionary`2<YamlNode, YamlNode> children;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MappingStyle <Style>k__BackingField;
    public IDictionary`2<YamlNode, YamlNode> Children { get; }
    public MappingStyle Style { get; public set; }
    public YamlNodeType NodeType { get; }
    internal YamlMappingNode(IParser parser, DocumentLoadingState state);
    public YamlMappingNode(KeyValuePair`2[] children);
    public YamlMappingNode(IEnumerable`1<KeyValuePair`2<YamlNode, YamlNode>> children);
    public YamlMappingNode(YamlNode[] children);
    public YamlMappingNode(IEnumerable`1<YamlNode> children);
    public IDictionary`2<YamlNode, YamlNode> get_Children();
    [CompilerGeneratedAttribute]
public MappingStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(MappingStyle value);
    private void Load(IParser parser, DocumentLoadingState state);
    public void Add(YamlNode key, YamlNode value);
    public void Add(string key, YamlNode value);
    public void Add(YamlNode key, string value);
    public void Add(string key, string value);
    internal virtual void ResolveAliases(DocumentLoadingState state);
    internal virtual void Emit(IEmitter emitter, EmitterState state);
    public virtual void Accept(IYamlVisitor visitor);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [IteratorStateMachineAttribute("YamlDotNet.RepresentationModel.YamlMappingNode/<SafeAllNodes>d__23")]
internal virtual IEnumerable`1<YamlNode> SafeAllNodes(RecursionLevel level);
    public virtual YamlNodeType get_NodeType();
    internal virtual string ToString(RecursionLevel level);
    public sealed virtual IEnumerator`1<KeyValuePair`2<YamlNode, YamlNode>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void YamlDotNet.Serialization.IYamlConvertible.Read(IParser parser, Type expectedType, ObjectDeserializer nestedObjectDeserializer);
    private sealed virtual override void YamlDotNet.Serialization.IYamlConvertible.Write(IEmitter emitter, ObjectSerializer nestedObjectSerializer);
    public static YamlMappingNode FromObject(object mapping);
}
[DefaultMemberAttribute("Item")]
public abstract class YamlDotNet.RepresentationModel.YamlNode : object {
    private static int MaximumRecursionLevel;
    internal static string MaximumRecursionLevelReachedToStringValue;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Anchor>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Mark <Start>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Mark <End>k__BackingField;
    public string Anchor { get; public set; }
    public string Tag { get; public set; }
    public Mark Start { get; private set; }
    public Mark End { get; private set; }
    public IEnumerable`1<YamlNode> AllNodes { get; }
    public YamlNodeType NodeType { get; }
    public YamlNode Item { get; }
    public YamlNode Item { get; }
    [CompilerGeneratedAttribute]
public string get_Anchor();
    [CompilerGeneratedAttribute]
public void set_Anchor(string value);
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(string value);
    [CompilerGeneratedAttribute]
public Mark get_Start();
    [CompilerGeneratedAttribute]
private void set_Start(Mark value);
    [CompilerGeneratedAttribute]
public Mark get_End();
    [CompilerGeneratedAttribute]
private void set_End(Mark value);
    internal void Load(NodeEvent yamlEvent, DocumentLoadingState state);
    internal static YamlNode ParseNode(IParser parser, DocumentLoadingState state);
    internal abstract virtual void ResolveAliases(DocumentLoadingState state);
    internal void Save(IEmitter emitter, EmitterState state);
    internal abstract virtual void Emit(IEmitter emitter, EmitterState state);
    public abstract virtual void Accept(IYamlVisitor visitor);
    protected bool Equals(YamlNode other);
    protected static bool SafeEquals(object first, object second);
    public virtual int GetHashCode();
    protected static int GetHashCode(object value);
    protected static int CombineHashCodes(int h1, int h2);
    public virtual string ToString();
    internal abstract virtual string ToString(RecursionLevel level);
    public IEnumerable`1<YamlNode> get_AllNodes();
    internal abstract virtual IEnumerable`1<YamlNode> SafeAllNodes(RecursionLevel level);
    public abstract virtual YamlNodeType get_NodeType();
    public static YamlNode op_Implicit(string value);
    public static YamlNode op_Implicit(String[] sequence);
    public static string op_Explicit(YamlNode scalar);
    public YamlNode get_Item(int index);
    public YamlNode get_Item(YamlNode key);
}
public class YamlDotNet.RepresentationModel.YamlNodeIdentityEqualityComparer : object {
    public sealed virtual bool Equals(YamlNode x, YamlNode y);
    public sealed virtual int GetHashCode(YamlNode obj);
}
public enum YamlDotNet.RepresentationModel.YamlNodeType : Enum {
    public int value__;
    public static YamlNodeType Alias;
    public static YamlNodeType Mapping;
    public static YamlNodeType Scalar;
    public static YamlNodeType Sequence;
}
[DebuggerDisplayAttribute("{Value}")]
public class YamlDotNet.RepresentationModel.YamlScalarNode : YamlNode {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ScalarStyle <Style>k__BackingField;
    public string Value { get; public set; }
    public ScalarStyle Style { get; public set; }
    public YamlNodeType NodeType { get; }
    internal YamlScalarNode(IParser parser, DocumentLoadingState state);
    public YamlScalarNode(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public ScalarStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(ScalarStyle value);
    private void Load(IParser parser, DocumentLoadingState state);
    internal virtual void ResolveAliases(DocumentLoadingState state);
    internal virtual void Emit(IEmitter emitter, EmitterState state);
    public virtual void Accept(IYamlVisitor visitor);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static string op_Explicit(YamlScalarNode value);
    internal virtual string ToString(RecursionLevel level);
    [IteratorStateMachineAttribute("YamlDotNet.RepresentationModel.YamlScalarNode/<SafeAllNodes>d__19")]
internal virtual IEnumerable`1<YamlNode> SafeAllNodes(RecursionLevel level);
    public virtual YamlNodeType get_NodeType();
    private sealed virtual override void YamlDotNet.Serialization.IYamlConvertible.Read(IParser parser, Type expectedType, ObjectDeserializer nestedObjectDeserializer);
    private sealed virtual override void YamlDotNet.Serialization.IYamlConvertible.Write(IEmitter emitter, ObjectSerializer nestedObjectSerializer);
}
[DebuggerDisplayAttribute("Count = {children.Count}")]
public class YamlDotNet.RepresentationModel.YamlSequenceNode : YamlNode {
    private IList`1<YamlNode> children;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private SequenceStyle <Style>k__BackingField;
    public IList`1<YamlNode> Children { get; }
    public SequenceStyle Style { get; public set; }
    public YamlNodeType NodeType { get; }
    internal YamlSequenceNode(IParser parser, DocumentLoadingState state);
    public YamlSequenceNode(YamlNode[] children);
    public YamlSequenceNode(IEnumerable`1<YamlNode> children);
    public IList`1<YamlNode> get_Children();
    [CompilerGeneratedAttribute]
public SequenceStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(SequenceStyle value);
    private void Load(IParser parser, DocumentLoadingState state);
    public void Add(YamlNode child);
    public void Add(string child);
    internal virtual void ResolveAliases(DocumentLoadingState state);
    internal virtual void Emit(IEmitter emitter, EmitterState state);
    public virtual void Accept(IYamlVisitor visitor);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [IteratorStateMachineAttribute("YamlDotNet.RepresentationModel.YamlSequenceNode/<SafeAllNodes>d__19")]
internal virtual IEnumerable`1<YamlNode> SafeAllNodes(RecursionLevel level);
    public virtual YamlNodeType get_NodeType();
    internal virtual string ToString(RecursionLevel level);
    public sealed virtual IEnumerator`1<YamlNode> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void YamlDotNet.Serialization.IYamlConvertible.Read(IParser parser, Type expectedType, ObjectDeserializer nestedObjectDeserializer);
    private sealed virtual override void YamlDotNet.Serialization.IYamlConvertible.Write(IEmitter emitter, ObjectSerializer nestedObjectSerializer);
}
public class YamlDotNet.RepresentationModel.YamlStream : object {
    private IList`1<YamlDocument> documents;
    public IList`1<YamlDocument> Documents { get; }
    public YamlStream(YamlDocument[] documents);
    public YamlStream(IEnumerable`1<YamlDocument> documents);
    public IList`1<YamlDocument> get_Documents();
    public void Add(YamlDocument document);
    public void Load(TextReader input);
    public void Load(IParser parser);
    public void Save(TextWriter output);
    public void Save(TextWriter output, bool assignAnchors);
    public void Accept(IYamlVisitor visitor);
    public sealed virtual IEnumerator`1<YamlDocument> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ObsoleteAttribute("Use YamlVisitorBase")]
public abstract class YamlDotNet.RepresentationModel.YamlVisitor : object {
    protected virtual void Visit(YamlStream stream);
    protected virtual void Visited(YamlStream stream);
    protected virtual void Visit(YamlDocument document);
    protected virtual void Visited(YamlDocument document);
    protected virtual void Visit(YamlScalarNode scalar);
    protected virtual void Visited(YamlScalarNode scalar);
    protected virtual void Visit(YamlSequenceNode sequence);
    protected virtual void Visited(YamlSequenceNode sequence);
    protected virtual void Visit(YamlMappingNode mapping);
    protected virtual void Visited(YamlMappingNode mapping);
    protected virtual void VisitChildren(YamlStream stream);
    protected virtual void VisitChildren(YamlDocument document);
    protected virtual void VisitChildren(YamlSequenceNode sequence);
    protected virtual void VisitChildren(YamlMappingNode mapping);
    private sealed virtual override void YamlDotNet.RepresentationModel.IYamlVisitor.Visit(YamlStream stream);
    private sealed virtual override void YamlDotNet.RepresentationModel.IYamlVisitor.Visit(YamlDocument document);
    private sealed virtual override void YamlDotNet.RepresentationModel.IYamlVisitor.Visit(YamlScalarNode scalar);
    private sealed virtual override void YamlDotNet.RepresentationModel.IYamlVisitor.Visit(YamlSequenceNode sequence);
    private sealed virtual override void YamlDotNet.RepresentationModel.IYamlVisitor.Visit(YamlMappingNode mapping);
}
public abstract class YamlDotNet.RepresentationModel.YamlVisitorBase : object {
    public virtual void Visit(YamlStream stream);
    public virtual void Visit(YamlDocument document);
    public virtual void Visit(YamlScalarNode scalar);
    public virtual void Visit(YamlSequenceNode sequence);
    public virtual void Visit(YamlMappingNode mapping);
    protected virtual void VisitPair(YamlNode key, YamlNode value);
    protected virtual void VisitChildren(YamlStream stream);
    protected virtual void VisitChildren(YamlDocument document);
    protected virtual void VisitChildren(YamlSequenceNode sequence);
    protected virtual void VisitChildren(YamlMappingNode mapping);
}
public class YamlDotNet.Serialization.AliasEventInfo : EventInfo {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Alias>k__BackingField;
    public string Alias { get; public set; }
    public AliasEventInfo(IObjectDescriptor source);
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
public void set_Alias(string value);
}
public abstract class YamlDotNet.Serialization.BuilderSkeleton`1 : object {
    internal INamingConvention namingConvention;
    internal ITypeResolver typeResolver;
    internal YamlAttributeOverrides overrides;
    internal LazyComponentRegistrationList`2<Nothing, IYamlTypeConverter> typeConverterFactories;
    internal LazyComponentRegistrationList`2<ITypeInspector, ITypeInspector> typeInspectorFactories;
    protected TBuilder Self { get; }
    protected abstract virtual TBuilder get_Self();
    internal ITypeInspector BuildTypeInspector();
    public TBuilder WithNamingConvention(INamingConvention namingConvention);
    public TBuilder WithTypeResolver(ITypeResolver typeResolver);
    public TBuilder WithAttributeOverride(Expression`1<Func`2<TClass, object>> propertyAccessor, Attribute attribute);
    public TBuilder WithAttributeOverride(Type type, string member, Attribute attribute);
    public TBuilder WithTypeConverter(IYamlTypeConverter typeConverter);
    public TBuilder WithTypeConverter(IYamlTypeConverter typeConverter, Action`1<IRegistrationLocationSelectionSyntax`1<IYamlTypeConverter>> where);
    public TBuilder WithTypeConverter(WrapperFactory`2<IYamlTypeConverter, IYamlTypeConverter> typeConverterFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<IYamlTypeConverter>> where);
    public TBuilder WithoutTypeConverter();
    public TBuilder WithoutTypeConverter(Type converterType);
    public TBuilder WithTypeInspector(Func`2<ITypeInspector, TTypeInspector> typeInspectorFactory);
    public TBuilder WithTypeInspector(Func`2<ITypeInspector, TTypeInspector> typeInspectorFactory, Action`1<IRegistrationLocationSelectionSyntax`1<ITypeInspector>> where);
    public TBuilder WithTypeInspector(WrapperFactory`3<ITypeInspector, ITypeInspector, TTypeInspector> typeInspectorFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<ITypeInspector>> where);
    public TBuilder WithoutTypeInspector();
    public TBuilder WithoutTypeInspector(Type inspectorType);
    protected IEnumerable`1<IYamlTypeConverter> BuildTypeConverters();
}
public class YamlDotNet.Serialization.Converters.DateTimeConverter : object {
    private DateTimeKind kind;
    private IFormatProvider provider;
    private String[] formats;
    public DateTimeConverter(DateTimeKind kind, IFormatProvider provider, String[] formats);
    public sealed virtual bool Accepts(Type type);
    public sealed virtual object ReadYaml(IParser parser, Type type);
    public sealed virtual void WriteYaml(IEmitter emitter, object value, Type type);
    private static DateTime EnsureDateTimeKind(DateTime dt, DateTimeKind kind);
}
public class YamlDotNet.Serialization.Converters.GuidConverter : object {
    private bool jsonCompatible;
    public GuidConverter(bool jsonCompatible);
    public sealed virtual bool Accepts(Type type);
    public sealed virtual object ReadYaml(IParser parser, Type type);
    public sealed virtual void WriteYaml(IEmitter emitter, object value, Type type);
}
public class YamlDotNet.Serialization.Converters.SystemTypeConverter : object {
    public sealed virtual bool Accepts(Type type);
    public sealed virtual object ReadYaml(IParser parser, Type type);
    public sealed virtual void WriteYaml(IEmitter emitter, object value, Type type);
}
public class YamlDotNet.Serialization.Deserializer : object {
    private IValueDeserializer valueDeserializer;
    private Deserializer(IValueDeserializer valueDeserializer);
    public static Deserializer FromValueDeserializer(IValueDeserializer valueDeserializer);
    public sealed virtual T Deserialize(string input);
    public sealed virtual T Deserialize(TextReader input);
    public sealed virtual object Deserialize(TextReader input);
    public sealed virtual object Deserialize(string input, Type type);
    public sealed virtual object Deserialize(TextReader input, Type type);
    public sealed virtual T Deserialize(IParser parser);
    public sealed virtual object Deserialize(IParser parser);
    public sealed virtual object Deserialize(IParser parser, Type type);
}
public class YamlDotNet.Serialization.DeserializerBuilder : BuilderSkeleton`1<DeserializerBuilder> {
    private IObjectFactory objectFactory;
    private LazyComponentRegistrationList`2<Nothing, INodeDeserializer> nodeDeserializerFactories;
    private LazyComponentRegistrationList`2<Nothing, INodeTypeResolver> nodeTypeResolverFactories;
    private Dictionary`2<string, Type> tagMappings;
    private bool ignoreUnmatched;
    protected DeserializerBuilder Self { get; }
    protected virtual DeserializerBuilder get_Self();
    public DeserializerBuilder WithObjectFactory(IObjectFactory objectFactory);
    public DeserializerBuilder WithObjectFactory(Func`2<Type, object> objectFactory);
    public DeserializerBuilder WithNodeDeserializer(INodeDeserializer nodeDeserializer);
    public DeserializerBuilder WithNodeDeserializer(INodeDeserializer nodeDeserializer, Action`1<IRegistrationLocationSelectionSyntax`1<INodeDeserializer>> where);
    public DeserializerBuilder WithNodeDeserializer(WrapperFactory`2<INodeDeserializer, TNodeDeserializer> nodeDeserializerFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<INodeDeserializer>> where);
    public DeserializerBuilder WithoutNodeDeserializer();
    public DeserializerBuilder WithoutNodeDeserializer(Type nodeDeserializerType);
    public DeserializerBuilder WithNodeTypeResolver(INodeTypeResolver nodeTypeResolver);
    public DeserializerBuilder WithNodeTypeResolver(INodeTypeResolver nodeTypeResolver, Action`1<IRegistrationLocationSelectionSyntax`1<INodeTypeResolver>> where);
    public DeserializerBuilder WithNodeTypeResolver(WrapperFactory`2<INodeTypeResolver, TNodeTypeResolver> nodeTypeResolverFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<INodeTypeResolver>> where);
    public DeserializerBuilder WithoutNodeTypeResolver();
    public DeserializerBuilder WithoutNodeTypeResolver(Type nodeTypeResolverType);
    public DeserializerBuilder WithTagMapping(string tag, Type type);
    public DeserializerBuilder WithoutTagMapping(string tag);
    public DeserializerBuilder IgnoreUnmatchedProperties();
    public IDeserializer Build();
    public IValueDeserializer BuildValueDeserializer();
    [CompilerGeneratedAttribute]
private ITypeInspector <.ctor>b__5_1(ITypeInspector inner);
    [CompilerGeneratedAttribute]
private ITypeInspector <.ctor>b__5_3(ITypeInspector inner);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__5_5(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__5_6(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__5_7(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__5_11(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__5_12(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__5_14(Nothing _);
    [CompilerGeneratedAttribute]
private INodeTypeResolver <.ctor>b__5_17(Nothing _);
}
public class YamlDotNet.Serialization.EmissionPhaseObjectGraphVisitorArgs : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IObjectGraphVisitor`1<IEmitter> <InnerVisitor>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IEventEmitter <EventEmitter>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ObjectSerializer <NestedObjectSerializer>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IEnumerable`1<IYamlTypeConverter> <TypeConverters>k__BackingField;
    private IEnumerable`1<IObjectGraphVisitor`1<Nothing>> preProcessingPhaseVisitors;
    public IObjectGraphVisitor`1<IEmitter> InnerVisitor { get; private set; }
    public IEventEmitter EventEmitter { get; private set; }
    public ObjectSerializer NestedObjectSerializer { get; private set; }
    public IEnumerable`1<IYamlTypeConverter> TypeConverters { get; private set; }
    public EmissionPhaseObjectGraphVisitorArgs(IObjectGraphVisitor`1<IEmitter> innerVisitor, IEventEmitter eventEmitter, IEnumerable`1<IObjectGraphVisitor`1<Nothing>> preProcessingPhaseVisitors, IEnumerable`1<IYamlTypeConverter> typeConverters, ObjectSerializer nestedObjectSerializer);
    [CompilerGeneratedAttribute]
public IObjectGraphVisitor`1<IEmitter> get_InnerVisitor();
    [CompilerGeneratedAttribute]
private void set_InnerVisitor(IObjectGraphVisitor`1<IEmitter> value);
    [CompilerGeneratedAttribute]
public IEventEmitter get_EventEmitter();
    [CompilerGeneratedAttribute]
private void set_EventEmitter(IEventEmitter value);
    [CompilerGeneratedAttribute]
public ObjectSerializer get_NestedObjectSerializer();
    [CompilerGeneratedAttribute]
private void set_NestedObjectSerializer(ObjectSerializer value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IYamlTypeConverter> get_TypeConverters();
    [CompilerGeneratedAttribute]
private void set_TypeConverters(IEnumerable`1<IYamlTypeConverter> value);
    public T GetPreProcessingPhaseObjectGraphVisitor();
}
public abstract class YamlDotNet.Serialization.EventEmitters.ChainedEventEmitter : object {
    protected IEventEmitter nextEmitter;
    protected ChainedEventEmitter(IEventEmitter nextEmitter);
    public virtual void Emit(AliasEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(ScalarEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(MappingStartEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(MappingEndEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(SequenceStartEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(SequenceEndEventInfo eventInfo, IEmitter emitter);
}
public class YamlDotNet.Serialization.EventEmitters.JsonEventEmitter : ChainedEventEmitter {
    public JsonEventEmitter(IEventEmitter nextEmitter);
    public virtual void Emit(AliasEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(ScalarEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(MappingStartEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(SequenceStartEventInfo eventInfo, IEmitter emitter);
}
public class YamlDotNet.Serialization.EventEmitters.TypeAssigningEventEmitter : ChainedEventEmitter {
    private bool requireTagWhenStaticAndActualTypesAreDifferent;
    private IDictionary`2<Type, string> tagMappings;
    public TypeAssigningEventEmitter(IEventEmitter nextEmitter, bool requireTagWhenStaticAndActualTypesAreDifferent, IDictionary`2<Type, string> tagMappings);
    public virtual void Emit(ScalarEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(MappingStartEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(SequenceStartEventInfo eventInfo, IEmitter emitter);
    private void AssignTypeIfNeeded(ObjectEventInfo eventInfo);
}
public class YamlDotNet.Serialization.EventEmitters.WriterEventEmitter : object {
    private sealed virtual override void YamlDotNet.Serialization.IEventEmitter.Emit(AliasEventInfo eventInfo, IEmitter emitter);
    private sealed virtual override void YamlDotNet.Serialization.IEventEmitter.Emit(ScalarEventInfo eventInfo, IEmitter emitter);
    private sealed virtual override void YamlDotNet.Serialization.IEventEmitter.Emit(MappingStartEventInfo eventInfo, IEmitter emitter);
    private sealed virtual override void YamlDotNet.Serialization.IEventEmitter.Emit(MappingEndEventInfo eventInfo, IEmitter emitter);
    private sealed virtual override void YamlDotNet.Serialization.IEventEmitter.Emit(SequenceStartEventInfo eventInfo, IEmitter emitter);
    private sealed virtual override void YamlDotNet.Serialization.IEventEmitter.Emit(SequenceEndEventInfo eventInfo, IEmitter emitter);
}
public abstract class YamlDotNet.Serialization.EventInfo : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IObjectDescriptor <Source>k__BackingField;
    public IObjectDescriptor Source { get; private set; }
    protected EventInfo(IObjectDescriptor source);
    [CompilerGeneratedAttribute]
public IObjectDescriptor get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(IObjectDescriptor value);
}
public interface YamlDotNet.Serialization.IAliasProvider {
    public abstract virtual string GetAlias(object target);
}
public interface YamlDotNet.Serialization.IDeserializer {
    public abstract virtual T Deserialize(string input);
    public abstract virtual T Deserialize(TextReader input);
    public abstract virtual object Deserialize(TextReader input);
    public abstract virtual object Deserialize(string input, Type type);
    public abstract virtual object Deserialize(TextReader input, Type type);
    public abstract virtual T Deserialize(IParser parser);
    public abstract virtual object Deserialize(IParser parser);
    public abstract virtual object Deserialize(IParser parser, Type type);
}
public interface YamlDotNet.Serialization.IEventEmitter {
    public abstract virtual void Emit(AliasEventInfo eventInfo, IEmitter emitter);
    public abstract virtual void Emit(ScalarEventInfo eventInfo, IEmitter emitter);
    public abstract virtual void Emit(MappingStartEventInfo eventInfo, IEmitter emitter);
    public abstract virtual void Emit(MappingEndEventInfo eventInfo, IEmitter emitter);
    public abstract virtual void Emit(SequenceStartEventInfo eventInfo, IEmitter emitter);
    public abstract virtual void Emit(SequenceEndEventInfo eventInfo, IEmitter emitter);
}
public interface YamlDotNet.Serialization.INamingConvention {
    public abstract virtual string Apply(string value);
}
public interface YamlDotNet.Serialization.INodeDeserializer {
    public abstract virtual bool Deserialize(IParser reader, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value);
}
public interface YamlDotNet.Serialization.INodeTypeResolver {
    public abstract virtual bool Resolve(NodeEvent nodeEvent, Type& currentType);
}
public interface YamlDotNet.Serialization.IObjectDescriptor {
    public object Value { get; }
    public Type Type { get; }
    public Type StaticType { get; }
    public ScalarStyle ScalarStyle { get; }
    public abstract virtual object get_Value();
    public abstract virtual Type get_Type();
    public abstract virtual Type get_StaticType();
    public abstract virtual ScalarStyle get_ScalarStyle();
}
public interface YamlDotNet.Serialization.IObjectFactory {
    public abstract virtual object Create(Type type);
}
public interface YamlDotNet.Serialization.IObjectGraphTraversalStrategy {
    public abstract virtual void Traverse(IObjectDescriptor graph, IObjectGraphVisitor`1<TContext> visitor, TContext context);
}
public interface YamlDotNet.Serialization.IObjectGraphVisitor`1 {
    public abstract virtual bool Enter(IObjectDescriptor value, TContext context);
    public abstract virtual bool EnterMapping(IObjectDescriptor key, IObjectDescriptor value, TContext context);
    public abstract virtual bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, TContext context);
    public abstract virtual void VisitScalar(IObjectDescriptor scalar, TContext context);
    public abstract virtual void VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType, TContext context);
    public abstract virtual void VisitMappingEnd(IObjectDescriptor mapping, TContext context);
    public abstract virtual void VisitSequenceStart(IObjectDescriptor sequence, Type elementType, TContext context);
    public abstract virtual void VisitSequenceEnd(IObjectDescriptor sequence, TContext context);
}
public interface YamlDotNet.Serialization.IPropertyDescriptor {
    public string Name { get; }
    public bool CanWrite { get; }
    public Type Type { get; }
    public Type TypeOverride { get; public set; }
    public int Order { get; public set; }
    public ScalarStyle ScalarStyle { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual bool get_CanWrite();
    public abstract virtual Type get_Type();
    public abstract virtual Type get_TypeOverride();
    public abstract virtual void set_TypeOverride(Type value);
    public abstract virtual int get_Order();
    public abstract virtual void set_Order(int value);
    public abstract virtual ScalarStyle get_ScalarStyle();
    public abstract virtual void set_ScalarStyle(ScalarStyle value);
    public abstract virtual T GetCustomAttribute();
    public abstract virtual IObjectDescriptor Read(object target);
    public abstract virtual void Write(object target, object value);
}
public interface YamlDotNet.Serialization.IRegistrationLocationSelectionSyntax`1 {
    public abstract virtual void InsteadOf();
    public abstract virtual void Before();
    public abstract virtual void After();
    public abstract virtual void OnTop();
    public abstract virtual void OnBottom();
}
public interface YamlDotNet.Serialization.ISerializer {
    public abstract virtual void Serialize(TextWriter writer, object graph);
    public abstract virtual string Serialize(object graph);
    public abstract virtual void Serialize(TextWriter writer, object graph, Type type);
    public abstract virtual void Serialize(IEmitter emitter, object graph);
    public abstract virtual void Serialize(IEmitter emitter, object graph, Type type);
}
public interface YamlDotNet.Serialization.ITrackingRegistrationLocationSelectionSyntax`1 {
    public abstract virtual void InsteadOf();
}
public interface YamlDotNet.Serialization.ITypeInspector {
    public abstract virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
    public abstract virtual IPropertyDescriptor GetProperty(Type type, object container, string name, bool ignoreUnmatched);
}
public interface YamlDotNet.Serialization.ITypeResolver {
    public abstract virtual Type Resolve(Type staticType, object actualValue);
}
public interface YamlDotNet.Serialization.IValueDeserializer {
    public abstract virtual object DeserializeValue(IParser parser, Type expectedType, SerializerState state, IValueDeserializer nestedObjectDeserializer);
}
public interface YamlDotNet.Serialization.IValuePromise {
    [CompilerGeneratedAttribute]
public abstract virtual void add_ValueAvailable(Action`1<object> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ValueAvailable(Action`1<object> value);
}
public interface YamlDotNet.Serialization.IValueSerializer {
    public abstract virtual void SerializeValue(IEmitter emitter, object value, Type type);
}
public interface YamlDotNet.Serialization.IYamlConvertible {
    public abstract virtual void Read(IParser parser, Type expectedType, ObjectDeserializer nestedObjectDeserializer);
    public abstract virtual void Write(IEmitter emitter, ObjectSerializer nestedObjectSerializer);
}
[ObsoleteAttribute("Please use IYamlConvertible instead")]
public interface YamlDotNet.Serialization.IYamlSerializable {
    public abstract virtual void ReadYaml(IParser parser);
    public abstract virtual void WriteYaml(IEmitter emitter);
}
public interface YamlDotNet.Serialization.IYamlTypeConverter {
    public abstract virtual bool Accepts(Type type);
    public abstract virtual object ReadYaml(IParser parser, Type type);
    public abstract virtual void WriteYaml(IEmitter emitter, object value, Type type);
}
internal class YamlDotNet.Serialization.LazyComponentRegistrationList`2 : object {
    private List`1<LazyComponentRegistration<TArgument, TComponent>> entries;
    public int Count { get; }
    public IEnumerable`1<Func`2<TArgument, TComponent>> InReverseOrder { get; }
    public LazyComponentRegistrationList`2<TArgument, TComponent> Clone();
    public void Add(Type componentType, Func`2<TArgument, TComponent> factory);
    public void Remove(Type componentType);
    public int get_Count();
    [IteratorStateMachineAttribute("YamlDotNet.Serialization.LazyComponentRegistrationList`2/<get_InReverseOrder>d__9")]
public IEnumerable`1<Func`2<TArgument, TComponent>> get_InReverseOrder();
    public IRegistrationLocationSelectionSyntax`1<TComponent> CreateRegistrationLocationSelector(Type componentType, Func`2<TArgument, TComponent> factory);
    public ITrackingRegistrationLocationSelectionSyntax`1<TComponent> CreateTrackingRegistrationLocationSelector(Type componentType, Func`3<TComponent, TArgument, TComponent> factory);
    public sealed virtual IEnumerator`1<Func`2<TArgument, TComponent>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private int IndexOfRegistration(Type registrationType);
    private void EnsureNoDuplicateRegistrationType(Type componentType);
    private int EnsureRegistrationExists();
}
[ExtensionAttribute]
internal static class YamlDotNet.Serialization.LazyComponentRegistrationListExtensions : object {
    [ExtensionAttribute]
public static TComponent BuildComponentChain(LazyComponentRegistrationList`2<TComponent, TComponent> registrations, TComponent innerComponent);
    [ExtensionAttribute]
public static TComponent BuildComponentChain(LazyComponentRegistrationList`2<TArgument, TComponent> registrations, TComponent innerComponent, Func`2<TComponent, TArgument> argumentBuilder);
    [ExtensionAttribute]
public static List`1<TComponent> BuildComponentList(LazyComponentRegistrationList`2<Nothing, TComponent> registrations);
    [ExtensionAttribute]
public static List`1<TComponent> BuildComponentList(LazyComponentRegistrationList`2<TArgument, TComponent> registrations, TArgument argument);
}
public class YamlDotNet.Serialization.MappingEndEventInfo : EventInfo {
    public MappingEndEventInfo(IObjectDescriptor source);
}
public class YamlDotNet.Serialization.MappingStartEventInfo : ObjectEventInfo {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <IsImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MappingStyle <Style>k__BackingField;
    public bool IsImplicit { get; public set; }
    public MappingStyle Style { get; public set; }
    public MappingStartEventInfo(IObjectDescriptor source);
    [CompilerGeneratedAttribute]
public bool get_IsImplicit();
    [CompilerGeneratedAttribute]
public void set_IsImplicit(bool value);
    [CompilerGeneratedAttribute]
public MappingStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(MappingStyle value);
}
public class YamlDotNet.Serialization.NamingConventions.CamelCaseNamingConvention : object {
    public sealed virtual string Apply(string value);
}
public class YamlDotNet.Serialization.NamingConventions.HyphenatedNamingConvention : object {
    public sealed virtual string Apply(string value);
}
public class YamlDotNet.Serialization.NamingConventions.NullNamingConvention : object {
    public sealed virtual string Apply(string value);
}
public class YamlDotNet.Serialization.NamingConventions.PascalCaseNamingConvention : object {
    public sealed virtual string Apply(string value);
}
public class YamlDotNet.Serialization.NamingConventions.UnderscoredNamingConvention : object {
    public sealed virtual string Apply(string value);
}
public class YamlDotNet.Serialization.NodeDeserializers.ArrayNodeDeserializer : object {
    private sealed virtual override bool YamlDotNet.Serialization.INodeDeserializer.Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value);
}
public class YamlDotNet.Serialization.NodeDeserializers.CollectionNodeDeserializer : object {
    private IObjectFactory _objectFactory;
    public CollectionNodeDeserializer(IObjectFactory objectFactory);
    private sealed virtual override bool YamlDotNet.Serialization.INodeDeserializer.Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value);
    internal static void DeserializeHelper(Type tItem, IParser parser, Func`3<IParser, Type, object> nestedObjectDeserializer, IList result, bool canUpdate);
}
public class YamlDotNet.Serialization.NodeDeserializers.DictionaryNodeDeserializer : object {
    private IObjectFactory _objectFactory;
    public DictionaryNodeDeserializer(IObjectFactory objectFactory);
    private sealed virtual override bool YamlDotNet.Serialization.INodeDeserializer.Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value);
    private static void DeserializeHelper(Type tKey, Type tValue, IParser parser, Func`3<IParser, Type, object> nestedObjectDeserializer, IDictionary result);
}
public class YamlDotNet.Serialization.NodeDeserializers.EnumerableNodeDeserializer : object {
    private sealed virtual override bool YamlDotNet.Serialization.INodeDeserializer.Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value);
}
public class YamlDotNet.Serialization.NodeDeserializers.NullNodeDeserializer : object {
    private sealed virtual override bool YamlDotNet.Serialization.INodeDeserializer.Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value);
    private bool NodeIsNull(NodeEvent nodeEvent);
}
public class YamlDotNet.Serialization.NodeDeserializers.ObjectNodeDeserializer : object {
    private IObjectFactory _objectFactory;
    private ITypeInspector _typeDescriptor;
    private bool _ignoreUnmatched;
    public ObjectNodeDeserializer(IObjectFactory objectFactory, ITypeInspector typeDescriptor, bool ignoreUnmatched);
    private sealed virtual override bool YamlDotNet.Serialization.INodeDeserializer.Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value);
}
public class YamlDotNet.Serialization.NodeDeserializers.ScalarNodeDeserializer : object {
    private static string BooleanTruePattern;
    private static string BooleanFalsePattern;
    private sealed virtual override bool YamlDotNet.Serialization.INodeDeserializer.Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value);
    private object DeserializeBooleanHelper(string value);
    private object DeserializeIntegerHelper(TypeCode typeCode, string value);
    private static object CastInteger(long number, TypeCode typeCode);
    private static object CastInteger(ulong number, TypeCode typeCode);
}
public class YamlDotNet.Serialization.NodeDeserializers.TypeConverterNodeDeserializer : object {
    private IEnumerable`1<IYamlTypeConverter> converters;
    public TypeConverterNodeDeserializer(IEnumerable`1<IYamlTypeConverter> converters);
    private sealed virtual override bool YamlDotNet.Serialization.INodeDeserializer.Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value);
}
public class YamlDotNet.Serialization.NodeDeserializers.YamlConvertibleNodeDeserializer : object {
    private IObjectFactory objectFactory;
    public YamlConvertibleNodeDeserializer(IObjectFactory objectFactory);
    public sealed virtual bool Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value);
}
public class YamlDotNet.Serialization.NodeDeserializers.YamlSerializableNodeDeserializer : object {
    private IObjectFactory objectFactory;
    public YamlSerializableNodeDeserializer(IObjectFactory objectFactory);
    public sealed virtual bool Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value);
}
public class YamlDotNet.Serialization.NodeTypeResolvers.DefaultContainersNodeTypeResolver : object {
    private sealed virtual override bool YamlDotNet.Serialization.INodeTypeResolver.Resolve(NodeEvent nodeEvent, Type& currentType);
}
public class YamlDotNet.Serialization.NodeTypeResolvers.PreventUnknownTagsNodeTypeResolver : object {
    private sealed virtual override bool YamlDotNet.Serialization.INodeTypeResolver.Resolve(NodeEvent nodeEvent, Type& currentType);
}
public class YamlDotNet.Serialization.NodeTypeResolvers.TagNodeTypeResolver : object {
    private IDictionary`2<string, Type> tagMappings;
    public TagNodeTypeResolver(IDictionary`2<string, Type> tagMappings);
    private sealed virtual override bool YamlDotNet.Serialization.INodeTypeResolver.Resolve(NodeEvent nodeEvent, Type& currentType);
}
[ObsoleteAttribute("The mechanism that this class uses to specify type names is non-standard. Register the tags explicitly instead of using this convention.")]
public class YamlDotNet.Serialization.NodeTypeResolvers.TypeNameInTagNodeTypeResolver : object {
    private sealed virtual override bool YamlDotNet.Serialization.INodeTypeResolver.Resolve(NodeEvent nodeEvent, Type& currentType);
}
public class YamlDotNet.Serialization.NodeTypeResolvers.YamlConvertibleTypeResolver : object {
    public sealed virtual bool Resolve(NodeEvent nodeEvent, Type& currentType);
}
public class YamlDotNet.Serialization.NodeTypeResolvers.YamlSerializableTypeResolver : object {
    public sealed virtual bool Resolve(NodeEvent nodeEvent, Type& currentType);
}
public class YamlDotNet.Serialization.Nothing : object {
}
public class YamlDotNet.Serialization.ObjectDescriptor : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Type <StaticType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ScalarStyle <ScalarStyle>k__BackingField;
    public object Value { get; private set; }
    public Type Type { get; private set; }
    public Type StaticType { get; private set; }
    public ScalarStyle ScalarStyle { get; private set; }
    public ObjectDescriptor(object value, Type type, Type staticType);
    public ObjectDescriptor(object value, Type type, Type staticType, ScalarStyle scalarStyle);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_StaticType();
    [CompilerGeneratedAttribute]
private void set_StaticType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual ScalarStyle get_ScalarStyle();
    [CompilerGeneratedAttribute]
private void set_ScalarStyle(ScalarStyle value);
}
public class YamlDotNet.Serialization.ObjectDeserializer : MulticastDelegate {
    public ObjectDeserializer(object object, IntPtr method);
    public virtual object Invoke(Type type);
    public virtual IAsyncResult BeginInvoke(Type type, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class YamlDotNet.Serialization.ObjectEventInfo : EventInfo {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Anchor>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Tag>k__BackingField;
    public string Anchor { get; public set; }
    public string Tag { get; public set; }
    protected ObjectEventInfo(IObjectDescriptor source);
    [CompilerGeneratedAttribute]
public string get_Anchor();
    [CompilerGeneratedAttribute]
public void set_Anchor(string value);
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(string value);
}
public class YamlDotNet.Serialization.ObjectFactories.DefaultObjectFactory : object {
    private static Dictionary`2<Type, Type> defaultInterfaceImplementations;
    private static DefaultObjectFactory();
    public sealed virtual object Create(Type type);
}
public class YamlDotNet.Serialization.ObjectFactories.LambdaObjectFactory : object {
    private Func`2<Type, object> _factory;
    public LambdaObjectFactory(Func`2<Type, object> factory);
    public sealed virtual object Create(Type type);
}
public class YamlDotNet.Serialization.ObjectGraphTraversalStrategies.FullObjectGraphTraversalStrategy : object {
    private int maxRecursion;
    private ITypeInspector typeDescriptor;
    private ITypeResolver typeResolver;
    private INamingConvention namingConvention;
    public FullObjectGraphTraversalStrategy(ITypeInspector typeDescriptor, ITypeResolver typeResolver, int maxRecursion, INamingConvention namingConvention);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphTraversalStrategy.Traverse(IObjectDescriptor graph, IObjectGraphVisitor`1<TContext> visitor, TContext context);
    protected virtual void Traverse(IObjectDescriptor value, IObjectGraphVisitor`1<TContext> visitor, int currentDepth, TContext context);
    protected virtual void TraverseObject(IObjectDescriptor value, IObjectGraphVisitor`1<TContext> visitor, int currentDepth, TContext context);
    protected virtual void TraverseDictionary(IObjectDescriptor dictionary, IObjectGraphVisitor`1<TContext> visitor, int currentDepth, Type keyType, Type valueType, TContext context);
    private void TraverseList(IObjectDescriptor value, IObjectGraphVisitor`1<TContext> visitor, int currentDepth, TContext context);
    protected virtual void TraverseProperties(IObjectDescriptor value, IObjectGraphVisitor`1<TContext> visitor, int currentDepth, TContext context);
    private IObjectDescriptor GetObjectDescriptor(object value, Type staticType);
}
public class YamlDotNet.Serialization.ObjectGraphTraversalStrategies.RoundtripObjectGraphTraversalStrategy : FullObjectGraphTraversalStrategy {
    private IEnumerable`1<IYamlTypeConverter> converters;
    public RoundtripObjectGraphTraversalStrategy(IEnumerable`1<IYamlTypeConverter> converters, ITypeInspector typeDescriptor, ITypeResolver typeResolver, int maxRecursion);
    protected virtual void TraverseProperties(IObjectDescriptor value, IObjectGraphVisitor`1<TContext> visitor, int currentDepth, TContext context);
}
public class YamlDotNet.Serialization.ObjectGraphVisitors.AnchorAssigner : PreProcessingPhaseObjectGraphVisitorSkeleton {
    private IDictionary`2<object, AnchorAssignment> assignments;
    private UInt32 nextId;
    public AnchorAssigner(IEnumerable`1<IYamlTypeConverter> typeConverters);
    protected virtual bool Enter(IObjectDescriptor value);
    protected virtual bool EnterMapping(IObjectDescriptor key, IObjectDescriptor value);
    protected virtual bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value);
    protected virtual void VisitScalar(IObjectDescriptor scalar);
    protected virtual void VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType);
    protected virtual void VisitMappingEnd(IObjectDescriptor mapping);
    protected virtual void VisitSequenceStart(IObjectDescriptor sequence, Type elementType);
    protected virtual void VisitSequenceEnd(IObjectDescriptor sequence);
    private void VisitObject(IObjectDescriptor value);
    private sealed virtual override string YamlDotNet.Serialization.IAliasProvider.GetAlias(object target);
}
public class YamlDotNet.Serialization.ObjectGraphVisitors.AnchorAssigningObjectGraphVisitor : ChainedObjectGraphVisitor {
    private IEventEmitter eventEmitter;
    private IAliasProvider aliasProvider;
    private HashSet`1<string> emittedAliases;
    public AnchorAssigningObjectGraphVisitor(IObjectGraphVisitor`1<IEmitter> nextVisitor, IEventEmitter eventEmitter, IAliasProvider aliasProvider);
    public virtual bool Enter(IObjectDescriptor value, IEmitter context);
    public virtual void VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType, IEmitter context);
    public virtual void VisitSequenceStart(IObjectDescriptor sequence, Type elementType, IEmitter context);
    public virtual void VisitScalar(IObjectDescriptor scalar, IEmitter context);
}
public abstract class YamlDotNet.Serialization.ObjectGraphVisitors.ChainedObjectGraphVisitor : object {
    private IObjectGraphVisitor`1<IEmitter> nextVisitor;
    protected ChainedObjectGraphVisitor(IObjectGraphVisitor`1<IEmitter> nextVisitor);
    public virtual bool Enter(IObjectDescriptor value, IEmitter context);
    public virtual bool EnterMapping(IObjectDescriptor key, IObjectDescriptor value, IEmitter context);
    public virtual bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, IEmitter context);
    public virtual void VisitScalar(IObjectDescriptor scalar, IEmitter context);
    public virtual void VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType, IEmitter context);
    public virtual void VisitMappingEnd(IObjectDescriptor mapping, IEmitter context);
    public virtual void VisitSequenceStart(IObjectDescriptor sequence, Type elementType, IEmitter context);
    public virtual void VisitSequenceEnd(IObjectDescriptor sequence, IEmitter context);
}
public class YamlDotNet.Serialization.ObjectGraphVisitors.CustomSerializationObjectGraphVisitor : ChainedObjectGraphVisitor {
    private IEnumerable`1<IYamlTypeConverter> typeConverters;
    private ObjectSerializer nestedObjectSerializer;
    public CustomSerializationObjectGraphVisitor(IObjectGraphVisitor`1<IEmitter> nextVisitor, IEnumerable`1<IYamlTypeConverter> typeConverters, ObjectSerializer nestedObjectSerializer);
    public virtual bool Enter(IObjectDescriptor value, IEmitter context);
}
public class YamlDotNet.Serialization.ObjectGraphVisitors.DefaultExclusiveObjectGraphVisitor : ChainedObjectGraphVisitor {
    private static IEqualityComparer`1<object> _objectComparer;
    public DefaultExclusiveObjectGraphVisitor(IObjectGraphVisitor`1<IEmitter> nextVisitor);
    private static DefaultExclusiveObjectGraphVisitor();
    private static object GetDefault(Type type);
    public virtual bool EnterMapping(IObjectDescriptor key, IObjectDescriptor value, IEmitter context);
    public virtual bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, IEmitter context);
}
public class YamlDotNet.Serialization.ObjectGraphVisitors.EmittingObjectGraphVisitor : object {
    private IEventEmitter eventEmitter;
    public EmittingObjectGraphVisitor(IEventEmitter eventEmitter);
    private sealed virtual override bool YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Core.IEmitter>.Enter(IObjectDescriptor value, IEmitter context);
    private sealed virtual override bool YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Core.IEmitter>.EnterMapping(IObjectDescriptor key, IObjectDescriptor value, IEmitter context);
    private sealed virtual override bool YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Core.IEmitter>.EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, IEmitter context);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Core.IEmitter>.VisitScalar(IObjectDescriptor scalar, IEmitter context);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Core.IEmitter>.VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType, IEmitter context);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Core.IEmitter>.VisitMappingEnd(IObjectDescriptor mapping, IEmitter context);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Core.IEmitter>.VisitSequenceStart(IObjectDescriptor sequence, Type elementType, IEmitter context);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Core.IEmitter>.VisitSequenceEnd(IObjectDescriptor sequence, IEmitter context);
}
public abstract class YamlDotNet.Serialization.ObjectGraphVisitors.PreProcessingPhaseObjectGraphVisitorSkeleton : object {
    protected IEnumerable`1<IYamlTypeConverter> typeConverters;
    public PreProcessingPhaseObjectGraphVisitorSkeleton(IEnumerable`1<IYamlTypeConverter> typeConverters);
    private sealed virtual override bool YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Serialization.Nothing>.Enter(IObjectDescriptor value, Nothing context);
    private sealed virtual override bool YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Serialization.Nothing>.EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, Nothing context);
    private sealed virtual override bool YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Serialization.Nothing>.EnterMapping(IObjectDescriptor key, IObjectDescriptor value, Nothing context);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Serialization.Nothing>.VisitMappingEnd(IObjectDescriptor mapping, Nothing context);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Serialization.Nothing>.VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType, Nothing context);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Serialization.Nothing>.VisitScalar(IObjectDescriptor scalar, Nothing context);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Serialization.Nothing>.VisitSequenceEnd(IObjectDescriptor sequence, Nothing context);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Serialization.Nothing>.VisitSequenceStart(IObjectDescriptor sequence, Type elementType, Nothing context);
    protected abstract virtual bool Enter(IObjectDescriptor value);
    protected abstract virtual bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value);
    protected abstract virtual bool EnterMapping(IObjectDescriptor key, IObjectDescriptor value);
    protected abstract virtual void VisitMappingEnd(IObjectDescriptor mapping);
    protected abstract virtual void VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType);
    protected abstract virtual void VisitScalar(IObjectDescriptor scalar);
    protected abstract virtual void VisitSequenceEnd(IObjectDescriptor sequence);
    protected abstract virtual void VisitSequenceStart(IObjectDescriptor sequence, Type elementType);
}
public class YamlDotNet.Serialization.ObjectSerializer : MulticastDelegate {
    public ObjectSerializer(object object, IntPtr method);
    public virtual void Invoke(object value, Type type);
    public virtual IAsyncResult BeginInvoke(object value, Type type, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class YamlDotNet.Serialization.PropertyDescriptor : object {
    private IPropertyDescriptor baseDescriptor;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <Order>k__BackingField;
    public string Name { get; public set; }
    public Type Type { get; }
    public Type TypeOverride { get; public set; }
    public int Order { get; public set; }
    public ScalarStyle ScalarStyle { get; public set; }
    public bool CanWrite { get; }
    public PropertyDescriptor(IPropertyDescriptor baseDescriptor);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public sealed virtual Type get_Type();
    public sealed virtual Type get_TypeOverride();
    public sealed virtual void set_TypeOverride(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Order();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Order(int value);
    public sealed virtual ScalarStyle get_ScalarStyle();
    public sealed virtual void set_ScalarStyle(ScalarStyle value);
    public sealed virtual bool get_CanWrite();
    public sealed virtual void Write(object target, object value);
    public sealed virtual T GetCustomAttribute();
    public sealed virtual IObjectDescriptor Read(object target);
}
public class YamlDotNet.Serialization.ScalarEventInfo : ObjectEventInfo {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <RenderedValue>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ScalarStyle <Style>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <IsPlainImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <IsQuotedImplicit>k__BackingField;
    public string RenderedValue { get; public set; }
    public ScalarStyle Style { get; public set; }
    public bool IsPlainImplicit { get; public set; }
    public bool IsQuotedImplicit { get; public set; }
    public ScalarEventInfo(IObjectDescriptor source);
    [CompilerGeneratedAttribute]
public string get_RenderedValue();
    [CompilerGeneratedAttribute]
public void set_RenderedValue(string value);
    [CompilerGeneratedAttribute]
public ScalarStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(ScalarStyle value);
    [CompilerGeneratedAttribute]
public bool get_IsPlainImplicit();
    [CompilerGeneratedAttribute]
public void set_IsPlainImplicit(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsQuotedImplicit();
    [CompilerGeneratedAttribute]
public void set_IsQuotedImplicit(bool value);
}
public class YamlDotNet.Serialization.SequenceEndEventInfo : EventInfo {
    public SequenceEndEventInfo(IObjectDescriptor source);
}
public class YamlDotNet.Serialization.SequenceStartEventInfo : ObjectEventInfo {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <IsImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private SequenceStyle <Style>k__BackingField;
    public bool IsImplicit { get; public set; }
    public SequenceStyle Style { get; public set; }
    public SequenceStartEventInfo(IObjectDescriptor source);
    [CompilerGeneratedAttribute]
public bool get_IsImplicit();
    [CompilerGeneratedAttribute]
public void set_IsImplicit(bool value);
    [CompilerGeneratedAttribute]
public SequenceStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(SequenceStyle value);
}
[FlagsAttribute]
public enum YamlDotNet.Serialization.SerializationOptions : Enum {
    public int value__;
    public static SerializationOptions None;
    public static SerializationOptions Roundtrip;
    public static SerializationOptions DisableAliases;
    public static SerializationOptions EmitDefaults;
    public static SerializationOptions JsonCompatible;
    public static SerializationOptions DefaultToStaticType;
}
public class YamlDotNet.Serialization.Serializer : object {
    private IValueSerializer valueSerializer;
    private Serializer(IValueSerializer valueSerializer);
    public static Serializer FromValueSerializer(IValueSerializer valueSerializer);
    public sealed virtual void Serialize(TextWriter writer, object graph);
    public sealed virtual string Serialize(object graph);
    public sealed virtual void Serialize(TextWriter writer, object graph, Type type);
    public sealed virtual void Serialize(IEmitter emitter, object graph);
    public sealed virtual void Serialize(IEmitter emitter, object graph, Type type);
    private void EmitDocument(IEmitter emitter, object graph, Type type);
}
public class YamlDotNet.Serialization.SerializerBuilder : BuilderSkeleton`1<SerializerBuilder> {
    private Func`4<ITypeInspector, ITypeResolver, IEnumerable`1<IYamlTypeConverter>, IObjectGraphTraversalStrategy> objectGraphTraversalStrategyFactory;
    private LazyComponentRegistrationList`2<IEnumerable`1<IYamlTypeConverter>, IObjectGraphVisitor`1<Nothing>> preProcessingPhaseObjectGraphVisitorFactories;
    private LazyComponentRegistrationList`2<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor`1<IEmitter>> emissionPhaseObjectGraphVisitorFactories;
    private LazyComponentRegistrationList`2<IEventEmitter, IEventEmitter> eventEmitterFactories;
    private IDictionary`2<Type, string> tagMappings;
    private int maximumRecursion;
    protected SerializerBuilder Self { get; }
    protected virtual SerializerBuilder get_Self();
    public SerializerBuilder WithMaximumRecursion(int maximumRecursion);
    public SerializerBuilder WithEventEmitter(Func`2<IEventEmitter, TEventEmitter> eventEmitterFactory);
    public SerializerBuilder WithEventEmitter(Func`2<IEventEmitter, TEventEmitter> eventEmitterFactory, Action`1<IRegistrationLocationSelectionSyntax`1<IEventEmitter>> where);
    public SerializerBuilder WithEventEmitter(WrapperFactory`3<IEventEmitter, IEventEmitter, TEventEmitter> eventEmitterFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<IEventEmitter>> where);
    public SerializerBuilder WithoutEventEmitter();
    public SerializerBuilder WithoutEventEmitter(Type eventEmitterType);
    public SerializerBuilder WithTagMapping(string tag, Type type);
    public SerializerBuilder WithoutTagMapping(Type type);
    public SerializerBuilder EnsureRoundtrip();
    public SerializerBuilder DisableAliases();
    public SerializerBuilder EmitDefaults();
    public SerializerBuilder JsonCompatible();
    public SerializerBuilder WithPreProcessingPhaseObjectGraphVisitor(TObjectGraphVisitor objectGraphVisitor);
    public SerializerBuilder WithPreProcessingPhaseObjectGraphVisitor(TObjectGraphVisitor objectGraphVisitor, Action`1<IRegistrationLocationSelectionSyntax`1<IObjectGraphVisitor`1<Nothing>>> where);
    public SerializerBuilder WithPreProcessingPhaseObjectGraphVisitor(WrapperFactory`2<IObjectGraphVisitor`1<Nothing>, TObjectGraphVisitor> objectGraphVisitorFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<IObjectGraphVisitor`1<Nothing>>> where);
    public SerializerBuilder WithoutPreProcessingPhaseObjectGraphVisitor();
    public SerializerBuilder WithoutPreProcessingPhaseObjectGraphVisitor(Type objectGraphVisitorType);
    public SerializerBuilder WithEmissionPhaseObjectGraphVisitor(Func`2<EmissionPhaseObjectGraphVisitorArgs, TObjectGraphVisitor> objectGraphVisitorFactory);
    public SerializerBuilder WithEmissionPhaseObjectGraphVisitor(Func`2<EmissionPhaseObjectGraphVisitorArgs, TObjectGraphVisitor> objectGraphVisitorFactory, Action`1<IRegistrationLocationSelectionSyntax`1<IObjectGraphVisitor`1<IEmitter>>> where);
    public SerializerBuilder WithEmissionPhaseObjectGraphVisitor(WrapperFactory`3<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor`1<IEmitter>, TObjectGraphVisitor> objectGraphVisitorFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<IObjectGraphVisitor`1<IEmitter>>> where);
    public SerializerBuilder WithoutEmissionPhaseObjectGraphVisitor();
    public SerializerBuilder WithoutEmissionPhaseObjectGraphVisitor(Type objectGraphVisitorType);
    public ISerializer Build();
    public IValueSerializer BuildValueSerializer();
    [CompilerGeneratedAttribute]
private ITypeInspector <.ctor>b__6_1(ITypeInspector inner);
    [CompilerGeneratedAttribute]
private ITypeInspector <.ctor>b__6_3(ITypeInspector inner);
    [CompilerGeneratedAttribute]
private IEventEmitter <.ctor>b__6_8(IEventEmitter inner);
    [CompilerGeneratedAttribute]
private IObjectGraphTraversalStrategy <.ctor>b__6_9(ITypeInspector typeInspector, ITypeResolver typeResolver, IEnumerable`1<IYamlTypeConverter> typeConverters);
    [CompilerGeneratedAttribute]
private IObjectGraphTraversalStrategy <EnsureRoundtrip>b__17_0(ITypeInspector typeInspector, ITypeResolver typeResolver, IEnumerable`1<IYamlTypeConverter> typeConverters);
    [CompilerGeneratedAttribute]
private TypeAssigningEventEmitter <EnsureRoundtrip>b__17_1(IEventEmitter inner);
}
public class YamlDotNet.Serialization.StreamFragment : object {
    private List`1<ParsingEvent> events;
    public IList`1<ParsingEvent> Events { get; }
    public IList`1<ParsingEvent> get_Events();
    private sealed virtual override void YamlDotNet.Serialization.IYamlConvertible.Read(IParser parser, Type expectedType, ObjectDeserializer nestedObjectDeserializer);
    private sealed virtual override void YamlDotNet.Serialization.IYamlConvertible.Write(IEmitter emitter, ObjectSerializer nestedObjectSerializer);
}
public class YamlDotNet.Serialization.TagMappings : object {
    private IDictionary`2<string, Type> mappings;
    public TagMappings(IDictionary`2<string, Type> mappings);
    public void Add(string tag, Type mapping);
    internal Type GetMapping(string tag);
}
public class YamlDotNet.Serialization.TypeInspectors.CachedTypeInspector : TypeInspectorSkeleton {
    private ITypeInspector innerTypeDescriptor;
    private Dictionary`2<Type, List`1<IPropertyDescriptor>> cache;
    public CachedTypeInspector(ITypeInspector innerTypeDescriptor);
    public virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
}
public class YamlDotNet.Serialization.TypeInspectors.NamingConventionTypeInspector : TypeInspectorSkeleton {
    private ITypeInspector innerTypeDescriptor;
    private INamingConvention namingConvention;
    public NamingConventionTypeInspector(ITypeInspector innerTypeDescriptor, INamingConvention namingConvention);
    public virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
    [CompilerGeneratedAttribute]
private IPropertyDescriptor <GetProperties>b__3_0(IPropertyDescriptor p);
}
public class YamlDotNet.Serialization.TypeInspectors.ReadableAndWritablePropertiesTypeInspector : TypeInspectorSkeleton {
    private ITypeInspector _innerTypeDescriptor;
    public ReadableAndWritablePropertiesTypeInspector(ITypeInspector innerTypeDescriptor);
    public virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
}
public class YamlDotNet.Serialization.TypeInspectors.ReadablePropertiesTypeInspector : TypeInspectorSkeleton {
    private ITypeResolver _typeResolver;
    public ReadablePropertiesTypeInspector(ITypeResolver typeResolver);
    private static bool IsValidProperty(PropertyInfo property);
    public virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
    [CompilerGeneratedAttribute]
private IPropertyDescriptor <GetProperties>b__3_0(PropertyInfo p);
}
public abstract class YamlDotNet.Serialization.TypeInspectors.TypeInspectorSkeleton : object {
    public abstract virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
    public sealed virtual IPropertyDescriptor GetProperty(Type type, object container, string name, bool ignoreUnmatched);
}
public class YamlDotNet.Serialization.TypeResolvers.DynamicTypeResolver : object {
    public sealed virtual Type Resolve(Type staticType, object actualValue);
}
public class YamlDotNet.Serialization.TypeResolvers.StaticTypeResolver : object {
    public sealed virtual Type Resolve(Type staticType, object actualValue);
}
public interface YamlDotNet.Serialization.Utilities.IPostDeserializationCallback {
    public abstract virtual void OnDeserialization();
}
[DefaultMemberAttribute("Item")]
internal class YamlDotNet.Serialization.Utilities.ObjectAnchorCollection : object {
    private IDictionary`2<string, object> objectsByAnchor;
    private IDictionary`2<object, string> anchorsByObject;
    public object Item { get; }
    public void Add(string anchor, object object);
    public bool TryGetAnchor(object object, String& anchor);
    public object get_Item(string anchor);
}
internal static class YamlDotNet.Serialization.Utilities.ReflectionUtility : object {
    public static Type GetImplementedGenericInterface(Type type, Type genericInterfaceType);
    [IteratorStateMachineAttribute("YamlDotNet.Serialization.Utilities.ReflectionUtility/<GetImplementedInterfaces>d__1")]
public static IEnumerable`1<Type> GetImplementedInterfaces(Type type);
}
public class YamlDotNet.Serialization.Utilities.SerializerState : object {
    private IDictionary`2<Type, object> items;
    public T Get();
    public void OnDeserialization();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class YamlDotNet.Serialization.Utilities.StringExtensions : object {
    private static string ToCamelOrPascalCase(string str, Func`2<char, char> firstLetterTransform);
    [ExtensionAttribute]
public static string ToCamelCase(string str);
    [ExtensionAttribute]
public static string ToPascalCase(string str);
    [ExtensionAttribute]
public static string FromCamelCase(string str, string separator);
}
public static class YamlDotNet.Serialization.Utilities.TypeConverter : object {
    public static T ChangeType(object value);
    public static T ChangeType(object value, IFormatProvider provider);
    public static T ChangeType(object value, CultureInfo culture);
    public static object ChangeType(object value, Type destinationType);
    public static object ChangeType(object value, Type destinationType, IFormatProvider provider);
    public static object ChangeType(object value, Type destinationType, CultureInfo culture);
}
public class YamlDotNet.Serialization.ValueDeserializers.AliasValueDeserializer : object {
    private IValueDeserializer innerDeserializer;
    public AliasValueDeserializer(IValueDeserializer innerDeserializer);
    public sealed virtual object DeserializeValue(IParser parser, Type expectedType, SerializerState state, IValueDeserializer nestedObjectDeserializer);
}
public class YamlDotNet.Serialization.ValueDeserializers.NodeValueDeserializer : object {
    private IList`1<INodeDeserializer> deserializers;
    private IList`1<INodeTypeResolver> typeResolvers;
    public NodeValueDeserializer(IList`1<INodeDeserializer> deserializers, IList`1<INodeTypeResolver> typeResolvers);
    public sealed virtual object DeserializeValue(IParser parser, Type expectedType, SerializerState state, IValueDeserializer nestedObjectDeserializer);
    private Type GetTypeFromEvent(NodeEvent nodeEvent, Type currentType);
}
public class YamlDotNet.Serialization.WrapperFactory`2 : MulticastDelegate {
    public WrapperFactory`2(object object, IntPtr method);
    public virtual TComponent Invoke(TComponentBase wrapped);
    public virtual IAsyncResult BeginInvoke(TComponentBase wrapped, AsyncCallback callback, object object);
    public virtual TComponent EndInvoke(IAsyncResult result);
}
public class YamlDotNet.Serialization.WrapperFactory`3 : MulticastDelegate {
    public WrapperFactory`3(object object, IntPtr method);
    public virtual TComponent Invoke(TComponentBase wrapped, TArgument argument);
    public virtual IAsyncResult BeginInvoke(TComponentBase wrapped, TArgument argument, AsyncCallback callback, object object);
    public virtual TComponent EndInvoke(IAsyncResult result);
}
public class YamlDotNet.Serialization.YamlAttributeOverrides : object {
    private Dictionary`2<AttributeKey, List`1<AttributeMapping>> overrides;
    public T GetAttribute(Type type, string member);
    public void Add(Type type, string member, Attribute attribute);
    public void Add(Expression`1<Func`2<TClass, object>> propertyAccessor, Attribute attribute);
    public YamlAttributeOverrides Clone();
}
public class YamlDotNet.Serialization.YamlAttributeOverridesInspector : TypeInspectorSkeleton {
    private ITypeInspector innerTypeDescriptor;
    private YamlAttributeOverrides overrides;
    public YamlAttributeOverridesInspector(ITypeInspector innerTypeDescriptor, YamlAttributeOverrides overrides);
    public virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
}
public class YamlDotNet.Serialization.YamlAttributesTypeInspector : TypeInspectorSkeleton {
    private ITypeInspector innerTypeDescriptor;
    public YamlAttributesTypeInspector(ITypeInspector innerTypeDescriptor);
    public virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
}
internal static class YamlDotNet.Serialization.YamlFormatter : object {
    public static NumberFormatInfo NumberFormat;
    private static YamlFormatter();
    public static string FormatNumber(object number);
    public static string FormatNumber(double number);
    public static string FormatNumber(float number);
    public static string FormatBoolean(object boolean);
    public static string FormatDateTime(object dateTime);
    public static string FormatTimeSpan(object timeSpan);
}
[AttributeUsageAttribute("384")]
public class YamlDotNet.Serialization.YamlIgnoreAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
public class YamlDotNet.Serialization.YamlMemberAttribute : Attribute {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Type <SerializeAs>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <ApplyNamingConventions>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ScalarStyle <ScalarStyle>k__BackingField;
    public Type SerializeAs { get; public set; }
    public int Order { get; public set; }
    public string Alias { get; public set; }
    public bool ApplyNamingConventions { get; public set; }
    public ScalarStyle ScalarStyle { get; public set; }
    public YamlMemberAttribute(Type serializeAs);
    [CompilerGeneratedAttribute]
public Type get_SerializeAs();
    [CompilerGeneratedAttribute]
public void set_SerializeAs(Type value);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
public void set_Alias(string value);
    [CompilerGeneratedAttribute]
public bool get_ApplyNamingConventions();
    [CompilerGeneratedAttribute]
public void set_ApplyNamingConventions(bool value);
    [CompilerGeneratedAttribute]
public ScalarStyle get_ScalarStyle();
    [CompilerGeneratedAttribute]
public void set_ScalarStyle(ScalarStyle value);
}
internal static class YamlDotNet.StandardRegexOptions : object {
    public static RegexOptions Compiled;
}
