[SecurityCriticalAttribute("1")]
public static class System.IO.Packaging.PackageStore : object {
    public static Package GetPackage(Uri uri);
    public static void AddPackage(Uri uri, Package package);
    public static void RemovePackage(Uri uri);
}
public class System.IO.Packaging.PackWebRequest : WebRequest {
    public RequestCachePolicy CachePolicy { get; public set; }
    public string ConnectionGroupName { get; public set; }
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public ICredentials Credentials { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public string Method { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public Uri RequestUri { get; }
    public int Timeout { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public virtual RequestCachePolicy get_CachePolicy();
    public virtual void set_CachePolicy(RequestCachePolicy value);
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    [SecurityCriticalAttribute]
public virtual IWebProxy get_Proxy();
    [SecurityCriticalAttribute]
public virtual void set_Proxy(IWebProxy value);
    public virtual Uri get_RequestUri();
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public virtual Stream GetRequestStream();
    [SecurityCriticalAttribute]
public virtual WebResponse GetResponse();
    public WebRequest GetInnerRequest();
}
public class System.IO.Packaging.PackWebRequestFactory : object {
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private static PackWebRequestFactory();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private sealed virtual override WebRequest System.Net.IWebRequestCreate.Create(Uri uri);
}
public class System.IO.Packaging.PackWebResponse : WebResponse {
    public WebResponse InnerResponse { get; }
    public WebHeaderCollection Headers { get; }
    public Uri ResponseUri { get; }
    public bool IsFromCache { get; }
    public string ContentType { get; }
    public long ContentLength { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static PackWebResponse();
    public WebResponse get_InnerResponse();
    public virtual WebHeaderCollection get_Headers();
    public virtual Uri get_ResponseUri();
    public virtual bool get_IsFromCache();
    public virtual string get_ContentType();
    public virtual long get_ContentLength();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual Stream GetResponseStream();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
}
internal class System.JetBrainsMockNotImplementedException : NotImplementedException {
    private Guid _guid;
    public string Message { get; }
    public JetBrainsMockNotImplementedException(Guid guid);
    public virtual string get_Message();
}
public static class System.Windows.Automation.AutomationProperties : object {
    public static DependencyProperty AutomationIdProperty;
    public static DependencyProperty NameProperty;
    public static DependencyProperty HelpTextProperty;
    public static DependencyProperty AcceleratorKeyProperty;
    public static DependencyProperty AccessKeyProperty;
    public static DependencyProperty ItemStatusProperty;
    public static DependencyProperty ItemTypeProperty;
    public static DependencyProperty IsColumnHeaderProperty;
    public static DependencyProperty IsRowHeaderProperty;
    public static DependencyProperty IsRequiredForFormProperty;
    public static DependencyProperty LabeledByProperty;
    public static DependencyProperty IsOffscreenBehaviorProperty;
    public static void SetAutomationId(DependencyObject element, string value);
    public static string GetAutomationId(DependencyObject element);
    public static void SetName(DependencyObject element, string value);
    public static string GetName(DependencyObject element);
    public static void SetHelpText(DependencyObject element, string value);
    public static string GetHelpText(DependencyObject element);
    public static void SetAcceleratorKey(DependencyObject element, string value);
    public static string GetAcceleratorKey(DependencyObject element);
    public static void SetAccessKey(DependencyObject element, string value);
    public static string GetAccessKey(DependencyObject element);
    public static void SetItemStatus(DependencyObject element, string value);
    public static string GetItemStatus(DependencyObject element);
    public static void SetItemType(DependencyObject element, string value);
    public static string GetItemType(DependencyObject element);
    public static void SetIsColumnHeader(DependencyObject element, bool value);
    public static bool GetIsColumnHeader(DependencyObject element);
    public static void SetIsRowHeader(DependencyObject element, bool value);
    public static bool GetIsRowHeader(DependencyObject element);
    public static void SetIsRequiredForForm(DependencyObject element, bool value);
    public static bool GetIsRequiredForForm(DependencyObject element);
    public static void SetLabeledBy(DependencyObject element, UIElement value);
    public static UIElement GetLabeledBy(DependencyObject element);
    public static void SetIsOffscreenBehavior(DependencyObject element, IsOffscreenBehavior value);
    public static IsOffscreenBehavior GetIsOffscreenBehavior(DependencyObject element);
}
public enum System.Windows.Automation.IsOffscreenBehavior : Enum {
    public int value__;
    public static IsOffscreenBehavior Default;
    public static IsOffscreenBehavior Onscreen;
    public static IsOffscreenBehavior Offscreen;
    public static IsOffscreenBehavior FromClip;
}
public enum System.Windows.Automation.Peers.AutomationControlType : Enum {
    public int value__;
    public static AutomationControlType Button;
    public static AutomationControlType Calendar;
    public static AutomationControlType CheckBox;
    public static AutomationControlType ComboBox;
    public static AutomationControlType Edit;
    public static AutomationControlType Hyperlink;
    public static AutomationControlType Image;
    public static AutomationControlType ListItem;
    public static AutomationControlType List;
    public static AutomationControlType Menu;
    public static AutomationControlType MenuBar;
    public static AutomationControlType MenuItem;
    public static AutomationControlType ProgressBar;
    public static AutomationControlType RadioButton;
    public static AutomationControlType ScrollBar;
    public static AutomationControlType Slider;
    public static AutomationControlType Spinner;
    public static AutomationControlType StatusBar;
    public static AutomationControlType Tab;
    public static AutomationControlType TabItem;
    public static AutomationControlType Text;
    public static AutomationControlType ToolBar;
    public static AutomationControlType ToolTip;
    public static AutomationControlType Tree;
    public static AutomationControlType TreeItem;
    public static AutomationControlType Custom;
    public static AutomationControlType Group;
    public static AutomationControlType Thumb;
    public static AutomationControlType DataGrid;
    public static AutomationControlType DataItem;
    public static AutomationControlType Document;
    public static AutomationControlType SplitButton;
    public static AutomationControlType Window;
    public static AutomationControlType Pane;
    public static AutomationControlType Header;
    public static AutomationControlType HeaderItem;
    public static AutomationControlType Table;
    public static AutomationControlType TitleBar;
    public static AutomationControlType Separator;
}
public enum System.Windows.Automation.Peers.AutomationEvents : Enum {
    public int value__;
    public static AutomationEvents ToolTipOpened;
    public static AutomationEvents ToolTipClosed;
    public static AutomationEvents MenuOpened;
    public static AutomationEvents MenuClosed;
    public static AutomationEvents AutomationFocusChanged;
    public static AutomationEvents InvokePatternOnInvoked;
    public static AutomationEvents SelectionItemPatternOnElementAddedToSelection;
    public static AutomationEvents SelectionItemPatternOnElementRemovedFromSelection;
    public static AutomationEvents SelectionItemPatternOnElementSelected;
    public static AutomationEvents SelectionPatternOnInvalidated;
    public static AutomationEvents TextPatternOnTextSelectionChanged;
    public static AutomationEvents TextPatternOnTextChanged;
    public static AutomationEvents AsyncContentLoaded;
    public static AutomationEvents PropertyChanged;
    public static AutomationEvents StructureChanged;
    public static AutomationEvents InputReachedTarget;
    public static AutomationEvents InputReachedOtherElement;
    public static AutomationEvents InputDiscarded;
}
public enum System.Windows.Automation.Peers.AutomationOrientation : Enum {
    public int value__;
    public static AutomationOrientation None;
    public static AutomationOrientation Horizontal;
    public static AutomationOrientation Vertical;
}
public abstract class System.Windows.Automation.Peers.AutomationPeer : DispatcherObject {
    protected bool IsHwndHost { get; }
    public AutomationPeer EventsSource { get; public set; }
    protected virtual bool get_IsHwndHost();
    public AutomationPeer get_EventsSource();
    public void set_EventsSource(AutomationPeer value);
    protected abstract virtual List`1<AutomationPeer> GetChildrenCore();
    public abstract virtual object GetPattern(PatternInterface patternInterface);
    public void InvalidatePeer();
    public static bool ListenerExists(AutomationEvents eventId);
    public void RaiseAutomationEvent(AutomationEvents eventId);
    public void RaisePropertyChangedEvent(AutomationProperty property, object oldValue, object newValue);
    public void RaiseAsyncContentLoadedEvent(AsyncContentLoadedEventArgs args);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual HostedWindowWrapper GetHostRawElementProviderCore();
    protected abstract virtual Rect GetBoundingRectangleCore();
    protected abstract virtual bool IsOffscreenCore();
    protected abstract virtual AutomationOrientation GetOrientationCore();
    protected abstract virtual string GetItemTypeCore();
    protected abstract virtual string GetClassNameCore();
    protected abstract virtual string GetItemStatusCore();
    protected abstract virtual bool IsRequiredForFormCore();
    protected abstract virtual bool IsKeyboardFocusableCore();
    protected abstract virtual bool HasKeyboardFocusCore();
    protected abstract virtual bool IsEnabledCore();
    protected abstract virtual bool IsPasswordCore();
    protected abstract virtual string GetAutomationIdCore();
    protected abstract virtual string GetNameCore();
    protected abstract virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetLocalizedControlTypeCore();
    protected abstract virtual bool IsContentElementCore();
    protected abstract virtual bool IsControlElementCore();
    protected abstract virtual AutomationPeer GetLabeledByCore();
    protected abstract virtual string GetHelpTextCore();
    protected abstract virtual string GetAcceleratorKeyCore();
    protected abstract virtual string GetAccessKeyCore();
    protected abstract virtual Point GetClickablePointCore();
    protected abstract virtual void SetFocusCore();
    public Rect GetBoundingRectangle();
    public bool IsOffscreen();
    public AutomationOrientation GetOrientation();
    public string GetItemType();
    public string GetClassName();
    public string GetItemStatus();
    public bool IsRequiredForForm();
    public bool IsKeyboardFocusable();
    public bool HasKeyboardFocus();
    public bool IsEnabled();
    public bool IsPassword();
    public string GetAutomationId();
    public string GetName();
    public AutomationControlType GetAutomationControlType();
    public string GetLocalizedControlType();
    public bool IsContentElement();
    public bool IsControlElement();
    public AutomationPeer GetLabeledBy();
    public string GetHelpText();
    public string GetAcceleratorKey();
    public string GetAccessKey();
    public Point GetClickablePoint();
    public void SetFocus();
    public AutomationPeer GetParent();
    public List`1<AutomationPeer> GetChildren();
    public void ResetChildrenCache();
    public AutomationPeer GetPeerFromPoint(Point point);
    protected virtual AutomationPeer GetPeerFromPointCore(Point point);
    protected internal IRawElementProviderSimple ProviderFromPeer(AutomationPeer peer);
    protected AutomationPeer PeerFromProvider(IRawElementProviderSimple provider);
}
public class System.Windows.Automation.Peers.ContentElementAutomationPeer : AutomationPeer {
    public ContentElement Owner { get; }
    public ContentElementAutomationPeer(ContentElement owner);
    public ContentElement get_Owner();
    public static AutomationPeer CreatePeerForElement(ContentElement element);
    public static AutomationPeer FromElement(ContentElement element);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetAutomationIdCore();
    protected virtual string GetNameCore();
    protected virtual string GetHelpTextCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual bool IsOffscreenCore();
    protected virtual AutomationOrientation GetOrientationCore();
    protected virtual string GetItemTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual string GetItemStatusCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsPasswordCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual Point GetClickablePointCore();
    protected virtual void SetFocusCore();
}
public class System.Windows.Automation.Peers.GenericRootAutomationPeer : UIElementAutomationPeer {
    public GenericRootAutomationPeer(UIElement owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual string GetNameCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual Rect GetBoundingRectangleCore();
}
public class System.Windows.Automation.Peers.HostedWindowWrapper : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public HostedWindowWrapper(IntPtr hwnd);
}
public enum System.Windows.Automation.Peers.PatternInterface : Enum {
    public int value__;
    public static PatternInterface Invoke;
    public static PatternInterface Selection;
    public static PatternInterface Value;
    public static PatternInterface RangeValue;
    public static PatternInterface Scroll;
    public static PatternInterface ScrollItem;
    public static PatternInterface ExpandCollapse;
    public static PatternInterface Grid;
    public static PatternInterface GridItem;
    public static PatternInterface MultipleView;
    public static PatternInterface Window;
    public static PatternInterface SelectionItem;
    public static PatternInterface Dock;
    public static PatternInterface Table;
    public static PatternInterface TableItem;
    public static PatternInterface Toggle;
    public static PatternInterface Transform;
    public static PatternInterface Text;
    public static PatternInterface ItemContainer;
    public static PatternInterface VirtualizedItem;
    public static PatternInterface SynchronizedInput;
}
public class System.Windows.Automation.Peers.UIElement3DAutomationPeer : AutomationPeer {
    public UIElement3D Owner { get; }
    public UIElement3DAutomationPeer(UIElement3D owner);
    public UIElement3D get_Owner();
    public static AutomationPeer CreatePeerForElement(UIElement3D element);
    public static AutomationPeer FromElement(UIElement3D element);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetAutomationIdCore();
    protected virtual string GetNameCore();
    protected virtual string GetHelpTextCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual bool IsOffscreenCore();
    protected virtual AutomationOrientation GetOrientationCore();
    protected virtual string GetItemTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual string GetItemStatusCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsPasswordCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual Point GetClickablePointCore();
    protected virtual void SetFocusCore();
}
public class System.Windows.Automation.Peers.UIElementAutomationPeer : AutomationPeer {
    public UIElement Owner { get; }
    public UIElementAutomationPeer(UIElement owner);
    public UIElement get_Owner();
    public static AutomationPeer CreatePeerForElement(UIElement element);
    public static AutomationPeer FromElement(UIElement element);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetAutomationIdCore();
    protected virtual string GetNameCore();
    protected virtual string GetHelpTextCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual Rect GetBoundingRectangleCore();
    protected virtual bool IsOffscreenCore();
    protected virtual AutomationOrientation GetOrientationCore();
    protected virtual string GetItemTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual string GetItemStatusCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsPasswordCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual Point GetClickablePointCore();
    protected virtual void SetFocusCore();
}
public class System.Windows.AutoResizedEventArgs : EventArgs {
    public Size Size { get; }
    public AutoResizedEventArgs(Size size);
    public Size get_Size();
}
public class System.Windows.AutoResizedEventHandler : MulticastDelegate {
    public AutoResizedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AutoResizedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AutoResizedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.BaselineAlignment : Enum {
    public int value__;
    public static BaselineAlignment Top;
    public static BaselineAlignment Center;
    public static BaselineAlignment Bottom;
    public static BaselineAlignment Baseline;
    public static BaselineAlignment TextTop;
    public static BaselineAlignment TextBottom;
    public static BaselineAlignment Subscript;
    public static BaselineAlignment Superscript;
}
public static class System.Windows.Clipboard : object {
    [SecurityCriticalAttribute]
public static void Clear();
    public static bool ContainsAudio();
    public static bool ContainsData(string format);
    public static bool ContainsFileDropList();
    public static bool ContainsImage();
    public static bool ContainsText();
    public static bool ContainsText(TextDataFormat format);
    public static void Flush();
    public static Stream GetAudioStream();
    public static object GetData(string format);
    public static StringCollection GetFileDropList();
    public static BitmapSource GetImage();
    public static string GetText();
    public static string GetText(TextDataFormat format);
    public static void SetAudio(Byte[] audioBytes);
    public static void SetAudio(Stream audioStream);
    public static void SetData(string format, object data);
    public static void SetFileDropList(StringCollection fileDropList);
    public static void SetImage(BitmapSource image);
    public static void SetText(string text);
    public static void SetText(string text, TextDataFormat format);
    [SecurityCriticalAttribute]
public static IDataObject GetDataObject();
    public static bool IsCurrent(IDataObject data);
    [SecurityCriticalAttribute]
public static void SetDataObject(object data);
    [SecurityCriticalAttribute]
public static void SetDataObject(object data, bool copy);
}
public class System.Windows.ContentElement : DependencyObject {
    public static RoutedEvent GotFocusEvent;
    public static RoutedEvent LostFocusEvent;
    public static DependencyProperty IsFocusedProperty;
    public static DependencyProperty IsEnabledProperty;
    public static DependencyProperty FocusableProperty;
    public static DependencyProperty AllowDropProperty;
    public static RoutedEvent PreviewMouseDownEvent;
    public static RoutedEvent MouseDownEvent;
    public static RoutedEvent PreviewMouseUpEvent;
    public static RoutedEvent MouseUpEvent;
    public static RoutedEvent PreviewMouseLeftButtonDownEvent;
    public static RoutedEvent MouseLeftButtonDownEvent;
    public static RoutedEvent PreviewMouseLeftButtonUpEvent;
    public static RoutedEvent MouseLeftButtonUpEvent;
    public static RoutedEvent PreviewMouseRightButtonDownEvent;
    public static RoutedEvent MouseRightButtonDownEvent;
    public static RoutedEvent PreviewMouseRightButtonUpEvent;
    public static RoutedEvent MouseRightButtonUpEvent;
    public static RoutedEvent PreviewMouseMoveEvent;
    public static RoutedEvent MouseMoveEvent;
    public static RoutedEvent PreviewMouseWheelEvent;
    public static RoutedEvent MouseWheelEvent;
    public static RoutedEvent MouseEnterEvent;
    public static RoutedEvent MouseLeaveEvent;
    public static RoutedEvent GotMouseCaptureEvent;
    public static RoutedEvent LostMouseCaptureEvent;
    public static RoutedEvent QueryCursorEvent;
    public static RoutedEvent PreviewStylusDownEvent;
    public static RoutedEvent StylusDownEvent;
    public static RoutedEvent PreviewStylusUpEvent;
    public static RoutedEvent StylusUpEvent;
    public static RoutedEvent PreviewStylusMoveEvent;
    public static RoutedEvent StylusMoveEvent;
    public static RoutedEvent PreviewStylusInAirMoveEvent;
    public static RoutedEvent StylusInAirMoveEvent;
    public static RoutedEvent StylusEnterEvent;
    public static RoutedEvent StylusLeaveEvent;
    public static RoutedEvent PreviewStylusInRangeEvent;
    public static RoutedEvent StylusInRangeEvent;
    public static RoutedEvent PreviewStylusOutOfRangeEvent;
    public static RoutedEvent StylusOutOfRangeEvent;
    public static RoutedEvent PreviewStylusSystemGestureEvent;
    public static RoutedEvent StylusSystemGestureEvent;
    public static RoutedEvent GotStylusCaptureEvent;
    public static RoutedEvent LostStylusCaptureEvent;
    public static RoutedEvent StylusButtonDownEvent;
    public static RoutedEvent StylusButtonUpEvent;
    public static RoutedEvent PreviewStylusButtonDownEvent;
    public static RoutedEvent PreviewStylusButtonUpEvent;
    public static RoutedEvent PreviewKeyDownEvent;
    public static RoutedEvent KeyDownEvent;
    public static RoutedEvent PreviewKeyUpEvent;
    public static RoutedEvent KeyUpEvent;
    public static RoutedEvent PreviewGotKeyboardFocusEvent;
    public static RoutedEvent GotKeyboardFocusEvent;
    public static RoutedEvent PreviewLostKeyboardFocusEvent;
    public static RoutedEvent LostKeyboardFocusEvent;
    public static RoutedEvent PreviewTextInputEvent;
    public static RoutedEvent TextInputEvent;
    public static RoutedEvent PreviewQueryContinueDragEvent;
    public static RoutedEvent QueryContinueDragEvent;
    public static RoutedEvent PreviewGiveFeedbackEvent;
    public static RoutedEvent GiveFeedbackEvent;
    public static RoutedEvent PreviewDragEnterEvent;
    public static RoutedEvent DragEnterEvent;
    public static RoutedEvent PreviewDragOverEvent;
    public static RoutedEvent DragOverEvent;
    public static RoutedEvent PreviewDragLeaveEvent;
    public static RoutedEvent DragLeaveEvent;
    public static RoutedEvent PreviewDropEvent;
    public static RoutedEvent DropEvent;
    public static RoutedEvent PreviewTouchDownEvent;
    public static RoutedEvent TouchDownEvent;
    public static RoutedEvent PreviewTouchMoveEvent;
    public static RoutedEvent TouchMoveEvent;
    public static RoutedEvent PreviewTouchUpEvent;
    public static RoutedEvent TouchUpEvent;
    public static RoutedEvent GotTouchCaptureEvent;
    public static RoutedEvent LostTouchCaptureEvent;
    public static RoutedEvent TouchEnterEvent;
    public static RoutedEvent TouchLeaveEvent;
    public static DependencyProperty IsMouseDirectlyOverProperty;
    public static DependencyProperty IsMouseOverProperty;
    public static DependencyProperty IsStylusOverProperty;
    public static DependencyProperty IsKeyboardFocusWithinProperty;
    public static DependencyProperty IsMouseCapturedProperty;
    public static DependencyProperty IsMouseCaptureWithinProperty;
    public static DependencyProperty IsStylusDirectlyOverProperty;
    public static DependencyProperty IsStylusCapturedProperty;
    public static DependencyProperty IsStylusCaptureWithinProperty;
    public static DependencyProperty IsKeyboardFocusedProperty;
    public static DependencyProperty AreAnyTouchesDirectlyOverProperty;
    public static DependencyProperty AreAnyTouchesOverProperty;
    public static DependencyProperty AreAnyTouchesCapturedProperty;
    public static DependencyProperty AreAnyTouchesCapturedWithinProperty;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private RoutedEventHandler GotFocus;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private RoutedEventHandler LostFocus;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsEnabledChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler FocusableChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler PreviewMouseDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler MouseDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler PreviewMouseUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler MouseUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler PreviewMouseLeftButtonDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler MouseLeftButtonDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler PreviewMouseLeftButtonUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler MouseLeftButtonUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler PreviewMouseRightButtonDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler MouseRightButtonDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler PreviewMouseRightButtonUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler MouseRightButtonUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseEventHandler PreviewMouseMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseEventHandler MouseMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseWheelEventHandler PreviewMouseWheel;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseWheelEventHandler MouseWheel;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseEventHandler MouseEnter;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseEventHandler MouseLeave;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseEventHandler GotMouseCapture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseEventHandler LostMouseCapture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private QueryCursorEventHandler QueryCursor;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusDownEventHandler PreviewStylusDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusDownEventHandler StylusDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler PreviewStylusUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler PreviewStylusMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler PreviewStylusInAirMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusInAirMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusEnter;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusLeave;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler PreviewStylusInRange;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusInRange;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler PreviewStylusOutOfRange;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusOutOfRange;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusSystemGestureEventHandler PreviewStylusSystemGesture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusSystemGestureEventHandler StylusSystemGesture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler GotStylusCapture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler LostStylusCapture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusButtonEventHandler StylusButtonDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusButtonEventHandler StylusButtonUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusButtonEventHandler PreviewStylusButtonDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusButtonEventHandler PreviewStylusButtonUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyEventHandler PreviewKeyDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyEventHandler KeyDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyEventHandler PreviewKeyUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyEventHandler KeyUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyboardFocusChangedEventHandler GotKeyboardFocus;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyboardFocusChangedEventHandler LostKeyboardFocus;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TextCompositionEventHandler PreviewTextInput;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TextCompositionEventHandler TextInput;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private QueryContinueDragEventHandler PreviewQueryContinueDrag;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private QueryContinueDragEventHandler QueryContinueDrag;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private GiveFeedbackEventHandler PreviewGiveFeedback;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private GiveFeedbackEventHandler GiveFeedback;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler PreviewDragEnter;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler DragEnter;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler PreviewDragOver;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler DragOver;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler PreviewDragLeave;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler DragLeave;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler PreviewDrop;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler Drop;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> PreviewTouchDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> TouchDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> PreviewTouchMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> TouchMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> PreviewTouchUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> TouchUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> GotTouchCapture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> LostTouchCapture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> TouchEnter;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> TouchLeave;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsMouseCapturedChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsStylusCapturedChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;
    public bool IsMouseDirectlyOver { get; }
    public bool IsMouseOver { get; }
    public bool IsStylusOver { get; }
    public bool IsKeyboardFocusWithin { get; }
    public bool IsMouseCaptured { get; }
    public bool IsMouseCaptureWithin { get; }
    public bool IsStylusDirectlyOver { get; }
    public bool IsStylusCaptured { get; }
    public bool IsStylusCaptureWithin { get; }
    public bool IsKeyboardFocused { get; }
    public bool IsFocused { get; }
    public bool IsEnabled { get; public set; }
    protected bool IsEnabledCore { get; }
    public bool Focusable { get; public set; }
    public bool IsInputMethodEnabled { get; }
    public bool AllowDrop { get; public set; }
    public bool AreAnyTouchesOver { get; }
    public bool AreAnyTouchesDirectlyOver { get; }
    public bool AreAnyTouchesCapturedWithin { get; }
    public bool AreAnyTouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCapturedWithin { get; }
    public IEnumerable`1<TouchDevice> TouchesOver { get; }
    public IEnumerable`1<TouchDevice> TouchesDirectlyOver { get; }
    public bool HasAnimatedProperties { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public InputBindingCollection InputBindings { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public CommandBindingCollection CommandBindings { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static ContentElement();
    public sealed virtual bool get_IsMouseDirectlyOver();
    public sealed virtual bool get_IsMouseOver();
    public sealed virtual bool get_IsStylusOver();
    public sealed virtual bool get_IsKeyboardFocusWithin();
    public sealed virtual bool get_IsMouseCaptured();
    public bool get_IsMouseCaptureWithin();
    public sealed virtual bool get_IsStylusDirectlyOver();
    public sealed virtual bool get_IsStylusCaptured();
    public bool get_IsStylusCaptureWithin();
    public sealed virtual bool get_IsKeyboardFocused();
    public bool get_IsFocused();
    public sealed virtual bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    protected virtual bool get_IsEnabledCore();
    public sealed virtual bool get_Focusable();
    public sealed virtual void set_Focusable(bool value);
    public bool get_IsInputMethodEnabled();
    public bool get_AllowDrop();
    public void set_AllowDrop(bool value);
    public bool get_AreAnyTouchesOver();
    public bool get_AreAnyTouchesDirectlyOver();
    public bool get_AreAnyTouchesCapturedWithin();
    public bool get_AreAnyTouchesCaptured();
    public IEnumerable`1<TouchDevice> get_TouchesCaptured();
    public IEnumerable`1<TouchDevice> get_TouchesCapturedWithin();
    public IEnumerable`1<TouchDevice> get_TouchesOver();
    public IEnumerable`1<TouchDevice> get_TouchesDirectlyOver();
    public sealed virtual bool get_HasAnimatedProperties();
    public InputBindingCollection get_InputBindings();
    public CommandBindingCollection get_CommandBindings();
    [CompilerGeneratedAttribute]
public void add_GotFocus(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_GotFocus(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_LostFocus(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LostFocus(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_FocusableChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_FocusableChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewMouseDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewMouseDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void add_MouseDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_MouseDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewMouseUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewMouseUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void add_MouseUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_MouseUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewMouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewMouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewMouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewMouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseEnter(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseEnter(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseLeave(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseLeave(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_GotMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_GotMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_LostMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_LostMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public void add_QueryCursor(QueryCursorEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_QueryCursor(QueryCursorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusEnter(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusEnter(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusLeave(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusLeave(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_GotStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_GotStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_LostStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_LostStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewKeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewKeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_KeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_KeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewKeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewKeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_KeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_KeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewTextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewTextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_QueryContinueDrag(QueryContinueDragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_QueryContinueDrag(QueryContinueDragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    [CompilerGeneratedAttribute]
public void add_GiveFeedback(GiveFeedbackEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_GiveFeedback(GiveFeedbackEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewDragEnter(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewDragEnter(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DragEnter(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DragEnter(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewDragOver(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewDragOver(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DragOver(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DragOver(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewDragLeave(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewDragLeave(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DragLeave(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DragLeave(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewDrop(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewDrop(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Drop(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Drop(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_TouchDown(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TouchDown(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_TouchMove(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TouchMove(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_TouchUp(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TouchUp(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_TouchEnter(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TouchEnter(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_TouchLeave(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TouchLeave(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    protected internal virtual DependencyObject GetUIParentCore();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    public sealed virtual bool CaptureMouse();
    public sealed virtual void ReleaseMouseCapture();
    public sealed virtual bool CaptureStylus();
    public sealed virtual void ReleaseStylusCapture();
    public sealed virtual bool Focus();
    public virtual bool MoveFocus(TraversalRequest request);
    public virtual DependencyObject PredictFocus(FocusNavigationDirection direction);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    protected virtual void OnLostFocus(RoutedEventArgs e);
    public bool CaptureTouch(TouchDevice touchDevice);
    public bool ReleaseTouchCapture(TouchDevice touchDevice);
    public void ReleaseAllTouchCaptures();
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public sealed virtual object GetAnimationBaseValue(DependencyProperty dp);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInputBindings();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeCommandBindings();
    public sealed virtual void RaiseEvent(RoutedEventArgs e);
    public sealed virtual void AddHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    public sealed virtual void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddToEventRoute(EventRoute route, RoutedEventArgs e);
    protected internal virtual void OnPreviewMouseDown(MouseButtonEventArgs e);
    protected internal virtual void OnMouseDown(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseUp(MouseButtonEventArgs e);
    protected internal virtual void OnMouseUp(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e);
    protected internal virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);
    protected internal virtual void OnMouseRightButtonUp(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseMove(MouseEventArgs e);
    protected internal virtual void OnMouseMove(MouseEventArgs e);
    protected internal virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);
    protected internal virtual void OnMouseWheel(MouseWheelEventArgs e);
    protected internal virtual void OnMouseEnter(MouseEventArgs e);
    protected internal virtual void OnMouseLeave(MouseEventArgs e);
    protected internal virtual void OnGotMouseCapture(MouseEventArgs e);
    protected internal virtual void OnLostMouseCapture(MouseEventArgs e);
    protected internal virtual void OnQueryCursor(QueryCursorEventArgs e);
    protected internal virtual void OnPreviewStylusDown(StylusDownEventArgs e);
    protected internal virtual void OnStylusDown(StylusDownEventArgs e);
    protected internal virtual void OnPreviewStylusUp(StylusEventArgs e);
    protected internal virtual void OnStylusUp(StylusEventArgs e);
    protected internal virtual void OnPreviewStylusMove(StylusEventArgs e);
    protected internal virtual void OnStylusMove(StylusEventArgs e);
    protected internal virtual void OnPreviewStylusInAirMove(StylusEventArgs e);
    protected internal virtual void OnStylusInAirMove(StylusEventArgs e);
    protected internal virtual void OnStylusEnter(StylusEventArgs e);
    protected internal virtual void OnStylusLeave(StylusEventArgs e);
    protected internal virtual void OnPreviewStylusInRange(StylusEventArgs e);
    protected internal virtual void OnStylusInRange(StylusEventArgs e);
    protected internal virtual void OnPreviewStylusOutOfRange(StylusEventArgs e);
    protected internal virtual void OnStylusOutOfRange(StylusEventArgs e);
    protected internal virtual void OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs e);
    protected internal virtual void OnStylusSystemGesture(StylusSystemGestureEventArgs e);
    protected internal virtual void OnGotStylusCapture(StylusEventArgs e);
    protected internal virtual void OnLostStylusCapture(StylusEventArgs e);
    protected internal virtual void OnStylusButtonDown(StylusButtonEventArgs e);
    protected internal virtual void OnStylusButtonUp(StylusButtonEventArgs e);
    protected internal virtual void OnPreviewStylusButtonDown(StylusButtonEventArgs e);
    protected internal virtual void OnPreviewStylusButtonUp(StylusButtonEventArgs e);
    protected internal virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected internal virtual void OnPreviewKeyUp(KeyEventArgs e);
    protected internal virtual void OnKeyUp(KeyEventArgs e);
    protected internal virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected internal virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected internal virtual void OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected internal virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected internal virtual void OnPreviewTextInput(TextCompositionEventArgs e);
    protected internal virtual void OnTextInput(TextCompositionEventArgs e);
    protected internal virtual void OnPreviewQueryContinueDrag(QueryContinueDragEventArgs e);
    protected internal virtual void OnQueryContinueDrag(QueryContinueDragEventArgs e);
    protected internal virtual void OnPreviewGiveFeedback(GiveFeedbackEventArgs e);
    protected internal virtual void OnGiveFeedback(GiveFeedbackEventArgs e);
    protected internal virtual void OnPreviewDragEnter(DragEventArgs e);
    protected internal virtual void OnDragEnter(DragEventArgs e);
    protected internal virtual void OnPreviewDragOver(DragEventArgs e);
    protected internal virtual void OnDragOver(DragEventArgs e);
    protected internal virtual void OnPreviewDragLeave(DragEventArgs e);
    protected internal virtual void OnDragLeave(DragEventArgs e);
    protected internal virtual void OnPreviewDrop(DragEventArgs e);
    protected internal virtual void OnDrop(DragEventArgs e);
    protected internal virtual void OnPreviewTouchDown(TouchEventArgs e);
    protected internal virtual void OnTouchDown(TouchEventArgs e);
    protected internal virtual void OnPreviewTouchMove(TouchEventArgs e);
    protected internal virtual void OnTouchMove(TouchEventArgs e);
    protected internal virtual void OnPreviewTouchUp(TouchEventArgs e);
    protected internal virtual void OnTouchUp(TouchEventArgs e);
    protected internal virtual void OnGotTouchCapture(TouchEventArgs e);
    protected internal virtual void OnLostTouchCapture(TouchEventArgs e);
    protected internal virtual void OnTouchEnter(TouchEventArgs e);
    protected internal virtual void OnTouchLeave(TouchEventArgs e);
    protected virtual void OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs e);
}
public static class System.Windows.ContentOperations : object {
    public static DependencyObject GetParent(ContentElement reference);
    public static void SetParent(ContentElement reference, DependencyObject parent);
}
public static class System.Windows.CoreCompatibilityPreferences : object {
    public static bool IsAltKeyRequiredInAccessKeyDefaultScope { get; public set; }
    public static bool get_IsAltKeyRequiredInAccessKeyDefaultScope();
    public static void set_IsAltKeyRequiredInAccessKeyDefaultScope(bool value);
}
public class System.Windows.CultureInfoIetfLanguageTagConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
public class System.Windows.DataFormat : object {
    public string Name { get; }
    public int Id { get; }
    public DataFormat(string name, int id);
    public string get_Name();
    public int get_Id();
}
public static class System.Windows.DataFormats : object {
    public static string Text;
    public static string UnicodeText;
    public static string Dib;
    public static string Bitmap;
    public static string EnhancedMetafile;
    public static string MetafilePicture;
    public static string SymbolicLink;
    public static string Dif;
    public static string Tiff;
    public static string OemText;
    public static string Palette;
    public static string PenData;
    public static string Riff;
    public static string WaveAudio;
    public static string FileDrop;
    public static string Locale;
    public static string Html;
    public static string Rtf;
    public static string CommaSeparatedValue;
    public static string StringFormat;
    public static string Serializable;
    public static string Xaml;
    public static string XamlPackage;
    public static DataFormat GetDataFormat(int id);
    [SecurityCriticalAttribute]
public static DataFormat GetDataFormat(string format);
}
public class System.Windows.DataObject : object {
    public static RoutedEvent CopyingEvent;
    public static RoutedEvent PastingEvent;
    public static RoutedEvent SettingDataEvent;
    [SecurityCriticalAttribute]
public DataObject(object data);
    [SecurityCriticalAttribute]
public DataObject(string format, object data);
    [SecurityCriticalAttribute]
public DataObject(Type format, object data);
    [SecurityCriticalAttribute]
public DataObject(string format, object data, bool autoConvert);
    public sealed virtual object GetData(string format, bool autoConvert);
    public sealed virtual object GetData(string format);
    public sealed virtual object GetData(Type format);
    public sealed virtual bool GetDataPresent(Type format);
    public sealed virtual bool GetDataPresent(string format, bool autoConvert);
    public sealed virtual bool GetDataPresent(string format);
    public sealed virtual String[] GetFormats(bool autoConvert);
    public sealed virtual String[] GetFormats();
    [SecurityCriticalAttribute]
public sealed virtual void SetData(object data);
    [SecurityCriticalAttribute]
public sealed virtual void SetData(string format, object data);
    [SecurityCriticalAttribute]
public sealed virtual void SetData(Type format, object data);
    [SecurityCriticalAttribute]
public sealed virtual void SetData(string format, object data, bool autoConvert);
    public bool ContainsAudio();
    public bool ContainsFileDropList();
    public bool ContainsImage();
    public bool ContainsText();
    public bool ContainsText(TextDataFormat format);
    public Stream GetAudioStream();
    public StringCollection GetFileDropList();
    public BitmapSource GetImage();
    public string GetText();
    public string GetText(TextDataFormat format);
    public void SetAudio(Byte[] audioBytes);
    public void SetAudio(Stream audioStream);
    public void SetFileDropList(StringCollection fileDropList);
    public void SetImage(BitmapSource image);
    public void SetText(string textData);
    public void SetText(string textData, TextDataFormat format);
    [SecurityCriticalAttribute]
private sealed virtual override int System.Runtime.InteropServices.ComTypes.IDataObject.DAdvise(FORMATETC& pFormatetc, ADVF advf, IAdviseSink pAdvSink, Int32& pdwConnection);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.InteropServices.ComTypes.IDataObject.DUnadvise(int dwConnection);
    [SecurityCriticalAttribute]
private sealed virtual override int System.Runtime.InteropServices.ComTypes.IDataObject.EnumDAdvise(IEnumSTATDATA& enumAdvise);
    [SecurityCriticalAttribute]
private sealed virtual override IEnumFORMATETC System.Runtime.InteropServices.ComTypes.IDataObject.EnumFormatEtc(DATADIR dwDirection);
    [SecurityCriticalAttribute]
private sealed virtual override int System.Runtime.InteropServices.ComTypes.IDataObject.GetCanonicalFormatEtc(FORMATETC& pformatetcIn, FORMATETC& pformatetcOut);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.InteropServices.ComTypes.IDataObject.GetData(FORMATETC& formatetc, STGMEDIUM& medium);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.InteropServices.ComTypes.IDataObject.GetDataHere(FORMATETC& formatetc, STGMEDIUM& medium);
    [SecurityCriticalAttribute]
private sealed virtual override int System.Runtime.InteropServices.ComTypes.IDataObject.QueryGetData(FORMATETC& formatetc);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.InteropServices.ComTypes.IDataObject.SetData(FORMATETC& pFormatetcIn, STGMEDIUM& pmedium, bool fRelease);
    public static void AddCopyingHandler(DependencyObject element, DataObjectCopyingEventHandler handler);
    public static void RemoveCopyingHandler(DependencyObject element, DataObjectCopyingEventHandler handler);
    public static void AddPastingHandler(DependencyObject element, DataObjectPastingEventHandler handler);
    public static void RemovePastingHandler(DependencyObject element, DataObjectPastingEventHandler handler);
    public static void AddSettingDataHandler(DependencyObject element, DataObjectSettingDataEventHandler handler);
    public static void RemoveSettingDataHandler(DependencyObject element, DataObjectSettingDataEventHandler handler);
}
public class System.Windows.DataObjectCopyingEventArgs : DataObjectEventArgs {
    public IDataObject DataObject { get; }
    public DataObjectCopyingEventArgs(IDataObject dataObject, bool isDragDrop);
    public IDataObject get_DataObject();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.DataObjectCopyingEventHandler : MulticastDelegate {
    public DataObjectCopyingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataObjectCopyingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataObjectCopyingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.DataObjectEventArgs : RoutedEventArgs {
    public bool IsDragDrop { get; }
    public bool CommandCancelled { get; }
    internal DataObjectEventArgs(RoutedEvent routedEvent, bool isDragDrop);
    public bool get_IsDragDrop();
    public bool get_CommandCancelled();
    public void CancelCommand();
}
public class System.Windows.DataObjectPastingEventArgs : DataObjectEventArgs {
    public IDataObject SourceDataObject { get; }
    public IDataObject DataObject { get; public set; }
    public string FormatToApply { get; public set; }
    public DataObjectPastingEventArgs(IDataObject dataObject, bool isDragDrop, string formatToApply);
    public IDataObject get_SourceDataObject();
    public IDataObject get_DataObject();
    public void set_DataObject(IDataObject value);
    public string get_FormatToApply();
    public void set_FormatToApply(string value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.DataObjectPastingEventHandler : MulticastDelegate {
    public DataObjectPastingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataObjectPastingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataObjectPastingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.DataObjectSettingDataEventArgs : DataObjectEventArgs {
    public IDataObject DataObject { get; }
    public string Format { get; }
    public DataObjectSettingDataEventArgs(IDataObject dataObject, string format);
    public IDataObject get_DataObject();
    public string get_Format();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.DataObjectSettingDataEventHandler : MulticastDelegate {
    public DataObjectSettingDataEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataObjectSettingDataEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataObjectSettingDataEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.Documents.ContentPosition : object {
    public static ContentPosition Missing;
}
public class System.Windows.Documents.DocumentPage : object {
    public static DocumentPage Missing;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler PageDestroyed;
    public Visual Visual { get; }
    public Size Size { get; }
    public Rect BleedBox { get; }
    public Rect ContentBox { get; }
    public DocumentPage(Visual visual);
    public DocumentPage(Visual visual, Size pageSize, Rect bleedBox, Rect contentBox);
    public virtual Visual get_Visual();
    public virtual Size get_Size();
    public virtual Rect get_BleedBox();
    public virtual Rect get_ContentBox();
    [CompilerGeneratedAttribute]
public void add_PageDestroyed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageDestroyed(EventHandler value);
    public virtual void Dispose();
    protected void OnPageDestroyed(EventArgs e);
    protected void SetVisual(Visual visual);
    protected void SetSize(Size size);
    protected void SetBleedBox(Rect bleedBox);
    protected void SetContentBox(Rect contentBox);
}
public abstract class System.Windows.Documents.DocumentPaginator : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private AsyncCompletedEventHandler ComputePageCountCompleted;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private PagesChangedEventHandler PagesChanged;
    public bool IsPageCountValid { get; }
    public int PageCount { get; }
    public Size PageSize { get; public set; }
    public IDocumentPaginatorSource Source { get; }
    public abstract virtual bool get_IsPageCountValid();
    public abstract virtual int get_PageCount();
    public abstract virtual Size get_PageSize();
    public abstract virtual void set_PageSize(Size value);
    public abstract virtual IDocumentPaginatorSource get_Source();
    [CompilerGeneratedAttribute]
public void add_ComputePageCountCompleted(AsyncCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ComputePageCountCompleted(AsyncCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PagesChanged(PagesChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PagesChanged(PagesChangedEventHandler value);
    public abstract virtual DocumentPage GetPage(int pageNumber);
    public virtual void GetPageAsync(int pageNumber);
    public virtual void GetPageAsync(int pageNumber, object userState);
    public virtual void ComputePageCount();
    public virtual void ComputePageCountAsync();
    public virtual void ComputePageCountAsync(object userState);
    public virtual void CancelAsync(object userState);
    protected virtual void OnComputePageCountCompleted(AsyncCompletedEventArgs e);
    protected virtual void OnPagesChanged(PagesChangedEventArgs e);
}
public abstract class System.Windows.Documents.DynamicDocumentPaginator : DocumentPaginator {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler PaginationCompleted;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private PaginationProgressEventHandler PaginationProgress;
    public bool IsBackgroundPaginationEnabled { get; public set; }
    public virtual bool get_IsBackgroundPaginationEnabled();
    public virtual void set_IsBackgroundPaginationEnabled(bool value);
    [CompilerGeneratedAttribute]
public void add_PaginationCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PaginationCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PaginationProgress(PaginationProgressEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PaginationProgress(PaginationProgressEventHandler value);
    public abstract virtual int GetPageNumber(ContentPosition contentPosition);
    public virtual void GetPageNumberAsync(ContentPosition contentPosition);
    public virtual void GetPageNumberAsync(ContentPosition contentPosition, object userState);
    public abstract virtual ContentPosition GetPagePosition(DocumentPage page);
    public abstract virtual ContentPosition GetObjectPosition(object value);
    protected virtual void OnPaginationProgress(PaginationProgressEventArgs e);
    protected virtual void OnPaginationCompleted(EventArgs e);
}
public interface System.Windows.Documents.IDocumentPaginatorSource {
    public DocumentPaginator DocumentPaginator { get; }
    public abstract virtual DocumentPaginator get_DocumentPaginator();
}
public class System.Windows.Documents.PagesChangedEventArgs : EventArgs {
    public int Start { get; }
    public int Count { get; }
    public PagesChangedEventArgs(int start, int count);
    public int get_Start();
    public int get_Count();
}
public class System.Windows.Documents.PagesChangedEventHandler : MulticastDelegate {
    public PagesChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PagesChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PagesChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Documents.PaginationProgressEventArgs : EventArgs {
    public int Start { get; }
    public int Count { get; }
    public PaginationProgressEventArgs(int start, int count);
    public int get_Start();
    public int get_Count();
}
public class System.Windows.Documents.PaginationProgressEventHandler : MulticastDelegate {
    public PaginationProgressEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PaginationProgressEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PaginationProgressEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.DragAction : Enum {
    public int value__;
    public static DragAction Continue;
    public static DragAction Drop;
    public static DragAction Cancel;
}
public static class System.Windows.DragDrop : object {
    public static RoutedEvent PreviewQueryContinueDragEvent;
    public static RoutedEvent QueryContinueDragEvent;
    public static RoutedEvent PreviewGiveFeedbackEvent;
    public static RoutedEvent GiveFeedbackEvent;
    public static RoutedEvent PreviewDragEnterEvent;
    public static RoutedEvent DragEnterEvent;
    public static RoutedEvent PreviewDragOverEvent;
    public static RoutedEvent DragOverEvent;
    public static RoutedEvent PreviewDragLeaveEvent;
    public static RoutedEvent DragLeaveEvent;
    public static RoutedEvent PreviewDropEvent;
    public static RoutedEvent DropEvent;
    public static void AddPreviewQueryContinueDragHandler(DependencyObject element, QueryContinueDragEventHandler handler);
    public static void RemovePreviewQueryContinueDragHandler(DependencyObject element, QueryContinueDragEventHandler handler);
    public static void AddQueryContinueDragHandler(DependencyObject element, QueryContinueDragEventHandler handler);
    public static void RemoveQueryContinueDragHandler(DependencyObject element, QueryContinueDragEventHandler handler);
    public static void AddPreviewGiveFeedbackHandler(DependencyObject element, GiveFeedbackEventHandler handler);
    public static void RemovePreviewGiveFeedbackHandler(DependencyObject element, GiveFeedbackEventHandler handler);
    public static void AddGiveFeedbackHandler(DependencyObject element, GiveFeedbackEventHandler handler);
    public static void RemoveGiveFeedbackHandler(DependencyObject element, GiveFeedbackEventHandler handler);
    public static void AddPreviewDragEnterHandler(DependencyObject element, DragEventHandler handler);
    public static void RemovePreviewDragEnterHandler(DependencyObject element, DragEventHandler handler);
    public static void AddDragEnterHandler(DependencyObject element, DragEventHandler handler);
    public static void RemoveDragEnterHandler(DependencyObject element, DragEventHandler handler);
    public static void AddPreviewDragOverHandler(DependencyObject element, DragEventHandler handler);
    public static void RemovePreviewDragOverHandler(DependencyObject element, DragEventHandler handler);
    public static void AddDragOverHandler(DependencyObject element, DragEventHandler handler);
    public static void RemoveDragOverHandler(DependencyObject element, DragEventHandler handler);
    public static void AddPreviewDragLeaveHandler(DependencyObject element, DragEventHandler handler);
    public static void RemovePreviewDragLeaveHandler(DependencyObject element, DragEventHandler handler);
    public static void AddDragLeaveHandler(DependencyObject element, DragEventHandler handler);
    public static void RemoveDragLeaveHandler(DependencyObject element, DragEventHandler handler);
    public static void AddPreviewDropHandler(DependencyObject element, DragEventHandler handler);
    public static void RemovePreviewDropHandler(DependencyObject element, DragEventHandler handler);
    public static void AddDropHandler(DependencyObject element, DragEventHandler handler);
    public static void RemoveDropHandler(DependencyObject element, DragEventHandler handler);
    [SecurityCriticalAttribute]
public static DragDropEffects DoDragDrop(DependencyObject dragSource, object data, DragDropEffects allowedEffects);
}
[FlagsAttribute]
public enum System.Windows.DragDropEffects : Enum {
    public int value__;
    public static DragDropEffects None;
    public static DragDropEffects Copy;
    public static DragDropEffects Move;
    public static DragDropEffects Link;
    public static DragDropEffects Scroll;
    public static DragDropEffects All;
}
[FlagsAttribute]
public enum System.Windows.DragDropKeyStates : Enum {
    public int value__;
    public static DragDropKeyStates None;
    public static DragDropKeyStates LeftMouseButton;
    public static DragDropKeyStates RightMouseButton;
    public static DragDropKeyStates ShiftKey;
    public static DragDropKeyStates ControlKey;
    public static DragDropKeyStates MiddleMouseButton;
    public static DragDropKeyStates AltKey;
}
public class System.Windows.DragEventArgs : RoutedEventArgs {
    public IDataObject Data { get; }
    public DragDropKeyStates KeyStates { get; }
    public DragDropEffects AllowedEffects { get; }
    public DragDropEffects Effects { get; public set; }
    internal DragEventArgs(IDataObject data, DragDropKeyStates dragDropKeyStates, DragDropEffects allowedEffects, DependencyObject target, Point point);
    public IDataObject get_Data();
    public DragDropKeyStates get_KeyStates();
    public DragDropEffects get_AllowedEffects();
    public DragDropEffects get_Effects();
    public void set_Effects(DragDropEffects value);
    public Point GetPosition(IInputElement relativeTo);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.DragEventHandler : MulticastDelegate {
    public DragEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DragEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DragEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeConverterAttribute("System.Windows.DurationConverter")]
public class System.Windows.Duration : ValueType {
    private TimeSpan _timeSpan;
    private DurationType _durationType;
    public bool HasTimeSpan { get; }
    public static Duration Automatic { get; }
    public static Duration Forever { get; }
    public TimeSpan TimeSpan { get; }
    public Duration(TimeSpan timeSpan);
    public bool get_HasTimeSpan();
    public static Duration get_Automatic();
    public static Duration get_Forever();
    public TimeSpan get_TimeSpan();
    public static Duration op_Implicit(TimeSpan timeSpan);
    public static Duration op_Addition(Duration t1, Duration t2);
    public static Duration op_Subtraction(Duration t1, Duration t2);
    public static bool op_Equality(Duration t1, Duration t2);
    public static bool op_Inequality(Duration t1, Duration t2);
    public static bool op_GreaterThan(Duration t1, Duration t2);
    public static bool op_GreaterThanOrEqual(Duration t1, Duration t2);
    public static bool op_LessThan(Duration t1, Duration t2);
    public static bool op_LessThanOrEqual(Duration t1, Duration t2);
    public static Duration op_UnaryPlus(Duration duration);
    public static int Compare(Duration t1, Duration t2);
    public static Duration Plus(Duration duration);
    public Duration Add(Duration duration);
    public virtual bool Equals(object value);
    public bool Equals(Duration duration);
    public static bool Equals(Duration t1, Duration t2);
    public virtual int GetHashCode();
    public Duration Subtract(Duration duration);
    public virtual string ToString();
}
public class System.Windows.DurationConverter : TypeConverter {
    private static TimeSpanConverter ourTimeSpanConverter;
    private static DurationConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo cultureInfo, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo cultureInfo, object value, Type destinationType);
}
public static class System.Windows.EventManager : object {
    public static RoutedEvent RegisterRoutedEvent(string name, RoutingStrategy routingStrategy, Type handlerType, Type ownerType);
    public static void RegisterClassHandler(Type classType, RoutedEvent routedEvent, Delegate handler);
    public static void RegisterClassHandler(Type classType, RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    public static RoutedEvent[] GetRoutedEvents();
    public static RoutedEvent[] GetRoutedEventsForOwner(Type ownerType);
}
public class System.Windows.EventPrivateKey : object {
}
public class System.Windows.EventRoute : object {
    public EventRoute(RoutedEvent routedEvent);
    public void Add(object target, Delegate handler, bool handledEventsToo);
    [EditorBrowsableAttribute("2")]
public void PushBranchNode(object node, object source);
    [EditorBrowsableAttribute("2")]
public object PopBranchNode();
    [EditorBrowsableAttribute("2")]
public object PeekBranchNode();
    [EditorBrowsableAttribute("2")]
public object PeekBranchSource();
}
[LocalizabilityAttribute("0")]
public enum System.Windows.FlowDirection : Enum {
    public int value__;
    public static FlowDirection LeftToRight;
    public static FlowDirection RightToLeft;
}
public enum System.Windows.FontCapitals : Enum {
    public int value__;
    public static FontCapitals Normal;
    public static FontCapitals AllSmallCaps;
    public static FontCapitals SmallCaps;
    public static FontCapitals AllPetiteCaps;
    public static FontCapitals PetiteCaps;
    public static FontCapitals Unicase;
    public static FontCapitals Titling;
}
public enum System.Windows.FontEastAsianLanguage : Enum {
    public int value__;
    public static FontEastAsianLanguage Normal;
    public static FontEastAsianLanguage Jis78;
    public static FontEastAsianLanguage Jis83;
    public static FontEastAsianLanguage Jis90;
    public static FontEastAsianLanguage Jis04;
    public static FontEastAsianLanguage HojoKanji;
    public static FontEastAsianLanguage NlcKanji;
    public static FontEastAsianLanguage Simplified;
    public static FontEastAsianLanguage Traditional;
    public static FontEastAsianLanguage TraditionalNames;
}
public enum System.Windows.FontEastAsianWidths : Enum {
    public int value__;
    public static FontEastAsianWidths Normal;
    public static FontEastAsianWidths Proportional;
    public static FontEastAsianWidths Full;
    public static FontEastAsianWidths Half;
    public static FontEastAsianWidths Third;
    public static FontEastAsianWidths Quarter;
}
public enum System.Windows.FontFraction : Enum {
    public int value__;
    public static FontFraction Normal;
    public static FontFraction Slashed;
    public static FontFraction Stacked;
}
public enum System.Windows.FontNumeralAlignment : Enum {
    public int value__;
    public static FontNumeralAlignment Normal;
    public static FontNumeralAlignment Proportional;
    public static FontNumeralAlignment Tabular;
}
public enum System.Windows.FontNumeralStyle : Enum {
    public int value__;
    public static FontNumeralStyle Normal;
    public static FontNumeralStyle Lining;
    public static FontNumeralStyle OldStyle;
}
[LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.FontStretchConverter")]
public class System.Windows.FontStretch : ValueType {
    private int _stretch;
    internal FontStretch(int stretch);
    public static bool op_LessThan(FontStretch left, FontStretch right);
    public static bool op_LessThanOrEqual(FontStretch left, FontStretch right);
    public static bool op_GreaterThan(FontStretch left, FontStretch right);
    public static bool op_GreaterThanOrEqual(FontStretch left, FontStretch right);
    public static bool op_Equality(FontStretch left, FontStretch right);
    public static bool op_Inequality(FontStretch left, FontStretch right);
    public static FontStretch FromOpenTypeStretch(int stretchValue);
    public int ToOpenTypeStretch();
    public static int Compare(FontStretch left, FontStretch right);
    public bool Equals(FontStretch obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
public class System.Windows.FontStretchConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.FontStretches : object {
    public static FontStretch UltraCondensed { get; }
    public static FontStretch ExtraCondensed { get; }
    public static FontStretch Condensed { get; }
    public static FontStretch SemiCondensed { get; }
    public static FontStretch Normal { get; }
    public static FontStretch Medium { get; }
    public static FontStretch SemiExpanded { get; }
    public static FontStretch Expanded { get; }
    public static FontStretch ExtraExpanded { get; }
    public static FontStretch UltraExpanded { get; }
    public static FontStretch get_UltraCondensed();
    public static FontStretch get_ExtraCondensed();
    public static FontStretch get_Condensed();
    public static FontStretch get_SemiCondensed();
    public static FontStretch get_Normal();
    public static FontStretch get_Medium();
    public static FontStretch get_SemiExpanded();
    public static FontStretch get_Expanded();
    public static FontStretch get_ExtraExpanded();
    public static FontStretch get_UltraExpanded();
}
[TypeConverterAttribute("System.Windows.FontStyleConverter")]
[LocalizabilityAttribute("0")]
public class System.Windows.FontStyle : ValueType {
    private int _style;
    internal FontStyle(int style);
    public static bool op_Equality(FontStyle left, FontStyle right);
    public static bool op_Inequality(FontStyle left, FontStyle right);
    public bool Equals(FontStyle obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
public class System.Windows.FontStyleConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.FontStyles : object {
    public static FontStyle Normal { get; }
    public static FontStyle Oblique { get; }
    public static FontStyle Italic { get; }
    public static FontStyle get_Normal();
    public static FontStyle get_Oblique();
    public static FontStyle get_Italic();
}
public enum System.Windows.FontVariants : Enum {
    public int value__;
    public static FontVariants Normal;
    public static FontVariants Superscript;
    public static FontVariants Subscript;
    public static FontVariants Ordinal;
    public static FontVariants Inferior;
    public static FontVariants Ruby;
}
[LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.FontWeightConverter")]
public class System.Windows.FontWeight : ValueType {
    private int _weight;
    internal FontWeight(int weight);
    public static bool op_LessThan(FontWeight left, FontWeight right);
    public static bool op_LessThanOrEqual(FontWeight left, FontWeight right);
    public static bool op_GreaterThan(FontWeight left, FontWeight right);
    public static bool op_GreaterThanOrEqual(FontWeight left, FontWeight right);
    public static bool op_Equality(FontWeight left, FontWeight right);
    public static bool op_Inequality(FontWeight left, FontWeight right);
    public static FontWeight FromOpenTypeWeight(int weightValue);
    public int ToOpenTypeWeight();
    public static int Compare(FontWeight left, FontWeight right);
    public bool Equals(FontWeight obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
public class System.Windows.FontWeightConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.FontWeights : object {
    public static FontWeight Thin { get; }
    public static FontWeight ExtraLight { get; }
    public static FontWeight UltraLight { get; }
    public static FontWeight Light { get; }
    public static FontWeight Normal { get; }
    public static FontWeight Regular { get; }
    public static FontWeight Medium { get; }
    public static FontWeight DemiBold { get; }
    public static FontWeight SemiBold { get; }
    public static FontWeight Bold { get; }
    public static FontWeight ExtraBold { get; }
    public static FontWeight UltraBold { get; }
    public static FontWeight Black { get; }
    public static FontWeight Heavy { get; }
    public static FontWeight ExtraBlack { get; }
    public static FontWeight UltraBlack { get; }
    public static FontWeight get_Thin();
    public static FontWeight get_ExtraLight();
    public static FontWeight get_UltraLight();
    public static FontWeight get_Light();
    public static FontWeight get_Normal();
    public static FontWeight get_Regular();
    public static FontWeight get_Medium();
    public static FontWeight get_DemiBold();
    public static FontWeight get_SemiBold();
    public static FontWeight get_Bold();
    public static FontWeight get_ExtraBold();
    public static FontWeight get_UltraBold();
    public static FontWeight get_Black();
    public static FontWeight get_Heavy();
    public static FontWeight get_ExtraBlack();
    public static FontWeight get_UltraBlack();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.FreezableCollection`1 : Animatable {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private NotifyCollectionChangedEventHandler CollectionChanged;
    public T Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public FreezableCollection`1(int capacity);
    public FreezableCollection`1(IEnumerable`1<T> collection);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    public FreezableCollection`1<T> Clone();
    public FreezableCollection`1<T> CloneCurrentValue();
    public sealed virtual void Add(T value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T value);
    public sealed virtual int IndexOf(T value);
    public sealed virtual void Insert(int index, T value);
    public sealed virtual bool Remove(T value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(T[] array, int index);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
public class System.Windows.GiveFeedbackEventArgs : RoutedEventArgs {
    public DragDropEffects Effects { get; }
    public bool UseDefaultCursors { get; public set; }
    internal GiveFeedbackEventArgs(DragDropEffects effects, bool useDefaultCursors);
    public DragDropEffects get_Effects();
    public bool get_UseDefaultCursors();
    public void set_UseDefaultCursors(bool value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.GiveFeedbackEventHandler : MulticastDelegate {
    public GiveFeedbackEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, GiveFeedbackEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, GiveFeedbackEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface System.Windows.IContentHost {
    public IEnumerator`1<IInputElement> HostedElements { get; }
    public abstract virtual IEnumerator`1<IInputElement> get_HostedElements();
    public abstract virtual IInputElement InputHitTest(Point point);
    public abstract virtual ReadOnlyCollection`1<Rect> GetRectangles(ContentElement child);
    public abstract virtual void OnChildDesiredSizeChanged(UIElement child);
}
public interface System.Windows.IDataObject {
    [SecurityCriticalAttribute]
public abstract virtual object GetData(string format);
    [SecurityCriticalAttribute]
public abstract virtual object GetData(Type format);
    [SecurityCriticalAttribute]
public abstract virtual object GetData(string format, bool autoConvert);
    [SecurityCriticalAttribute]
public abstract virtual bool GetDataPresent(string format);
    [SecurityCriticalAttribute]
public abstract virtual bool GetDataPresent(Type format);
    [SecurityCriticalAttribute]
public abstract virtual bool GetDataPresent(string format, bool autoConvert);
    [SecurityCriticalAttribute]
public abstract virtual String[] GetFormats();
    [SecurityCriticalAttribute]
public abstract virtual String[] GetFormats(bool autoConvert);
    [SecurityCriticalAttribute]
public abstract virtual void SetData(object data);
    [SecurityCriticalAttribute]
public abstract virtual void SetData(string format, object data);
    [SecurityCriticalAttribute]
public abstract virtual void SetData(Type format, object data);
    [SecurityCriticalAttribute]
public abstract virtual void SetData(string format, object data, bool autoConvert);
}
public interface System.Windows.IInputElement {
    public bool IsMouseOver { get; }
    public bool IsMouseDirectlyOver { get; }
    public bool IsMouseCaptured { get; }
    public bool IsStylusOver { get; }
    public bool IsStylusDirectlyOver { get; }
    public bool IsStylusCaptured { get; }
    public bool IsKeyboardFocusWithin { get; }
    public bool IsKeyboardFocused { get; }
    public bool IsEnabled { get; }
    public bool Focusable { get; public set; }
    public abstract virtual bool get_IsMouseOver();
    public abstract virtual bool get_IsMouseDirectlyOver();
    public abstract virtual bool get_IsMouseCaptured();
    public abstract virtual bool get_IsStylusOver();
    public abstract virtual bool get_IsStylusDirectlyOver();
    public abstract virtual bool get_IsStylusCaptured();
    public abstract virtual bool get_IsKeyboardFocusWithin();
    public abstract virtual bool get_IsKeyboardFocused();
    public abstract virtual bool get_IsEnabled();
    public abstract virtual bool get_Focusable();
    public abstract virtual void set_Focusable(bool value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseEnter(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseEnter(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseLeave(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseLeave(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_GotMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_GotMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LostMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LostMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusEnter(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusEnter(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusLeave(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusLeave(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_GotStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_GotStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LostStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LostStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewKeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewKeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_KeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_KeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewKeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewKeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_KeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_KeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewTextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewTextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TextInput(TextCompositionEventHandler value);
    public abstract virtual void RaiseEvent(RoutedEventArgs e);
    public abstract virtual void AddHandler(RoutedEvent routedEvent, Delegate handler);
    public abstract virtual void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    public abstract virtual bool CaptureMouse();
    public abstract virtual void ReleaseMouseCapture();
    public abstract virtual bool CaptureStylus();
    public abstract virtual void ReleaseStylusCapture();
    public abstract virtual bool Focus();
}
public enum System.Windows.Ink.ApplicationGesture : Enum {
    public int value__;
    public static ApplicationGesture AllGestures;
    public static ApplicationGesture NoGesture;
    public static ApplicationGesture ScratchOut;
    public static ApplicationGesture Triangle;
    public static ApplicationGesture Square;
    public static ApplicationGesture Star;
    public static ApplicationGesture Check;
    public static ApplicationGesture Curlicue;
    public static ApplicationGesture DoubleCurlicue;
    public static ApplicationGesture Circle;
    public static ApplicationGesture DoubleCircle;
    public static ApplicationGesture SemicircleLeft;
    public static ApplicationGesture SemicircleRight;
    public static ApplicationGesture ChevronUp;
    public static ApplicationGesture ChevronDown;
    public static ApplicationGesture ChevronLeft;
    public static ApplicationGesture ChevronRight;
    public static ApplicationGesture ArrowUp;
    public static ApplicationGesture ArrowDown;
    public static ApplicationGesture ArrowLeft;
    public static ApplicationGesture ArrowRight;
    public static ApplicationGesture Up;
    public static ApplicationGesture Down;
    public static ApplicationGesture Left;
    public static ApplicationGesture Right;
    public static ApplicationGesture UpDown;
    public static ApplicationGesture DownUp;
    public static ApplicationGesture LeftRight;
    public static ApplicationGesture RightLeft;
    public static ApplicationGesture UpLeftLong;
    public static ApplicationGesture UpRightLong;
    public static ApplicationGesture DownLeftLong;
    public static ApplicationGesture DownRightLong;
    public static ApplicationGesture UpLeft;
    public static ApplicationGesture UpRight;
    public static ApplicationGesture DownLeft;
    public static ApplicationGesture DownRight;
    public static ApplicationGesture LeftUp;
    public static ApplicationGesture LeftDown;
    public static ApplicationGesture RightUp;
    public static ApplicationGesture RightDown;
    public static ApplicationGesture Exclamation;
    public static ApplicationGesture Tap;
    public static ApplicationGesture DoubleTap;
}
public static class System.Windows.Ink.DrawingAttributeIds : object {
    public static Guid Color;
    public static Guid StylusTip;
    public static Guid StylusTipTransform;
    public static Guid StylusHeight;
    public static Guid StylusWidth;
    public static Guid DrawingFlags;
    public static Guid IsHighlighter;
}
public class System.Windows.Ink.DrawingAttributes : object {
    public static double MinHeight;
    public static double MinWidth;
    public static double MaxHeight;
    public static double MaxWidth;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private PropertyDataChangedEventHandler AttributeChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private PropertyDataChangedEventHandler PropertyDataChanged;
    public Color Color { get; public set; }
    public StylusTip StylusTip { get; public set; }
    public Matrix StylusTipTransform { get; public set; }
    public double Height { get; public set; }
    public double Width { get; public set; }
    public bool FitToCurve { get; public set; }
    public bool IgnorePressure { get; public set; }
    public bool IsHighlighter { get; public set; }
    public Color get_Color();
    public void set_Color(Color value);
    public StylusTip get_StylusTip();
    public void set_StylusTip(StylusTip value);
    public Matrix get_StylusTipTransform();
    public void set_StylusTipTransform(Matrix value);
    public double get_Height();
    public void set_Height(double value);
    public double get_Width();
    public void set_Width(double value);
    public bool get_FitToCurve();
    public void set_FitToCurve(bool value);
    public bool get_IgnorePressure();
    public void set_IgnorePressure(bool value);
    public bool get_IsHighlighter();
    public void set_IsHighlighter(bool value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_AttributeChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AttributeChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PropertyDataChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PropertyDataChanged(PropertyDataChangedEventHandler value);
    public static bool op_Equality(DrawingAttributes first, DrawingAttributes second);
    public static bool op_Inequality(DrawingAttributes first, DrawingAttributes second);
    public void AddPropertyData(Guid propertyDataId, object propertyData);
    public void RemovePropertyData(Guid propertyDataId);
    public object GetPropertyData(Guid propertyDataId);
    public Guid[] GetPropertyDataIds();
    public bool ContainsPropertyData(Guid propertyDataId);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual DrawingAttributes Clone();
    protected virtual void OnAttributeChanged(PropertyDataChangedEventArgs e);
    protected virtual void OnPropertyDataChanged(PropertyDataChangedEventArgs e);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
}
public class System.Windows.Ink.DrawingAttributesReplacedEventArgs : EventArgs {
    public DrawingAttributes NewDrawingAttributes { get; }
    public DrawingAttributes PreviousDrawingAttributes { get; }
    public DrawingAttributesReplacedEventArgs(DrawingAttributes newDrawingAttributes, DrawingAttributes previousDrawingAttributes);
    public DrawingAttributes get_NewDrawingAttributes();
    public DrawingAttributes get_PreviousDrawingAttributes();
}
public class System.Windows.Ink.DrawingAttributesReplacedEventHandler : MulticastDelegate {
    public DrawingAttributesReplacedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DrawingAttributesReplacedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DrawingAttributesReplacedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Ink.EllipseStylusShape : StylusShape {
    public EllipseStylusShape(double width, double height);
    public EllipseStylusShape(double width, double height, double rotation);
}
public class System.Windows.Ink.GestureRecognitionResult : object {
    public RecognitionConfidence RecognitionConfidence { get; }
    public ApplicationGesture ApplicationGesture { get; }
    internal GestureRecognitionResult(RecognitionConfidence confidence, ApplicationGesture gesture);
    public RecognitionConfidence get_RecognitionConfidence();
    public ApplicationGesture get_ApplicationGesture();
}
public class System.Windows.Ink.GestureRecognizer : DependencyObject {
    public bool IsRecognizerAvailable { get; }
    public GestureRecognizer(IEnumerable`1<ApplicationGesture> enabledApplicationGestures);
    public bool get_IsRecognizerAvailable();
    public void SetEnabledGestures(IEnumerable`1<ApplicationGesture> applicationGestures);
    public ReadOnlyCollection`1<ApplicationGesture> GetEnabledGestures();
    [SecurityCriticalAttribute]
public ReadOnlyCollection`1<GestureRecognitionResult> Recognize(StrokeCollection strokes);
    public sealed virtual void Dispose();
}
public abstract class System.Windows.Ink.IncrementalHitTester : object {
    public bool IsValid { get; }
    internal IncrementalHitTester(StrokeCollection strokes);
    public bool get_IsValid();
    public void AddPoint(Point point);
    public void AddPoints(IEnumerable`1<Point> points);
    public void AddPoints(StylusPointCollection stylusPoints);
    public void EndHitTesting();
    protected abstract virtual void AddPointsCore(IEnumerable`1<Point> points);
}
public class System.Windows.Ink.IncrementalLassoHitTester : IncrementalHitTester {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private LassoSelectionChangedEventHandler SelectionChanged;
    internal IncrementalLassoHitTester(StrokeCollection strokes, int percentageWithinLasso);
    [CompilerGeneratedAttribute]
public void add_SelectionChanged(LassoSelectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectionChanged(LassoSelectionChangedEventHandler value);
    protected virtual void AddPointsCore(IEnumerable`1<Point> points);
    protected void OnSelectionChanged(LassoSelectionChangedEventArgs eventArgs);
}
public class System.Windows.Ink.IncrementalStrokeHitTester : IncrementalHitTester {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StrokeHitEventHandler StrokeHit;
    internal IncrementalStrokeHitTester(StrokeCollection strokes, StylusShape eraserShape);
    [CompilerGeneratedAttribute]
public void add_StrokeHit(StrokeHitEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StrokeHit(StrokeHitEventHandler value);
    protected virtual void AddPointsCore(IEnumerable`1<Point> points);
    protected void OnStrokeHit(StrokeHitEventArgs eventArgs);
}
public class System.Windows.Ink.LassoSelectionChangedEventArgs : EventArgs {
    public StrokeCollection SelectedStrokes { get; }
    public StrokeCollection DeselectedStrokes { get; }
    internal LassoSelectionChangedEventArgs(StrokeCollection selectedStrokes, StrokeCollection deselectedStrokes);
    public StrokeCollection get_SelectedStrokes();
    public StrokeCollection get_DeselectedStrokes();
}
public class System.Windows.Ink.LassoSelectionChangedEventHandler : MulticastDelegate {
    public LassoSelectionChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, LassoSelectionChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, LassoSelectionChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Ink.PropertyDataChangedEventArgs : EventArgs {
    public Guid PropertyGuid { get; }
    public object NewValue { get; }
    public object PreviousValue { get; }
    public PropertyDataChangedEventArgs(Guid propertyGuid, object newValue, object previousValue);
    public Guid get_PropertyGuid();
    public object get_NewValue();
    public object get_PreviousValue();
}
public class System.Windows.Ink.PropertyDataChangedEventHandler : MulticastDelegate {
    public PropertyDataChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PropertyDataChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PropertyDataChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Ink.RecognitionConfidence : Enum {
    public int value__;
    public static RecognitionConfidence Strong;
    public static RecognitionConfidence Intermediate;
    public static RecognitionConfidence Poor;
}
public class System.Windows.Ink.RectangleStylusShape : StylusShape {
    public RectangleStylusShape(double width, double height);
    public RectangleStylusShape(double width, double height, double rotation);
}
public class System.Windows.Ink.Stroke : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private PropertyDataChangedEventHandler DrawingAttributesChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DrawingAttributesReplacedEventHandler DrawingAttributesReplaced;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusPointsReplacedEventHandler StylusPointsReplaced;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler StylusPointsChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private PropertyDataChangedEventHandler PropertyDataChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler Invalidated;
    public DrawingAttributes DrawingAttributes { get; public set; }
    public StylusPointCollection StylusPoints { get; public set; }
    public Stroke(StylusPointCollection stylusPoints);
    public Stroke(StylusPointCollection stylusPoints, DrawingAttributes drawingAttributes);
    public DrawingAttributes get_DrawingAttributes();
    public void set_DrawingAttributes(DrawingAttributes value);
    public StylusPointCollection get_StylusPoints();
    public void set_StylusPoints(StylusPointCollection value);
    [CompilerGeneratedAttribute]
public void add_DrawingAttributesChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DrawingAttributesChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DrawingAttributesReplaced(DrawingAttributesReplacedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DrawingAttributesReplaced(DrawingAttributesReplacedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_StylusPointsReplaced(StylusPointsReplacedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StylusPointsReplaced(StylusPointsReplacedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_StylusPointsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StylusPointsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PropertyDataChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PropertyDataChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Invalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Invalidated(EventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    public virtual Stroke Clone();
    public virtual void Transform(Matrix transformMatrix, bool applyToStylusTip);
    public StylusPointCollection GetBezierStylusPoints();
    public void AddPropertyData(Guid propertyDataId, object propertyData);
    public void RemovePropertyData(Guid propertyDataId);
    public object GetPropertyData(Guid propertyDataId);
    public Guid[] GetPropertyDataIds();
    public bool ContainsPropertyData(Guid propertyDataId);
    protected virtual void OnDrawingAttributesChanged(PropertyDataChangedEventArgs e);
    protected virtual void OnDrawingAttributesReplaced(DrawingAttributesReplacedEventArgs e);
    protected virtual void OnStylusPointsReplaced(StylusPointsReplacedEventArgs e);
    protected virtual void OnStylusPointsChanged(EventArgs e);
    protected virtual void OnPropertyDataChanged(PropertyDataChangedEventArgs e);
    protected virtual void OnInvalidated(EventArgs e);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    public virtual Rect GetBounds();
    public void Draw(DrawingContext context);
    public void Draw(DrawingContext drawingContext, DrawingAttributes drawingAttributes);
    public StrokeCollection GetClipResult(Rect bounds);
    public StrokeCollection GetClipResult(IEnumerable`1<Point> lassoPoints);
    public StrokeCollection GetEraseResult(Rect bounds);
    public StrokeCollection GetEraseResult(IEnumerable`1<Point> lassoPoints);
    public StrokeCollection GetEraseResult(IEnumerable`1<Point> eraserPath, StylusShape eraserShape);
    public bool HitTest(Point point);
    public bool HitTest(Point point, double diameter);
    public bool HitTest(Rect bounds, int percentageWithinBounds);
    public bool HitTest(IEnumerable`1<Point> lassoPoints, int percentageWithinLasso);
    public bool HitTest(IEnumerable`1<Point> path, StylusShape stylusShape);
    protected virtual void DrawCore(DrawingContext drawingContext, DrawingAttributes drawingAttributes);
    public Geometry GetGeometry();
    public Geometry GetGeometry(DrawingAttributes drawingAttributes);
}
[TypeConverterAttribute("System.Windows.StrokeCollectionConverter")]
public class System.Windows.Ink.StrokeCollection : Collection`1<Stroke> {
    public static string InkSerializedFormat;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StrokeCollectionChangedEventHandler StrokesChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private PropertyDataChangedEventHandler PropertyDataChanged;
    public StrokeCollection(IEnumerable`1<Stroke> strokes);
    public StrokeCollection(Stream stream);
    [CompilerGeneratedAttribute]
public void add_StrokesChanged(StrokeCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StrokesChanged(StrokeCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PropertyDataChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PropertyDataChanged(PropertyDataChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public virtual void Save(Stream stream, bool compress);
    public void Save(Stream stream);
    public void AddPropertyData(Guid propertyDataId, object propertyData);
    public void RemovePropertyData(Guid propertyDataId);
    public object GetPropertyData(Guid propertyDataId);
    public Guid[] GetPropertyDataIds();
    public bool ContainsPropertyData(Guid propertyDataId);
    public void Transform(Matrix transformMatrix, bool applyToStylusTip);
    public virtual StrokeCollection Clone();
    protected sealed virtual void ClearItems();
    protected sealed virtual void RemoveItem(int index);
    protected sealed virtual void InsertItem(int index, Stroke stroke);
    protected sealed virtual void SetItem(int index, Stroke stroke);
    public int IndexOf(Stroke stroke);
    public void Remove(StrokeCollection strokes);
    public void Add(StrokeCollection strokes);
    public void Replace(Stroke strokeToReplace, StrokeCollection strokesToReplaceWith);
    public void Replace(StrokeCollection strokesToReplace, StrokeCollection strokesToReplaceWith);
    protected virtual void OnStrokesChanged(StrokeCollectionChangedEventArgs e);
    protected virtual void OnPropertyDataChanged(PropertyDataChangedEventArgs e);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    public Rect GetBounds();
    public StrokeCollection HitTest(Point point);
    public StrokeCollection HitTest(Point point, double diameter);
    public StrokeCollection HitTest(IEnumerable`1<Point> lassoPoints, int percentageWithinLasso);
    public StrokeCollection HitTest(Rect bounds, int percentageWithinBounds);
    public StrokeCollection HitTest(IEnumerable`1<Point> path, StylusShape stylusShape);
    public void Clip(IEnumerable`1<Point> lassoPoints);
    public void Clip(Rect bounds);
    public void Erase(IEnumerable`1<Point> lassoPoints);
    public void Erase(Rect bounds);
    public void Erase(IEnumerable`1<Point> eraserPath, StylusShape eraserShape);
    public void Draw(DrawingContext context);
    public IncrementalStrokeHitTester GetIncrementalStrokeHitTester(StylusShape eraserShape);
    public IncrementalLassoHitTester GetIncrementalLassoHitTester(int percentageWithinLasso);
}
public class System.Windows.Ink.StrokeCollectionChangedEventArgs : EventArgs {
    public StrokeCollection Added { get; }
    public StrokeCollection Removed { get; }
    public StrokeCollectionChangedEventArgs(StrokeCollection added, StrokeCollection removed);
    public StrokeCollection get_Added();
    public StrokeCollection get_Removed();
}
public class System.Windows.Ink.StrokeCollectionChangedEventHandler : MulticastDelegate {
    public StrokeCollectionChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StrokeCollectionChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StrokeCollectionChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Ink.StrokeHitEventArgs : EventArgs {
    public Stroke HitStroke { get; }
    public Stroke get_HitStroke();
    public StrokeCollection GetPointEraseResults();
}
public class System.Windows.Ink.StrokeHitEventHandler : MulticastDelegate {
    public StrokeHitEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StrokeHitEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StrokeHitEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Ink.StylusPointsReplacedEventArgs : EventArgs {
    public StylusPointCollection NewStylusPoints { get; }
    public StylusPointCollection PreviousStylusPoints { get; }
    public StylusPointsReplacedEventArgs(StylusPointCollection newStylusPoints, StylusPointCollection previousStylusPoints);
    public StylusPointCollection get_NewStylusPoints();
    public StylusPointCollection get_PreviousStylusPoints();
}
public class System.Windows.Ink.StylusPointsReplacedEventHandler : MulticastDelegate {
    public StylusPointsReplacedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusPointsReplacedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusPointsReplacedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.Ink.StylusShape : object {
    public double Width { get; }
    public double Height { get; }
    public double Rotation { get; }
    public double get_Width();
    public double get_Height();
    public double get_Rotation();
}
public enum System.Windows.Ink.StylusTip : Enum {
    public int value__;
    public static StylusTip Rectangle;
    public static StylusTip Ellipse;
}
public class System.Windows.Input.AccessKeyEventArgs : EventArgs {
    public string Key { get; }
    public bool IsMultiple { get; }
    [SecurityCriticalAttribute]
internal AccessKeyEventArgs(string key, bool isMultiple, bool userInitiated);
    public string get_Key();
    public bool get_IsMultiple();
}
public class System.Windows.Input.AccessKeyManager : object {
    public static RoutedEvent AccessKeyPressedEvent;
    public static void Register(string key, IInputElement element);
    public static void Unregister(string key, IInputElement element);
    public static bool IsKeyRegistered(object scope, string key);
    [SecurityCriticalAttribute]
public static bool ProcessKey(object scope, string key, bool isMultiple);
    public static void AddAccessKeyPressedHandler(DependencyObject element, AccessKeyPressedEventHandler handler);
    public static void RemoveAccessKeyPressedHandler(DependencyObject element, AccessKeyPressedEventHandler handler);
}
public class System.Windows.Input.AccessKeyPressedEventArgs : RoutedEventArgs {
    public object Scope { get; public set; }
    public UIElement Target { get; public set; }
    public string Key { get; }
    public AccessKeyPressedEventArgs(string key);
    public object get_Scope();
    public void set_Scope(object value);
    public UIElement get_Target();
    public void set_Target(UIElement value);
    public string get_Key();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.AccessKeyPressedEventHandler : MulticastDelegate {
    public AccessKeyPressedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AccessKeyPressedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AccessKeyPressedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Windows.Input.ApplicationCommands : object {
    public static RoutedUICommand Cut { get; }
    public static RoutedUICommand Copy { get; }
    public static RoutedUICommand Paste { get; }
    public static RoutedUICommand Delete { get; }
    public static RoutedUICommand Undo { get; }
    public static RoutedUICommand Redo { get; }
    public static RoutedUICommand Find { get; }
    public static RoutedUICommand Replace { get; }
    public static RoutedUICommand SelectAll { get; }
    public static RoutedUICommand Help { get; }
    public static RoutedUICommand New { get; }
    public static RoutedUICommand Open { get; }
    public static RoutedUICommand Close { get; }
    public static RoutedUICommand Save { get; }
    public static RoutedUICommand SaveAs { get; }
    public static RoutedUICommand Print { get; }
    public static RoutedUICommand CancelPrint { get; }
    public static RoutedUICommand PrintPreview { get; }
    public static RoutedUICommand Properties { get; }
    public static RoutedUICommand ContextMenu { get; }
    public static RoutedUICommand Stop { get; }
    public static RoutedUICommand CorrectionList { get; }
    public static RoutedUICommand NotACommand { get; }
    public static RoutedUICommand get_Cut();
    public static RoutedUICommand get_Copy();
    public static RoutedUICommand get_Paste();
    public static RoutedUICommand get_Delete();
    public static RoutedUICommand get_Undo();
    public static RoutedUICommand get_Redo();
    public static RoutedUICommand get_Find();
    public static RoutedUICommand get_Replace();
    public static RoutedUICommand get_SelectAll();
    public static RoutedUICommand get_Help();
    public static RoutedUICommand get_New();
    public static RoutedUICommand get_Open();
    public static RoutedUICommand get_Close();
    public static RoutedUICommand get_Save();
    public static RoutedUICommand get_SaveAs();
    public static RoutedUICommand get_Print();
    public static RoutedUICommand get_CancelPrint();
    public static RoutedUICommand get_PrintPreview();
    public static RoutedUICommand get_Properties();
    public static RoutedUICommand get_ContextMenu();
    public static RoutedUICommand get_Stop();
    public static RoutedUICommand get_CorrectionList();
    public static RoutedUICommand get_NotACommand();
}
public class System.Windows.Input.CanExecuteChangedEventManager : WeakEventManager {
    public static void AddHandler(ICommand source, EventHandler`1<EventArgs> handler);
    public static void RemoveHandler(ICommand source, EventHandler`1<EventArgs> handler);
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    protected virtual bool Purge(object source, object data, bool purgeAll);
}
public class System.Windows.Input.CanExecuteRoutedEventArgs : RoutedEventArgs {
    public ICommand Command { get; }
    public object Parameter { get; }
    public bool CanExecute { get; public set; }
    public bool ContinueRouting { get; public set; }
    internal CanExecuteRoutedEventArgs(ICommand command, object parameter);
    public ICommand get_Command();
    public object get_Parameter();
    public bool get_CanExecute();
    public void set_CanExecute(bool value);
    public bool get_ContinueRouting();
    public void set_ContinueRouting(bool value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object target);
}
public class System.Windows.Input.CanExecuteRoutedEventHandler : MulticastDelegate {
    public CanExecuteRoutedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CanExecuteRoutedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CanExecuteRoutedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Input.CaptureMode : Enum {
    public int value__;
    public static CaptureMode None;
    public static CaptureMode Element;
    public static CaptureMode SubTree;
}
public class System.Windows.Input.CommandBinding : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ExecutedRoutedEventHandler PreviewExecuted;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ExecutedRoutedEventHandler Executed;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private CanExecuteRoutedEventHandler PreviewCanExecute;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private CanExecuteRoutedEventHandler CanExecute;
    [LocalizabilityAttribute("17")]
public ICommand Command { get; public set; }
    public CommandBinding(ICommand command);
    public CommandBinding(ICommand command, ExecutedRoutedEventHandler executed);
    public CommandBinding(ICommand command, ExecutedRoutedEventHandler executed, CanExecuteRoutedEventHandler canExecute);
    public ICommand get_Command();
    public void set_Command(ICommand value);
    [CompilerGeneratedAttribute]
public void add_PreviewExecuted(ExecutedRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewExecuted(ExecutedRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Executed(ExecutedRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Executed(ExecutedRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewCanExecute(CanExecuteRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewCanExecute(CanExecuteRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_CanExecute(CanExecuteRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CanExecute(CanExecuteRoutedEventHandler value);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Input.CommandBindingCollection : object {
    private object System.Collections.IList.Item { get; private set; }
    public CommandBinding Item { get; public set; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    public CommandBindingCollection(IList commandBindings);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public CommandBinding get_Item(int index);
    public void set_Item(int index, CommandBinding value);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.Contains(object key);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object commandBinding);
    private sealed virtual override void System.Collections.IList.Remove(object commandBinding);
    public int Add(CommandBinding commandBinding);
    public void AddRange(ICollection collection);
    public void Insert(int index, CommandBinding commandBinding);
    public void Remove(CommandBinding commandBinding);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Clear();
    public int IndexOf(CommandBinding value);
    public bool Contains(CommandBinding commandBinding);
    public void CopyTo(CommandBinding[] commandBindings, int index);
    public sealed virtual IEnumerator GetEnumerator();
}
public class System.Windows.Input.CommandManager : object {
    public static RoutedEvent PreviewExecutedEvent;
    public static RoutedEvent ExecutedEvent;
    public static RoutedEvent PreviewCanExecuteEvent;
    public static RoutedEvent CanExecuteEvent;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static EventHandler RequerySuggested;
    [CompilerGeneratedAttribute]
public static void add_RequerySuggested(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_RequerySuggested(EventHandler value);
    public static void AddPreviewExecutedHandler(UIElement element, ExecutedRoutedEventHandler handler);
    public static void RemovePreviewExecutedHandler(UIElement element, ExecutedRoutedEventHandler handler);
    public static void AddExecutedHandler(UIElement element, ExecutedRoutedEventHandler handler);
    public static void RemoveExecutedHandler(UIElement element, ExecutedRoutedEventHandler handler);
    public static void AddPreviewCanExecuteHandler(UIElement element, CanExecuteRoutedEventHandler handler);
    public static void RemovePreviewCanExecuteHandler(UIElement element, CanExecuteRoutedEventHandler handler);
    public static void AddCanExecuteHandler(UIElement element, CanExecuteRoutedEventHandler handler);
    public static void RemoveCanExecuteHandler(UIElement element, CanExecuteRoutedEventHandler handler);
    public static void RegisterClassInputBinding(Type type, InputBinding inputBinding);
    public static void RegisterClassCommandBinding(Type type, CommandBinding commandBinding);
    public static void InvalidateRequerySuggested();
}
public static class System.Windows.Input.ComponentCommands : object {
    public static RoutedUICommand ScrollPageUp { get; }
    public static RoutedUICommand ScrollPageDown { get; }
    public static RoutedUICommand ScrollPageLeft { get; }
    public static RoutedUICommand ScrollPageRight { get; }
    public static RoutedUICommand ScrollByLine { get; }
    public static RoutedUICommand MoveLeft { get; }
    public static RoutedUICommand MoveRight { get; }
    public static RoutedUICommand MoveUp { get; }
    public static RoutedUICommand MoveDown { get; }
    public static RoutedUICommand MoveToHome { get; }
    public static RoutedUICommand MoveToEnd { get; }
    public static RoutedUICommand MoveToPageUp { get; }
    public static RoutedUICommand MoveToPageDown { get; }
    public static RoutedUICommand ExtendSelectionUp { get; }
    public static RoutedUICommand ExtendSelectionDown { get; }
    public static RoutedUICommand ExtendSelectionLeft { get; }
    public static RoutedUICommand ExtendSelectionRight { get; }
    public static RoutedUICommand SelectToHome { get; }
    public static RoutedUICommand SelectToEnd { get; }
    public static RoutedUICommand SelectToPageUp { get; }
    public static RoutedUICommand SelectToPageDown { get; }
    public static RoutedUICommand MoveFocusUp { get; }
    public static RoutedUICommand MoveFocusDown { get; }
    public static RoutedUICommand MoveFocusForward { get; }
    public static RoutedUICommand MoveFocusBack { get; }
    public static RoutedUICommand MoveFocusPageUp { get; }
    public static RoutedUICommand MoveFocusPageDown { get; }
    public static RoutedUICommand get_ScrollPageUp();
    public static RoutedUICommand get_ScrollPageDown();
    public static RoutedUICommand get_ScrollPageLeft();
    public static RoutedUICommand get_ScrollPageRight();
    public static RoutedUICommand get_ScrollByLine();
    public static RoutedUICommand get_MoveLeft();
    public static RoutedUICommand get_MoveRight();
    public static RoutedUICommand get_MoveUp();
    public static RoutedUICommand get_MoveDown();
    public static RoutedUICommand get_MoveToHome();
    public static RoutedUICommand get_MoveToEnd();
    public static RoutedUICommand get_MoveToPageUp();
    public static RoutedUICommand get_MoveToPageDown();
    public static RoutedUICommand get_ExtendSelectionUp();
    public static RoutedUICommand get_ExtendSelectionDown();
    public static RoutedUICommand get_ExtendSelectionLeft();
    public static RoutedUICommand get_ExtendSelectionRight();
    public static RoutedUICommand get_SelectToHome();
    public static RoutedUICommand get_SelectToEnd();
    public static RoutedUICommand get_SelectToPageUp();
    public static RoutedUICommand get_SelectToPageDown();
    public static RoutedUICommand get_MoveFocusUp();
    public static RoutedUICommand get_MoveFocusDown();
    public static RoutedUICommand get_MoveFocusForward();
    public static RoutedUICommand get_MoveFocusBack();
    public static RoutedUICommand get_MoveFocusPageUp();
    public static RoutedUICommand get_MoveFocusPageDown();
}
[LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.Input.CursorConverter")]
public class System.Windows.Input.Cursor : object {
    public Cursor(string cursorFile);
    public Cursor(Stream cursorStream);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public virtual string ToString();
}
public class System.Windows.Input.CursorConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.Input.Cursors : object {
    public static Cursor None { get; }
    public static Cursor No { get; }
    public static Cursor Arrow { get; }
    public static Cursor AppStarting { get; }
    public static Cursor Cross { get; }
    public static Cursor Help { get; }
    public static Cursor IBeam { get; }
    public static Cursor SizeAll { get; }
    public static Cursor SizeNESW { get; }
    public static Cursor SizeNS { get; }
    public static Cursor SizeNWSE { get; }
    public static Cursor SizeWE { get; }
    public static Cursor UpArrow { get; }
    public static Cursor Wait { get; }
    public static Cursor Hand { get; }
    public static Cursor Pen { get; }
    public static Cursor ScrollNS { get; }
    public static Cursor ScrollWE { get; }
    public static Cursor ScrollAll { get; }
    public static Cursor ScrollN { get; }
    public static Cursor ScrollS { get; }
    public static Cursor ScrollW { get; }
    public static Cursor ScrollE { get; }
    public static Cursor ScrollNW { get; }
    public static Cursor ScrollNE { get; }
    public static Cursor ScrollSW { get; }
    public static Cursor ScrollSE { get; }
    public static Cursor ArrowCD { get; }
    public static Cursor get_None();
    public static Cursor get_No();
    public static Cursor get_Arrow();
    public static Cursor get_AppStarting();
    public static Cursor get_Cross();
    public static Cursor get_Help();
    public static Cursor get_IBeam();
    public static Cursor get_SizeAll();
    public static Cursor get_SizeNESW();
    public static Cursor get_SizeNS();
    public static Cursor get_SizeNWSE();
    public static Cursor get_SizeWE();
    public static Cursor get_UpArrow();
    public static Cursor get_Wait();
    public static Cursor get_Hand();
    public static Cursor get_Pen();
    public static Cursor get_ScrollNS();
    public static Cursor get_ScrollWE();
    public static Cursor get_ScrollAll();
    public static Cursor get_ScrollN();
    public static Cursor get_ScrollS();
    public static Cursor get_ScrollW();
    public static Cursor get_ScrollE();
    public static Cursor get_ScrollNW();
    public static Cursor get_ScrollNE();
    public static Cursor get_ScrollSW();
    public static Cursor get_ScrollSE();
    public static Cursor get_ArrowCD();
}
public enum System.Windows.Input.CursorType : Enum {
    public int value__;
    public static CursorType None;
    public static CursorType No;
    public static CursorType Arrow;
    public static CursorType AppStarting;
    public static CursorType Cross;
    public static CursorType Help;
    public static CursorType IBeam;
    public static CursorType SizeAll;
    public static CursorType SizeNESW;
    public static CursorType SizeNS;
    public static CursorType SizeNWSE;
    public static CursorType SizeWE;
    public static CursorType UpArrow;
    public static CursorType Wait;
    public static CursorType Hand;
    public static CursorType Pen;
    public static CursorType ScrollNS;
    public static CursorType ScrollWE;
    public static CursorType ScrollAll;
    public static CursorType ScrollN;
    public static CursorType ScrollS;
    public static CursorType ScrollW;
    public static CursorType ScrollE;
    public static CursorType ScrollNW;
    public static CursorType ScrollNE;
    public static CursorType ScrollSW;
    public static CursorType ScrollSE;
    public static CursorType ArrowCD;
}
public class System.Windows.Input.ExecutedRoutedEventArgs : RoutedEventArgs {
    public ICommand Command { get; }
    public object Parameter { get; }
    internal ExecutedRoutedEventArgs(ICommand command, object parameter);
    public ICommand get_Command();
    public object get_Parameter();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object target);
}
public class System.Windows.Input.ExecutedRoutedEventHandler : MulticastDelegate {
    public ExecutedRoutedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ExecutedRoutedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ExecutedRoutedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Windows.Input.FocusManager : object {
    public static RoutedEvent GotFocusEvent;
    public static RoutedEvent LostFocusEvent;
    public static DependencyProperty FocusedElementProperty;
    public static DependencyProperty IsFocusScopeProperty;
    public static void AddGotFocusHandler(DependencyObject element, RoutedEventHandler handler);
    public static void RemoveGotFocusHandler(DependencyObject element, RoutedEventHandler handler);
    public static void AddLostFocusHandler(DependencyObject element, RoutedEventHandler handler);
    public static void RemoveLostFocusHandler(DependencyObject element, RoutedEventHandler handler);
    [DesignerSerializationVisibilityAttribute("0")]
public static IInputElement GetFocusedElement(DependencyObject element);
    public static void SetFocusedElement(DependencyObject element, IInputElement value);
    public static void SetIsFocusScope(DependencyObject element, bool value);
    public static bool GetIsFocusScope(DependencyObject element);
    public static DependencyObject GetFocusScope(DependencyObject element);
}
public interface System.Windows.Input.ICommandSource {
    public ICommand Command { get; }
    public object CommandParameter { get; }
    public IInputElement CommandTarget { get; }
    public abstract virtual ICommand get_Command();
    public abstract virtual object get_CommandParameter();
    public abstract virtual IInputElement get_CommandTarget();
}
public interface System.Windows.Input.IInputLanguageSource {
    public CultureInfo CurrentInputLanguage { get; public set; }
    public IEnumerable InputLanguageList { get; }
    public abstract virtual CultureInfo get_CurrentInputLanguage();
    public abstract virtual void set_CurrentInputLanguage(CultureInfo value);
    public abstract virtual IEnumerable get_InputLanguageList();
    public abstract virtual void Initialize();
    public abstract virtual void Uninitialize();
}
public interface System.Windows.Input.IManipulator {
    public int Id { get; }
    public abstract virtual int get_Id();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Updated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Updated(EventHandler value);
    public abstract virtual Point GetPosition(IInputElement relativeTo);
    [SecurityCriticalAttribute]
public abstract virtual void ManipulationEnded(bool cancel);
}
[FlagsAttribute]
public enum System.Windows.Input.ImeConversionModeValues : Enum {
    public int value__;
    public static ImeConversionModeValues Native;
    public static ImeConversionModeValues Katakana;
    public static ImeConversionModeValues FullShape;
    public static ImeConversionModeValues Roman;
    public static ImeConversionModeValues CharCode;
    public static ImeConversionModeValues NoConversion;
    public static ImeConversionModeValues Eudc;
    public static ImeConversionModeValues Symbol;
    public static ImeConversionModeValues Fixed;
    public static ImeConversionModeValues Alphanumeric;
    public static ImeConversionModeValues DoNotCare;
}
[FlagsAttribute]
public enum System.Windows.Input.ImeSentenceModeValues : Enum {
    public int value__;
    public static ImeSentenceModeValues None;
    public static ImeSentenceModeValues PluralClause;
    public static ImeSentenceModeValues SingleConversion;
    public static ImeSentenceModeValues Automatic;
    public static ImeSentenceModeValues PhrasePrediction;
    public static ImeSentenceModeValues Conversation;
    public static ImeSentenceModeValues DoNotCare;
}
public class System.Windows.Input.InertiaExpansionBehavior : object {
    public Vector InitialVelocity { get; public set; }
    public double DesiredDeceleration { get; public set; }
    public Vector DesiredExpansion { get; public set; }
    public double InitialRadius { get; public set; }
    public Vector get_InitialVelocity();
    public void set_InitialVelocity(Vector value);
    public double get_DesiredDeceleration();
    public void set_DesiredDeceleration(double value);
    public Vector get_DesiredExpansion();
    public void set_DesiredExpansion(Vector value);
    public double get_InitialRadius();
    public void set_InitialRadius(double value);
}
public class System.Windows.Input.InertiaRotationBehavior : object {
    public double InitialVelocity { get; public set; }
    public double DesiredDeceleration { get; public set; }
    public double DesiredRotation { get; public set; }
    public double get_InitialVelocity();
    public void set_InitialVelocity(double value);
    public double get_DesiredDeceleration();
    public void set_DesiredDeceleration(double value);
    public double get_DesiredRotation();
    public void set_DesiredRotation(double value);
}
public class System.Windows.Input.InertiaTranslationBehavior : object {
    public Vector InitialVelocity { get; public set; }
    public double DesiredDeceleration { get; public set; }
    public double DesiredDisplacement { get; public set; }
    public Vector get_InitialVelocity();
    public void set_InitialVelocity(Vector value);
    public double get_DesiredDeceleration();
    public void set_DesiredDeceleration(double value);
    public double get_DesiredDisplacement();
    public void set_DesiredDisplacement(double value);
}
public class System.Windows.Input.InputBinding : Freezable {
    public static DependencyProperty CommandProperty;
    public static DependencyProperty CommandParameterProperty;
    public static DependencyProperty CommandTargetProperty;
    [TypeConverterAttribute("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[LocalizabilityAttribute("17")]
public ICommand Command { get; public set; }
    public object CommandParameter { get; public set; }
    public IInputElement CommandTarget { get; public set; }
    public InputGesture Gesture { get; public set; }
    [SecurityCriticalAttribute]
public InputBinding(ICommand command, InputGesture gesture);
    public sealed virtual ICommand get_Command();
    public void set_Command(ICommand value);
    public sealed virtual object get_CommandParameter();
    public void set_CommandParameter(object value);
    public sealed virtual IInputElement get_CommandTarget();
    public void set_CommandTarget(IInputElement value);
    public virtual InputGesture get_Gesture();
    [SecurityCriticalAttribute]
public virtual void set_Gesture(InputGesture value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Input.InputBindingCollection : object {
    private object System.Collections.IList.Item { get; private set; }
    public InputBinding Item { get; public set; }
    public bool IsSynchronized { get; }
    public bool IsFixedSize { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsReadOnly { get; }
    public InputBindingCollection(IList inputBindings);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public InputBinding get_Item(int index);
    public void set_Item(int index, InputBinding value);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.Contains(object key);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object inputBinding);
    private sealed virtual override void System.Collections.IList.Remove(object inputBinding);
    public int Add(InputBinding inputBinding);
    public int IndexOf(InputBinding value);
    public void AddRange(ICollection collection);
    public void Insert(int index, InputBinding inputBinding);
    public void Remove(InputBinding inputBinding);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Clear();
    public sealed virtual IEnumerator GetEnumerator();
    public bool Contains(InputBinding key);
    public void CopyTo(InputBinding[] inputBindings, int index);
}
public abstract class System.Windows.Input.InputDevice : DispatcherObject {
    public IInputElement Target { get; }
    public PresentationSource ActiveSource { get; }
    public abstract virtual IInputElement get_Target();
    public abstract virtual PresentationSource get_ActiveSource();
}
public class System.Windows.Input.InputEventArgs : RoutedEventArgs {
    public InputDevice Device { get; internal set; }
    public int Timestamp { get; }
    public InputEventArgs(InputDevice inputDevice, int timestamp);
    public InputDevice get_Device();
    internal void set_Device(InputDevice value);
    public int get_Timestamp();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.InputEventHandler : MulticastDelegate {
    public InputEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InputEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InputEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.Input.InputGesture : object {
    public abstract virtual bool Matches(object targetElement, InputEventArgs inputEventArgs);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Input.InputGestureCollection : object {
    private object System.Collections.IList.Item { get; private set; }
    public InputGesture Item { get; public set; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    public InputGestureCollection(IList inputGestures);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public InputGesture get_Item(int index);
    public void set_Item(int index, InputGesture value);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.Contains(object key);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object inputGesture);
    private sealed virtual override void System.Collections.IList.Remove(object inputGesture);
    public sealed virtual IEnumerator GetEnumerator();
    public int IndexOf(InputGesture value);
    public sealed virtual void RemoveAt(int index);
    public int Add(InputGesture inputGesture);
    public void AddRange(ICollection collection);
    public void Insert(int index, InputGesture inputGesture);
    public void Remove(InputGesture inputGesture);
    public sealed virtual void Clear();
    public bool Contains(InputGesture key);
    public void CopyTo(InputGesture[] inputGestures, int index);
    public void Seal();
}
public class System.Windows.Input.InputLanguageChangedEventArgs : InputLanguageEventArgs {
    public InputLanguageChangedEventArgs(CultureInfo newLanguageId, CultureInfo previousLanguageId);
}
public class System.Windows.Input.InputLanguageChangingEventArgs : InputLanguageEventArgs {
    public bool Rejected { get; public set; }
    public InputLanguageChangingEventArgs(CultureInfo newLanguageId, CultureInfo previousLanguageId);
    public bool get_Rejected();
    public void set_Rejected(bool value);
}
public abstract class System.Windows.Input.InputLanguageEventArgs : EventArgs {
    public CultureInfo NewLanguage { get; }
    public CultureInfo PreviousLanguage { get; }
    protected InputLanguageEventArgs(CultureInfo newLanguageId, CultureInfo previousLanguageId);
    public virtual CultureInfo get_NewLanguage();
    public virtual CultureInfo get_PreviousLanguage();
}
public class System.Windows.Input.InputLanguageEventHandler : MulticastDelegate {
    public InputLanguageEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InputLanguageEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InputLanguageEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.InputLanguageManager : DispatcherObject {
    public static DependencyProperty InputLanguageProperty;
    public static DependencyProperty RestoreInputLanguageProperty;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private InputLanguageEventHandler InputLanguageChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private InputLanguageEventHandler InputLanguageChanging;
    public static InputLanguageManager Current { get; }
    [TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
public CultureInfo CurrentInputLanguage { get; public set; }
    public IEnumerable AvailableInputLanguages { get; }
    public static InputLanguageManager get_Current();
    public CultureInfo get_CurrentInputLanguage();
    public void set_CurrentInputLanguage(CultureInfo value);
    public IEnumerable get_AvailableInputLanguages();
    [CompilerGeneratedAttribute]
public void add_InputLanguageChanged(InputLanguageEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_InputLanguageChanged(InputLanguageEventHandler value);
    [CompilerGeneratedAttribute]
public void add_InputLanguageChanging(InputLanguageEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_InputLanguageChanging(InputLanguageEventHandler value);
    public static void SetInputLanguage(DependencyObject target, CultureInfo inputLanguage);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
[TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
public static CultureInfo GetInputLanguage(DependencyObject target);
    public static void SetRestoreInputLanguage(DependencyObject target, bool restore);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetRestoreInputLanguage(DependencyObject target);
    public void RegisterInputLanguageSource(IInputLanguageSource inputLanguageSource);
    public void ReportInputLanguageChanged(CultureInfo newLanguageId, CultureInfo previousLanguageId);
    public bool ReportInputLanguageChanging(CultureInfo newLanguageId, CultureInfo previousLanguageId);
}
public class System.Windows.Input.InputManager : DispatcherObject {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private PreProcessInputEventHandler PreProcessInput;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private NotifyInputEventHandler PreNotifyInput;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private NotifyInputEventHandler PostNotifyInput;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ProcessInputEventHandler PostProcessInput;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler EnterMenuMode;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler LeaveMenuMode;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler HitTestInvalidatedAsync;
    public static InputManager Current { get; }
    public ICollection InputProviders { get; }
    public KeyboardDevice PrimaryKeyboardDevice { get; }
    public MouseDevice PrimaryMouseDevice { get; }
    public InputDevice MostRecentInputDevice { get; internal set; }
    public bool IsInMenuMode { get; }
    [SecurityCriticalAttribute]
public static InputManager get_Current();
    [SecurityCriticalAttribute]
public ICollection get_InputProviders();
    public KeyboardDevice get_PrimaryKeyboardDevice();
    public MouseDevice get_PrimaryMouseDevice();
    public InputDevice get_MostRecentInputDevice();
    internal void set_MostRecentInputDevice(InputDevice value);
    public bool get_IsInMenuMode();
    [CompilerGeneratedAttribute]
public void add_PreProcessInput(PreProcessInputEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreProcessInput(PreProcessInputEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreNotifyInput(NotifyInputEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreNotifyInput(NotifyInputEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PostNotifyInput(NotifyInputEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PostNotifyInput(NotifyInputEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PostProcessInput(ProcessInputEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PostProcessInput(ProcessInputEventHandler value);
    [CompilerGeneratedAttribute]
public void add_EnterMenuMode(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EnterMenuMode(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_LeaveMenuMode(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LeaveMenuMode(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_HitTestInvalidatedAsync(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_HitTestInvalidatedAsync(EventHandler value);
    public void PushMenuMode(PresentationSource menuSite);
    public void PopMenuMode(PresentationSource menuSite);
    [SecurityCriticalAttribute]
public bool ProcessInput(InputEventArgs input);
}
public class System.Windows.Input.InputMethod : DispatcherObject {
    public static DependencyProperty IsInputMethodEnabledProperty;
    public static DependencyProperty IsInputMethodSuspendedProperty;
    public static DependencyProperty PreferredImeStateProperty;
    public static DependencyProperty PreferredImeConversionModeProperty;
    public static DependencyProperty PreferredImeSentenceModeProperty;
    public static DependencyProperty InputScopeProperty;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private InputMethodStateChangedEventHandler StateChanged;
    public static InputMethod Current { get; }
    public InputMethodState ImeState { get; public set; }
    public InputMethodState MicrophoneState { get; public set; }
    public InputMethodState HandwritingState { get; public set; }
    public SpeechMode SpeechMode { get; public set; }
    public ImeConversionModeValues ImeConversionMode { get; public set; }
    public ImeSentenceModeValues ImeSentenceMode { get; public set; }
    public bool CanShowConfigurationUI { get; }
    public bool CanShowRegisterWordUI { get; }
    public static InputMethod get_Current();
    [SecurityCriticalAttribute]
public InputMethodState get_ImeState();
    [SecurityCriticalAttribute]
public void set_ImeState(InputMethodState value);
    [SecurityCriticalAttribute]
public InputMethodState get_MicrophoneState();
    [SecurityCriticalAttribute]
public void set_MicrophoneState(InputMethodState value);
    [SecurityCriticalAttribute]
public InputMethodState get_HandwritingState();
    [SecurityCriticalAttribute]
public void set_HandwritingState(InputMethodState value);
    [SecurityCriticalAttribute]
public SpeechMode get_SpeechMode();
    [SecurityCriticalAttribute]
public void set_SpeechMode(SpeechMode value);
    [SecurityCriticalAttribute]
public ImeConversionModeValues get_ImeConversionMode();
    [SecurityCriticalAttribute]
public void set_ImeConversionMode(ImeConversionModeValues value);
    [SecurityCriticalAttribute]
public ImeSentenceModeValues get_ImeSentenceMode();
    [SecurityCriticalAttribute]
public void set_ImeSentenceMode(ImeSentenceModeValues value);
    public bool get_CanShowConfigurationUI();
    public bool get_CanShowRegisterWordUI();
    [CompilerGeneratedAttribute]
public void add_StateChanged(InputMethodStateChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StateChanged(InputMethodStateChangedEventHandler value);
    public static void SetIsInputMethodEnabled(DependencyObject target, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsInputMethodEnabled(DependencyObject target);
    public static void SetIsInputMethodSuspended(DependencyObject target, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsInputMethodSuspended(DependencyObject target);
    public static void SetPreferredImeState(DependencyObject target, InputMethodState value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static InputMethodState GetPreferredImeState(DependencyObject target);
    public static void SetPreferredImeConversionMode(DependencyObject target, ImeConversionModeValues value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static ImeConversionModeValues GetPreferredImeConversionMode(DependencyObject target);
    public static void SetPreferredImeSentenceMode(DependencyObject target, ImeSentenceModeValues value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static ImeSentenceModeValues GetPreferredImeSentenceMode(DependencyObject target);
    public static void SetInputScope(DependencyObject target, InputScope value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static InputScope GetInputScope(DependencyObject target);
    public void ShowConfigureUI();
    public void ShowConfigureUI(UIElement element);
    public void ShowRegisterWordUI();
    public void ShowRegisterWordUI(string registeredText);
    public void ShowRegisterWordUI(UIElement element, string registeredText);
}
public enum System.Windows.Input.InputMethodState : Enum {
    public int value__;
    public static InputMethodState Off;
    public static InputMethodState On;
    public static InputMethodState DoNotCare;
}
public class System.Windows.Input.InputMethodStateChangedEventArgs : EventArgs {
    public bool IsImeStateChanged { get; }
    public bool IsMicrophoneStateChanged { get; }
    public bool IsHandwritingStateChanged { get; }
    public bool IsSpeechModeChanged { get; }
    public bool IsImeConversionModeChanged { get; }
    public bool IsImeSentenceModeChanged { get; }
    public bool get_IsImeStateChanged();
    public bool get_IsMicrophoneStateChanged();
    public bool get_IsHandwritingStateChanged();
    public bool get_IsSpeechModeChanged();
    public bool get_IsImeConversionModeChanged();
    public bool get_IsImeSentenceModeChanged();
}
public class System.Windows.Input.InputMethodStateChangedEventHandler : MulticastDelegate {
    public InputMethodStateChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InputMethodStateChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InputMethodStateChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Input.InputMode : Enum {
    public int value__;
    public static InputMode Foreground;
    public static InputMode Sink;
}
[TypeConverterAttribute("System.Windows.Input.InputScopeConverter, PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.Input.InputScope : object {
    [DesignerSerializationVisibilityAttribute("2")]
public IList Names { get; }
    [DefaultValueAttribute("")]
public string SrgsMarkup { get; public set; }
    [DefaultValueAttribute("")]
public string RegularExpression { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public IList PhraseList { get; }
    public IList get_Names();
    public string get_SrgsMarkup();
    public void set_SrgsMarkup(string value);
    public string get_RegularExpression();
    public void set_RegularExpression(string value);
    public IList get_PhraseList();
}
public class System.Windows.Input.InputScopeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ContentPropertyAttribute("NameValue")]
[TypeConverterAttribute("System.Windows.Input.InputScopeNameConverter, PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.Input.InputScopeName : object {
    public InputScopeNameValue NameValue { get; public set; }
    public InputScopeName(InputScopeNameValue nameValue);
    public InputScopeNameValue get_NameValue();
    public void set_NameValue(InputScopeNameValue value);
    public sealed virtual void AddChild(object value);
    public sealed virtual void AddText(string name);
}
public class System.Windows.Input.InputScopeNameConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.Input.InputScopeNameValue : Enum {
    public int value__;
    public static InputScopeNameValue Xml;
    public static InputScopeNameValue Srgs;
    public static InputScopeNameValue RegularExpression;
    public static InputScopeNameValue PhraseList;
    public static InputScopeNameValue Default;
    public static InputScopeNameValue Url;
    public static InputScopeNameValue FullFilePath;
    public static InputScopeNameValue FileName;
    public static InputScopeNameValue EmailUserName;
    public static InputScopeNameValue EmailSmtpAddress;
    public static InputScopeNameValue LogOnName;
    public static InputScopeNameValue PersonalFullName;
    public static InputScopeNameValue PersonalNamePrefix;
    public static InputScopeNameValue PersonalGivenName;
    public static InputScopeNameValue PersonalMiddleName;
    public static InputScopeNameValue PersonalSurname;
    public static InputScopeNameValue PersonalNameSuffix;
    public static InputScopeNameValue PostalAddress;
    public static InputScopeNameValue PostalCode;
    public static InputScopeNameValue AddressStreet;
    public static InputScopeNameValue AddressStateOrProvince;
    public static InputScopeNameValue AddressCity;
    public static InputScopeNameValue AddressCountryName;
    public static InputScopeNameValue AddressCountryShortName;
    public static InputScopeNameValue CurrencyAmountAndSymbol;
    public static InputScopeNameValue CurrencyAmount;
    public static InputScopeNameValue Date;
    public static InputScopeNameValue DateMonth;
    public static InputScopeNameValue DateDay;
    public static InputScopeNameValue DateYear;
    public static InputScopeNameValue DateMonthName;
    public static InputScopeNameValue DateDayName;
    public static InputScopeNameValue Digits;
    public static InputScopeNameValue Number;
    public static InputScopeNameValue OneChar;
    public static InputScopeNameValue Password;
    public static InputScopeNameValue TelephoneNumber;
    public static InputScopeNameValue TelephoneCountryCode;
    public static InputScopeNameValue TelephoneAreaCode;
    public static InputScopeNameValue TelephoneLocalNumber;
    public static InputScopeNameValue Time;
    public static InputScopeNameValue TimeHour;
    public static InputScopeNameValue TimeMinorSec;
    public static InputScopeNameValue NumberFullWidth;
    public static InputScopeNameValue AlphanumericHalfWidth;
    public static InputScopeNameValue AlphanumericFullWidth;
    public static InputScopeNameValue CurrencyChinese;
    public static InputScopeNameValue Bopomofo;
    public static InputScopeNameValue Hiragana;
    public static InputScopeNameValue KatakanaHalfWidth;
    public static InputScopeNameValue KatakanaFullWidth;
    public static InputScopeNameValue Hanja;
}
[ContentPropertyAttribute("Name")]
public class System.Windows.Input.InputScopePhrase : object {
    public string Name { get; public set; }
    public InputScopePhrase(string name);
    public string get_Name();
    public void set_Name(string value);
    public sealed virtual void AddChild(object value);
    public sealed virtual void AddText(string name);
}
public enum System.Windows.Input.InputType : Enum {
    public int value__;
    public static InputType Keyboard;
    public static InputType Mouse;
    public static InputType Stylus;
    public static InputType Hid;
    public static InputType Text;
    public static InputType Command;
}
public class System.Windows.Input.KeyBinding : InputBinding {
    public static DependencyProperty ModifiersProperty;
    public static DependencyProperty KeyProperty;
    [TypeConverterAttribute("System.Windows.Input.KeyGestureConverter")]
[ValueSerializerAttribute("System.Windows.Input.KeyGestureValueSerializer")]
public InputGesture Gesture { get; public set; }
    public ModifierKeys Modifiers { get; public set; }
    public Key Key { get; public set; }
    public KeyBinding(ICommand command, KeyGesture gesture);
    public KeyBinding(ICommand command, Key key, ModifierKeys modifiers);
    public virtual InputGesture get_Gesture();
    public virtual void set_Gesture(InputGesture value);
    public ModifierKeys get_Modifiers();
    public void set_Modifiers(ModifierKeys value);
    public Key get_Key();
    public void set_Key(Key value);
    protected virtual Freezable CreateInstanceCore();
}
public static class System.Windows.Input.Keyboard : object {
    public static RoutedEvent PreviewKeyDownEvent;
    public static RoutedEvent KeyDownEvent;
    public static RoutedEvent PreviewKeyUpEvent;
    public static RoutedEvent KeyUpEvent;
    public static RoutedEvent PreviewGotKeyboardFocusEvent;
    public static RoutedEvent PreviewKeyboardInputProviderAcquireFocusEvent;
    public static RoutedEvent KeyboardInputProviderAcquireFocusEvent;
    public static RoutedEvent GotKeyboardFocusEvent;
    public static RoutedEvent PreviewLostKeyboardFocusEvent;
    public static RoutedEvent LostKeyboardFocusEvent;
    public static IInputElement FocusedElement { get; }
    public static RestoreFocusMode DefaultRestoreFocusMode { get; public set; }
    public static ModifierKeys Modifiers { get; }
    public static KeyboardDevice PrimaryDevice { get; }
    public static IInputElement get_FocusedElement();
    public static RestoreFocusMode get_DefaultRestoreFocusMode();
    public static void set_DefaultRestoreFocusMode(RestoreFocusMode value);
    public static ModifierKeys get_Modifiers();
    [SecurityCriticalAttribute]
public static KeyboardDevice get_PrimaryDevice();
    public static void AddPreviewKeyDownHandler(DependencyObject element, KeyEventHandler handler);
    public static void RemovePreviewKeyDownHandler(DependencyObject element, KeyEventHandler handler);
    public static void AddKeyDownHandler(DependencyObject element, KeyEventHandler handler);
    public static void RemoveKeyDownHandler(DependencyObject element, KeyEventHandler handler);
    public static void AddPreviewKeyUpHandler(DependencyObject element, KeyEventHandler handler);
    public static void RemovePreviewKeyUpHandler(DependencyObject element, KeyEventHandler handler);
    public static void AddKeyUpHandler(DependencyObject element, KeyEventHandler handler);
    public static void RemoveKeyUpHandler(DependencyObject element, KeyEventHandler handler);
    public static void AddPreviewGotKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void RemovePreviewGotKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void AddPreviewKeyboardInputProviderAcquireFocusHandler(DependencyObject element, KeyboardInputProviderAcquireFocusEventHandler handler);
    public static void RemovePreviewKeyboardInputProviderAcquireFocusHandler(DependencyObject element, KeyboardInputProviderAcquireFocusEventHandler handler);
    public static void AddKeyboardInputProviderAcquireFocusHandler(DependencyObject element, KeyboardInputProviderAcquireFocusEventHandler handler);
    public static void RemoveKeyboardInputProviderAcquireFocusHandler(DependencyObject element, KeyboardInputProviderAcquireFocusEventHandler handler);
    public static void AddGotKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void RemoveGotKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void AddPreviewLostKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void RemovePreviewLostKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void AddLostKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void RemoveLostKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void ClearFocus();
    public static IInputElement Focus(IInputElement element);
    public static bool IsKeyDown(Key key);
    public static bool IsKeyUp(Key key);
    public static bool IsKeyToggled(Key key);
    public static KeyStates GetKeyStates(Key key);
}
public abstract class System.Windows.Input.KeyboardDevice : InputDevice {
    public IInputElement Target { get; }
    public PresentationSource ActiveSource { get; }
    public RestoreFocusMode DefaultRestoreFocusMode { get; public set; }
    public IInputElement FocusedElement { get; }
    public ModifierKeys Modifiers { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected KeyboardDevice(InputManager inputManager);
    public virtual IInputElement get_Target();
    [SecurityCriticalAttribute]
public virtual PresentationSource get_ActiveSource();
    public RestoreFocusMode get_DefaultRestoreFocusMode();
    public void set_DefaultRestoreFocusMode(RestoreFocusMode value);
    public IInputElement get_FocusedElement();
    public ModifierKeys get_Modifiers();
    protected abstract virtual KeyStates GetKeyStatesFromSystem(Key key);
    public void ClearFocus();
    [SecurityCriticalAttribute]
public IInputElement Focus(IInputElement element);
    public bool IsKeyDown(Key key);
    public bool IsKeyUp(Key key);
    public bool IsKeyToggled(Key key);
    public KeyStates GetKeyStates(Key key);
}
public class System.Windows.Input.KeyboardEventArgs : InputEventArgs {
    public KeyboardDevice KeyboardDevice { get; }
    public KeyboardEventArgs(KeyboardDevice keyboard, int timestamp);
    public KeyboardDevice get_KeyboardDevice();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.KeyboardEventHandler : MulticastDelegate {
    public KeyboardEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, KeyboardEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, KeyboardEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.KeyboardFocusChangedEventArgs : KeyboardEventArgs {
    public IInputElement OldFocus { get; }
    public IInputElement NewFocus { get; }
    public KeyboardFocusChangedEventArgs(KeyboardDevice keyboard, int timestamp, IInputElement oldFocus, IInputElement newFocus);
    public IInputElement get_OldFocus();
    public IInputElement get_NewFocus();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.KeyboardFocusChangedEventHandler : MulticastDelegate {
    public KeyboardFocusChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, KeyboardFocusChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, KeyboardFocusChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.KeyboardInputProviderAcquireFocusEventArgs : KeyboardEventArgs {
    public bool FocusAcquired { get; }
    public KeyboardInputProviderAcquireFocusEventArgs(KeyboardDevice keyboard, int timestamp, bool focusAcquired);
    public bool get_FocusAcquired();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler : MulticastDelegate {
    public KeyboardInputProviderAcquireFocusEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, KeyboardInputProviderAcquireFocusEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, KeyboardInputProviderAcquireFocusEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.KeyEventArgs : KeyboardEventArgs {
    public PresentationSource InputSource { get; }
    public Key Key { get; }
    public Key ImeProcessedKey { get; }
    public Key SystemKey { get; }
    public Key DeadCharProcessedKey { get; }
    public KeyStates KeyStates { get; }
    public bool IsRepeat { get; }
    public bool IsDown { get; }
    public bool IsUp { get; }
    public bool IsToggled { get; }
    [SecurityCriticalAttribute]
public KeyEventArgs(KeyboardDevice keyboard, PresentationSource inputSource, int timestamp, Key key);
    [SecurityCriticalAttribute]
public PresentationSource get_InputSource();
    public Key get_Key();
    public Key get_ImeProcessedKey();
    public Key get_SystemKey();
    public Key get_DeadCharProcessedKey();
    public KeyStates get_KeyStates();
    public bool get_IsRepeat();
    public bool get_IsDown();
    public bool get_IsUp();
    public bool get_IsToggled();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.KeyEventHandler : MulticastDelegate {
    public KeyEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, KeyEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, KeyEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ValueSerializerAttribute("System.Windows.Input.KeyGestureValueSerializer")]
[TypeConverterAttribute("System.Windows.Input.KeyGestureConverter")]
public class System.Windows.Input.KeyGesture : InputGesture {
    public ModifierKeys Modifiers { get; }
    public Key Key { get; }
    public string DisplayString { get; }
    public KeyGesture(Key key);
    public KeyGesture(Key key, ModifierKeys modifiers);
    public KeyGesture(Key key, ModifierKeys modifiers, string displayString);
    public ModifierKeys get_Modifiers();
    public Key get_Key();
    public string get_DisplayString();
    public string GetDisplayStringForCulture(CultureInfo culture);
    public virtual bool Matches(object targetElement, InputEventArgs inputEventArgs);
}
public class System.Windows.Input.KeyGestureConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Input.KeyGestureValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
[FlagsAttribute]
public enum System.Windows.Input.KeyStates : Enum {
    public byte value__;
    public static KeyStates None;
    public static KeyStates Down;
    public static KeyStates Toggled;
}
public static class System.Windows.Input.Manipulation : object {
    public static bool IsManipulationActive(UIElement element);
    public static void StartInertia(UIElement element);
    public static void CompleteManipulation(UIElement element);
    public static void SetManipulationMode(UIElement element, ManipulationModes mode);
    public static ManipulationModes GetManipulationMode(UIElement element);
    public static void SetManipulationContainer(UIElement element, IInputElement container);
    public static IInputElement GetManipulationContainer(UIElement element);
    public static void SetManipulationPivot(UIElement element, ManipulationPivot pivot);
    public static ManipulationPivot GetManipulationPivot(UIElement element);
    public static void AddManipulator(UIElement element, IManipulator manipulator);
    public static void RemoveManipulator(UIElement element, IManipulator manipulator);
    [BrowsableAttribute("False")]
public static void SetManipulationParameter(UIElement element, ManipulationParameters2D parameter);
}
public class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs : InputEventArgs {
    public IInputElement ManipulationContainer { get; private set; }
    public ManipulationDelta BoundaryFeedback { get; private set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    public ManipulationBoundaryFeedbackEventArgs(InputDevice inputDevice, int timestamp);
    public IInputElement get_ManipulationContainer();
    private void set_ManipulationContainer(IInputElement value);
    public ManipulationDelta get_BoundaryFeedback();
    private void set_BoundaryFeedback(ManipulationDelta value);
    public IEnumerable`1<IManipulator> get_Manipulators();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.ManipulationCompletedEventArgs : InputEventArgs {
    public bool IsInertial { get; private set; }
    public IInputElement ManipulationContainer { get; private set; }
    public Point ManipulationOrigin { get; private set; }
    public ManipulationDelta TotalManipulation { get; private set; }
    public ManipulationVelocities FinalVelocities { get; private set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    public ManipulationCompletedEventArgs(InputDevice inputDevice, int timestamp);
    public bool get_IsInertial();
    private void set_IsInertial(bool value);
    public IInputElement get_ManipulationContainer();
    private void set_ManipulationContainer(IInputElement value);
    public Point get_ManipulationOrigin();
    private void set_ManipulationOrigin(Point value);
    public ManipulationDelta get_TotalManipulation();
    private void set_TotalManipulation(ManipulationDelta value);
    public ManipulationVelocities get_FinalVelocities();
    private void set_FinalVelocities(ManipulationVelocities value);
    public IEnumerable`1<IManipulator> get_Manipulators();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    public bool Cancel();
}
public class System.Windows.Input.ManipulationDelta : object {
    public Vector Translation { get; private set; }
    public double Rotation { get; private set; }
    public Vector Scale { get; private set; }
    public Vector Expansion { get; private set; }
    public ManipulationDelta(Vector translation, double rotation, Vector scale, Vector expansion);
    public Vector get_Translation();
    private void set_Translation(Vector value);
    public double get_Rotation();
    private void set_Rotation(double value);
    public Vector get_Scale();
    private void set_Scale(Vector value);
    public Vector get_Expansion();
    private void set_Expansion(Vector value);
}
public class System.Windows.Input.ManipulationDeltaEventArgs : InputEventArgs {
    public bool IsInertial { get; private set; }
    public IInputElement ManipulationContainer { get; private set; }
    public Point ManipulationOrigin { get; private set; }
    public ManipulationDelta CumulativeManipulation { get; private set; }
    public ManipulationDelta DeltaManipulation { get; private set; }
    public ManipulationVelocities Velocities { get; private set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    public ManipulationDeltaEventArgs(InputDevice inputDevice, int timestamp);
    public bool get_IsInertial();
    private void set_IsInertial(bool value);
    public IInputElement get_ManipulationContainer();
    private void set_ManipulationContainer(IInputElement value);
    public Point get_ManipulationOrigin();
    private void set_ManipulationOrigin(Point value);
    public ManipulationDelta get_CumulativeManipulation();
    private void set_CumulativeManipulation(ManipulationDelta value);
    public ManipulationDelta get_DeltaManipulation();
    private void set_DeltaManipulation(ManipulationDelta value);
    public ManipulationVelocities get_Velocities();
    private void set_Velocities(ManipulationVelocities value);
    public IEnumerable`1<IManipulator> get_Manipulators();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    public void ReportBoundaryFeedback(ManipulationDelta unusedManipulation);
    public void Complete();
    public void StartInertia();
    public bool Cancel();
}
public class System.Windows.Input.ManipulationInertiaStartingEventArgs : InputEventArgs {
    public IInputElement ManipulationContainer { get; private set; }
    public Point ManipulationOrigin { get; public set; }
    public ManipulationVelocities InitialVelocities { get; private set; }
    public InertiaTranslationBehavior TranslationBehavior { get; public set; }
    public InertiaRotationBehavior RotationBehavior { get; public set; }
    public InertiaExpansionBehavior ExpansionBehavior { get; public set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    public ManipulationInertiaStartingEventArgs(InputDevice inputDevice, int timestamp);
    public IInputElement get_ManipulationContainer();
    private void set_ManipulationContainer(IInputElement value);
    public Point get_ManipulationOrigin();
    public void set_ManipulationOrigin(Point value);
    public ManipulationVelocities get_InitialVelocities();
    private void set_InitialVelocities(ManipulationVelocities value);
    public InertiaTranslationBehavior get_TranslationBehavior();
    public void set_TranslationBehavior(InertiaTranslationBehavior value);
    public InertiaRotationBehavior get_RotationBehavior();
    public void set_RotationBehavior(InertiaRotationBehavior value);
    public InertiaExpansionBehavior get_ExpansionBehavior();
    public void set_ExpansionBehavior(InertiaExpansionBehavior value);
    public IEnumerable`1<IManipulator> get_Manipulators();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    public bool Cancel();
    [BrowsableAttribute("False")]
public void SetInertiaParameter(InertiaParameters2D parameter);
}
[FlagsAttribute]
public enum System.Windows.Input.ManipulationModes : Enum {
    public int value__;
    public static ManipulationModes None;
    public static ManipulationModes TranslateX;
    public static ManipulationModes TranslateY;
    public static ManipulationModes Translate;
    public static ManipulationModes Rotate;
    public static ManipulationModes Scale;
    public static ManipulationModes All;
}
public class System.Windows.Input.ManipulationPivot : object {
    public Point Center { get; public set; }
    public double Radius { get; public set; }
    public ManipulationPivot(Point center, double radius);
    public Point get_Center();
    public void set_Center(Point value);
    public double get_Radius();
    public void set_Radius(double value);
}
public class System.Windows.Input.ManipulationStartedEventArgs : InputEventArgs {
    public IInputElement ManipulationContainer { get; private set; }
    public Point ManipulationOrigin { get; private set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    public ManipulationStartedEventArgs(InputDevice inputDevice, int timestamp);
    public IInputElement get_ManipulationContainer();
    private void set_ManipulationContainer(IInputElement value);
    public Point get_ManipulationOrigin();
    private void set_ManipulationOrigin(Point value);
    public IEnumerable`1<IManipulator> get_Manipulators();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    public void Complete();
    public bool Cancel();
}
public class System.Windows.Input.ManipulationStartingEventArgs : InputEventArgs {
    public ManipulationModes Mode { get; public set; }
    public IInputElement ManipulationContainer { get; public set; }
    public ManipulationPivot Pivot { get; public set; }
    public bool IsSingleTouchEnabled { get; public set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    public ManipulationStartingEventArgs(InputDevice inputDevice, int timestamp);
    public ManipulationModes get_Mode();
    public void set_Mode(ManipulationModes value);
    public IInputElement get_ManipulationContainer();
    public void set_ManipulationContainer(IInputElement value);
    public ManipulationPivot get_Pivot();
    public void set_Pivot(ManipulationPivot value);
    public bool get_IsSingleTouchEnabled();
    public void set_IsSingleTouchEnabled(bool value);
    public IEnumerable`1<IManipulator> get_Manipulators();
    public bool Cancel();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    [BrowsableAttribute("False")]
public void SetManipulationParameter(ManipulationParameters2D parameter);
}
public class System.Windows.Input.ManipulationVelocities : object {
    public Vector LinearVelocity { get; private set; }
    public double AngularVelocity { get; private set; }
    public Vector ExpansionVelocity { get; private set; }
    public ManipulationVelocities(Vector linearVelocity, double angularVelocity, Vector expansionVelocity);
    public Vector get_LinearVelocity();
    private void set_LinearVelocity(Vector value);
    public double get_AngularVelocity();
    private void set_AngularVelocity(double value);
    public Vector get_ExpansionVelocity();
    private void set_ExpansionVelocity(Vector value);
}
public static class System.Windows.Input.MediaCommands : object {
    public static RoutedUICommand Play { get; }
    public static RoutedUICommand Pause { get; }
    public static RoutedUICommand Stop { get; }
    public static RoutedUICommand Record { get; }
    public static RoutedUICommand NextTrack { get; }
    public static RoutedUICommand PreviousTrack { get; }
    public static RoutedUICommand FastForward { get; }
    public static RoutedUICommand Rewind { get; }
    public static RoutedUICommand ChannelUp { get; }
    public static RoutedUICommand ChannelDown { get; }
    public static RoutedUICommand TogglePlayPause { get; }
    public static RoutedUICommand Select { get; }
    public static RoutedUICommand IncreaseVolume { get; }
    public static RoutedUICommand DecreaseVolume { get; }
    public static RoutedUICommand MuteVolume { get; }
    public static RoutedUICommand IncreaseTreble { get; }
    public static RoutedUICommand DecreaseTreble { get; }
    public static RoutedUICommand IncreaseBass { get; }
    public static RoutedUICommand DecreaseBass { get; }
    public static RoutedUICommand BoostBass { get; }
    public static RoutedUICommand IncreaseMicrophoneVolume { get; }
    public static RoutedUICommand DecreaseMicrophoneVolume { get; }
    public static RoutedUICommand MuteMicrophoneVolume { get; }
    public static RoutedUICommand ToggleMicrophoneOnOff { get; }
    public static RoutedUICommand get_Play();
    public static RoutedUICommand get_Pause();
    public static RoutedUICommand get_Stop();
    public static RoutedUICommand get_Record();
    public static RoutedUICommand get_NextTrack();
    public static RoutedUICommand get_PreviousTrack();
    public static RoutedUICommand get_FastForward();
    public static RoutedUICommand get_Rewind();
    public static RoutedUICommand get_ChannelUp();
    public static RoutedUICommand get_ChannelDown();
    public static RoutedUICommand get_TogglePlayPause();
    public static RoutedUICommand get_Select();
    public static RoutedUICommand get_IncreaseVolume();
    public static RoutedUICommand get_DecreaseVolume();
    public static RoutedUICommand get_MuteVolume();
    public static RoutedUICommand get_IncreaseTreble();
    public static RoutedUICommand get_DecreaseTreble();
    public static RoutedUICommand get_IncreaseBass();
    public static RoutedUICommand get_DecreaseBass();
    public static RoutedUICommand get_BoostBass();
    public static RoutedUICommand get_IncreaseMicrophoneVolume();
    public static RoutedUICommand get_DecreaseMicrophoneVolume();
    public static RoutedUICommand get_MuteMicrophoneVolume();
    public static RoutedUICommand get_ToggleMicrophoneOnOff();
}
public static class System.Windows.Input.Mouse : object {
    public static int MouseWheelDeltaForOneLine;
    public static RoutedEvent PreviewMouseMoveEvent;
    public static RoutedEvent MouseMoveEvent;
    public static RoutedEvent PreviewMouseDownOutsideCapturedElementEvent;
    public static RoutedEvent PreviewMouseUpOutsideCapturedElementEvent;
    public static RoutedEvent PreviewMouseDownEvent;
    public static RoutedEvent MouseDownEvent;
    public static RoutedEvent PreviewMouseUpEvent;
    public static RoutedEvent MouseUpEvent;
    public static RoutedEvent PreviewMouseWheelEvent;
    public static RoutedEvent MouseWheelEvent;
    public static RoutedEvent MouseEnterEvent;
    public static RoutedEvent MouseLeaveEvent;
    public static RoutedEvent GotMouseCaptureEvent;
    public static RoutedEvent LostMouseCaptureEvent;
    public static RoutedEvent QueryCursorEvent;
    public static IInputElement DirectlyOver { get; }
    public static IInputElement Captured { get; }
    public static Cursor OverrideCursor { get; public set; }
    public static MouseButtonState LeftButton { get; }
    public static MouseButtonState RightButton { get; }
    public static MouseButtonState MiddleButton { get; }
    public static MouseButtonState XButton1 { get; }
    public static MouseButtonState XButton2 { get; }
    public static MouseDevice PrimaryDevice { get; }
    public static IInputElement get_DirectlyOver();
    public static IInputElement get_Captured();
    public static Cursor get_OverrideCursor();
    public static void set_OverrideCursor(Cursor value);
    public static MouseButtonState get_LeftButton();
    public static MouseButtonState get_RightButton();
    public static MouseButtonState get_MiddleButton();
    public static MouseButtonState get_XButton1();
    public static MouseButtonState get_XButton2();
    [SecurityCriticalAttribute]
public static MouseDevice get_PrimaryDevice();
    public static void AddPreviewMouseMoveHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemovePreviewMouseMoveHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddMouseMoveHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveMouseMoveHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddPreviewMouseDownOutsideCapturedElementHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemovePreviewMouseDownOutsideCapturedElementHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddPreviewMouseUpOutsideCapturedElementHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemovePreviewMouseUpOutsideCapturedElementHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddPreviewMouseDownHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemovePreviewMouseDownHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddMouseDownHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemoveMouseDownHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddPreviewMouseUpHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemovePreviewMouseUpHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddMouseUpHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemoveMouseUpHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddPreviewMouseWheelHandler(DependencyObject element, MouseWheelEventHandler handler);
    public static void RemovePreviewMouseWheelHandler(DependencyObject element, MouseWheelEventHandler handler);
    public static void AddMouseWheelHandler(DependencyObject element, MouseWheelEventHandler handler);
    public static void RemoveMouseWheelHandler(DependencyObject element, MouseWheelEventHandler handler);
    public static void AddMouseEnterHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveMouseEnterHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddMouseLeaveHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveMouseLeaveHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddGotMouseCaptureHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveGotMouseCaptureHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddLostMouseCaptureHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveLostMouseCaptureHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddQueryCursorHandler(DependencyObject element, QueryCursorEventHandler handler);
    public static void RemoveQueryCursorHandler(DependencyObject element, QueryCursorEventHandler handler);
    public static bool Capture(IInputElement element);
    public static bool Capture(IInputElement element, CaptureMode captureMode);
    [SecurityCriticalAttribute]
public static int GetIntermediatePoints(IInputElement relativeTo, Point[] points);
    public static bool SetCursor(Cursor cursor);
    public static Point GetPosition(IInputElement relativeTo);
    public static void Synchronize();
    public static void UpdateCursor();
}
[TypeConverterAttribute("System.Windows.Input.MouseActionConverter")]
[ValueSerializerAttribute("System.Windows.Input.MouseActionValueSerializer")]
public enum System.Windows.Input.MouseAction : Enum {
    public byte value__;
    public static MouseAction None;
    public static MouseAction LeftClick;
    public static MouseAction RightClick;
    public static MouseAction MiddleClick;
    public static MouseAction WheelClick;
    public static MouseAction LeftDoubleClick;
    public static MouseAction RightDoubleClick;
    public static MouseAction MiddleDoubleClick;
}
public class System.Windows.Input.MouseActionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Input.MouseActionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Input.MouseBinding : InputBinding {
    public static DependencyProperty MouseActionProperty;
    [TypeConverterAttribute("System.Windows.Input.MouseGestureConverter")]
[ValueSerializerAttribute("System.Windows.Input.MouseGestureValueSerializer")]
public InputGesture Gesture { get; public set; }
    public MouseAction MouseAction { get; public set; }
    public MouseBinding(ICommand command, MouseGesture gesture);
    public virtual InputGesture get_Gesture();
    public virtual void set_Gesture(InputGesture value);
    public MouseAction get_MouseAction();
    public void set_MouseAction(MouseAction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
public enum System.Windows.Input.MouseButton : Enum {
    public int value__;
    public static MouseButton Left;
    public static MouseButton Middle;
    public static MouseButton Right;
    public static MouseButton XButton1;
    public static MouseButton XButton2;
}
public class System.Windows.Input.MouseButtonEventArgs : MouseEventArgs {
    public MouseButton ChangedButton { get; }
    public MouseButtonState ButtonState { get; }
    public int ClickCount { get; internal set; }
    public MouseButtonEventArgs(MouseDevice mouse, int timestamp, MouseButton button);
    public MouseButtonEventArgs(MouseDevice mouse, int timestamp, MouseButton button, StylusDevice stylusDevice);
    public MouseButton get_ChangedButton();
    public MouseButtonState get_ButtonState();
    public int get_ClickCount();
    internal void set_ClickCount(int value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.MouseButtonEventHandler : MulticastDelegate {
    public MouseButtonEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, MouseButtonEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, MouseButtonEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Input.MouseButtonState : Enum {
    public int value__;
    public static MouseButtonState Released;
    public static MouseButtonState Pressed;
}
public abstract class System.Windows.Input.MouseDevice : InputDevice {
    public IInputElement Target { get; }
    public PresentationSource ActiveSource { get; }
    public IInputElement DirectlyOver { get; }
    public IInputElement Captured { get; }
    public Cursor OverrideCursor { get; public set; }
    public MouseButtonState LeftButton { get; }
    public MouseButtonState RightButton { get; }
    public MouseButtonState MiddleButton { get; }
    public MouseButtonState XButton1 { get; }
    public MouseButtonState XButton2 { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal MouseDevice(InputManager inputManager);
    public virtual IInputElement get_Target();
    [SecurityCriticalAttribute]
public virtual PresentationSource get_ActiveSource();
    public IInputElement get_DirectlyOver();
    public IInputElement get_Captured();
    public Cursor get_OverrideCursor();
    public void set_OverrideCursor(Cursor value);
    public MouseButtonState get_LeftButton();
    public MouseButtonState get_RightButton();
    public MouseButtonState get_MiddleButton();
    public MouseButtonState get_XButton1();
    public MouseButtonState get_XButton2();
    protected MouseButtonState GetButtonState(MouseButton mouseButton);
    protected Point GetScreenPosition();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected Point GetClientPosition();
    protected Point GetClientPosition(PresentationSource presentationSource);
    public bool Capture(IInputElement element);
    [SecurityCriticalAttribute]
public bool Capture(IInputElement element, CaptureMode captureMode);
    [SecurityCriticalAttribute]
public bool SetCursor(Cursor cursor);
    [SecurityCriticalAttribute]
public Point GetPosition(IInputElement relativeTo);
    [SecurityCriticalAttribute]
public void Synchronize();
    public void UpdateCursor();
}
public class System.Windows.Input.MouseEventArgs : InputEventArgs {
    public MouseDevice MouseDevice { get; }
    public StylusDevice StylusDevice { get; }
    public MouseButtonState LeftButton { get; }
    public MouseButtonState RightButton { get; }
    public MouseButtonState MiddleButton { get; }
    public MouseButtonState XButton1 { get; }
    public MouseButtonState XButton2 { get; }
    public MouseEventArgs(MouseDevice mouse, int timestamp);
    public MouseEventArgs(MouseDevice mouse, int timestamp, StylusDevice stylusDevice);
    public MouseDevice get_MouseDevice();
    public StylusDevice get_StylusDevice();
    public MouseButtonState get_LeftButton();
    public MouseButtonState get_RightButton();
    public MouseButtonState get_MiddleButton();
    public MouseButtonState get_XButton1();
    public MouseButtonState get_XButton2();
    public Point GetPosition(IInputElement relativeTo);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.MouseEventHandler : MulticastDelegate {
    public MouseEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, MouseEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, MouseEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ValueSerializerAttribute("System.Windows.Input.MouseGestureValueSerializer")]
[TypeConverterAttribute("System.Windows.Input.MouseGestureConverter")]
public class System.Windows.Input.MouseGesture : InputGesture {
    public MouseAction MouseAction { get; public set; }
    public ModifierKeys Modifiers { get; public set; }
    public MouseGesture(MouseAction mouseAction);
    public MouseGesture(MouseAction mouseAction, ModifierKeys modifiers);
    public MouseAction get_MouseAction();
    public void set_MouseAction(MouseAction value);
    public ModifierKeys get_Modifiers();
    public void set_Modifiers(ModifierKeys value);
    public virtual bool Matches(object targetElement, InputEventArgs inputEventArgs);
}
public class System.Windows.Input.MouseGestureConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Input.MouseGestureValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Input.MouseWheelEventArgs : MouseEventArgs {
    public int Delta { get; }
    public MouseWheelEventArgs(MouseDevice mouse, int timestamp, int delta);
    public int get_Delta();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.MouseWheelEventHandler : MulticastDelegate {
    public MouseWheelEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, MouseWheelEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, MouseWheelEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Windows.Input.NavigationCommands : object {
    public static RoutedUICommand BrowseBack { get; }
    public static RoutedUICommand BrowseForward { get; }
    public static RoutedUICommand BrowseHome { get; }
    public static RoutedUICommand BrowseStop { get; }
    public static RoutedUICommand Refresh { get; }
    public static RoutedUICommand Favorites { get; }
    public static RoutedUICommand Search { get; }
    public static RoutedUICommand IncreaseZoom { get; }
    public static RoutedUICommand DecreaseZoom { get; }
    public static RoutedUICommand Zoom { get; }
    public static RoutedUICommand NextPage { get; }
    public static RoutedUICommand PreviousPage { get; }
    public static RoutedUICommand FirstPage { get; }
    public static RoutedUICommand LastPage { get; }
    public static RoutedUICommand GoToPage { get; }
    public static RoutedUICommand NavigateJournal { get; }
    public static RoutedUICommand get_BrowseBack();
    public static RoutedUICommand get_BrowseForward();
    public static RoutedUICommand get_BrowseHome();
    public static RoutedUICommand get_BrowseStop();
    public static RoutedUICommand get_Refresh();
    public static RoutedUICommand get_Favorites();
    public static RoutedUICommand get_Search();
    public static RoutedUICommand get_IncreaseZoom();
    public static RoutedUICommand get_DecreaseZoom();
    public static RoutedUICommand get_Zoom();
    public static RoutedUICommand get_NextPage();
    public static RoutedUICommand get_PreviousPage();
    public static RoutedUICommand get_FirstPage();
    public static RoutedUICommand get_LastPage();
    public static RoutedUICommand get_GoToPage();
    public static RoutedUICommand get_NavigateJournal();
}
public class System.Windows.Input.NotifyInputEventArgs : EventArgs {
    public StagingAreaInputItem StagingItem { get; }
    public InputManager InputManager { get; }
    public StagingAreaInputItem get_StagingItem();
    [SecurityCriticalAttribute]
public InputManager get_InputManager();
}
public class System.Windows.Input.NotifyInputEventHandler : MulticastDelegate {
    public NotifyInputEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NotifyInputEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NotifyInputEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.PreProcessInputEventArgs : ProcessInputEventArgs {
    public bool Canceled { get; }
    public bool get_Canceled();
    public void Cancel();
}
public class System.Windows.Input.PreProcessInputEventHandler : MulticastDelegate {
    public PreProcessInputEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PreProcessInputEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PreProcessInputEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.ProcessInputEventArgs : NotifyInputEventArgs {
    [SecurityCriticalAttribute]
public StagingAreaInputItem PushInput(InputEventArgs input, StagingAreaInputItem promote);
    [SecurityCriticalAttribute]
public StagingAreaInputItem PushInput(StagingAreaInputItem input);
    [SecurityCriticalAttribute]
public StagingAreaInputItem PopInput();
    [SecurityCriticalAttribute]
public StagingAreaInputItem PeekInput();
}
public class System.Windows.Input.ProcessInputEventHandler : MulticastDelegate {
    public ProcessInputEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ProcessInputEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ProcessInputEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.QueryCursorEventArgs : MouseEventArgs {
    public Cursor Cursor { get; public set; }
    public QueryCursorEventArgs(MouseDevice mouse, int timestamp);
    public QueryCursorEventArgs(MouseDevice mouse, int timestamp, StylusDevice stylusDevice);
    public Cursor get_Cursor();
    public void set_Cursor(Cursor value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.QueryCursorEventHandler : MulticastDelegate {
    public QueryCursorEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, QueryCursorEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, QueryCursorEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Input.RestoreFocusMode : Enum {
    public int value__;
    public static RestoreFocusMode Auto;
    public static RestoreFocusMode None;
}
[ValueSerializerAttribute("System.Windows.Input.CommandValueSerializer, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[TypeConverterAttribute("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.Input.RoutedCommand : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler CanExecuteChanged;
    public string Name { get; }
    public Type OwnerType { get; }
    public InputGestureCollection InputGestures { get; }
    public RoutedCommand(string name, Type ownerType);
    public RoutedCommand(string name, Type ownerType, InputGestureCollection inputGestures);
    public string get_Name();
    public Type get_OwnerType();
    public InputGestureCollection get_InputGestures();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CanExecuteChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    private sealed virtual override void System.Windows.Input.ICommand.Execute(object parameter);
    [SecurityCriticalAttribute]
private sealed virtual override bool System.Windows.Input.ICommand.CanExecute(object parameter);
    [SecurityCriticalAttribute]
public void Execute(object parameter, IInputElement target);
    [SecurityCriticalAttribute]
public bool CanExecute(object parameter, IInputElement target);
}
[TypeConverterAttribute("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.Input.RoutedUICommand : RoutedCommand {
    public string Text { get; public set; }
    public RoutedUICommand(string text, string name, Type ownerType);
    public RoutedUICommand(string text, string name, Type ownerType, InputGestureCollection inputGestures);
    public string get_Text();
    public void set_Text(string value);
}
public enum System.Windows.Input.SpeechMode : Enum {
    public int value__;
    public static SpeechMode Dictation;
    public static SpeechMode Command;
    public static SpeechMode Indeterminate;
}
public class System.Windows.Input.StagingAreaInputItem : object {
    public InputEventArgs Input { get; }
    internal StagingAreaInputItem(bool isMarker);
    [SecurityCriticalAttribute]
public InputEventArgs get_Input();
    public object GetData(object key);
    [SecurityCriticalAttribute]
public void SetData(object key, object value);
}
public static class System.Windows.Input.Stylus : object {
    public static RoutedEvent PreviewStylusDownEvent;
    public static RoutedEvent StylusDownEvent;
    public static RoutedEvent PreviewStylusUpEvent;
    public static RoutedEvent StylusUpEvent;
    public static RoutedEvent PreviewStylusMoveEvent;
    public static RoutedEvent StylusMoveEvent;
    public static RoutedEvent PreviewStylusInAirMoveEvent;
    public static RoutedEvent StylusInAirMoveEvent;
    public static RoutedEvent StylusEnterEvent;
    public static RoutedEvent StylusLeaveEvent;
    public static RoutedEvent PreviewStylusInRangeEvent;
    public static RoutedEvent StylusInRangeEvent;
    public static RoutedEvent PreviewStylusOutOfRangeEvent;
    public static RoutedEvent StylusOutOfRangeEvent;
    public static RoutedEvent PreviewStylusSystemGestureEvent;
    public static RoutedEvent StylusSystemGestureEvent;
    public static RoutedEvent GotStylusCaptureEvent;
    public static RoutedEvent LostStylusCaptureEvent;
    public static RoutedEvent StylusButtonDownEvent;
    public static RoutedEvent StylusButtonUpEvent;
    public static RoutedEvent PreviewStylusButtonDownEvent;
    public static RoutedEvent PreviewStylusButtonUpEvent;
    public static DependencyProperty IsPressAndHoldEnabledProperty;
    public static DependencyProperty IsFlicksEnabledProperty;
    public static DependencyProperty IsTapFeedbackEnabledProperty;
    public static DependencyProperty IsTouchFeedbackEnabledProperty;
    public static IInputElement DirectlyOver { get; }
    public static IInputElement Captured { get; }
    public static StylusDevice CurrentStylusDevice { get; }
    public static IInputElement get_DirectlyOver();
    public static IInputElement get_Captured();
    [SecurityCriticalAttribute]
public static StylusDevice get_CurrentStylusDevice();
    public static void AddPreviewStylusDownHandler(DependencyObject element, StylusDownEventHandler handler);
    public static void RemovePreviewStylusDownHandler(DependencyObject element, StylusDownEventHandler handler);
    public static void AddStylusDownHandler(DependencyObject element, StylusDownEventHandler handler);
    public static void RemoveStylusDownHandler(DependencyObject element, StylusDownEventHandler handler);
    public static void AddPreviewStylusUpHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusUpHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusUpHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusUpHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusInAirMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusInAirMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusInAirMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusInAirMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusEnterHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusEnterHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusLeaveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusLeaveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusInRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusInRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusInRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusInRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusOutOfRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusOutOfRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusOutOfRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusOutOfRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusSystemGestureHandler(DependencyObject element, StylusSystemGestureEventHandler handler);
    public static void RemovePreviewStylusSystemGestureHandler(DependencyObject element, StylusSystemGestureEventHandler handler);
    public static void AddStylusSystemGestureHandler(DependencyObject element, StylusSystemGestureEventHandler handler);
    public static void RemoveStylusSystemGestureHandler(DependencyObject element, StylusSystemGestureEventHandler handler);
    public static void AddGotStylusCaptureHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveGotStylusCaptureHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddLostStylusCaptureHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveLostStylusCaptureHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusButtonDownHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void RemoveStylusButtonDownHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void AddStylusButtonUpHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void RemoveStylusButtonUpHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void AddPreviewStylusButtonDownHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void RemovePreviewStylusButtonDownHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void AddPreviewStylusButtonUpHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void RemovePreviewStylusButtonUpHandler(DependencyObject element, StylusButtonEventHandler handler);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsPressAndHoldEnabled(DependencyObject element);
    public static void SetIsPressAndHoldEnabled(DependencyObject element, bool enabled);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsFlicksEnabled(DependencyObject element);
    public static void SetIsFlicksEnabled(DependencyObject element, bool enabled);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsTapFeedbackEnabled(DependencyObject element);
    public static void SetIsTapFeedbackEnabled(DependencyObject element, bool enabled);
    public static bool GetIsTouchFeedbackEnabled(DependencyObject element);
    public static void SetIsTouchFeedbackEnabled(DependencyObject element, bool enabled);
    public static bool Capture(IInputElement element);
    public static bool Capture(IInputElement element, CaptureMode captureMode);
    public static void Synchronize();
}
public class System.Windows.Input.StylusButton : object {
    public Guid Guid { get; }
    public StylusButtonState StylusButtonState { get; }
    public string Name { get; }
    public StylusDevice StylusDevice { get; }
    internal StylusButton(string name, Guid id);
    public Guid get_Guid();
    public StylusButtonState get_StylusButtonState();
    public string get_Name();
    public StylusDevice get_StylusDevice();
    public virtual string ToString();
}
public class System.Windows.Input.StylusButtonCollection : ReadOnlyCollection`1<StylusButton> {
    internal StylusButtonCollection(StylusButton[] buttons);
    public StylusButton GetStylusButtonByGuid(Guid guid);
}
public class System.Windows.Input.StylusButtonEventArgs : StylusEventArgs {
    public StylusButton StylusButton { get; }
    public StylusButtonEventArgs(StylusDevice stylusDevice, int timestamp, StylusButton button);
    public StylusButton get_StylusButton();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.StylusButtonEventHandler : MulticastDelegate {
    public StylusButtonEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusButtonEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusButtonEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Input.StylusButtonState : Enum {
    public int value__;
    public static StylusButtonState Up;
    public static StylusButtonState Down;
}
public class System.Windows.Input.StylusDevice : InputDevice {
    public IInputElement Target { get; }
    public PresentationSource ActiveSource { get; }
    public IInputElement DirectlyOver { get; }
    public IInputElement Captured { get; }
    public TabletDevice TabletDevice { get; }
    public string Name { get; }
    public int Id { get; }
    public StylusButtonCollection StylusButtons { get; }
    public bool InAir { get; }
    public bool Inverted { get; }
    public bool InRange { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal StylusDevice(TabletDevice tabletDevice, string sName, int id, bool fInverted, StylusButtonCollection stylusButtonCollection);
    public virtual IInputElement get_Target();
    [SecurityCriticalAttribute]
public virtual PresentationSource get_ActiveSource();
    public IInputElement get_DirectlyOver();
    public IInputElement get_Captured();
    public TabletDevice get_TabletDevice();
    public string get_Name();
    public int get_Id();
    public StylusButtonCollection get_StylusButtons();
    public bool get_InAir();
    public bool get_Inverted();
    public bool get_InRange();
    public bool Capture(IInputElement element, CaptureMode captureMode);
    public bool Capture(IInputElement element);
    [SecurityCriticalAttribute]
public void Synchronize();
    public virtual string ToString();
    public StylusPointCollection GetStylusPoints(IInputElement relativeTo);
    public StylusPointCollection GetStylusPoints(IInputElement relativeTo, StylusPointDescription subsetToReformatTo);
    [SecurityCriticalAttribute]
public Point GetPosition(IInputElement relativeTo);
}
public class System.Windows.Input.StylusDeviceCollection : ReadOnlyCollection`1<StylusDevice> {
    internal StylusDeviceCollection(StylusDevice[] styluses);
}
public class System.Windows.Input.StylusDownEventArgs : StylusEventArgs {
    public int TapCount { get; }
    public StylusDownEventArgs(StylusDevice stylusDevice, int timestamp);
    public int get_TapCount();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.StylusDownEventHandler : MulticastDelegate {
    public StylusDownEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusDownEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusDownEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.StylusEventArgs : InputEventArgs {
    public StylusDevice StylusDevice { get; }
    public bool InAir { get; }
    public bool Inverted { get; }
    public StylusEventArgs(StylusDevice stylus, int timestamp);
    public StylusDevice get_StylusDevice();
    public bool get_InAir();
    public bool get_Inverted();
    public Point GetPosition(IInputElement relativeTo);
    public StylusPointCollection GetStylusPoints(IInputElement relativeTo);
    public StylusPointCollection GetStylusPoints(IInputElement relativeTo, StylusPointDescription subsetToReformatTo);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.StylusEventHandler : MulticastDelegate {
    public StylusEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.StylusPlugIns.DynamicRenderer : StylusPlugIn {
    public Visual RootVisual { get; }
    public DrawingAttributes DrawingAttributes { get; public set; }
    public Visual get_RootVisual();
    public DrawingAttributes get_DrawingAttributes();
    public void set_DrawingAttributes(DrawingAttributes value);
    public virtual void Reset(StylusDevice stylusDevice, StylusPointCollection stylusPoints);
    protected virtual void OnAdded();
    protected virtual void OnRemoved();
    protected virtual void OnIsActiveForInputChanged();
    protected virtual void OnStylusEnter(RawStylusInput rawStylusInput, bool confirmed);
    protected virtual void OnStylusLeave(RawStylusInput rawStylusInput, bool confirmed);
    protected virtual void OnEnabledChanged();
    protected virtual void OnStylusDown(RawStylusInput rawStylusInput);
    protected virtual void OnStylusMove(RawStylusInput rawStylusInput);
    protected virtual void OnStylusUp(RawStylusInput rawStylusInput);
    protected virtual void OnStylusDownProcessed(object callbackData, bool targetVerified);
    protected virtual void OnStylusUpProcessed(object callbackData, bool targetVerified);
    protected virtual void OnDraw(DrawingContext drawingContext, StylusPointCollection stylusPoints, Geometry geometry, Brush fillBrush);
    protected virtual void OnDrawingAttributesReplaced();
    protected Dispatcher GetDispatcher();
}
public class System.Windows.Input.StylusPlugIns.RawStylusInput : object {
    public int StylusDeviceId { get; }
    public int TabletDeviceId { get; }
    public int Timestamp { get; }
    public int get_StylusDeviceId();
    public int get_TabletDeviceId();
    public int get_Timestamp();
    public StylusPointCollection GetStylusPoints();
    [SecuritySafeCriticalAttribute]
public void SetStylusPoints(StylusPointCollection stylusPoints);
    public void NotifyWhenProcessed(object callbackData);
}
public abstract class System.Windows.Input.StylusPlugIns.StylusPlugIn : object {
    public UIElement Element { get; }
    public Rect ElementBounds { get; }
    public bool Enabled { get; public set; }
    public bool IsActiveForInput { get; }
    public UIElement get_Element();
    public Rect get_ElementBounds();
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public bool get_IsActiveForInput();
    protected virtual void OnAdded();
    protected virtual void OnRemoved();
    protected virtual void OnStylusEnter(RawStylusInput rawStylusInput, bool confirmed);
    protected virtual void OnStylusLeave(RawStylusInput rawStylusInput, bool confirmed);
    protected virtual void OnStylusDown(RawStylusInput rawStylusInput);
    protected virtual void OnStylusMove(RawStylusInput rawStylusInput);
    protected virtual void OnStylusUp(RawStylusInput rawStylusInput);
    protected virtual void OnStylusDownProcessed(object callbackData, bool targetVerified);
    protected virtual void OnStylusMoveProcessed(object callbackData, bool targetVerified);
    protected virtual void OnStylusUpProcessed(object callbackData, bool targetVerified);
    protected virtual void OnEnabledChanged();
    protected virtual void OnIsActiveForInputChanged();
}
public class System.Windows.Input.StylusPlugIns.StylusPlugInCollection : Collection`1<StylusPlugIn> {
    internal StylusPlugInCollection(UIElement element);
    protected virtual void InsertItem(int index, StylusPlugIn plugIn);
    protected virtual void ClearItems();
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, StylusPlugIn plugIn);
}
public class System.Windows.Input.StylusPoint : ValueType {
    private double _x;
    private double _y;
    private float _pressureFactor;
    private Int32[] _additionalValues;
    private StylusPointDescription _stylusPointDescription;
    public static double MaxXY;
    public static double MinXY;
    public double X { get; public set; }
    public double Y { get; public set; }
    public float PressureFactor { get; public set; }
    public StylusPointDescription Description { get; internal set; }
    public StylusPoint(double x, double y);
    public StylusPoint(double x, double y, float pressureFactor);
    public StylusPoint(double x, double y, float pressureFactor, StylusPointDescription stylusPointDescription, Int32[] additionalValues);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public float get_PressureFactor();
    public void set_PressureFactor(float value);
    public StylusPointDescription get_Description();
    internal void set_Description(StylusPointDescription value);
    public static Point op_Explicit(StylusPoint stylusPoint);
    public static bool op_Equality(StylusPoint stylusPoint1, StylusPoint stylusPoint2);
    public static bool op_Inequality(StylusPoint stylusPoint1, StylusPoint stylusPoint2);
    public bool HasProperty(StylusPointProperty stylusPointProperty);
    public int GetPropertyValue(StylusPointProperty stylusPointProperty);
    public void SetPropertyValue(StylusPointProperty stylusPointProperty, int value);
    public Point ToPoint();
    public static bool Equals(StylusPoint stylusPoint1, StylusPoint stylusPoint2);
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(StylusPoint value);
    public virtual int GetHashCode();
}
public class System.Windows.Input.StylusPointCollection : Collection`1<StylusPoint> {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler Changed;
    public StylusPointDescription Description { get; }
    public StylusPointCollection(int initialCapacity);
    public StylusPointCollection(StylusPointDescription stylusPointDescription);
    public StylusPointCollection(StylusPointDescription stylusPointDescription, int initialCapacity);
    public StylusPointCollection(IEnumerable`1<StylusPoint> stylusPoints);
    public StylusPointCollection(IEnumerable`1<Point> points);
    public StylusPointDescription get_Description();
    [CompilerGeneratedAttribute]
public void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Changed(EventHandler value);
    public static Point[] op_Explicit(StylusPointCollection stylusPoints);
    public void Add(StylusPointCollection stylusPoints);
    protected sealed virtual void ClearItems();
    protected sealed virtual void RemoveItem(int index);
    protected sealed virtual void InsertItem(int index, StylusPoint stylusPoint);
    protected sealed virtual void SetItem(int index, StylusPoint stylusPoint);
    public StylusPointCollection Clone();
    protected virtual void OnChanged(EventArgs e);
    public StylusPointCollection Reformat(StylusPointDescription subsetToReformatTo);
    public Int32[] ToHiMetricArray();
}
public class System.Windows.Input.StylusPointDescription : object {
    public int PropertyCount { get; }
    public StylusPointDescription(IEnumerable`1<StylusPointPropertyInfo> stylusPointPropertyInfos);
    public int get_PropertyCount();
    public bool HasProperty(StylusPointProperty stylusPointProperty);
    public StylusPointPropertyInfo GetPropertyInfo(StylusPointProperty stylusPointProperty);
    public ReadOnlyCollection`1<StylusPointPropertyInfo> GetStylusPointProperties();
    public static bool AreCompatible(StylusPointDescription stylusPointDescription1, StylusPointDescription stylusPointDescription2);
    public static StylusPointDescription GetCommonDescription(StylusPointDescription stylusPointDescription, StylusPointDescription stylusPointDescriptionPreserveInfo);
    public bool IsSubsetOf(StylusPointDescription stylusPointDescriptionSuperset);
}
public static class System.Windows.Input.StylusPointProperties : object {
    public static StylusPointProperty X;
    public static StylusPointProperty Y;
    public static StylusPointProperty Z;
    public static StylusPointProperty Width;
    public static StylusPointProperty Height;
    public static StylusPointProperty SystemTouch;
    public static StylusPointProperty PacketStatus;
    public static StylusPointProperty SerialNumber;
    public static StylusPointProperty NormalPressure;
    public static StylusPointProperty TangentPressure;
    public static StylusPointProperty ButtonPressure;
    public static StylusPointProperty XTiltOrientation;
    public static StylusPointProperty YTiltOrientation;
    public static StylusPointProperty AzimuthOrientation;
    public static StylusPointProperty AltitudeOrientation;
    public static StylusPointProperty TwistOrientation;
    public static StylusPointProperty PitchRotation;
    public static StylusPointProperty RollRotation;
    public static StylusPointProperty YawRotation;
    public static StylusPointProperty TipButton;
    public static StylusPointProperty BarrelButton;
    public static StylusPointProperty SecondaryTipButton;
}
public class System.Windows.Input.StylusPointProperty : object {
    public Guid Id { get; }
    public bool IsButton { get; }
    public StylusPointProperty(Guid identifier, bool isButton);
    protected StylusPointProperty(StylusPointProperty stylusPointProperty);
    public Guid get_Id();
    public bool get_IsButton();
    public virtual string ToString();
}
public class System.Windows.Input.StylusPointPropertyInfo : StylusPointProperty {
    public int Minimum { get; }
    public int Maximum { get; }
    public float Resolution { get; }
    public StylusPointPropertyUnit Unit { get; }
    public StylusPointPropertyInfo(StylusPointProperty stylusPointProperty);
    public StylusPointPropertyInfo(StylusPointProperty stylusPointProperty, int minimum, int maximum, StylusPointPropertyUnit unit, float resolution);
    public int get_Minimum();
    public int get_Maximum();
    public float get_Resolution();
    public StylusPointPropertyUnit get_Unit();
}
public enum System.Windows.Input.StylusPointPropertyUnit : Enum {
    public int value__;
    public static StylusPointPropertyUnit None;
    public static StylusPointPropertyUnit Inches;
    public static StylusPointPropertyUnit Centimeters;
    public static StylusPointPropertyUnit Degrees;
    public static StylusPointPropertyUnit Radians;
    public static StylusPointPropertyUnit Seconds;
    public static StylusPointPropertyUnit Pounds;
    public static StylusPointPropertyUnit Grams;
}
public class System.Windows.Input.StylusSystemGestureEventArgs : StylusEventArgs {
    public SystemGesture SystemGesture { get; }
    public StylusSystemGestureEventArgs(StylusDevice stylusDevice, int timestamp, SystemGesture systemGesture);
    public SystemGesture get_SystemGesture();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.StylusSystemGestureEventHandler : MulticastDelegate {
    public StylusSystemGestureEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusSystemGestureEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusSystemGestureEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Input.SystemGesture : Enum {
    public int value__;
    public static SystemGesture None;
    public static SystemGesture Tap;
    public static SystemGesture RightTap;
    public static SystemGesture Drag;
    public static SystemGesture RightDrag;
    public static SystemGesture HoldEnter;
    public static SystemGesture HoldLeave;
    public static SystemGesture HoverEnter;
    public static SystemGesture HoverLeave;
    public static SystemGesture Flick;
    public static SystemGesture TwoFingerTap;
}
public static class System.Windows.Input.Tablet : object {
    public static TabletDevice CurrentTabletDevice { get; }
    public static TabletDeviceCollection TabletDevices { get; }
    public static TabletDevice get_CurrentTabletDevice();
    [SecurityCriticalAttribute]
public static TabletDeviceCollection get_TabletDevices();
}
public class System.Windows.Input.TabletDevice : InputDevice {
    public IInputElement Target { get; }
    public PresentationSource ActiveSource { get; }
    public int Id { get; }
    public string Name { get; }
    public string ProductId { get; }
    public TabletHardwareCapabilities TabletHardwareCapabilities { get; }
    public ReadOnlyCollection`1<StylusPointProperty> SupportedStylusPointProperties { get; }
    public TabletDeviceType Type { get; }
    public StylusDeviceCollection StylusDevices { get; }
    public virtual IInputElement get_Target();
    [SecurityCriticalAttribute]
public virtual PresentationSource get_ActiveSource();
    public int get_Id();
    public string get_Name();
    public string get_ProductId();
    public TabletHardwareCapabilities get_TabletHardwareCapabilities();
    public ReadOnlyCollection`1<StylusPointProperty> get_SupportedStylusPointProperties();
    public TabletDeviceType get_Type();
    public StylusDeviceCollection get_StylusDevices();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Input.TabletDeviceCollection : object {
    public int Count { get; }
    public TabletDevice Item { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public sealed virtual int get_Count();
    public TabletDevice get_Item(int index);
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(TabletDevice[] array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum System.Windows.Input.TabletDeviceType : Enum {
    public int value__;
    public static TabletDeviceType Stylus;
    public static TabletDeviceType Touch;
}
[FlagsAttribute]
public enum System.Windows.Input.TabletHardwareCapabilities : Enum {
    public int value__;
    public static TabletHardwareCapabilities None;
    public static TabletHardwareCapabilities Integrated;
    public static TabletHardwareCapabilities StylusMustTouch;
    public static TabletHardwareCapabilities HardProximity;
    public static TabletHardwareCapabilities StylusHasPhysicalIds;
    public static TabletHardwareCapabilities SupportsPressure;
}
public class System.Windows.Input.TextComposition : DispatcherObject {
    [CLSCompliantAttribute("False")]
public string Text { get; protected set; }
    [CLSCompliantAttribute("False")]
public string CompositionText { get; protected set; }
    [CLSCompliantAttribute("False")]
public string SystemText { get; protected set; }
    [CLSCompliantAttribute("False")]
public string ControlText { get; protected set; }
    [CLSCompliantAttribute("False")]
public string SystemCompositionText { get; protected set; }
    public TextCompositionAutoComplete AutoComplete { get; }
    public TextComposition(InputManager inputManager, IInputElement source, string resultText);
    [SecurityCriticalAttribute]
public TextComposition(InputManager inputManager, IInputElement source, string resultText, TextCompositionAutoComplete autoComplete);
    public string get_Text();
    protected void set_Text(string value);
    public string get_CompositionText();
    protected void set_CompositionText(string value);
    public string get_SystemText();
    protected void set_SystemText(string value);
    public string get_ControlText();
    protected void set_ControlText(string value);
    public string get_SystemCompositionText();
    protected void set_SystemCompositionText(string value);
    public TextCompositionAutoComplete get_AutoComplete();
    [SecurityCriticalAttribute]
public virtual void Complete();
}
public enum System.Windows.Input.TextCompositionAutoComplete : Enum {
    public int value__;
    public static TextCompositionAutoComplete Off;
    public static TextCompositionAutoComplete On;
}
public class System.Windows.Input.TextCompositionEventArgs : InputEventArgs {
    public TextComposition TextComposition { get; }
    public string Text { get; }
    public string SystemText { get; }
    public string ControlText { get; }
    public TextCompositionEventArgs(InputDevice inputDevice, TextComposition composition);
    public TextComposition get_TextComposition();
    public string get_Text();
    public string get_SystemText();
    public string get_ControlText();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.TextCompositionEventHandler : MulticastDelegate {
    public TextCompositionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TextCompositionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TextCompositionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.TextCompositionManager : DispatcherObject {
    public static RoutedEvent PreviewTextInputStartEvent;
    public static RoutedEvent TextInputStartEvent;
    public static RoutedEvent PreviewTextInputUpdateEvent;
    public static RoutedEvent TextInputUpdateEvent;
    public static RoutedEvent PreviewTextInputEvent;
    public static RoutedEvent TextInputEvent;
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal TextCompositionManager(InputManager inputManager);
    public static void AddPreviewTextInputStartHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemovePreviewTextInputStartHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddTextInputStartHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemoveTextInputStartHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddPreviewTextInputUpdateHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemovePreviewTextInputUpdateHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddTextInputUpdateHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemoveTextInputUpdateHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddPreviewTextInputHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemovePreviewTextInputHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddTextInputHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemoveTextInputHandler(DependencyObject element, TextCompositionEventHandler handler);
    [SecurityCriticalAttribute]
public static bool StartComposition(TextComposition composition);
    [SecurityCriticalAttribute]
public static bool UpdateComposition(TextComposition composition);
    [SecurityCriticalAttribute]
public static bool CompleteComposition(TextComposition composition);
}
public static class System.Windows.Input.Touch : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static TouchFrameEventHandler FrameReported;
    [CompilerGeneratedAttribute]
public static void add_FrameReported(TouchFrameEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_FrameReported(TouchFrameEventHandler value);
}
public enum System.Windows.Input.TouchAction : Enum {
    public int value__;
    public static TouchAction Down;
    public static TouchAction Move;
    public static TouchAction Up;
}
public abstract class System.Windows.Input.TouchDevice : InputDevice {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler Activated;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler Deactivated;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler Updated;
    public int Id { get; }
    public bool IsActive { get; }
    public IInputElement Target { get; }
    public PresentationSource ActiveSource { get; }
    public IInputElement DirectlyOver { get; }
    public IInputElement Captured { get; }
    public CaptureMode CaptureMode { get; }
    private int System.Windows.Input.IManipulator.Id { get; }
    [SecurityCriticalAttribute]
protected TouchDevice(int deviceId);
    public int get_Id();
    public bool get_IsActive();
    public sealed virtual IInputElement get_Target();
    [SecurityCriticalAttribute]
public sealed virtual PresentationSource get_ActiveSource();
    public IInputElement get_DirectlyOver();
    public IInputElement get_Captured();
    public CaptureMode get_CaptureMode();
    private sealed virtual override int System.Windows.Input.IManipulator.get_Id();
    [CompilerGeneratedAttribute]
public void add_Activated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Activated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Deactivated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Deactivated(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Updated(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Updated(EventHandler value);
    [SecurityCriticalAttribute]
protected void SetActiveSource(PresentationSource activeSource);
    public abstract virtual TouchPoint GetTouchPoint(IInputElement relativeTo);
    public abstract virtual TouchPointCollection GetIntermediateTouchPoints(IInputElement relativeTo);
    public bool Capture(IInputElement element);
    public bool Capture(IInputElement element, CaptureMode captureMode);
    protected virtual void OnCapture(IInputElement element, CaptureMode captureMode);
    protected bool ReportDown();
    protected bool ReportMove();
    protected bool ReportUp();
    protected void Activate();
    protected void Deactivate();
    [SecurityCriticalAttribute]
public void Synchronize();
    [SecurityCriticalAttribute]
protected virtual void OnManipulationEnded(bool cancel);
    protected virtual void OnManipulationStarted();
    private sealed virtual override Point System.Windows.Input.IManipulator.GetPosition(IInputElement relativeTo);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Windows.Input.IManipulator.ManipulationEnded(bool cancel);
}
public class System.Windows.Input.TouchEventArgs : InputEventArgs {
    public TouchDevice TouchDevice { get; }
    public TouchEventArgs(TouchDevice touchDevice, int timestamp);
    public TouchDevice get_TouchDevice();
    public TouchPoint GetTouchPoint(IInputElement relativeTo);
    public TouchPointCollection GetIntermediateTouchPoints(IInputElement relativeTo);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.TouchFrameEventArgs : EventArgs {
    public int Timestamp { get; private set; }
    internal TouchFrameEventArgs(int timestamp);
    public int get_Timestamp();
    private void set_Timestamp(int value);
    public TouchPointCollection GetTouchPoints(IInputElement relativeTo);
    public TouchPoint GetPrimaryTouchPoint(IInputElement relativeTo);
    public void SuspendMousePromotionUntilTouchUp();
}
public class System.Windows.Input.TouchFrameEventHandler : MulticastDelegate {
    public TouchFrameEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TouchFrameEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TouchFrameEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.TouchPoint : object {
    public TouchDevice TouchDevice { get; private set; }
    public Point Position { get; private set; }
    public Rect Bounds { get; private set; }
    public Size Size { get; }
    public TouchAction Action { get; private set; }
    public TouchPoint(TouchDevice device, Point position, Rect bounds, TouchAction action);
    public TouchDevice get_TouchDevice();
    private void set_TouchDevice(TouchDevice value);
    public Point get_Position();
    private void set_Position(Point value);
    public Rect get_Bounds();
    private void set_Bounds(Rect value);
    public Size get_Size();
    public TouchAction get_Action();
    private void set_Action(TouchAction value);
    private sealed virtual override bool System.IEquatable<System.Windows.Input.TouchPoint>.Equals(TouchPoint other);
}
public class System.Windows.Input.TouchPointCollection : Collection`1<TouchPoint> {
}
public static class System.Windows.Interop.CursorInteropHelper : object {
    [SecurityCriticalAttribute]
public static Cursor Create(SafeHandle cursorHandle);
}
public class System.Windows.Interop.D3DImage : ImageSource {
    public static DependencyProperty IsFrontBufferAvailableProperty;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged;
    public bool IsFrontBufferAvailable { get; }
    public int PixelWidth { get; }
    public int PixelHeight { get; }
    public double Width { get; }
    public double Height { get; }
    public ImageMetadata Metadata { get; }
    [SecurityCriticalAttribute]
public D3DImage(double dpiX, double dpiY);
    public bool get_IsFrontBufferAvailable();
    public int get_PixelWidth();
    public int get_PixelHeight();
    public sealed virtual double get_Width();
    public sealed virtual double get_Height();
    public sealed virtual ImageMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public void add_IsFrontBufferAvailableChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsFrontBufferAvailableChanged(DependencyPropertyChangedEventHandler value);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual override void Finalize();
    public void SetBackBuffer(D3DResourceType backBufferType, IntPtr backBuffer);
    [SecurityCriticalAttribute]
public void SetBackBuffer(D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);
    public void Lock();
    public bool TryLock(Duration timeout);
    public void Unlock();
    [SecurityCriticalAttribute]
public void AddDirtyRect(Int32Rect dirtyRect);
    public D3DImage Clone();
    public D3DImage CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected sealed virtual bool FreezeCore(bool isChecking);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected internal virtual BitmapSource CopyBackBuffer();
}
public enum System.Windows.Interop.D3DResourceType : Enum {
    public int value__;
    public static D3DResourceType IDirect3DSurface9;
}
public class System.Windows.Interop.HwndSource : PresentationSource {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler Disposed;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler SizeToContentChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private AutoResizedEventHandler AutoResized;
    public bool IsDisposed { get; }
    public Visual RootVisual { get; public set; }
    public IEnumerable`1<IKeyboardInputSink> ChildKeyboardInputSinks { get; }
    public HwndTarget CompositionTarget { get; }
    public IntPtr Handle { get; }
    public SizeToContent SizeToContent { get; public set; }
    public bool UsesPerPixelOpacity { get; }
    protected IKeyboardInputSite KeyboardInputSiteCore { get; protected set; }
    private IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite { get; private set; }
    public RestoreFocusMode RestoreFocusMode { get; }
    public static bool DefaultAcquireHwndFocusInMenuMode { get; public set; }
    public bool AcquireHwndFocusInMenuMode { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private static HwndSource();
    [SecurityCriticalAttribute]
public HwndSource(int classStyle, int style, int exStyle, int x, int y, string name, IntPtr parent);
    [SecurityCriticalAttribute]
public HwndSource(int classStyle, int style, int exStyle, int x, int y, int width, int height, string name, IntPtr parent, bool adjustSizingForNonClientArea);
    [SecurityCriticalAttribute]
public HwndSource(int classStyle, int style, int exStyle, int x, int y, int width, int height, string name, IntPtr parent);
    [SecurityCriticalAttribute]
public HwndSource(HwndSourceParameters parameters);
    public virtual bool get_IsDisposed();
    [SecurityCriticalAttribute]
public virtual Visual get_RootVisual();
    [SecurityCriticalAttribute]
public virtual void set_RootVisual(Visual value);
    public IEnumerable`1<IKeyboardInputSink> get_ChildKeyboardInputSinks();
    [SecurityCriticalAttribute]
public HwndTarget get_CompositionTarget();
    [SecurityCriticalAttribute]
public sealed virtual IntPtr get_Handle();
    public SizeToContent get_SizeToContent();
    public void set_SizeToContent(SizeToContent value);
    [SecurityCriticalAttribute]
public bool get_UsesPerPixelOpacity();
    [SecurityCriticalAttribute]
protected IKeyboardInputSite get_KeyboardInputSiteCore();
    [SecurityCriticalAttribute]
protected void set_KeyboardInputSiteCore(IKeyboardInputSite value);
    private sealed virtual override IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.get_KeyboardInputSite();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Windows.Interop.IKeyboardInputSink.set_KeyboardInputSite(IKeyboardInputSite value);
    public RestoreFocusMode get_RestoreFocusMode();
    public static bool get_DefaultAcquireHwndFocusInMenuMode();
    public static void set_DefaultAcquireHwndFocusInMenuMode(bool value);
    public bool get_AcquireHwndFocusInMenuMode();
    [CompilerGeneratedAttribute]
public void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_SizeToContentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SizeToContentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_AutoResized(AutoResizedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AutoResized(AutoResizedEventHandler value);
    public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
public void AddHook(HwndSourceHook hook);
    [SecurityCriticalAttribute]
public void RemoveHook(HwndSourceHook hook);
    [SecurityCriticalAttribute]
public static HwndSource FromHwnd(IntPtr hwnd);
    [SecurityCriticalAttribute]
protected virtual CompositionTarget GetCompositionTargetCore();
    public HandleRef CreateHandleRef();
    [SecurityCriticalAttribute]
protected IKeyboardInputSite RegisterKeyboardInputSinkCore(IKeyboardInputSink sink);
    [SecurityCriticalAttribute]
private sealed virtual override IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink(IKeyboardInputSink sink);
    [SecurityCriticalAttribute]
protected virtual bool TranslateAcceleratorCore(MSG& msg, ModifierKeys modifiers);
    [SecurityCriticalAttribute]
private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(MSG& msg, ModifierKeys modifiers);
    protected virtual bool TabIntoCore(TraversalRequest request);
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.TabInto(TraversalRequest request);
    [SecurityCriticalAttribute]
protected virtual bool OnMnemonicCore(MSG& msg, ModifierKeys modifiers);
    [SecurityCriticalAttribute]
private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.OnMnemonic(MSG& msg, ModifierKeys modifiers);
    [SecurityCriticalAttribute]
protected virtual bool TranslateCharCore(MSG& msg, ModifierKeys modifiers);
    [SecurityCriticalAttribute]
private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.TranslateChar(MSG& msg, ModifierKeys modifiers);
    protected virtual bool HasFocusWithinCore();
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.HasFocusWithin();
}
public class System.Windows.Interop.HwndSourceHook : MulticastDelegate {
    public HwndSourceHook(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    public virtual IAsyncResult BeginInvoke(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(Boolean& handled, IAsyncResult result);
}
public class System.Windows.Interop.HwndSourceParameters : ValueType {
    private int _classStyleBits;
    private int _styleBits;
    private int _extendedStyleBits;
    private int _x;
    private int _y;
    private int _width;
    private int _height;
    private string _name;
    private IntPtr _parent;
    private HwndSourceHook _hwndSourceHook;
    private bool _adjustSizingForNonClientArea;
    private bool _hasAssignedSize;
    private bool _usesPerPixelOpacity;
    private Nullable`1<bool> _treatAsInputRoot;
    private bool _treatAncestorsAsNonClientArea;
    private Nullable`1<RestoreFocusMode> _restoreFocusMode;
    private Nullable`1<bool> _acquireHwndFocusInMenuMode;
    public int WindowClassStyle { get; public set; }
    public int WindowStyle { get; public set; }
    public int ExtendedWindowStyle { get; public set; }
    public int PositionX { get; public set; }
    public int PositionY { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public bool HasAssignedSize { get; }
    public string WindowName { get; public set; }
    public IntPtr ParentWindow { get; public set; }
    public HwndSourceHook HwndSourceHook { get; public set; }
    public bool AdjustSizingForNonClientArea { get; public set; }
    public bool TreatAncestorsAsNonClientArea { get; public set; }
    public bool UsesPerPixelOpacity { get; public set; }
    public RestoreFocusMode RestoreFocusMode { get; public set; }
    public bool AcquireHwndFocusInMenuMode { get; public set; }
    public bool TreatAsInputRoot { get; public set; }
    public HwndSourceParameters(string name);
    public HwndSourceParameters(string name, int width, int height);
    public int get_WindowClassStyle();
    public void set_WindowClassStyle(int value);
    public int get_WindowStyle();
    public void set_WindowStyle(int value);
    public int get_ExtendedWindowStyle();
    public void set_ExtendedWindowStyle(int value);
    public int get_PositionX();
    public void set_PositionX(int value);
    public int get_PositionY();
    public void set_PositionY(int value);
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public bool get_HasAssignedSize();
    public string get_WindowName();
    public void set_WindowName(string value);
    public IntPtr get_ParentWindow();
    public void set_ParentWindow(IntPtr value);
    public HwndSourceHook get_HwndSourceHook();
    public void set_HwndSourceHook(HwndSourceHook value);
    public bool get_AdjustSizingForNonClientArea();
    public void set_AdjustSizingForNonClientArea(bool value);
    public bool get_TreatAncestorsAsNonClientArea();
    public void set_TreatAncestorsAsNonClientArea(bool value);
    public bool get_UsesPerPixelOpacity();
    public void set_UsesPerPixelOpacity(bool value);
    public RestoreFocusMode get_RestoreFocusMode();
    public void set_RestoreFocusMode(RestoreFocusMode value);
    public bool get_AcquireHwndFocusInMenuMode();
    public void set_AcquireHwndFocusInMenuMode(bool value);
    public bool get_TreatAsInputRoot();
    public void set_TreatAsInputRoot(bool value);
    public static bool op_Equality(HwndSourceParameters a, HwndSourceParameters b);
    public static bool op_Inequality(HwndSourceParameters a, HwndSourceParameters b);
    public virtual int GetHashCode();
    public void SetPosition(int x, int y);
    public void SetSize(int width, int height);
    public virtual bool Equals(object obj);
    public bool Equals(HwndSourceParameters obj);
}
public class System.Windows.Interop.HwndTarget : CompositionTarget {
    public RenderMode RenderMode { get; public set; }
    unknown Visual RootVisual {public set; }
    public Matrix TransformToDevice { get; }
    public Matrix TransformFromDevice { get; }
    public Color BackgroundColor { get; public set; }
    public bool UsesPerPixelOpacity { get; internal set; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private static HwndTarget();
    [SecurityCriticalAttribute]
public HwndTarget(IntPtr hwnd);
    public RenderMode get_RenderMode();
    [SecurityCriticalAttribute]
public void set_RenderMode(RenderMode value);
    [SecurityCriticalAttribute]
public virtual void set_RootVisual(Visual value);
    public virtual Matrix get_TransformToDevice();
    public virtual Matrix get_TransformFromDevice();
    public Color get_BackgroundColor();
    public void set_BackgroundColor(Color value);
    public bool get_UsesPerPixelOpacity();
    internal void set_UsesPerPixelOpacity(bool value);
    [SecurityCriticalAttribute]
public virtual void Dispose();
}
public static class System.Windows.Interop.Imaging : object {
    [SecurityCriticalAttribute]
public static BitmapSource CreateBitmapSourceFromHBitmap(IntPtr bitmap, IntPtr palette, Int32Rect sourceRect, BitmapSizeOptions sizeOptions);
    [SecurityCriticalAttribute]
public static BitmapSource CreateBitmapSourceFromHIcon(IntPtr icon, Int32Rect sourceRect, BitmapSizeOptions sizeOptions);
    [SecurityCriticalAttribute]
public static BitmapSource CreateBitmapSourceFromMemorySection(IntPtr section, int pixelWidth, int pixelHeight, PixelFormat format, int stride, int offset);
}
public class System.Windows.Interop.InteropBitmap : BitmapSource {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void CloneCore(Freezable sourceFreezable);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    [SecurityCriticalAttribute]
public void Invalidate();
    [SecurityCriticalAttribute]
public void Invalidate(Nullable`1<Int32Rect> dirtyRect);
}
public interface System.Windows.Interop.IWin32Window {
    public IntPtr Handle { get; }
    public abstract virtual IntPtr get_Handle();
}
public enum System.Windows.Interop.RenderMode : Enum {
    public int value__;
    public static RenderMode Default;
    public static RenderMode SoftwareOnly;
}
public class System.Windows.KeySplineConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptor, Type destinationType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo cultureInfo, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo cultureInfo, object value, Type destinationType);
}
public class System.Windows.KeyTimeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type type);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type type);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
public enum System.Windows.LineBreakCondition : Enum {
    public int value__;
    public static LineBreakCondition BreakDesired;
    public static LineBreakCondition BreakPossible;
    public static LineBreakCondition BreakRestrained;
    public static LineBreakCondition BreakAlways;
}
[AttributeUsageAttribute("412")]
public class System.Windows.LocalizabilityAttribute : Attribute {
    private LocalizationCategory _category;
    private Readability _readability;
    private Modifiability _modifiability;
    public LocalizationCategory Category { get; }
    public Readability Readability { get; public set; }
    public Modifiability Modifiability { get; public set; }
    public LocalizabilityAttribute(LocalizationCategory category);
    public LocalizationCategory get_Category();
    public Readability get_Readability();
    public void set_Readability(Readability value);
    public Modifiability get_Modifiability();
    public void set_Modifiability(Modifiability value);
}
public enum System.Windows.LocalizationCategory : Enum {
    public int value__;
    public static LocalizationCategory None;
    public static LocalizationCategory Text;
    public static LocalizationCategory Title;
    public static LocalizationCategory Label;
    public static LocalizationCategory Button;
    public static LocalizationCategory CheckBox;
    public static LocalizationCategory ComboBox;
    public static LocalizationCategory ListBox;
    public static LocalizationCategory Menu;
    public static LocalizationCategory RadioButton;
    public static LocalizationCategory ToolTip;
    public static LocalizationCategory Hyperlink;
    public static LocalizationCategory TextFlow;
    public static LocalizationCategory XmlData;
    public static LocalizationCategory Font;
    public static LocalizationCategory Inherit;
    public static LocalizationCategory Ignore;
    public static LocalizationCategory NeverLocalize;
}
public interface System.Windows.Markup.IAddChild {
    public abstract virtual void AddChild(object value);
    public abstract virtual void AddText(string text);
}
[TypeConverterAttribute("System.Windows.Markup.XmlLanguageConverter")]
public class System.Windows.Markup.XmlLanguage : object {
    public static XmlLanguage Empty { get; }
    public string IetfLanguageTag { get; }
    public static XmlLanguage get_Empty();
    public string get_IetfLanguageTag();
    public static XmlLanguage GetLanguage(string ietfLanguageTag);
    public virtual string ToString();
    public CultureInfo GetEquivalentCulture();
    public CultureInfo GetSpecificCulture();
}
public class System.Windows.Markup.XmlLanguageConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
public enum System.Windows.Media.AlignmentX : Enum {
    public int value__;
    public static AlignmentX Left;
    public static AlignmentX Center;
    public static AlignmentX Right;
}
public enum System.Windows.Media.AlignmentY : Enum {
    public int value__;
    public static AlignmentY Top;
    public static AlignmentY Center;
    public static AlignmentY Bottom;
}
public abstract class System.Windows.Media.Animation.Animatable : Freezable {
    public bool HasAnimatedProperties { get; }
    public sealed virtual bool get_HasAnimatedProperties();
    public Animatable Clone();
    protected virtual bool FreezeCore(bool isChecking);
    [EditorBrowsableAttribute("1")]
public static bool ShouldSerializeStoredWeakReference(DependencyObject target);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public sealed virtual object GetAnimationBaseValue(DependencyProperty dp);
}
public class System.Windows.Media.Animation.AnimationClock : Clock {
    public AnimationTimeline Timeline { get; }
    protected internal AnimationClock(AnimationTimeline animation);
    public AnimationTimeline get_Timeline();
    public object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue);
}
public class System.Windows.Media.Animation.AnimationException : SystemException {
    public AnimationClock Clock { get; }
    public DependencyProperty Property { get; }
    public IAnimatable Target { get; }
    private AnimationException(SerializationInfo info, StreamingContext context);
    public AnimationClock get_Clock();
    public DependencyProperty get_Property();
    public IAnimatable get_Target();
}
public abstract class System.Windows.Media.Animation.AnimationTimeline : Timeline {
    public static DependencyProperty IsAdditiveProperty;
    public static DependencyProperty IsCumulativeProperty;
    public Type TargetPropertyType { get; }
    public bool IsDestinationDefault { get; }
    public abstract virtual Type get_TargetPropertyType();
    public virtual bool get_IsDestinationDefault();
    public AnimationTimeline Clone();
    protected internal virtual Clock AllocateClock();
    public AnimationClock CreateClock();
    public virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    protected virtual Duration GetNaturalDurationCore(Clock clock);
}
public class System.Windows.Media.Animation.BackEase : EasingFunctionBase {
    public static DependencyProperty AmplitudeProperty;
    public double Amplitude { get; public set; }
    public double get_Amplitude();
    public void set_Amplitude(double value);
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.Animation.BooleanAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public BooleanAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public bool GetCurrentValue(bool defaultOriginValue, bool defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual bool GetCurrentValueCore(bool defaultOriginValue, bool defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.BooleanAnimationUsingKeyFrames : BooleanAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public BooleanKeyFrameCollection KeyFrames { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public BooleanKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(BooleanKeyFrameCollection value);
    public BooleanAnimationUsingKeyFrames Clone();
    public BooleanAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual bool GetCurrentValueCore(bool defaultOriginValue, bool defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.BooleanKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public bool Value { get; public set; }
    protected BooleanKeyFrame(bool value);
    protected BooleanKeyFrame(bool value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public bool get_Value();
    public void set_Value(bool value);
    public bool InterpolateValue(bool baseValue, double keyFrameProgress);
    protected abstract virtual bool InterpolateValueCore(bool baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.BooleanKeyFrameCollection : Freezable {
    public static BooleanKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public BooleanKeyFrame Item { get; public set; }
    public static BooleanKeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public BooleanKeyFrame get_Item(int index);
    public void set_Item(int index, BooleanKeyFrame value);
    public BooleanKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(BooleanKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(BooleanKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(BooleanKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(BooleanKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, BooleanKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(BooleanKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
public class System.Windows.Media.Animation.BounceEase : EasingFunctionBase {
    public static DependencyProperty BouncesProperty;
    public static DependencyProperty BouncinessProperty;
    public int Bounces { get; public set; }
    public double Bounciness { get; public set; }
    public int get_Bounces();
    public void set_Bounces(int value);
    public double get_Bounciness();
    public void set_Bounciness(double value);
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.ByteAnimation : ByteAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<byte> From { get; public set; }
    public Nullable`1<byte> To { get; public set; }
    public Nullable`1<byte> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public ByteAnimation(byte toValue, Duration duration);
    public ByteAnimation(byte toValue, Duration duration, FillBehavior fillBehavior);
    public ByteAnimation(byte fromValue, byte toValue, Duration duration);
    public ByteAnimation(byte fromValue, byte toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<byte> get_From();
    public void set_From(Nullable`1<byte> value);
    public Nullable`1<byte> get_To();
    public void set_To(Nullable`1<byte> value);
    public Nullable`1<byte> get_By();
    public void set_By(Nullable`1<byte> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public ByteAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte GetCurrentValueCore(byte defaultOriginValue, byte defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.ByteAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public ByteAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public byte GetCurrentValue(byte defaultOriginValue, byte defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual byte GetCurrentValueCore(byte defaultOriginValue, byte defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.ByteAnimationUsingKeyFrames : ByteAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public ByteKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public ByteKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(ByteKeyFrameCollection value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public ByteAnimationUsingKeyFrames Clone();
    public ByteAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual byte GetCurrentValueCore(byte defaultOriginValue, byte defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.ByteKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public byte Value { get; public set; }
    protected ByteKeyFrame(byte value);
    protected ByteKeyFrame(byte value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public byte get_Value();
    public void set_Value(byte value);
    public byte InterpolateValue(byte baseValue, double keyFrameProgress);
    protected abstract virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.ByteKeyFrameCollection : Freezable {
    public static ByteKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ByteKeyFrame Item { get; public set; }
    public static ByteKeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public ByteKeyFrame get_Item(int index);
    public void set_Item(int index, ByteKeyFrame value);
    public ByteKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(ByteKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(ByteKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(ByteKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(ByteKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, ByteKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(ByteKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
public abstract class System.Windows.Media.Animation.CharAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public CharAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public char GetCurrentValue(char defaultOriginValue, char defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual char GetCurrentValueCore(char defaultOriginValue, char defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.CharAnimationUsingKeyFrames : CharAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public CharKeyFrameCollection KeyFrames { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public CharKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(CharKeyFrameCollection value);
    public CharAnimationUsingKeyFrames Clone();
    public CharAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual char GetCurrentValueCore(char defaultOriginValue, char defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.CharKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public char Value { get; public set; }
    protected CharKeyFrame(char value);
    protected CharKeyFrame(char value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public char get_Value();
    public void set_Value(char value);
    public char InterpolateValue(char baseValue, double keyFrameProgress);
    protected abstract virtual char InterpolateValueCore(char baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.CharKeyFrameCollection : Freezable {
    public static CharKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public CharKeyFrame Item { get; public set; }
    public static CharKeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public CharKeyFrame get_Item(int index);
    public void set_Item(int index, CharKeyFrame value);
    public CharKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(CharKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(CharKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(CharKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(CharKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, CharKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(CharKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
public class System.Windows.Media.Animation.CircleEase : EasingFunctionBase {
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.Clock : DispatcherObject {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler Completed;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler CurrentGlobalSpeedInvalidated;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler CurrentStateInvalidated;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler CurrentTimeInvalidated;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler RemoveRequested;
    public ClockController Controller { get; }
    public Nullable`1<int> CurrentIteration { get; }
    public Nullable`1<double> CurrentGlobalSpeed { get; }
    public Nullable`1<double> CurrentProgress { get; }
    public ClockState CurrentState { get; }
    public Nullable`1<TimeSpan> CurrentTime { get; }
    public bool HasControllableRoot { get; }
    public bool IsPaused { get; }
    public Duration NaturalDuration { get; }
    public Clock Parent { get; }
    public Timeline Timeline { get; }
    protected TimeSpan CurrentGlobalTime { get; }
    protected internal Clock(Timeline timeline);
    public ClockController get_Controller();
    public Nullable`1<int> get_CurrentIteration();
    public Nullable`1<double> get_CurrentGlobalSpeed();
    public Nullable`1<double> get_CurrentProgress();
    public ClockState get_CurrentState();
    public Nullable`1<TimeSpan> get_CurrentTime();
    public bool get_HasControllableRoot();
    public bool get_IsPaused();
    public Duration get_NaturalDuration();
    public Clock get_Parent();
    public Timeline get_Timeline();
    protected TimeSpan get_CurrentGlobalTime();
    [CompilerGeneratedAttribute]
public void add_Completed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Completed(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_CurrentGlobalSpeedInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CurrentGlobalSpeedInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_CurrentStateInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CurrentStateInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_CurrentTimeInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CurrentTimeInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_RemoveRequested(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_RemoveRequested(EventHandler value);
    protected virtual void DiscontinuousTimeMovement();
    protected virtual bool GetCanSlip();
    protected virtual TimeSpan GetCurrentTimeCore();
    protected virtual void SpeedChanged();
    protected virtual void Stopped();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.ClockCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public Clock Item { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public Clock get_Item(int index);
    public static bool op_Equality(ClockCollection objA, ClockCollection objB);
    public static bool op_Inequality(ClockCollection objA, ClockCollection objB);
    public sealed virtual void Clear();
    public sealed virtual void Add(Clock item);
    public sealed virtual bool Remove(Clock item);
    public sealed virtual bool Contains(Clock item);
    public sealed virtual void CopyTo(Clock[] array, int index);
    private sealed virtual override IEnumerator`1<Clock> System.Collections.Generic.IEnumerable<System.Windows.Media.Animation.Clock>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool Equals(object obj);
    public static bool Equals(ClockCollection objA, ClockCollection objB);
    public virtual int GetHashCode();
}
public class System.Windows.Media.Animation.ClockController : DispatcherObject {
    public Clock Clock { get; }
    public double SpeedRatio { get; public set; }
    internal ClockController(Clock owner);
    public Clock get_Clock();
    public double get_SpeedRatio();
    public void set_SpeedRatio(double value);
    public void Begin();
    public void SkipToFill();
    public void Pause();
    public void Resume();
    public void Seek(TimeSpan offset, TimeSeekOrigin origin);
    public void SeekAlignedToLastTick(TimeSpan offset, TimeSeekOrigin origin);
    public void Stop();
    public void Remove();
}
public class System.Windows.Media.Animation.ClockGroup : Clock {
    public TimelineGroup Timeline { get; }
    public ClockCollection Children { get; }
    protected internal ClockGroup(TimelineGroup timelineGroup);
    public TimelineGroup get_Timeline();
    public ClockCollection get_Children();
}
public enum System.Windows.Media.Animation.ClockState : Enum {
    public int value__;
    public static ClockState Active;
    public static ClockState Filling;
    public static ClockState Stopped;
}
public class System.Windows.Media.Animation.ColorAnimation : ColorAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Color> From { get; public set; }
    public Nullable`1<Color> To { get; public set; }
    public Nullable`1<Color> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public ColorAnimation(Color toValue, Duration duration);
    public ColorAnimation(Color toValue, Duration duration, FillBehavior fillBehavior);
    public ColorAnimation(Color fromValue, Color toValue, Duration duration);
    public ColorAnimation(Color fromValue, Color toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<Color> get_From();
    public void set_From(Nullable`1<Color> value);
    public Nullable`1<Color> get_To();
    public void set_To(Nullable`1<Color> value);
    public Nullable`1<Color> get_By();
    public void set_By(Nullable`1<Color> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public ColorAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color GetCurrentValueCore(Color defaultOriginValue, Color defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.ColorAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public ColorAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Color GetCurrentValue(Color defaultOriginValue, Color defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Color GetCurrentValueCore(Color defaultOriginValue, Color defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.ColorAnimationUsingKeyFrames : ColorAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public ColorKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public ColorKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(ColorKeyFrameCollection value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public ColorAnimationUsingKeyFrames Clone();
    public ColorAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Color GetCurrentValueCore(Color defaultOriginValue, Color defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.ColorKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Color Value { get; public set; }
    protected ColorKeyFrame(Color value);
    protected ColorKeyFrame(Color value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Color get_Value();
    public void set_Value(Color value);
    public Color InterpolateValue(Color baseValue, double keyFrameProgress);
    protected abstract virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.ColorKeyFrameCollection : Freezable {
    public static ColorKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ColorKeyFrame Item { get; public set; }
    public static ColorKeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public ColorKeyFrame get_Item(int index);
    public void set_Item(int index, ColorKeyFrame value);
    public ColorKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(ColorKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(ColorKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(ColorKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(ColorKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, ColorKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(ColorKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
public class System.Windows.Media.Animation.CubicEase : EasingFunctionBase {
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.DecimalAnimation : DecimalAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<decimal> From { get; public set; }
    public Nullable`1<decimal> To { get; public set; }
    public Nullable`1<decimal> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public DecimalAnimation(decimal toValue, Duration duration);
    public DecimalAnimation(decimal toValue, Duration duration, FillBehavior fillBehavior);
    public DecimalAnimation(decimal fromValue, decimal toValue, Duration duration);
    public DecimalAnimation(decimal fromValue, decimal toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<decimal> get_From();
    public void set_From(Nullable`1<decimal> value);
    public Nullable`1<decimal> get_To();
    public void set_To(Nullable`1<decimal> value);
    public Nullable`1<decimal> get_By();
    public void set_By(Nullable`1<decimal> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public DecimalAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal GetCurrentValueCore(decimal defaultOriginValue, decimal defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.DecimalAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public DecimalAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public decimal GetCurrentValue(decimal defaultOriginValue, decimal defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual decimal GetCurrentValueCore(decimal defaultOriginValue, decimal defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.DecimalAnimationUsingKeyFrames : DecimalAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public DecimalKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public DecimalKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(DecimalKeyFrameCollection value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public DecimalAnimationUsingKeyFrames Clone();
    public DecimalAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual decimal GetCurrentValueCore(decimal defaultOriginValue, decimal defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.DecimalKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public decimal Value { get; public set; }
    protected DecimalKeyFrame(decimal value);
    protected DecimalKeyFrame(decimal value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public decimal get_Value();
    public void set_Value(decimal value);
    public decimal InterpolateValue(decimal baseValue, double keyFrameProgress);
    protected abstract virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.DecimalKeyFrameCollection : Freezable {
    public static DecimalKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public DecimalKeyFrame Item { get; public set; }
    public static DecimalKeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public DecimalKeyFrame get_Item(int index);
    public void set_Item(int index, DecimalKeyFrame value);
    public DecimalKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(DecimalKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(DecimalKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(DecimalKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(DecimalKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, DecimalKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(DecimalKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
public class System.Windows.Media.Animation.DiscreteBooleanKeyFrame : BooleanKeyFrame {
    public DiscreteBooleanKeyFrame(bool value);
    public DiscreteBooleanKeyFrame(bool value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool InterpolateValueCore(bool baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteByteKeyFrame : ByteKeyFrame {
    public DiscreteByteKeyFrame(byte value);
    public DiscreteByteKeyFrame(byte value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteCharKeyFrame : CharKeyFrame {
    public DiscreteCharKeyFrame(char value);
    public DiscreteCharKeyFrame(char value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual char InterpolateValueCore(char baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteColorKeyFrame : ColorKeyFrame {
    public DiscreteColorKeyFrame(Color value);
    public DiscreteColorKeyFrame(Color value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteDecimalKeyFrame : DecimalKeyFrame {
    public DiscreteDecimalKeyFrame(decimal value);
    public DiscreteDecimalKeyFrame(decimal value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteDoubleKeyFrame : DoubleKeyFrame {
    public DiscreteDoubleKeyFrame(double value);
    public DiscreteDoubleKeyFrame(double value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteInt16KeyFrame : Int16KeyFrame {
    public DiscreteInt16KeyFrame(short value);
    public DiscreteInt16KeyFrame(short value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteInt32KeyFrame : Int32KeyFrame {
    public DiscreteInt32KeyFrame(int value);
    public DiscreteInt32KeyFrame(int value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteInt64KeyFrame : Int64KeyFrame {
    public DiscreteInt64KeyFrame(long value);
    public DiscreteInt64KeyFrame(long value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteMatrixKeyFrame : MatrixKeyFrame {
    public DiscreteMatrixKeyFrame(Matrix value);
    public DiscreteMatrixKeyFrame(Matrix value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Matrix InterpolateValueCore(Matrix baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteObjectKeyFrame : ObjectKeyFrame {
    public DiscreteObjectKeyFrame(object value);
    public DiscreteObjectKeyFrame(object value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual object InterpolateValueCore(object baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscretePoint3DKeyFrame : Point3DKeyFrame {
    public DiscretePoint3DKeyFrame(Point3D value);
    public DiscretePoint3DKeyFrame(Point3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscretePointKeyFrame : PointKeyFrame {
    public DiscretePointKeyFrame(Point value);
    public DiscretePointKeyFrame(Point value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteQuaternionKeyFrame : QuaternionKeyFrame {
    public DiscreteQuaternionKeyFrame(Quaternion value);
    public DiscreteQuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteRectKeyFrame : RectKeyFrame {
    public DiscreteRectKeyFrame(Rect value);
    public DiscreteRectKeyFrame(Rect value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteRotation3DKeyFrame : Rotation3DKeyFrame {
    public DiscreteRotation3DKeyFrame(Rotation3D value);
    public DiscreteRotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteSingleKeyFrame : SingleKeyFrame {
    public DiscreteSingleKeyFrame(float value);
    public DiscreteSingleKeyFrame(float value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteSizeKeyFrame : SizeKeyFrame {
    public DiscreteSizeKeyFrame(Size value);
    public DiscreteSizeKeyFrame(Size value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteStringKeyFrame : StringKeyFrame {
    public DiscreteStringKeyFrame(string value);
    public DiscreteStringKeyFrame(string value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual string InterpolateValueCore(string baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteVector3DKeyFrame : Vector3DKeyFrame {
    public DiscreteVector3DKeyFrame(Vector3D value);
    public DiscreteVector3DKeyFrame(Vector3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteVectorKeyFrame : VectorKeyFrame {
    public DiscreteVectorKeyFrame(Vector value);
    public DiscreteVectorKeyFrame(Vector value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DoubleAnimation : DoubleAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<double> From { get; public set; }
    public Nullable`1<double> To { get; public set; }
    public Nullable`1<double> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public DoubleAnimation(double toValue, Duration duration);
    public DoubleAnimation(double toValue, Duration duration, FillBehavior fillBehavior);
    public DoubleAnimation(double fromValue, double toValue, Duration duration);
    public DoubleAnimation(double fromValue, double toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<double> get_From();
    public void set_From(Nullable`1<double> value);
    public Nullable`1<double> get_To();
    public void set_To(Nullable`1<double> value);
    public Nullable`1<double> get_By();
    public void set_By(Nullable`1<double> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public DoubleAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual double GetCurrentValueCore(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.DoubleAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public DoubleAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public double GetCurrentValue(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual double GetCurrentValueCore(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.DoubleAnimationUsingKeyFrames : DoubleAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public DoubleKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public DoubleKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(DoubleKeyFrameCollection value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public DoubleAnimationUsingKeyFrames Clone();
    public DoubleAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual double GetCurrentValueCore(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public class System.Windows.Media.Animation.DoubleAnimationUsingPath : DoubleAnimationBase {
    public static DependencyProperty PathGeometryProperty;
    public static DependencyProperty SourceProperty;
    public PathGeometry PathGeometry { get; public set; }
    public PathAnimationSource Source { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public PathGeometry get_PathGeometry();
    public void set_PathGeometry(PathGeometry value);
    public PathAnimationSource get_Source();
    public void set_Source(PathAnimationSource value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public DoubleAnimationUsingPath Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void OnChanged();
    protected virtual double GetCurrentValueCore(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.DoubleKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public double Value { get; public set; }
    protected DoubleKeyFrame(double value);
    protected DoubleKeyFrame(double value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public double get_Value();
    public void set_Value(double value);
    public double InterpolateValue(double baseValue, double keyFrameProgress);
    protected abstract virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.DoubleKeyFrameCollection : Freezable {
    public static DoubleKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public DoubleKeyFrame Item { get; public set; }
    public static DoubleKeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public DoubleKeyFrame get_Item(int index);
    public void set_Item(int index, DoubleKeyFrame value);
    public DoubleKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(DoubleKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(DoubleKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(DoubleKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(DoubleKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, DoubleKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(DoubleKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
public class System.Windows.Media.Animation.EasingByteKeyFrame : ByteKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingByteKeyFrame(byte value);
    public EasingByteKeyFrame(byte value, KeyTime keyTime);
    public EasingByteKeyFrame(byte value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingColorKeyFrame : ColorKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingColorKeyFrame(Color value);
    public EasingColorKeyFrame(Color value, KeyTime keyTime);
    public EasingColorKeyFrame(Color value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingDecimalKeyFrame : DecimalKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingDecimalKeyFrame(decimal value);
    public EasingDecimalKeyFrame(decimal value, KeyTime keyTime);
    public EasingDecimalKeyFrame(decimal value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingDoubleKeyFrame : DoubleKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingDoubleKeyFrame(double value);
    public EasingDoubleKeyFrame(double value, KeyTime keyTime);
    public EasingDoubleKeyFrame(double value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
}
public abstract class System.Windows.Media.Animation.EasingFunctionBase : Freezable {
    public static DependencyProperty EasingModeProperty;
    public EasingMode EasingMode { get; public set; }
    public EasingMode get_EasingMode();
    public void set_EasingMode(EasingMode value);
    public sealed virtual double Ease(double normalizedTime);
    protected abstract virtual double EaseInCore(double normalizedTime);
}
public class System.Windows.Media.Animation.EasingInt16KeyFrame : Int16KeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingInt16KeyFrame(short value);
    public EasingInt16KeyFrame(short value, KeyTime keyTime);
    public EasingInt16KeyFrame(short value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingInt32KeyFrame : Int32KeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingInt32KeyFrame(int value);
    public EasingInt32KeyFrame(int value, KeyTime keyTime);
    public EasingInt32KeyFrame(int value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingInt64KeyFrame : Int64KeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingInt64KeyFrame(long value);
    public EasingInt64KeyFrame(long value, KeyTime keyTime);
    public EasingInt64KeyFrame(long value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
}
public enum System.Windows.Media.Animation.EasingMode : Enum {
    public int value__;
    public static EasingMode EaseIn;
    public static EasingMode EaseOut;
    public static EasingMode EaseInOut;
}
public class System.Windows.Media.Animation.EasingPoint3DKeyFrame : Point3DKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingPoint3DKeyFrame(Point3D value);
    public EasingPoint3DKeyFrame(Point3D value, KeyTime keyTime);
    public EasingPoint3DKeyFrame(Point3D value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingPointKeyFrame : PointKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingPointKeyFrame(Point value);
    public EasingPointKeyFrame(Point value, KeyTime keyTime);
    public EasingPointKeyFrame(Point value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingQuaternionKeyFrame : QuaternionKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty UseShortestPathProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public bool UseShortestPath { get; public set; }
    public EasingQuaternionKeyFrame(Quaternion value);
    public EasingQuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    public EasingQuaternionKeyFrame(Quaternion value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_UseShortestPath();
    public void set_UseShortestPath(bool value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingRectKeyFrame : RectKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingRectKeyFrame(Rect value);
    public EasingRectKeyFrame(Rect value, KeyTime keyTime);
    public EasingRectKeyFrame(Rect value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingRotation3DKeyFrame : Rotation3DKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingRotation3DKeyFrame(Rotation3D value);
    public EasingRotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    public EasingRotation3DKeyFrame(Rotation3D value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingSingleKeyFrame : SingleKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingSingleKeyFrame(float value);
    public EasingSingleKeyFrame(float value, KeyTime keyTime);
    public EasingSingleKeyFrame(float value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingSizeKeyFrame : SizeKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingSizeKeyFrame(Size value);
    public EasingSizeKeyFrame(Size value, KeyTime keyTime);
    public EasingSizeKeyFrame(Size value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingVector3DKeyFrame : Vector3DKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingVector3DKeyFrame(Vector3D value);
    public EasingVector3DKeyFrame(Vector3D value, KeyTime keyTime);
    public EasingVector3DKeyFrame(Vector3D value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingVectorKeyFrame : VectorKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingVectorKeyFrame(Vector value);
    public EasingVectorKeyFrame(Vector value, KeyTime keyTime);
    public EasingVectorKeyFrame(Vector value, KeyTime keyTime, IEasingFunction easingFunction);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.ElasticEase : EasingFunctionBase {
    public static DependencyProperty OscillationsProperty;
    public static DependencyProperty SpringinessProperty;
    public int Oscillations { get; public set; }
    public double Springiness { get; public set; }
    public int get_Oscillations();
    public void set_Oscillations(int value);
    public double get_Springiness();
    public void set_Springiness(double value);
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.ExponentialEase : EasingFunctionBase {
    public static DependencyProperty ExponentProperty;
    public double Exponent { get; public set; }
    public double get_Exponent();
    public void set_Exponent(double value);
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public enum System.Windows.Media.Animation.FillBehavior : Enum {
    public int value__;
    public static FillBehavior HoldEnd;
    public static FillBehavior Stop;
}
public enum System.Windows.Media.Animation.HandoffBehavior : Enum {
    public int value__;
    public static HandoffBehavior SnapshotAndReplace;
    public static HandoffBehavior Compose;
}
public interface System.Windows.Media.Animation.IAnimatable {
    public bool HasAnimatedProperties { get; }
    public abstract virtual bool get_HasAnimatedProperties();
    public abstract virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public abstract virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public abstract virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public abstract virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public abstract virtual object GetAnimationBaseValue(DependencyProperty dp);
}
public interface System.Windows.Media.Animation.IEasingFunction {
    public abstract virtual double Ease(double normalizedTime);
}
public interface System.Windows.Media.Animation.IKeyFrame {
    public KeyTime KeyTime { get; public set; }
    public object Value { get; public set; }
    public abstract virtual KeyTime get_KeyTime();
    public abstract virtual void set_KeyTime(KeyTime value);
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
public interface System.Windows.Media.Animation.IKeyFrameAnimation {
    public IList KeyFrames { get; public set; }
    public abstract virtual IList get_KeyFrames();
    public abstract virtual void set_KeyFrames(IList value);
}
public class System.Windows.Media.Animation.Int16Animation : Int16AnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<short> From { get; public set; }
    public Nullable`1<short> To { get; public set; }
    public Nullable`1<short> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Int16Animation(short toValue, Duration duration);
    public Int16Animation(short toValue, Duration duration, FillBehavior fillBehavior);
    public Int16Animation(short fromValue, short toValue, Duration duration);
    public Int16Animation(short fromValue, short toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<short> get_From();
    public void set_From(Nullable`1<short> value);
    public Nullable`1<short> get_To();
    public void set_To(Nullable`1<short> value);
    public Nullable`1<short> get_By();
    public void set_By(Nullable`1<short> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Int16Animation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual short GetCurrentValueCore(short defaultOriginValue, short defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.Int16AnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public Int16AnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public short GetCurrentValue(short defaultOriginValue, short defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual short GetCurrentValueCore(short defaultOriginValue, short defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Int16AnimationUsingKeyFrames : Int16AnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public Int16KeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public Int16KeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Int16KeyFrameCollection value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Int16AnimationUsingKeyFrames Clone();
    public Int16AnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual short GetCurrentValueCore(short defaultOriginValue, short defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.Int16KeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public short Value { get; public set; }
    protected Int16KeyFrame(short value);
    protected Int16KeyFrame(short value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public short get_Value();
    public void set_Value(short value);
    public short InterpolateValue(short baseValue, double keyFrameProgress);
    protected abstract virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Int16KeyFrameCollection : Freezable {
    public static Int16KeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Int16KeyFrame Item { get; public set; }
    public static Int16KeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public Int16KeyFrame get_Item(int index);
    public void set_Item(int index, Int16KeyFrame value);
    public Int16KeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Int16KeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(Int16KeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(Int16KeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(Int16KeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, Int16KeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(Int16KeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
public class System.Windows.Media.Animation.Int32Animation : Int32AnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<int> From { get; public set; }
    public Nullable`1<int> To { get; public set; }
    public Nullable`1<int> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Int32Animation(int toValue, Duration duration);
    public Int32Animation(int toValue, Duration duration, FillBehavior fillBehavior);
    public Int32Animation(int fromValue, int toValue, Duration duration);
    public Int32Animation(int fromValue, int toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<int> get_From();
    public void set_From(Nullable`1<int> value);
    public Nullable`1<int> get_To();
    public void set_To(Nullable`1<int> value);
    public Nullable`1<int> get_By();
    public void set_By(Nullable`1<int> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Int32Animation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual int GetCurrentValueCore(int defaultOriginValue, int defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.Int32AnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public Int32AnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public int GetCurrentValue(int defaultOriginValue, int defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual int GetCurrentValueCore(int defaultOriginValue, int defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Int32AnimationUsingKeyFrames : Int32AnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public Int32KeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public Int32KeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Int32KeyFrameCollection value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Int32AnimationUsingKeyFrames Clone();
    public Int32AnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual int GetCurrentValueCore(int defaultOriginValue, int defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.Int32KeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public int Value { get; public set; }
    protected Int32KeyFrame(int value);
    protected Int32KeyFrame(int value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public int get_Value();
    public void set_Value(int value);
    public int InterpolateValue(int baseValue, double keyFrameProgress);
    protected abstract virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Int32KeyFrameCollection : Freezable {
    public static Int32KeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Int32KeyFrame Item { get; public set; }
    public static Int32KeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public Int32KeyFrame get_Item(int index);
    public void set_Item(int index, Int32KeyFrame value);
    public Int32KeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Int32KeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(Int32KeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(Int32KeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(Int32KeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, Int32KeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(Int32KeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
public class System.Windows.Media.Animation.Int64Animation : Int64AnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<long> From { get; public set; }
    public Nullable`1<long> To { get; public set; }
    public Nullable`1<long> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Int64Animation(long toValue, Duration duration);
    public Int64Animation(long toValue, Duration duration, FillBehavior fillBehavior);
    public Int64Animation(long fromValue, long toValue, Duration duration);
    public Int64Animation(long fromValue, long toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<long> get_From();
    public void set_From(Nullable`1<long> value);
    public Nullable`1<long> get_To();
    public void set_To(Nullable`1<long> value);
    public Nullable`1<long> get_By();
    public void set_By(Nullable`1<long> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Int64Animation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual long GetCurrentValueCore(long defaultOriginValue, long defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.Int64AnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public Int64AnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public long GetCurrentValue(long defaultOriginValue, long defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual long GetCurrentValueCore(long defaultOriginValue, long defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Int64AnimationUsingKeyFrames : Int64AnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public Int64KeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public Int64KeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Int64KeyFrameCollection value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Int64AnimationUsingKeyFrames Clone();
    public Int64AnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual long GetCurrentValueCore(long defaultOriginValue, long defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.Int64KeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public long Value { get; public set; }
    protected Int64KeyFrame(long value);
    protected Int64KeyFrame(long value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public long get_Value();
    public void set_Value(long value);
    public long InterpolateValue(long baseValue, double keyFrameProgress);
    protected abstract virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Int64KeyFrameCollection : Freezable {
    public static Int64KeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Int64KeyFrame Item { get; public set; }
    public static Int64KeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public Int64KeyFrame get_Item(int index);
    public void set_Item(int index, Int64KeyFrame value);
    public Int64KeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Int64KeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(Int64KeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(Int64KeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(Int64KeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, Int64KeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(Int64KeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
[LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.KeySplineConverter")]
public class System.Windows.Media.Animation.KeySpline : Freezable {
    public Point ControlPoint1 { get; public set; }
    public Point ControlPoint2 { get; public set; }
    public KeySpline(double x1, double y1, double x2, double y2);
    public KeySpline(Point controlPoint1, Point controlPoint2);
    public Point get_ControlPoint1();
    public void set_ControlPoint1(Point value);
    public Point get_ControlPoint2();
    public void set_ControlPoint2(Point value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual void OnChanged();
    public double GetSplineProgress(double linearProgress);
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
}
[TypeConverterAttribute("System.Windows.KeyTimeConverter")]
public class System.Windows.Media.Animation.KeyTime : ValueType {
    private object _value;
    private KeyTimeType _type;
    public static KeyTime Uniform { get; }
    public static KeyTime Paced { get; }
    public TimeSpan TimeSpan { get; }
    public double Percent { get; }
    public KeyTimeType Type { get; }
    public static KeyTime get_Uniform();
    public static KeyTime get_Paced();
    public TimeSpan get_TimeSpan();
    public double get_Percent();
    public KeyTimeType get_Type();
    public static KeyTime op_Implicit(TimeSpan timeSpan);
    public static bool op_Equality(KeyTime keyTime1, KeyTime keyTime2);
    public static bool op_Inequality(KeyTime keyTime1, KeyTime keyTime2);
    public static KeyTime FromPercent(double percent);
    public static KeyTime FromTimeSpan(TimeSpan timeSpan);
    public static bool Equals(KeyTime keyTime1, KeyTime keyTime2);
    public sealed virtual bool Equals(KeyTime value);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum System.Windows.Media.Animation.KeyTimeType : Enum {
    public byte value__;
    public static KeyTimeType Uniform;
    public static KeyTimeType Percent;
    public static KeyTimeType TimeSpan;
    public static KeyTimeType Paced;
}
public class System.Windows.Media.Animation.LinearByteKeyFrame : ByteKeyFrame {
    public LinearByteKeyFrame(byte value);
    public LinearByteKeyFrame(byte value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearColorKeyFrame : ColorKeyFrame {
    public LinearColorKeyFrame(Color value);
    public LinearColorKeyFrame(Color value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearDecimalKeyFrame : DecimalKeyFrame {
    public LinearDecimalKeyFrame(decimal value);
    public LinearDecimalKeyFrame(decimal value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearDoubleKeyFrame : DoubleKeyFrame {
    public LinearDoubleKeyFrame(double value);
    public LinearDoubleKeyFrame(double value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearInt16KeyFrame : Int16KeyFrame {
    public LinearInt16KeyFrame(short value);
    public LinearInt16KeyFrame(short value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearInt32KeyFrame : Int32KeyFrame {
    public LinearInt32KeyFrame(int value);
    public LinearInt32KeyFrame(int value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearInt64KeyFrame : Int64KeyFrame {
    public LinearInt64KeyFrame(long value);
    public LinearInt64KeyFrame(long value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearPoint3DKeyFrame : Point3DKeyFrame {
    public LinearPoint3DKeyFrame(Point3D value);
    public LinearPoint3DKeyFrame(Point3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearPointKeyFrame : PointKeyFrame {
    public LinearPointKeyFrame(Point value);
    public LinearPointKeyFrame(Point value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearQuaternionKeyFrame : QuaternionKeyFrame {
    public static DependencyProperty UseShortestPathProperty;
    public bool UseShortestPath { get; public set; }
    public LinearQuaternionKeyFrame(Quaternion value);
    public LinearQuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    public bool get_UseShortestPath();
    public void set_UseShortestPath(bool value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearRectKeyFrame : RectKeyFrame {
    public LinearRectKeyFrame(Rect value);
    public LinearRectKeyFrame(Rect value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearRotation3DKeyFrame : Rotation3DKeyFrame {
    public LinearRotation3DKeyFrame(Rotation3D value);
    public LinearRotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearSingleKeyFrame : SingleKeyFrame {
    public LinearSingleKeyFrame(float value);
    public LinearSingleKeyFrame(float value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearSizeKeyFrame : SizeKeyFrame {
    public LinearSizeKeyFrame(Size value);
    public LinearSizeKeyFrame(Size value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearVector3DKeyFrame : Vector3DKeyFrame {
    public LinearVector3DKeyFrame(Vector3D value);
    public LinearVector3DKeyFrame(Vector3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearVectorKeyFrame : VectorKeyFrame {
    public LinearVectorKeyFrame(Vector value);
    public LinearVectorKeyFrame(Vector value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
}
public abstract class System.Windows.Media.Animation.MatrixAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public MatrixAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Matrix GetCurrentValue(Matrix defaultOriginValue, Matrix defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Matrix GetCurrentValueCore(Matrix defaultOriginValue, Matrix defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.MatrixAnimationUsingKeyFrames : MatrixAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public MatrixKeyFrameCollection KeyFrames { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public MatrixKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(MatrixKeyFrameCollection value);
    public MatrixAnimationUsingKeyFrames Clone();
    public MatrixAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Matrix GetCurrentValueCore(Matrix defaultOriginValue, Matrix defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public class System.Windows.Media.Animation.MatrixAnimationUsingPath : MatrixAnimationBase {
    public static DependencyProperty DoesRotateWithTangentProperty;
    public static DependencyProperty IsAngleCumulativeProperty;
    public static DependencyProperty IsOffsetCumulativeProperty;
    public static DependencyProperty PathGeometryProperty;
    public bool DoesRotateWithTangent { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsAngleCumulative { get; public set; }
    public bool IsOffsetCumulative { get; public set; }
    public PathGeometry PathGeometry { get; public set; }
    public bool get_DoesRotateWithTangent();
    public void set_DoesRotateWithTangent(bool value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsAngleCumulative();
    public void set_IsAngleCumulative(bool value);
    public bool get_IsOffsetCumulative();
    public void set_IsOffsetCumulative(bool value);
    public PathGeometry get_PathGeometry();
    public void set_PathGeometry(PathGeometry value);
    public MatrixAnimationUsingPath Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void OnChanged();
    protected virtual Matrix GetCurrentValueCore(Matrix defaultOriginValue, Matrix defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.MatrixKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Matrix Value { get; public set; }
    protected MatrixKeyFrame(Matrix value);
    protected MatrixKeyFrame(Matrix value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Matrix get_Value();
    public void set_Value(Matrix value);
    public Matrix InterpolateValue(Matrix baseValue, double keyFrameProgress);
    protected abstract virtual Matrix InterpolateValueCore(Matrix baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.MatrixKeyFrameCollection : Freezable {
    public static MatrixKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public MatrixKeyFrame Item { get; public set; }
    public static MatrixKeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public MatrixKeyFrame get_Item(int index);
    public void set_Item(int index, MatrixKeyFrame value);
    public MatrixKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(MatrixKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(MatrixKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(MatrixKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(MatrixKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, MatrixKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(MatrixKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
public abstract class System.Windows.Media.Animation.ObjectAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public ObjectAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual object GetCurrentValueCore(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.ObjectAnimationUsingKeyFrames : ObjectAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public ObjectKeyFrameCollection KeyFrames { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public ObjectKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(ObjectKeyFrameCollection value);
    public ObjectAnimationUsingKeyFrames Clone();
    public ObjectAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual object GetCurrentValueCore(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.ObjectKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public object Value { get; public set; }
    protected ObjectKeyFrame(object value);
    protected ObjectKeyFrame(object value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public object get_Value();
    public void set_Value(object value);
    public object InterpolateValue(object baseValue, double keyFrameProgress);
    protected abstract virtual object InterpolateValueCore(object baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.ObjectKeyFrameCollection : Freezable {
    public static ObjectKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ObjectKeyFrame Item { get; public set; }
    public static ObjectKeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public ObjectKeyFrame get_Item(int index);
    public void set_Item(int index, ObjectKeyFrame value);
    public ObjectKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(ObjectKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(ObjectKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(ObjectKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(ObjectKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, ObjectKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(ObjectKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
public class System.Windows.Media.Animation.ParallelTimeline : TimelineGroup {
    public static DependencyProperty SlipBehaviorProperty;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public SlipBehavior SlipBehavior { get; public set; }
    public ParallelTimeline(Nullable`1<TimeSpan> beginTime);
    public ParallelTimeline(Nullable`1<TimeSpan> beginTime, Duration duration);
    public ParallelTimeline(Nullable`1<TimeSpan> beginTime, Duration duration, RepeatBehavior repeatBehavior);
    public SlipBehavior get_SlipBehavior();
    public void set_SlipBehavior(SlipBehavior value);
    public ParallelTimeline Clone();
    public ParallelTimeline CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Duration GetNaturalDurationCore(Clock clock);
}
public enum System.Windows.Media.Animation.PathAnimationSource : Enum {
    public byte value__;
    public static PathAnimationSource X;
    public static PathAnimationSource Y;
    public static PathAnimationSource Angle;
}
public class System.Windows.Media.Animation.Point3DAnimation : Point3DAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Point3D> From { get; public set; }
    public Nullable`1<Point3D> To { get; public set; }
    public Nullable`1<Point3D> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Point3DAnimation(Point3D toValue, Duration duration);
    public Point3DAnimation(Point3D toValue, Duration duration, FillBehavior fillBehavior);
    public Point3DAnimation(Point3D fromValue, Point3D toValue, Duration duration);
    public Point3DAnimation(Point3D fromValue, Point3D toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<Point3D> get_From();
    public void set_From(Nullable`1<Point3D> value);
    public Nullable`1<Point3D> get_To();
    public void set_To(Nullable`1<Point3D> value);
    public Nullable`1<Point3D> get_By();
    public void set_By(Nullable`1<Point3D> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Point3DAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D GetCurrentValueCore(Point3D defaultOriginValue, Point3D defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.Point3DAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public Point3DAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Point3D GetCurrentValue(Point3D defaultOriginValue, Point3D defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Point3D GetCurrentValueCore(Point3D defaultOriginValue, Point3D defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Point3DAnimationUsingKeyFrames : Point3DAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public Point3DKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public Point3DKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Point3DKeyFrameCollection value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Point3DAnimationUsingKeyFrames Clone();
    public Point3DAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Point3D GetCurrentValueCore(Point3D defaultOriginValue, Point3D defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.Point3DKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Point3D Value { get; public set; }
    protected Point3DKeyFrame(Point3D value);
    protected Point3DKeyFrame(Point3D value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Point3D get_Value();
    public void set_Value(Point3D value);
    public Point3D InterpolateValue(Point3D baseValue, double keyFrameProgress);
    protected abstract virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Point3DKeyFrameCollection : Freezable {
    public static Point3DKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Point3DKeyFrame Item { get; public set; }
    public static Point3DKeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public Point3DKeyFrame get_Item(int index);
    public void set_Item(int index, Point3DKeyFrame value);
    public Point3DKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Point3DKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(Point3DKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(Point3DKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(Point3DKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, Point3DKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(Point3DKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
public class System.Windows.Media.Animation.PointAnimation : PointAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Point> From { get; public set; }
    public Nullable`1<Point> To { get; public set; }
    public Nullable`1<Point> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public PointAnimation(Point toValue, Duration duration);
    public PointAnimation(Point toValue, Duration duration, FillBehavior fillBehavior);
    public PointAnimation(Point fromValue, Point toValue, Duration duration);
    public PointAnimation(Point fromValue, Point toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<Point> get_From();
    public void set_From(Nullable`1<Point> value);
    public Nullable`1<Point> get_To();
    public void set_To(Nullable`1<Point> value);
    public Nullable`1<Point> get_By();
    public void set_By(Nullable`1<Point> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public PointAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point GetCurrentValueCore(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.PointAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public PointAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Point GetCurrentValue(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Point GetCurrentValueCore(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.PointAnimationUsingKeyFrames : PointAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public PointKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public PointKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(PointKeyFrameCollection value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public PointAnimationUsingKeyFrames Clone();
    public PointAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Point GetCurrentValueCore(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public class System.Windows.Media.Animation.PointAnimationUsingPath : PointAnimationBase {
    public static DependencyProperty PathGeometryProperty;
    public PathGeometry PathGeometry { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public PathGeometry get_PathGeometry();
    public void set_PathGeometry(PathGeometry value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public PointAnimationUsingPath Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void OnChanged();
    protected virtual Point GetCurrentValueCore(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.PointKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Point Value { get; public set; }
    protected PointKeyFrame(Point value);
    protected PointKeyFrame(Point value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Point get_Value();
    public void set_Value(Point value);
    public Point InterpolateValue(Point baseValue, double keyFrameProgress);
    protected abstract virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.PointKeyFrameCollection : Freezable {
    public static PointKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public PointKeyFrame Item { get; public set; }
    public static PointKeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public PointKeyFrame get_Item(int index);
    public void set_Item(int index, PointKeyFrame value);
    public PointKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(PointKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(PointKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(PointKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(PointKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, PointKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(PointKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
public class System.Windows.Media.Animation.PowerEase : EasingFunctionBase {
    public static DependencyProperty PowerProperty;
    public double Power { get; public set; }
    public double get_Power();
    public void set_Power(double value);
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.QuadraticEase : EasingFunctionBase {
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.QuarticEase : EasingFunctionBase {
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.QuaternionAnimation : QuaternionAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty UseShortestPathProperty;
    public Nullable`1<Quaternion> From { get; public set; }
    public Nullable`1<Quaternion> To { get; public set; }
    public Nullable`1<Quaternion> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public bool UseShortestPath { get; public set; }
    public QuaternionAnimation(Quaternion toValue, Duration duration);
    public QuaternionAnimation(Quaternion toValue, Duration duration, FillBehavior fillBehavior);
    public QuaternionAnimation(Quaternion fromValue, Quaternion toValue, Duration duration);
    public QuaternionAnimation(Quaternion fromValue, Quaternion toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<Quaternion> get_From();
    public void set_From(Nullable`1<Quaternion> value);
    public Nullable`1<Quaternion> get_To();
    public void set_To(Nullable`1<Quaternion> value);
    public Nullable`1<Quaternion> get_By();
    public void set_By(Nullable`1<Quaternion> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public bool get_UseShortestPath();
    public void set_UseShortestPath(bool value);
    public QuaternionAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion GetCurrentValueCore(Quaternion defaultOriginValue, Quaternion defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.QuaternionAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public QuaternionAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Quaternion GetCurrentValue(Quaternion defaultOriginValue, Quaternion defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Quaternion GetCurrentValueCore(Quaternion defaultOriginValue, Quaternion defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.QuaternionAnimationUsingKeyFrames : QuaternionAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public QuaternionKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public QuaternionKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(QuaternionKeyFrameCollection value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public QuaternionAnimationUsingKeyFrames Clone();
    public QuaternionAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Quaternion GetCurrentValueCore(Quaternion defaultOriginValue, Quaternion defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.QuaternionKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Quaternion Value { get; public set; }
    protected QuaternionKeyFrame(Quaternion value);
    protected QuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Quaternion get_Value();
    public void set_Value(Quaternion value);
    public Quaternion InterpolateValue(Quaternion baseValue, double keyFrameProgress);
    protected abstract virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.QuaternionKeyFrameCollection : Freezable {
    public static QuaternionKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public QuaternionKeyFrame Item { get; public set; }
    public static QuaternionKeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public QuaternionKeyFrame get_Item(int index);
    public void set_Item(int index, QuaternionKeyFrame value);
    public QuaternionKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(QuaternionKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(QuaternionKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(QuaternionKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(QuaternionKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, QuaternionKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(QuaternionKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
public class System.Windows.Media.Animation.QuinticEase : EasingFunctionBase {
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.RectAnimation : RectAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Rect> From { get; public set; }
    public Nullable`1<Rect> To { get; public set; }
    public Nullable`1<Rect> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public RectAnimation(Rect toValue, Duration duration);
    public RectAnimation(Rect toValue, Duration duration, FillBehavior fillBehavior);
    public RectAnimation(Rect fromValue, Rect toValue, Duration duration);
    public RectAnimation(Rect fromValue, Rect toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<Rect> get_From();
    public void set_From(Nullable`1<Rect> value);
    public Nullable`1<Rect> get_To();
    public void set_To(Nullable`1<Rect> value);
    public Nullable`1<Rect> get_By();
    public void set_By(Nullable`1<Rect> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public RectAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect GetCurrentValueCore(Rect defaultOriginValue, Rect defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.RectAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public RectAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Rect GetCurrentValue(Rect defaultOriginValue, Rect defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Rect GetCurrentValueCore(Rect defaultOriginValue, Rect defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.RectAnimationUsingKeyFrames : RectAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public RectKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public RectKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(RectKeyFrameCollection value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public RectAnimationUsingKeyFrames Clone();
    public RectAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Rect GetCurrentValueCore(Rect defaultOriginValue, Rect defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.RectKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Rect Value { get; public set; }
    protected RectKeyFrame(Rect value);
    protected RectKeyFrame(Rect value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Rect get_Value();
    public void set_Value(Rect value);
    public Rect InterpolateValue(Rect baseValue, double keyFrameProgress);
    protected abstract virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.RectKeyFrameCollection : Freezable {
    public static RectKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public RectKeyFrame Item { get; public set; }
    public static RectKeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public RectKeyFrame get_Item(int index);
    public void set_Item(int index, RectKeyFrame value);
    public RectKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(RectKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(RectKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(RectKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(RectKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, RectKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(RectKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
[TypeConverterAttribute("System.Windows.Media.Animation.RepeatBehaviorConverter")]
public class System.Windows.Media.Animation.RepeatBehavior : ValueType {
    private double _iterationCount;
    private TimeSpan _repeatDuration;
    private RepeatBehaviorType _type;
    public static RepeatBehavior Forever { get; }
    public bool HasCount { get; }
    public bool HasDuration { get; }
    public double Count { get; }
    public TimeSpan Duration { get; }
    public RepeatBehavior(double count);
    public RepeatBehavior(TimeSpan duration);
    public static RepeatBehavior get_Forever();
    public bool get_HasCount();
    public bool get_HasDuration();
    public double get_Count();
    public TimeSpan get_Duration();
    public static bool op_Equality(RepeatBehavior repeatBehavior1, RepeatBehavior repeatBehavior2);
    public static bool op_Inequality(RepeatBehavior repeatBehavior1, RepeatBehavior repeatBehavior2);
    public virtual bool Equals(object value);
    public bool Equals(RepeatBehavior repeatBehavior);
    public static bool Equals(RepeatBehavior repeatBehavior1, RepeatBehavior repeatBehavior2);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
}
public class System.Windows.Media.Animation.RepeatBehaviorConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo cultureInfo, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo cultureInfo, object value, Type destinationType);
}
public class System.Windows.Media.Animation.Rotation3DAnimation : Rotation3DAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Rotation3D From { get; public set; }
    public Rotation3D To { get; public set; }
    public Rotation3D By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Rotation3DAnimation(Rotation3D toValue, Duration duration);
    public Rotation3DAnimation(Rotation3D toValue, Duration duration, FillBehavior fillBehavior);
    public Rotation3DAnimation(Rotation3D fromValue, Rotation3D toValue, Duration duration);
    public Rotation3DAnimation(Rotation3D fromValue, Rotation3D toValue, Duration duration, FillBehavior fillBehavior);
    public Rotation3D get_From();
    public void set_From(Rotation3D value);
    public Rotation3D get_To();
    public void set_To(Rotation3D value);
    public Rotation3D get_By();
    public void set_By(Rotation3D value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Rotation3DAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D GetCurrentValueCore(Rotation3D defaultOriginValue, Rotation3D defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.Rotation3DAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public Rotation3DAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Rotation3D GetCurrentValue(Rotation3D defaultOriginValue, Rotation3D defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Rotation3D GetCurrentValueCore(Rotation3D defaultOriginValue, Rotation3D defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames : Rotation3DAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public Rotation3DKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public Rotation3DKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Rotation3DKeyFrameCollection value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Rotation3DAnimationUsingKeyFrames Clone();
    public Rotation3DAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Rotation3D GetCurrentValueCore(Rotation3D defaultOriginValue, Rotation3D defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.Rotation3DKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Rotation3D Value { get; public set; }
    protected Rotation3DKeyFrame(Rotation3D value);
    protected Rotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Rotation3D get_Value();
    public void set_Value(Rotation3D value);
    public Rotation3D InterpolateValue(Rotation3D baseValue, double keyFrameProgress);
    protected abstract virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Rotation3DKeyFrameCollection : Freezable {
    public static Rotation3DKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Rotation3DKeyFrame Item { get; public set; }
    public static Rotation3DKeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public Rotation3DKeyFrame get_Item(int index);
    public void set_Item(int index, Rotation3DKeyFrame value);
    public Rotation3DKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Rotation3DKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(Rotation3DKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(Rotation3DKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(Rotation3DKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, Rotation3DKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(Rotation3DKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
public class System.Windows.Media.Animation.SineEase : EasingFunctionBase {
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.SingleAnimation : SingleAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<float> From { get; public set; }
    public Nullable`1<float> To { get; public set; }
    public Nullable`1<float> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public SingleAnimation(float toValue, Duration duration);
    public SingleAnimation(float toValue, Duration duration, FillBehavior fillBehavior);
    public SingleAnimation(float fromValue, float toValue, Duration duration);
    public SingleAnimation(float fromValue, float toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<float> get_From();
    public void set_From(Nullable`1<float> value);
    public Nullable`1<float> get_To();
    public void set_To(Nullable`1<float> value);
    public Nullable`1<float> get_By();
    public void set_By(Nullable`1<float> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public SingleAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual float GetCurrentValueCore(float defaultOriginValue, float defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.SingleAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public SingleAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public float GetCurrentValue(float defaultOriginValue, float defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual float GetCurrentValueCore(float defaultOriginValue, float defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.SingleAnimationUsingKeyFrames : SingleAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public SingleKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public SingleKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(SingleKeyFrameCollection value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public SingleAnimationUsingKeyFrames Clone();
    public SingleAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual float GetCurrentValueCore(float defaultOriginValue, float defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.SingleKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public float Value { get; public set; }
    protected SingleKeyFrame(float value);
    protected SingleKeyFrame(float value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public float get_Value();
    public void set_Value(float value);
    public float InterpolateValue(float baseValue, double keyFrameProgress);
    protected abstract virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.SingleKeyFrameCollection : Freezable {
    public static SingleKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public SingleKeyFrame Item { get; public set; }
    public static SingleKeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public SingleKeyFrame get_Item(int index);
    public void set_Item(int index, SingleKeyFrame value);
    public SingleKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(SingleKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(SingleKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(SingleKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(SingleKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, SingleKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(SingleKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
public class System.Windows.Media.Animation.SizeAnimation : SizeAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Size> From { get; public set; }
    public Nullable`1<Size> To { get; public set; }
    public Nullable`1<Size> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public SizeAnimation(Size toValue, Duration duration);
    public SizeAnimation(Size toValue, Duration duration, FillBehavior fillBehavior);
    public SizeAnimation(Size fromValue, Size toValue, Duration duration);
    public SizeAnimation(Size fromValue, Size toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<Size> get_From();
    public void set_From(Nullable`1<Size> value);
    public Nullable`1<Size> get_To();
    public void set_To(Nullable`1<Size> value);
    public Nullable`1<Size> get_By();
    public void set_By(Nullable`1<Size> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public SizeAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size GetCurrentValueCore(Size defaultOriginValue, Size defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.SizeAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public SizeAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Size GetCurrentValue(Size defaultOriginValue, Size defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Size GetCurrentValueCore(Size defaultOriginValue, Size defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.SizeAnimationUsingKeyFrames : SizeAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public SizeKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public SizeKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(SizeKeyFrameCollection value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public SizeAnimationUsingKeyFrames Clone();
    public SizeAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Size GetCurrentValueCore(Size defaultOriginValue, Size defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.SizeKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Size Value { get; public set; }
    protected SizeKeyFrame(Size value);
    protected SizeKeyFrame(Size value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Size get_Value();
    public void set_Value(Size value);
    public Size InterpolateValue(Size baseValue, double keyFrameProgress);
    protected abstract virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.SizeKeyFrameCollection : Freezable {
    public static SizeKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public SizeKeyFrame Item { get; public set; }
    public static SizeKeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public SizeKeyFrame get_Item(int index);
    public void set_Item(int index, SizeKeyFrame value);
    public SizeKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(SizeKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(SizeKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(SizeKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(SizeKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, SizeKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(SizeKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
public enum System.Windows.Media.Animation.SlipBehavior : Enum {
    public int value__;
    public static SlipBehavior Grow;
    public static SlipBehavior Slip;
}
public class System.Windows.Media.Animation.SplineByteKeyFrame : ByteKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineByteKeyFrame(byte value);
    public SplineByteKeyFrame(byte value, KeyTime keyTime);
    public SplineByteKeyFrame(byte value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineColorKeyFrame : ColorKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineColorKeyFrame(Color value);
    public SplineColorKeyFrame(Color value, KeyTime keyTime);
    public SplineColorKeyFrame(Color value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineDecimalKeyFrame : DecimalKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineDecimalKeyFrame(decimal value);
    public SplineDecimalKeyFrame(decimal value, KeyTime keyTime);
    public SplineDecimalKeyFrame(decimal value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineDoubleKeyFrame : DoubleKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineDoubleKeyFrame(double value);
    public SplineDoubleKeyFrame(double value, KeyTime keyTime);
    public SplineDoubleKeyFrame(double value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineInt16KeyFrame : Int16KeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineInt16KeyFrame(short value);
    public SplineInt16KeyFrame(short value, KeyTime keyTime);
    public SplineInt16KeyFrame(short value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineInt32KeyFrame : Int32KeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineInt32KeyFrame(int value);
    public SplineInt32KeyFrame(int value, KeyTime keyTime);
    public SplineInt32KeyFrame(int value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineInt64KeyFrame : Int64KeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineInt64KeyFrame(long value);
    public SplineInt64KeyFrame(long value, KeyTime keyTime);
    public SplineInt64KeyFrame(long value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplinePoint3DKeyFrame : Point3DKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplinePoint3DKeyFrame(Point3D value);
    public SplinePoint3DKeyFrame(Point3D value, KeyTime keyTime);
    public SplinePoint3DKeyFrame(Point3D value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplinePointKeyFrame : PointKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplinePointKeyFrame(Point value);
    public SplinePointKeyFrame(Point value, KeyTime keyTime);
    public SplinePointKeyFrame(Point value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineQuaternionKeyFrame : QuaternionKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public static DependencyProperty UseShortestPathProperty;
    public KeySpline KeySpline { get; public set; }
    public bool UseShortestPath { get; public set; }
    public SplineQuaternionKeyFrame(Quaternion value);
    public SplineQuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    public SplineQuaternionKeyFrame(Quaternion value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    public bool get_UseShortestPath();
    public void set_UseShortestPath(bool value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineRectKeyFrame : RectKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineRectKeyFrame(Rect value);
    public SplineRectKeyFrame(Rect value, KeyTime keyTime);
    public SplineRectKeyFrame(Rect value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineRotation3DKeyFrame : Rotation3DKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineRotation3DKeyFrame(Rotation3D value);
    public SplineRotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    public SplineRotation3DKeyFrame(Rotation3D value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineSingleKeyFrame : SingleKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineSingleKeyFrame(float value);
    public SplineSingleKeyFrame(float value, KeyTime keyTime);
    public SplineSingleKeyFrame(float value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineSizeKeyFrame : SizeKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineSizeKeyFrame(Size value);
    public SplineSizeKeyFrame(Size value, KeyTime keyTime);
    public SplineSizeKeyFrame(Size value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineVector3DKeyFrame : Vector3DKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineVector3DKeyFrame(Vector3D value);
    public SplineVector3DKeyFrame(Vector3D value, KeyTime keyTime);
    public SplineVector3DKeyFrame(Vector3D value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.SplineVectorKeyFrame : VectorKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineVectorKeyFrame(Vector value);
    public SplineVectorKeyFrame(Vector value, KeyTime keyTime);
    public SplineVectorKeyFrame(Vector value, KeyTime keyTime, KeySpline keySpline);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
}
public abstract class System.Windows.Media.Animation.StringAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public StringAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public string GetCurrentValue(string defaultOriginValue, string defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual string GetCurrentValueCore(string defaultOriginValue, string defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.StringAnimationUsingKeyFrames : StringAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public StringKeyFrameCollection KeyFrames { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public StringKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(StringKeyFrameCollection value);
    public StringAnimationUsingKeyFrames Clone();
    public StringAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual string GetCurrentValueCore(string defaultOriginValue, string defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.StringKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public string Value { get; public set; }
    protected StringKeyFrame(string value);
    protected StringKeyFrame(string value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public string get_Value();
    public void set_Value(string value);
    public string InterpolateValue(string baseValue, double keyFrameProgress);
    protected abstract virtual string InterpolateValueCore(string baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.StringKeyFrameCollection : Freezable {
    public static StringKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public StringKeyFrame Item { get; public set; }
    public static StringKeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public StringKeyFrame get_Item(int index);
    public void set_Item(int index, StringKeyFrame value);
    public StringKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(StringKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(StringKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(StringKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(StringKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, StringKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(StringKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
[RuntimeNamePropertyAttribute("Name")]
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Animation.Timeline : Animatable {
    public static DependencyProperty AccelerationRatioProperty;
    public static DependencyProperty AutoReverseProperty;
    public static DependencyProperty BeginTimeProperty;
    public static DependencyProperty DecelerationRatioProperty;
    public static DependencyProperty DesiredFrameRateProperty;
    public static DependencyProperty DurationProperty;
    public static DependencyProperty FillBehaviorProperty;
    public static DependencyProperty NameProperty;
    public static DependencyProperty RepeatBehaviorProperty;
    public static DependencyProperty SpeedRatioProperty;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler CurrentStateInvalidated;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler CurrentTimeInvalidated;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler CurrentGlobalSpeedInvalidated;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler Completed;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler RemoveRequested;
    public double AccelerationRatio { get; public set; }
    [DefaultValueAttribute("False")]
public bool AutoReverse { get; public set; }
    public Nullable`1<TimeSpan> BeginTime { get; public set; }
    public double DecelerationRatio { get; public set; }
    public Duration Duration { get; public set; }
    public FillBehavior FillBehavior { get; public set; }
    [MergablePropertyAttribute("False")]
[DefaultValueAttribute("")]
public string Name { get; public set; }
    public RepeatBehavior RepeatBehavior { get; public set; }
    [DefaultValueAttribute("1")]
public double SpeedRatio { get; public set; }
    protected Timeline(Nullable`1<TimeSpan> beginTime);
    protected Timeline(Nullable`1<TimeSpan> beginTime, Duration duration);
    protected Timeline(Nullable`1<TimeSpan> beginTime, Duration duration, RepeatBehavior repeatBehavior);
    public double get_AccelerationRatio();
    public void set_AccelerationRatio(double value);
    public bool get_AutoReverse();
    public void set_AutoReverse(bool value);
    public Nullable`1<TimeSpan> get_BeginTime();
    public void set_BeginTime(Nullable`1<TimeSpan> value);
    public double get_DecelerationRatio();
    public void set_DecelerationRatio(double value);
    public Duration get_Duration();
    public void set_Duration(Duration value);
    public FillBehavior get_FillBehavior();
    public void set_FillBehavior(FillBehavior value);
    public string get_Name();
    public void set_Name(string value);
    public RepeatBehavior get_RepeatBehavior();
    public void set_RepeatBehavior(RepeatBehavior value);
    public double get_SpeedRatio();
    public void set_SpeedRatio(double value);
    [CompilerGeneratedAttribute]
public void add_CurrentStateInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CurrentStateInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_CurrentTimeInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CurrentTimeInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_CurrentGlobalSpeedInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CurrentGlobalSpeedInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Completed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Completed(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_RemoveRequested(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_RemoveRequested(EventHandler value);
    public Timeline Clone();
    public Timeline CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public static Nullable`1<int> GetDesiredFrameRate(Timeline timeline);
    public static void SetDesiredFrameRate(Timeline timeline, Nullable`1<int> desiredFrameRate);
    protected internal virtual Clock AllocateClock();
    public Clock CreateClock();
    public Clock CreateClock(bool hasControllableRoot);
    protected internal Duration GetNaturalDuration(Clock clock);
    protected virtual Duration GetNaturalDurationCore(Clock clock);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.TimelineCollection : Animatable {
    public Timeline Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Animation.Timeline>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public TimelineCollection(int capacity);
    public TimelineCollection(IEnumerable`1<Timeline> collection);
    public sealed virtual Timeline get_Item(int index);
    public sealed virtual void set_Item(int index, Timeline value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Animation.Timeline>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public TimelineCollection Clone();
    public TimelineCollection CloneCurrentValue();
    public sealed virtual void Add(Timeline value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Timeline value);
    public sealed virtual int IndexOf(Timeline value);
    public sealed virtual void Insert(int index, Timeline value);
    public sealed virtual bool Remove(Timeline value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(Timeline[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Timeline> System.Collections.Generic.IEnumerable<System.Windows.Media.Animation.Timeline>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
public abstract class System.Windows.Media.Animation.TimelineGroup : Timeline {
    public static DependencyProperty ChildrenProperty;
    public TimelineCollection Children { get; public set; }
    protected TimelineGroup(Nullable`1<TimeSpan> beginTime);
    protected TimelineGroup(Nullable`1<TimeSpan> beginTime, Duration duration);
    protected TimelineGroup(Nullable`1<TimeSpan> beginTime, Duration duration, RepeatBehavior repeatBehavior);
    public TimelineCollection get_Children();
    public void set_Children(TimelineCollection value);
    public TimelineGroup Clone();
    public TimelineGroup CloneCurrentValue();
    protected internal virtual Clock AllocateClock();
    public ClockGroup CreateClock();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
}
public enum System.Windows.Media.Animation.TimeSeekOrigin : Enum {
    public int value__;
    public static TimeSeekOrigin BeginTime;
    public static TimeSeekOrigin Duration;
}
public class System.Windows.Media.Animation.Vector3DAnimation : Vector3DAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Vector3D> From { get; public set; }
    public Nullable`1<Vector3D> To { get; public set; }
    public Nullable`1<Vector3D> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Vector3DAnimation(Vector3D toValue, Duration duration);
    public Vector3DAnimation(Vector3D toValue, Duration duration, FillBehavior fillBehavior);
    public Vector3DAnimation(Vector3D fromValue, Vector3D toValue, Duration duration);
    public Vector3DAnimation(Vector3D fromValue, Vector3D toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<Vector3D> get_From();
    public void set_From(Nullable`1<Vector3D> value);
    public Nullable`1<Vector3D> get_To();
    public void set_To(Nullable`1<Vector3D> value);
    public Nullable`1<Vector3D> get_By();
    public void set_By(Nullable`1<Vector3D> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Vector3DAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D GetCurrentValueCore(Vector3D defaultOriginValue, Vector3D defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.Vector3DAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public Vector3DAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Vector3D GetCurrentValue(Vector3D defaultOriginValue, Vector3D defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Vector3D GetCurrentValueCore(Vector3D defaultOriginValue, Vector3D defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Vector3DAnimationUsingKeyFrames : Vector3DAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public Vector3DKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public Vector3DKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Vector3DKeyFrameCollection value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public Vector3DAnimationUsingKeyFrames Clone();
    public Vector3DAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Vector3D GetCurrentValueCore(Vector3D defaultOriginValue, Vector3D defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.Vector3DKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Vector3D Value { get; public set; }
    protected Vector3DKeyFrame(Vector3D value);
    protected Vector3DKeyFrame(Vector3D value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Vector3D get_Value();
    public void set_Value(Vector3D value);
    public Vector3D InterpolateValue(Vector3D baseValue, double keyFrameProgress);
    protected abstract virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Vector3DKeyFrameCollection : Freezable {
    public static Vector3DKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Vector3DKeyFrame Item { get; public set; }
    public static Vector3DKeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public Vector3DKeyFrame get_Item(int index);
    public void set_Item(int index, Vector3DKeyFrame value);
    public Vector3DKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Vector3DKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(Vector3DKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(Vector3DKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(Vector3DKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, Vector3DKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(Vector3DKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
public class System.Windows.Media.Animation.VectorAnimation : VectorAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Vector> From { get; public set; }
    public Nullable`1<Vector> To { get; public set; }
    public Nullable`1<Vector> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public VectorAnimation(Vector toValue, Duration duration);
    public VectorAnimation(Vector toValue, Duration duration, FillBehavior fillBehavior);
    public VectorAnimation(Vector fromValue, Vector toValue, Duration duration);
    public VectorAnimation(Vector fromValue, Vector toValue, Duration duration, FillBehavior fillBehavior);
    public Nullable`1<Vector> get_From();
    public void set_From(Nullable`1<Vector> value);
    public Nullable`1<Vector> get_To();
    public void set_To(Nullable`1<Vector> value);
    public Nullable`1<Vector> get_By();
    public void set_By(Nullable`1<Vector> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public VectorAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector GetCurrentValueCore(Vector defaultOriginValue, Vector defaultDestinationValue, AnimationClock animationClock);
}
public abstract class System.Windows.Media.Animation.VectorAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public sealed virtual Type get_TargetPropertyType();
    public VectorAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public Vector GetCurrentValue(Vector defaultOriginValue, Vector defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Vector GetCurrentValueCore(Vector defaultOriginValue, Vector defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.VectorAnimationUsingKeyFrames : VectorAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public VectorKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public VectorKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(VectorKeyFrameCollection value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public VectorAnimationUsingKeyFrames Clone();
    public VectorAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Vector GetCurrentValueCore(Vector defaultOriginValue, Vector defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.VectorKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Vector Value { get; public set; }
    protected VectorKeyFrame(Vector value);
    protected VectorKeyFrame(Vector value, KeyTime keyTime);
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Vector get_Value();
    public void set_Value(Vector value);
    public Vector InterpolateValue(Vector baseValue, double keyFrameProgress);
    protected abstract virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.VectorKeyFrameCollection : Freezable {
    public static VectorKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public VectorKeyFrame Item { get; public set; }
    public static VectorKeyFrameCollection get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public VectorKeyFrame get_Item(int index);
    public void set_Item(int index, VectorKeyFrame value);
    public VectorKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(VectorKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(VectorKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(VectorKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(VectorKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, VectorKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(VectorKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
}
public class System.Windows.Media.ArcSegment : PathSegment {
    public static DependencyProperty PointProperty;
    public static DependencyProperty SizeProperty;
    public static DependencyProperty RotationAngleProperty;
    public static DependencyProperty IsLargeArcProperty;
    public static DependencyProperty SweepDirectionProperty;
    public Point Point { get; public set; }
    public Size Size { get; public set; }
    public double RotationAngle { get; public set; }
    public bool IsLargeArc { get; public set; }
    public SweepDirection SweepDirection { get; public set; }
    public ArcSegment(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection, bool isStroked);
    public Point get_Point();
    public void set_Point(Point value);
    public Size get_Size();
    public void set_Size(Size value);
    public double get_RotationAngle();
    public void set_RotationAngle(double value);
    public bool get_IsLargeArc();
    public void set_IsLargeArc(bool value);
    public SweepDirection get_SweepDirection();
    public void set_SweepDirection(SweepDirection value);
    public ArcSegment Clone();
    public ArcSegment CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.BezierSegment : PathSegment {
    public static DependencyProperty Point1Property;
    public static DependencyProperty Point2Property;
    public static DependencyProperty Point3Property;
    public Point Point1 { get; public set; }
    public Point Point2 { get; public set; }
    public Point Point3 { get; public set; }
    public BezierSegment(Point point1, Point point2, Point point3, bool isStroked);
    public Point get_Point1();
    public void set_Point1(Point value);
    public Point get_Point2();
    public void set_Point2(Point value);
    public Point get_Point3();
    public void set_Point3(Point value);
    public BezierSegment Clone();
    public BezierSegment CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.BitmapCache : CacheMode {
    public static DependencyProperty RenderAtScaleProperty;
    public static DependencyProperty SnapsToDevicePixelsProperty;
    public static DependencyProperty EnableClearTypeProperty;
    public double RenderAtScale { get; public set; }
    public bool SnapsToDevicePixels { get; public set; }
    public bool EnableClearType { get; public set; }
    public BitmapCache(double renderAtScale);
    public double get_RenderAtScale();
    public void set_RenderAtScale(double value);
    public bool get_SnapsToDevicePixels();
    public void set_SnapsToDevicePixels(bool value);
    public bool get_EnableClearType();
    public void set_EnableClearType(bool value);
    public BitmapCache Clone();
    public BitmapCache CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.BitmapCacheBrush : Brush {
    public static DependencyProperty TargetProperty;
    public static DependencyProperty BitmapCacheProperty;
    public static DependencyProperty AutoLayoutContentProperty;
    public Visual Target { get; public set; }
    public BitmapCache BitmapCache { get; public set; }
    public bool AutoLayoutContent { get; public set; }
    public BitmapCacheBrush(Visual visual);
    public Visual get_Target();
    public void set_Target(Visual value);
    public BitmapCache get_BitmapCache();
    public void set_BitmapCache(BitmapCache value);
    public bool get_AutoLayoutContent();
    public void set_AutoLayoutContent(bool value);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    public BitmapCacheBrush Clone();
    public BitmapCacheBrush CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public enum System.Windows.Media.BitmapScalingMode : Enum {
    public int value__;
    public static BitmapScalingMode Unspecified;
    public static BitmapScalingMode Linear;
    public static BitmapScalingMode LowQuality;
    public static BitmapScalingMode Fant;
    public static BitmapScalingMode HighQuality;
    public static BitmapScalingMode NearestNeighbor;
}
[LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.Media.BrushConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.BrushValueSerializer")]
public abstract class System.Windows.Media.Brush : Animatable {
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty TransformProperty;
    public static DependencyProperty RelativeTransformProperty;
    public double Opacity { get; public set; }
    public Transform Transform { get; public set; }
    public Transform RelativeTransform { get; public set; }
    public double get_Opacity();
    public void set_Opacity(double value);
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public Transform get_RelativeTransform();
    public void set_RelativeTransform(Transform value);
    public Brush Clone();
    public Brush CloneCurrentValue();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.BrushConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Brushes : object {
    public static SolidColorBrush AliceBlue { get; }
    public static SolidColorBrush AntiqueWhite { get; }
    public static SolidColorBrush Aqua { get; }
    public static SolidColorBrush Aquamarine { get; }
    public static SolidColorBrush Azure { get; }
    public static SolidColorBrush Beige { get; }
    public static SolidColorBrush Bisque { get; }
    public static SolidColorBrush Black { get; }
    public static SolidColorBrush BlanchedAlmond { get; }
    public static SolidColorBrush Blue { get; }
    public static SolidColorBrush BlueViolet { get; }
    public static SolidColorBrush Brown { get; }
    public static SolidColorBrush BurlyWood { get; }
    public static SolidColorBrush CadetBlue { get; }
    public static SolidColorBrush Chartreuse { get; }
    public static SolidColorBrush Chocolate { get; }
    public static SolidColorBrush Coral { get; }
    public static SolidColorBrush CornflowerBlue { get; }
    public static SolidColorBrush Cornsilk { get; }
    public static SolidColorBrush Crimson { get; }
    public static SolidColorBrush Cyan { get; }
    public static SolidColorBrush DarkBlue { get; }
    public static SolidColorBrush DarkCyan { get; }
    public static SolidColorBrush DarkGoldenrod { get; }
    public static SolidColorBrush DarkGray { get; }
    public static SolidColorBrush DarkGreen { get; }
    public static SolidColorBrush DarkKhaki { get; }
    public static SolidColorBrush DarkMagenta { get; }
    public static SolidColorBrush DarkOliveGreen { get; }
    public static SolidColorBrush DarkOrange { get; }
    public static SolidColorBrush DarkOrchid { get; }
    public static SolidColorBrush DarkRed { get; }
    public static SolidColorBrush DarkSalmon { get; }
    public static SolidColorBrush DarkSeaGreen { get; }
    public static SolidColorBrush DarkSlateBlue { get; }
    public static SolidColorBrush DarkSlateGray { get; }
    public static SolidColorBrush DarkTurquoise { get; }
    public static SolidColorBrush DarkViolet { get; }
    public static SolidColorBrush DeepPink { get; }
    public static SolidColorBrush DeepSkyBlue { get; }
    public static SolidColorBrush DimGray { get; }
    public static SolidColorBrush DodgerBlue { get; }
    public static SolidColorBrush Firebrick { get; }
    public static SolidColorBrush FloralWhite { get; }
    public static SolidColorBrush ForestGreen { get; }
    public static SolidColorBrush Fuchsia { get; }
    public static SolidColorBrush Gainsboro { get; }
    public static SolidColorBrush GhostWhite { get; }
    public static SolidColorBrush Gold { get; }
    public static SolidColorBrush Goldenrod { get; }
    public static SolidColorBrush Gray { get; }
    public static SolidColorBrush Green { get; }
    public static SolidColorBrush GreenYellow { get; }
    public static SolidColorBrush Honeydew { get; }
    public static SolidColorBrush HotPink { get; }
    public static SolidColorBrush IndianRed { get; }
    public static SolidColorBrush Indigo { get; }
    public static SolidColorBrush Ivory { get; }
    public static SolidColorBrush Khaki { get; }
    public static SolidColorBrush Lavender { get; }
    public static SolidColorBrush LavenderBlush { get; }
    public static SolidColorBrush LawnGreen { get; }
    public static SolidColorBrush LemonChiffon { get; }
    public static SolidColorBrush LightBlue { get; }
    public static SolidColorBrush LightCoral { get; }
    public static SolidColorBrush LightCyan { get; }
    public static SolidColorBrush LightGoldenrodYellow { get; }
    public static SolidColorBrush LightGray { get; }
    public static SolidColorBrush LightGreen { get; }
    public static SolidColorBrush LightPink { get; }
    public static SolidColorBrush LightSalmon { get; }
    public static SolidColorBrush LightSeaGreen { get; }
    public static SolidColorBrush LightSkyBlue { get; }
    public static SolidColorBrush LightSlateGray { get; }
    public static SolidColorBrush LightSteelBlue { get; }
    public static SolidColorBrush LightYellow { get; }
    public static SolidColorBrush Lime { get; }
    public static SolidColorBrush LimeGreen { get; }
    public static SolidColorBrush Linen { get; }
    public static SolidColorBrush Magenta { get; }
    public static SolidColorBrush Maroon { get; }
    public static SolidColorBrush MediumAquamarine { get; }
    public static SolidColorBrush MediumBlue { get; }
    public static SolidColorBrush MediumOrchid { get; }
    public static SolidColorBrush MediumPurple { get; }
    public static SolidColorBrush MediumSeaGreen { get; }
    public static SolidColorBrush MediumSlateBlue { get; }
    public static SolidColorBrush MediumSpringGreen { get; }
    public static SolidColorBrush MediumTurquoise { get; }
    public static SolidColorBrush MediumVioletRed { get; }
    public static SolidColorBrush MidnightBlue { get; }
    public static SolidColorBrush MintCream { get; }
    public static SolidColorBrush MistyRose { get; }
    public static SolidColorBrush Moccasin { get; }
    public static SolidColorBrush NavajoWhite { get; }
    public static SolidColorBrush Navy { get; }
    public static SolidColorBrush OldLace { get; }
    public static SolidColorBrush Olive { get; }
    public static SolidColorBrush OliveDrab { get; }
    public static SolidColorBrush Orange { get; }
    public static SolidColorBrush OrangeRed { get; }
    public static SolidColorBrush Orchid { get; }
    public static SolidColorBrush PaleGoldenrod { get; }
    public static SolidColorBrush PaleGreen { get; }
    public static SolidColorBrush PaleTurquoise { get; }
    public static SolidColorBrush PaleVioletRed { get; }
    public static SolidColorBrush PapayaWhip { get; }
    public static SolidColorBrush PeachPuff { get; }
    public static SolidColorBrush Peru { get; }
    public static SolidColorBrush Pink { get; }
    public static SolidColorBrush Plum { get; }
    public static SolidColorBrush PowderBlue { get; }
    public static SolidColorBrush Purple { get; }
    public static SolidColorBrush Red { get; }
    public static SolidColorBrush RosyBrown { get; }
    public static SolidColorBrush RoyalBlue { get; }
    public static SolidColorBrush SaddleBrown { get; }
    public static SolidColorBrush Salmon { get; }
    public static SolidColorBrush SandyBrown { get; }
    public static SolidColorBrush SeaGreen { get; }
    public static SolidColorBrush SeaShell { get; }
    public static SolidColorBrush Sienna { get; }
    public static SolidColorBrush Silver { get; }
    public static SolidColorBrush SkyBlue { get; }
    public static SolidColorBrush SlateBlue { get; }
    public static SolidColorBrush SlateGray { get; }
    public static SolidColorBrush Snow { get; }
    public static SolidColorBrush SpringGreen { get; }
    public static SolidColorBrush SteelBlue { get; }
    public static SolidColorBrush Tan { get; }
    public static SolidColorBrush Teal { get; }
    public static SolidColorBrush Thistle { get; }
    public static SolidColorBrush Tomato { get; }
    public static SolidColorBrush Transparent { get; }
    public static SolidColorBrush Turquoise { get; }
    public static SolidColorBrush Violet { get; }
    public static SolidColorBrush Wheat { get; }
    public static SolidColorBrush White { get; }
    public static SolidColorBrush WhiteSmoke { get; }
    public static SolidColorBrush Yellow { get; }
    public static SolidColorBrush YellowGreen { get; }
    public static SolidColorBrush get_AliceBlue();
    public static SolidColorBrush get_AntiqueWhite();
    public static SolidColorBrush get_Aqua();
    public static SolidColorBrush get_Aquamarine();
    public static SolidColorBrush get_Azure();
    public static SolidColorBrush get_Beige();
    public static SolidColorBrush get_Bisque();
    public static SolidColorBrush get_Black();
    public static SolidColorBrush get_BlanchedAlmond();
    public static SolidColorBrush get_Blue();
    public static SolidColorBrush get_BlueViolet();
    public static SolidColorBrush get_Brown();
    public static SolidColorBrush get_BurlyWood();
    public static SolidColorBrush get_CadetBlue();
    public static SolidColorBrush get_Chartreuse();
    public static SolidColorBrush get_Chocolate();
    public static SolidColorBrush get_Coral();
    public static SolidColorBrush get_CornflowerBlue();
    public static SolidColorBrush get_Cornsilk();
    public static SolidColorBrush get_Crimson();
    public static SolidColorBrush get_Cyan();
    public static SolidColorBrush get_DarkBlue();
    public static SolidColorBrush get_DarkCyan();
    public static SolidColorBrush get_DarkGoldenrod();
    public static SolidColorBrush get_DarkGray();
    public static SolidColorBrush get_DarkGreen();
    public static SolidColorBrush get_DarkKhaki();
    public static SolidColorBrush get_DarkMagenta();
    public static SolidColorBrush get_DarkOliveGreen();
    public static SolidColorBrush get_DarkOrange();
    public static SolidColorBrush get_DarkOrchid();
    public static SolidColorBrush get_DarkRed();
    public static SolidColorBrush get_DarkSalmon();
    public static SolidColorBrush get_DarkSeaGreen();
    public static SolidColorBrush get_DarkSlateBlue();
    public static SolidColorBrush get_DarkSlateGray();
    public static SolidColorBrush get_DarkTurquoise();
    public static SolidColorBrush get_DarkViolet();
    public static SolidColorBrush get_DeepPink();
    public static SolidColorBrush get_DeepSkyBlue();
    public static SolidColorBrush get_DimGray();
    public static SolidColorBrush get_DodgerBlue();
    public static SolidColorBrush get_Firebrick();
    public static SolidColorBrush get_FloralWhite();
    public static SolidColorBrush get_ForestGreen();
    public static SolidColorBrush get_Fuchsia();
    public static SolidColorBrush get_Gainsboro();
    public static SolidColorBrush get_GhostWhite();
    public static SolidColorBrush get_Gold();
    public static SolidColorBrush get_Goldenrod();
    public static SolidColorBrush get_Gray();
    public static SolidColorBrush get_Green();
    public static SolidColorBrush get_GreenYellow();
    public static SolidColorBrush get_Honeydew();
    public static SolidColorBrush get_HotPink();
    public static SolidColorBrush get_IndianRed();
    public static SolidColorBrush get_Indigo();
    public static SolidColorBrush get_Ivory();
    public static SolidColorBrush get_Khaki();
    public static SolidColorBrush get_Lavender();
    public static SolidColorBrush get_LavenderBlush();
    public static SolidColorBrush get_LawnGreen();
    public static SolidColorBrush get_LemonChiffon();
    public static SolidColorBrush get_LightBlue();
    public static SolidColorBrush get_LightCoral();
    public static SolidColorBrush get_LightCyan();
    public static SolidColorBrush get_LightGoldenrodYellow();
    public static SolidColorBrush get_LightGray();
    public static SolidColorBrush get_LightGreen();
    public static SolidColorBrush get_LightPink();
    public static SolidColorBrush get_LightSalmon();
    public static SolidColorBrush get_LightSeaGreen();
    public static SolidColorBrush get_LightSkyBlue();
    public static SolidColorBrush get_LightSlateGray();
    public static SolidColorBrush get_LightSteelBlue();
    public static SolidColorBrush get_LightYellow();
    public static SolidColorBrush get_Lime();
    public static SolidColorBrush get_LimeGreen();
    public static SolidColorBrush get_Linen();
    public static SolidColorBrush get_Magenta();
    public static SolidColorBrush get_Maroon();
    public static SolidColorBrush get_MediumAquamarine();
    public static SolidColorBrush get_MediumBlue();
    public static SolidColorBrush get_MediumOrchid();
    public static SolidColorBrush get_MediumPurple();
    public static SolidColorBrush get_MediumSeaGreen();
    public static SolidColorBrush get_MediumSlateBlue();
    public static SolidColorBrush get_MediumSpringGreen();
    public static SolidColorBrush get_MediumTurquoise();
    public static SolidColorBrush get_MediumVioletRed();
    public static SolidColorBrush get_MidnightBlue();
    public static SolidColorBrush get_MintCream();
    public static SolidColorBrush get_MistyRose();
    public static SolidColorBrush get_Moccasin();
    public static SolidColorBrush get_NavajoWhite();
    public static SolidColorBrush get_Navy();
    public static SolidColorBrush get_OldLace();
    public static SolidColorBrush get_Olive();
    public static SolidColorBrush get_OliveDrab();
    public static SolidColorBrush get_Orange();
    public static SolidColorBrush get_OrangeRed();
    public static SolidColorBrush get_Orchid();
    public static SolidColorBrush get_PaleGoldenrod();
    public static SolidColorBrush get_PaleGreen();
    public static SolidColorBrush get_PaleTurquoise();
    public static SolidColorBrush get_PaleVioletRed();
    public static SolidColorBrush get_PapayaWhip();
    public static SolidColorBrush get_PeachPuff();
    public static SolidColorBrush get_Peru();
    public static SolidColorBrush get_Pink();
    public static SolidColorBrush get_Plum();
    public static SolidColorBrush get_PowderBlue();
    public static SolidColorBrush get_Purple();
    public static SolidColorBrush get_Red();
    public static SolidColorBrush get_RosyBrown();
    public static SolidColorBrush get_RoyalBlue();
    public static SolidColorBrush get_SaddleBrown();
    public static SolidColorBrush get_Salmon();
    public static SolidColorBrush get_SandyBrown();
    public static SolidColorBrush get_SeaGreen();
    public static SolidColorBrush get_SeaShell();
    public static SolidColorBrush get_Sienna();
    public static SolidColorBrush get_Silver();
    public static SolidColorBrush get_SkyBlue();
    public static SolidColorBrush get_SlateBlue();
    public static SolidColorBrush get_SlateGray();
    public static SolidColorBrush get_Snow();
    public static SolidColorBrush get_SpringGreen();
    public static SolidColorBrush get_SteelBlue();
    public static SolidColorBrush get_Tan();
    public static SolidColorBrush get_Teal();
    public static SolidColorBrush get_Thistle();
    public static SolidColorBrush get_Tomato();
    public static SolidColorBrush get_Transparent();
    public static SolidColorBrush get_Turquoise();
    public static SolidColorBrush get_Violet();
    public static SolidColorBrush get_Wheat();
    public static SolidColorBrush get_White();
    public static SolidColorBrush get_WhiteSmoke();
    public static SolidColorBrush get_Yellow();
    public static SolidColorBrush get_YellowGreen();
}
public enum System.Windows.Media.BrushMappingMode : Enum {
    public int value__;
    public static BrushMappingMode Absolute;
    public static BrushMappingMode RelativeToBoundingBox;
}
[TypeConverterAttribute("System.Windows.Media.CacheModeConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.CacheModeValueSerializer")]
public abstract class System.Windows.Media.CacheMode : Animatable {
    public CacheMode Clone();
    public CacheMode CloneCurrentValue();
}
public class System.Windows.Media.CacheModeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.Media.CachingHint : Enum {
    public int value__;
    public static CachingHint Unspecified;
    public static CachingHint Cache;
}
public class System.Windows.Media.CharacterMetrics : object {
    public string Metrics { get; public set; }
    public double BlackBoxWidth { get; }
    public double BlackBoxHeight { get; }
    public double Baseline { get; }
    public double LeftSideBearing { get; }
    public double RightSideBearing { get; }
    public double TopSideBearing { get; }
    public double BottomSideBearing { get; }
    public CharacterMetrics(string metrics);
    public string get_Metrics();
    public void set_Metrics(string value);
    public double get_BlackBoxWidth();
    public double get_BlackBoxHeight();
    public double get_Baseline();
    public double get_LeftSideBearing();
    public double get_RightSideBearing();
    public double get_TopSideBearing();
    public double get_BottomSideBearing();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.CharacterMetricsDictionary : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public CharacterMetrics Item { get; public set; }
    [CLSCompliantAttribute("False")]
public ICollection`1<int> Keys { get; }
    [CLSCompliantAttribute("False")]
public ICollection`1<CharacterMetrics> Values { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual CharacterMetrics get_Item(int key);
    public sealed virtual void set_Item(int key, CharacterMetrics value);
    public sealed virtual ICollection`1<int> get_Keys();
    public sealed virtual ICollection`1<CharacterMetrics> get_Values();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    [CLSCompliantAttribute("False")]
public sealed virtual IEnumerator`1<KeyValuePair`2<int, CharacterMetrics>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual bool TryGetValue(int key, CharacterMetrics& value);
    [CLSCompliantAttribute("False")]
public sealed virtual void Add(KeyValuePair`2<int, CharacterMetrics> item);
    public sealed virtual void Clear();
    [CLSCompliantAttribute("False")]
public sealed virtual bool Contains(KeyValuePair`2<int, CharacterMetrics> item);
    [CLSCompliantAttribute("False")]
public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    [CLSCompliantAttribute("False")]
public sealed virtual bool Remove(KeyValuePair`2<int, CharacterMetrics> item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual void Add(int key, CharacterMetrics value);
    public sealed virtual bool ContainsKey(int key);
    public sealed virtual bool Remove(int key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
}
public enum System.Windows.Media.ClearTypeHint : Enum {
    public int value__;
    public static ClearTypeHint Auto;
    public static ClearTypeHint Enabled;
}
[TypeConverterAttribute("System.Windows.Media.ColorConverter")]
[LocalizabilityAttribute("0")]
public class System.Windows.Media.Color : ValueType {
    private byte a;
    private byte b;
    private byte g;
    private byte r;
    public ColorContext ColorContext { get; }
    public byte A { get; public set; }
    public byte R { get; public set; }
    public byte G { get; public set; }
    public byte B { get; public set; }
    public float ScA { get; public set; }
    public float ScR { get; public set; }
    public float ScG { get; public set; }
    public float ScB { get; public set; }
    public ColorContext get_ColorContext();
    public byte get_A();
    public void set_A(byte value);
    public byte get_R();
    public void set_R(byte value);
    public byte get_G();
    public void set_G(byte value);
    public byte get_B();
    public void set_B(byte value);
    public float get_ScA();
    public void set_ScA(float value);
    public float get_ScR();
    public void set_ScR(float value);
    public float get_ScG();
    public void set_ScG(float value);
    public float get_ScB();
    public void set_ScB(float value);
    public sealed virtual bool Equals(Color color);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public static Color op_Addition(Color color1, Color color2);
    public static Color op_Subtraction(Color color1, Color color2);
    public static Color op_Multiply(Color color, float coefficient);
    public static bool op_Equality(Color color1, Color color2);
    public static bool op_Inequality(Color color1, Color color2);
    public static Color FromAValues(float a, Single[] values, Uri profileUri);
    public static Color FromValues(Single[] values, Uri profileUri);
    public static Color FromScRgb(float a, float r, float g, float b);
    public static Color FromArgb(byte a, byte r, byte g, byte b);
    public static Color FromRgb(byte r, byte g, byte b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    public static bool AreClose(Color color1, Color color2);
    public void Clamp();
    public Single[] GetNativeColorValues();
    public static Color Add(Color color1, Color color2);
    public static Color Subtract(Color color1, Color color2);
    public static Color Multiply(Color color, float coefficient);
    public static bool Equals(Color color1, Color color2);
    internal static Color FromUInt32(UInt32 argb);
    public virtual bool Equals(object obj);
}
public class System.Windows.Media.ColorContext : object {
    public Uri ProfileUri { get; }
    [SecurityCriticalAttribute]
public ColorContext(Uri profileUri);
    [SecurityCriticalAttribute]
public ColorContext(PixelFormat pixelFormat);
    [SecurityCriticalAttribute]
public Uri get_ProfileUri();
    [SecurityCriticalAttribute]
public static bool op_Equality(ColorContext context1, ColorContext context2);
    public static bool op_Inequality(ColorContext context1, ColorContext context2);
    [SecurityCriticalAttribute]
public Stream OpenProfileStream();
    public virtual bool Equals(object obj);
    [SecurityCriticalAttribute]
public virtual int GetHashCode();
}
public class System.Windows.Media.ColorConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public static object ConvertFromString(string value);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.Media.ColorInterpolationMode : Enum {
    public int value__;
    public static ColorInterpolationMode ScRgbLinearInterpolation;
    public static ColorInterpolationMode SRgbLinearInterpolation;
}
public class System.Windows.Media.Colors : object {
    public static Color AliceBlue { get; }
    public static Color AntiqueWhite { get; }
    public static Color Aqua { get; }
    public static Color Aquamarine { get; }
    public static Color Azure { get; }
    public static Color Beige { get; }
    public static Color Bisque { get; }
    public static Color Black { get; }
    public static Color BlanchedAlmond { get; }
    public static Color Blue { get; }
    public static Color BlueViolet { get; }
    public static Color Brown { get; }
    public static Color BurlyWood { get; }
    public static Color CadetBlue { get; }
    public static Color Chartreuse { get; }
    public static Color Chocolate { get; }
    public static Color Coral { get; }
    public static Color CornflowerBlue { get; }
    public static Color Cornsilk { get; }
    public static Color Crimson { get; }
    public static Color Cyan { get; }
    public static Color DarkBlue { get; }
    public static Color DarkCyan { get; }
    public static Color DarkGoldenrod { get; }
    public static Color DarkGray { get; }
    public static Color DarkGreen { get; }
    public static Color DarkKhaki { get; }
    public static Color DarkMagenta { get; }
    public static Color DarkOliveGreen { get; }
    public static Color DarkOrange { get; }
    public static Color DarkOrchid { get; }
    public static Color DarkRed { get; }
    public static Color DarkSalmon { get; }
    public static Color DarkSeaGreen { get; }
    public static Color DarkSlateBlue { get; }
    public static Color DarkSlateGray { get; }
    public static Color DarkTurquoise { get; }
    public static Color DarkViolet { get; }
    public static Color DeepPink { get; }
    public static Color DeepSkyBlue { get; }
    public static Color DimGray { get; }
    public static Color DodgerBlue { get; }
    public static Color Firebrick { get; }
    public static Color FloralWhite { get; }
    public static Color ForestGreen { get; }
    public static Color Fuchsia { get; }
    public static Color Gainsboro { get; }
    public static Color GhostWhite { get; }
    public static Color Gold { get; }
    public static Color Goldenrod { get; }
    public static Color Gray { get; }
    public static Color Green { get; }
    public static Color GreenYellow { get; }
    public static Color Honeydew { get; }
    public static Color HotPink { get; }
    public static Color IndianRed { get; }
    public static Color Indigo { get; }
    public static Color Ivory { get; }
    public static Color Khaki { get; }
    public static Color Lavender { get; }
    public static Color LavenderBlush { get; }
    public static Color LawnGreen { get; }
    public static Color LemonChiffon { get; }
    public static Color LightBlue { get; }
    public static Color LightCoral { get; }
    public static Color LightCyan { get; }
    public static Color LightGoldenrodYellow { get; }
    public static Color LightGray { get; }
    public static Color LightGreen { get; }
    public static Color LightPink { get; }
    public static Color LightSalmon { get; }
    public static Color LightSeaGreen { get; }
    public static Color LightSkyBlue { get; }
    public static Color LightSlateGray { get; }
    public static Color LightSteelBlue { get; }
    public static Color LightYellow { get; }
    public static Color Lime { get; }
    public static Color LimeGreen { get; }
    public static Color Linen { get; }
    public static Color Magenta { get; }
    public static Color Maroon { get; }
    public static Color MediumAquamarine { get; }
    public static Color MediumBlue { get; }
    public static Color MediumOrchid { get; }
    public static Color MediumPurple { get; }
    public static Color MediumSeaGreen { get; }
    public static Color MediumSlateBlue { get; }
    public static Color MediumSpringGreen { get; }
    public static Color MediumTurquoise { get; }
    public static Color MediumVioletRed { get; }
    public static Color MidnightBlue { get; }
    public static Color MintCream { get; }
    public static Color MistyRose { get; }
    public static Color Moccasin { get; }
    public static Color NavajoWhite { get; }
    public static Color Navy { get; }
    public static Color OldLace { get; }
    public static Color Olive { get; }
    public static Color OliveDrab { get; }
    public static Color Orange { get; }
    public static Color OrangeRed { get; }
    public static Color Orchid { get; }
    public static Color PaleGoldenrod { get; }
    public static Color PaleGreen { get; }
    public static Color PaleTurquoise { get; }
    public static Color PaleVioletRed { get; }
    public static Color PapayaWhip { get; }
    public static Color PeachPuff { get; }
    public static Color Peru { get; }
    public static Color Pink { get; }
    public static Color Plum { get; }
    public static Color PowderBlue { get; }
    public static Color Purple { get; }
    public static Color Red { get; }
    public static Color RosyBrown { get; }
    public static Color RoyalBlue { get; }
    public static Color SaddleBrown { get; }
    public static Color Salmon { get; }
    public static Color SandyBrown { get; }
    public static Color SeaGreen { get; }
    public static Color SeaShell { get; }
    public static Color Sienna { get; }
    public static Color Silver { get; }
    public static Color SkyBlue { get; }
    public static Color SlateBlue { get; }
    public static Color SlateGray { get; }
    public static Color Snow { get; }
    public static Color SpringGreen { get; }
    public static Color SteelBlue { get; }
    public static Color Tan { get; }
    public static Color Teal { get; }
    public static Color Thistle { get; }
    public static Color Tomato { get; }
    public static Color Transparent { get; }
    public static Color Turquoise { get; }
    public static Color Violet { get; }
    public static Color Wheat { get; }
    public static Color White { get; }
    public static Color WhiteSmoke { get; }
    public static Color Yellow { get; }
    public static Color YellowGreen { get; }
    public static Color get_AliceBlue();
    public static Color get_AntiqueWhite();
    public static Color get_Aqua();
    public static Color get_Aquamarine();
    public static Color get_Azure();
    public static Color get_Beige();
    public static Color get_Bisque();
    public static Color get_Black();
    public static Color get_BlanchedAlmond();
    public static Color get_Blue();
    public static Color get_BlueViolet();
    public static Color get_Brown();
    public static Color get_BurlyWood();
    public static Color get_CadetBlue();
    public static Color get_Chartreuse();
    public static Color get_Chocolate();
    public static Color get_Coral();
    public static Color get_CornflowerBlue();
    public static Color get_Cornsilk();
    public static Color get_Crimson();
    public static Color get_Cyan();
    public static Color get_DarkBlue();
    public static Color get_DarkCyan();
    public static Color get_DarkGoldenrod();
    public static Color get_DarkGray();
    public static Color get_DarkGreen();
    public static Color get_DarkKhaki();
    public static Color get_DarkMagenta();
    public static Color get_DarkOliveGreen();
    public static Color get_DarkOrange();
    public static Color get_DarkOrchid();
    public static Color get_DarkRed();
    public static Color get_DarkSalmon();
    public static Color get_DarkSeaGreen();
    public static Color get_DarkSlateBlue();
    public static Color get_DarkSlateGray();
    public static Color get_DarkTurquoise();
    public static Color get_DarkViolet();
    public static Color get_DeepPink();
    public static Color get_DeepSkyBlue();
    public static Color get_DimGray();
    public static Color get_DodgerBlue();
    public static Color get_Firebrick();
    public static Color get_FloralWhite();
    public static Color get_ForestGreen();
    public static Color get_Fuchsia();
    public static Color get_Gainsboro();
    public static Color get_GhostWhite();
    public static Color get_Gold();
    public static Color get_Goldenrod();
    public static Color get_Gray();
    public static Color get_Green();
    public static Color get_GreenYellow();
    public static Color get_Honeydew();
    public static Color get_HotPink();
    public static Color get_IndianRed();
    public static Color get_Indigo();
    public static Color get_Ivory();
    public static Color get_Khaki();
    public static Color get_Lavender();
    public static Color get_LavenderBlush();
    public static Color get_LawnGreen();
    public static Color get_LemonChiffon();
    public static Color get_LightBlue();
    public static Color get_LightCoral();
    public static Color get_LightCyan();
    public static Color get_LightGoldenrodYellow();
    public static Color get_LightGray();
    public static Color get_LightGreen();
    public static Color get_LightPink();
    public static Color get_LightSalmon();
    public static Color get_LightSeaGreen();
    public static Color get_LightSkyBlue();
    public static Color get_LightSlateGray();
    public static Color get_LightSteelBlue();
    public static Color get_LightYellow();
    public static Color get_Lime();
    public static Color get_LimeGreen();
    public static Color get_Linen();
    public static Color get_Magenta();
    public static Color get_Maroon();
    public static Color get_MediumAquamarine();
    public static Color get_MediumBlue();
    public static Color get_MediumOrchid();
    public static Color get_MediumPurple();
    public static Color get_MediumSeaGreen();
    public static Color get_MediumSlateBlue();
    public static Color get_MediumSpringGreen();
    public static Color get_MediumTurquoise();
    public static Color get_MediumVioletRed();
    public static Color get_MidnightBlue();
    public static Color get_MintCream();
    public static Color get_MistyRose();
    public static Color get_Moccasin();
    public static Color get_NavajoWhite();
    public static Color get_Navy();
    public static Color get_OldLace();
    public static Color get_Olive();
    public static Color get_OliveDrab();
    public static Color get_Orange();
    public static Color get_OrangeRed();
    public static Color get_Orchid();
    public static Color get_PaleGoldenrod();
    public static Color get_PaleGreen();
    public static Color get_PaleTurquoise();
    public static Color get_PaleVioletRed();
    public static Color get_PapayaWhip();
    public static Color get_PeachPuff();
    public static Color get_Peru();
    public static Color get_Pink();
    public static Color get_Plum();
    public static Color get_PowderBlue();
    public static Color get_Purple();
    public static Color get_Red();
    public static Color get_RosyBrown();
    public static Color get_RoyalBlue();
    public static Color get_SaddleBrown();
    public static Color get_Salmon();
    public static Color get_SandyBrown();
    public static Color get_SeaGreen();
    public static Color get_SeaShell();
    public static Color get_Sienna();
    public static Color get_Silver();
    public static Color get_SkyBlue();
    public static Color get_SlateBlue();
    public static Color get_SlateGray();
    public static Color get_Snow();
    public static Color get_SpringGreen();
    public static Color get_SteelBlue();
    public static Color get_Tan();
    public static Color get_Teal();
    public static Color get_Thistle();
    public static Color get_Tomato();
    public static Color get_Transparent();
    public static Color get_Turquoise();
    public static Color get_Violet();
    public static Color get_Wheat();
    public static Color get_White();
    public static Color get_WhiteSmoke();
    public static Color get_Yellow();
    public static Color get_YellowGreen();
}
public class System.Windows.Media.CombinedGeometry : Geometry {
    public static DependencyProperty GeometryCombineModeProperty;
    public static DependencyProperty Geometry1Property;
    public static DependencyProperty Geometry2Property;
    public Rect Bounds { get; }
    public GeometryCombineMode GeometryCombineMode { get; public set; }
    public Geometry Geometry1 { get; public set; }
    public Geometry Geometry2 { get; public set; }
    public CombinedGeometry(Geometry geometry1, Geometry geometry2);
    public CombinedGeometry(GeometryCombineMode geometryCombineMode, Geometry geometry1, Geometry geometry2);
    public CombinedGeometry(GeometryCombineMode geometryCombineMode, Geometry geometry1, Geometry geometry2, Transform transform);
    public virtual Rect get_Bounds();
    public GeometryCombineMode get_GeometryCombineMode();
    public void set_GeometryCombineMode(GeometryCombineMode value);
    public Geometry get_Geometry1();
    public void set_Geometry1(Geometry value);
    public Geometry get_Geometry2();
    public void set_Geometry2(Geometry value);
    public virtual double GetArea(double tolerance, ToleranceType type);
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
    public CombinedGeometry Clone();
    public CombinedGeometry CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.CompositionTarget : DispatcherObject {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static EventHandler Rendering;
    public Visual RootVisual { get; public set; }
    public Matrix TransformToDevice { get; }
    public Matrix TransformFromDevice { get; }
    [SecurityCriticalAttribute]
public virtual Visual get_RootVisual();
    [SecurityCriticalAttribute]
public virtual void set_RootVisual(Visual value);
    public abstract virtual Matrix get_TransformToDevice();
    public abstract virtual Matrix get_TransformFromDevice();
    [CompilerGeneratedAttribute]
public static void add_Rendering(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_Rendering(EventHandler value);
    public virtual void Dispose();
}
public class System.Windows.Media.ContainerVisual : Visual {
    public VisualCollection Children { get; }
    public DependencyObject Parent { get; }
    public Geometry Clip { get; public set; }
    public double Opacity { get; public set; }
    public Brush OpacityMask { get; public set; }
    public CacheMode CacheMode { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffect BitmapEffect { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffectInput BitmapEffectInput { get; public set; }
    public Effect Effect { get; public set; }
    [DefaultValueAttribute("")]
public DoubleCollection XSnappingGuidelines { get; public set; }
    [DefaultValueAttribute("")]
public DoubleCollection YSnappingGuidelines { get; public set; }
    public Rect ContentBounds { get; }
    public Transform Transform { get; public set; }
    public Vector Offset { get; public set; }
    public Rect DescendantBounds { get; }
    protected int VisualChildrenCount { get; }
    public VisualCollection get_Children();
    public DependencyObject get_Parent();
    public Geometry get_Clip();
    public void set_Clip(Geometry value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public Brush get_OpacityMask();
    public void set_OpacityMask(Brush value);
    public CacheMode get_CacheMode();
    public void set_CacheMode(CacheMode value);
    public BitmapEffect get_BitmapEffect();
    public void set_BitmapEffect(BitmapEffect value);
    public BitmapEffectInput get_BitmapEffectInput();
    public void set_BitmapEffectInput(BitmapEffectInput value);
    public Effect get_Effect();
    public void set_Effect(Effect value);
    public DoubleCollection get_XSnappingGuidelines();
    public void set_XSnappingGuidelines(DoubleCollection value);
    public DoubleCollection get_YSnappingGuidelines();
    public void set_YSnappingGuidelines(DoubleCollection value);
    public Rect get_ContentBounds();
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public Vector get_Offset();
    public void set_Offset(Vector value);
    public Rect get_DescendantBounds();
    protected sealed virtual int get_VisualChildrenCount();
    public HitTestResult HitTest(Point point);
    public void HitTest(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters hitTestParameters);
    protected sealed virtual Visual GetVisualChild(int index);
}
public abstract class System.Windows.Media.Converters.BaseIListConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Converters.BoolIListConverter : BaseIListConverter {
}
public class System.Windows.Media.Converters.BrushValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.CacheModeValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.CharIListConverter : BaseIListConverter {
}
public class System.Windows.Media.Converters.DoubleCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.DoubleIListConverter : BaseIListConverter {
}
public class System.Windows.Media.Converters.GeometryValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.Int32CollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.PathFigureCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.PointCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.PointIListConverter : BaseIListConverter {
}
public class System.Windows.Media.Converters.TransformValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.UShortIListConverter : BaseIListConverter {
}
public class System.Windows.Media.Converters.VectorCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
[LocalizabilityAttribute("0")]
public class System.Windows.Media.DashStyle : Animatable {
    public static DependencyProperty OffsetProperty;
    public static DependencyProperty DashesProperty;
    public double Offset { get; public set; }
    public DoubleCollection Dashes { get; public set; }
    public DashStyle(IEnumerable`1<double> dashes, double offset);
    public double get_Offset();
    public void set_Offset(double value);
    public DoubleCollection get_Dashes();
    public void set_Dashes(DoubleCollection value);
    public DashStyle Clone();
    public DashStyle CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public static class System.Windows.Media.DashStyles : object {
    public static DashStyle Solid { get; }
    public static DashStyle Dash { get; }
    public static DashStyle Dot { get; }
    public static DashStyle DashDot { get; }
    public static DashStyle DashDotDot { get; }
    public static DashStyle get_Solid();
    public static DashStyle get_Dash();
    public static DashStyle get_Dot();
    public static DashStyle get_DashDot();
    public static DashStyle get_DashDotDot();
}
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.Media.DoubleCollectionConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.DoubleCollectionValueSerializer")]
public class System.Windows.Media.DoubleCollection : Freezable {
    public double Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Double>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public DoubleCollection(int capacity);
    public DoubleCollection(IEnumerable`1<double> collection);
    public sealed virtual double get_Item(int index);
    public sealed virtual void set_Item(int index, double value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Double>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public DoubleCollection Clone();
    public DoubleCollection CloneCurrentValue();
    public sealed virtual void Add(double value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(double value);
    public sealed virtual int IndexOf(double value);
    public sealed virtual void Insert(int index, double value);
    public sealed virtual bool Remove(double value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(Double[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<double> System.Collections.Generic.IEnumerable<System.Double>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public static DoubleCollection Parse(string source);
}
public class System.Windows.Media.DoubleCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Drawing : Animatable {
    public Rect Bounds { get; }
    public Rect get_Bounds();
    public Drawing Clone();
    public Drawing CloneCurrentValue();
}
public class System.Windows.Media.DrawingBrush : TileBrush {
    public static DependencyProperty DrawingProperty;
    public Drawing Drawing { get; public set; }
    public DrawingBrush(Drawing drawing);
    public Drawing get_Drawing();
    public void set_Drawing(Drawing value);
    protected virtual void GetContentBounds(Rect& contentBounds);
    public DrawingBrush Clone();
    public DrawingBrush CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.DrawingCollection : Animatable {
    public Drawing Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Drawing>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public DrawingCollection(int capacity);
    public DrawingCollection(IEnumerable`1<Drawing> collection);
    public sealed virtual Drawing get_Item(int index);
    public sealed virtual void set_Item(int index, Drawing value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Drawing>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public DrawingCollection Clone();
    public DrawingCollection CloneCurrentValue();
    public sealed virtual void Add(Drawing value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Drawing value);
    public sealed virtual int IndexOf(Drawing value);
    public sealed virtual void Insert(int index, Drawing value);
    public sealed virtual bool Remove(Drawing value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(Drawing[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Drawing> System.Collections.Generic.IEnumerable<System.Windows.Media.Drawing>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
public abstract class System.Windows.Media.DrawingContext : DispatcherObject {
    public void DrawText(FormattedText formattedText, Point origin);
    public abstract virtual void Close();
    private sealed virtual override void System.IDisposable.Dispose();
    protected abstract virtual void DisposeCore();
    protected virtual void VerifyApiNonstructuralChange();
    public abstract virtual void DrawLine(Pen pen, Point point0, Point point1);
    public abstract virtual void DrawLine(Pen pen, Point point0, AnimationClock point0Animations, Point point1, AnimationClock point1Animations);
    public abstract virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle);
    public abstract virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations);
    public abstract virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, double radiusX, double radiusY);
    public abstract virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public abstract virtual void DrawEllipse(Brush brush, Pen pen, Point center, double radiusX, double radiusY);
    public abstract virtual void DrawEllipse(Brush brush, Pen pen, Point center, AnimationClock centerAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public abstract virtual void DrawGeometry(Brush brush, Pen pen, Geometry geometry);
    public abstract virtual void DrawImage(ImageSource imageSource, Rect rectangle);
    public abstract virtual void DrawImage(ImageSource imageSource, Rect rectangle, AnimationClock rectangleAnimations);
    public abstract virtual void DrawGlyphRun(Brush foregroundBrush, GlyphRun glyphRun);
    public abstract virtual void DrawDrawing(Drawing drawing);
    public abstract virtual void DrawVideo(MediaPlayer player, Rect rectangle);
    public abstract virtual void DrawVideo(MediaPlayer player, Rect rectangle, AnimationClock rectangleAnimations);
    public abstract virtual void PushClip(Geometry clipGeometry);
    public abstract virtual void PushOpacityMask(Brush opacityMask);
    public abstract virtual void PushOpacity(double opacity);
    public abstract virtual void PushOpacity(double opacity, AnimationClock opacityAnimations);
    public abstract virtual void PushTransform(Transform transform);
    public abstract virtual void PushGuidelineSet(GuidelineSet guidelines);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public abstract virtual void PushEffect(BitmapEffect effect, BitmapEffectInput effectInput);
    public abstract virtual void Pop();
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.DrawingGroup : Drawing {
    public static DependencyProperty ChildrenProperty;
    public static DependencyProperty ClipGeometryProperty;
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty OpacityMaskProperty;
    public static DependencyProperty TransformProperty;
    public static DependencyProperty GuidelineSetProperty;
    public static DependencyProperty BitmapEffectProperty;
    public static DependencyProperty BitmapEffectInputProperty;
    public DrawingCollection Children { get; public set; }
    public Geometry ClipGeometry { get; public set; }
    public double Opacity { get; public set; }
    public Brush OpacityMask { get; public set; }
    public Transform Transform { get; public set; }
    public GuidelineSet GuidelineSet { get; public set; }
    public BitmapEffect BitmapEffect { get; public set; }
    public BitmapEffectInput BitmapEffectInput { get; public set; }
    public DrawingCollection get_Children();
    public void set_Children(DrawingCollection value);
    public Geometry get_ClipGeometry();
    public void set_ClipGeometry(Geometry value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public Brush get_OpacityMask();
    public void set_OpacityMask(Brush value);
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public GuidelineSet get_GuidelineSet();
    public void set_GuidelineSet(GuidelineSet value);
    public BitmapEffect get_BitmapEffect();
    public void set_BitmapEffect(BitmapEffect value);
    public BitmapEffectInput get_BitmapEffectInput();
    public void set_BitmapEffectInput(BitmapEffectInput value);
    public DrawingContext Open();
    public DrawingContext Append();
    public DrawingGroup Clone();
    public DrawingGroup CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.DrawingImage : ImageSource {
    public static DependencyProperty DrawingProperty;
    public double Width { get; }
    public double Height { get; }
    public ImageMetadata Metadata { get; }
    public Drawing Drawing { get; public set; }
    public DrawingImage(Drawing drawing);
    public virtual double get_Width();
    public virtual double get_Height();
    public virtual ImageMetadata get_Metadata();
    public Drawing get_Drawing();
    public void set_Drawing(Drawing value);
    public DrawingImage Clone();
    public DrawingImage CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.DrawingVisual : ContainerVisual {
    public DrawingGroup Drawing { get; }
    public DrawingGroup get_Drawing();
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    public DrawingContext RenderOpen();
}
public enum System.Windows.Media.EdgeMode : Enum {
    public int value__;
    public static EdgeMode Unspecified;
    public static EdgeMode Aliased;
}
public class System.Windows.Media.Effects.BevelBitmapEffect : BitmapEffect {
    public static DependencyProperty BevelWidthProperty;
    public static DependencyProperty ReliefProperty;
    public static DependencyProperty LightAngleProperty;
    public static DependencyProperty SmoothnessProperty;
    public static DependencyProperty EdgeProfileProperty;
    public double BevelWidth { get; public set; }
    public double Relief { get; public set; }
    public double LightAngle { get; public set; }
    public double Smoothness { get; public set; }
    public EdgeProfile EdgeProfile { get; public set; }
    public double get_BevelWidth();
    public void set_BevelWidth(double value);
    public double get_Relief();
    public void set_Relief(double value);
    public double get_LightAngle();
    public void set_LightAngle(double value);
    public double get_Smoothness();
    public void set_Smoothness(double value);
    public EdgeProfile get_EdgeProfile();
    public void set_EdgeProfile(EdgeProfile value);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    public BevelBitmapEffect Clone();
    public BevelBitmapEffect CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.Effects.BitmapEffect : Animatable {
    [SecurityCriticalAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected abstract virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecurityCriticalAttribute]
protected abstract virtual SafeHandle CreateUnmanagedEffect();
    [SecurityTreatAsSafeAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecurityCriticalAttribute]
protected static void SetValue(SafeHandle effect, string propertyName, object value);
    [SecurityCriticalAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecurityTreatAsSafeAttribute]
protected static SafeHandle CreateBitmapEffectOuter();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected static void InitializeBitmapEffect(SafeHandle outerObject, SafeHandle innerObject);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapSource GetOutput(BitmapEffectInput input);
    public BitmapEffect Clone();
    public BitmapEffect CloneCurrentValue();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Effects.BitmapEffectCollection : Animatable {
    public BitmapEffect Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Effects.BitmapEffect>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public BitmapEffectCollection(int capacity);
    public BitmapEffectCollection(IEnumerable`1<BitmapEffect> collection);
    public sealed virtual BitmapEffect get_Item(int index);
    public sealed virtual void set_Item(int index, BitmapEffect value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Effects.BitmapEffect>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public BitmapEffectCollection Clone();
    public BitmapEffectCollection CloneCurrentValue();
    public sealed virtual void Add(BitmapEffect value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(BitmapEffect value);
    public sealed virtual int IndexOf(BitmapEffect value);
    public sealed virtual void Insert(int index, BitmapEffect value);
    public sealed virtual bool Remove(BitmapEffect value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(BitmapEffect[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<BitmapEffect> System.Collections.Generic.IEnumerable<System.Windows.Media.Effects.BitmapEffect>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Effects.BitmapEffectGroup : BitmapEffect {
    public static DependencyProperty ChildrenProperty;
    public BitmapEffectCollection Children { get; public set; }
    public BitmapEffectCollection get_Children();
    public void set_Children(BitmapEffectCollection value);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    public BitmapEffectGroup Clone();
    public BitmapEffectGroup CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Effects.BitmapEffectInput : Animatable {
    public static DependencyProperty InputProperty;
    public static DependencyProperty AreaToApplyEffectUnitsProperty;
    public static DependencyProperty AreaToApplyEffectProperty;
    public static BitmapSource ContextInputSource { get; }
    public BitmapSource Input { get; public set; }
    public BrushMappingMode AreaToApplyEffectUnits { get; public set; }
    public Rect AreaToApplyEffect { get; public set; }
    public BitmapEffectInput(BitmapSource input);
    public static BitmapSource get_ContextInputSource();
    public BitmapSource get_Input();
    public void set_Input(BitmapSource value);
    public BrushMappingMode get_AreaToApplyEffectUnits();
    public void set_AreaToApplyEffectUnits(BrushMappingMode value);
    public Rect get_AreaToApplyEffect();
    public void set_AreaToApplyEffect(Rect value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInput();
    public BitmapEffectInput Clone();
    public BitmapEffectInput CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Effects.BlurBitmapEffect : BitmapEffect {
    public static DependencyProperty RadiusProperty;
    public static DependencyProperty KernelTypeProperty;
    public double Radius { get; public set; }
    public KernelType KernelType { get; public set; }
    public double get_Radius();
    public void set_Radius(double value);
    public KernelType get_KernelType();
    public void set_KernelType(KernelType value);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    public BlurBitmapEffect Clone();
    public BlurBitmapEffect CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Effects.BlurEffect : Effect {
    public static DependencyProperty RadiusProperty;
    public static DependencyProperty KernelTypeProperty;
    public static DependencyProperty RenderingBiasProperty;
    public double Radius { get; public set; }
    public KernelType KernelType { get; public set; }
    public RenderingBias RenderingBias { get; public set; }
    public double get_Radius();
    public void set_Radius(double value);
    public KernelType get_KernelType();
    public void set_KernelType(KernelType value);
    public RenderingBias get_RenderingBias();
    public void set_RenderingBias(RenderingBias value);
    public BlurEffect Clone();
    public BlurEffect CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Effects.DropShadowBitmapEffect : BitmapEffect {
    public static DependencyProperty ShadowDepthProperty;
    public static DependencyProperty ColorProperty;
    public static DependencyProperty DirectionProperty;
    public static DependencyProperty NoiseProperty;
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty SoftnessProperty;
    public double ShadowDepth { get; public set; }
    public Color Color { get; public set; }
    public double Direction { get; public set; }
    public double Noise { get; public set; }
    public double Opacity { get; public set; }
    public double Softness { get; public set; }
    public double get_ShadowDepth();
    public void set_ShadowDepth(double value);
    public Color get_Color();
    public void set_Color(Color value);
    public double get_Direction();
    public void set_Direction(double value);
    public double get_Noise();
    public void set_Noise(double value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public double get_Softness();
    public void set_Softness(double value);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    public DropShadowBitmapEffect Clone();
    public DropShadowBitmapEffect CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Effects.DropShadowEffect : Effect {
    public static DependencyProperty ShadowDepthProperty;
    public static DependencyProperty ColorProperty;
    public static DependencyProperty DirectionProperty;
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty BlurRadiusProperty;
    public static DependencyProperty RenderingBiasProperty;
    public double ShadowDepth { get; public set; }
    public Color Color { get; public set; }
    public double Direction { get; public set; }
    public double Opacity { get; public set; }
    public double BlurRadius { get; public set; }
    public RenderingBias RenderingBias { get; public set; }
    public double get_ShadowDepth();
    public void set_ShadowDepth(double value);
    public Color get_Color();
    public void set_Color(Color value);
    public double get_Direction();
    public void set_Direction(double value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public double get_BlurRadius();
    public void set_BlurRadius(double value);
    public RenderingBias get_RenderingBias();
    public void set_RenderingBias(RenderingBias value);
    public DropShadowEffect Clone();
    public DropShadowEffect CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public enum System.Windows.Media.Effects.EdgeProfile : Enum {
    public int value__;
    public static EdgeProfile Linear;
    public static EdgeProfile CurvedIn;
    public static EdgeProfile CurvedOut;
    public static EdgeProfile BulgedUp;
}
public abstract class System.Windows.Media.Effects.Effect : Animatable {
    [BrowsableAttribute("False")]
public static Brush ImplicitInput { get; private set; }
    protected internal GeneralTransform EffectMapping { get; }
    public static Brush get_ImplicitInput();
    private static void set_ImplicitInput(Brush value);
    protected internal virtual GeneralTransform get_EffectMapping();
    public Effect Clone();
    public Effect CloneCurrentValue();
}
public class System.Windows.Media.Effects.EmbossBitmapEffect : BitmapEffect {
    public static DependencyProperty LightAngleProperty;
    public static DependencyProperty ReliefProperty;
    public double LightAngle { get; public set; }
    public double Relief { get; public set; }
    public double get_LightAngle();
    public void set_LightAngle(double value);
    public double get_Relief();
    public void set_Relief(double value);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    public EmbossBitmapEffect Clone();
    public EmbossBitmapEffect CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public enum System.Windows.Media.Effects.KernelType : Enum {
    public int value__;
    public static KernelType Gaussian;
    public static KernelType Box;
}
public class System.Windows.Media.Effects.OuterGlowBitmapEffect : BitmapEffect {
    public static DependencyProperty GlowColorProperty;
    public static DependencyProperty GlowSizeProperty;
    public static DependencyProperty NoiseProperty;
    public static DependencyProperty OpacityProperty;
    public Color GlowColor { get; public set; }
    public double GlowSize { get; public set; }
    public double Noise { get; public set; }
    public double Opacity { get; public set; }
    public Color get_GlowColor();
    public void set_GlowColor(Color value);
    public double get_GlowSize();
    public void set_GlowSize(double value);
    public double get_Noise();
    public void set_Noise(double value);
    public double get_Opacity();
    public void set_Opacity(double value);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecuritySafeCriticalAttribute]
protected virtual SafeHandle CreateUnmanagedEffect();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    public OuterGlowBitmapEffect Clone();
    public OuterGlowBitmapEffect CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Effects.PixelShader : Animatable {
    public static DependencyProperty UriSourceProperty;
    public static DependencyProperty ShaderRenderModeProperty;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static EventHandler InvalidPixelShaderEncountered;
    public Uri UriSource { get; public set; }
    public ShaderRenderMode ShaderRenderMode { get; public set; }
    public Uri get_UriSource();
    public void set_UriSource(Uri value);
    public ShaderRenderMode get_ShaderRenderMode();
    public void set_ShaderRenderMode(ShaderRenderMode value);
    [CompilerGeneratedAttribute]
public static void add_InvalidPixelShaderEncountered(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_InvalidPixelShaderEncountered(EventHandler value);
    public void SetStreamSource(Stream source);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public PixelShader Clone();
    public PixelShader CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public enum System.Windows.Media.Effects.RenderingBias : Enum {
    public int value__;
    public static RenderingBias Performance;
    public static RenderingBias Quality;
}
public enum System.Windows.Media.Effects.SamplingMode : Enum {
    public int value__;
    public static SamplingMode NearestNeighbor;
    public static SamplingMode Bilinear;
    public static SamplingMode Auto;
}
public abstract class System.Windows.Media.Effects.ShaderEffect : Effect {
    protected static DependencyProperty PixelShaderProperty;
    protected double PaddingTop { get; protected set; }
    protected double PaddingBottom { get; protected set; }
    protected double PaddingLeft { get; protected set; }
    protected double PaddingRight { get; protected set; }
    protected int DdxUvDdyUvRegisterIndex { get; protected set; }
    protected PixelShader PixelShader { get; protected set; }
    protected double get_PaddingTop();
    protected void set_PaddingTop(double value);
    protected double get_PaddingBottom();
    protected void set_PaddingBottom(double value);
    protected double get_PaddingLeft();
    protected void set_PaddingLeft(double value);
    protected double get_PaddingRight();
    protected void set_PaddingRight(double value);
    protected int get_DdxUvDdyUvRegisterIndex();
    protected void set_DdxUvDdyUvRegisterIndex(int value);
    protected PixelShader get_PixelShader();
    protected void set_PixelShader(PixelShader value);
    protected void UpdateShaderValue(DependencyProperty dp);
    protected static PropertyChangedCallback PixelShaderConstantCallback(int floatRegisterIndex);
    protected static PropertyChangedCallback PixelShaderSamplerCallback(int samplerRegisterIndex);
    protected static PropertyChangedCallback PixelShaderSamplerCallback(int samplerRegisterIndex, SamplingMode samplingMode);
    protected static DependencyProperty RegisterPixelShaderSamplerProperty(string dpName, Type ownerType, int samplerRegisterIndex);
    protected static DependencyProperty RegisterPixelShaderSamplerProperty(string dpName, Type ownerType, int samplerRegisterIndex, SamplingMode samplingMode);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public ShaderEffect Clone();
    public ShaderEffect CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public enum System.Windows.Media.Effects.ShaderRenderMode : Enum {
    public int value__;
    public static ShaderRenderMode Auto;
    public static ShaderRenderMode SoftwareOnly;
    public static ShaderRenderMode HardwareOnly;
}
public class System.Windows.Media.EllipseGeometry : Geometry {
    public static DependencyProperty RadiusXProperty;
    public static DependencyProperty RadiusYProperty;
    public static DependencyProperty CenterProperty;
    public Rect Bounds { get; }
    public double RadiusX { get; public set; }
    public double RadiusY { get; public set; }
    public Point Center { get; public set; }
    public EllipseGeometry(Rect rect);
    public EllipseGeometry(Point center, double radiusX, double radiusY);
    public EllipseGeometry(Point center, double radiusX, double radiusY, Transform transform);
    public virtual Rect get_Bounds();
    public double get_RadiusX();
    public void set_RadiusX(double value);
    public double get_RadiusY();
    public void set_RadiusY(double value);
    public Point get_Center();
    public void set_Center(Point value);
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
    public virtual double GetArea(double tolerance, ToleranceType type);
    public EllipseGeometry Clone();
    public EllipseGeometry CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.ExceptionEventArgs : EventArgs {
    public Exception ErrorException { get; }
    internal ExceptionEventArgs(Exception errorException);
    public Exception get_ErrorException();
}
public class System.Windows.Media.FamilyTypeface : object {
    public FontStyle Style { get; public set; }
    public FontWeight Weight { get; public set; }
    public FontStretch Stretch { get; public set; }
    public double UnderlinePosition { get; public set; }
    public double UnderlineThickness { get; public set; }
    public double StrikethroughPosition { get; public set; }
    public double StrikethroughThickness { get; public set; }
    public double CapsHeight { get; public set; }
    public double XHeight { get; public set; }
    public IDictionary`2<XmlLanguage, string> AdjustedFaceNames { get; }
    public string DeviceFontName { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public CharacterMetricsDictionary DeviceFontCharacterMetrics { get; }
    public FontStyle get_Style();
    public void set_Style(FontStyle value);
    public FontWeight get_Weight();
    public void set_Weight(FontWeight value);
    public FontStretch get_Stretch();
    public void set_Stretch(FontStretch value);
    public double get_UnderlinePosition();
    public void set_UnderlinePosition(double value);
    public double get_UnderlineThickness();
    public void set_UnderlineThickness(double value);
    public double get_StrikethroughPosition();
    public void set_StrikethroughPosition(double value);
    public double get_StrikethroughThickness();
    public void set_StrikethroughThickness(double value);
    public double get_CapsHeight();
    public void set_CapsHeight(double value);
    public double get_XHeight();
    public void set_XHeight(double value);
    public IDictionary`2<XmlLanguage, string> get_AdjustedFaceNames();
    public string get_DeviceFontName();
    public void set_DeviceFontName(string value);
    public CharacterMetricsDictionary get_DeviceFontCharacterMetrics();
    public bool Equals(FamilyTypeface typeface);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.FamilyTypefaceCollection : object {
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public FamilyTypeface Item { get; public set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual FamilyTypeface get_Item(int index);
    public sealed virtual void set_Item(int index, FamilyTypeface value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual IEnumerator`1<FamilyTypeface> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(FamilyTypeface item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(FamilyTypeface item);
    public sealed virtual void CopyTo(FamilyTypeface[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual bool Remove(FamilyTypeface item);
    public sealed virtual int IndexOf(FamilyTypeface item);
    public sealed virtual void Insert(int index, FamilyTypeface item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
public enum System.Windows.Media.FillRule : Enum {
    public int value__;
    public static FillRule EvenOdd;
    public static FillRule Nonzero;
}
public class System.Windows.Media.FontEmbeddingManager : object {
    [CLSCompliantAttribute("False")]
public ICollection`1<Uri> GlyphTypefaceUris { get; }
    public ICollection`1<Uri> get_GlyphTypefaceUris();
    public void RecordUsage(GlyphRun glyphRun);
    [CLSCompliantAttribute("False")]
public ICollection`1<ushort> GetUsedGlyphs(Uri glyphTypeface);
}
public enum System.Windows.Media.FontEmbeddingRight : Enum {
    public int value__;
    public static FontEmbeddingRight Installable;
    public static FontEmbeddingRight InstallableButNoSubsetting;
    public static FontEmbeddingRight InstallableButWithBitmapsOnly;
    public static FontEmbeddingRight InstallableButNoSubsettingAndWithBitmapsOnly;
    public static FontEmbeddingRight RestrictedLicense;
    public static FontEmbeddingRight PreviewAndPrint;
    public static FontEmbeddingRight PreviewAndPrintButNoSubsetting;
    public static FontEmbeddingRight PreviewAndPrintButWithBitmapsOnly;
    public static FontEmbeddingRight PreviewAndPrintButNoSubsettingAndWithBitmapsOnly;
    public static FontEmbeddingRight Editable;
    public static FontEmbeddingRight EditableButNoSubsetting;
    public static FontEmbeddingRight EditableButWithBitmapsOnly;
    public static FontEmbeddingRight EditableButNoSubsettingAndWithBitmapsOnly;
}
[ValueSerializerAttribute("System.Windows.Media.FontFamilyValueSerializer")]
[LocalizabilityAttribute("14")]
[TypeConverterAttribute("System.Windows.Media.FontFamilyConverter")]
public class System.Windows.Media.FontFamily : object {
    [DesignerSerializationVisibilityAttribute("2")]
public LanguageSpecificStringDictionary FamilyNames { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public FamilyTypefaceCollection FamilyTypefaces { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public FontFamilyMapCollection FamilyMaps { get; }
    public string Source { get; }
    public Uri BaseUri { get; }
    public double Baseline { get; public set; }
    public double LineSpacing { get; public set; }
    public FontFamily(string familyName);
    public FontFamily(Uri baseUri, string familyName);
    public LanguageSpecificStringDictionary get_FamilyNames();
    public FamilyTypefaceCollection get_FamilyTypefaces();
    public FontFamilyMapCollection get_FamilyMaps();
    public string get_Source();
    public Uri get_BaseUri();
    public double get_Baseline();
    public void set_Baseline(double value);
    public double get_LineSpacing();
    public void set_LineSpacing(double value);
    public virtual string ToString();
    [CLSCompliantAttribute("False")]
public ICollection`1<Typeface> GetTypefaces();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
public class System.Windows.Media.FontFamilyConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo cultureInfo, object o);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.FontFamilyMap : object {
    [DesignerSerializationOptionsAttribute("1")]
public string Unicode { get; public set; }
    [DesignerSerializationOptionsAttribute("1")]
public string Target { get; public set; }
    public double Scale { get; public set; }
    public XmlLanguage Language { get; public set; }
    public string get_Unicode();
    public void set_Unicode(string value);
    public string get_Target();
    public void set_Target(string value);
    public double get_Scale();
    public void set_Scale(double value);
    public XmlLanguage get_Language();
    public void set_Language(XmlLanguage value);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.FontFamilyMapCollection : object {
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public FontFamilyMap Item { get; public set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual FontFamilyMap get_Item(int index);
    public sealed virtual void set_Item(int index, FontFamilyMap value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual IEnumerator`1<FontFamilyMap> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(FontFamilyMap item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(FontFamilyMap item);
    public sealed virtual void CopyTo(FontFamilyMap[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual bool Remove(FontFamilyMap item);
    public sealed virtual int IndexOf(FontFamilyMap item);
    public sealed virtual void Insert(int index, FontFamilyMap item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
public class System.Windows.Media.FontFamilyValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public static class System.Windows.Media.Fonts : object {
    public static ICollection`1<FontFamily> SystemFontFamilies { get; }
    public static ICollection`1<Typeface> SystemTypefaces { get; }
    public static ICollection`1<FontFamily> get_SystemFontFamilies();
    public static ICollection`1<Typeface> get_SystemTypefaces();
    public static ICollection`1<FontFamily> GetFontFamilies(string location);
    public static ICollection`1<FontFamily> GetFontFamilies(Uri baseUri);
    public static ICollection`1<FontFamily> GetFontFamilies(Uri baseUri, string location);
    public static ICollection`1<Typeface> GetTypefaces(string location);
    public static ICollection`1<Typeface> GetTypefaces(Uri baseUri);
    public static ICollection`1<Typeface> GetTypefaces(Uri baseUri, string location);
}
public class System.Windows.Media.FormattedText : object {
    public string Text { get; }
    public FlowDirection FlowDirection { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    public double LineHeight { get; public set; }
    public double MaxTextWidth { get; public set; }
    public double MaxTextHeight { get; public set; }
    public int MaxLineCount { get; public set; }
    public TextTrimming Trimming { get; public set; }
    public double Height { get; }
    public double Extent { get; }
    public double Baseline { get; }
    public double OverhangAfter { get; }
    public double OverhangLeading { get; }
    public double OverhangTrailing { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public double MinWidth { get; }
    public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground);
    public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground, NumberSubstitution numberSubstitution);
    public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground, NumberSubstitution numberSubstitution, TextFormattingMode textFormattingMode);
    public string get_Text();
    public FlowDirection get_FlowDirection();
    public void set_FlowDirection(FlowDirection value);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public double get_LineHeight();
    public void set_LineHeight(double value);
    public double get_MaxTextWidth();
    public void set_MaxTextWidth(double value);
    public double get_MaxTextHeight();
    public void set_MaxTextHeight(double value);
    public int get_MaxLineCount();
    public void set_MaxLineCount(int value);
    public TextTrimming get_Trimming();
    public void set_Trimming(TextTrimming value);
    public double get_Height();
    public double get_Extent();
    public double get_Baseline();
    public double get_OverhangAfter();
    public double get_OverhangLeading();
    public double get_OverhangTrailing();
    public double get_Width();
    public double get_WidthIncludingTrailingWhitespace();
    public double get_MinWidth();
    public void SetForegroundBrush(Brush foregroundBrush);
    public void SetForegroundBrush(Brush foregroundBrush, int startIndex, int count);
    public void SetFontFamily(string fontFamily);
    public void SetFontFamily(string fontFamily, int startIndex, int count);
    public void SetFontFamily(FontFamily fontFamily);
    public void SetFontFamily(FontFamily fontFamily, int startIndex, int count);
    public void SetFontSize(double emSize);
    public void SetFontSize(double emSize, int startIndex, int count);
    public void SetCulture(CultureInfo culture);
    public void SetCulture(CultureInfo culture, int startIndex, int count);
    public void SetNumberSubstitution(NumberSubstitution numberSubstitution);
    public void SetNumberSubstitution(NumberSubstitution numberSubstitution, int startIndex, int count);
    public void SetFontWeight(FontWeight weight);
    public void SetFontWeight(FontWeight weight, int startIndex, int count);
    public void SetFontStyle(FontStyle style);
    public void SetFontStyle(FontStyle style, int startIndex, int count);
    public void SetFontStretch(FontStretch stretch);
    public void SetFontStretch(FontStretch stretch, int startIndex, int count);
    public void SetFontTypeface(Typeface typeface);
    public void SetFontTypeface(Typeface typeface, int startIndex, int count);
    public void SetTextDecorations(TextDecorationCollection textDecorations);
    public void SetTextDecorations(TextDecorationCollection textDecorations, int startIndex, int count);
    public void SetMaxTextWidths(Double[] maxTextWidths);
    public Double[] GetMaxTextWidths();
    public Geometry BuildHighlightGeometry(Point origin);
    public Geometry BuildGeometry(Point origin);
    public Geometry BuildHighlightGeometry(Point origin, int startIndex, int count);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.GeneralTransform : Animatable {
    public GeneralTransform Inverse { get; }
    public abstract virtual GeneralTransform get_Inverse();
    public abstract virtual bool TryTransform(Point inPoint, Point& result);
    public Point Transform(Point point);
    public abstract virtual Rect TransformBounds(Rect rect);
    public GeneralTransform Clone();
    public GeneralTransform CloneCurrentValue();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.GeneralTransformCollection : Animatable {
    public GeneralTransform Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.GeneralTransform>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public GeneralTransformCollection(int capacity);
    public GeneralTransformCollection(IEnumerable`1<GeneralTransform> collection);
    public sealed virtual GeneralTransform get_Item(int index);
    public sealed virtual void set_Item(int index, GeneralTransform value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.GeneralTransform>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public GeneralTransformCollection Clone();
    public GeneralTransformCollection CloneCurrentValue();
    public sealed virtual void Add(GeneralTransform value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(GeneralTransform value);
    public sealed virtual int IndexOf(GeneralTransform value);
    public sealed virtual void Insert(int index, GeneralTransform value);
    public sealed virtual bool Remove(GeneralTransform value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(GeneralTransform[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<GeneralTransform> System.Collections.Generic.IEnumerable<System.Windows.Media.GeneralTransform>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
[LocalizabilityAttribute("0")]
public class System.Windows.Media.GeneralTransformGroup : GeneralTransform {
    public static DependencyProperty ChildrenProperty;
    public GeneralTransform Inverse { get; }
    public GeneralTransformCollection Children { get; public set; }
    public virtual GeneralTransform get_Inverse();
    public GeneralTransformCollection get_Children();
    public void set_Children(GeneralTransformCollection value);
    public virtual bool TryTransform(Point inPoint, Point& result);
    public virtual Rect TransformBounds(Rect rect);
    public GeneralTransformGroup Clone();
    public GeneralTransformGroup CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[TypeConverterAttribute("System.Windows.Media.GeometryConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.GeometryValueSerializer")]
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Geometry : Animatable {
    public static DependencyProperty TransformProperty;
    public Transform Transform { get; public set; }
    public static Geometry Empty { get; }
    public Rect Bounds { get; }
    public static double StandardFlatteningTolerance { get; }
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public static Geometry get_Empty();
    public virtual Rect get_Bounds();
    public static double get_StandardFlatteningTolerance();
    public Geometry Clone();
    public Geometry CloneCurrentValue();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public static Geometry Parse(string source);
    public virtual Rect GetRenderBounds(Pen pen, double tolerance, ToleranceType type);
    public Rect GetRenderBounds(Pen pen);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTransform();
    [SecurityCriticalAttribute]
public virtual double GetArea(double tolerance, ToleranceType type);
    public double GetArea();
    public abstract virtual bool IsEmpty();
    public abstract virtual bool MayHaveCurves();
    public bool FillContains(Point hitPoint, double tolerance, ToleranceType type);
    public bool FillContains(Point hitPoint);
    public bool StrokeContains(Pen pen, Point hitPoint, double tolerance, ToleranceType type);
    public bool StrokeContains(Pen pen, Point hitPoint);
    public bool FillContains(Geometry geometry, double tolerance, ToleranceType type);
    public bool FillContains(Geometry geometry);
    public virtual IntersectionDetail FillContainsWithDetail(Geometry geometry, double tolerance, ToleranceType type);
    public IntersectionDetail FillContainsWithDetail(Geometry geometry);
    public IntersectionDetail StrokeContainsWithDetail(Pen pen, Geometry geometry, double tolerance, ToleranceType type);
    public IntersectionDetail StrokeContainsWithDetail(Pen pen, Geometry geometry);
    [SecurityCriticalAttribute]
public virtual PathGeometry GetFlattenedPathGeometry(double tolerance, ToleranceType type);
    public PathGeometry GetFlattenedPathGeometry();
    [SecurityCriticalAttribute]
public virtual PathGeometry GetWidenedPathGeometry(Pen pen, double tolerance, ToleranceType type);
    public PathGeometry GetWidenedPathGeometry(Pen pen);
    public static PathGeometry Combine(Geometry geometry1, Geometry geometry2, GeometryCombineMode mode, Transform transform, double tolerance, ToleranceType type);
    public static PathGeometry Combine(Geometry geometry1, Geometry geometry2, GeometryCombineMode mode, Transform transform);
    [SecurityCriticalAttribute]
public virtual PathGeometry GetOutlinedPathGeometry(double tolerance, ToleranceType type);
    public PathGeometry GetOutlinedPathGeometry();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.GeometryCollection : Animatable {
    public Geometry Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Geometry>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public GeometryCollection(int capacity);
    public GeometryCollection(IEnumerable`1<Geometry> collection);
    public sealed virtual Geometry get_Item(int index);
    public sealed virtual void set_Item(int index, Geometry value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Geometry>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public GeometryCollection Clone();
    public GeometryCollection CloneCurrentValue();
    public sealed virtual void Add(Geometry value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Geometry value);
    public sealed virtual int IndexOf(Geometry value);
    public sealed virtual void Insert(int index, Geometry value);
    public sealed virtual bool Remove(Geometry value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(Geometry[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Geometry> System.Collections.Generic.IEnumerable<System.Windows.Media.Geometry>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
public enum System.Windows.Media.GeometryCombineMode : Enum {
    public int value__;
    public static GeometryCombineMode Union;
    public static GeometryCombineMode Intersect;
    public static GeometryCombineMode Xor;
    public static GeometryCombineMode Exclude;
}
public class System.Windows.Media.GeometryConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.GeometryDrawing : Drawing {
    public static DependencyProperty BrushProperty;
    public static DependencyProperty PenProperty;
    public static DependencyProperty GeometryProperty;
    public Brush Brush { get; public set; }
    public Pen Pen { get; public set; }
    public Geometry Geometry { get; public set; }
    public GeometryDrawing(Brush brush, Pen pen, Geometry geometry);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    public Pen get_Pen();
    public void set_Pen(Pen value);
    public Geometry get_Geometry();
    public void set_Geometry(Geometry value);
    public GeometryDrawing Clone();
    public GeometryDrawing CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.GeometryGroup : Geometry {
    public static DependencyProperty FillRuleProperty;
    public static DependencyProperty ChildrenProperty;
    public FillRule FillRule { get; public set; }
    public GeometryCollection Children { get; public set; }
    public FillRule get_FillRule();
    public void set_FillRule(FillRule value);
    public GeometryCollection get_Children();
    public void set_Children(GeometryCollection value);
    public GeometryGroup Clone();
    public GeometryGroup CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
}
public class System.Windows.Media.GeometryHitTestParameters : HitTestParameters {
    public Geometry HitGeometry { get; }
    public GeometryHitTestParameters(Geometry geometry);
    public Geometry get_HitGeometry();
}
public class System.Windows.Media.GeometryHitTestResult : HitTestResult {
    public IntersectionDetail IntersectionDetail { get; }
    public Visual VisualHit { get; }
    public GeometryHitTestResult(Visual visualHit, IntersectionDetail intersectionDetail);
    public IntersectionDetail get_IntersectionDetail();
    public Visual get_VisualHit();
}
public class System.Windows.Media.GlyphRun : object {
    public Point BaselineOrigin { get; public set; }
    public double FontRenderingEmSize { get; public set; }
    public GlyphTypeface GlyphTypeface { get; public set; }
    public int BidiLevel { get; public set; }
    public bool IsSideways { get; public set; }
    [CLSCompliantAttribute("False")]
[TypeConverterAttribute("System.Windows.Media.Converters.BoolIListConverter")]
public IList`1<bool> CaretStops { get; public set; }
    public bool IsHitTestable { get; }
    [CLSCompliantAttribute("False")]
[TypeConverterAttribute("System.Windows.Media.Converters.UShortIListConverter")]
public IList`1<ushort> ClusterMap { get; public set; }
    [CLSCompliantAttribute("False")]
[TypeConverterAttribute("System.Windows.Media.Converters.CharIListConverter")]
public IList`1<char> Characters { get; public set; }
    [TypeConverterAttribute("System.Windows.Media.Converters.UShortIListConverter")]
[CLSCompliantAttribute("False")]
public IList`1<ushort> GlyphIndices { get; public set; }
    [TypeConverterAttribute("System.Windows.Media.Converters.DoubleIListConverter")]
[CLSCompliantAttribute("False")]
public IList`1<double> AdvanceWidths { get; public set; }
    [CLSCompliantAttribute("False")]
[TypeConverterAttribute("System.Windows.Media.Converters.PointIListConverter")]
public IList`1<Point> GlyphOffsets { get; public set; }
    public XmlLanguage Language { get; public set; }
    public string DeviceFontName { get; public set; }
    [CLSCompliantAttribute("False")]
public GlyphRun(GlyphTypeface glyphTypeface, int bidiLevel, bool isSideways, double renderingEmSize, IList`1<ushort> glyphIndices, Point baselineOrigin, IList`1<double> advanceWidths, IList`1<Point> glyphOffsets, IList`1<char> characters, string deviceFontName, IList`1<ushort> clusterMap, IList`1<bool> caretStops, XmlLanguage language);
    public Point get_BaselineOrigin();
    public void set_BaselineOrigin(Point value);
    public double get_FontRenderingEmSize();
    public void set_FontRenderingEmSize(double value);
    public GlyphTypeface get_GlyphTypeface();
    public void set_GlyphTypeface(GlyphTypeface value);
    public int get_BidiLevel();
    public void set_BidiLevel(int value);
    public bool get_IsSideways();
    public void set_IsSideways(bool value);
    public IList`1<bool> get_CaretStops();
    public void set_CaretStops(IList`1<bool> value);
    public bool get_IsHitTestable();
    public IList`1<ushort> get_ClusterMap();
    public void set_ClusterMap(IList`1<ushort> value);
    public IList`1<char> get_Characters();
    public void set_Characters(IList`1<char> value);
    public IList`1<ushort> get_GlyphIndices();
    public void set_GlyphIndices(IList`1<ushort> value);
    public IList`1<double> get_AdvanceWidths();
    public void set_AdvanceWidths(IList`1<double> value);
    public IList`1<Point> get_GlyphOffsets();
    public void set_GlyphOffsets(IList`1<Point> value);
    public XmlLanguage get_Language();
    public void set_Language(XmlLanguage value);
    public string get_DeviceFontName();
    public void set_DeviceFontName(string value);
    public double GetDistanceFromCaretCharacterHit(CharacterHit characterHit);
    public CharacterHit GetCaretCharacterHitFromDistance(double distance, Boolean& isInside);
    public CharacterHit GetNextCaretCharacterHit(CharacterHit characterHit);
    public CharacterHit GetPreviousCaretCharacterHit(CharacterHit characterHit);
    public Rect ComputeInkBoundingBox();
    public Geometry BuildGeometry();
    public Rect ComputeAlignmentBox();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
}
public class System.Windows.Media.GlyphRunDrawing : Drawing {
    public static DependencyProperty GlyphRunProperty;
    public static DependencyProperty ForegroundBrushProperty;
    public GlyphRun GlyphRun { get; public set; }
    public Brush ForegroundBrush { get; public set; }
    public GlyphRunDrawing(Brush foregroundBrush, GlyphRun glyphRun);
    public GlyphRun get_GlyphRun();
    public void set_GlyphRun(GlyphRun value);
    public Brush get_ForegroundBrush();
    public void set_ForegroundBrush(Brush value);
    public GlyphRunDrawing Clone();
    public GlyphRunDrawing CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.GlyphTypeface : object {
    public Uri FontUri { get; public set; }
    public IDictionary`2<CultureInfo, string> FamilyNames { get; }
    public IDictionary`2<CultureInfo, string> FaceNames { get; }
    public IDictionary`2<CultureInfo, string> Win32FamilyNames { get; }
    public IDictionary`2<CultureInfo, string> Win32FaceNames { get; }
    public IDictionary`2<CultureInfo, string> VersionStrings { get; }
    public IDictionary`2<CultureInfo, string> Copyrights { get; }
    public IDictionary`2<CultureInfo, string> ManufacturerNames { get; }
    public IDictionary`2<CultureInfo, string> Trademarks { get; }
    public IDictionary`2<CultureInfo, string> DesignerNames { get; }
    public IDictionary`2<CultureInfo, string> Descriptions { get; }
    public IDictionary`2<CultureInfo, string> VendorUrls { get; }
    public IDictionary`2<CultureInfo, string> DesignerUrls { get; }
    public IDictionary`2<CultureInfo, string> LicenseDescriptions { get; }
    public IDictionary`2<CultureInfo, string> SampleTexts { get; }
    public FontStyle Style { get; }
    public FontWeight Weight { get; }
    public FontStretch Stretch { get; }
    public double Version { get; }
    public double Height { get; }
    public double Baseline { get; }
    public double CapsHeight { get; }
    public double XHeight { get; }
    public bool Symbol { get; }
    public double UnderlinePosition { get; }
    public double UnderlineThickness { get; }
    public double StrikethroughPosition { get; }
    public double StrikethroughThickness { get; }
    public FontEmbeddingRight EmbeddingRights { get; }
    public IDictionary`2<ushort, double> AdvanceWidths { get; }
    public IDictionary`2<ushort, double> AdvanceHeights { get; }
    public IDictionary`2<ushort, double> LeftSideBearings { get; }
    public IDictionary`2<ushort, double> RightSideBearings { get; }
    public IDictionary`2<ushort, double> TopSideBearings { get; }
    public IDictionary`2<ushort, double> BottomSideBearings { get; }
    public IDictionary`2<ushort, double> DistancesFromHorizontalBaselineToBlackBoxBottom { get; }
    public IDictionary`2<int, ushort> CharacterToGlyphMap { get; }
    public StyleSimulations StyleSimulations { get; public set; }
    public int GlyphCount { get; }
    public GlyphTypeface(Uri typefaceSource);
    public GlyphTypeface(Uri typefaceSource, StyleSimulations styleSimulations);
    [SecurityCriticalAttribute]
public Uri get_FontUri();
    [SecurityCriticalAttribute]
public void set_FontUri(Uri value);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_FamilyNames();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_FaceNames();
    public IDictionary`2<CultureInfo, string> get_Win32FamilyNames();
    public IDictionary`2<CultureInfo, string> get_Win32FaceNames();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_VersionStrings();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_Copyrights();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_ManufacturerNames();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_Trademarks();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_DesignerNames();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_Descriptions();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_VendorUrls();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_DesignerUrls();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_LicenseDescriptions();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_SampleTexts();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public FontStyle get_Style();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public FontWeight get_Weight();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public FontStretch get_Stretch();
    [SecurityCriticalAttribute]
public double get_Version();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public double get_Height();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public double get_Baseline();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public double get_CapsHeight();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public double get_XHeight();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public bool get_Symbol();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public double get_UnderlinePosition();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public double get_UnderlineThickness();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public double get_StrikethroughPosition();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public double get_StrikethroughThickness();
    [SecurityCriticalAttribute]
public FontEmbeddingRight get_EmbeddingRights();
    public IDictionary`2<ushort, double> get_AdvanceWidths();
    public IDictionary`2<ushort, double> get_AdvanceHeights();
    public IDictionary`2<ushort, double> get_LeftSideBearings();
    public IDictionary`2<ushort, double> get_RightSideBearings();
    public IDictionary`2<ushort, double> get_TopSideBearings();
    public IDictionary`2<ushort, double> get_BottomSideBearings();
    public IDictionary`2<ushort, double> get_DistancesFromHorizontalBaselineToBlackBoxBottom();
    [SecurityCriticalAttribute]
public IDictionary`2<int, ushort> get_CharacterToGlyphMap();
    public StyleSimulations get_StyleSimulations();
    public void set_StyleSimulations(StyleSimulations value);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public int get_GlyphCount();
    [SecurityCriticalAttribute]
public virtual int GetHashCode();
    [SecurityCriticalAttribute]
public virtual bool Equals(object o);
    [CLSCompliantAttribute("False")]
public Geometry GetGlyphOutline(ushort glyphIndex, double renderingEmSize, double hintingEmSize);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public Byte[] ComputeSubset(ICollection`1<ushort> glyphs);
    [SecurityCriticalAttribute]
public Stream GetFontStream();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
}
[ContentPropertyAttribute("GradientStops")]
public abstract class System.Windows.Media.GradientBrush : Brush {
    public static DependencyProperty ColorInterpolationModeProperty;
    public static DependencyProperty MappingModeProperty;
    public static DependencyProperty SpreadMethodProperty;
    public static DependencyProperty GradientStopsProperty;
    public ColorInterpolationMode ColorInterpolationMode { get; public set; }
    public BrushMappingMode MappingMode { get; public set; }
    public GradientSpreadMethod SpreadMethod { get; public set; }
    public GradientStopCollection GradientStops { get; public set; }
    protected GradientBrush(GradientStopCollection gradientStopCollection);
    public ColorInterpolationMode get_ColorInterpolationMode();
    public void set_ColorInterpolationMode(ColorInterpolationMode value);
    public BrushMappingMode get_MappingMode();
    public void set_MappingMode(BrushMappingMode value);
    public GradientSpreadMethod get_SpreadMethod();
    public void set_SpreadMethod(GradientSpreadMethod value);
    public GradientStopCollection get_GradientStops();
    public void set_GradientStops(GradientStopCollection value);
    public GradientBrush Clone();
    public GradientBrush CloneCurrentValue();
}
public enum System.Windows.Media.GradientSpreadMethod : Enum {
    public int value__;
    public static GradientSpreadMethod Pad;
    public static GradientSpreadMethod Reflect;
    public static GradientSpreadMethod Repeat;
}
[LocalizabilityAttribute("0")]
public class System.Windows.Media.GradientStop : Animatable {
    public static DependencyProperty ColorProperty;
    public static DependencyProperty OffsetProperty;
    public Color Color { get; public set; }
    public double Offset { get; public set; }
    public GradientStop(Color color, double offset);
    public Color get_Color();
    public void set_Color(Color value);
    public double get_Offset();
    public void set_Offset(double value);
    public GradientStop Clone();
    public GradientStop CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.GradientStopCollection : Animatable {
    public GradientStop Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.GradientStop>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public GradientStopCollection(int capacity);
    public GradientStopCollection(IEnumerable`1<GradientStop> collection);
    public sealed virtual GradientStop get_Item(int index);
    public sealed virtual void set_Item(int index, GradientStop value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.GradientStop>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public GradientStopCollection Clone();
    public GradientStopCollection CloneCurrentValue();
    public sealed virtual void Add(GradientStop value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(GradientStop value);
    public sealed virtual int IndexOf(GradientStop value);
    public sealed virtual void Insert(int index, GradientStop value);
    public sealed virtual bool Remove(GradientStop value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(GradientStop[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<GradientStop> System.Collections.Generic.IEnumerable<System.Windows.Media.GradientStop>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public static GradientStopCollection Parse(string source);
}
public class System.Windows.Media.GuidelineSet : Animatable {
    public static DependencyProperty GuidelinesXProperty;
    public static DependencyProperty GuidelinesYProperty;
    public DoubleCollection GuidelinesX { get; public set; }
    public DoubleCollection GuidelinesY { get; public set; }
    public GuidelineSet(Double[] guidelinesX, Double[] guidelinesY);
    public DoubleCollection get_GuidelinesX();
    public void set_GuidelinesX(DoubleCollection value);
    public DoubleCollection get_GuidelinesY();
    public void set_GuidelinesY(DoubleCollection value);
    public GuidelineSet Clone();
    public GuidelineSet CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public enum System.Windows.Media.HitTestFilterBehavior : Enum {
    public int value__;
    public static HitTestFilterBehavior ContinueSkipSelfAndChildren;
    public static HitTestFilterBehavior ContinueSkipChildren;
    public static HitTestFilterBehavior ContinueSkipSelf;
    public static HitTestFilterBehavior Continue;
    public static HitTestFilterBehavior Stop;
}
public class System.Windows.Media.HitTestFilterCallback : MulticastDelegate {
    public HitTestFilterCallback(object object, IntPtr method);
    public virtual HitTestFilterBehavior Invoke(DependencyObject potentialHitTestTarget);
    public virtual IAsyncResult BeginInvoke(DependencyObject potentialHitTestTarget, AsyncCallback callback, object object);
    public virtual HitTestFilterBehavior EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.Media.HitTestParameters : object {
}
public abstract class System.Windows.Media.HitTestResult : object {
    public DependencyObject VisualHit { get; }
    internal HitTestResult(DependencyObject visualHit);
    public DependencyObject get_VisualHit();
}
public enum System.Windows.Media.HitTestResultBehavior : Enum {
    public int value__;
    public static HitTestResultBehavior Stop;
    public static HitTestResultBehavior Continue;
}
public class System.Windows.Media.HitTestResultCallback : MulticastDelegate {
    public HitTestResultCallback(object object, IntPtr method);
    public virtual HitTestResultBehavior Invoke(HitTestResult result);
    public virtual IAsyncResult BeginInvoke(HitTestResult result, AsyncCallback callback, object object);
    public virtual HitTestResultBehavior EndInvoke(IAsyncResult result);
}
public class System.Windows.Media.HostVisual : ContainerVisual {
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
}
public class System.Windows.Media.ImageBrush : TileBrush {
    public static DependencyProperty ImageSourceProperty;
    public ImageSource ImageSource { get; public set; }
    public ImageBrush(ImageSource image);
    public ImageSource get_ImageSource();
    public void set_ImageSource(ImageSource value);
    public ImageBrush Clone();
    public ImageBrush CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void GetContentBounds(Rect& contentBounds);
}
public class System.Windows.Media.ImageDrawing : Drawing {
    public static DependencyProperty ImageSourceProperty;
    public static DependencyProperty RectProperty;
    public ImageSource ImageSource { get; public set; }
    public Rect Rect { get; public set; }
    public ImageDrawing(ImageSource imageSource, Rect rect);
    public ImageSource get_ImageSource();
    public void set_ImageSource(ImageSource value);
    public Rect get_Rect();
    public void set_Rect(Rect value);
    public ImageDrawing Clone();
    public ImageDrawing CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.ImageMetadata : Freezable {
    public ImageMetadata Clone();
}
[LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.Media.ImageSourceConverter")]
[ValueSerializerAttribute("System.Windows.Media.ImageSourceValueSerializer")]
public abstract class System.Windows.Media.ImageSource : Animatable {
    public double Width { get; }
    public double Height { get; }
    public ImageMetadata Metadata { get; }
    public abstract virtual double get_Width();
    public abstract virtual double get_Height();
    public abstract virtual ImageMetadata get_Metadata();
    public ImageSource Clone();
    public ImageSource CloneCurrentValue();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    protected static double PixelsToDIPs(double dpi, int pixels);
}
public class System.Windows.Media.ImageSourceConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.ImageSourceValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public enum System.Windows.Media.Imaging.BitmapCacheOption : Enum {
    public int value__;
    public static BitmapCacheOption Default;
    public static BitmapCacheOption OnDemand;
    public static BitmapCacheOption OnLoad;
    public static BitmapCacheOption None;
}
public abstract class System.Windows.Media.Imaging.BitmapCodecInfo : object {
    public Guid ContainerFormat { get; }
    public string Author { get; }
    public Version Version { get; }
    public Version SpecificationVersion { get; }
    public string FriendlyName { get; }
    public string DeviceManufacturer { get; }
    public string DeviceModels { get; }
    public string MimeTypes { get; }
    public string FileExtensions { get; }
    public bool SupportsAnimation { get; }
    public bool SupportsLossless { get; }
    public bool SupportsMultipleFrames { get; }
    [SecurityCriticalAttribute]
public virtual Guid get_ContainerFormat();
    [SecurityCriticalAttribute]
public virtual string get_Author();
    [SecurityCriticalAttribute]
public virtual Version get_Version();
    [SecurityCriticalAttribute]
public virtual Version get_SpecificationVersion();
    [SecurityCriticalAttribute]
public virtual string get_FriendlyName();
    [SecurityCriticalAttribute]
public virtual string get_DeviceManufacturer();
    [SecurityCriticalAttribute]
public virtual string get_DeviceModels();
    [SecurityCriticalAttribute]
public virtual string get_MimeTypes();
    [SecurityCriticalAttribute]
public virtual string get_FileExtensions();
    [SecurityCriticalAttribute]
public virtual bool get_SupportsAnimation();
    [SecurityCriticalAttribute]
public virtual bool get_SupportsLossless();
    [SecurityCriticalAttribute]
public virtual bool get_SupportsMultipleFrames();
}
[FlagsAttribute]
public enum System.Windows.Media.Imaging.BitmapCreateOptions : Enum {
    public int value__;
    public static BitmapCreateOptions None;
    public static BitmapCreateOptions PreservePixelFormat;
    public static BitmapCreateOptions DelayCreation;
    public static BitmapCreateOptions IgnoreColorProfile;
    public static BitmapCreateOptions IgnoreImageCache;
}
public abstract class System.Windows.Media.Imaging.BitmapDecoder : DispatcherObject {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler DownloadCompleted;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<DownloadProgressEventArgs> DownloadProgress;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<ExceptionEventArgs> DownloadFailed;
    public BitmapPalette Palette { get; }
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; }
    public BitmapSource Thumbnail { get; }
    public BitmapMetadata Metadata { get; }
    public BitmapCodecInfo CodecInfo { get; }
    public ReadOnlyCollection`1<BitmapFrame> Frames { get; }
    public BitmapSource Preview { get; }
    public bool IsDownloading { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static BitmapDecoder();
    [SecurityCriticalAttribute]
public virtual BitmapPalette get_Palette();
    public virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    [SecurityCriticalAttribute]
public virtual BitmapSource get_Thumbnail();
    [SecurityCriticalAttribute]
public virtual BitmapMetadata get_Metadata();
    [SecurityCriticalAttribute]
public virtual BitmapCodecInfo get_CodecInfo();
    public virtual ReadOnlyCollection`1<BitmapFrame> get_Frames();
    [SecurityCriticalAttribute]
public virtual BitmapSource get_Preview();
    public virtual bool get_IsDownloading();
    [CompilerGeneratedAttribute]
public virtual void add_DownloadCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public virtual void remove_DownloadCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public virtual void add_DownloadProgress(EventHandler`1<DownloadProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_DownloadProgress(EventHandler`1<DownloadProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void add_DownloadFailed(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_DownloadFailed(EventHandler`1<ExceptionEventArgs> value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual override void Finalize();
    public static BitmapDecoder Create(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public static BitmapDecoder Create(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, RequestCachePolicy uriCachePolicy);
    public static BitmapDecoder Create(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public virtual InPlaceBitmapMetadataWriter CreateInPlaceBitmapMetadataWriter();
    public virtual string ToString();
}
public abstract class System.Windows.Media.Imaging.BitmapEncoder : DispatcherObject {
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; public set; }
    public BitmapSource Thumbnail { get; public set; }
    public BitmapMetadata Metadata { get; public set; }
    public BitmapSource Preview { get; public set; }
    public BitmapCodecInfo CodecInfo { get; }
    public BitmapPalette Palette { get; public set; }
    public IList`1<BitmapFrame> Frames { get; public set; }
    public virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    public virtual void set_ColorContexts(ReadOnlyCollection`1<ColorContext> value);
    public virtual BitmapSource get_Thumbnail();
    public virtual void set_Thumbnail(BitmapSource value);
    public virtual BitmapMetadata get_Metadata();
    public virtual void set_Metadata(BitmapMetadata value);
    public virtual BitmapSource get_Preview();
    public virtual void set_Preview(BitmapSource value);
    [SecurityCriticalAttribute]
public virtual BitmapCodecInfo get_CodecInfo();
    public virtual BitmapPalette get_Palette();
    public virtual void set_Palette(BitmapPalette value);
    public virtual IList`1<BitmapFrame> get_Frames();
    public virtual void set_Frames(IList`1<BitmapFrame> value);
    [SecurityCriticalAttribute]
public static BitmapEncoder Create(Guid containerFormat);
    [SecurityCriticalAttribute]
public virtual void Save(Stream stream);
}
public abstract class System.Windows.Media.Imaging.BitmapFrame : BitmapSource {
    public Uri BaseUri { get; public set; }
    public BitmapSource Thumbnail { get; }
    public BitmapDecoder Decoder { get; }
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; }
    public abstract virtual Uri get_BaseUri();
    public abstract virtual void set_BaseUri(Uri value);
    public abstract virtual BitmapSource get_Thumbnail();
    public abstract virtual BitmapDecoder get_Decoder();
    public abstract virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    public static BitmapFrame Create(Uri bitmapUri);
    public static BitmapFrame Create(Uri bitmapUri, RequestCachePolicy uriCachePolicy);
    public static BitmapFrame Create(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public static BitmapFrame Create(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, RequestCachePolicy uriCachePolicy);
    public static BitmapFrame Create(Stream bitmapStream);
    public static BitmapFrame Create(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public static BitmapFrame Create(BitmapSource source);
    public static BitmapFrame Create(BitmapSource source, BitmapSource thumbnail);
    public static BitmapFrame Create(BitmapSource source, BitmapSource thumbnail, BitmapMetadata metadata, ReadOnlyCollection`1<ColorContext> colorContexts);
    public abstract virtual InPlaceBitmapMetadataWriter CreateInPlaceBitmapMetadataWriter();
}
public class System.Windows.Media.Imaging.BitmapImage : BitmapSource {
    public static DependencyProperty UriCachePolicyProperty;
    public static DependencyProperty UriSourceProperty;
    public static DependencyProperty StreamSourceProperty;
    public static DependencyProperty DecodePixelWidthProperty;
    public static DependencyProperty DecodePixelHeightProperty;
    public static DependencyProperty RotationProperty;
    public static DependencyProperty SourceRectProperty;
    public static DependencyProperty CreateOptionsProperty;
    public static DependencyProperty CacheOptionProperty;
    public Uri BaseUri { get; public set; }
    public bool IsDownloading { get; }
    public ImageMetadata Metadata { get; }
    [TypeConverterAttribute("System.Windows.Media.RequestCachePolicyConverter")]
public RequestCachePolicy UriCachePolicy { get; public set; }
    public Uri UriSource { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public Stream StreamSource { get; public set; }
    public int DecodePixelWidth { get; public set; }
    public int DecodePixelHeight { get; public set; }
    public Rotation Rotation { get; public set; }
    public Int32Rect SourceRect { get; public set; }
    public BitmapCreateOptions CreateOptions { get; public set; }
    public BitmapCacheOption CacheOption { get; public set; }
    public BitmapImage(Uri uriSource);
    public BitmapImage(Uri uriSource, RequestCachePolicy uriCachePolicy);
    public sealed virtual Uri get_BaseUri();
    public sealed virtual void set_BaseUri(Uri value);
    public virtual bool get_IsDownloading();
    public virtual ImageMetadata get_Metadata();
    public RequestCachePolicy get_UriCachePolicy();
    public void set_UriCachePolicy(RequestCachePolicy value);
    public Uri get_UriSource();
    public void set_UriSource(Uri value);
    public Stream get_StreamSource();
    public void set_StreamSource(Stream value);
    public int get_DecodePixelWidth();
    public void set_DecodePixelWidth(int value);
    public int get_DecodePixelHeight();
    public void set_DecodePixelHeight(int value);
    public Rotation get_Rotation();
    public void set_Rotation(Rotation value);
    public Int32Rect get_SourceRect();
    public void set_SourceRect(Int32Rect value);
    public BitmapCreateOptions get_CreateOptions();
    public void set_CreateOptions(BitmapCreateOptions value);
    public BitmapCacheOption get_CacheOption();
    public void set_CacheOption(BitmapCacheOption value);
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    public BitmapImage Clone();
    public BitmapImage CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
public class System.Windows.Media.Imaging.BitmapMetadata : ImageMetadata {
    public string Format { get; }
    public string Location { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public ReadOnlyCollection`1<string> Author { get; public set; }
    public string Title { get; public set; }
    public int Rating { get; public set; }
    public string Subject { get; public set; }
    public string Comment { get; public set; }
    public string DateTaken { get; public set; }
    public string ApplicationName { get; public set; }
    public string Copyright { get; public set; }
    public string CameraManufacturer { get; public set; }
    public string CameraModel { get; public set; }
    public ReadOnlyCollection`1<string> Keywords { get; public set; }
    [SecurityCriticalAttribute]
public BitmapMetadata(string containerFormat);
    [SecurityCriticalAttribute]
public string get_Format();
    [SecurityCriticalAttribute]
public string get_Location();
    public bool get_IsReadOnly();
    public bool get_IsFixedSize();
    public ReadOnlyCollection`1<string> get_Author();
    public void set_Author(ReadOnlyCollection`1<string> value);
    public string get_Title();
    public void set_Title(string value);
    public int get_Rating();
    public void set_Rating(int value);
    public string get_Subject();
    public void set_Subject(string value);
    public string get_Comment();
    public void set_Comment(string value);
    public string get_DateTaken();
    public void set_DateTaken(string value);
    public string get_ApplicationName();
    public void set_ApplicationName(string value);
    public string get_Copyright();
    public void set_Copyright(string value);
    public string get_CameraManufacturer();
    public void set_CameraManufacturer(string value);
    public string get_CameraModel();
    public void set_CameraModel(string value);
    public ReadOnlyCollection`1<string> get_Keywords();
    public void set_Keywords(ReadOnlyCollection`1<string> value);
    public BitmapMetadata Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    [SecurityCriticalAttribute]
public void SetQuery(string query, object value);
    [SecurityCriticalAttribute]
public object GetQuery(string query);
    [SecurityCriticalAttribute]
public void RemoveQuery(string query);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    [SecurityCriticalAttribute]
public bool ContainsQuery(string query);
}
public class System.Windows.Media.Imaging.BitmapMetadataBlob : object {
    public BitmapMetadataBlob(Byte[] blob);
    public Byte[] GetBlobValue();
}
public class System.Windows.Media.Imaging.BitmapPalette : DispatcherObject {
    public IList`1<Color> Colors { get; }
    public BitmapPalette(IList`1<Color> colors);
    [SecurityCriticalAttribute]
public BitmapPalette(BitmapSource bitmapSource, int maxColorCount);
    public IList`1<Color> get_Colors();
}
public static class System.Windows.Media.Imaging.BitmapPalettes : object {
    public static BitmapPalette BlackAndWhite { get; }
    public static BitmapPalette BlackAndWhiteTransparent { get; }
    public static BitmapPalette Halftone8 { get; }
    public static BitmapPalette Halftone8Transparent { get; }
    public static BitmapPalette Halftone27 { get; }
    public static BitmapPalette Halftone27Transparent { get; }
    public static BitmapPalette Halftone64 { get; }
    public static BitmapPalette Halftone64Transparent { get; }
    public static BitmapPalette Halftone125 { get; }
    public static BitmapPalette Halftone125Transparent { get; }
    public static BitmapPalette Halftone216 { get; }
    public static BitmapPalette Halftone216Transparent { get; }
    public static BitmapPalette Halftone252 { get; }
    public static BitmapPalette Halftone252Transparent { get; }
    public static BitmapPalette Halftone256 { get; }
    public static BitmapPalette Halftone256Transparent { get; }
    public static BitmapPalette Gray4 { get; }
    public static BitmapPalette Gray4Transparent { get; }
    public static BitmapPalette Gray16 { get; }
    public static BitmapPalette Gray16Transparent { get; }
    public static BitmapPalette Gray256 { get; }
    public static BitmapPalette Gray256Transparent { get; }
    public static BitmapPalette WebPalette { get; }
    public static BitmapPalette WebPaletteTransparent { get; }
    public static BitmapPalette get_BlackAndWhite();
    public static BitmapPalette get_BlackAndWhiteTransparent();
    public static BitmapPalette get_Halftone8();
    public static BitmapPalette get_Halftone8Transparent();
    public static BitmapPalette get_Halftone27();
    public static BitmapPalette get_Halftone27Transparent();
    public static BitmapPalette get_Halftone64();
    public static BitmapPalette get_Halftone64Transparent();
    public static BitmapPalette get_Halftone125();
    public static BitmapPalette get_Halftone125Transparent();
    public static BitmapPalette get_Halftone216();
    public static BitmapPalette get_Halftone216Transparent();
    public static BitmapPalette get_Halftone252();
    public static BitmapPalette get_Halftone252Transparent();
    public static BitmapPalette get_Halftone256();
    public static BitmapPalette get_Halftone256Transparent();
    public static BitmapPalette get_Gray4();
    public static BitmapPalette get_Gray4Transparent();
    public static BitmapPalette get_Gray16();
    public static BitmapPalette get_Gray16Transparent();
    public static BitmapPalette get_Gray256();
    public static BitmapPalette get_Gray256Transparent();
    public static BitmapPalette get_WebPalette();
    public static BitmapPalette get_WebPaletteTransparent();
}
public class System.Windows.Media.Imaging.BitmapSizeOptions : object {
    public bool PreservesAspectRatio { get; }
    public int PixelWidth { get; }
    public int PixelHeight { get; }
    public Rotation Rotation { get; }
    public bool get_PreservesAspectRatio();
    public int get_PixelWidth();
    public int get_PixelHeight();
    public Rotation get_Rotation();
    public static BitmapSizeOptions FromEmptyOptions();
    public static BitmapSizeOptions FromHeight(int pixelHeight);
    public static BitmapSizeOptions FromWidth(int pixelWidth);
    public static BitmapSizeOptions FromWidthAndHeight(int pixelWidth, int pixelHeight);
    public static BitmapSizeOptions FromRotation(Rotation rotation);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Imaging.BitmapSource : ImageSource {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler DownloadCompleted;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<DownloadProgressEventArgs> DownloadProgress;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<ExceptionEventArgs> DownloadFailed;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<ExceptionEventArgs> DecodeFailed;
    public PixelFormat Format { get; }
    public int PixelWidth { get; }
    public int PixelHeight { get; }
    public double DpiX { get; }
    public double DpiY { get; }
    public BitmapPalette Palette { get; }
    public bool IsDownloading { get; }
    public double Width { get; }
    public double Height { get; }
    public ImageMetadata Metadata { get; }
    public virtual PixelFormat get_Format();
    public virtual int get_PixelWidth();
    public virtual int get_PixelHeight();
    public virtual double get_DpiX();
    public virtual double get_DpiY();
    public virtual BitmapPalette get_Palette();
    public virtual bool get_IsDownloading();
    public virtual double get_Width();
    public virtual double get_Height();
    public virtual ImageMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public virtual void add_DownloadCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public virtual void remove_DownloadCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public virtual void add_DownloadProgress(EventHandler`1<DownloadProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_DownloadProgress(EventHandler`1<DownloadProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void add_DownloadFailed(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_DownloadFailed(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void add_DecodeFailed(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_DecodeFailed(EventHandler`1<ExceptionEventArgs> value);
    public static BitmapSource Create(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat, BitmapPalette palette, Array pixels, int stride);
    [SecurityCriticalAttribute]
public static BitmapSource Create(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat, BitmapPalette palette, IntPtr buffer, int bufferSize, int stride);
    public BitmapSource Clone();
    public BitmapSource CloneCurrentValue();
    [SecurityCriticalAttribute]
public virtual void CopyPixels(Int32Rect sourceRect, Array pixels, int stride, int offset);
    [SecurityCriticalAttribute]
public virtual void CopyPixels(Array pixels, int stride, int offset);
    [SecurityCriticalAttribute]
public virtual void CopyPixels(Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected void CheckIfSiteOfOrigin();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
public class System.Windows.Media.Imaging.BmpBitmapDecoder : BitmapDecoder {
    [SecurityCriticalAttribute]
public BmpBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
public BmpBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
}
public class System.Windows.Media.Imaging.BmpBitmapEncoder : BitmapEncoder {
}
public class System.Windows.Media.Imaging.CachedBitmap : BitmapSource {
    public CachedBitmap(BitmapSource source, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public CachedBitmap Clone();
    public CachedBitmap CloneCurrentValue();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void CloneCore(Freezable sourceFreezable);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
public class System.Windows.Media.Imaging.ColorConvertedBitmap : BitmapSource {
    public static DependencyProperty SourceProperty;
    public static DependencyProperty SourceColorContextProperty;
    public static DependencyProperty DestinationColorContextProperty;
    public static DependencyProperty DestinationFormatProperty;
    public BitmapSource Source { get; public set; }
    public ColorContext SourceColorContext { get; public set; }
    public ColorContext DestinationColorContext { get; public set; }
    public PixelFormat DestinationFormat { get; public set; }
    public ColorConvertedBitmap(BitmapSource source, ColorContext sourceColorContext, ColorContext destinationColorContext, PixelFormat format);
    public BitmapSource get_Source();
    public void set_Source(BitmapSource value);
    public ColorContext get_SourceColorContext();
    public void set_SourceColorContext(ColorContext value);
    public ColorContext get_DestinationColorContext();
    public void set_DestinationColorContext(ColorContext value);
    public PixelFormat get_DestinationFormat();
    public void set_DestinationFormat(PixelFormat value);
    public sealed virtual void BeginInit();
    [SecurityCriticalAttribute]
public sealed virtual void EndInit();
    public ColorConvertedBitmap Clone();
    public ColorConvertedBitmap CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
public class System.Windows.Media.Imaging.CroppedBitmap : BitmapSource {
    public static DependencyProperty SourceProperty;
    public static DependencyProperty SourceRectProperty;
    public BitmapSource Source { get; public set; }
    public Int32Rect SourceRect { get; public set; }
    public CroppedBitmap(BitmapSource source, Int32Rect sourceRect);
    public BitmapSource get_Source();
    public void set_Source(BitmapSource value);
    public Int32Rect get_SourceRect();
    public void set_SourceRect(Int32Rect value);
    public sealed virtual void BeginInit();
    [SecurityCriticalAttribute]
public sealed virtual void EndInit();
    public CroppedBitmap Clone();
    public CroppedBitmap CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
public class System.Windows.Media.Imaging.DownloadProgressEventArgs : EventArgs {
    public int Progress { get; }
    internal DownloadProgressEventArgs(int percentComplete);
    public int get_Progress();
}
public class System.Windows.Media.Imaging.FormatConvertedBitmap : BitmapSource {
    public static DependencyProperty SourceProperty;
    public static DependencyProperty DestinationFormatProperty;
    public static DependencyProperty DestinationPaletteProperty;
    public static DependencyProperty AlphaThresholdProperty;
    public BitmapSource Source { get; public set; }
    public PixelFormat DestinationFormat { get; public set; }
    public BitmapPalette DestinationPalette { get; public set; }
    public double AlphaThreshold { get; public set; }
    public FormatConvertedBitmap(BitmapSource source, PixelFormat destinationFormat, BitmapPalette destinationPalette, double alphaThreshold);
    public BitmapSource get_Source();
    public void set_Source(BitmapSource value);
    public PixelFormat get_DestinationFormat();
    public void set_DestinationFormat(PixelFormat value);
    public BitmapPalette get_DestinationPalette();
    public void set_DestinationPalette(BitmapPalette value);
    public double get_AlphaThreshold();
    public void set_AlphaThreshold(double value);
    public sealed virtual void BeginInit();
    [SecurityCriticalAttribute]
public sealed virtual void EndInit();
    public FormatConvertedBitmap Clone();
    public FormatConvertedBitmap CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
public class System.Windows.Media.Imaging.GifBitmapDecoder : BitmapDecoder {
    [SecurityCriticalAttribute]
public GifBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
public GifBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
}
public class System.Windows.Media.Imaging.GifBitmapEncoder : BitmapEncoder {
}
public class System.Windows.Media.Imaging.IconBitmapDecoder : BitmapDecoder {
    [SecurityCriticalAttribute]
public IconBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
public IconBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
}
public class System.Windows.Media.Imaging.InPlaceBitmapMetadataWriter : BitmapMetadata {
    [SecurityCriticalAttribute]
public bool TrySave();
    public InPlaceBitmapMetadataWriter Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
public class System.Windows.Media.Imaging.JpegBitmapDecoder : BitmapDecoder {
    [SecurityCriticalAttribute]
public JpegBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
public JpegBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
}
public class System.Windows.Media.Imaging.JpegBitmapEncoder : BitmapEncoder {
    public int QualityLevel { get; public set; }
    public Rotation Rotation { get; public set; }
    public bool FlipHorizontal { get; public set; }
    public bool FlipVertical { get; public set; }
    public int get_QualityLevel();
    public void set_QualityLevel(int value);
    public Rotation get_Rotation();
    public void set_Rotation(Rotation value);
    public bool get_FlipHorizontal();
    public void set_FlipHorizontal(bool value);
    public bool get_FlipVertical();
    public void set_FlipVertical(bool value);
}
public class System.Windows.Media.Imaging.LateBoundBitmapDecoder : BitmapDecoder {
    public BitmapPalette Palette { get; }
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; }
    public BitmapSource Thumbnail { get; }
    public BitmapCodecInfo CodecInfo { get; }
    public ReadOnlyCollection`1<BitmapFrame> Frames { get; }
    public BitmapSource Preview { get; }
    public BitmapDecoder Decoder { get; }
    public bool IsDownloading { get; }
    [SecurityCriticalAttribute]
internal LateBoundBitmapDecoder(Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, RequestCachePolicy requestCachePolicy);
    [SecurityCriticalAttribute]
public virtual BitmapPalette get_Palette();
    [SecurityCriticalAttribute]
public virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    [SecurityCriticalAttribute]
public virtual BitmapSource get_Thumbnail();
    [SecurityCriticalAttribute]
public virtual BitmapCodecInfo get_CodecInfo();
    public virtual ReadOnlyCollection`1<BitmapFrame> get_Frames();
    [SecurityCriticalAttribute]
public virtual BitmapSource get_Preview();
    public BitmapDecoder get_Decoder();
    public virtual bool get_IsDownloading();
}
public class System.Windows.Media.Imaging.PngBitmapDecoder : BitmapDecoder {
    [SecurityCriticalAttribute]
public PngBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
public PngBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
}
public class System.Windows.Media.Imaging.PngBitmapEncoder : BitmapEncoder {
    public PngInterlaceOption Interlace { get; public set; }
    public PngInterlaceOption get_Interlace();
    public void set_Interlace(PngInterlaceOption value);
}
public enum System.Windows.Media.Imaging.PngInterlaceOption : Enum {
    public int value__;
    public static PngInterlaceOption Default;
    public static PngInterlaceOption On;
    public static PngInterlaceOption Off;
}
public class System.Windows.Media.Imaging.RenderTargetBitmap : BitmapSource {
    [SecurityCriticalAttribute]
public RenderTargetBitmap(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public void Render(Visual visual);
    [SecurityCriticalAttribute]
public void Clear();
}
public enum System.Windows.Media.Imaging.Rotation : Enum {
    public int value__;
    public static Rotation Rotate0;
    public static Rotation Rotate90;
    public static Rotation Rotate180;
    public static Rotation Rotate270;
}
public class System.Windows.Media.Imaging.TiffBitmapDecoder : BitmapDecoder {
    [SecurityCriticalAttribute]
public TiffBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
public TiffBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
}
public class System.Windows.Media.Imaging.TiffBitmapEncoder : BitmapEncoder {
    public TiffCompressOption Compression { get; public set; }
    public TiffCompressOption get_Compression();
    public void set_Compression(TiffCompressOption value);
}
public enum System.Windows.Media.Imaging.TiffCompressOption : Enum {
    public int value__;
    public static TiffCompressOption Default;
    public static TiffCompressOption None;
    public static TiffCompressOption Ccitt3;
    public static TiffCompressOption Ccitt4;
    public static TiffCompressOption Lzw;
    public static TiffCompressOption Rle;
    public static TiffCompressOption Zip;
}
public class System.Windows.Media.Imaging.TransformedBitmap : BitmapSource {
    public static DependencyProperty SourceProperty;
    public static DependencyProperty TransformProperty;
    public BitmapSource Source { get; public set; }
    public Transform Transform { get; public set; }
    public TransformedBitmap(BitmapSource source, Transform newTransform);
    public BitmapSource get_Source();
    public void set_Source(BitmapSource value);
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public sealed virtual void BeginInit();
    [SecurityCriticalAttribute]
public sealed virtual void EndInit();
    public TransformedBitmap Clone();
    public TransformedBitmap CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
public class System.Windows.Media.Imaging.WmpBitmapDecoder : BitmapDecoder {
    [SecurityCriticalAttribute]
public WmpBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
public WmpBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
}
public class System.Windows.Media.Imaging.WmpBitmapEncoder : BitmapEncoder {
    public float ImageQualityLevel { get; public set; }
    public bool Lossless { get; public set; }
    public Rotation Rotation { get; public set; }
    public bool FlipHorizontal { get; public set; }
    public bool FlipVertical { get; public set; }
    public bool UseCodecOptions { get; public set; }
    public byte QualityLevel { get; public set; }
    public byte SubsamplingLevel { get; public set; }
    public byte OverlapLevel { get; public set; }
    public short HorizontalTileSlices { get; public set; }
    public short VerticalTileSlices { get; public set; }
    public bool FrequencyOrder { get; public set; }
    public bool InterleavedAlpha { get; public set; }
    public byte AlphaQualityLevel { get; public set; }
    public bool CompressedDomainTranscode { get; public set; }
    public byte ImageDataDiscardLevel { get; public set; }
    public byte AlphaDataDiscardLevel { get; public set; }
    public bool IgnoreOverlap { get; public set; }
    public float get_ImageQualityLevel();
    public void set_ImageQualityLevel(float value);
    public bool get_Lossless();
    public void set_Lossless(bool value);
    public Rotation get_Rotation();
    public void set_Rotation(Rotation value);
    public bool get_FlipHorizontal();
    public void set_FlipHorizontal(bool value);
    public bool get_FlipVertical();
    public void set_FlipVertical(bool value);
    public bool get_UseCodecOptions();
    public void set_UseCodecOptions(bool value);
    public byte get_QualityLevel();
    public void set_QualityLevel(byte value);
    public byte get_SubsamplingLevel();
    public void set_SubsamplingLevel(byte value);
    public byte get_OverlapLevel();
    public void set_OverlapLevel(byte value);
    public short get_HorizontalTileSlices();
    public void set_HorizontalTileSlices(short value);
    public short get_VerticalTileSlices();
    public void set_VerticalTileSlices(short value);
    public bool get_FrequencyOrder();
    public void set_FrequencyOrder(bool value);
    public bool get_InterleavedAlpha();
    public void set_InterleavedAlpha(bool value);
    public byte get_AlphaQualityLevel();
    public void set_AlphaQualityLevel(byte value);
    public bool get_CompressedDomainTranscode();
    public void set_CompressedDomainTranscode(bool value);
    public byte get_ImageDataDiscardLevel();
    public void set_ImageDataDiscardLevel(byte value);
    public byte get_AlphaDataDiscardLevel();
    public void set_AlphaDataDiscardLevel(byte value);
    public bool get_IgnoreOverlap();
    public void set_IgnoreOverlap(bool value);
}
public class System.Windows.Media.Imaging.WriteableBitmap : BitmapSource {
    public IntPtr BackBuffer { get; private set; }
    public int BackBufferStride { get; }
    [SecurityCriticalAttribute]
public WriteableBitmap(BitmapSource source);
    [SecurityCriticalAttribute]
public WriteableBitmap(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat, BitmapPalette palette);
    [SecurityCriticalAttribute]
public IntPtr get_BackBuffer();
    [SecurityCriticalAttribute]
private void set_BackBuffer(IntPtr value);
    public int get_BackBufferStride();
    [SecurityCriticalAttribute]
public void AddDirtyRect(Int32Rect dirtyRect);
    public WriteableBitmap Clone();
    public WriteableBitmap CloneCurrentValue();
    public void Lock();
    [SecurityCriticalAttribute]
public bool TryLock(Duration timeout);
    [SecurityCriticalAttribute]
public void Unlock();
    [SecurityCriticalAttribute]
public void WritePixels(Int32Rect sourceRect, IntPtr sourceBuffer, int sourceBufferSize, int sourceBufferStride, int destinationX, int destinationY);
    [SecurityCriticalAttribute]
public void WritePixels(Int32Rect sourceRect, Array sourceBuffer, int sourceBufferStride, int destinationX, int destinationY);
    [SecurityCriticalAttribute]
public void WritePixels(Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);
    [SecurityCriticalAttribute]
public void WritePixels(Int32Rect sourceRect, Array pixels, int stride, int offset);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void CloneCore(Freezable sourceFreezable);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual bool FreezeCore(bool isChecking);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
[DefaultMemberAttribute("Item")]
[ValueSerializerAttribute("System.Windows.Media.Converters.Int32CollectionValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.Int32CollectionConverter")]
public class System.Windows.Media.Int32Collection : Freezable {
    public int Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Int32>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Int32Collection(int capacity);
    public Int32Collection(IEnumerable`1<int> collection);
    public sealed virtual int get_Item(int index);
    public sealed virtual void set_Item(int index, int value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Int32>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public Int32Collection Clone();
    public Int32Collection CloneCurrentValue();
    public sealed virtual void Add(int value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(int value);
    public sealed virtual int IndexOf(int value);
    public sealed virtual void Insert(int index, int value);
    public sealed virtual bool Remove(int value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(Int32[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<int> System.Collections.Generic.IEnumerable<System.Int32>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public static Int32Collection Parse(string source);
}
public class System.Windows.Media.Int32CollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.Media.IntersectionDetail : Enum {
    public int value__;
    public static IntersectionDetail NotCalculated;
    public static IntersectionDetail Empty;
    public static IntersectionDetail FullyInside;
    public static IntersectionDetail FullyContains;
    public static IntersectionDetail Intersects;
}
public class System.Windows.Media.InvalidWmpVersionException : SystemException {
    public InvalidWmpVersionException(string message);
    protected InvalidWmpVersionException(SerializationInfo info, StreamingContext context);
    public InvalidWmpVersionException(string message, Exception innerException);
}
internal enum System.Windows.Media.KnownColor : Enum {
    public UInt32 value__;
    public static KnownColor UnknownColor;
    public static KnownColor Transparent;
    public static KnownColor Black;
    public static KnownColor Navy;
    public static KnownColor DarkBlue;
    public static KnownColor MediumBlue;
    public static KnownColor Blue;
    public static KnownColor DarkGreen;
    public static KnownColor Green;
    public static KnownColor Teal;
    public static KnownColor DarkCyan;
    public static KnownColor DeepSkyBlue;
    public static KnownColor DarkTurquoise;
    public static KnownColor MediumSpringGreen;
    public static KnownColor Lime;
    public static KnownColor SpringGreen;
    public static KnownColor Aqua;
    public static KnownColor Cyan;
    public static KnownColor MidnightBlue;
    public static KnownColor DodgerBlue;
    public static KnownColor LightSeaGreen;
    public static KnownColor ForestGreen;
    public static KnownColor SeaGreen;
    public static KnownColor DarkSlateGray;
    public static KnownColor LimeGreen;
    public static KnownColor MediumSeaGreen;
    public static KnownColor Turquoise;
    public static KnownColor RoyalBlue;
    public static KnownColor SteelBlue;
    public static KnownColor DarkSlateBlue;
    public static KnownColor MediumTurquoise;
    public static KnownColor Indigo;
    public static KnownColor DarkOliveGreen;
    public static KnownColor CadetBlue;
    public static KnownColor CornflowerBlue;
    public static KnownColor MediumAquamarine;
    public static KnownColor DimGray;
    public static KnownColor SlateBlue;
    public static KnownColor OliveDrab;
    public static KnownColor SlateGray;
    public static KnownColor LightSlateGray;
    public static KnownColor MediumSlateBlue;
    public static KnownColor LawnGreen;
    public static KnownColor Chartreuse;
    public static KnownColor Aquamarine;
    public static KnownColor Maroon;
    public static KnownColor Purple;
    public static KnownColor Olive;
    public static KnownColor Gray;
    public static KnownColor SkyBlue;
    public static KnownColor LightSkyBlue;
    public static KnownColor BlueViolet;
    public static KnownColor DarkRed;
    public static KnownColor DarkMagenta;
    public static KnownColor SaddleBrown;
    public static KnownColor DarkSeaGreen;
    public static KnownColor LightGreen;
    public static KnownColor MediumPurple;
    public static KnownColor DarkViolet;
    public static KnownColor PaleGreen;
    public static KnownColor DarkOrchid;
    public static KnownColor YellowGreen;
    public static KnownColor Sienna;
    public static KnownColor Brown;
    public static KnownColor DarkGray;
    public static KnownColor LightBlue;
    public static KnownColor GreenYellow;
    public static KnownColor PaleTurquoise;
    public static KnownColor LightSteelBlue;
    public static KnownColor PowderBlue;
    public static KnownColor Firebrick;
    public static KnownColor DarkGoldenrod;
    public static KnownColor MediumOrchid;
    public static KnownColor RosyBrown;
    public static KnownColor DarkKhaki;
    public static KnownColor Silver;
    public static KnownColor MediumVioletRed;
    public static KnownColor IndianRed;
    public static KnownColor Peru;
    public static KnownColor Chocolate;
    public static KnownColor Tan;
    public static KnownColor LightGray;
    public static KnownColor Thistle;
    public static KnownColor Orchid;
    public static KnownColor Goldenrod;
    public static KnownColor PaleVioletRed;
    public static KnownColor Crimson;
    public static KnownColor Gainsboro;
    public static KnownColor Plum;
    public static KnownColor BurlyWood;
    public static KnownColor LightCyan;
    public static KnownColor Lavender;
    public static KnownColor DarkSalmon;
    public static KnownColor Violet;
    public static KnownColor PaleGoldenrod;
    public static KnownColor LightCoral;
    public static KnownColor Khaki;
    public static KnownColor AliceBlue;
    public static KnownColor Honeydew;
    public static KnownColor Azure;
    public static KnownColor SandyBrown;
    public static KnownColor Wheat;
    public static KnownColor Beige;
    public static KnownColor WhiteSmoke;
    public static KnownColor MintCream;
    public static KnownColor GhostWhite;
    public static KnownColor Salmon;
    public static KnownColor AntiqueWhite;
    public static KnownColor Linen;
    public static KnownColor LightGoldenrodYellow;
    public static KnownColor OldLace;
    public static KnownColor Red;
    public static KnownColor Fuchsia;
    public static KnownColor Magenta;
    public static KnownColor DeepPink;
    public static KnownColor OrangeRed;
    public static KnownColor Tomato;
    public static KnownColor HotPink;
    public static KnownColor Coral;
    public static KnownColor DarkOrange;
    public static KnownColor LightSalmon;
    public static KnownColor Orange;
    public static KnownColor LightPink;
    public static KnownColor Pink;
    public static KnownColor Gold;
    public static KnownColor PeachPuff;
    public static KnownColor NavajoWhite;
    public static KnownColor Moccasin;
    public static KnownColor Bisque;
    public static KnownColor MistyRose;
    public static KnownColor BlanchedAlmond;
    public static KnownColor PapayaWhip;
    public static KnownColor LavenderBlush;
    public static KnownColor SeaShell;
    public static KnownColor Cornsilk;
    public static KnownColor LemonChiffon;
    public static KnownColor FloralWhite;
    public static KnownColor Snow;
    public static KnownColor Yellow;
    public static KnownColor LightYellow;
    public static KnownColor Ivory;
    public static KnownColor White;
}
internal static class System.Windows.Media.KnownColors : object {
    private static Dictionary`2<UInt32, SolidColorBrush> SolidColorBrushCache;
    private static Dictionary`2<string, KnownColor> KnownArgbColors;
    private static KnownColors();
    public static SolidColorBrush ColorStringToKnownBrush(string s);
    public static bool IsKnownSolidColorBrush(SolidColorBrush scp);
    public static SolidColorBrush SolidColorBrushFromUint(UInt32 argb);
    internal static string MatchColor(string colorString, Boolean& isKnownColor, Boolean& isNumericColor, Boolean& isContextColor, Boolean& isScRgbColor);
    internal static KnownColor ColorStringToKnownColor(string colorString);
    internal static KnownColor ArgbStringToKnownColor(string argbString);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.LanguageSpecificStringDictionary : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public string Item { get; public set; }
    [CLSCompliantAttribute("False")]
public ICollection`1<XmlLanguage> Keys { get; }
    [CLSCompliantAttribute("False")]
public ICollection`1<string> Values { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    internal LanguageSpecificStringDictionary(IDictionary`2<XmlLanguage, string> innerDictionary);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual string get_Item(XmlLanguage key);
    public sealed virtual void set_Item(XmlLanguage key, string value);
    public sealed virtual ICollection`1<XmlLanguage> get_Keys();
    public sealed virtual ICollection`1<string> get_Values();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    [CLSCompliantAttribute("False")]
public sealed virtual IEnumerator`1<KeyValuePair`2<XmlLanguage, string>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual bool TryGetValue(XmlLanguage key, String& value);
    [CLSCompliantAttribute("False")]
public sealed virtual void Add(KeyValuePair`2<XmlLanguage, string> item);
    public sealed virtual void Clear();
    [CLSCompliantAttribute("False")]
public sealed virtual bool Contains(KeyValuePair`2<XmlLanguage, string> item);
    [CLSCompliantAttribute("False")]
public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    [CLSCompliantAttribute("False")]
public sealed virtual bool Remove(KeyValuePair`2<XmlLanguage, string> item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual void Add(XmlLanguage key, string value);
    public sealed virtual bool ContainsKey(XmlLanguage key);
    public sealed virtual bool Remove(XmlLanguage key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
}
public class System.Windows.Media.LinearGradientBrush : GradientBrush {
    public static DependencyProperty StartPointProperty;
    public static DependencyProperty EndPointProperty;
    public Point StartPoint { get; public set; }
    public Point EndPoint { get; public set; }
    public LinearGradientBrush(Color startColor, Color endColor, double angle);
    public LinearGradientBrush(Color startColor, Color endColor, Point startPoint, Point endPoint);
    public LinearGradientBrush(GradientStopCollection gradientStopCollection);
    public LinearGradientBrush(GradientStopCollection gradientStopCollection, double angle);
    public LinearGradientBrush(GradientStopCollection gradientStopCollection, Point startPoint, Point endPoint);
    public Point get_StartPoint();
    public void set_StartPoint(Point value);
    public Point get_EndPoint();
    public void set_EndPoint(Point value);
    public LinearGradientBrush Clone();
    public LinearGradientBrush CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.LineGeometry : Geometry {
    public static DependencyProperty StartPointProperty;
    public static DependencyProperty EndPointProperty;
    public Point StartPoint { get; public set; }
    public Point EndPoint { get; public set; }
    public Rect Bounds { get; }
    public LineGeometry(Point startPoint, Point endPoint);
    public LineGeometry(Point startPoint, Point endPoint, Transform transform);
    public Point get_StartPoint();
    public void set_StartPoint(Point value);
    public Point get_EndPoint();
    public void set_EndPoint(Point value);
    public virtual Rect get_Bounds();
    public LineGeometry Clone();
    public LineGeometry CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
    public virtual double GetArea(double tolerance, ToleranceType type);
}
public class System.Windows.Media.LineSegment : PathSegment {
    public static DependencyProperty PointProperty;
    public Point Point { get; public set; }
    public LineSegment(Point point, bool isStroked);
    public Point get_Point();
    public void set_Point(Point value);
    public LineSegment Clone();
    public LineSegment CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.MatrixTransform : Transform {
    public static DependencyProperty MatrixProperty;
    public Matrix Matrix { get; public set; }
    public Matrix Value { get; }
    public MatrixTransform(double m11, double m12, double m21, double m22, double offsetX, double offsetY);
    public MatrixTransform(Matrix matrix);
    public Matrix get_Matrix();
    public void set_Matrix(Matrix value);
    public virtual Matrix get_Value();
    public MatrixTransform Clone();
    public MatrixTransform CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.Media3D.AffineTransform3D : Transform3D {
    public bool IsAffine { get; }
    public virtual bool get_IsAffine();
    public AffineTransform3D Clone();
    public AffineTransform3D CloneCurrentValue();
}
public class System.Windows.Media.Media3D.AmbientLight : Light {
    public AmbientLight(Color ambientColor);
    public AmbientLight Clone();
    public AmbientLight CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.AxisAngleRotation3D : Rotation3D {
    public static DependencyProperty AxisProperty;
    public static DependencyProperty AngleProperty;
    public Vector3D Axis { get; public set; }
    public double Angle { get; public set; }
    public AxisAngleRotation3D(Vector3D axis, double angle);
    public Vector3D get_Axis();
    public void set_Axis(Vector3D value);
    public double get_Angle();
    public void set_Angle(double value);
    public AxisAngleRotation3D Clone();
    public AxisAngleRotation3D CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.Media3D.Camera : Animatable {
    public static DependencyProperty TransformProperty;
    public Transform3D Transform { get; public set; }
    public Transform3D get_Transform();
    public void set_Transform(Transform3D value);
    public Camera Clone();
    public Camera CloneCurrentValue();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.ContainerUIElement3D : UIElement3D {
    protected int Visual3DChildrenCount { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public Visual3DCollection Children { get; }
    protected virtual int get_Visual3DChildrenCount();
    public Visual3DCollection get_Children();
    protected virtual Visual3D GetVisual3DChild(int index);
    protected virtual AutomationPeer OnCreateAutomationPeer();
}
public class System.Windows.Media.Media3D.Converters.Matrix3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Point3DCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Point3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Point4DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.QuaternionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Rect3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Size3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Vector3DCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Vector3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.DiffuseMaterial : Material {
    public static DependencyProperty ColorProperty;
    public static DependencyProperty AmbientColorProperty;
    public static DependencyProperty BrushProperty;
    public Color Color { get; public set; }
    public Color AmbientColor { get; public set; }
    public Brush Brush { get; public set; }
    public DiffuseMaterial(Brush brush);
    public Color get_Color();
    public void set_Color(Color value);
    public Color get_AmbientColor();
    public void set_AmbientColor(Color value);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    public DiffuseMaterial Clone();
    public DiffuseMaterial CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.DirectionalLight : Light {
    public static DependencyProperty DirectionProperty;
    public Vector3D Direction { get; public set; }
    public DirectionalLight(Color diffuseColor, Vector3D direction);
    public Vector3D get_Direction();
    public void set_Direction(Vector3D value);
    public DirectionalLight Clone();
    public DirectionalLight CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.EmissiveMaterial : Material {
    public static DependencyProperty ColorProperty;
    public static DependencyProperty BrushProperty;
    public Color Color { get; public set; }
    public Brush Brush { get; public set; }
    public EmissiveMaterial(Brush brush);
    public Color get_Color();
    public void set_Color(Color value);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    public EmissiveMaterial Clone();
    public EmissiveMaterial CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.GeneralTransform2DTo3D : Freezable {
    public bool TryTransform(Point inPoint, Point3D& result);
    public Point3D Transform(Point point);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.GeneralTransform3D : Animatable {
    public GeneralTransform3D Inverse { get; }
    public abstract virtual GeneralTransform3D get_Inverse();
    public abstract virtual bool TryTransform(Point3D inPoint, Point3D& result);
    public Point3D Transform(Point3D point);
    public abstract virtual Rect3D TransformBounds(Rect3D rect);
    public GeneralTransform3D Clone();
    public GeneralTransform3D CloneCurrentValue();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.GeneralTransform3DCollection : Animatable {
    public GeneralTransform3D Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.GeneralTransform3D>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public GeneralTransform3DCollection(int capacity);
    public GeneralTransform3DCollection(IEnumerable`1<GeneralTransform3D> collection);
    public sealed virtual GeneralTransform3D get_Item(int index);
    public sealed virtual void set_Item(int index, GeneralTransform3D value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.GeneralTransform3D>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public GeneralTransform3DCollection Clone();
    public GeneralTransform3DCollection CloneCurrentValue();
    public sealed virtual void Add(GeneralTransform3D value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(GeneralTransform3D value);
    public sealed virtual int IndexOf(GeneralTransform3D value);
    public sealed virtual void Insert(int index, GeneralTransform3D value);
    public sealed virtual bool Remove(GeneralTransform3D value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(GeneralTransform3D[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<GeneralTransform3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.GeneralTransform3D>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
[LocalizabilityAttribute("0")]
public class System.Windows.Media.Media3D.GeneralTransform3DGroup : GeneralTransform3D {
    public static DependencyProperty ChildrenProperty;
    public GeneralTransform3D Inverse { get; }
    public GeneralTransform3DCollection Children { get; public set; }
    public virtual GeneralTransform3D get_Inverse();
    public GeneralTransform3DCollection get_Children();
    public void set_Children(GeneralTransform3DCollection value);
    public virtual bool TryTransform(Point3D inPoint, Point3D& result);
    public virtual Rect3D TransformBounds(Rect3D rect);
    public GeneralTransform3DGroup Clone();
    public GeneralTransform3DGroup CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.GeneralTransform3DTo2D : Freezable {
    public bool TryTransform(Point3D inPoint, Point& result);
    public Point Transform(Point3D point);
    public Rect TransformBounds(Rect3D rect3D);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.Geometry3D : Animatable {
    public Rect3D Bounds { get; }
    public abstract virtual Rect3D get_Bounds();
    public Geometry3D Clone();
    public Geometry3D CloneCurrentValue();
}
public class System.Windows.Media.Media3D.GeometryModel3D : Model3D {
    public static DependencyProperty GeometryProperty;
    public static DependencyProperty MaterialProperty;
    public static DependencyProperty BackMaterialProperty;
    public Geometry3D Geometry { get; public set; }
    public Material Material { get; public set; }
    public Material BackMaterial { get; public set; }
    public GeometryModel3D(Geometry3D geometry, Material material);
    public Geometry3D get_Geometry();
    public void set_Geometry(Geometry3D value);
    public Material get_Material();
    public void set_Material(Material value);
    public Material get_BackMaterial();
    public void set_BackMaterial(Material value);
    public GeometryModel3D Clone();
    public GeometryModel3D CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.Media3D.HitTestParameters3D : object {
}
public abstract class System.Windows.Media.Media3D.Light : Model3D {
    public static DependencyProperty ColorProperty;
    public Color Color { get; public set; }
    public Color get_Color();
    public void set_Color(Color value);
    public Light Clone();
    public Light CloneCurrentValue();
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.Material : Animatable {
    public Material Clone();
    public Material CloneCurrentValue();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.MaterialCollection : Animatable {
    public Material Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Material>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public MaterialCollection(int capacity);
    public MaterialCollection(IEnumerable`1<Material> collection);
    public sealed virtual Material get_Item(int index);
    public sealed virtual void set_Item(int index, Material value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Material>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public MaterialCollection Clone();
    public MaterialCollection CloneCurrentValue();
    public sealed virtual void Add(Material value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Material value);
    public sealed virtual int IndexOf(Material value);
    public sealed virtual void Insert(int index, Material value);
    public sealed virtual bool Remove(Material value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(Material[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Material> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Material>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.MaterialGroup : Material {
    public static DependencyProperty ChildrenProperty;
    public MaterialCollection Children { get; public set; }
    public MaterialCollection get_Children();
    public void set_Children(MaterialCollection value);
    public MaterialGroup Clone();
    public MaterialGroup CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[TypeConverterAttribute("System.Windows.Media.Media3D.Matrix3DConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Matrix3DValueSerializer")]
public class System.Windows.Media.Media3D.Matrix3D : ValueType {
    private static int c_identityHashCode;
    private double _m11;
    private double _m12;
    private double _m13;
    private double _m14;
    private double _m21;
    private double _m22;
    private double _m23;
    private double _m24;
    private double _m31;
    private double _m32;
    private double _m33;
    private double _m34;
    private double _offsetX;
    private double _offsetY;
    private double _offsetZ;
    private double _m44;
    private bool _isNotKnownToBeIdentity;
    public static Matrix3D Identity { get; }
    public bool IsIdentity { get; }
    public bool IsAffine { get; }
    public double Determinant { get; }
    public bool HasInverse { get; }
    public double M11 { get; public set; }
    public double M12 { get; public set; }
    public double M13 { get; public set; }
    public double M14 { get; public set; }
    public double M21 { get; public set; }
    public double M22 { get; public set; }
    public double M23 { get; public set; }
    public double M24 { get; public set; }
    public double M31 { get; public set; }
    public double M32 { get; public set; }
    public double M33 { get; public set; }
    public double M34 { get; public set; }
    public double OffsetX { get; public set; }
    public double OffsetY { get; public set; }
    public double OffsetZ { get; public set; }
    public double M44 { get; public set; }
    public Matrix3D(double m11, double m12, double m13, double m14, double m21, double m22, double m23, double m24, double m31, double m32, double m33, double m34, double offsetX, double offsetY, double offsetZ, double m44);
    public static Matrix3D get_Identity();
    public bool get_IsIdentity();
    public bool get_IsAffine();
    public double get_Determinant();
    public bool get_HasInverse();
    public double get_M11();
    public void set_M11(double value);
    public double get_M12();
    public void set_M12(double value);
    public double get_M13();
    public void set_M13(double value);
    public double get_M14();
    public void set_M14(double value);
    public double get_M21();
    public void set_M21(double value);
    public double get_M22();
    public void set_M22(double value);
    public double get_M23();
    public void set_M23(double value);
    public double get_M24();
    public void set_M24(double value);
    public double get_M31();
    public void set_M31(double value);
    public double get_M32();
    public void set_M32(double value);
    public double get_M33();
    public void set_M33(double value);
    public double get_M34();
    public void set_M34(double value);
    public double get_OffsetX();
    public void set_OffsetX(double value);
    public double get_OffsetY();
    public void set_OffsetY(double value);
    public double get_OffsetZ();
    public void set_OffsetZ(double value);
    public double get_M44();
    public void set_M44(double value);
    public static Matrix3D op_Multiply(Matrix3D matrix1, Matrix3D matrix2);
    public static bool op_Equality(Matrix3D matrix1, Matrix3D matrix2);
    public static bool op_Inequality(Matrix3D matrix1, Matrix3D matrix2);
    public void SetIdentity();
    public void Prepend(Matrix3D matrix);
    public void Append(Matrix3D matrix);
    public void Rotate(Quaternion quaternion);
    public void RotatePrepend(Quaternion quaternion);
    public void RotateAt(Quaternion quaternion, Point3D center);
    public void RotateAtPrepend(Quaternion quaternion, Point3D center);
    public void Scale(Vector3D scale);
    public void ScalePrepend(Vector3D scale);
    public void ScaleAt(Vector3D scale, Point3D center);
    public void ScaleAtPrepend(Vector3D scale, Point3D center);
    public void Translate(Vector3D offset);
    public void TranslatePrepend(Vector3D offset);
    public static Matrix3D Multiply(Matrix3D matrix1, Matrix3D matrix2);
    public Point3D Transform(Point3D point);
    public void Transform(Point3D[] points);
    public Point4D Transform(Point4D point);
    public void Transform(Point4D[] points);
    public Vector3D Transform(Vector3D vector);
    public void Transform(Vector3D[] vectors);
    public void Invert();
    public static bool Equals(Matrix3D matrix1, Matrix3D matrix2);
    public virtual bool Equals(object o);
    public bool Equals(Matrix3D value);
    public virtual int GetHashCode();
    public static Matrix3D Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.Media3D.Matrix3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.MatrixCamera : Camera {
    public static DependencyProperty ViewMatrixProperty;
    public static DependencyProperty ProjectionMatrixProperty;
    public Matrix3D ViewMatrix { get; public set; }
    public Matrix3D ProjectionMatrix { get; public set; }
    public MatrixCamera(Matrix3D viewMatrix, Matrix3D projectionMatrix);
    public Matrix3D get_ViewMatrix();
    public void set_ViewMatrix(Matrix3D value);
    public Matrix3D get_ProjectionMatrix();
    public void set_ProjectionMatrix(Matrix3D value);
    public MatrixCamera Clone();
    public MatrixCamera CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.MatrixTransform3D : Transform3D {
    public static DependencyProperty MatrixProperty;
    public Matrix3D Value { get; }
    public bool IsAffine { get; }
    public Matrix3D Matrix { get; public set; }
    public MatrixTransform3D(Matrix3D matrix);
    public virtual Matrix3D get_Value();
    public virtual bool get_IsAffine();
    public Matrix3D get_Matrix();
    public void set_Matrix(Matrix3D value);
    public MatrixTransform3D Clone();
    public MatrixTransform3D CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.MeshGeometry3D : Geometry3D {
    public static DependencyProperty PositionsProperty;
    public static DependencyProperty NormalsProperty;
    public static DependencyProperty TextureCoordinatesProperty;
    public static DependencyProperty TriangleIndicesProperty;
    public Rect3D Bounds { get; }
    public Point3DCollection Positions { get; public set; }
    public Vector3DCollection Normals { get; public set; }
    public PointCollection TextureCoordinates { get; public set; }
    public Int32Collection TriangleIndices { get; public set; }
    public virtual Rect3D get_Bounds();
    public Point3DCollection get_Positions();
    public void set_Positions(Point3DCollection value);
    public Vector3DCollection get_Normals();
    public void set_Normals(Vector3DCollection value);
    public PointCollection get_TextureCoordinates();
    public void set_TextureCoordinates(PointCollection value);
    public Int32Collection get_TriangleIndices();
    public void set_TriangleIndices(Int32Collection value);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    public MeshGeometry3D Clone();
    public MeshGeometry3D CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.Model3D : Animatable {
    public static DependencyProperty TransformProperty;
    public Rect3D Bounds { get; }
    public Transform3D Transform { get; public set; }
    public Rect3D get_Bounds();
    public Transform3D get_Transform();
    public void set_Transform(Transform3D value);
    public Model3D Clone();
    public Model3D CloneCurrentValue();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.Model3DCollection : Animatable {
    public Model3D Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Model3D>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Model3DCollection(int capacity);
    public Model3DCollection(IEnumerable`1<Model3D> collection);
    public sealed virtual Model3D get_Item(int index);
    public sealed virtual void set_Item(int index, Model3D value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Model3D>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public Model3DCollection Clone();
    public Model3DCollection CloneCurrentValue();
    public sealed virtual void Add(Model3D value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Model3D value);
    public sealed virtual int IndexOf(Model3D value);
    public sealed virtual void Insert(int index, Model3D value);
    public sealed virtual bool Remove(Model3D value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(Model3D[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Model3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Model3D>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.Model3DGroup : Model3D {
    public static DependencyProperty ChildrenProperty;
    public Model3DCollection Children { get; public set; }
    public Model3DCollection get_Children();
    public void set_Children(Model3DCollection value);
    public Model3DGroup Clone();
    public Model3DGroup CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[ContentPropertyAttribute("Model")]
public class System.Windows.Media.Media3D.ModelUIElement3D : UIElement3D {
    public static DependencyProperty ModelProperty;
    public Model3D Model { get; public set; }
    public Model3D get_Model();
    public void set_Model(Model3D value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.ModelVisual3D : Visual3D {
    public static DependencyProperty ContentProperty;
    public static DependencyProperty TransformProperty;
    protected int Visual3DChildrenCount { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public Visual3DCollection Children { get; }
    public Model3D Content { get; public set; }
    public Transform3D Transform { get; public set; }
    protected sealed virtual int get_Visual3DChildrenCount();
    public Visual3DCollection get_Children();
    public Model3D get_Content();
    public void set_Content(Model3D value);
    public Transform3D get_Transform();
    public void set_Transform(Transform3D value);
    protected sealed virtual Visual3D GetVisual3DChild(int index);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
}
public class System.Windows.Media.Media3D.OrthographicCamera : ProjectionCamera {
    public static DependencyProperty WidthProperty;
    public double Width { get; public set; }
    public OrthographicCamera(Point3D position, Vector3D lookDirection, Vector3D upDirection, double width);
    public double get_Width();
    public void set_Width(double value);
    public OrthographicCamera Clone();
    public OrthographicCamera CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.PerspectiveCamera : ProjectionCamera {
    public static DependencyProperty FieldOfViewProperty;
    public double FieldOfView { get; public set; }
    public PerspectiveCamera(Point3D position, Vector3D lookDirection, Vector3D upDirection, double fieldOfView);
    public double get_FieldOfView();
    public void set_FieldOfView(double value);
    public PerspectiveCamera Clone();
    public PerspectiveCamera CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[TypeConverterAttribute("System.Windows.Media.Media3D.Point3DConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Point3DValueSerializer")]
public class System.Windows.Media.Media3D.Point3D : ValueType {
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public Point3D(double x, double y, double z);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public static Vector3D op_Explicit(Point3D point);
    public static Point4D op_Explicit(Point3D point);
    public static Point3D op_Addition(Point3D point, Vector3D vector);
    public static Point3D op_Subtraction(Point3D point, Vector3D vector);
    public static Vector3D op_Subtraction(Point3D point1, Point3D point2);
    public static Point3D op_Multiply(Point3D point, Matrix3D matrix);
    public static bool op_Equality(Point3D point1, Point3D point2);
    public static bool op_Inequality(Point3D point1, Point3D point2);
    public void Offset(double offsetX, double offsetY, double offsetZ);
    public static Point3D Add(Point3D point, Vector3D vector);
    public static Point3D Subtract(Point3D point, Vector3D vector);
    public static Vector3D Subtract(Point3D point1, Point3D point2);
    public static Point3D Multiply(Point3D point, Matrix3D matrix);
    public static bool Equals(Point3D point1, Point3D point2);
    public virtual bool Equals(object o);
    public bool Equals(Point3D value);
    public virtual int GetHashCode();
    public static Point3D Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.Media.Media3D.Point3DCollectionConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Point3DCollectionValueSerializer")]
public class System.Windows.Media.Media3D.Point3DCollection : Freezable {
    public Point3D Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Point3D>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Point3DCollection(int capacity);
    public Point3DCollection(IEnumerable`1<Point3D> collection);
    public sealed virtual Point3D get_Item(int index);
    public sealed virtual void set_Item(int index, Point3D value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Point3D>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public Point3DCollection Clone();
    public Point3DCollection CloneCurrentValue();
    public sealed virtual void Add(Point3D value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Point3D value);
    public sealed virtual int IndexOf(Point3D value);
    public sealed virtual void Insert(int index, Point3D value);
    public sealed virtual bool Remove(Point3D value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(Point3D[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Point3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Point3D>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public static Point3DCollection Parse(string source);
}
public class System.Windows.Media.Media3D.Point3DCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.Point3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Point4DValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.Media3D.Point4DConverter")]
public class System.Windows.Media.Media3D.Point4D : ValueType {
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public double W { get; public set; }
    public Point4D(double x, double y, double z, double w);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public double get_W();
    public void set_W(double value);
    public static Point4D op_Addition(Point4D point1, Point4D point2);
    public static Point4D op_Subtraction(Point4D point1, Point4D point2);
    public static Point4D op_Multiply(Point4D point, Matrix3D matrix);
    public static bool op_Equality(Point4D point1, Point4D point2);
    public static bool op_Inequality(Point4D point1, Point4D point2);
    public void Offset(double deltaX, double deltaY, double deltaZ, double deltaW);
    public static Point4D Add(Point4D point1, Point4D point2);
    public static Point4D Subtract(Point4D point1, Point4D point2);
    public static Point4D Multiply(Point4D point, Matrix3D matrix);
    public static bool Equals(Point4D point1, Point4D point2);
    public virtual bool Equals(object o);
    public bool Equals(Point4D value);
    public virtual int GetHashCode();
    public static Point4D Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.Media3D.Point4DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.PointLight : PointLightBase {
    public PointLight(Color diffuseColor, Point3D position);
    public PointLight Clone();
    public PointLight CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.Media3D.PointLightBase : Light {
    public static DependencyProperty PositionProperty;
    public static DependencyProperty RangeProperty;
    public static DependencyProperty ConstantAttenuationProperty;
    public static DependencyProperty LinearAttenuationProperty;
    public static DependencyProperty QuadraticAttenuationProperty;
    public Point3D Position { get; public set; }
    public double Range { get; public set; }
    public double ConstantAttenuation { get; public set; }
    public double LinearAttenuation { get; public set; }
    public double QuadraticAttenuation { get; public set; }
    public Point3D get_Position();
    public void set_Position(Point3D value);
    public double get_Range();
    public void set_Range(double value);
    public double get_ConstantAttenuation();
    public void set_ConstantAttenuation(double value);
    public double get_LinearAttenuation();
    public void set_LinearAttenuation(double value);
    public double get_QuadraticAttenuation();
    public void set_QuadraticAttenuation(double value);
    public PointLightBase Clone();
    public PointLightBase CloneCurrentValue();
}
public abstract class System.Windows.Media.Media3D.ProjectionCamera : Camera {
    public static DependencyProperty NearPlaneDistanceProperty;
    public static DependencyProperty FarPlaneDistanceProperty;
    public static DependencyProperty PositionProperty;
    public static DependencyProperty LookDirectionProperty;
    public static DependencyProperty UpDirectionProperty;
    public double NearPlaneDistance { get; public set; }
    public double FarPlaneDistance { get; public set; }
    public Point3D Position { get; public set; }
    public Vector3D LookDirection { get; public set; }
    public Vector3D UpDirection { get; public set; }
    public double get_NearPlaneDistance();
    public void set_NearPlaneDistance(double value);
    public double get_FarPlaneDistance();
    public void set_FarPlaneDistance(double value);
    public Point3D get_Position();
    public void set_Position(Point3D value);
    public Vector3D get_LookDirection();
    public void set_LookDirection(Vector3D value);
    public Vector3D get_UpDirection();
    public void set_UpDirection(Vector3D value);
    public ProjectionCamera Clone();
    public ProjectionCamera CloneCurrentValue();
}
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.QuaternionValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.Media3D.QuaternionConverter")]
public class System.Windows.Media.Media3D.Quaternion : ValueType {
    private bool _isNotDistinguishedIdentity;
    public static Quaternion Identity { get; }
    public Vector3D Axis { get; }
    public double Angle { get; }
    public bool IsNormalized { get; }
    public bool IsIdentity { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public double W { get; public set; }
    public Quaternion(double x, double y, double z, double w);
    public Quaternion(Vector3D axisOfRotation, double angleInDegrees);
    public static Quaternion get_Identity();
    public Vector3D get_Axis();
    public double get_Angle();
    public bool get_IsNormalized();
    public bool get_IsIdentity();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public double get_W();
    public void set_W(double value);
    public static Quaternion op_Addition(Quaternion left, Quaternion right);
    public static Quaternion op_Subtraction(Quaternion left, Quaternion right);
    public static Quaternion op_Multiply(Quaternion left, Quaternion right);
    public static bool op_Equality(Quaternion quaternion1, Quaternion quaternion2);
    public static bool op_Inequality(Quaternion quaternion1, Quaternion quaternion2);
    public void Conjugate();
    public void Invert();
    public void Normalize();
    public static Quaternion Add(Quaternion left, Quaternion right);
    public static Quaternion Subtract(Quaternion left, Quaternion right);
    public static Quaternion Multiply(Quaternion left, Quaternion right);
    public static Quaternion Slerp(Quaternion from, Quaternion to, double t);
    public static Quaternion Slerp(Quaternion from, Quaternion to, double t, bool useShortestPath);
    public static bool Equals(Quaternion quaternion1, Quaternion quaternion2);
    public virtual bool Equals(object o);
    public bool Equals(Quaternion value);
    public virtual int GetHashCode();
    public static Quaternion Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.Media3D.QuaternionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.QuaternionRotation3D : Rotation3D {
    public static DependencyProperty QuaternionProperty;
    public Quaternion Quaternion { get; public set; }
    public QuaternionRotation3D(Quaternion quaternion);
    public Quaternion get_Quaternion();
    public void set_Quaternion(Quaternion value);
    public QuaternionRotation3D Clone();
    public QuaternionRotation3D CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.RayHitTestParameters : HitTestParameters3D {
    public Point3D Origin { get; }
    public Vector3D Direction { get; }
    public RayHitTestParameters(Point3D origin, Vector3D direction);
    public Point3D get_Origin();
    public Vector3D get_Direction();
}
public abstract class System.Windows.Media.Media3D.RayHitTestResult : HitTestResult {
    public Visual3D VisualHit { get; }
    public Model3D ModelHit { get; }
    public Point3D PointHit { get; }
    public double DistanceToRayOrigin { get; }
    internal RayHitTestResult(Visual3D visualHit, Model3D modelHit);
    public Visual3D get_VisualHit();
    public Model3D get_ModelHit();
    public abstract virtual Point3D get_PointHit();
    public abstract virtual double get_DistanceToRayOrigin();
}
public class System.Windows.Media.Media3D.RayMeshGeometry3DHitTestResult : RayHitTestResult {
    public Point3D PointHit { get; }
    public double DistanceToRayOrigin { get; }
    public int VertexIndex1 { get; }
    public int VertexIndex2 { get; }
    public int VertexIndex3 { get; }
    public double VertexWeight1 { get; }
    public double VertexWeight2 { get; }
    public double VertexWeight3 { get; }
    public MeshGeometry3D MeshHit { get; }
    internal RayMeshGeometry3DHitTestResult(Visual3D visualHit, Model3D modelHit, MeshGeometry3D meshHit, Point3D pointHit, double distanceToRayOrigin, int vertexIndex1, int vertexIndex2, int vertexIndex3, Point barycentricCoordinate);
    public virtual Point3D get_PointHit();
    public virtual double get_DistanceToRayOrigin();
    public int get_VertexIndex1();
    public int get_VertexIndex2();
    public int get_VertexIndex3();
    public double get_VertexWeight1();
    public double get_VertexWeight2();
    public double get_VertexWeight3();
    public MeshGeometry3D get_MeshHit();
}
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Rect3DValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.Media3D.Rect3DConverter")]
public class System.Windows.Media.Media3D.Rect3D : ValueType {
    public static Rect3D Empty { get; }
    public bool IsEmpty { get; }
    public Point3D Location { get; public set; }
    public Size3D Size { get; public set; }
    public double SizeX { get; public set; }
    public double SizeY { get; public set; }
    public double SizeZ { get; public set; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public Rect3D(Point3D location, Size3D size);
    public Rect3D(double x, double y, double z, double sizeX, double sizeY, double sizeZ);
    public static Rect3D get_Empty();
    public bool get_IsEmpty();
    public Point3D get_Location();
    public void set_Location(Point3D value);
    public Size3D get_Size();
    public void set_Size(Size3D value);
    public double get_SizeX();
    public void set_SizeX(double value);
    public double get_SizeY();
    public void set_SizeY(double value);
    public double get_SizeZ();
    public void set_SizeZ(double value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public static bool op_Equality(Rect3D rect1, Rect3D rect2);
    public static bool op_Inequality(Rect3D rect1, Rect3D rect2);
    public bool Contains(Point3D point);
    public bool Contains(double x, double y, double z);
    public bool Contains(Rect3D rect);
    public bool IntersectsWith(Rect3D rect);
    public void Intersect(Rect3D rect);
    public static Rect3D Intersect(Rect3D rect1, Rect3D rect2);
    public void Union(Rect3D rect);
    public static Rect3D Union(Rect3D rect1, Rect3D rect2);
    public void Union(Point3D point);
    public static Rect3D Union(Rect3D rect, Point3D point);
    public void Offset(Vector3D offsetVector);
    public void Offset(double offsetX, double offsetY, double offsetZ);
    public static Rect3D Offset(Rect3D rect, Vector3D offsetVector);
    public static Rect3D Offset(Rect3D rect, double offsetX, double offsetY, double offsetZ);
    public static bool Equals(Rect3D rect1, Rect3D rect2);
    public virtual bool Equals(object o);
    public bool Equals(Rect3D value);
    public virtual int GetHashCode();
    public static Rect3D Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.Media3D.Rect3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.RotateTransform3D : AffineTransform3D {
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    public static DependencyProperty CenterZProperty;
    public static DependencyProperty RotationProperty;
    public Matrix3D Value { get; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public double CenterZ { get; public set; }
    public Rotation3D Rotation { get; public set; }
    public RotateTransform3D(Rotation3D rotation);
    public RotateTransform3D(Rotation3D rotation, Point3D center);
    public RotateTransform3D(Rotation3D rotation, double centerX, double centerY, double centerZ);
    public virtual Matrix3D get_Value();
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public double get_CenterZ();
    public void set_CenterZ(double value);
    public Rotation3D get_Rotation();
    public void set_Rotation(Rotation3D value);
    public RotateTransform3D Clone();
    public RotateTransform3D CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.Media3D.Rotation3D : Animatable {
    public static Rotation3D Identity { get; }
    public static Rotation3D get_Identity();
    public Rotation3D Clone();
    public Rotation3D CloneCurrentValue();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.Media3D.ScaleTransform3D : AffineTransform3D {
    public static DependencyProperty ScaleXProperty;
    public static DependencyProperty ScaleYProperty;
    public static DependencyProperty ScaleZProperty;
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    public static DependencyProperty CenterZProperty;
    public Matrix3D Value { get; }
    public double ScaleX { get; public set; }
    public double ScaleY { get; public set; }
    public double ScaleZ { get; public set; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public double CenterZ { get; public set; }
    public ScaleTransform3D(Vector3D scale);
    public ScaleTransform3D(double scaleX, double scaleY, double scaleZ);
    public ScaleTransform3D(Vector3D scale, Point3D center);
    public ScaleTransform3D(double scaleX, double scaleY, double scaleZ, double centerX, double centerY, double centerZ);
    public virtual Matrix3D get_Value();
    public double get_ScaleX();
    public void set_ScaleX(double value);
    public double get_ScaleY();
    public void set_ScaleY(double value);
    public double get_ScaleZ();
    public void set_ScaleZ(double value);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public double get_CenterZ();
    public void set_CenterZ(double value);
    public ScaleTransform3D Clone();
    public ScaleTransform3D CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Size3DValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.Media3D.Size3DConverter")]
public class System.Windows.Media.Media3D.Size3D : ValueType {
    public static Size3D Empty { get; }
    public bool IsEmpty { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public Size3D(double x, double y, double z);
    public static Size3D get_Empty();
    public bool get_IsEmpty();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public static Vector3D op_Explicit(Size3D size);
    public static Point3D op_Explicit(Size3D size);
    public static bool op_Equality(Size3D size1, Size3D size2);
    public static bool op_Inequality(Size3D size1, Size3D size2);
    public static bool Equals(Size3D size1, Size3D size2);
    public virtual bool Equals(object o);
    public bool Equals(Size3D value);
    public virtual int GetHashCode();
    public static Size3D Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.Media3D.Size3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.SpecularMaterial : Material {
    public static DependencyProperty ColorProperty;
    public static DependencyProperty BrushProperty;
    public static DependencyProperty SpecularPowerProperty;
    public Color Color { get; public set; }
    public Brush Brush { get; public set; }
    public double SpecularPower { get; public set; }
    public SpecularMaterial(Brush brush, double specularPower);
    public Color get_Color();
    public void set_Color(Color value);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    public double get_SpecularPower();
    public void set_SpecularPower(double value);
    public SpecularMaterial Clone();
    public SpecularMaterial CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.SpotLight : PointLightBase {
    public static DependencyProperty DirectionProperty;
    public static DependencyProperty OuterConeAngleProperty;
    public static DependencyProperty InnerConeAngleProperty;
    public Vector3D Direction { get; public set; }
    public double OuterConeAngle { get; public set; }
    public double InnerConeAngle { get; public set; }
    public SpotLight(Color diffuseColor, Point3D position, Vector3D direction, double outerConeAngle, double innerConeAngle);
    public Vector3D get_Direction();
    public void set_Direction(Vector3D value);
    public double get_OuterConeAngle();
    public void set_OuterConeAngle(double value);
    public double get_InnerConeAngle();
    public void set_InnerConeAngle(double value);
    public SpotLight Clone();
    public SpotLight CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.Transform3D : GeneralTransform3D {
    public GeneralTransform3D Inverse { get; }
    public static Transform3D Identity { get; }
    public bool IsAffine { get; }
    public Matrix3D Value { get; }
    public virtual GeneralTransform3D get_Inverse();
    public static Transform3D get_Identity();
    public abstract virtual bool get_IsAffine();
    public abstract virtual Matrix3D get_Value();
    public Point3D Transform(Point3D point);
    public Vector3D Transform(Vector3D vector);
    public Point4D Transform(Point4D point);
    public void Transform(Point3D[] points);
    public void Transform(Vector3D[] vectors);
    public void Transform(Point4D[] points);
    public virtual bool TryTransform(Point3D inPoint, Point3D& result);
    public virtual Rect3D TransformBounds(Rect3D rect);
    public Transform3D Clone();
    public Transform3D CloneCurrentValue();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.Transform3DCollection : Animatable {
    public Transform3D Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Transform3D>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Transform3DCollection(int capacity);
    public Transform3DCollection(IEnumerable`1<Transform3D> collection);
    public sealed virtual Transform3D get_Item(int index);
    public sealed virtual void set_Item(int index, Transform3D value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Transform3D>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public Transform3DCollection Clone();
    public Transform3DCollection CloneCurrentValue();
    public sealed virtual void Add(Transform3D value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Transform3D value);
    public sealed virtual int IndexOf(Transform3D value);
    public sealed virtual void Insert(int index, Transform3D value);
    public sealed virtual bool Remove(Transform3D value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(Transform3D[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Transform3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Transform3D>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.Transform3DGroup : Transform3D {
    public static DependencyProperty ChildrenProperty;
    public Matrix3D Value { get; }
    public bool IsAffine { get; }
    public Transform3DCollection Children { get; public set; }
    public virtual Matrix3D get_Value();
    public virtual bool get_IsAffine();
    public Transform3DCollection get_Children();
    public void set_Children(Transform3DCollection value);
    public Transform3DGroup Clone();
    public Transform3DGroup CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.TranslateTransform3D : AffineTransform3D {
    public static DependencyProperty OffsetXProperty;
    public static DependencyProperty OffsetYProperty;
    public static DependencyProperty OffsetZProperty;
    public Matrix3D Value { get; }
    public double OffsetX { get; public set; }
    public double OffsetY { get; public set; }
    public double OffsetZ { get; public set; }
    public TranslateTransform3D(Vector3D offset);
    public TranslateTransform3D(double offsetX, double offsetY, double offsetZ);
    public virtual Matrix3D get_Value();
    public double get_OffsetX();
    public void set_OffsetX(double value);
    public double get_OffsetY();
    public void set_OffsetY(double value);
    public double get_OffsetZ();
    public void set_OffsetZ(double value);
    public TranslateTransform3D Clone();
    public TranslateTransform3D CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[TypeConverterAttribute("System.Windows.Media.Media3D.Vector3DConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Vector3DValueSerializer")]
public class System.Windows.Media.Media3D.Vector3D : ValueType {
    public double Length { get; }
    public double LengthSquared { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public Vector3D(double x, double y, double z);
    public double get_Length();
    public double get_LengthSquared();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public static Point3D op_Explicit(Vector3D vector);
    public static Size3D op_Explicit(Vector3D vector);
    public static Vector3D op_UnaryNegation(Vector3D vector);
    public static Vector3D op_Addition(Vector3D vector1, Vector3D vector2);
    public static Vector3D op_Subtraction(Vector3D vector1, Vector3D vector2);
    public static Point3D op_Addition(Vector3D vector, Point3D point);
    public static Point3D op_Subtraction(Vector3D vector, Point3D point);
    public static Vector3D op_Multiply(Vector3D vector, double scalar);
    public static Vector3D op_Multiply(double scalar, Vector3D vector);
    public static Vector3D op_Division(Vector3D vector, double scalar);
    public static Vector3D op_Multiply(Vector3D vector, Matrix3D matrix);
    public static bool op_Equality(Vector3D vector1, Vector3D vector2);
    public static bool op_Inequality(Vector3D vector1, Vector3D vector2);
    public void Normalize();
    public static double AngleBetween(Vector3D vector1, Vector3D vector2);
    public void Negate();
    public static Vector3D Add(Vector3D vector1, Vector3D vector2);
    public static Vector3D Subtract(Vector3D vector1, Vector3D vector2);
    public static Point3D Add(Vector3D vector, Point3D point);
    public static Point3D Subtract(Vector3D vector, Point3D point);
    public static Vector3D Multiply(Vector3D vector, double scalar);
    public static Vector3D Multiply(double scalar, Vector3D vector);
    public static Vector3D Divide(Vector3D vector, double scalar);
    public static Vector3D Multiply(Vector3D vector, Matrix3D matrix);
    public static double DotProduct(Vector3D vector1, Vector3D vector2);
    public static Vector3D CrossProduct(Vector3D vector1, Vector3D vector2);
    public static bool Equals(Vector3D vector1, Vector3D vector2);
    public virtual bool Equals(object o);
    public bool Equals(Vector3D value);
    public virtual int GetHashCode();
    public static Vector3D Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Vector3DCollectionValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.Media3D.Vector3DCollectionConverter")]
public class System.Windows.Media.Media3D.Vector3DCollection : Freezable {
    public Vector3D Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Vector3D>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Vector3DCollection(int capacity);
    public Vector3DCollection(IEnumerable`1<Vector3D> collection);
    public sealed virtual Vector3D get_Item(int index);
    public sealed virtual void set_Item(int index, Vector3D value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Vector3D>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public Vector3DCollection Clone();
    public Vector3DCollection CloneCurrentValue();
    public sealed virtual void Add(Vector3D value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Vector3D value);
    public sealed virtual int IndexOf(Vector3D value);
    public sealed virtual void Insert(int index, Vector3D value);
    public sealed virtual bool Remove(Vector3D value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(Vector3D[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Vector3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Vector3D>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public static Vector3DCollection Parse(string source);
}
public class System.Windows.Media.Media3D.Vector3DCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.Vector3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ContentPropertyAttribute("Visual")]
public class System.Windows.Media.Media3D.Viewport2DVisual3D : Visual3D {
    public static DependencyProperty VisualProperty;
    public static DependencyProperty GeometryProperty;
    public static DependencyProperty MaterialProperty;
    public static DependencyProperty IsVisualHostMaterialProperty;
    public static DependencyProperty CacheModeProperty;
    public Visual Visual { get; public set; }
    public Geometry3D Geometry { get; public set; }
    public Material Material { get; public set; }
    public CacheMode CacheMode { get; public set; }
    protected int Visual3DChildrenCount { get; }
    public Visual get_Visual();
    public void set_Visual(Visual value);
    public Geometry3D get_Geometry();
    public void set_Geometry(Geometry3D value);
    public Material get_Material();
    public void set_Material(Material value);
    public CacheMode get_CacheMode();
    public void set_CacheMode(CacheMode value);
    protected virtual int get_Visual3DChildrenCount();
    public static void SetIsVisualHostMaterial(Material element, bool value);
    public static bool GetIsVisualHostMaterial(Material element);
    protected virtual Visual3D GetVisual3DChild(int index);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.Viewport3DVisual : Visual {
    public static DependencyProperty CameraProperty;
    public static DependencyProperty ViewportProperty;
    public DependencyObject Parent { get; }
    public Geometry Clip { get; public set; }
    public double Opacity { get; public set; }
    public Brush OpacityMask { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffect BitmapEffect { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffectInput BitmapEffectInput { get; public set; }
    public Rect ContentBounds { get; }
    public Transform Transform { get; public set; }
    public Vector Offset { get; public set; }
    public Rect DescendantBounds { get; }
    public Camera Camera { get; public set; }
    public Rect Viewport { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public Visual3DCollection Children { get; }
    public DependencyObject get_Parent();
    public Geometry get_Clip();
    public void set_Clip(Geometry value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public Brush get_OpacityMask();
    public void set_OpacityMask(Brush value);
    public BitmapEffect get_BitmapEffect();
    public void set_BitmapEffect(BitmapEffect value);
    public BitmapEffectInput get_BitmapEffectInput();
    public void set_BitmapEffectInput(BitmapEffectInput value);
    public Rect get_ContentBounds();
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public Vector get_Offset();
    public void set_Offset(Vector value);
    public Rect get_DescendantBounds();
    public Camera get_Camera();
    public void set_Camera(Camera value);
    public Rect get_Viewport();
    public void set_Viewport(Rect value);
    public Visual3DCollection get_Children();
    public HitTestResult HitTest(Point point);
    public void HitTest(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters hitTestParameters);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
}
public abstract class System.Windows.Media.Media3D.Visual3D : DependencyObject {
    public static DependencyProperty TransformProperty;
    public Transform3D Transform { get; public set; }
    protected Model3D Visual3DModel { get; protected set; }
    protected int Visual3DChildrenCount { get; }
    public bool HasAnimatedProperties { get; }
    public Transform3D get_Transform();
    public void set_Transform(Transform3D value);
    protected Model3D get_Visual3DModel();
    protected void set_Visual3DModel(Model3D value);
    protected virtual int get_Visual3DChildrenCount();
    public sealed virtual bool get_HasAnimatedProperties();
    protected void AddVisual3DChild(Visual3D child);
    protected void RemoveVisual3DChild(Visual3D child);
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    protected internal virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    protected virtual Visual3D GetVisual3DChild(int index);
    public bool IsAncestorOf(DependencyObject descendant);
    public bool IsDescendantOf(DependencyObject ancestor);
    public DependencyObject FindCommonVisualAncestor(DependencyObject otherVisual);
    public GeneralTransform3D TransformToAncestor(Visual3D ancestor);
    public GeneralTransform3D TransformToDescendant(Visual3D descendant);
    public GeneralTransform3DTo2D TransformToAncestor(Visual ancestor);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public sealed virtual object GetAnimationBaseValue(DependencyProperty dp);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.Visual3DCollection : object {
    public Visual3D Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Visual3D>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual Visual3D get_Item(int index);
    public sealed virtual void set_Item(int index, Visual3D value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Visual3D>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(Visual3D value);
    public sealed virtual void Insert(int index, Visual3D value);
    public sealed virtual bool Remove(Visual3D value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(Visual3D[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual bool Contains(Visual3D value);
    public sealed virtual int IndexOf(Visual3D value);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<Visual3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Visual3D>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
public class System.Windows.Media.MediaClock : Clock {
    public MediaTimeline Timeline { get; }
    protected internal MediaClock(MediaTimeline media);
    public MediaTimeline get_Timeline();
    protected virtual bool GetCanSlip();
    protected virtual TimeSpan GetCurrentTimeCore();
    protected virtual void Stopped();
    protected virtual void SpeedChanged();
    protected virtual void DiscontinuousTimeMovement();
}
public class System.Windows.Media.MediaPlayer : Animatable {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<ExceptionEventArgs> MediaFailed;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler MediaOpened;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler MediaEnded;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler BufferingStarted;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler BufferingEnded;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<MediaScriptCommandEventArgs> ScriptCommand;
    public bool IsBuffering { get; }
    public bool CanPause { get; }
    public double DownloadProgress { get; }
    public double BufferingProgress { get; }
    public int NaturalVideoHeight { get; }
    public int NaturalVideoWidth { get; }
    public bool HasAudio { get; }
    public bool HasVideo { get; }
    public Uri Source { get; }
    public double Volume { get; public set; }
    public double Balance { get; public set; }
    public bool ScrubbingEnabled { get; public set; }
    public bool IsMuted { get; public set; }
    public Duration NaturalDuration { get; }
    public TimeSpan Position { get; public set; }
    public double SpeedRatio { get; public set; }
    public MediaClock Clock { get; public set; }
    public bool get_IsBuffering();
    public bool get_CanPause();
    public double get_DownloadProgress();
    public double get_BufferingProgress();
    public int get_NaturalVideoHeight();
    public int get_NaturalVideoWidth();
    public bool get_HasAudio();
    public bool get_HasVideo();
    public Uri get_Source();
    public double get_Volume();
    public void set_Volume(double value);
    public double get_Balance();
    public void set_Balance(double value);
    public bool get_ScrubbingEnabled();
    public void set_ScrubbingEnabled(bool value);
    public bool get_IsMuted();
    public void set_IsMuted(bool value);
    public Duration get_NaturalDuration();
    public TimeSpan get_Position();
    public void set_Position(TimeSpan value);
    public double get_SpeedRatio();
    public void set_SpeedRatio(double value);
    public MediaClock get_Clock();
    public void set_Clock(MediaClock value);
    [CompilerGeneratedAttribute]
public void add_MediaFailed(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MediaFailed(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_MediaOpened(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_MediaOpened(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_MediaEnded(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_MediaEnded(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_BufferingStarted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BufferingStarted(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_BufferingEnded(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BufferingEnded(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_ScriptCommand(EventHandler`1<MediaScriptCommandEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ScriptCommand(EventHandler`1<MediaScriptCommandEventArgs> value);
    public void Open(Uri source);
    public void Play();
    public void Pause();
    public void Stop();
    public void Close();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected void ReadPreamble();
    protected void WritePreamble();
}
public class System.Windows.Media.MediaScriptCommandEventArgs : EventArgs {
    public string ParameterType { get; }
    public string ParameterValue { get; }
    internal MediaScriptCommandEventArgs(string parameterType, string parameterValue);
    public string get_ParameterType();
    public string get_ParameterValue();
}
public class System.Windows.Media.MediaTimeline : Timeline {
    public static DependencyProperty SourceProperty;
    public Uri Source { get; public set; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    public MediaTimeline(Uri source);
    public MediaTimeline(Nullable`1<TimeSpan> beginTime);
    public MediaTimeline(Nullable`1<TimeSpan> beginTime, Duration duration);
    public MediaTimeline(Nullable`1<TimeSpan> beginTime, Duration duration, RepeatBehavior repeatBehavior);
    public Uri get_Source();
    public void set_Source(Uri value);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    public MediaTimeline Clone();
    public MediaTimeline CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected internal virtual Clock AllocateClock();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public MediaClock CreateClock();
    protected virtual Duration GetNaturalDurationCore(Clock clock);
    public virtual string ToString();
}
public enum System.Windows.Media.NumberCultureSource : Enum {
    public int value__;
    public static NumberCultureSource Text;
    public static NumberCultureSource User;
    public static NumberCultureSource Override;
}
public class System.Windows.Media.NumberSubstitution : object {
    public static DependencyProperty CultureSourceProperty;
    public static DependencyProperty CultureOverrideProperty;
    public static DependencyProperty SubstitutionProperty;
    public NumberCultureSource CultureSource { get; public set; }
    [TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
public CultureInfo CultureOverride { get; public set; }
    public NumberSubstitutionMethod Substitution { get; public set; }
    public NumberSubstitution(NumberCultureSource source, CultureInfo cultureOverride, NumberSubstitutionMethod substitution);
    public NumberCultureSource get_CultureSource();
    public void set_CultureSource(NumberCultureSource value);
    public CultureInfo get_CultureOverride();
    public void set_CultureOverride(CultureInfo value);
    public NumberSubstitutionMethod get_Substitution();
    public void set_Substitution(NumberSubstitutionMethod value);
    public static void SetCultureSource(DependencyObject target, NumberCultureSource value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static NumberCultureSource GetCultureSource(DependencyObject target);
    public static void SetCultureOverride(DependencyObject target, CultureInfo value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
[TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
public static CultureInfo GetCultureOverride(DependencyObject target);
    public static void SetSubstitution(DependencyObject target, NumberSubstitutionMethod value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static NumberSubstitutionMethod GetSubstitution(DependencyObject target);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public enum System.Windows.Media.NumberSubstitutionMethod : Enum {
    public int value__;
    public static NumberSubstitutionMethod AsCulture;
    public static NumberSubstitutionMethod Context;
    public static NumberSubstitutionMethod European;
    public static NumberSubstitutionMethod NativeNational;
    public static NumberSubstitutionMethod Traditional;
}
internal static class System.Windows.Media.Parsers : object {
    private static int ZeroChar;
    private static int ALower;
    private static int AUpper;
    private static int ParseHexChar(char c);
    private static Color ParseHexColor(string trimmedColor);
    public static Color ParseColor(string color);
}
[LocalizabilityAttribute("0")]
[ContentPropertyAttribute("Segments")]
public class System.Windows.Media.PathFigure : Animatable {
    public static DependencyProperty StartPointProperty;
    public static DependencyProperty IsFilledProperty;
    public static DependencyProperty SegmentsProperty;
    public static DependencyProperty IsClosedProperty;
    public Point StartPoint { get; public set; }
    public bool IsFilled { get; public set; }
    public PathSegmentCollection Segments { get; public set; }
    public bool IsClosed { get; public set; }
    public PathFigure(Point start, IEnumerable`1<PathSegment> segments, bool closed);
    public Point get_StartPoint();
    public void set_StartPoint(Point value);
    public bool get_IsFilled();
    public void set_IsFilled(bool value);
    public PathSegmentCollection get_Segments();
    public void set_Segments(PathSegmentCollection value);
    public bool get_IsClosed();
    public void set_IsClosed(bool value);
    public PathFigure Clone();
    public PathFigure CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    public PathFigure GetFlattenedPathFigure(double tolerance, ToleranceType type);
    public PathFigure GetFlattenedPathFigure();
    public bool MayHaveCurves();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
[ValueSerializerAttribute("System.Windows.Media.Converters.PathFigureCollectionValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.PathFigureCollectionConverter")]
public class System.Windows.Media.PathFigureCollection : Animatable {
    public PathFigure Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.PathFigure>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public PathFigureCollection(int capacity);
    public PathFigureCollection(IEnumerable`1<PathFigure> collection);
    public sealed virtual PathFigure get_Item(int index);
    public sealed virtual void set_Item(int index, PathFigure value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.PathFigure>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public PathFigureCollection Clone();
    public PathFigureCollection CloneCurrentValue();
    public sealed virtual void Add(PathFigure value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(PathFigure value);
    public sealed virtual int IndexOf(PathFigure value);
    public sealed virtual void Insert(int index, PathFigure value);
    public sealed virtual bool Remove(PathFigure value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(PathFigure[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<PathFigure> System.Collections.Generic.IEnumerable<System.Windows.Media.PathFigure>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public static PathFigureCollection Parse(string source);
}
public class System.Windows.Media.PathFigureCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ContentPropertyAttribute("Figures")]
public class System.Windows.Media.PathGeometry : Geometry {
    public static DependencyProperty FillRuleProperty;
    public static DependencyProperty FiguresProperty;
    public FillRule FillRule { get; public set; }
    public PathFigureCollection Figures { get; public set; }
    public Rect Bounds { get; }
    public PathGeometry(IEnumerable`1<PathFigure> figures);
    public PathGeometry(IEnumerable`1<PathFigure> figures, FillRule fillRule, Transform transform);
    public FillRule get_FillRule();
    public void set_FillRule(FillRule value);
    public PathFigureCollection get_Figures();
    public void set_Figures(PathFigureCollection value);
    public virtual Rect get_Bounds();
    public PathGeometry Clone();
    public PathGeometry CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    public static PathGeometry CreateFromGeometry(Geometry geometry);
    protected virtual void OnChanged();
    public void AddGeometry(Geometry geometry);
    [SecurityCriticalAttribute]
public void GetPointAtFractionLength(double progress, Point& point, Point& tangent);
    public void Clear();
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.PathSegment : Animatable {
    public static DependencyProperty IsStrokedProperty;
    public static DependencyProperty IsSmoothJoinProperty;
    public bool IsStroked { get; public set; }
    public bool IsSmoothJoin { get; public set; }
    public bool get_IsStroked();
    public void set_IsStroked(bool value);
    public bool get_IsSmoothJoin();
    public void set_IsSmoothJoin(bool value);
    public PathSegment Clone();
    public PathSegment CloneCurrentValue();
}
[DefaultMemberAttribute("Item")]
[LocalizabilityAttribute("0")]
public class System.Windows.Media.PathSegmentCollection : Animatable {
    public PathSegment Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.PathSegment>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public PathSegmentCollection(int capacity);
    public PathSegmentCollection(IEnumerable`1<PathSegment> collection);
    public sealed virtual PathSegment get_Item(int index);
    public sealed virtual void set_Item(int index, PathSegment value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.PathSegment>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public PathSegmentCollection Clone();
    public PathSegmentCollection CloneCurrentValue();
    public sealed virtual void Add(PathSegment value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(PathSegment value);
    public sealed virtual int IndexOf(PathSegment value);
    public sealed virtual void Insert(int index, PathSegment value);
    public sealed virtual bool Remove(PathSegment value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(PathSegment[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<PathSegment> System.Collections.Generic.IEnumerable<System.Windows.Media.PathSegment>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[LocalizabilityAttribute("0")]
public class System.Windows.Media.Pen : Animatable {
    public static DependencyProperty BrushProperty;
    public static DependencyProperty ThicknessProperty;
    public static DependencyProperty StartLineCapProperty;
    public static DependencyProperty EndLineCapProperty;
    public static DependencyProperty DashCapProperty;
    public static DependencyProperty LineJoinProperty;
    public static DependencyProperty MiterLimitProperty;
    public static DependencyProperty DashStyleProperty;
    public Brush Brush { get; public set; }
    public double Thickness { get; public set; }
    public PenLineCap StartLineCap { get; public set; }
    public PenLineCap EndLineCap { get; public set; }
    public PenLineCap DashCap { get; public set; }
    public PenLineJoin LineJoin { get; public set; }
    public double MiterLimit { get; public set; }
    public DashStyle DashStyle { get; public set; }
    public Pen(Brush brush, double thickness);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    public double get_Thickness();
    public void set_Thickness(double value);
    public PenLineCap get_StartLineCap();
    public void set_StartLineCap(PenLineCap value);
    public PenLineCap get_EndLineCap();
    public void set_EndLineCap(PenLineCap value);
    public PenLineCap get_DashCap();
    public void set_DashCap(PenLineCap value);
    public PenLineJoin get_LineJoin();
    public void set_LineJoin(PenLineJoin value);
    public double get_MiterLimit();
    public void set_MiterLimit(double value);
    public DashStyle get_DashStyle();
    public void set_DashStyle(DashStyle value);
    public Pen Clone();
    public Pen CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public enum System.Windows.Media.PenLineCap : Enum {
    public int value__;
    public static PenLineCap Flat;
    public static PenLineCap Square;
    public static PenLineCap Round;
    public static PenLineCap Triangle;
}
public enum System.Windows.Media.PenLineJoin : Enum {
    public int value__;
    public static PenLineJoin Miter;
    public static PenLineJoin Bevel;
    public static PenLineJoin Round;
}
[TypeConverterAttribute("System.Windows.Media.PixelFormatConverter")]
public class System.Windows.Media.PixelFormat : ValueType {
    private UInt32 _bitsPerPixel;
    public int BitsPerPixel { get; }
    public IList`1<PixelFormatChannelMask> Masks { get; }
    public int get_BitsPerPixel();
    [SecurityCriticalAttribute]
public IList`1<PixelFormatChannelMask> get_Masks();
    public static bool op_Equality(PixelFormat left, PixelFormat right);
    public static bool op_Inequality(PixelFormat left, PixelFormat right);
    public static bool Equals(PixelFormat left, PixelFormat right);
    public sealed virtual bool Equals(PixelFormat pixelFormat);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Windows.Media.PixelFormatChannelMask : ValueType {
    private Byte[] _mask;
    public IList`1<byte> Mask { get; }
    internal PixelFormatChannelMask(Byte[] mask);
    public IList`1<byte> get_Mask();
    public static bool op_Equality(PixelFormatChannelMask left, PixelFormatChannelMask right);
    public static bool op_Inequality(PixelFormatChannelMask left, PixelFormatChannelMask right);
    public static bool Equals(PixelFormatChannelMask left, PixelFormatChannelMask right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.Windows.Media.PixelFormatConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public object ConvertFromString(string value);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object o);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.Media.PixelFormats : object {
    public static PixelFormat Default { get; }
    public static PixelFormat Indexed1 { get; }
    public static PixelFormat Indexed2 { get; }
    public static PixelFormat Indexed4 { get; }
    public static PixelFormat Indexed8 { get; }
    public static PixelFormat BlackWhite { get; }
    public static PixelFormat Gray2 { get; }
    public static PixelFormat Gray4 { get; }
    public static PixelFormat Gray8 { get; }
    public static PixelFormat Bgr555 { get; }
    public static PixelFormat Bgr565 { get; }
    public static PixelFormat Rgb128Float { get; }
    public static PixelFormat Bgr24 { get; }
    public static PixelFormat Rgb24 { get; }
    public static PixelFormat Bgr101010 { get; }
    public static PixelFormat Bgr32 { get; }
    public static PixelFormat Bgra32 { get; }
    public static PixelFormat Pbgra32 { get; }
    public static PixelFormat Rgb48 { get; }
    public static PixelFormat Rgba64 { get; }
    public static PixelFormat Prgba64 { get; }
    public static PixelFormat Gray16 { get; }
    public static PixelFormat Gray32Float { get; }
    public static PixelFormat Rgba128Float { get; }
    public static PixelFormat Prgba128Float { get; }
    public static PixelFormat Cmyk32 { get; }
    public static PixelFormat get_Default();
    public static PixelFormat get_Indexed1();
    public static PixelFormat get_Indexed2();
    public static PixelFormat get_Indexed4();
    public static PixelFormat get_Indexed8();
    public static PixelFormat get_BlackWhite();
    public static PixelFormat get_Gray2();
    public static PixelFormat get_Gray4();
    public static PixelFormat get_Gray8();
    public static PixelFormat get_Bgr555();
    public static PixelFormat get_Bgr565();
    public static PixelFormat get_Rgb128Float();
    public static PixelFormat get_Bgr24();
    public static PixelFormat get_Rgb24();
    public static PixelFormat get_Bgr101010();
    public static PixelFormat get_Bgr32();
    public static PixelFormat get_Bgra32();
    public static PixelFormat get_Pbgra32();
    public static PixelFormat get_Rgb48();
    public static PixelFormat get_Rgba64();
    public static PixelFormat get_Prgba64();
    public static PixelFormat get_Gray16();
    public static PixelFormat get_Gray32Float();
    public static PixelFormat get_Rgba128Float();
    public static PixelFormat get_Prgba128Float();
    public static PixelFormat get_Cmyk32();
}
[DefaultMemberAttribute("Item")]
[ValueSerializerAttribute("System.Windows.Media.Converters.PointCollectionValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.PointCollectionConverter")]
public class System.Windows.Media.PointCollection : Freezable {
    public Point Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Point>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public PointCollection(int capacity);
    public PointCollection(IEnumerable`1<Point> collection);
    public sealed virtual Point get_Item(int index);
    public sealed virtual void set_Item(int index, Point value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Point>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public PointCollection Clone();
    public PointCollection CloneCurrentValue();
    public sealed virtual void Add(Point value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Point value);
    public sealed virtual int IndexOf(Point value);
    public sealed virtual void Insert(int index, Point value);
    public sealed virtual bool Remove(Point value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(Point[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Point> System.Collections.Generic.IEnumerable<System.Windows.Point>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public static PointCollection Parse(string source);
}
public class System.Windows.Media.PointCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.PointHitTestParameters : HitTestParameters {
    public Point HitPoint { get; }
    public PointHitTestParameters(Point point);
    public Point get_HitPoint();
}
public class System.Windows.Media.PointHitTestResult : HitTestResult {
    public Point PointHit { get; }
    public Visual VisualHit { get; }
    public PointHitTestResult(Visual visualHit, Point pointHit);
    public Point get_PointHit();
    public Visual get_VisualHit();
}
public class System.Windows.Media.PolyBezierSegment : PathSegment {
    public static DependencyProperty PointsProperty;
    public PointCollection Points { get; public set; }
    public PolyBezierSegment(IEnumerable`1<Point> points, bool isStroked);
    public PointCollection get_Points();
    public void set_Points(PointCollection value);
    public PolyBezierSegment Clone();
    public PolyBezierSegment CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.PolyLineSegment : PathSegment {
    public static DependencyProperty PointsProperty;
    public PointCollection Points { get; public set; }
    public PolyLineSegment(IEnumerable`1<Point> points, bool isStroked);
    public PointCollection get_Points();
    public void set_Points(PointCollection value);
    public PolyLineSegment Clone();
    public PolyLineSegment CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.PolyQuadraticBezierSegment : PathSegment {
    public static DependencyProperty PointsProperty;
    public PointCollection Points { get; public set; }
    public PolyQuadraticBezierSegment(IEnumerable`1<Point> points, bool isStroked);
    public PointCollection get_Points();
    public void set_Points(PointCollection value);
    public PolyQuadraticBezierSegment Clone();
    public PolyQuadraticBezierSegment CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.QuadraticBezierSegment : PathSegment {
    public static DependencyProperty Point1Property;
    public static DependencyProperty Point2Property;
    public Point Point1 { get; public set; }
    public Point Point2 { get; public set; }
    public QuadraticBezierSegment(Point point1, Point point2, bool isStroked);
    public Point get_Point1();
    public void set_Point1(Point value);
    public Point get_Point2();
    public void set_Point2(Point value);
    public QuadraticBezierSegment Clone();
    public QuadraticBezierSegment CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.RadialGradientBrush : GradientBrush {
    public static DependencyProperty CenterProperty;
    public static DependencyProperty RadiusXProperty;
    public static DependencyProperty RadiusYProperty;
    public static DependencyProperty GradientOriginProperty;
    public Point Center { get; public set; }
    public double RadiusX { get; public set; }
    public double RadiusY { get; public set; }
    public Point GradientOrigin { get; public set; }
    public RadialGradientBrush(Color startColor, Color endColor);
    public RadialGradientBrush(GradientStopCollection gradientStopCollection);
    public Point get_Center();
    public void set_Center(Point value);
    public double get_RadiusX();
    public void set_RadiusX(double value);
    public double get_RadiusY();
    public void set_RadiusY(double value);
    public Point get_GradientOrigin();
    public void set_GradientOrigin(Point value);
    public RadialGradientBrush Clone();
    public RadialGradientBrush CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.RectangleGeometry : Geometry {
    public static DependencyProperty RadiusXProperty;
    public static DependencyProperty RadiusYProperty;
    public static DependencyProperty RectProperty;
    public double RadiusX { get; public set; }
    public double RadiusY { get; public set; }
    public Rect Rect { get; public set; }
    public Rect Bounds { get; }
    public RectangleGeometry(Rect rect);
    public RectangleGeometry(Rect rect, double radiusX, double radiusY);
    public RectangleGeometry(Rect rect, double radiusX, double radiusY, Transform transform);
    public double get_RadiusX();
    public void set_RadiusX(double value);
    public double get_RadiusY();
    public void set_RadiusY(double value);
    public Rect get_Rect();
    public void set_Rect(Rect value);
    public virtual Rect get_Bounds();
    public RectangleGeometry Clone();
    public RectangleGeometry CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    public virtual double GetArea(double tolerance, ToleranceType type);
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
}
public static class System.Windows.Media.RenderCapability : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static EventHandler TierChanged;
    public static int Tier { get; }
    [ObsoleteAttribute("IsShaderEffectSoftwareRenderingSupported property is deprecated.  Use IsPixelShaderVersionSupportedInSoftware static method instead.")]
public static bool IsShaderEffectSoftwareRenderingSupported { get; }
    public static Size MaxHardwareTextureSize { get; }
    public static int get_Tier();
    public static bool get_IsShaderEffectSoftwareRenderingSupported();
    public static Size get_MaxHardwareTextureSize();
    [CompilerGeneratedAttribute]
public static void add_TierChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_TierChanged(EventHandler value);
    public static bool IsPixelShaderVersionSupported(short majorVersionRequested, short minorVersionRequested);
    public static bool IsPixelShaderVersionSupportedInSoftware(short majorVersionRequested, short minorVersionRequested);
    public static int MaxPixelShaderInstructionSlots(short majorVersionRequested, short minorVersionRequested);
}
public class System.Windows.Media.RenderingEventArgs : EventArgs {
    public TimeSpan RenderingTime { get; }
    internal RenderingEventArgs(TimeSpan renderingTime);
    public TimeSpan get_RenderingTime();
}
public static class System.Windows.Media.RenderOptions : object {
    public static DependencyProperty EdgeModeProperty;
    public static DependencyProperty BitmapScalingModeProperty;
    public static DependencyProperty ClearTypeHintProperty;
    public static DependencyProperty CachingHintProperty;
    public static DependencyProperty CacheInvalidationThresholdMinimumProperty;
    public static DependencyProperty CacheInvalidationThresholdMaximumProperty;
    public static RenderMode ProcessRenderMode { get; public set; }
    [SecurityCriticalAttribute]
public static RenderMode get_ProcessRenderMode();
    [SecurityCriticalAttribute]
public static void set_ProcessRenderMode(RenderMode value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static EdgeMode GetEdgeMode(DependencyObject target);
    public static void SetEdgeMode(DependencyObject target, EdgeMode edgeMode);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static BitmapScalingMode GetBitmapScalingMode(DependencyObject target);
    public static void SetBitmapScalingMode(DependencyObject target, BitmapScalingMode bitmapScalingMode);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static ClearTypeHint GetClearTypeHint(DependencyObject target);
    public static void SetClearTypeHint(DependencyObject target, ClearTypeHint clearTypeHint);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.Media.TileBrush")]
public static CachingHint GetCachingHint(DependencyObject target);
    public static void SetCachingHint(DependencyObject target, CachingHint cachingHint);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.Media.TileBrush")]
public static double GetCacheInvalidationThresholdMinimum(DependencyObject target);
    public static void SetCacheInvalidationThresholdMinimum(DependencyObject target, double cacheInvalidationThresholdMinimum);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.Media.TileBrush")]
public static double GetCacheInvalidationThresholdMaximum(DependencyObject target);
    public static void SetCacheInvalidationThresholdMaximum(DependencyObject target, double cacheInvalidationThresholdMaximum);
}
public class System.Windows.Media.RequestCachePolicyConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
public class System.Windows.Media.RotateTransform : Transform {
    public static DependencyProperty AngleProperty;
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    public double Angle { get; public set; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public Matrix Value { get; }
    public RotateTransform(double angle);
    public RotateTransform(double angle, double centerX, double centerY);
    public double get_Angle();
    public void set_Angle(double value);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public virtual Matrix get_Value();
    public RotateTransform Clone();
    public RotateTransform CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.ScaleTransform : Transform {
    public static DependencyProperty ScaleXProperty;
    public static DependencyProperty ScaleYProperty;
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    public double ScaleX { get; public set; }
    public double ScaleY { get; public set; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public Matrix Value { get; }
    public ScaleTransform(double scaleX, double scaleY);
    public ScaleTransform(double scaleX, double scaleY, double centerX, double centerY);
    public double get_ScaleX();
    public void set_ScaleX(double value);
    public double get_ScaleY();
    public void set_ScaleY(double value);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public virtual Matrix get_Value();
    public ScaleTransform Clone();
    public ScaleTransform CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.SkewTransform : Transform {
    public static DependencyProperty AngleXProperty;
    public static DependencyProperty AngleYProperty;
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    public double AngleX { get; public set; }
    public double AngleY { get; public set; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public Matrix Value { get; }
    public SkewTransform(double angleX, double angleY);
    public SkewTransform(double angleX, double angleY, double centerX, double centerY);
    public double get_AngleX();
    public void set_AngleX(double value);
    public double get_AngleY();
    public void set_AngleY(double value);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public virtual Matrix get_Value();
    public SkewTransform Clone();
    public SkewTransform CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.SolidColorBrush : Brush {
    public static DependencyProperty ColorProperty;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Color <Color>k__BackingField;
    public Color Color { get; public set; }
    public SolidColorBrush(Color color);
    [CompilerGeneratedAttribute]
public Color get_Color();
    [CompilerGeneratedAttribute]
public void set_Color(Color value);
    public SolidColorBrush Clone();
    public SolidColorBrush CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    public static object DeserializeFrom(BinaryReader reader);
}
[TypeConverterAttribute("System.Windows.Media.GeometryConverter")]
public class System.Windows.Media.StreamGeometry : Geometry {
    public static DependencyProperty FillRuleProperty;
    public FillRule FillRule { get; public set; }
    public Rect Bounds { get; }
    public FillRule get_FillRule();
    public void set_FillRule(FillRule value);
    public virtual Rect get_Bounds();
    public StreamGeometry Clone();
    public StreamGeometry CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    public StreamGeometryContext Open();
    public void Clear();
    [SecurityCriticalAttribute]
public virtual bool IsEmpty();
    [SecurityCriticalAttribute]
public virtual bool MayHaveCurves();
    protected virtual void OnChanged();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
public abstract class System.Windows.Media.StreamGeometryContext : DispatcherObject {
    private sealed virtual override void System.IDisposable.Dispose();
    public virtual void Close();
    public abstract virtual void BeginFigure(Point startPoint, bool isFilled, bool isClosed);
    public abstract virtual void LineTo(Point point, bool isStroked, bool isSmoothJoin);
    public abstract virtual void QuadraticBezierTo(Point point1, Point point2, bool isStroked, bool isSmoothJoin);
    public abstract virtual void BezierTo(Point point1, Point point2, Point point3, bool isStroked, bool isSmoothJoin);
    public abstract virtual void PolyLineTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public abstract virtual void PolyQuadraticBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public abstract virtual void PolyBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public abstract virtual void ArcTo(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection, bool isStroked, bool isSmoothJoin);
}
public enum System.Windows.Media.Stretch : Enum {
    public int value__;
    public static Stretch None;
    public static Stretch Fill;
    public static Stretch Uniform;
    public static Stretch UniformToFill;
}
[FlagsAttribute]
public enum System.Windows.Media.StyleSimulations : Enum {
    public int value__;
    public static StyleSimulations None;
    public static StyleSimulations BoldSimulation;
    public static StyleSimulations ItalicSimulation;
    public static StyleSimulations BoldItalicSimulation;
}
public enum System.Windows.Media.SweepDirection : Enum {
    public int value__;
    public static SweepDirection Counterclockwise;
    public static SweepDirection Clockwise;
}
[LocalizabilityAttribute("0")]
public class System.Windows.Media.TextEffect : Animatable {
    public static DependencyProperty TransformProperty;
    public static DependencyProperty ClipProperty;
    public static DependencyProperty ForegroundProperty;
    public static DependencyProperty PositionStartProperty;
    public static DependencyProperty PositionCountProperty;
    public Transform Transform { get; public set; }
    public Geometry Clip { get; public set; }
    public Brush Foreground { get; public set; }
    public int PositionStart { get; public set; }
    public int PositionCount { get; public set; }
    public TextEffect(Transform transform, Brush foreground, Geometry clip, int positionStart, int positionCount);
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public Geometry get_Clip();
    public void set_Clip(Geometry value);
    public Brush get_Foreground();
    public void set_Foreground(Brush value);
    public int get_PositionStart();
    public void set_PositionStart(int value);
    public int get_PositionCount();
    public void set_PositionCount(int value);
    public TextEffect Clone();
    public TextEffect CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[DefaultMemberAttribute("Item")]
[LocalizabilityAttribute("0")]
public class System.Windows.Media.TextEffectCollection : Animatable {
    public TextEffect Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.TextEffect>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public TextEffectCollection(int capacity);
    public TextEffectCollection(IEnumerable`1<TextEffect> collection);
    public sealed virtual TextEffect get_Item(int index);
    public sealed virtual void set_Item(int index, TextEffect value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.TextEffect>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public TextEffectCollection Clone();
    public TextEffectCollection CloneCurrentValue();
    public sealed virtual void Add(TextEffect value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TextEffect value);
    public sealed virtual int IndexOf(TextEffect value);
    public sealed virtual void Insert(int index, TextEffect value);
    public sealed virtual bool Remove(TextEffect value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(TextEffect[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<TextEffect> System.Collections.Generic.IEnumerable<System.Windows.Media.TextEffect>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
public class System.Windows.Media.TextFormatting.CharacterBufferRange : ValueType {
    private CharacterBufferReference _charBufferRef;
    private int _length;
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public static CharacterBufferRange Empty { get; }
    public CharacterBufferRange(Char[] characterArray, int offsetToFirstChar, int characterLength);
    public CharacterBufferRange(string characterString, int offsetToFirstChar, int characterLength);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public CharacterBufferRange(Char* unsafeCharacterString, int characterLength);
    public CharacterBufferReference get_CharacterBufferReference();
    public int get_Length();
    public static CharacterBufferRange get_Empty();
    public static bool op_Equality(CharacterBufferRange left, CharacterBufferRange right);
    public static bool op_Inequality(CharacterBufferRange left, CharacterBufferRange right);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CharacterBufferRange value);
}
public class System.Windows.Media.TextFormatting.CharacterBufferReference : ValueType {
    private int _offsetToFirstChar;
    public CharacterBufferReference(Char[] characterArray, int offsetToFirstChar);
    public CharacterBufferReference(string characterString, int offsetToFirstChar);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public CharacterBufferReference(Char* unsafeCharacterString, int characterLength);
    public static bool op_Equality(CharacterBufferReference left, CharacterBufferReference right);
    public static bool op_Inequality(CharacterBufferReference left, CharacterBufferReference right);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CharacterBufferReference value);
}
public class System.Windows.Media.TextFormatting.CharacterHit : ValueType {
    private int _firstCharacterIndex;
    private int _trailingLength;
    public int FirstCharacterIndex { get; }
    public int TrailingLength { get; }
    public CharacterHit(int firstCharacterIndex, int trailingLength);
    public int get_FirstCharacterIndex();
    public int get_TrailingLength();
    public static bool op_Equality(CharacterHit left, CharacterHit right);
    public static bool op_Inequality(CharacterHit left, CharacterHit right);
    public sealed virtual bool Equals(CharacterHit obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.Windows.Media.TextFormatting.CultureSpecificCharacterBufferRange : object {
    public CultureInfo CultureInfo { get; }
    public CharacterBufferRange CharacterBufferRange { get; }
    public CultureSpecificCharacterBufferRange(CultureInfo culture, CharacterBufferRange characterBufferRange);
    public CultureInfo get_CultureInfo();
    public CharacterBufferRange get_CharacterBufferRange();
}
public class System.Windows.Media.TextFormatting.IndexedGlyphRun : object {
    public int TextSourceCharacterIndex { get; }
    public int TextSourceLength { get; }
    public GlyphRun GlyphRun { get; }
    internal IndexedGlyphRun(int textSourceCharacterIndex, int textSourceCharacterLength, GlyphRun glyphRun);
    public int get_TextSourceCharacterIndex();
    public int get_TextSourceLength();
    public GlyphRun get_GlyphRun();
}
[FlagsAttribute]
public enum System.Windows.Media.TextFormatting.InvertAxes : Enum {
    public int value__;
    public static InvertAxes None;
    public static InvertAxes Horizontal;
    public static InvertAxes Vertical;
    public static InvertAxes Both;
}
public class System.Windows.Media.TextFormatting.MinMaxParagraphWidth : ValueType {
    private double _minWidth;
    private double _maxWidth;
    public double MinWidth { get; }
    public double MaxWidth { get; }
    internal MinMaxParagraphWidth(double minWidth, double maxWidth);
    public double get_MinWidth();
    public double get_MaxWidth();
    public static bool op_Equality(MinMaxParagraphWidth left, MinMaxParagraphWidth right);
    public static bool op_Inequality(MinMaxParagraphWidth left, MinMaxParagraphWidth right);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MinMaxParagraphWidth value);
    public virtual bool Equals(object obj);
}
public class System.Windows.Media.TextFormatting.TextBounds : object {
    public Rect Rectangle { get; }
    public IList`1<TextRunBounds> TextRunBounds { get; }
    public FlowDirection FlowDirection { get; }
    internal TextBounds(Rect bounds, FlowDirection flowDirection, IList`1<TextRunBounds> runBounds);
    public Rect get_Rectangle();
    public IList`1<TextRunBounds> get_TextRunBounds();
    public FlowDirection get_FlowDirection();
}
public class System.Windows.Media.TextFormatting.TextCharacters : TextRun {
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public TextCharacters(Char[] characterArray, int offsetToFirstChar, int length, TextRunProperties textRunProperties);
    public TextCharacters(string characterString, TextRunProperties textRunProperties);
    public TextCharacters(string characterString, int offsetToFirstChar, int length, TextRunProperties textRunProperties);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public TextCharacters(Char* unsafeCharacterString, int length, TextRunProperties textRunProperties);
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
}
public class System.Windows.Media.TextFormatting.TextCollapsedRange : object {
    public int TextSourceCharacterIndex { get; }
    public int Length { get; }
    public double Width { get; }
    internal TextCollapsedRange(int cp, int length, double width);
    public int get_TextSourceCharacterIndex();
    public int get_Length();
    public double get_Width();
}
public abstract class System.Windows.Media.TextFormatting.TextCollapsingProperties : object {
    public double Width { get; }
    public TextRun Symbol { get; }
    public TextCollapsingStyle Style { get; }
    public abstract virtual double get_Width();
    public abstract virtual TextRun get_Symbol();
    public abstract virtual TextCollapsingStyle get_Style();
}
public enum System.Windows.Media.TextFormatting.TextCollapsingStyle : Enum {
    public int value__;
    public static TextCollapsingStyle TrailingCharacter;
    public static TextCollapsingStyle TrailingWord;
}
public abstract class System.Windows.Media.TextFormatting.TextEmbeddedObject : TextRun {
    public LineBreakCondition BreakBefore { get; }
    public LineBreakCondition BreakAfter { get; }
    public bool HasFixedSize { get; }
    public abstract virtual LineBreakCondition get_BreakBefore();
    public abstract virtual LineBreakCondition get_BreakAfter();
    public abstract virtual bool get_HasFixedSize();
    public abstract virtual TextEmbeddedObjectMetrics Format(double remainingParagraphWidth);
    public abstract virtual Rect ComputeBoundingBox(bool rightToLeft, bool sideways);
    public abstract virtual void Draw(DrawingContext drawingContext, Point origin, bool rightToLeft, bool sideways);
}
public class System.Windows.Media.TextFormatting.TextEmbeddedObjectMetrics : object {
    public double Width { get; }
    public double Height { get; }
    public double Baseline { get; }
    public TextEmbeddedObjectMetrics(double width, double height, double baseline);
    public double get_Width();
    public double get_Height();
    public double get_Baseline();
}
public class System.Windows.Media.TextFormatting.TextEndOfLine : TextRun {
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public TextEndOfLine(int length);
    public TextEndOfLine(int length, TextRunProperties textRunProperties);
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
}
public class System.Windows.Media.TextFormatting.TextEndOfParagraph : TextEndOfLine {
    public TextEndOfParagraph(int length);
    public TextEndOfParagraph(int length, TextRunProperties textRunProperties);
}
public class System.Windows.Media.TextFormatting.TextEndOfSegment : TextRun {
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public TextEndOfSegment(int length);
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
}
public abstract class System.Windows.Media.TextFormatting.TextFormatter : object {
    public static TextFormatter Create(TextFormattingMode textFormattingMode);
    public static TextFormatter Create();
    public virtual void Dispose();
    public abstract virtual TextLine FormatLine(TextSource textSource, int firstCharIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak);
    public abstract virtual TextLine FormatLine(TextSource textSource, int firstCharIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache);
    public abstract virtual MinMaxParagraphWidth FormatMinMaxParagraphWidth(TextSource textSource, int firstCharIndex, TextParagraphProperties paragraphProperties);
    public abstract virtual MinMaxParagraphWidth FormatMinMaxParagraphWidth(TextSource textSource, int firstCharIndex, TextParagraphProperties paragraphProperties, TextRunCache textRunCache);
}
public class System.Windows.Media.TextFormatting.TextHidden : TextRun {
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public TextHidden(int length);
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
}
public abstract class System.Windows.Media.TextFormatting.TextLine : object {
    public bool HasOverflowed { get; }
    public bool HasCollapsed { get; }
    public bool IsTruncated { get; }
    public int Length { get; }
    public int TrailingWhitespaceLength { get; }
    public int DependentLength { get; }
    public int NewlineLength { get; }
    public double Start { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public double Height { get; }
    public double TextHeight { get; }
    public double Extent { get; }
    public double Baseline { get; }
    public double TextBaseline { get; }
    public double MarkerBaseline { get; }
    public double MarkerHeight { get; }
    public double OverhangLeading { get; }
    public double OverhangTrailing { get; }
    public double OverhangAfter { get; }
    public abstract virtual bool get_HasOverflowed();
    public abstract virtual bool get_HasCollapsed();
    public virtual bool get_IsTruncated();
    public abstract virtual int get_Length();
    public abstract virtual int get_TrailingWhitespaceLength();
    public abstract virtual int get_DependentLength();
    public abstract virtual int get_NewlineLength();
    public abstract virtual double get_Start();
    public abstract virtual double get_Width();
    public abstract virtual double get_WidthIncludingTrailingWhitespace();
    public abstract virtual double get_Height();
    public abstract virtual double get_TextHeight();
    public abstract virtual double get_Extent();
    public abstract virtual double get_Baseline();
    public abstract virtual double get_TextBaseline();
    public abstract virtual double get_MarkerBaseline();
    public abstract virtual double get_MarkerHeight();
    public abstract virtual double get_OverhangLeading();
    public abstract virtual double get_OverhangTrailing();
    public abstract virtual double get_OverhangAfter();
    public abstract virtual void Dispose();
    public abstract virtual void Draw(DrawingContext drawingContext, Point origin, InvertAxes inversion);
    public abstract virtual TextLine Collapse(TextCollapsingProperties[] collapsingPropertiesList);
    public abstract virtual IList`1<TextCollapsedRange> GetTextCollapsedRanges();
    public abstract virtual CharacterHit GetCharacterHitFromDistance(double distance);
    public abstract virtual double GetDistanceFromCharacterHit(CharacterHit characterHit);
    public abstract virtual CharacterHit GetNextCaretCharacterHit(CharacterHit characterHit);
    public abstract virtual CharacterHit GetPreviousCaretCharacterHit(CharacterHit characterHit);
    public abstract virtual CharacterHit GetBackspaceCaretCharacterHit(CharacterHit characterHit);
    public abstract virtual IList`1<TextBounds> GetTextBounds(int firstTextSourceCharacterIndex, int textLength);
    public abstract virtual IList`1<TextSpan`1<TextRun>> GetTextRunSpans();
    public abstract virtual IEnumerable`1<IndexedGlyphRun> GetIndexedGlyphRuns();
    public abstract virtual TextLineBreak GetTextLineBreak();
}
public class System.Windows.Media.TextFormatting.TextLineBreak : object {
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
public TextLineBreak Clone();
}
public abstract class System.Windows.Media.TextFormatting.TextMarkerProperties : object {
    public double Offset { get; }
    public TextSource TextSource { get; }
    public abstract virtual double get_Offset();
    public abstract virtual TextSource get_TextSource();
}
public abstract class System.Windows.Media.TextFormatting.TextModifier : TextRun {
    public CharacterBufferReference CharacterBufferReference { get; }
    public bool HasDirectionalEmbedding { get; }
    public FlowDirection FlowDirection { get; }
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public abstract virtual bool get_HasDirectionalEmbedding();
    public abstract virtual FlowDirection get_FlowDirection();
    public abstract virtual TextRunProperties ModifyProperties(TextRunProperties properties);
}
public abstract class System.Windows.Media.TextFormatting.TextParagraphProperties : object {
    public FlowDirection FlowDirection { get; }
    public TextAlignment TextAlignment { get; }
    public double LineHeight { get; }
    public bool FirstLineInParagraph { get; }
    public bool AlwaysCollapsible { get; }
    public TextRunProperties DefaultTextRunProperties { get; }
    public TextDecorationCollection TextDecorations { get; }
    public TextWrapping TextWrapping { get; }
    public TextMarkerProperties TextMarkerProperties { get; }
    public double Indent { get; }
    public double ParagraphIndent { get; }
    public double DefaultIncrementalTab { get; }
    public IList`1<TextTabProperties> Tabs { get; }
    public abstract virtual FlowDirection get_FlowDirection();
    public abstract virtual TextAlignment get_TextAlignment();
    public abstract virtual double get_LineHeight();
    public abstract virtual bool get_FirstLineInParagraph();
    public virtual bool get_AlwaysCollapsible();
    public abstract virtual TextRunProperties get_DefaultTextRunProperties();
    public virtual TextDecorationCollection get_TextDecorations();
    public abstract virtual TextWrapping get_TextWrapping();
    public abstract virtual TextMarkerProperties get_TextMarkerProperties();
    public abstract virtual double get_Indent();
    public virtual double get_ParagraphIndent();
    public virtual double get_DefaultIncrementalTab();
    public virtual IList`1<TextTabProperties> get_Tabs();
}
public abstract class System.Windows.Media.TextFormatting.TextRun : object {
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public abstract virtual CharacterBufferReference get_CharacterBufferReference();
    public abstract virtual int get_Length();
    public abstract virtual TextRunProperties get_Properties();
}
public class System.Windows.Media.TextFormatting.TextRunBounds : object {
    public int TextSourceCharacterIndex { get; }
    public int Length { get; }
    public Rect Rectangle { get; }
    public TextRun TextRun { get; }
    internal TextRunBounds(Rect bounds, int cpFirst, int cpEnd, TextRun textRun);
    public int get_TextSourceCharacterIndex();
    public int get_Length();
    public Rect get_Rectangle();
    public TextRun get_TextRun();
}
public class System.Windows.Media.TextFormatting.TextRunCache : object {
    public void Change(int textSourceCharacterIndex, int addition, int removal);
    public void Invalidate();
}
public abstract class System.Windows.Media.TextFormatting.TextRunProperties : object {
    public Typeface Typeface { get; }
    public double FontRenderingEmSize { get; }
    public double FontHintingEmSize { get; }
    public TextDecorationCollection TextDecorations { get; }
    public Brush ForegroundBrush { get; }
    public Brush BackgroundBrush { get; }
    public CultureInfo CultureInfo { get; }
    public TextEffectCollection TextEffects { get; }
    public BaselineAlignment BaselineAlignment { get; }
    public TextRunTypographyProperties TypographyProperties { get; }
    public NumberSubstitution NumberSubstitution { get; }
    public abstract virtual Typeface get_Typeface();
    public abstract virtual double get_FontRenderingEmSize();
    public abstract virtual double get_FontHintingEmSize();
    public abstract virtual TextDecorationCollection get_TextDecorations();
    public abstract virtual Brush get_ForegroundBrush();
    public abstract virtual Brush get_BackgroundBrush();
    public abstract virtual CultureInfo get_CultureInfo();
    public abstract virtual TextEffectCollection get_TextEffects();
    public virtual BaselineAlignment get_BaselineAlignment();
    public virtual TextRunTypographyProperties get_TypographyProperties();
    public virtual NumberSubstitution get_NumberSubstitution();
}
public abstract class System.Windows.Media.TextFormatting.TextRunTypographyProperties : object {
    public bool StandardLigatures { get; }
    public bool ContextualLigatures { get; }
    public bool DiscretionaryLigatures { get; }
    public bool HistoricalLigatures { get; }
    public bool ContextualAlternates { get; }
    public bool HistoricalForms { get; }
    public bool Kerning { get; }
    public bool CapitalSpacing { get; }
    public bool CaseSensitiveForms { get; }
    public bool StylisticSet1 { get; }
    public bool StylisticSet2 { get; }
    public bool StylisticSet3 { get; }
    public bool StylisticSet4 { get; }
    public bool StylisticSet5 { get; }
    public bool StylisticSet6 { get; }
    public bool StylisticSet7 { get; }
    public bool StylisticSet8 { get; }
    public bool StylisticSet9 { get; }
    public bool StylisticSet10 { get; }
    public bool StylisticSet11 { get; }
    public bool StylisticSet12 { get; }
    public bool StylisticSet13 { get; }
    public bool StylisticSet14 { get; }
    public bool StylisticSet15 { get; }
    public bool StylisticSet16 { get; }
    public bool StylisticSet17 { get; }
    public bool StylisticSet18 { get; }
    public bool StylisticSet19 { get; }
    public bool StylisticSet20 { get; }
    public bool SlashedZero { get; }
    public bool MathematicalGreek { get; }
    public bool EastAsianExpertForms { get; }
    public FontVariants Variants { get; }
    public FontCapitals Capitals { get; }
    public FontFraction Fraction { get; }
    public FontNumeralStyle NumeralStyle { get; }
    public FontNumeralAlignment NumeralAlignment { get; }
    public FontEastAsianWidths EastAsianWidths { get; }
    public FontEastAsianLanguage EastAsianLanguage { get; }
    public int StandardSwashes { get; }
    public int ContextualSwashes { get; }
    public int StylisticAlternates { get; }
    public int AnnotationAlternates { get; }
    public abstract virtual bool get_StandardLigatures();
    public abstract virtual bool get_ContextualLigatures();
    public abstract virtual bool get_DiscretionaryLigatures();
    public abstract virtual bool get_HistoricalLigatures();
    public abstract virtual bool get_ContextualAlternates();
    public abstract virtual bool get_HistoricalForms();
    public abstract virtual bool get_Kerning();
    public abstract virtual bool get_CapitalSpacing();
    public abstract virtual bool get_CaseSensitiveForms();
    public abstract virtual bool get_StylisticSet1();
    public abstract virtual bool get_StylisticSet2();
    public abstract virtual bool get_StylisticSet3();
    public abstract virtual bool get_StylisticSet4();
    public abstract virtual bool get_StylisticSet5();
    public abstract virtual bool get_StylisticSet6();
    public abstract virtual bool get_StylisticSet7();
    public abstract virtual bool get_StylisticSet8();
    public abstract virtual bool get_StylisticSet9();
    public abstract virtual bool get_StylisticSet10();
    public abstract virtual bool get_StylisticSet11();
    public abstract virtual bool get_StylisticSet12();
    public abstract virtual bool get_StylisticSet13();
    public abstract virtual bool get_StylisticSet14();
    public abstract virtual bool get_StylisticSet15();
    public abstract virtual bool get_StylisticSet16();
    public abstract virtual bool get_StylisticSet17();
    public abstract virtual bool get_StylisticSet18();
    public abstract virtual bool get_StylisticSet19();
    public abstract virtual bool get_StylisticSet20();
    public abstract virtual bool get_SlashedZero();
    public abstract virtual bool get_MathematicalGreek();
    public abstract virtual bool get_EastAsianExpertForms();
    public abstract virtual FontVariants get_Variants();
    public abstract virtual FontCapitals get_Capitals();
    public abstract virtual FontFraction get_Fraction();
    public abstract virtual FontNumeralStyle get_NumeralStyle();
    public abstract virtual FontNumeralAlignment get_NumeralAlignment();
    public abstract virtual FontEastAsianWidths get_EastAsianWidths();
    public abstract virtual FontEastAsianLanguage get_EastAsianLanguage();
    public abstract virtual int get_StandardSwashes();
    public abstract virtual int get_ContextualSwashes();
    public abstract virtual int get_StylisticAlternates();
    public abstract virtual int get_AnnotationAlternates();
    protected void OnPropertiesChanged();
}
public class System.Windows.Media.TextFormatting.TextSimpleMarkerProperties : TextMarkerProperties {
    public double Offset { get; }
    public TextSource TextSource { get; }
    public TextSimpleMarkerProperties(TextMarkerStyle style, double offset, int autoNumberingIndex, TextParagraphProperties textParagraphProperties);
    public sealed virtual double get_Offset();
    public sealed virtual TextSource get_TextSource();
}
public abstract class System.Windows.Media.TextFormatting.TextSource : object {
    public abstract virtual TextRun GetTextRun(int textSourceCharacterIndex);
    public abstract virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int textSourceCharacterIndexLimit);
    public abstract virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int textSourceCharacterIndex);
}
public class System.Windows.Media.TextFormatting.TextSpan`1 : object {
    public int Length { get; }
    public T Value { get; }
    public TextSpan`1(int length, T value);
    public int get_Length();
    public T get_Value();
}
public enum System.Windows.Media.TextFormatting.TextTabAlignment : Enum {
    public int value__;
    public static TextTabAlignment Left;
    public static TextTabAlignment Center;
    public static TextTabAlignment Right;
    public static TextTabAlignment Character;
}
public class System.Windows.Media.TextFormatting.TextTabProperties : object {
    public TextTabAlignment Alignment { get; }
    public double Location { get; }
    public int TabLeader { get; }
    public int AligningCharacter { get; }
    public TextTabProperties(TextTabAlignment alignment, double location, int tabLeader, int aligningChar);
    public TextTabAlignment get_Alignment();
    public double get_Location();
    public int get_TabLeader();
    public int get_AligningCharacter();
}
public class System.Windows.Media.TextFormatting.TextTrailingCharacterEllipsis : TextCollapsingProperties {
    public double Width { get; }
    public TextRun Symbol { get; }
    public TextCollapsingStyle Style { get; }
    public TextTrailingCharacterEllipsis(double width, TextRunProperties textRunProperties);
    public sealed virtual double get_Width();
    public sealed virtual TextRun get_Symbol();
    public sealed virtual TextCollapsingStyle get_Style();
}
public class System.Windows.Media.TextFormatting.TextTrailingWordEllipsis : TextCollapsingProperties {
    public double Width { get; }
    public TextRun Symbol { get; }
    public TextCollapsingStyle Style { get; }
    public TextTrailingWordEllipsis(double width, TextRunProperties textRunProperties);
    public sealed virtual double get_Width();
    public sealed virtual TextRun get_Symbol();
    public sealed virtual TextCollapsingStyle get_Style();
}
public enum System.Windows.Media.TextFormattingMode : Enum {
    public int value__;
    public static TextFormattingMode Ideal;
    public static TextFormattingMode Display;
}
public enum System.Windows.Media.TextHintingMode : Enum {
    public int value__;
    public static TextHintingMode Auto;
    public static TextHintingMode Fixed;
    public static TextHintingMode Animated;
}
public enum System.Windows.Media.TextRenderingMode : Enum {
    public int value__;
    public static TextRenderingMode Auto;
    public static TextRenderingMode Aliased;
    public static TextRenderingMode Grayscale;
    public static TextRenderingMode ClearType;
}
public abstract class System.Windows.Media.TileBrush : Brush {
    public static DependencyProperty ViewportUnitsProperty;
    public static DependencyProperty ViewboxUnitsProperty;
    public static DependencyProperty ViewportProperty;
    public static DependencyProperty ViewboxProperty;
    public static DependencyProperty StretchProperty;
    public static DependencyProperty TileModeProperty;
    public static DependencyProperty AlignmentXProperty;
    public static DependencyProperty AlignmentYProperty;
    public BrushMappingMode ViewportUnits { get; public set; }
    public BrushMappingMode ViewboxUnits { get; public set; }
    public Rect Viewport { get; public set; }
    public Rect Viewbox { get; public set; }
    public Stretch Stretch { get; public set; }
    public TileMode TileMode { get; public set; }
    public AlignmentX AlignmentX { get; public set; }
    public AlignmentY AlignmentY { get; public set; }
    public BrushMappingMode get_ViewportUnits();
    public void set_ViewportUnits(BrushMappingMode value);
    public BrushMappingMode get_ViewboxUnits();
    public void set_ViewboxUnits(BrushMappingMode value);
    public Rect get_Viewport();
    public void set_Viewport(Rect value);
    public Rect get_Viewbox();
    public void set_Viewbox(Rect value);
    public Stretch get_Stretch();
    public void set_Stretch(Stretch value);
    public TileMode get_TileMode();
    public void set_TileMode(TileMode value);
    public AlignmentX get_AlignmentX();
    public void set_AlignmentX(AlignmentX value);
    public AlignmentY get_AlignmentY();
    public void set_AlignmentY(AlignmentY value);
    public TileBrush Clone();
    public TileBrush CloneCurrentValue();
    protected abstract virtual void GetContentBounds(Rect& contentBounds);
}
public enum System.Windows.Media.TileMode : Enum {
    public int value__;
    public static TileMode None;
    public static TileMode FlipX;
    public static TileMode FlipY;
    public static TileMode FlipXY;
    public static TileMode Tile;
}
public enum System.Windows.Media.ToleranceType : Enum {
    public int value__;
    public static ToleranceType Absolute;
    public static ToleranceType Relative;
}
[ValueSerializerAttribute("System.Windows.Media.Converters.TransformValueSerializer")]
[LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.Media.TransformConverter")]
public abstract class System.Windows.Media.Transform : GeneralTransform {
    public static Transform Identity { get; }
    public Matrix Value { get; }
    public GeneralTransform Inverse { get; }
    public static Transform get_Identity();
    public abstract virtual Matrix get_Value();
    public virtual GeneralTransform get_Inverse();
    public Transform Clone();
    public Transform CloneCurrentValue();
    public static Transform Parse(string source);
    public virtual bool TryTransform(Point inPoint, Point& result);
    public virtual Rect TransformBounds(Rect rect);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.TransformCollection : Animatable {
    public Transform Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Transform>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public TransformCollection(int capacity);
    public TransformCollection(IEnumerable`1<Transform> collection);
    public sealed virtual Transform get_Item(int index);
    public sealed virtual void set_Item(int index, Transform value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Transform>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public TransformCollection Clone();
    public TransformCollection CloneCurrentValue();
    public sealed virtual void Add(Transform value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Transform value);
    public sealed virtual int IndexOf(Transform value);
    public sealed virtual void Insert(int index, Transform value);
    public sealed virtual bool Remove(Transform value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(Transform[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Transform> System.Collections.Generic.IEnumerable<System.Windows.Media.Transform>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
public class System.Windows.Media.TransformConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.TransformGroup : Transform {
    public static DependencyProperty ChildrenProperty;
    public TransformCollection Children { get; public set; }
    public Matrix Value { get; }
    public TransformCollection get_Children();
    public void set_Children(TransformCollection value);
    public virtual Matrix get_Value();
    public TransformGroup Clone();
    public TransformGroup CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.TranslateTransform : Transform {
    public static DependencyProperty XProperty;
    public static DependencyProperty YProperty;
    public double X { get; public set; }
    public double Y { get; public set; }
    public Matrix Value { get; }
    public TranslateTransform(double offsetX, double offsetY);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual Matrix get_Value();
    public TranslateTransform Clone();
    public TranslateTransform CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Typeface : object {
    public FontFamily FontFamily { get; }
    public FontWeight Weight { get; }
    public FontStyle Style { get; }
    public FontStretch Stretch { get; }
    public bool IsObliqueSimulated { get; }
    public bool IsBoldSimulated { get; }
    public double XHeight { get; }
    public double CapsHeight { get; }
    public double UnderlinePosition { get; }
    public double UnderlineThickness { get; }
    public double StrikethroughPosition { get; }
    public double StrikethroughThickness { get; }
    public LanguageSpecificStringDictionary FaceNames { get; }
    public Typeface(string typefaceName);
    public Typeface(FontFamily fontFamily, FontStyle style, FontWeight weight, FontStretch stretch);
    public Typeface(FontFamily fontFamily, FontStyle style, FontWeight weight, FontStretch stretch, FontFamily fallbackFontFamily);
    public FontFamily get_FontFamily();
    public FontWeight get_Weight();
    public FontStyle get_Style();
    public FontStretch get_Stretch();
    public bool get_IsObliqueSimulated();
    public bool get_IsBoldSimulated();
    public double get_XHeight();
    public double get_CapsHeight();
    public double get_UnderlinePosition();
    public double get_UnderlineThickness();
    public double get_StrikethroughPosition();
    public double get_StrikethroughThickness();
    public LanguageSpecificStringDictionary get_FaceNames();
    public bool TryGetGlyphTypeface(GlyphTypeface& glyphTypeface);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
[DefaultMemberAttribute("Item")]
[ValueSerializerAttribute("System.Windows.Media.Converters.VectorCollectionValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.VectorCollectionConverter")]
public class System.Windows.Media.VectorCollection : Freezable {
    public Vector Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Vector>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public VectorCollection(int capacity);
    public VectorCollection(IEnumerable`1<Vector> collection);
    public sealed virtual Vector get_Item(int index);
    public sealed virtual void set_Item(int index, Vector value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Vector>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public VectorCollection Clone();
    public VectorCollection CloneCurrentValue();
    public sealed virtual void Add(Vector value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Vector value);
    public sealed virtual int IndexOf(Vector value);
    public sealed virtual void Insert(int index, Vector value);
    public sealed virtual bool Remove(Vector value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(Vector[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Vector> System.Collections.Generic.IEnumerable<System.Windows.Vector>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public static VectorCollection Parse(string source);
}
public class System.Windows.Media.VectorCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.VideoDrawing : Drawing {
    public static DependencyProperty PlayerProperty;
    public static DependencyProperty RectProperty;
    public MediaPlayer Player { get; public set; }
    public Rect Rect { get; public set; }
    public MediaPlayer get_Player();
    public void set_Player(MediaPlayer value);
    public Rect get_Rect();
    public void set_Rect(Rect value);
    public VideoDrawing Clone();
    public VideoDrawing CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.Visual : DependencyObject {
    protected int VisualChildrenCount { get; }
    protected DependencyObject VisualParent { get; }
    protected internal Transform VisualTransform { get; protected set; }
    protected internal Effect VisualEffect { get; protected set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected internal BitmapEffect VisualBitmapEffect { get; protected set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected internal BitmapEffectInput VisualBitmapEffectInput { get; protected set; }
    protected internal CacheMode VisualCacheMode { get; protected set; }
    protected internal Nullable`1<Rect> VisualScrollableAreaClip { get; protected set; }
    protected internal Geometry VisualClip { get; protected set; }
    protected internal Vector VisualOffset { get; protected set; }
    protected internal double VisualOpacity { get; protected set; }
    protected internal EdgeMode VisualEdgeMode { get; protected set; }
    protected internal BitmapScalingMode VisualBitmapScalingMode { get; protected set; }
    protected internal ClearTypeHint VisualClearTypeHint { get; protected internal set; }
    protected internal TextRenderingMode VisualTextRenderingMode { get; protected internal set; }
    protected internal TextHintingMode VisualTextHintingMode { get; protected internal set; }
    protected internal Brush VisualOpacityMask { get; protected set; }
    protected internal DoubleCollection VisualXSnappingGuidelines { get; protected set; }
    protected internal DoubleCollection VisualYSnappingGuidelines { get; protected set; }
    protected virtual int get_VisualChildrenCount();
    protected DependencyObject get_VisualParent();
    protected internal Transform get_VisualTransform();
    protected void set_VisualTransform(Transform value);
    protected internal Effect get_VisualEffect();
    protected void set_VisualEffect(Effect value);
    protected internal BitmapEffect get_VisualBitmapEffect();
    protected void set_VisualBitmapEffect(BitmapEffect value);
    protected internal BitmapEffectInput get_VisualBitmapEffectInput();
    protected void set_VisualBitmapEffectInput(BitmapEffectInput value);
    protected internal CacheMode get_VisualCacheMode();
    protected void set_VisualCacheMode(CacheMode value);
    protected internal Nullable`1<Rect> get_VisualScrollableAreaClip();
    protected void set_VisualScrollableAreaClip(Nullable`1<Rect> value);
    protected internal Geometry get_VisualClip();
    protected void set_VisualClip(Geometry value);
    protected internal Vector get_VisualOffset();
    protected void set_VisualOffset(Vector value);
    protected internal double get_VisualOpacity();
    protected void set_VisualOpacity(double value);
    protected internal EdgeMode get_VisualEdgeMode();
    protected void set_VisualEdgeMode(EdgeMode value);
    protected internal BitmapScalingMode get_VisualBitmapScalingMode();
    protected void set_VisualBitmapScalingMode(BitmapScalingMode value);
    protected internal ClearTypeHint get_VisualClearTypeHint();
    protected internal void set_VisualClearTypeHint(ClearTypeHint value);
    protected internal TextRenderingMode get_VisualTextRenderingMode();
    protected internal void set_VisualTextRenderingMode(TextRenderingMode value);
    protected internal TextHintingMode get_VisualTextHintingMode();
    protected internal void set_VisualTextHintingMode(TextHintingMode value);
    protected internal Brush get_VisualOpacityMask();
    protected void set_VisualOpacityMask(Brush value);
    protected internal DoubleCollection get_VisualXSnappingGuidelines();
    protected void set_VisualXSnappingGuidelines(DoubleCollection value);
    protected internal DoubleCollection get_VisualYSnappingGuidelines();
    protected void set_VisualYSnappingGuidelines(DoubleCollection value);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    protected virtual Visual GetVisualChild(int index);
    protected void AddVisualChild(Visual child);
    protected void RemoveVisualChild(Visual child);
    protected virtual void OnVisualParentChanged(DependencyObject oldParent);
    protected virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    public bool IsAncestorOf(DependencyObject descendant);
    public bool IsDescendantOf(DependencyObject ancestor);
    public DependencyObject FindCommonVisualAncestor(DependencyObject otherVisual);
    public GeneralTransform TransformToAncestor(Visual ancestor);
    public GeneralTransform2DTo3D TransformToAncestor(Visual3D ancestor);
    public GeneralTransform TransformToDescendant(Visual descendant);
    public GeneralTransform TransformToVisual(Visual visual);
    public Point PointToScreen(Point point);
    public Point PointFromScreen(Point point);
}
public class System.Windows.Media.VisualBrush : TileBrush {
    public static DependencyProperty VisualProperty;
    public static DependencyProperty AutoLayoutContentProperty;
    public Visual Visual { get; public set; }
    public bool AutoLayoutContent { get; public set; }
    public VisualBrush(Visual visual);
    public Visual get_Visual();
    public void set_Visual(Visual value);
    public bool get_AutoLayoutContent();
    public void set_AutoLayoutContent(bool value);
    public VisualBrush Clone();
    public VisualBrush CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void GetContentBounds(Rect& contentBounds);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.VisualCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Capacity { get; public set; }
    public Visual Item { get; public set; }
    public VisualCollection(Visual parent);
    public sealed virtual int get_Count();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public int get_Capacity();
    public void set_Capacity(int value);
    public Visual get_Item(int index);
    public void set_Item(int index, Visual value);
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(Visual[] array, int index);
    public int Add(Visual visual);
    public int IndexOf(Visual visual);
    public void Remove(Visual visual);
    public bool Contains(Visual visual);
    public void Clear();
    public void Insert(int index, Visual visual);
    public void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator GetEnumerator();
}
public class System.Windows.Media.VisualTarget : CompositionTarget {
    public Matrix TransformToDevice { get; }
    public Matrix TransformFromDevice { get; }
    public VisualTarget(HostVisual hostVisual);
    public virtual Matrix get_TransformToDevice();
    public virtual Matrix get_TransformFromDevice();
    [SecurityCriticalAttribute]
public virtual void Dispose();
}
public static class System.Windows.Media.VisualTreeHelper : object {
    public static int GetChildrenCount(DependencyObject reference);
    public static DependencyObject GetChild(DependencyObject reference, int childIndex);
    public static DependencyObject GetParent(DependencyObject reference);
    public static Geometry GetClip(Visual reference);
    public static double GetOpacity(Visual reference);
    public static Brush GetOpacityMask(Visual reference);
    public static Vector GetOffset(Visual reference);
    public static Transform GetTransform(Visual reference);
    public static DoubleCollection GetXSnappingGuidelines(Visual reference);
    public static DoubleCollection GetYSnappingGuidelines(Visual reference);
    public static DrawingGroup GetDrawing(Visual reference);
    public static Rect GetContentBounds(Visual reference);
    public static Rect3D GetContentBounds(Visual3D reference);
    public static Rect GetDescendantBounds(Visual reference);
    public static Rect3D GetDescendantBounds(Visual3D reference);
    public static BitmapEffect GetBitmapEffect(Visual reference);
    public static BitmapEffectInput GetBitmapEffectInput(Visual reference);
    public static Effect GetEffect(Visual reference);
    public static CacheMode GetCacheMode(Visual reference);
    public static EdgeMode GetEdgeMode(Visual reference);
    public static HitTestResult HitTest(Visual reference, Point point);
    public static void HitTest(Visual reference, HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters hitTestParameters);
    public static void HitTest(Visual3D reference, HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters3D hitTestParameters);
}
public enum System.Windows.Modifiability : Enum {
    public int value__;
    public static Modifiability Unmodifiable;
    public static Modifiability Modifiable;
    public static Modifiability Inherit;
}
public static class System.Windows.Navigation.BaseUriHelper : object {
    public static DependencyProperty BaseUriProperty;
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static BaseUriHelper();
    [SecurityCriticalAttribute]
public static Uri GetBaseUri(DependencyObject element);
}
public abstract class System.Windows.PresentationSource : DispatcherObject {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler ContentRendered;
    public CompositionTarget CompositionTarget { get; }
    public Visual RootVisual { get; public set; }
    public bool IsDisposed { get; }
    public static IEnumerable CurrentSources { get; }
    [SecurityCriticalAttribute]
private static PresentationSource();
    [SecurityCriticalAttribute]
public CompositionTarget get_CompositionTarget();
    public abstract virtual Visual get_RootVisual();
    [SecurityCriticalAttribute]
public abstract virtual void set_RootVisual(Visual value);
    public abstract virtual bool get_IsDisposed();
    [SecurityCriticalAttribute]
public static IEnumerable get_CurrentSources();
    [CompilerGeneratedAttribute]
public void add_ContentRendered(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ContentRendered(EventHandler value);
    [SecurityCriticalAttribute]
public static PresentationSource FromVisual(Visual visual);
    [SecurityCriticalAttribute]
public static PresentationSource FromDependencyObject(DependencyObject dependencyObject);
    [SecurityCriticalAttribute]
public static void AddSourceChangedHandler(IInputElement element, SourceChangedEventHandler handler);
    public static void RemoveSourceChangedHandler(IInputElement e, SourceChangedEventHandler handler);
    protected abstract virtual CompositionTarget GetCompositionTargetCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected void RootChanged(Visual oldRoot, Visual newRoot);
    protected void AddSource();
    protected void RemoveSource();
    protected void ClearContentRenderedListeners();
}
public class System.Windows.QueryContinueDragEventArgs : RoutedEventArgs {
    public bool EscapePressed { get; }
    public DragDropKeyStates KeyStates { get; }
    public DragAction Action { get; public set; }
    internal QueryContinueDragEventArgs(bool escapePressed, DragDropKeyStates dragDropKeyStates);
    public bool get_EscapePressed();
    public DragDropKeyStates get_KeyStates();
    public DragAction get_Action();
    public void set_Action(DragAction value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.QueryContinueDragEventHandler : MulticastDelegate {
    public QueryContinueDragEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, QueryContinueDragEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, QueryContinueDragEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Readability : Enum {
    public int value__;
    public static Readability Unreadable;
    public static Readability Readable;
    public static Readability Inherit;
}
[AttributeUsageAttribute("1")]
public class System.Windows.Resources.AssemblyAssociatedContentFileAttribute : Attribute {
    public string RelativeContentFilePath { get; }
    public AssemblyAssociatedContentFileAttribute(string relativeContentFilePath);
    public string get_RelativeContentFilePath();
}
[TypeConverterAttribute("System.Windows.Markup.RoutedEventConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[ValueSerializerAttribute("System.Windows.Markup.RoutedEventValueSerializer, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.RoutedEvent : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private RoutingStrategy <RoutingStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Type <HandlerType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Type <OwnerType>k__BackingField;
    public string Name { get; private set; }
    public RoutingStrategy RoutingStrategy { get; private set; }
    public Type HandlerType { get; private set; }
    public Type OwnerType { get; private set; }
    internal RoutedEvent(string name, RoutingStrategy routingStrategy, Type handlerType, Type ownerType);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public RoutingStrategy get_RoutingStrategy();
    [CompilerGeneratedAttribute]
private void set_RoutingStrategy(RoutingStrategy value);
    [CompilerGeneratedAttribute]
public Type get_HandlerType();
    [CompilerGeneratedAttribute]
private void set_HandlerType(Type value);
    [CompilerGeneratedAttribute]
public Type get_OwnerType();
    [CompilerGeneratedAttribute]
private void set_OwnerType(Type value);
    public RoutedEvent AddOwner(Type ownerType);
    public virtual string ToString();
}
public class System.Windows.RoutedEventArgs : EventArgs {
    public RoutedEvent RoutedEvent { get; public set; }
    public bool Handled { get; public set; }
    public object Source { get; public set; }
    public object OriginalSource { get; }
    public RoutedEventArgs(RoutedEvent routedEvent);
    public RoutedEventArgs(RoutedEvent routedEvent, object source);
    public RoutedEvent get_RoutedEvent();
    public void set_RoutedEvent(RoutedEvent value);
    [SecurityCriticalAttribute]
public bool get_Handled();
    [SecurityCriticalAttribute]
public void set_Handled(bool value);
    public object get_Source();
    public void set_Source(object value);
    public object get_OriginalSource();
    protected virtual void OnSetSource(object source);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.RoutedEventHandler : MulticastDelegate {
    public RoutedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RoutedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RoutedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.RoutedEventHandlerInfo : ValueType {
    private Delegate _handler;
    private bool _handledEventsToo;
    public Delegate Handler { get; }
    public bool InvokeHandledEventsToo { get; }
    internal RoutedEventHandlerInfo(Delegate handler, bool handledEventsToo);
    public Delegate get_Handler();
    public bool get_InvokeHandledEventsToo();
    public static bool op_Equality(RoutedEventHandlerInfo handlerInfo1, RoutedEventHandlerInfo handlerInfo2);
    public static bool op_Inequality(RoutedEventHandlerInfo handlerInfo1, RoutedEventHandlerInfo handlerInfo2);
    public virtual bool Equals(object obj);
    public bool Equals(RoutedEventHandlerInfo handlerInfo);
    public virtual int GetHashCode();
}
public enum System.Windows.RoutingStrategy : Enum {
    public int value__;
    public static RoutingStrategy Tunnel;
    public static RoutingStrategy Bubble;
    public static RoutingStrategy Direct;
}
public class System.Windows.SizeChangedInfo : object {
    public Size PreviousSize { get; }
    public Size NewSize { get; }
    public bool WidthChanged { get; }
    public bool HeightChanged { get; }
    public SizeChangedInfo(UIElement element, Size previousSize, bool widthChanged, bool heightChanged);
    public Size get_PreviousSize();
    public Size get_NewSize();
    public bool get_WidthChanged();
    public bool get_HeightChanged();
}
[LocalizabilityAttribute("0")]
public enum System.Windows.SizeToContent : Enum {
    public int value__;
    public static SizeToContent Manual;
    public static SizeToContent Width;
    public static SizeToContent Height;
    public static SizeToContent WidthAndHeight;
}
public class System.Windows.SourceChangedEventArgs : RoutedEventArgs {
    public PresentationSource OldSource { get; }
    public PresentationSource NewSource { get; }
    public IInputElement Element { get; }
    public IInputElement OldParent { get; }
    [SecurityCriticalAttribute]
public SourceChangedEventArgs(PresentationSource oldSource, PresentationSource newSource);
    [SecurityCriticalAttribute]
public SourceChangedEventArgs(PresentationSource oldSource, PresentationSource newSource, IInputElement element, IInputElement oldParent);
    [SecurityCriticalAttribute]
public PresentationSource get_OldSource();
    [SecurityCriticalAttribute]
public PresentationSource get_NewSource();
    public IInputElement get_Element();
    public IInputElement get_OldParent();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.SourceChangedEventHandler : MulticastDelegate {
    public SourceChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SourceChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SourceChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.StrokeCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
[LocalizabilityAttribute("0")]
public enum System.Windows.TextAlignment : Enum {
    public int value__;
    public static TextAlignment Left;
    public static TextAlignment Right;
    public static TextAlignment Center;
    public static TextAlignment Justify;
}
public enum System.Windows.TextDataFormat : Enum {
    public int value__;
    public static TextDataFormat Text;
    public static TextDataFormat UnicodeText;
    public static TextDataFormat Rtf;
    public static TextDataFormat Html;
    public static TextDataFormat CommaSeparatedValue;
    public static TextDataFormat Xaml;
}
[LocalizabilityAttribute("0")]
public class System.Windows.TextDecoration : Animatable {
    public static DependencyProperty PenProperty;
    public static DependencyProperty PenOffsetProperty;
    public static DependencyProperty PenOffsetUnitProperty;
    public static DependencyProperty PenThicknessUnitProperty;
    public static DependencyProperty LocationProperty;
    public Pen Pen { get; public set; }
    public double PenOffset { get; public set; }
    public TextDecorationUnit PenOffsetUnit { get; public set; }
    public TextDecorationUnit PenThicknessUnit { get; public set; }
    public TextDecorationLocation Location { get; public set; }
    public TextDecoration(TextDecorationLocation location, Pen pen, double penOffset, TextDecorationUnit penOffsetUnit, TextDecorationUnit penThicknessUnit);
    public Pen get_Pen();
    public void set_Pen(Pen value);
    public double get_PenOffset();
    public void set_PenOffset(double value);
    public TextDecorationUnit get_PenOffsetUnit();
    public void set_PenOffsetUnit(TextDecorationUnit value);
    public TextDecorationUnit get_PenThicknessUnit();
    public void set_PenThicknessUnit(TextDecorationUnit value);
    public TextDecorationLocation get_Location();
    public void set_Location(TextDecorationLocation value);
    public TextDecoration Clone();
    public TextDecoration CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.TextDecorationCollectionConverter")]
[LocalizabilityAttribute("0")]
public class System.Windows.TextDecorationCollection : Animatable {
    public TextDecoration Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.TextDecoration>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public TextDecorationCollection(int capacity);
    public TextDecorationCollection(IEnumerable`1<TextDecoration> collection);
    public sealed virtual TextDecoration get_Item(int index);
    public sealed virtual void set_Item(int index, TextDecoration value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.TextDecoration>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [CLSCompliantAttribute("False")]
public void Add(IEnumerable`1<TextDecoration> textDecorations);
    public TextDecorationCollection Clone();
    public TextDecorationCollection CloneCurrentValue();
    public sealed virtual void Add(TextDecoration value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TextDecoration value);
    public sealed virtual int IndexOf(TextDecoration value);
    public sealed virtual void Insert(int index, TextDecoration value);
    public sealed virtual bool Remove(TextDecoration value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(TextDecoration[] array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<TextDecoration> System.Collections.Generic.IEnumerable<System.Windows.TextDecoration>.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
public class System.Windows.TextDecorationCollectionConverter : TypeConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object input);
    public static TextDecorationCollection ConvertFromString(string text);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.TextDecorationLocation : Enum {
    public int value__;
    public static TextDecorationLocation Underline;
    public static TextDecorationLocation OverLine;
    public static TextDecorationLocation Strikethrough;
    public static TextDecorationLocation Baseline;
}
public static class System.Windows.TextDecorations : object {
    public static TextDecorationCollection Underline { get; }
    public static TextDecorationCollection Strikethrough { get; }
    public static TextDecorationCollection OverLine { get; }
    public static TextDecorationCollection Baseline { get; }
    public static TextDecorationCollection get_Underline();
    public static TextDecorationCollection get_Strikethrough();
    public static TextDecorationCollection get_OverLine();
    public static TextDecorationCollection get_Baseline();
}
public enum System.Windows.TextDecorationUnit : Enum {
    public int value__;
    public static TextDecorationUnit FontRecommended;
    public static TextDecorationUnit FontRenderingEmSize;
    public static TextDecorationUnit Pixel;
}
public enum System.Windows.TextMarkerStyle : Enum {
    public int value__;
    public static TextMarkerStyle None;
    public static TextMarkerStyle Disc;
    public static TextMarkerStyle Circle;
    public static TextMarkerStyle Square;
    public static TextMarkerStyle Box;
    public static TextMarkerStyle LowerRoman;
    public static TextMarkerStyle UpperRoman;
    public static TextMarkerStyle LowerLatin;
    public static TextMarkerStyle UpperLatin;
    public static TextMarkerStyle Decimal;
}
[LocalizabilityAttribute("0")]
public enum System.Windows.TextTrimming : Enum {
    public int value__;
    public static TextTrimming None;
    public static TextTrimming CharacterEllipsis;
    public static TextTrimming WordEllipsis;
}
[LocalizabilityAttribute("0")]
public enum System.Windows.TextWrapping : Enum {
    public int value__;
    public static TextWrapping WrapWithOverflow;
    public static TextWrapping NoWrap;
    public static TextWrapping Wrap;
}
[UidPropertyAttribute("Uid")]
public class System.Windows.UIElement : Visual {
    public static RoutedEvent PreviewMouseDownEvent;
    public static RoutedEvent MouseDownEvent;
    public static RoutedEvent PreviewMouseUpEvent;
    public static RoutedEvent MouseUpEvent;
    public static RoutedEvent PreviewMouseLeftButtonDownEvent;
    public static RoutedEvent MouseLeftButtonDownEvent;
    public static RoutedEvent PreviewMouseLeftButtonUpEvent;
    public static RoutedEvent MouseLeftButtonUpEvent;
    public static RoutedEvent PreviewMouseRightButtonDownEvent;
    public static RoutedEvent MouseRightButtonDownEvent;
    public static RoutedEvent PreviewMouseRightButtonUpEvent;
    public static RoutedEvent MouseRightButtonUpEvent;
    public static RoutedEvent PreviewMouseMoveEvent;
    public static RoutedEvent MouseMoveEvent;
    public static RoutedEvent PreviewMouseWheelEvent;
    public static RoutedEvent MouseWheelEvent;
    public static RoutedEvent MouseEnterEvent;
    public static RoutedEvent MouseLeaveEvent;
    public static RoutedEvent GotMouseCaptureEvent;
    public static RoutedEvent LostMouseCaptureEvent;
    public static RoutedEvent QueryCursorEvent;
    public static RoutedEvent PreviewStylusDownEvent;
    public static RoutedEvent StylusDownEvent;
    public static RoutedEvent PreviewStylusUpEvent;
    public static RoutedEvent StylusUpEvent;
    public static RoutedEvent PreviewStylusMoveEvent;
    public static RoutedEvent StylusMoveEvent;
    public static RoutedEvent PreviewStylusInAirMoveEvent;
    public static RoutedEvent StylusInAirMoveEvent;
    public static RoutedEvent StylusEnterEvent;
    public static RoutedEvent StylusLeaveEvent;
    public static RoutedEvent PreviewStylusInRangeEvent;
    public static RoutedEvent StylusInRangeEvent;
    public static RoutedEvent PreviewStylusOutOfRangeEvent;
    public static RoutedEvent StylusOutOfRangeEvent;
    public static RoutedEvent PreviewStylusSystemGestureEvent;
    public static RoutedEvent StylusSystemGestureEvent;
    public static RoutedEvent GotStylusCaptureEvent;
    public static RoutedEvent LostStylusCaptureEvent;
    public static RoutedEvent StylusButtonDownEvent;
    public static RoutedEvent StylusButtonUpEvent;
    public static RoutedEvent PreviewStylusButtonDownEvent;
    public static RoutedEvent PreviewStylusButtonUpEvent;
    public static RoutedEvent PreviewKeyDownEvent;
    public static RoutedEvent KeyDownEvent;
    public static RoutedEvent PreviewKeyUpEvent;
    public static RoutedEvent KeyUpEvent;
    public static RoutedEvent PreviewGotKeyboardFocusEvent;
    public static RoutedEvent GotKeyboardFocusEvent;
    public static RoutedEvent PreviewLostKeyboardFocusEvent;
    public static RoutedEvent LostKeyboardFocusEvent;
    public static RoutedEvent PreviewTextInputEvent;
    public static RoutedEvent TextInputEvent;
    public static RoutedEvent PreviewQueryContinueDragEvent;
    public static RoutedEvent QueryContinueDragEvent;
    public static RoutedEvent PreviewGiveFeedbackEvent;
    public static RoutedEvent GiveFeedbackEvent;
    public static RoutedEvent PreviewDragEnterEvent;
    public static RoutedEvent DragEnterEvent;
    public static RoutedEvent PreviewDragOverEvent;
    public static RoutedEvent DragOverEvent;
    public static RoutedEvent PreviewDragLeaveEvent;
    public static RoutedEvent DragLeaveEvent;
    public static RoutedEvent PreviewDropEvent;
    public static RoutedEvent DropEvent;
    public static RoutedEvent PreviewTouchDownEvent;
    public static RoutedEvent TouchDownEvent;
    public static RoutedEvent PreviewTouchMoveEvent;
    public static RoutedEvent TouchMoveEvent;
    public static RoutedEvent PreviewTouchUpEvent;
    public static RoutedEvent TouchUpEvent;
    public static RoutedEvent GotTouchCaptureEvent;
    public static RoutedEvent LostTouchCaptureEvent;
    public static RoutedEvent TouchEnterEvent;
    public static RoutedEvent TouchLeaveEvent;
    public static DependencyProperty IsMouseDirectlyOverProperty;
    public static DependencyProperty IsMouseOverProperty;
    public static DependencyProperty IsStylusOverProperty;
    public static DependencyProperty IsKeyboardFocusWithinProperty;
    public static DependencyProperty IsMouseCapturedProperty;
    public static DependencyProperty IsMouseCaptureWithinProperty;
    public static DependencyProperty IsStylusDirectlyOverProperty;
    public static DependencyProperty IsStylusCapturedProperty;
    public static DependencyProperty IsStylusCaptureWithinProperty;
    public static DependencyProperty IsKeyboardFocusedProperty;
    public static DependencyProperty AreAnyTouchesDirectlyOverProperty;
    public static DependencyProperty AreAnyTouchesOverProperty;
    public static DependencyProperty AreAnyTouchesCapturedProperty;
    public static DependencyProperty AreAnyTouchesCapturedWithinProperty;
    public static DependencyProperty AllowDropProperty;
    public static DependencyProperty RenderTransformProperty;
    public static DependencyProperty RenderTransformOriginProperty;
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty OpacityMaskProperty;
    public static DependencyProperty BitmapEffectProperty;
    public static DependencyProperty EffectProperty;
    public static DependencyProperty BitmapEffectInputProperty;
    public static DependencyProperty CacheModeProperty;
    public static DependencyProperty UidProperty;
    public static DependencyProperty VisibilityProperty;
    public static DependencyProperty ClipToBoundsProperty;
    public static DependencyProperty ClipProperty;
    public static DependencyProperty SnapsToDevicePixelsProperty;
    public static RoutedEvent GotFocusEvent;
    public static RoutedEvent LostFocusEvent;
    public static DependencyProperty IsFocusedProperty;
    public static DependencyProperty IsEnabledProperty;
    public static DependencyProperty IsHitTestVisibleProperty;
    public static DependencyProperty IsVisibleProperty;
    public static DependencyProperty FocusableProperty;
    public static DependencyProperty IsManipulationEnabledProperty;
    public static RoutedEvent ManipulationStartingEvent;
    public static RoutedEvent ManipulationStartedEvent;
    public static RoutedEvent ManipulationDeltaEvent;
    public static RoutedEvent ManipulationInertiaStartingEvent;
    public static RoutedEvent ManipulationBoundaryFeedbackEvent;
    public static RoutedEvent ManipulationCompletedEvent;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler PreviewMouseDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler MouseDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler PreviewMouseUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler MouseUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler PreviewMouseLeftButtonDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler MouseLeftButtonDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler PreviewMouseLeftButtonUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler MouseLeftButtonUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler PreviewMouseRightButtonDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler MouseRightButtonDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler PreviewMouseRightButtonUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler MouseRightButtonUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseEventHandler PreviewMouseMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseEventHandler MouseMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseWheelEventHandler PreviewMouseWheel;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseWheelEventHandler MouseWheel;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseEventHandler MouseEnter;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseEventHandler MouseLeave;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseEventHandler GotMouseCapture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseEventHandler LostMouseCapture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private QueryCursorEventHandler QueryCursor;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusDownEventHandler PreviewStylusDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusDownEventHandler StylusDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler PreviewStylusUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler PreviewStylusMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler PreviewStylusInAirMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusInAirMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusEnter;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusLeave;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler PreviewStylusInRange;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusInRange;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler PreviewStylusOutOfRange;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusOutOfRange;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusSystemGestureEventHandler PreviewStylusSystemGesture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusSystemGestureEventHandler StylusSystemGesture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler GotStylusCapture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler LostStylusCapture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusButtonEventHandler StylusButtonDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusButtonEventHandler StylusButtonUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusButtonEventHandler PreviewStylusButtonDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusButtonEventHandler PreviewStylusButtonUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyEventHandler PreviewKeyDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyEventHandler KeyDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyEventHandler PreviewKeyUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyEventHandler KeyUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyboardFocusChangedEventHandler GotKeyboardFocus;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyboardFocusChangedEventHandler LostKeyboardFocus;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TextCompositionEventHandler PreviewTextInput;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TextCompositionEventHandler TextInput;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private QueryContinueDragEventHandler PreviewQueryContinueDrag;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private QueryContinueDragEventHandler QueryContinueDrag;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private GiveFeedbackEventHandler PreviewGiveFeedback;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private GiveFeedbackEventHandler GiveFeedback;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler PreviewDragEnter;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler DragEnter;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler PreviewDragOver;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler DragOver;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler PreviewDragLeave;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler DragLeave;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler PreviewDrop;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler Drop;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> PreviewTouchDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> TouchDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> PreviewTouchMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> TouchMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> PreviewTouchUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> TouchUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> GotTouchCapture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> LostTouchCapture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> TouchEnter;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> TouchLeave;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsMouseCapturedChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsStylusCapturedChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler LayoutUpdated;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private RoutedEventHandler GotFocus;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private RoutedEventHandler LostFocus;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsEnabledChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsHitTestVisibleChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsVisibleChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler FocusableChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<ManipulationStartingEventArgs> ManipulationStarting;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<ManipulationStartedEventArgs> ManipulationStarted;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<ManipulationDeltaEventArgs> ManipulationDelta;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<ManipulationInertiaStartingEventArgs> ManipulationInertiaStarting;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<ManipulationBoundaryFeedbackEventArgs> ManipulationBoundaryFeedback;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<ManipulationCompletedEventArgs> ManipulationCompleted;
    public bool HasAnimatedProperties { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public InputBindingCollection InputBindings { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public CommandBindingCollection CommandBindings { get; }
    public bool AllowDrop { get; public set; }
    protected StylusPlugInCollection StylusPlugIns { get; }
    public Size DesiredSize { get; }
    public bool IsMeasureValid { get; }
    public bool IsArrangeValid { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public Size RenderSize { get; public set; }
    public Transform RenderTransform { get; public set; }
    public Point RenderTransformOrigin { get; public set; }
    public bool IsMouseDirectlyOver { get; }
    public bool IsMouseOver { get; }
    public bool IsStylusOver { get; }
    public bool IsKeyboardFocusWithin { get; }
    public bool IsMouseCaptured { get; }
    public bool IsMouseCaptureWithin { get; }
    public bool IsStylusDirectlyOver { get; }
    public bool IsStylusCaptured { get; }
    public bool IsStylusCaptureWithin { get; }
    public bool IsKeyboardFocused { get; }
    public bool IsInputMethodEnabled { get; }
    [LocalizabilityAttribute("0")]
public double Opacity { get; public set; }
    public Brush OpacityMask { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffect BitmapEffect { get; public set; }
    public Effect Effect { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffectInput BitmapEffectInput { get; public set; }
    public CacheMode CacheMode { get; public set; }
    public string Uid { get; public set; }
    [LocalizabilityAttribute("0")]
public Visibility Visibility { get; public set; }
    public bool ClipToBounds { get; public set; }
    public Geometry Clip { get; public set; }
    public bool SnapsToDevicePixels { get; public set; }
    protected bool HasEffectiveKeyboardFocus { get; }
    public bool IsFocused { get; }
    public bool IsEnabled { get; public set; }
    protected bool IsEnabledCore { get; }
    public bool IsHitTestVisible { get; public set; }
    public bool IsVisible { get; }
    public bool Focusable { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[ObsoleteAttribute("PersistId is an obsolete property and may be removed in a future release.  The value of this property is not defined.")]
public int PersistId { get; }
    public bool IsManipulationEnabled { get; public set; }
    public bool AreAnyTouchesOver { get; }
    public bool AreAnyTouchesDirectlyOver { get; }
    public bool AreAnyTouchesCapturedWithin { get; }
    public bool AreAnyTouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCapturedWithin { get; }
    public IEnumerable`1<TouchDevice> TouchesOver { get; }
    public IEnumerable`1<TouchDevice> TouchesDirectlyOver { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static UIElement();
    public sealed virtual bool get_HasAnimatedProperties();
    public InputBindingCollection get_InputBindings();
    public CommandBindingCollection get_CommandBindings();
    public bool get_AllowDrop();
    public void set_AllowDrop(bool value);
    protected StylusPlugInCollection get_StylusPlugIns();
    public Size get_DesiredSize();
    public bool get_IsMeasureValid();
    public bool get_IsArrangeValid();
    public Size get_RenderSize();
    public void set_RenderSize(Size value);
    public Transform get_RenderTransform();
    public void set_RenderTransform(Transform value);
    public Point get_RenderTransformOrigin();
    public void set_RenderTransformOrigin(Point value);
    public sealed virtual bool get_IsMouseDirectlyOver();
    public sealed virtual bool get_IsMouseOver();
    public sealed virtual bool get_IsStylusOver();
    public sealed virtual bool get_IsKeyboardFocusWithin();
    public sealed virtual bool get_IsMouseCaptured();
    public bool get_IsMouseCaptureWithin();
    public sealed virtual bool get_IsStylusDirectlyOver();
    public sealed virtual bool get_IsStylusCaptured();
    public bool get_IsStylusCaptureWithin();
    public sealed virtual bool get_IsKeyboardFocused();
    public bool get_IsInputMethodEnabled();
    public double get_Opacity();
    public void set_Opacity(double value);
    public Brush get_OpacityMask();
    public void set_OpacityMask(Brush value);
    public BitmapEffect get_BitmapEffect();
    public void set_BitmapEffect(BitmapEffect value);
    public Effect get_Effect();
    public void set_Effect(Effect value);
    public BitmapEffectInput get_BitmapEffectInput();
    public void set_BitmapEffectInput(BitmapEffectInput value);
    public CacheMode get_CacheMode();
    public void set_CacheMode(CacheMode value);
    public string get_Uid();
    public void set_Uid(string value);
    public Visibility get_Visibility();
    public void set_Visibility(Visibility value);
    public bool get_ClipToBounds();
    public void set_ClipToBounds(bool value);
    public Geometry get_Clip();
    public void set_Clip(Geometry value);
    public bool get_SnapsToDevicePixels();
    public void set_SnapsToDevicePixels(bool value);
    protected virtual bool get_HasEffectiveKeyboardFocus();
    public bool get_IsFocused();
    public sealed virtual bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    protected virtual bool get_IsEnabledCore();
    public bool get_IsHitTestVisible();
    public void set_IsHitTestVisible(bool value);
    public bool get_IsVisible();
    public sealed virtual bool get_Focusable();
    public sealed virtual void set_Focusable(bool value);
    public int get_PersistId();
    public bool get_IsManipulationEnabled();
    public void set_IsManipulationEnabled(bool value);
    public bool get_AreAnyTouchesOver();
    public bool get_AreAnyTouchesDirectlyOver();
    public bool get_AreAnyTouchesCapturedWithin();
    public bool get_AreAnyTouchesCaptured();
    public IEnumerable`1<TouchDevice> get_TouchesCaptured();
    public IEnumerable`1<TouchDevice> get_TouchesCapturedWithin();
    public IEnumerable`1<TouchDevice> get_TouchesOver();
    public IEnumerable`1<TouchDevice> get_TouchesDirectlyOver();
    [CompilerGeneratedAttribute]
public void add_PreviewMouseDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewMouseDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void add_MouseDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_MouseDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewMouseUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewMouseUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void add_MouseUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_MouseUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewMouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewMouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewMouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewMouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseEnter(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseEnter(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseLeave(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseLeave(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_GotMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_GotMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_LostMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_LostMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public void add_QueryCursor(QueryCursorEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_QueryCursor(QueryCursorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusEnter(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusEnter(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusLeave(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusLeave(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_GotStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_GotStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_LostStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_LostStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewKeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewKeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_KeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_KeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewKeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewKeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_KeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_KeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewTextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewTextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_QueryContinueDrag(QueryContinueDragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_QueryContinueDrag(QueryContinueDragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    [CompilerGeneratedAttribute]
public void add_GiveFeedback(GiveFeedbackEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_GiveFeedback(GiveFeedbackEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewDragEnter(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewDragEnter(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DragEnter(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DragEnter(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewDragOver(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewDragOver(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DragOver(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DragOver(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewDragLeave(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewDragLeave(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DragLeave(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DragLeave(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewDrop(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewDrop(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Drop(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Drop(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_TouchDown(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TouchDown(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_TouchMove(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TouchMove(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_TouchUp(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TouchUp(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_TouchEnter(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TouchEnter(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_TouchLeave(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TouchLeave(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_LayoutUpdated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LayoutUpdated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_GotFocus(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_GotFocus(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_LostFocus(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LostFocus(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsHitTestVisibleChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsHitTestVisibleChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsVisibleChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsVisibleChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_FocusableChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_FocusableChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_ManipulationStarting(EventHandler`1<ManipulationStartingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ManipulationStarting(EventHandler`1<ManipulationStartingEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ManipulationStarted(EventHandler`1<ManipulationStartedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ManipulationStarted(EventHandler`1<ManipulationStartedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ManipulationDelta(EventHandler`1<ManipulationDeltaEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ManipulationDelta(EventHandler`1<ManipulationDeltaEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ManipulationInertiaStarting(EventHandler`1<ManipulationInertiaStartingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ManipulationInertiaStarting(EventHandler`1<ManipulationInertiaStartingEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ManipulationBoundaryFeedback(EventHandler`1<ManipulationBoundaryFeedbackEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ManipulationBoundaryFeedback(EventHandler`1<ManipulationBoundaryFeedbackEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ManipulationCompleted(EventHandler`1<ManipulationCompletedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ManipulationCompleted(EventHandler`1<ManipulationCompletedEventArgs> value);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public sealed virtual object GetAnimationBaseValue(DependencyProperty dp);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInputBindings();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeCommandBindings();
    public sealed virtual void RaiseEvent(RoutedEventArgs e);
    public sealed virtual void AddHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    public sealed virtual void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddToEventRoute(EventRoute route, RoutedEventArgs e);
    protected virtual void OnPreviewMouseDown(MouseButtonEventArgs e);
    protected virtual void OnMouseDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseUp(MouseButtonEventArgs e);
    protected virtual void OnMouseUp(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseRightButtonUp(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseMove(MouseEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);
    protected virtual void OnMouseWheel(MouseWheelEventArgs e);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    protected virtual void OnGotMouseCapture(MouseEventArgs e);
    protected virtual void OnLostMouseCapture(MouseEventArgs e);
    protected virtual void OnQueryCursor(QueryCursorEventArgs e);
    protected virtual void OnPreviewStylusDown(StylusDownEventArgs e);
    protected virtual void OnStylusDown(StylusDownEventArgs e);
    protected virtual void OnPreviewStylusUp(StylusEventArgs e);
    protected virtual void OnStylusUp(StylusEventArgs e);
    protected virtual void OnPreviewStylusMove(StylusEventArgs e);
    protected virtual void OnStylusMove(StylusEventArgs e);
    protected virtual void OnPreviewStylusInAirMove(StylusEventArgs e);
    protected virtual void OnStylusInAirMove(StylusEventArgs e);
    protected virtual void OnStylusEnter(StylusEventArgs e);
    protected virtual void OnStylusLeave(StylusEventArgs e);
    protected virtual void OnPreviewStylusInRange(StylusEventArgs e);
    protected virtual void OnStylusInRange(StylusEventArgs e);
    protected virtual void OnPreviewStylusOutOfRange(StylusEventArgs e);
    protected virtual void OnStylusOutOfRange(StylusEventArgs e);
    protected virtual void OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs e);
    protected virtual void OnStylusSystemGesture(StylusSystemGestureEventArgs e);
    protected virtual void OnGotStylusCapture(StylusEventArgs e);
    protected virtual void OnLostStylusCapture(StylusEventArgs e);
    protected virtual void OnStylusButtonDown(StylusButtonEventArgs e);
    protected virtual void OnStylusButtonUp(StylusButtonEventArgs e);
    protected virtual void OnPreviewStylusButtonDown(StylusButtonEventArgs e);
    protected virtual void OnPreviewStylusButtonUp(StylusButtonEventArgs e);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnPreviewKeyUp(KeyEventArgs e);
    protected virtual void OnKeyUp(KeyEventArgs e);
    protected virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnPreviewTextInput(TextCompositionEventArgs e);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    protected virtual void OnPreviewQueryContinueDrag(QueryContinueDragEventArgs e);
    protected virtual void OnQueryContinueDrag(QueryContinueDragEventArgs e);
    protected virtual void OnPreviewGiveFeedback(GiveFeedbackEventArgs e);
    protected virtual void OnGiveFeedback(GiveFeedbackEventArgs e);
    protected virtual void OnPreviewDragEnter(DragEventArgs e);
    protected virtual void OnDragEnter(DragEventArgs e);
    protected virtual void OnPreviewDragOver(DragEventArgs e);
    protected virtual void OnDragOver(DragEventArgs e);
    protected virtual void OnPreviewDragLeave(DragEventArgs e);
    protected virtual void OnDragLeave(DragEventArgs e);
    protected virtual void OnPreviewDrop(DragEventArgs e);
    protected virtual void OnDrop(DragEventArgs e);
    protected virtual void OnPreviewTouchDown(TouchEventArgs e);
    protected virtual void OnTouchDown(TouchEventArgs e);
    protected virtual void OnPreviewTouchMove(TouchEventArgs e);
    protected virtual void OnTouchMove(TouchEventArgs e);
    protected virtual void OnPreviewTouchUp(TouchEventArgs e);
    protected virtual void OnTouchUp(TouchEventArgs e);
    protected virtual void OnGotTouchCapture(TouchEventArgs e);
    protected virtual void OnLostTouchCapture(TouchEventArgs e);
    protected virtual void OnTouchEnter(TouchEventArgs e);
    protected virtual void OnTouchLeave(TouchEventArgs e);
    protected virtual void OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs e);
    public void InvalidateMeasure();
    public void InvalidateArrange();
    public void InvalidateVisual();
    protected virtual void OnChildDesiredSizeChanged(UIElement child);
    public void Measure(Size availableSize);
    public void Arrange(Rect finalRect);
    protected virtual void OnRender(DrawingContext drawingContext);
    protected virtual void OnRenderSizeChanged(SizeChangedInfo info);
    protected virtual Size MeasureCore(Size availableSize);
    protected virtual void ArrangeCore(Rect finalRect);
    protected virtual void OnVisualParentChanged(DependencyObject oldParent);
    protected virtual DependencyObject GetUIParentCore();
    public void UpdateLayout();
    public Point TranslatePoint(Point point, UIElement relativeTo);
    public IInputElement InputHitTest(Point point);
    public sealed virtual bool CaptureMouse();
    public sealed virtual void ReleaseMouseCapture();
    public sealed virtual bool CaptureStylus();
    public sealed virtual void ReleaseStylusCapture();
    public sealed virtual bool Focus();
    public virtual bool MoveFocus(TraversalRequest request);
    public virtual DependencyObject PredictFocus(FocusNavigationDirection direction);
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    protected virtual void OnLostFocus(RoutedEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnManipulationStarting(ManipulationStartingEventArgs e);
    protected virtual void OnManipulationStarted(ManipulationStartedEventArgs e);
    protected virtual void OnManipulationDelta(ManipulationDeltaEventArgs e);
    protected virtual void OnManipulationInertiaStarting(ManipulationInertiaStartingEventArgs e);
    protected virtual void OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs e);
    protected virtual void OnManipulationCompleted(ManipulationCompletedEventArgs e);
    public bool CaptureTouch(TouchDevice touchDevice);
    public bool ReleaseTouchCapture(TouchDevice touchDevice);
    public void ReleaseAllTouchCaptures();
}
public abstract class System.Windows.UIElement3D : Visual3D {
    public static RoutedEvent PreviewMouseDownEvent;
    public static RoutedEvent MouseDownEvent;
    public static RoutedEvent PreviewMouseUpEvent;
    public static RoutedEvent MouseUpEvent;
    public static RoutedEvent PreviewMouseLeftButtonDownEvent;
    public static RoutedEvent MouseLeftButtonDownEvent;
    public static RoutedEvent PreviewMouseLeftButtonUpEvent;
    public static RoutedEvent MouseLeftButtonUpEvent;
    public static RoutedEvent PreviewMouseRightButtonDownEvent;
    public static RoutedEvent MouseRightButtonDownEvent;
    public static RoutedEvent PreviewMouseRightButtonUpEvent;
    public static RoutedEvent MouseRightButtonUpEvent;
    public static RoutedEvent PreviewMouseMoveEvent;
    public static RoutedEvent MouseMoveEvent;
    public static RoutedEvent PreviewMouseWheelEvent;
    public static RoutedEvent MouseWheelEvent;
    public static RoutedEvent MouseEnterEvent;
    public static RoutedEvent MouseLeaveEvent;
    public static RoutedEvent GotMouseCaptureEvent;
    public static RoutedEvent LostMouseCaptureEvent;
    public static RoutedEvent QueryCursorEvent;
    public static RoutedEvent PreviewStylusDownEvent;
    public static RoutedEvent StylusDownEvent;
    public static RoutedEvent PreviewStylusUpEvent;
    public static RoutedEvent StylusUpEvent;
    public static RoutedEvent PreviewStylusMoveEvent;
    public static RoutedEvent StylusMoveEvent;
    public static RoutedEvent PreviewStylusInAirMoveEvent;
    public static RoutedEvent StylusInAirMoveEvent;
    public static RoutedEvent StylusEnterEvent;
    public static RoutedEvent StylusLeaveEvent;
    public static RoutedEvent PreviewStylusInRangeEvent;
    public static RoutedEvent StylusInRangeEvent;
    public static RoutedEvent PreviewStylusOutOfRangeEvent;
    public static RoutedEvent StylusOutOfRangeEvent;
    public static RoutedEvent PreviewStylusSystemGestureEvent;
    public static RoutedEvent StylusSystemGestureEvent;
    public static RoutedEvent GotStylusCaptureEvent;
    public static RoutedEvent LostStylusCaptureEvent;
    public static RoutedEvent StylusButtonDownEvent;
    public static RoutedEvent StylusButtonUpEvent;
    public static RoutedEvent PreviewStylusButtonDownEvent;
    public static RoutedEvent PreviewStylusButtonUpEvent;
    public static RoutedEvent PreviewKeyDownEvent;
    public static RoutedEvent KeyDownEvent;
    public static RoutedEvent PreviewKeyUpEvent;
    public static RoutedEvent KeyUpEvent;
    public static RoutedEvent PreviewGotKeyboardFocusEvent;
    public static RoutedEvent GotKeyboardFocusEvent;
    public static RoutedEvent PreviewLostKeyboardFocusEvent;
    public static RoutedEvent LostKeyboardFocusEvent;
    public static RoutedEvent PreviewTextInputEvent;
    public static RoutedEvent TextInputEvent;
    public static RoutedEvent PreviewQueryContinueDragEvent;
    public static RoutedEvent QueryContinueDragEvent;
    public static RoutedEvent PreviewGiveFeedbackEvent;
    public static RoutedEvent GiveFeedbackEvent;
    public static RoutedEvent PreviewDragEnterEvent;
    public static RoutedEvent DragEnterEvent;
    public static RoutedEvent PreviewDragOverEvent;
    public static RoutedEvent DragOverEvent;
    public static RoutedEvent PreviewDragLeaveEvent;
    public static RoutedEvent DragLeaveEvent;
    public static RoutedEvent PreviewDropEvent;
    public static RoutedEvent DropEvent;
    public static RoutedEvent PreviewTouchDownEvent;
    public static RoutedEvent TouchDownEvent;
    public static RoutedEvent PreviewTouchMoveEvent;
    public static RoutedEvent TouchMoveEvent;
    public static RoutedEvent PreviewTouchUpEvent;
    public static RoutedEvent TouchUpEvent;
    public static RoutedEvent GotTouchCaptureEvent;
    public static RoutedEvent LostTouchCaptureEvent;
    public static RoutedEvent TouchEnterEvent;
    public static RoutedEvent TouchLeaveEvent;
    public static DependencyProperty IsMouseDirectlyOverProperty;
    public static DependencyProperty IsMouseOverProperty;
    public static DependencyProperty IsStylusOverProperty;
    public static DependencyProperty IsKeyboardFocusWithinProperty;
    public static DependencyProperty IsMouseCapturedProperty;
    public static DependencyProperty IsMouseCaptureWithinProperty;
    public static DependencyProperty IsStylusDirectlyOverProperty;
    public static DependencyProperty IsStylusCapturedProperty;
    public static DependencyProperty IsStylusCaptureWithinProperty;
    public static DependencyProperty IsKeyboardFocusedProperty;
    public static DependencyProperty AreAnyTouchesDirectlyOverProperty;
    public static DependencyProperty AreAnyTouchesOverProperty;
    public static DependencyProperty AreAnyTouchesCapturedProperty;
    public static DependencyProperty AreAnyTouchesCapturedWithinProperty;
    public static DependencyProperty AllowDropProperty;
    public static DependencyProperty VisibilityProperty;
    public static RoutedEvent GotFocusEvent;
    public static RoutedEvent LostFocusEvent;
    public static DependencyProperty IsFocusedProperty;
    public static DependencyProperty IsEnabledProperty;
    public static DependencyProperty IsHitTestVisibleProperty;
    public static DependencyProperty IsVisibleProperty;
    public static DependencyProperty FocusableProperty;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler PreviewMouseDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler MouseDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler PreviewMouseUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler MouseUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler PreviewMouseLeftButtonDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler MouseLeftButtonDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler PreviewMouseLeftButtonUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler MouseLeftButtonUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler PreviewMouseRightButtonDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler MouseRightButtonDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler PreviewMouseRightButtonUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseButtonEventHandler MouseRightButtonUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseEventHandler PreviewMouseMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseEventHandler MouseMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseWheelEventHandler PreviewMouseWheel;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseWheelEventHandler MouseWheel;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseEventHandler MouseEnter;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseEventHandler MouseLeave;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseEventHandler GotMouseCapture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MouseEventHandler LostMouseCapture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private QueryCursorEventHandler QueryCursor;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusDownEventHandler PreviewStylusDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusDownEventHandler StylusDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler PreviewStylusUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler PreviewStylusMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler PreviewStylusInAirMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusInAirMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusEnter;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusLeave;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler PreviewStylusInRange;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusInRange;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler PreviewStylusOutOfRange;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler StylusOutOfRange;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusSystemGestureEventHandler PreviewStylusSystemGesture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusSystemGestureEventHandler StylusSystemGesture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler GotStylusCapture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusEventHandler LostStylusCapture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusButtonEventHandler StylusButtonDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusButtonEventHandler StylusButtonUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusButtonEventHandler PreviewStylusButtonDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StylusButtonEventHandler PreviewStylusButtonUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyEventHandler PreviewKeyDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyEventHandler KeyDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyEventHandler PreviewKeyUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyEventHandler KeyUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyboardFocusChangedEventHandler GotKeyboardFocus;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private KeyboardFocusChangedEventHandler LostKeyboardFocus;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TextCompositionEventHandler PreviewTextInput;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TextCompositionEventHandler TextInput;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private QueryContinueDragEventHandler PreviewQueryContinueDrag;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private QueryContinueDragEventHandler QueryContinueDrag;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private GiveFeedbackEventHandler PreviewGiveFeedback;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private GiveFeedbackEventHandler GiveFeedback;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler PreviewDragEnter;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler DragEnter;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler PreviewDragOver;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler DragOver;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler PreviewDragLeave;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler DragLeave;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler PreviewDrop;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DragEventHandler Drop;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> PreviewTouchDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> TouchDown;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> PreviewTouchMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> TouchMove;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> PreviewTouchUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> TouchUp;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> GotTouchCapture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> LostTouchCapture;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> TouchEnter;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<TouchEventArgs> TouchLeave;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsMouseCapturedChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsStylusCapturedChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private RoutedEventHandler GotFocus;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private RoutedEventHandler LostFocus;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsEnabledChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsHitTestVisibleChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler IsVisibleChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DependencyPropertyChangedEventHandler FocusableChanged;
    [DesignerSerializationVisibilityAttribute("2")]
public InputBindingCollection InputBindings { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public CommandBindingCollection CommandBindings { get; }
    public bool AllowDrop { get; public set; }
    public bool IsMouseDirectlyOver { get; }
    public bool IsMouseOver { get; }
    public bool IsStylusOver { get; }
    public bool IsKeyboardFocusWithin { get; }
    public bool IsMouseCaptured { get; }
    public bool IsMouseCaptureWithin { get; }
    public bool IsStylusDirectlyOver { get; }
    public bool IsStylusCaptured { get; }
    public bool IsStylusCaptureWithin { get; }
    public bool IsKeyboardFocused { get; }
    public bool IsInputMethodEnabled { get; }
    [LocalizabilityAttribute("0")]
public Visibility Visibility { get; public set; }
    public bool IsFocused { get; }
    public bool IsEnabled { get; public set; }
    protected bool IsEnabledCore { get; }
    public bool IsHitTestVisible { get; public set; }
    public bool IsVisible { get; }
    public bool Focusable { get; public set; }
    public bool AreAnyTouchesOver { get; }
    public bool AreAnyTouchesDirectlyOver { get; }
    public bool AreAnyTouchesCapturedWithin { get; }
    public bool AreAnyTouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCapturedWithin { get; }
    public IEnumerable`1<TouchDevice> TouchesOver { get; }
    public IEnumerable`1<TouchDevice> TouchesDirectlyOver { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private static UIElement3D();
    public InputBindingCollection get_InputBindings();
    public CommandBindingCollection get_CommandBindings();
    public bool get_AllowDrop();
    public void set_AllowDrop(bool value);
    public sealed virtual bool get_IsMouseDirectlyOver();
    public sealed virtual bool get_IsMouseOver();
    public sealed virtual bool get_IsStylusOver();
    public sealed virtual bool get_IsKeyboardFocusWithin();
    public sealed virtual bool get_IsMouseCaptured();
    public bool get_IsMouseCaptureWithin();
    public sealed virtual bool get_IsStylusDirectlyOver();
    public sealed virtual bool get_IsStylusCaptured();
    public bool get_IsStylusCaptureWithin();
    public sealed virtual bool get_IsKeyboardFocused();
    public bool get_IsInputMethodEnabled();
    public Visibility get_Visibility();
    public void set_Visibility(Visibility value);
    public bool get_IsFocused();
    public sealed virtual bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    protected virtual bool get_IsEnabledCore();
    public bool get_IsHitTestVisible();
    public void set_IsHitTestVisible(bool value);
    public bool get_IsVisible();
    public sealed virtual bool get_Focusable();
    public sealed virtual void set_Focusable(bool value);
    public bool get_AreAnyTouchesOver();
    public bool get_AreAnyTouchesDirectlyOver();
    public bool get_AreAnyTouchesCapturedWithin();
    public bool get_AreAnyTouchesCaptured();
    public IEnumerable`1<TouchDevice> get_TouchesCaptured();
    public IEnumerable`1<TouchDevice> get_TouchesCapturedWithin();
    public IEnumerable`1<TouchDevice> get_TouchesOver();
    public IEnumerable`1<TouchDevice> get_TouchesDirectlyOver();
    [CompilerGeneratedAttribute]
public void add_PreviewMouseDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewMouseDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void add_MouseDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_MouseDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewMouseUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewMouseUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void add_MouseUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_MouseUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewMouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewMouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewMouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewMouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseEnter(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseEnter(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MouseLeave(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MouseLeave(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_GotMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_GotMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_LostMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_LostMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public void add_QueryCursor(QueryCursorEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_QueryCursor(QueryCursorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusEnter(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusEnter(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusLeave(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusLeave(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_GotStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_GotStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_LostStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_LostStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewStylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewStylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewKeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewKeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_KeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_KeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewKeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewKeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_KeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_KeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PreviewTextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PreviewTextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_QueryContinueDrag(QueryContinueDragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_QueryContinueDrag(QueryContinueDragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    [CompilerGeneratedAttribute]
public void add_GiveFeedback(GiveFeedbackEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_GiveFeedback(GiveFeedbackEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewDragEnter(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewDragEnter(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DragEnter(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DragEnter(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewDragOver(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewDragOver(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DragOver(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DragOver(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewDragLeave(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewDragLeave(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DragLeave(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DragLeave(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewDrop(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewDrop(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Drop(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Drop(DragEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_TouchDown(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TouchDown(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_TouchMove(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TouchMove(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_TouchUp(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TouchUp(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_TouchEnter(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TouchEnter(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_TouchLeave(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TouchLeave(EventHandler`1<TouchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_GotFocus(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_GotFocus(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_LostFocus(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LostFocus(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsHitTestVisibleChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsHitTestVisibleChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_IsVisibleChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsVisibleChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_FocusableChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_FocusableChanged(DependencyPropertyChangedEventHandler value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInputBindings();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeCommandBindings();
    public sealed virtual void RaiseEvent(RoutedEventArgs e);
    public sealed virtual void AddHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    public sealed virtual void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddToEventRoute(EventRoute route, RoutedEventArgs e);
    protected internal virtual void OnPreviewMouseDown(MouseButtonEventArgs e);
    protected internal virtual void OnMouseDown(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseUp(MouseButtonEventArgs e);
    protected internal virtual void OnMouseUp(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    protected internal virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e);
    protected internal virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e);
    protected internal virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);
    protected internal virtual void OnMouseRightButtonUp(MouseButtonEventArgs e);
    protected internal virtual void OnPreviewMouseMove(MouseEventArgs e);
    protected internal virtual void OnMouseMove(MouseEventArgs e);
    protected internal virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);
    protected internal virtual void OnMouseWheel(MouseWheelEventArgs e);
    protected internal virtual void OnMouseEnter(MouseEventArgs e);
    protected internal virtual void OnMouseLeave(MouseEventArgs e);
    protected internal virtual void OnGotMouseCapture(MouseEventArgs e);
    protected internal virtual void OnLostMouseCapture(MouseEventArgs e);
    protected internal virtual void OnQueryCursor(QueryCursorEventArgs e);
    protected internal virtual void OnPreviewStylusDown(StylusDownEventArgs e);
    protected internal virtual void OnStylusDown(StylusDownEventArgs e);
    protected internal virtual void OnPreviewStylusUp(StylusEventArgs e);
    protected internal virtual void OnStylusUp(StylusEventArgs e);
    protected internal virtual void OnPreviewStylusMove(StylusEventArgs e);
    protected internal virtual void OnStylusMove(StylusEventArgs e);
    protected internal virtual void OnPreviewStylusInAirMove(StylusEventArgs e);
    protected internal virtual void OnStylusInAirMove(StylusEventArgs e);
    protected internal virtual void OnStylusEnter(StylusEventArgs e);
    protected internal virtual void OnStylusLeave(StylusEventArgs e);
    protected internal virtual void OnPreviewStylusInRange(StylusEventArgs e);
    protected internal virtual void OnStylusInRange(StylusEventArgs e);
    protected internal virtual void OnPreviewStylusOutOfRange(StylusEventArgs e);
    protected internal virtual void OnStylusOutOfRange(StylusEventArgs e);
    protected internal virtual void OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs e);
    protected internal virtual void OnStylusSystemGesture(StylusSystemGestureEventArgs e);
    protected internal virtual void OnGotStylusCapture(StylusEventArgs e);
    protected internal virtual void OnLostStylusCapture(StylusEventArgs e);
    protected internal virtual void OnStylusButtonDown(StylusButtonEventArgs e);
    protected internal virtual void OnStylusButtonUp(StylusButtonEventArgs e);
    protected internal virtual void OnPreviewStylusButtonDown(StylusButtonEventArgs e);
    protected internal virtual void OnPreviewStylusButtonUp(StylusButtonEventArgs e);
    protected internal virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected internal virtual void OnKeyDown(KeyEventArgs e);
    protected internal virtual void OnPreviewKeyUp(KeyEventArgs e);
    protected internal virtual void OnKeyUp(KeyEventArgs e);
    protected internal virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected internal virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected internal virtual void OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected internal virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected internal virtual void OnPreviewTextInput(TextCompositionEventArgs e);
    protected internal virtual void OnTextInput(TextCompositionEventArgs e);
    protected internal virtual void OnPreviewQueryContinueDrag(QueryContinueDragEventArgs e);
    protected internal virtual void OnQueryContinueDrag(QueryContinueDragEventArgs e);
    protected internal virtual void OnPreviewGiveFeedback(GiveFeedbackEventArgs e);
    protected internal virtual void OnGiveFeedback(GiveFeedbackEventArgs e);
    protected internal virtual void OnPreviewDragEnter(DragEventArgs e);
    protected internal virtual void OnDragEnter(DragEventArgs e);
    protected internal virtual void OnPreviewDragOver(DragEventArgs e);
    protected internal virtual void OnDragOver(DragEventArgs e);
    protected internal virtual void OnPreviewDragLeave(DragEventArgs e);
    protected internal virtual void OnDragLeave(DragEventArgs e);
    protected internal virtual void OnPreviewDrop(DragEventArgs e);
    protected internal virtual void OnDrop(DragEventArgs e);
    protected internal virtual void OnPreviewTouchDown(TouchEventArgs e);
    protected internal virtual void OnTouchDown(TouchEventArgs e);
    protected internal virtual void OnPreviewTouchMove(TouchEventArgs e);
    protected internal virtual void OnTouchMove(TouchEventArgs e);
    protected internal virtual void OnPreviewTouchUp(TouchEventArgs e);
    protected internal virtual void OnTouchUp(TouchEventArgs e);
    protected internal virtual void OnGotTouchCapture(TouchEventArgs e);
    protected internal virtual void OnLostTouchCapture(TouchEventArgs e);
    protected internal virtual void OnTouchEnter(TouchEventArgs e);
    protected internal virtual void OnTouchLeave(TouchEventArgs e);
    protected virtual void OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs e);
    public void InvalidateModel();
    protected virtual void OnUpdateModel();
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    protected internal DependencyObject GetUIParentCore();
    public sealed virtual bool CaptureMouse();
    public sealed virtual void ReleaseMouseCapture();
    public sealed virtual bool CaptureStylus();
    public sealed virtual void ReleaseStylusCapture();
    public sealed virtual bool Focus();
    public virtual bool MoveFocus(TraversalRequest request);
    public virtual DependencyObject PredictFocus(FocusNavigationDirection direction);
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    protected virtual void OnLostFocus(RoutedEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    public bool CaptureTouch(TouchDevice touchDevice);
    public bool ReleaseTouchCapture(TouchDevice touchDevice);
    public void ReleaseAllTouchCaptures();
}
public class System.Windows.UIPropertyMetadata : PropertyMetadata {
    public bool IsAnimationProhibited { get; public set; }
    public UIPropertyMetadata(object defaultValue);
    public UIPropertyMetadata(PropertyChangedCallback propertyChangedCallback);
    public UIPropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback);
    public UIPropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback);
    public UIPropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);
    public bool get_IsAnimationProhibited();
    public void set_IsAnimationProhibited(bool value);
}
public enum System.Windows.Visibility : Enum {
    public byte value__;
    public static Visibility Visible;
    public static Visibility Hidden;
    public static Visibility Collapsed;
}
