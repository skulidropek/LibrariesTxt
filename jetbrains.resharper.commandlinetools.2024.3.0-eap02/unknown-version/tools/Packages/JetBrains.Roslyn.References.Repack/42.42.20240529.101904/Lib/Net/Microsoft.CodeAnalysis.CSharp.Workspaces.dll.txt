[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CodeActions.CSharpCodeFixOptionsProvider : ValueType {
    private IOptionsReader _options;
    private HostLanguageServices _languageServices;
    private CodeActionOptionsProvider _fallbackOptions;
    public string NewLine { get; }
    public CodeStyleOption2`1<bool> VarForBuiltInTypes { get; }
    public CodeStyleOption2`1<bool> VarElsewhere { get; }
    public CodeStyleOption2`1<NamespaceDeclarationPreference> NamespaceDeclarations { get; }
    public CodeStyleOption2`1<bool> PreferTopLevelStatements { get; }
    public CodeStyleOption2`1<AddImportPlacement> UsingDirectivePlacement { get; }
    public CodeStyleOption2`1<string> PreferredModifierOrder { get; }
    public CodeStyleOption2`1<AccessibilityModifiersRequired> AccessibilityModifiersRequired { get; }
    private CSharpIdeCodeStyleOptions FallbackCodeStyleOptions { get; }
    private CSharpSimplifierOptions FallbackSimplifierOptions { get; }
    private CSharpSyntaxFormattingOptions FallbackSyntaxFormattingOptions { get; }
    private LineFormattingOptions FallbackLineFormattingOptions { get; }
    private AddImportPlacementOptions FallbackAddImportPlacementOptions { get; }
    public CSharpCodeFixOptionsProvider(IOptionsReader options, CodeActionOptionsProvider fallbackOptions, HostLanguageServices languageServices);
    public string get_NewLine();
    public CodeStyleOption2`1<bool> get_VarForBuiltInTypes();
    public CodeStyleOption2`1<bool> get_VarElsewhere();
    public SimplifierOptions GetSimplifierOptions();
    public CodeStyleOption2`1<NamespaceDeclarationPreference> get_NamespaceDeclarations();
    public CodeStyleOption2`1<bool> get_PreferTopLevelStatements();
    internal CSharpSyntaxFormattingOptions GetFormattingOptions();
    public CodeStyleOption2`1<AddImportPlacement> get_UsingDirectivePlacement();
    public CodeStyleOption2`1<string> get_PreferredModifierOrder();
    public CodeStyleOption2`1<AccessibilityModifiersRequired> get_AccessibilityModifiersRequired();
    private TValue GetOption(Option2`1<TValue> option, TValue defaultValue);
    private TValue GetOption(PerLanguageOption2`1<TValue> option, TValue defaultValue);
    private CSharpIdeCodeStyleOptions get_FallbackCodeStyleOptions();
    private CSharpSimplifierOptions get_FallbackSimplifierOptions();
    private CSharpSyntaxFormattingOptions get_FallbackSyntaxFormattingOptions();
    private LineFormattingOptions get_FallbackLineFormattingOptions();
    private AddImportPlacementOptions get_FallbackAddImportPlacementOptions();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeActions.CSharpCodeFixOptionsProviders : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CSharpCodeFixOptionsProviders/<GetCSharpCodeFixOptionsProviderAsync>d__0")]
[ExtensionAttribute]
public static ValueTask`1<CSharpCodeFixOptionsProvider> GetCSharpCodeFixOptionsProviderAsync(Document document, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.CodeStyle.PreferBracesPreference : Enum {
    public int value__;
    public static PreferBracesPreference None;
    public static PreferBracesPreference Always;
    public static PreferBracesPreference WhenMultiline;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.AddImport.IAddImportsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddImport.CSharpAddImportsService : AbstractAddImportsService`4<CompilationUnitSyntax, BaseNamespaceDeclarationSyntax, UsingDirectiveSyntax, ExternAliasDirectiveSyntax> {
    protected string Language { get; }
    protected virtual string get_Language();
    public virtual CodeStyleOption2`1<AddImportPlacement> GetUsingDirectivePlacementCodeStyleOption(IOptionsReader configOptions, CodeStyleOption2`1<AddImportPlacement> fallbackValue);
    protected virtual ImmutableArray`1<SyntaxNode> GetGlobalImports(Compilation compilation, SyntaxGenerator generator);
    protected virtual SyntaxNode GetAlias(UsingDirectiveSyntax usingOrAlias);
    protected virtual bool IsStaticUsing(UsingDirectiveSyntax usingOrAlias);
    protected virtual SyntaxNode Rewrite(ExternAliasDirectiveSyntax[] externAliases, UsingDirectiveSyntax[] usingDirectives, UsingDirectiveSyntax[] staticUsingDirectives, UsingDirectiveSyntax[] aliasDirectives, SyntaxNode externContainer, SyntaxNode usingContainer, SyntaxNode staticUsingContainer, SyntaxNode aliasContainer, AddImportPlacementOptions options, SyntaxNode root, CancellationToken cancellationToken);
    protected virtual SyntaxList`1<UsingDirectiveSyntax> GetUsingsAndAliases(SyntaxNode node);
    protected virtual SyntaxList`1<ExternAliasDirectiveSyntax> GetExterns(SyntaxNode node);
    protected virtual bool IsEquivalentImport(SyntaxNode a, SyntaxNode b);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CaseCorrection.ICaseCorrectionService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CaseCorrection.CSharpCaseCorrectionService : AbstractCaseCorrectionService {
    [NullableContextAttribute("1")]
protected virtual void AddReplacements(SemanticModel semanticModel, SyntaxNode root, ImmutableArray`1<TextSpan> spans, ConcurrentDictionary`2<SyntaxToken, SyntaxToken> replacements, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Classification.ClassificationHelpers : object {
    private static string FromKeyword;
    private static string VarKeyword;
    private static string UnmanagedKeyword;
    private static string NotNullKeyword;
    private static string DynamicKeyword;
    private static string AwaitKeyword;
    [NullableContextAttribute("2")]
public static string GetClassification(SyntaxToken token);
    private static bool IsControlKeyword(SyntaxToken token);
    private static bool IsControlKeywordKind(SyntaxKind kind);
    private static bool IsControlStatementKind(SyntaxKind kind);
    private static bool IsStringToken(SyntaxToken token);
    private static bool IsVerbatimStringToken(SyntaxToken token);
    [NullableContextAttribute("2")]
public static string GetSyntacticClassificationForIdentifier(SyntaxToken token);
    private static string GetClassificationTypeForConstructorOrDestructorParent(SyntaxNode parentNode);
    private static bool IsNamespaceName(IdentifierNameSyntax identifierSyntax);
    public static bool IsStaticallyDeclared(SyntaxToken token);
    private static bool IsExtensionMethod(MethodDeclarationSyntax methodDeclaration);
    [NullableContextAttribute("2")]
private static string GetClassificationForTypeDeclarationIdentifier(SyntaxToken identifier);
    private static string GetClassificationForPunctuation(SyntaxToken token);
    [ExtensionAttribute]
private static bool IsOperator(SyntaxKind kind);
    private static bool IsActualContextualKeyword(SyntaxToken token);
    internal static void AddLexicalClassifications(SourceText text, TextSpan textSpan, SegmentedList`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    internal static ClassifiedSpan AdjustStaleClassification(SourceText rawText, ClassifiedSpan classifiedSpan);
}
internal class Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.DiscardSyntaxClassifier : AbstractSyntaxClassifier {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<Type> <SyntaxNodeTypes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Type> SyntaxNodeTypes { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<Type> get_SyntaxNodeTypes();
    [NullableContextAttribute("1")]
public virtual void AddClassifications(SyntaxNode syntax, TextSpan textSpan, SemanticModel semanticModel, ClassificationOptions options, SegmentedList`1<ClassifiedSpan> result, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier : AbstractNameSyntaxClassifier {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<Type> <SyntaxNodeTypes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Type> SyntaxNodeTypes { get; }
    public virtual void AddClassifications(SyntaxNode syntax, TextSpan textSpan, SemanticModel semanticModel, ClassificationOptions options, SegmentedList`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<Type> get_SyntaxNodeTypes();
    protected virtual Nullable`1<int> GetRightmostNameArity(SyntaxNode node);
    protected virtual bool IsParentAnAttribute(SyntaxNode node);
    private void ClassifyTypeSyntax(NameSyntax name, SemanticModel semanticModel, SegmentedList`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    private bool TryClassifySymbol(NameSyntax name, SymbolInfo symbolInfo, SegmentedList`1<ClassifiedSpan> result);
    private static bool TryClassifyAmbiguousSymbol(NameSyntax name, SymbolInfo symbolInfo, SegmentedList`1<ClassifiedSpan> result);
    private static bool TryClassifySymbol(NameSyntax name, ISymbol symbol, ClassifiedSpan& classifiedSpan);
    private static string GetClassificationForField(IFieldSymbol fieldSymbol);
    private static string GetClassificationForLocal(ILocalSymbol localSymbol);
    private static string GetClassificationForMethod(IMethodSymbol methodSymbol);
    private static bool IsInVarContext(NameSyntax name);
    private static bool TryClassifyFromIdentifier(NameSyntax name, SymbolInfo symbolInfo, SegmentedList`1<ClassifiedSpan> result);
    private static bool TryClassifyValueIdentifier(NameSyntax name, SymbolInfo symbolInfo, SegmentedList`1<ClassifiedSpan> result);
    private static bool TryClassifySomeContextualKeywordIdentifiersAsKeywords(NameSyntax name, SymbolInfo symbolInfo, SegmentedList`1<ClassifiedSpan> result);
}
internal class Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.SyntaxTokenClassifier : AbstractSyntaxClassifier {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<int> <SyntaxTokenKinds>k__BackingField;
    [NullableAttribute("1")]
private static Func`2<ITypeSymbol, bool> s_shouldInclude;
    public ImmutableArray`1<int> SyntaxTokenKinds { get; }
    private static SyntaxTokenClassifier();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<int> get_SyntaxTokenKinds();
    [NullableContextAttribute("1")]
public virtual void AddClassifications(SyntaxToken lessThanToken, TextSpan textSpan, SemanticModel semanticModel, ClassificationOptions options, SegmentedList`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    private static bool CouldBeGenericType(SyntaxToken identifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.UsingDirectiveSyntaxClassifier : AbstractSyntaxClassifier {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<Type> <SyntaxNodeTypes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Type> SyntaxNodeTypes { get; }
    public virtual void AddClassifications(SyntaxNode syntax, TextSpan textSpan, SemanticModel semanticModel, ClassificationOptions options, SegmentedList`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<Type> get_SyntaxNodeTypes();
    private static void ClassifyUsingDirectiveSyntax(UsingDirectiveSyntax usingDirective, SemanticModel semanticModel, SegmentedList`1<ClassifiedSpan> result, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Classification.IClassificationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Classification.CSharpEditorClassificationService : AbstractClassificationService {
    public virtual void AddLexicalClassifications(SourceText text, TextSpan textSpan, SegmentedList`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public virtual ClassifiedSpan AdjustStaleClassification(SourceText text, ClassifiedSpan classifiedSpan);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Classification.ISyntaxClassificationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Classification.CSharpSyntaxClassificationService : AbstractSyntaxClassificationService {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<ISyntaxClassifier> s_defaultSyntaxClassifiers;
    private static CSharpSyntaxClassificationService();
    public virtual ImmutableArray`1<ISyntaxClassifier> GetDefaultSyntaxClassifiers();
    public virtual void AddLexicalClassifications(SourceText text, TextSpan textSpan, SegmentedList`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public virtual void AddSyntacticClassifications(SyntaxNode root, ImmutableArray`1<TextSpan> textSpans, SegmentedList`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public virtual ClassifiedSpan FixClassification(SourceText rawText, ClassifiedSpan classifiedSpan);
    [NullableContextAttribute("2")]
public virtual string GetSyntacticClassificationForIdentifier(SyntaxToken identifier);
}
internal class Microsoft.CodeAnalysis.CSharp.Classification.FunctionPointerUnmanagedCallingConventionClassifier : AbstractSyntaxClassifier {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<Type> <SyntaxNodeTypes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Type> SyntaxNodeTypes { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<Type> get_SyntaxNodeTypes();
    [NullableContextAttribute("1")]
public virtual void AddClassifications(SyntaxNode syntax, TextSpan textSpan, SemanticModel semanticModel, ClassificationOptions options, SegmentedList`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <AddClassifications>g__IsLegalCallingConvention|3_0(string name, <>c__DisplayClass3_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Classification.OperatorOverloadSyntaxClassifier : AbstractSyntaxClassifier {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<Type> <SyntaxNodeTypes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Type> SyntaxNodeTypes { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<Type> get_SyntaxNodeTypes();
    public virtual void AddClassifications(SyntaxNode syntax, TextSpan textSpan, SemanticModel semanticModel, ClassificationOptions options, SegmentedList`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    private static TextSpan GetOperatorTokenSpan(SyntaxNode syntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Classification.Worker : ValueType {
    private TextSpan _textSpan;
    private SegmentedList`1<ClassifiedSpan> _result;
    private CancellationToken _cancellationToken;
    private Worker(TextSpan textSpan, SegmentedList`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    internal static void CollectClassifiedSpans(IEnumerable`1<SyntaxToken> tokens, TextSpan textSpan, SegmentedList`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    internal static void CollectClassifiedSpans(SyntaxNode node, TextSpan textSpan, SegmentedList`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    private void AddClassification(TextSpan span, string type);
    private bool ShouldAddSpan(TextSpan span);
    private void AddClassification(SyntaxTrivia trivia, string type);
    private void AddClassification(SyntaxToken token, string type);
    private void ClassifyNodeOrToken(SyntaxNodeOrToken nodeOrToken);
    private void ClassifyNode(SyntaxNode node);
    private void ClassifyToken(SyntaxToken token);
    private void ClassifyTriviaList(SyntaxTriviaList list);
    private void ClassifyTrivia(SyntaxTrivia trivia, SyntaxTriviaList triviaList);
    private void ClassifySkippedTokens(SkippedTokensTriviaSyntax skippedTokens);
    private void ClassifyConflictMarker(SyntaxTrivia trivia);
    private void ClassifyDisabledText(SyntaxTrivia trivia, SyntaxTriviaList triviaList);
    private void ClassifyDocumentationComment(DocumentationCommentTriviaSyntax documentationComment);
    private void ClassifyXmlNode(XmlNodeSyntax node);
    private void ClassifyXmlTrivia(SyntaxTriviaList triviaList);
    private void ClassifyExteriorTrivia(SyntaxTrivia trivia);
    private void AddXmlClassification(SyntaxToken token, string classificationType);
    private void ClassifyXmlTextTokens(SyntaxTokenList textTokens);
    private void ClassifyXmlTextToken(SyntaxToken token);
    private void ClassifyXmlName(XmlNameSyntax node);
    private void ClassifyXmlElement(XmlElementSyntax node);
    private void ClassifyXmlElementStartTag(XmlElementStartTagSyntax node);
    private void ClassifyXmlElementEndTag(XmlElementEndTagSyntax node);
    private void ClassifyXmlEmptyElement(XmlEmptyElementSyntax node);
    private void ClassifyXmlAttribute(XmlAttributeSyntax attribute);
    private void ClassifyXmlText(XmlTextSyntax node);
    private void ClassifyXmlComment(XmlCommentSyntax node);
    private void ClassifyXmlCDataSection(XmlCDataSectionSyntax node);
    private void ClassifyXmlProcessingInstruction(XmlProcessingInstructionSyntax node);
    private void ClassifyPreprocessorDirective(DirectiveTriviaSyntax node);
    private void ClassifyDirectiveTrivia(DirectiveTriviaSyntax node, bool allowComments);
    private void ClassifyPreprocessorTrivia(SyntaxTrivia trivia, bool allowComments);
    [NullableContextAttribute("2")]
private void ClassifyPreprocessorExpression(ExpressionSyntax node);
    private void ClassifyIfDirective(IfDirectiveTriviaSyntax node);
    private void ClassifyElifDirective(ElifDirectiveTriviaSyntax node);
    private void ClassifyElseDirective(ElseDirectiveTriviaSyntax node);
    private void ClassifyEndIfDirective(EndIfDirectiveTriviaSyntax node);
    private void ClassifyErrorDirective(ErrorDirectiveTriviaSyntax node);
    private void ClassifyWarningDirective(WarningDirectiveTriviaSyntax node);
    private void ClassifyRegionDirective(RegionDirectiveTriviaSyntax node);
    private void ClassifyEndRegionDirective(EndRegionDirectiveTriviaSyntax node);
    private void ClassifyDefineDirective(DefineDirectiveTriviaSyntax node);
    private void ClassifyUndefDirective(UndefDirectiveTriviaSyntax node);
    private void ClassifyBadDirective(BadDirectiveTriviaSyntax node);
    private void ClassifyLineDirective(LineDirectiveTriviaSyntax node);
    private void ClassifyLineSpanDirective(LineSpanDirectiveTriviaSyntax node);
    private void AddOptionalClassification(SyntaxToken token, string classification);
    private void ClassifyLineDirectivePosition(LineDirectivePositionSyntax node);
    private void ClassifyPragmaChecksumDirective(PragmaChecksumDirectiveTriviaSyntax node);
    private void ClassifyPragmaWarningDirective(PragmaWarningDirectiveTriviaSyntax node);
    private void ClassifyReferenceDirective(ReferenceDirectiveTriviaSyntax node);
    private void ClassifyLoadDirective(LoadDirectiveTriviaSyntax node);
    private void ClassifyNullableDirective(NullableDirectiveTriviaSyntax node);
}
internal class Microsoft.CodeAnalysis.CSharp.CodeCleanup.CSharpCodeCleanerService : AbstractCodeCleanerService {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<ICodeCleanupProvider> s_defaultProviders;
    private static CSharpCodeCleanerService();
    public virtual ImmutableArray`1<ICodeCleanupProvider> GetDefaultProviders();
    protected virtual ImmutableArray`1<TextSpan> GetSpansToAvoid(SyntaxNode root);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanerService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeCleanup.CSharpCodeCleanerServiceFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices provider);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllSpanMappingService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixesAndRefactorings.CSharpFixAllSpanMappingService : AbstractFixAllSpanMappingService {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixesAndRefactorings.CSharpFixAllSpanMappingService/<GetFixAllSpansIfWithinGlobalStatementAsync>d__1")]
protected virtual Task`1<ImmutableDictionary`2<Document, ImmutableArray`1<TextSpan>>> GetFixAllSpansIfWithinGlobalStatementAsync(Document document, TextSpan span, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.ArgumentGenerator : object {
    public static ArgumentSyntax GenerateArgument(SyntaxNode argument);
    public static ArgumentListSyntax GenerateArgumentList(IList`1<SyntaxNode> arguments);
    public static BracketedArgumentListSyntax GenerateBracketedArgumentList(IList`1<SyntaxNode> arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.AttributeGenerator : object {
    public static SyntaxList`1<AttributeListSyntax> GenerateAttributeLists(ImmutableArray`1<AttributeData> attributes, CSharpCodeGenerationContextInfo info, Nullable`1<SyntaxToken> target);
    private static AttributeListSyntax TryGenerateAttributeDeclaration(AttributeData attribute, Nullable`1<SyntaxToken> target, CSharpCodeGenerationContextInfo info);
    private static AttributeSyntax TryGenerateAttribute(AttributeData attribute, CSharpCodeGenerationContextInfo info);
    private static AttributeArgumentListSyntax GenerateAttributeArgumentList(SyntaxGenerator generator, AttributeData attribute);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.ConstructorGenerator : object {
    [NullableContextAttribute("2")]
private static MemberDeclarationSyntax LastConstructorOrField(SyntaxList`1<MemberDeclarationSyntax> members);
    internal static TypeDeclarationSyntax AddConstructorTo(TypeDeclarationSyntax destination, IMethodSymbol constructor, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static ConstructorDeclarationSyntax GenerateConstructorDeclaration(IMethodSymbol constructor, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static ConstructorDeclarationSyntax UseExpressionBodyIfDesired(CSharpCodeGenerationContextInfo info, ConstructorDeclarationSyntax declaration, CancellationToken cancellationToken);
    private static ConstructorInitializerSyntax GenerateConstructorInitializer(IMethodSymbol constructor);
    private static ArgumentListSyntax GenerateArgumentList(ImmutableArray`1<SyntaxNode> arguments);
    private static BlockSyntax GenerateBlock(IMethodSymbol constructor);
    private static SyntaxTokenList GenerateModifiers(IMethodSymbol constructor, CSharpCodeGenerationContextInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.ConversionGenerator : object {
    internal static TypeDeclarationSyntax AddConversionTo(TypeDeclarationSyntax destination, IMethodSymbol method, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static ConversionOperatorDeclarationSyntax GenerateConversionDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static ConversionOperatorDeclarationSyntax GenerateConversionDeclarationWorker(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static ConversionOperatorDeclarationSyntax UseExpressionBodyIfDesired(CSharpCodeGenerationContextInfo info, ConversionOperatorDeclarationSyntax declaration, CancellationToken cancellationToken);
    private static SyntaxTokenList GenerateModifiers(CodeGenerationDestination destination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpCodeGenerationContextInfo : CodeGenerationContextInfo {
    public LanguageVersion LanguageVersion;
    [CompilerGeneratedAttribute]
private CSharpCodeGenerationOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpCodeGenerationService <Service>k__BackingField;
    public CSharpCodeGenerationOptions Options { get; }
    public CSharpCodeGenerationService Service { get; }
    protected SyntaxGenerator GeneratorImpl { get; }
    protected CodeGenerationOptions OptionsImpl { get; }
    protected ICodeGenerationService ServiceImpl { get; }
    public CSharpCodeGenerationContextInfo(CodeGenerationContext context, CSharpCodeGenerationOptions options, CSharpCodeGenerationService service, LanguageVersion languageVersion);
    [CompilerGeneratedAttribute]
public CSharpCodeGenerationOptions get_Options();
    [CompilerGeneratedAttribute]
public CSharpCodeGenerationService get_Service();
    protected virtual SyntaxGenerator get_GeneratorImpl();
    protected virtual CodeGenerationOptions get_OptionsImpl();
    protected virtual ICodeGenerationService get_ServiceImpl();
    public CSharpCodeGenerationContextInfo WithContext(CodeGenerationContext value);
    protected virtual CodeGenerationContextInfo WithContextImpl(CodeGenerationContext value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpCodeGenerationHelpers : object {
    public static TDeclarationSyntax ConditionallyAddFormattingAnnotationTo(TDeclarationSyntax result, SyntaxList`1<MemberDeclarationSyntax> members);
    internal static void AddAccessibilityModifiers(Accessibility accessibility, ArrayBuilder`1<SyntaxToken> tokens, CSharpCodeGenerationContextInfo info, Accessibility defaultAccessibility);
    public static TypeDeclarationSyntax AddMembersTo(TypeDeclarationSyntax destination, SyntaxList`1<MemberDeclarationSyntax> members, CancellationToken cancellationToken);
    private static TypeDeclarationSyntax ReplaceUnterminatedConstructs(TypeDeclarationSyntax destination);
    private static SyntaxTrivia ReplaceUnterminatedConstructs(SyntaxTrivia skippedTokensTrivia);
    private static SyntaxToken ReplaceUnterminatedConstruct(SyntaxToken token);
    [NullableContextAttribute("2")]
public static MemberDeclarationSyntax FirstMember(SyntaxList`1<MemberDeclarationSyntax> members);
    [NullableContextAttribute("2")]
public static MemberDeclarationSyntax FirstMethod(SyntaxList`1<MemberDeclarationSyntax> members);
    [NullableContextAttribute("2")]
public static MemberDeclarationSyntax LastField(SyntaxList`1<MemberDeclarationSyntax> members);
    [NullableContextAttribute("2")]
public static MemberDeclarationSyntax LastConstructor(SyntaxList`1<MemberDeclarationSyntax> members);
    [NullableContextAttribute("2")]
public static MemberDeclarationSyntax LastMethod(SyntaxList`1<MemberDeclarationSyntax> members);
    [NullableContextAttribute("2")]
public static MemberDeclarationSyntax LastOperator(SyntaxList`1<MemberDeclarationSyntax> members);
    public static SyntaxList`1<TDeclaration> Insert(SyntaxList`1<TDeclaration> declarationList, TDeclaration declaration, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, Func`2<SyntaxList`1<TDeclaration>, TDeclaration> after, Func`2<SyntaxList`1<TDeclaration>, TDeclaration> before);
    private static bool AreBracesMissing(TDeclaration declaration);
    public static SyntaxNode GetContextNode(Location location, CancellationToken cancellationToken);
    public static ExplicitInterfaceSpecifierSyntax GenerateExplicitInterfaceSpecifier(IEnumerable`1<ISymbol> implementations);
    public static CodeGenerationDestination GetDestination(SyntaxNode destination);
    public static TSyntaxNode ConditionallyAddDocumentationCommentTo(TSyntaxNode node, ISymbol symbol, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public static T GetReuseableSyntaxNodeForSymbol(ISymbol symbol, CSharpCodeGenerationContextInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpCodeGenerationOptions : CodeGenerationOptions {
    private static CodeStyleOption2`1<ExpressionBodyPreference> s_neverWithSilentEnforcement;
    private static CodeStyleOption2`1<ExpressionBodyPreference> s_whenPossibleWithSilentEnforcement;
    private static CodeStyleOption2`1<NamespaceDeclarationPreference> s_blockedScopedWithSilentEnforcement;
    public static CSharpCodeGenerationOptions Default;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ExpressionBodyPreference> <PreferExpressionBodiedMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ExpressionBodyPreference> <PreferExpressionBodiedAccessors>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ExpressionBodyPreference> <PreferExpressionBodiedProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ExpressionBodyPreference> <PreferExpressionBodiedIndexers>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ExpressionBodyPreference> <PreferExpressionBodiedConstructors>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ExpressionBodyPreference> <PreferExpressionBodiedOperators>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ExpressionBodyPreference> <PreferExpressionBodiedLocalFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ExpressionBodyPreference> <PreferExpressionBodiedLambdas>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferStaticLocalFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<NamespaceDeclarationPreference> <NamespaceDeclarations>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedMethods { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedAccessors { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedProperties { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedIndexers { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedConstructors { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedOperators { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedLocalFunctions { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedLambdas { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferStaticLocalFunction { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<NamespaceDeclarationPreference> NamespaceDeclarations { get; public set; }
    internal CSharpCodeGenerationOptions(IOptionsReader options, CSharpCodeGenerationOptions fallbackOptions);
    [CompilerGeneratedAttribute]
private CSharpCodeGenerationOptions(CSharpCodeGenerationOptions original);
    private static CSharpCodeGenerationOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedMethods();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExpressionBodiedMethods(CodeStyleOption2`1<ExpressionBodyPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedAccessors();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExpressionBodiedAccessors(CodeStyleOption2`1<ExpressionBodyPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedProperties();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExpressionBodiedProperties(CodeStyleOption2`1<ExpressionBodyPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedIndexers();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExpressionBodiedIndexers(CodeStyleOption2`1<ExpressionBodyPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedConstructors();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExpressionBodiedConstructors(CodeStyleOption2`1<ExpressionBodyPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedOperators();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExpressionBodiedOperators(CodeStyleOption2`1<ExpressionBodyPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedLocalFunctions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExpressionBodiedLocalFunctions(CodeStyleOption2`1<ExpressionBodyPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedLambdas();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExpressionBodiedLambdas(CodeStyleOption2`1<ExpressionBodyPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferStaticLocalFunction();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferStaticLocalFunction(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<NamespaceDeclarationPreference> get_NamespaceDeclarations();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NamespaceDeclarations(CodeStyleOption2`1<NamespaceDeclarationPreference> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CSharpCodeGenerationOptions left, CSharpCodeGenerationOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CSharpCodeGenerationOptions left, CSharpCodeGenerationOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CodeGenerationOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CSharpCodeGenerationOptions other);
    [CompilerGeneratedAttribute]
public virtual CodeGenerationOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpCodeGenerationService : AbstractCodeGenerationService`1<CSharpCodeGenerationContextInfo> {
    public CodeGenerationOptions DefaultOptions { get; }
    public CSharpCodeGenerationService(LanguageServices languageServices);
    public virtual CodeGenerationOptions get_DefaultOptions();
    public virtual CodeGenerationOptions GetCodeGenerationOptions(IOptionsReader options, CodeGenerationOptions fallbackOptions);
    public virtual CSharpCodeGenerationContextInfo GetInfo(CodeGenerationContext context, CodeGenerationOptions options, ParseOptions parseOptions);
    public virtual CodeGenerationDestination GetDestination(SyntaxNode node);
    protected virtual IComparer`1<SyntaxNode> GetMemberComparer();
    protected virtual IList`1<bool> GetAvailableInsertionIndices(SyntaxNode destination, CancellationToken cancellationToken);
    private static IList`1<bool> GetInsertionIndices(TypeDeclarationSyntax destination, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpCodeGenerationService/<AddEventAsync>d__9")]
public virtual Task`1<Document> AddEventAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IEventSymbol event, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddEvent(TDeclarationNode destination, IEventSymbol event, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddField(TDeclarationNode destination, IFieldSymbol field, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddMethod(TDeclarationNode destination, IMethodSymbol method, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddProperty(TDeclarationNode destination, IPropertySymbol property, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddNamedType(TDeclarationNode destination, INamedTypeSymbol namedType, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddNamespace(TDeclarationNode destination, INamespaceSymbol namespace, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public virtual TDeclarationNode AddParameters(TDeclarationNode destination, IEnumerable`1<IParameterSymbol> parameters, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public virtual TDeclarationNode AddAttributes(TDeclarationNode destination, IEnumerable`1<AttributeData> attributes, Nullable`1<SyntaxToken> target, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<SyntaxNode> members);
    public virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, AttributeData attributeToRemove, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, SyntaxNode attributeToRemove, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static SyntaxList`1<AttributeListSyntax> RemoveAttributeFromAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxNode attributeToRemove, Int32& positionOfRemovedNode, SyntaxTriviaList& triviaOfRemovedNode);
    public virtual TDeclarationNode AddStatements(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static TDeclarationNode AddStatementsWorker(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static TDeclarationNode AddStatementsToBaseMethodDeclaration(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, BaseMethodDeclarationSyntax baseMethodDeclaration);
    private static TDeclarationNode AddStatementsToLocalFunctionStatement(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, LocalFunctionStatementSyntax localFunctionStatement);
    private static TDeclarationNode AddStatementsToAnonymousFunctions(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, AnonymousFunctionExpressionSyntax anonymousFunctionSyntax);
    public virtual SyntaxNode CreateEventDeclaration(IEventSymbol event, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public virtual SyntaxNode CreateFieldDeclaration(IFieldSymbol field, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public virtual SyntaxNode CreateMethodDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public virtual SyntaxNode CreatePropertyDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public virtual SyntaxNode CreateNamedTypeDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public virtual SyntaxNode CreateNamespaceDeclaration(INamespaceSymbol namespace, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode declaration, Func`2<SyntaxTokenList, SyntaxTokenList> computeNewModifiersList);
    public virtual TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode declaration, IEnumerable`1<SyntaxToken> newModifiers, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public virtual TDeclarationNode UpdateDeclarationAccessibility(TDeclarationNode declaration, Accessibility newAccessibility, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static SyntaxTokenList UpdateDeclarationAccessibility(SyntaxTokenList modifiersList, Accessibility newAccessibility, CSharpCodeGenerationContextInfo info);
    public virtual TDeclarationNode UpdateDeclarationType(TDeclarationNode declaration, ITypeSymbol newType, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public virtual TDeclarationNode UpdateDeclarationMembers(TDeclarationNode declaration, IList`1<ISymbol> newMembers, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Document> <>n__0(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IEventSymbol event, CancellationToken cancellationToken);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpCodeGenerationServiceFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpDeclarationComparer : object {
    private static Dictionary`2<SyntaxKind, int> s_kindPrecedenceMap;
    private static Dictionary`2<SyntaxKind, int> s_operatorPrecedenceMap;
    public static CSharpDeclarationComparer WithNamesInstance;
    public static CSharpDeclarationComparer WithoutNamesInstance;
    private bool _includeName;
    private CSharpDeclarationComparer(bool includeName);
    private static CSharpDeclarationComparer();
    [NullableContextAttribute("2")]
public sealed virtual int Compare(SyntaxNode x, SyntaxNode y);
    private int Compare(DelegateDeclarationSyntax x, DelegateDeclarationSyntax y);
    private int Compare(BaseFieldDeclarationSyntax x, BaseFieldDeclarationSyntax y);
    private static int Compare(ConstructorDeclarationSyntax x, ConstructorDeclarationSyntax y);
    private int Compare(MethodDeclarationSyntax x, MethodDeclarationSyntax y);
    private static int Compare(ConversionOperatorDeclarationSyntax x, ConversionOperatorDeclarationSyntax y);
    private static int Compare(OperatorDeclarationSyntax x, OperatorDeclarationSyntax y);
    private int Compare(EventDeclarationSyntax x, EventDeclarationSyntax y);
    private static int Compare(IndexerDeclarationSyntax x, IndexerDeclarationSyntax y);
    private int Compare(PropertyDeclarationSyntax x, PropertyDeclarationSyntax y);
    private int Compare(EnumDeclarationSyntax x, EnumDeclarationSyntax y);
    private int Compare(BaseTypeDeclarationSyntax x, BaseTypeDeclarationSyntax y);
    private static bool ContainsToken(SyntaxTokenList list, SyntaxKind kind);
    [NullableContextAttribute("2")]
private static int GetAccessibilityPrecedence(SyntaxTokenList modifiers, SyntaxNode parent);
    private static bool BothHaveModifier(SyntaxTokenList x, SyntaxTokenList y, SyntaxKind modifierKind, Int32& comparisonResult);
    private static bool EqualStaticness(SyntaxTokenList x, SyntaxTokenList y, Int32& comparisonResult);
    private static bool EqualConstness(SyntaxTokenList x, SyntaxTokenList y, Int32& comparisonResult);
    private static bool EqualReadOnlyness(SyntaxTokenList x, SyntaxTokenList y, Int32& comparisonResult);
    private static bool EqualAccessibility(SyntaxNode x, SyntaxTokenList xModifiers, SyntaxNode y, SyntaxTokenList yModifiers, Int32& comparisonResult);
    private static bool EqualIdentifierName(SyntaxToken x, SyntaxToken y, Int32& comparisonResult);
    private static bool EqualOperatorPrecedence(SyntaxToken x, SyntaxToken y, Int32& comparisonResult);
    private static bool EqualParameterCount(BaseParameterListSyntax x, BaseParameterListSyntax y, Int32& comparisonResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpFlagsEnumGenerator : AbstractFlagsEnumGenerator {
    public static CSharpFlagsEnumGenerator Instance;
    private static CSharpFlagsEnumGenerator();
    protected virtual SyntaxNode CreateExplicitlyCastedLiteralValue(SyntaxGenerator generator, INamedTypeSymbol enumType, SpecialType underlyingSpecialType, object constantValue);
    protected virtual bool IsValidName(INamedTypeSymbol enumType, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Editing.SyntaxGenerator", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpSyntaxGenerator : SyntaxGenerator {
    private static IdentifierNameSyntax s_nameOfIdentifier;
    public static SyntaxGenerator Instance;
    private static ConditionalWeakTable`2<SyntaxNode, IReadOnlyList`1<SyntaxNode>> s_declAttributes;
    private static ConditionalWeakTable`2<SyntaxNode, IReadOnlyList`1<SyntaxNode>> s_declReturnAttributes;
    private static DeclarationModifiers s_fieldModifiers;
    private static DeclarationModifiers s_methodModifiers;
    private static DeclarationModifiers s_constructorModifiers;
    private static DeclarationModifiers s_destructorModifiers;
    private static DeclarationModifiers s_propertyModifiers;
    private static DeclarationModifiers s_eventModifiers;
    private static DeclarationModifiers s_indexerModifiers;
    private static DeclarationModifiers s_classModifiers;
    private static DeclarationModifiers s_recordModifiers;
    private static DeclarationModifiers s_structModifiers;
    private static DeclarationModifiers s_interfaceModifiers;
    private static DeclarationModifiers s_eventAccessorModifiers;
    private static DeclarationModifiers s_propertyAccessorModifiers;
    private static DeclarationModifiers s_localFunctionModifiers;
    private static DeclarationModifiers s_lambdaModifiers;
    private static IReadOnlyList`1<SyntaxNode> s_EmptyList;
    internal SyntaxTrivia ElasticCarriageReturnLineFeed { get; }
    internal SyntaxTrivia CarriageReturnLineFeed { get; }
    internal SyntaxTrivia ElasticMarker { get; }
    internal bool RequiresExplicitImplementationForInterfaceMembers { get; }
    internal SyntaxGeneratorInternal SyntaxGeneratorInternal { get; }
    private static CSharpSyntaxGenerator();
    internal virtual SyntaxTrivia get_ElasticCarriageReturnLineFeed();
    internal virtual SyntaxTrivia get_CarriageReturnLineFeed();
    internal virtual SyntaxTrivia get_ElasticMarker();
    internal virtual bool get_RequiresExplicitImplementationForInterfaceMembers();
    internal virtual SyntaxGeneratorInternal get_SyntaxGeneratorInternal();
    internal virtual SyntaxTrivia Whitespace(string text);
    internal virtual SyntaxTrivia SingleLineComment(string text);
    [NullableContextAttribute("0")]
internal virtual SeparatedSyntaxList`1<TElement> SeparatedList(SyntaxNodeOrTokenList list);
    internal virtual SyntaxToken CreateInterpolatedStringStartToken(bool isVerbatim);
    internal virtual SyntaxToken CreateInterpolatedStringEndToken();
    internal virtual SeparatedSyntaxList`1<TElement> SeparatedList(IEnumerable`1<TElement> nodes, IEnumerable`1<SyntaxToken> separators);
    internal virtual SyntaxTrivia Trivia(SyntaxNode node);
    internal virtual SyntaxNode DocumentationCommentTrivia(IEnumerable`1<SyntaxNode> nodes, SyntaxTriviaList trailingTrivia, string endOfLineString);
    internal virtual SyntaxNode DocumentationCommentTriviaWithUpdatedContent(SyntaxTrivia trivia, IEnumerable`1<SyntaxNode> content);
    public virtual SyntaxNode CompilationUnit(IEnumerable`1<SyntaxNode> declarations);
    private SyntaxList`1<UsingDirectiveSyntax> AsUsingDirectives(IEnumerable`1<SyntaxNode> declarations);
    private SyntaxNode AsUsingDirective(SyntaxNode node);
    private static SyntaxList`1<MemberDeclarationSyntax> AsNamespaceMembers(IEnumerable`1<SyntaxNode> declarations);
    private static SyntaxNode AsNamespaceMember(SyntaxNode declaration);
    public virtual SyntaxNode NamespaceImportDeclaration(SyntaxNode name);
    public virtual SyntaxNode AliasImportDeclaration(string aliasIdentifierName, SyntaxNode name);
    public virtual SyntaxNode NamespaceDeclaration(SyntaxNode name, IEnumerable`1<SyntaxNode> declarations);
    public virtual SyntaxNode FieldDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, SyntaxNode initializer);
    private protected virtual SyntaxNode ParameterDeclaration(string name, SyntaxNode type, SyntaxNode initializer, RefKind refKind, bool isExtension, bool isParams, bool isScoped);
    internal static SyntaxToken GetArgumentModifiers(RefKind refKind);
    private protected virtual SyntaxNode MethodDeclaration(string name, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<SyntaxNode> typeParameters, SyntaxNode returnType, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> statements);
    private static string StripExplicitInterfaceName(string name);
    public virtual SyntaxNode OperatorDeclaration(OperatorKind kind, IEnumerable`1<SyntaxNode> parameters, SyntaxNode returnType, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> statements);
    private static SyntaxKind GetTokenKind(OperatorKind kind);
    private static ParameterListSyntax AsParameterList(IEnumerable`1<SyntaxNode> parameters);
    public virtual SyntaxNode ConstructorDeclaration(string name, IEnumerable`1<SyntaxNode> parameters, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> baseConstructorArguments, IEnumerable`1<SyntaxNode> statements);
    private protected virtual SyntaxNode DestructorDeclaration(IMethodSymbol destructorMethod);
    public virtual SyntaxNode PropertyDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> getAccessorStatements, IEnumerable`1<SyntaxNode> setAccessorStatements);
    private protected virtual SyntaxNode PropertyDeclaration(string name, SyntaxNode type, SyntaxNode getAccessor, SyntaxNode setAccessor, Accessibility accessibility, DeclarationModifiers modifiers);
    public virtual SyntaxNode GetAccessorDeclaration(Accessibility accessibility, IEnumerable`1<SyntaxNode> statements);
    private protected virtual SyntaxNode SetAccessorDeclaration(Accessibility accessibility, bool isInitOnly, IEnumerable`1<SyntaxNode> statements);
    private static SyntaxNode AccessorDeclaration(SyntaxKind kind, Accessibility accessibility, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode WithAccessorDeclarations(SyntaxNode declaration, IEnumerable`1<SyntaxNode> accessorDeclarations);
    private static AccessorListSyntax CreateAccessorList(AccessorListSyntax accessorList, IEnumerable`1<SyntaxNode> accessorDeclarations);
    public virtual SyntaxNode IndexerDeclaration(IEnumerable`1<SyntaxNode> parameters, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> getAccessorStatements, IEnumerable`1<SyntaxNode> setAccessorStatements);
    private static BracketedParameterListSyntax AsBracketedParameterList(IEnumerable`1<SyntaxNode> parameters);
    private static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode EventDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers);
    public virtual SyntaxNode CustomEventDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<SyntaxNode> addAccessorStatements, IEnumerable`1<SyntaxNode> removeAccessorStatements);
    public virtual SyntaxNode AsPublicInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceTypeName, string interfaceMemberName);
    public virtual SyntaxNode AsPrivateInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceTypeName, string interfaceMemberName);
    private SyntaxNode WithoutConstraints(SyntaxNode declaration);
    private static SyntaxNode WithInterfaceSpecifier(SyntaxNode declaration, ExplicitInterfaceSpecifierSyntax specifier);
    private SyntaxNode AsImplementation(SyntaxNode declaration, Accessibility requiredAccess);
    private static SyntaxNode WithBodies(SyntaxNode declaration);
    private static AccessorListSyntax WithBodies(AccessorListSyntax accessorList);
    private static AccessorDeclarationSyntax WithBody(AccessorDeclarationSyntax accessor);
    [NullableContextAttribute("2")]
private static AccessorListSyntax WithoutBodies(AccessorListSyntax accessorList);
    private static AccessorDeclarationSyntax WithoutBody(AccessorDeclarationSyntax accessor);
    private protected virtual SyntaxNode ClassDeclaration(bool isRecord, string name, IEnumerable`1<SyntaxNode> typeParameters, Accessibility accessibility, DeclarationModifiers modifiers, SyntaxNode baseType, IEnumerable`1<SyntaxNode> interfaceTypes, IEnumerable`1<SyntaxNode> members);
    private SyntaxList`1<MemberDeclarationSyntax> AsClassMembers(string className, IEnumerable`1<SyntaxNode> members);
    private MemberDeclarationSyntax AsClassMember(SyntaxNode node, string className);
    private protected virtual SyntaxNode StructDeclaration(bool isRecord, string name, IEnumerable`1<SyntaxNode> typeParameters, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> interfaceTypes, IEnumerable`1<SyntaxNode> members);
    private protected virtual SyntaxNode InterfaceDeclaration(string name, IEnumerable`1<SyntaxNode> typeParameters, Accessibility accessibility, IEnumerable`1<SyntaxNode> interfaceTypes, IEnumerable`1<SyntaxNode> members);
    private SyntaxList`1<MemberDeclarationSyntax> AsInterfaceMembers(IEnumerable`1<SyntaxNode> members);
    internal virtual SyntaxNode AsInterfaceMember(SyntaxNode m);
    public virtual SyntaxNode EnumDeclaration(string name, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> members);
    internal virtual SyntaxNode EnumDeclaration(string name, SyntaxNode underlyingType, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> members);
    public virtual SyntaxNode EnumMember(string name, SyntaxNode expression);
    private EnumMemberDeclarationSyntax AsEnumMember(SyntaxNode node);
    private SeparatedSyntaxList`1<EnumMemberDeclarationSyntax> AsEnumMembers(IEnumerable`1<SyntaxNode> members);
    private protected virtual SyntaxNode DelegateDeclaration(string name, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<SyntaxNode> typeParameters, SyntaxNode returnType, Accessibility accessibility, DeclarationModifiers modifiers);
    public virtual SyntaxNode Attribute(SyntaxNode name, IEnumerable`1<SyntaxNode> attributeArguments);
    public virtual SyntaxNode AttributeArgument(string name, SyntaxNode expression);
    [NullableContextAttribute("2")]
private static AttributeArgumentListSyntax AsAttributeArgumentList(IEnumerable`1<SyntaxNode> arguments);
    private static AttributeArgumentSyntax AsAttributeArgument(SyntaxNode node);
    public virtual TNode ClearTrivia(TNode node);
    private static SyntaxList`1<AttributeListSyntax> AsAttributeLists(IEnumerable`1<SyntaxNode> attributes);
    private static AttributeListSyntax AsAttributeList(SyntaxNode node);
    public virtual IReadOnlyList`1<SyntaxNode> GetAttributes(SyntaxNode declaration);
    public virtual IReadOnlyList`1<SyntaxNode> GetReturnAttributes(SyntaxNode declaration);
    private static bool IsReturnAttribute(AttributeListSyntax list);
    public virtual SyntaxNode InsertAttributes(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributes);
    private SyntaxNode InsertAttributesInternal(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributes);
    public virtual SyntaxNode InsertReturnAttributes(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributes);
    private SyntaxNode InsertReturnAttributesInternal(SyntaxNode d, int index, IEnumerable`1<SyntaxNode> attributes);
    private static IEnumerable`1<AttributeListSyntax> AsReturnAttributes(IEnumerable`1<SyntaxNode> attributes);
    private static SyntaxList`1<AttributeListSyntax> AsAssemblyAttributes(IEnumerable`1<AttributeListSyntax> attributes);
    private static SyntaxList`1<AttributeListSyntax> WithRequiredTargetSpecifier(SyntaxList`1<AttributeListSyntax> attributes, SyntaxNode declaration);
    public virtual IReadOnlyList`1<SyntaxNode> GetAttributeArguments(SyntaxNode attributeDeclaration);
    public virtual SyntaxNode InsertAttributeArguments(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributeArguments);
    private static SyntaxNode InsertAttributeArgumentsInternal(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributeArguments);
    private static AttributeArgumentListSyntax GetAttributeArgumentList(SyntaxNode declaration);
    private static SyntaxNode WithAttributeArgumentList(SyntaxNode declaration, AttributeArgumentListSyntax argList);
    internal static SyntaxList`1<AttributeListSyntax> GetAttributeLists(SyntaxNode declaration);
    private static SyntaxNode WithAttributeLists(SyntaxNode declaration, SyntaxList`1<AttributeListSyntax> attributeLists);
    internal virtual SyntaxNode GetPrimaryConstructorParameterList(SyntaxNode declaration);
    internal virtual ImmutableArray`1<SyntaxNode> GetTypeInheritance(SyntaxNode declaration);
    public virtual IReadOnlyList`1<SyntaxNode> GetNamespaceImports(SyntaxNode declaration);
    public virtual SyntaxNode InsertNamespaceImports(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> imports);
    private SyntaxNode InsertNamespaceImportsInternal(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> imports);
    public virtual IReadOnlyList`1<SyntaxNode> GetMembers(SyntaxNode declaration);
    private static ImmutableArray`1<SyntaxNode> Flatten(IEnumerable`1<SyntaxNode> declarations);
    private static int GetDeclarationCount(SyntaxNode declaration);
    private static SyntaxNode EnsureTypeDeclarationHasBody(SyntaxNode declaration);
    public virtual SyntaxNode InsertMembers(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> members);
    private IEnumerable`1<MemberDeclarationSyntax> AsMembersOf(SyntaxNode declaration, IEnumerable`1<SyntaxNode> members);
    private SyntaxNode AsMemberOf(SyntaxNode declaration, SyntaxNode member);
    private static bool CanHaveAccessibility(SyntaxNode declaration);
    public virtual Accessibility GetAccessibility(SyntaxNode declaration);
    private static void GetAccessibilityAndModifiers(SyntaxTokenList modifierList, Accessibility& accessibility, DeclarationModifiers& modifiers, Boolean& isDefault);
    public virtual SyntaxNode WithAccessibility(SyntaxNode declaration, Accessibility accessibility);
    private static DeclarationModifiers GetAllowedModifiers(SyntaxKind kind);
    public virtual DeclarationModifiers GetModifiers(SyntaxNode declaration);
    private static SyntaxTokenList GetModifierTokens(SyntaxNode declaration);
    public virtual SyntaxNode WithModifiers(SyntaxNode declaration, DeclarationModifiers modifiers);
    private SyntaxNode WithModifiersInternal(SyntaxNode declaration, DeclarationModifiers modifiers);
    private static SyntaxNode SetModifierTokens(SyntaxNode declaration, SyntaxTokenList modifiers);
    private static SyntaxTokenList AsModifierList(Accessibility accessibility, DeclarationModifiers modifiers, SyntaxKind kind);
    private static SyntaxTokenList AsModifierList(Accessibility accessibility, DeclarationModifiers modifiers);
    private protected virtual SyntaxNode TypeParameter(string name);
    private protected virtual SyntaxNode TypeParameter(ITypeParameterSymbol typeParameter);
    [NullableContextAttribute("2")]
private static TypeParameterListSyntax AsTypeParameterList(IEnumerable`1<SyntaxNode> typeParameterNodes);
    private protected virtual SyntaxNode WithTypeParameters(SyntaxNode declaration, IEnumerable`1<SyntaxNode> typeParameters);
    internal virtual SyntaxNode WithExplicitInterfaceImplementations(SyntaxNode declaration, ImmutableArray`1<ISymbol> explicitInterfaceImplementations, bool removeDefaults);
    private static MethodDeclarationSyntax WithoutConstraints(MethodDeclarationSyntax method);
    private static SyntaxNode RemoveDefaultValue(ParameterSyntax parameter, bool removeDefaults);
    private static ExplicitInterfaceSpecifierSyntax CreateExplicitInterfaceSpecifier(ImmutableArray`1<ISymbol> explicitInterfaceImplementations);
    private protected virtual SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kinds, bool isUnmanagedType, IEnumerable`1<SyntaxNode> types);
    private protected virtual SyntaxNode WithDefaultConstraint(SyntaxNode declaration, string typeParameterName);
    private static SyntaxList`1<TypeParameterConstraintClauseSyntax> WithTypeConstraints(SyntaxList`1<TypeParameterConstraintClauseSyntax> clauses, string typeParameterName, SpecialTypeConstraintKind kinds, bool isUnmanagedType, IEnumerable`1<SyntaxNode> types);
    public virtual DeclarationKind GetDeclarationKind(SyntaxNode declaration);
    public virtual string GetName(SyntaxNode declaration);
    public virtual SyntaxNode WithName(SyntaxNode declaration, string name);
    private SyntaxNode WithNameInternal(SyntaxNode declaration, string name);
    public virtual SyntaxNode GetType(SyntaxNode declaration);
    private static TypeSyntax NotVoid(TypeSyntax type);
    public virtual SyntaxNode WithType(SyntaxNode declaration, SyntaxNode type);
    private static SyntaxNode WithTypeInternal(SyntaxNode declaration, SyntaxNode type);
    private SyntaxNode Isolate(SyntaxNode declaration, Func`2<SyntaxNode, SyntaxNode> editor);
    private SyntaxNode AsIsolatedDeclaration(SyntaxNode declaration);
    private static SyntaxNode WithVariable(SyntaxNode declaration, VariableDeclaratorSyntax variable);
    private static VariableDeclarationSyntax GetVariableDeclaration(SyntaxNode declaration);
    private static SyntaxNode WithVariableDeclaration(SyntaxNode declaration, VariableDeclarationSyntax variables);
    private static SyntaxNode GetFullDeclaration(SyntaxNode declaration);
    private SyntaxNode AsNodeLike(SyntaxNode existingNode, SyntaxNode newNode);
    public virtual IReadOnlyList`1<SyntaxNode> GetParameters(SyntaxNode declaration);
    public virtual SyntaxNode InsertParameters(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> parameters);
    public virtual IReadOnlyList`1<SyntaxNode> GetSwitchSections(SyntaxNode switchStatement);
    public virtual SyntaxNode InsertSwitchSections(SyntaxNode switchStatement, int index, IEnumerable`1<SyntaxNode> switchSections);
    private static TNode AddMissingTokens(TNode node, bool recurse);
    internal virtual SyntaxNode GetParameterListNode(SyntaxNode declaration);
    private static SyntaxNode WithParameterList(SyntaxNode declaration, BaseParameterListSyntax list);
    public virtual SyntaxNode GetExpression(SyntaxNode declaration);
    public virtual SyntaxNode WithExpression(SyntaxNode declaration, SyntaxNode expression);
    private static SyntaxNode WithExpressionInternal(SyntaxNode declaration, SyntaxNode expression);
    private static EqualsValueClauseSyntax GetEqualsValue(SyntaxNode declaration);
    private static SyntaxNode WithEqualsValue(SyntaxNode declaration, EqualsValueClauseSyntax initializer);
    public virtual IReadOnlyList`1<SyntaxNode> GetStatements(SyntaxNode declaration);
    public virtual SyntaxNode WithStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    public virtual IReadOnlyList`1<SyntaxNode> GetAccessors(SyntaxNode declaration);
    public virtual SyntaxNode InsertAccessors(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> accessors);
    internal static AccessorListSyntax GetAccessorList(SyntaxNode declaration);
    private static bool CanHaveAccessors(SyntaxNode declaration);
    private static SyntaxNode WithAccessorList(SyntaxNode declaration, AccessorListSyntax accessorList);
    private static AccessorListSyntax AsAccessorList(IEnumerable`1<SyntaxNode> nodes, SyntaxKind parentKind);
    private static AccessorDeclarationSyntax AsAccessor(SyntaxNode node, SyntaxKind parentKind);
    private static AccessorDeclarationSyntax GetAccessor(SyntaxNode declaration, SyntaxKind kind);
    private SyntaxNode WithAccessor(SyntaxNode declaration, SyntaxKind kind, AccessorDeclarationSyntax accessor);
    private SyntaxNode WithAccessor(SyntaxNode declaration, AccessorListSyntax accessorList, SyntaxKind kind, AccessorDeclarationSyntax accessor);
    public virtual IReadOnlyList`1<SyntaxNode> GetGetAccessorStatements(SyntaxNode declaration);
    public virtual IReadOnlyList`1<SyntaxNode> GetSetAccessorStatements(SyntaxNode declaration);
    public virtual SyntaxNode WithGetAccessorStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode WithSetAccessorStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    private SyntaxNode WithAccessorStatements(SyntaxNode declaration, SyntaxKind kind, IEnumerable`1<SyntaxNode> statements);
    public virtual IReadOnlyList`1<SyntaxNode> GetBaseAndInterfaceTypes(SyntaxNode declaration);
    public virtual SyntaxNode AddBaseType(SyntaxNode declaration, SyntaxNode baseType);
    public virtual SyntaxNode AddInterfaceType(SyntaxNode declaration, SyntaxNode interfaceType);
    private static SyntaxNode AddBaseList(SyntaxNode declaration, BaseListSyntax baseList);
    private static BaseListSyntax GetBaseList(SyntaxNode declaration);
    private static SyntaxNode WithBaseList(SyntaxNode declaration, BaseListSyntax baseList);
    public virtual SyntaxNode ReplaceNode(SyntaxNode root, SyntaxNode declaration, SyntaxNode newDeclaration);
    private static bool AreInlineReplaceableSubDeclarations(SyntaxNode decl1, SyntaxNode decl2);
    [NullableContextAttribute("2")]
private static bool AreSimilarExceptForSubDeclarations(SyntaxNode decl1, SyntaxNode decl2);
    private IEnumerable`1<SyntaxNode> SplitAndReplace(SyntaxNode multiPartDeclaration, int index, IEnumerable`1<SyntaxNode> newDeclarations);
    public virtual SyntaxNode InsertNodesBefore(SyntaxNode root, SyntaxNode declaration, IEnumerable`1<SyntaxNode> newDeclarations);
    private SyntaxNode InsertNodesBeforeInternal(SyntaxNode root, SyntaxNode declaration, IEnumerable`1<SyntaxNode> newDeclarations);
    public virtual SyntaxNode InsertNodesAfter(SyntaxNode root, SyntaxNode declaration, IEnumerable`1<SyntaxNode> newDeclarations);
    private SyntaxNode InsertNodesAfterInternal(SyntaxNode root, SyntaxNode declaration, IEnumerable`1<SyntaxNode> newDeclarations);
    private IEnumerable`1<SyntaxNode> SplitAndInsert(SyntaxNode multiPartDeclaration, int index, IEnumerable`1<SyntaxNode> newDeclarations);
    private SyntaxNode WithSubDeclarationsRemoved(SyntaxNode declaration, int index, int count);
    private static IReadOnlyList`1<SyntaxNode> GetSubDeclarations(SyntaxNode declaration);
    public virtual SyntaxNode RemoveNode(SyntaxNode root, SyntaxNode node);
    public virtual SyntaxNode RemoveNode(SyntaxNode root, SyntaxNode node, SyntaxRemoveOptions options);
    private SyntaxNode RemoveNodeInternal(SyntaxNode root, SyntaxNode declaration, SyntaxRemoveOptions options);
    private static SyntaxNode ShiftTrivia(SyntaxNode root, SyntaxNode node);
    internal virtual bool IsRegularOrDocComment(SyntaxTrivia trivia);
    public virtual SyntaxNode AddEventHandler(SyntaxNode event, SyntaxNode handler);
    public virtual SyntaxNode RemoveEventHandler(SyntaxNode event, SyntaxNode handler);
    public virtual SyntaxNode AwaitExpression(SyntaxNode expression);
    public virtual SyntaxNode NameOfExpression(SyntaxNode expression);
    public virtual SyntaxNode ReturnStatement(SyntaxNode expression);
    public virtual SyntaxNode ThrowStatement(SyntaxNode expression);
    public virtual SyntaxNode ThrowExpression(SyntaxNode expression);
    internal virtual bool SupportsThrowExpression();
    public virtual SyntaxNode IfStatement(SyntaxNode condition, IEnumerable`1<SyntaxNode> trueStatements, IEnumerable`1<SyntaxNode> falseStatements);
    private static BlockSyntax CreateBlock(IEnumerable`1<SyntaxNode> statements);
    private static SyntaxList`1<StatementSyntax> AsStatementList(IEnumerable`1<SyntaxNode> nodes);
    private static StatementSyntax AsStatement(SyntaxNode node);
    public virtual SyntaxNode ExpressionStatement(SyntaxNode expression);
    internal virtual SyntaxNode MemberAccessExpressionWorker(SyntaxNode expression, SyntaxNode simpleName);
    public virtual SyntaxNode ConditionalAccessExpression(SyntaxNode expression, SyntaxNode whenNotNull);
    public virtual SyntaxNode MemberBindingExpression(SyntaxNode name);
    public virtual SyntaxNode ElementBindingExpression(IEnumerable`1<SyntaxNode> arguments);
    private static ExpressionSyntax ParenthesizeLeft(ExpressionSyntax expression);
    private static SeparatedSyntaxList`1<ExpressionSyntax> AsExpressionList(IEnumerable`1<SyntaxNode> expressions);
    public virtual SyntaxNode ArrayCreationExpression(SyntaxNode elementType, SyntaxNode size);
    public virtual SyntaxNode ArrayCreationExpression(SyntaxNode elementType, IEnumerable`1<SyntaxNode> elements);
    public virtual SyntaxNode ObjectCreationExpression(SyntaxNode type, IEnumerable`1<SyntaxNode> arguments);
    internal virtual SyntaxNode ObjectCreationExpression(SyntaxNode type, SyntaxToken openParen, SeparatedSyntaxList`1<SyntaxNode> arguments, SyntaxToken closeParen);
    private static ArgumentListSyntax CreateArgumentList(IEnumerable`1<SyntaxNode> arguments);
    private static SeparatedSyntaxList`1<ArgumentSyntax> CreateArguments(IEnumerable`1<SyntaxNode> arguments);
    private static ArgumentSyntax AsArgument(SyntaxNode argOrExpression);
    public virtual SyntaxNode InvocationExpression(SyntaxNode expression, IEnumerable`1<SyntaxNode> arguments);
    public virtual SyntaxNode ElementAccessExpression(SyntaxNode expression, IEnumerable`1<SyntaxNode> arguments);
    internal virtual SyntaxToken NumericLiteralToken(string text, ulong value);
    public virtual SyntaxNode DefaultExpression(SyntaxNode type);
    public virtual SyntaxNode DefaultExpression(ITypeSymbol type);
    private static SyntaxNode Parenthesize(SyntaxNode expression, bool includeElasticTrivia, bool addSimplifierAnnotation);
    public virtual SyntaxNode IsTypeExpression(SyntaxNode expression, SyntaxNode type);
    public virtual SyntaxNode TypeOfExpression(SyntaxNode type);
    public virtual SyntaxNode TryCastExpression(SyntaxNode expression, SyntaxNode type);
    public virtual SyntaxNode CastExpression(SyntaxNode type, SyntaxNode expression);
    public virtual SyntaxNode ConvertExpression(SyntaxNode type, SyntaxNode expression);
    public virtual SyntaxNode AssignmentStatement(SyntaxNode left, SyntaxNode right);
    private static SyntaxNode CreateBinaryExpression(SyntaxKind syntaxKind, SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ValueEqualsExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ReferenceEqualsExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ValueNotEqualsExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ReferenceNotEqualsExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode LessThanExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode LessThanOrEqualExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode GreaterThanExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode GreaterThanOrEqualExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode NegateExpression(SyntaxNode expression);
    public virtual SyntaxNode AddExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode SubtractExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode MultiplyExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode DivideExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ModuloExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode BitwiseAndExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode BitwiseOrExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode BitwiseNotExpression(SyntaxNode operand);
    public virtual SyntaxNode LogicalAndExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode LogicalOrExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode LogicalNotExpression(SyntaxNode expression);
    public virtual SyntaxNode ConditionalExpression(SyntaxNode condition, SyntaxNode whenTrue, SyntaxNode whenFalse);
    public virtual SyntaxNode CoalesceExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ThisExpression();
    public virtual SyntaxNode BaseExpression();
    public virtual SyntaxNode TypedConstantExpression(TypedConstant value);
    [NullableContextAttribute("2")]
private protected virtual SyntaxNode GenerateExpression(ITypeSymbol type, object value, bool canUseFieldReference);
    public virtual SyntaxNode IdentifierName(string identifier);
    public virtual SyntaxNode GenericName(string identifier, IEnumerable`1<SyntaxNode> typeArguments);
    internal virtual SyntaxNode GenericName(SyntaxToken identifier, IEnumerable`1<SyntaxNode> typeArguments);
    public virtual SyntaxNode WithTypeArguments(SyntaxNode expression, IEnumerable`1<SyntaxNode> typeArguments);
    public virtual SyntaxNode QualifiedName(SyntaxNode left, SyntaxNode right);
    internal virtual SyntaxNode GlobalAliasedName(SyntaxNode name);
    public virtual SyntaxNode NameExpression(INamespaceOrTypeSymbol namespaceOrTypeSymbol);
    private protected virtual SyntaxNode TypeExpression(ITypeSymbol typeSymbol, RefKind refKind);
    public virtual SyntaxNode TypeExpression(SpecialType specialType);
    public virtual SyntaxNode ArrayTypeExpression(SyntaxNode type);
    public virtual SyntaxNode NullableTypeExpression(SyntaxNode type);
    internal virtual SyntaxNode CreateTupleType(IEnumerable`1<SyntaxNode> elements);
    public virtual SyntaxNode TupleElementExpression(SyntaxNode type, string name);
    public virtual SyntaxNode Argument(string name, RefKind refKind, SyntaxNode expression);
    public virtual SyntaxNode LocalDeclarationStatement(SyntaxNode type, string name, SyntaxNode initializer, bool isConst);
    public virtual SyntaxNode UsingStatement(SyntaxNode type, string name, SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode UsingStatement(SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode LockStatement(SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode TryCatchStatement(IEnumerable`1<SyntaxNode> tryStatements, IEnumerable`1<SyntaxNode> catchClauses, IEnumerable`1<SyntaxNode> finallyStatements);
    public virtual SyntaxNode CatchClause(SyntaxNode type, string name, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode WhileStatement(SyntaxNode condition, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode SwitchStatement(SyntaxNode expression, IEnumerable`1<SyntaxNode> caseClauses);
    public virtual SyntaxNode SwitchSection(IEnumerable`1<SyntaxNode> expressions, IEnumerable`1<SyntaxNode> statements);
    internal virtual SyntaxNode SwitchSectionFromLabels(IEnumerable`1<SyntaxNode> labels, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode DefaultSwitchSection(IEnumerable`1<SyntaxNode> statements);
    private static SyntaxList`1<SwitchLabelSyntax> AsSwitchLabels(IEnumerable`1<SyntaxNode> expressions);
    public virtual SyntaxNode ExitSwitchStatement();
    internal virtual SyntaxNode ScopeBlock(IEnumerable`1<SyntaxNode> statements);
    internal virtual SyntaxNode GlobalStatement(SyntaxNode statement);
    public virtual SyntaxNode ValueReturningLambdaExpression(IEnumerable`1<SyntaxNode> parameterDeclarations, SyntaxNode expression);
    private static bool IsSimpleLambdaParameter(SyntaxNode node);
    public virtual SyntaxNode VoidReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, SyntaxNode expression);
    public virtual SyntaxNode ValueReturningLambdaExpression(IEnumerable`1<SyntaxNode> parameterDeclarations, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode VoidReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode LambdaParameter(string identifier, SyntaxNode type);
    internal virtual SyntaxNode IdentifierName(SyntaxToken identifier);
    internal virtual SyntaxNode NamedAnonymousObjectMemberDeclarator(SyntaxNode identifier, SyntaxNode expression);
    public virtual SyntaxNode TupleExpression(IEnumerable`1<SyntaxNode> arguments);
    internal virtual SyntaxNode RemoveAllComments(SyntaxNode node);
    internal virtual SyntaxTriviaList RemoveCommentLines(SyntaxTriviaList syntaxTriviaList);
    internal virtual SyntaxNode ParseExpression(string stringToParse);
    [CompilerGeneratedAttribute]
private SyntaxNode <AsInterfaceMember>b__68_0(SyntaxNode member);
    [CompilerGeneratedAttribute]
internal static void <Flatten>g__FlattenDeclaration|107_0(ArrayBuilder`1<SyntaxNode> builder, SyntaxNode declaration, VariableDeclarationSyntax variableDeclaration);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpSyntaxGenerator/<<RemoveCommentLines>g__splitIntoLines|323_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<IEnumerable`1<SyntaxTrivia>> <RemoveCommentLines>g__splitIntoLines|323_0(SyntaxTriviaList triviaList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpSyntaxGeneratorInternal : SyntaxGeneratorInternal {
    public static SyntaxGeneratorInternal Instance;
    public ISyntaxFacts SyntaxFacts { get; }
    private static CSharpSyntaxGeneratorInternal();
    public virtual ISyntaxFacts get_SyntaxFacts();
    public virtual SyntaxTrivia EndOfLine(string text);
    [NullableContextAttribute("2")]
public virtual SyntaxNode LocalDeclarationStatement(SyntaxNode type, SyntaxToken name, SyntaxNode initializer, bool isConst);
    public virtual SyntaxNode WithInitializer(SyntaxNode variableDeclarator, SyntaxNode initializer);
    public virtual SyntaxNode EqualsValueClause(SyntaxToken operatorToken, SyntaxNode value);
    [NullableContextAttribute("2")]
internal static VariableDeclarationSyntax VariableDeclaration(SyntaxNode type, SyntaxToken name, SyntaxNode expression);
    public virtual SyntaxToken Identifier(string identifier);
    public virtual SyntaxNode ConditionalAccessExpression(SyntaxNode expression, SyntaxNode whenNotNull);
    public virtual SyntaxNode MemberBindingExpression(SyntaxNode name);
    public virtual SyntaxNode RefExpression(SyntaxNode expression);
    public virtual SyntaxNode AddParentheses(SyntaxNode expressionOrPattern, bool includeElasticTrivia, bool addSimplifierAnnotation);
    internal static SyntaxNode Parenthesize(SyntaxNode expressionOrPattern, bool includeElasticTrivia, bool addSimplifierAnnotation);
    public virtual SyntaxNode YieldReturnStatement(SyntaxNode expression);
    public virtual bool RequiresLocalDeclarationType();
    public virtual SyntaxNode InterpolatedStringExpression(SyntaxToken startToken, IEnumerable`1<SyntaxNode> content, SyntaxToken endToken);
    public virtual SyntaxNode InterpolatedStringText(SyntaxToken textToken);
    public virtual SyntaxToken InterpolatedStringTextToken(string content, string value);
    public virtual SyntaxNode Interpolation(SyntaxNode syntaxNode);
    public virtual SyntaxNode InterpolationAlignmentClause(SyntaxNode alignment);
    public virtual SyntaxNode InterpolationFormatClause(string format);
    public virtual SyntaxNode TypeParameterList(IEnumerable`1<string> typeParameterNames);
    internal static SyntaxTokenList GetParameterModifiers(RefKind refKind, bool forFunctionPointerReturnParameter);
    public virtual SyntaxNode Type(ITypeSymbol typeSymbol, bool typeContext);
    public virtual SyntaxNode NegateEquality(SyntaxGenerator generator, SyntaxNode binaryExpression, SyntaxNode left, BinaryOperatorKind negatedKind, SyntaxNode right);
    public virtual SyntaxNode IsNotTypeExpression(SyntaxNode expression, SyntaxNode type);
    public virtual bool SupportsPatterns(ParseOptions options);
    public virtual SyntaxNode IsPatternExpression(SyntaxNode expression, SyntaxToken isKeyword, SyntaxNode pattern);
    public virtual SyntaxNode AndPattern(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ConstantPattern(SyntaxNode expression);
    public virtual SyntaxNode DeclarationPattern(INamedTypeSymbol type, string name);
    public virtual SyntaxNode LessThanRelationalPattern(SyntaxNode expression);
    public virtual SyntaxNode LessThanEqualsRelationalPattern(SyntaxNode expression);
    public virtual SyntaxNode GreaterThanRelationalPattern(SyntaxNode expression);
    public virtual SyntaxNode GreaterThanEqualsRelationalPattern(SyntaxNode expression);
    public virtual SyntaxNode NotPattern(SyntaxNode pattern);
    public virtual SyntaxNode OrPattern(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ParenthesizedPattern(SyntaxNode pattern);
    public virtual SyntaxNode TypePattern(SyntaxNode type);
    public virtual SyntaxNode UnaryPattern(SyntaxToken operatorToken, SyntaxNode pattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.DestructorGenerator : object {
    [NullableContextAttribute("2")]
private static MemberDeclarationSyntax LastConstructorOrField(SyntaxList`1<MemberDeclarationSyntax> members);
    internal static TypeDeclarationSyntax AddDestructorTo(TypeDeclarationSyntax destination, IMethodSymbol destructor, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static DestructorDeclarationSyntax GenerateDestructorDeclaration(IMethodSymbol destructor, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static BlockSyntax GenerateBlock(IMethodSymbol constructor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.EnumMemberGenerator : object {
    internal static EnumDeclarationSyntax AddEnumMemberTo(EnumDeclarationSyntax destination, IFieldSymbol enumMember, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public static EnumMemberDeclarationSyntax GenerateEnumMemberDeclaration(IFieldSymbol enumMember, EnumDeclarationSyntax destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static ExpressionSyntax CreateEnumMemberValue(SyntaxGenerator generator, EnumDeclarationSyntax destination, IFieldSymbol enumMember);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.EventGenerator : object {
    private static MemberDeclarationSyntax AfterMember(SyntaxList`1<MemberDeclarationSyntax> members, MemberDeclarationSyntax eventDeclaration);
    private static MemberDeclarationSyntax BeforeMember(SyntaxList`1<MemberDeclarationSyntax> members, MemberDeclarationSyntax eventDeclaration);
    internal static CompilationUnitSyntax AddEventTo(CompilationUnitSyntax destination, IEventSymbol event, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static TypeDeclarationSyntax AddEventTo(TypeDeclarationSyntax destination, IEventSymbol event, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static MemberDeclarationSyntax GenerateEventDeclaration(IEventSymbol event, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static MemberDeclarationSyntax GenerateEventFieldDeclaration(IEventSymbol event, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static MemberDeclarationSyntax GenerateEventDeclarationWorker(IEventSymbol event, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static AccessorListSyntax GenerateAccessorList(IEventSymbol event, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static AccessorDeclarationSyntax GenerateAccessorDeclaration(IEventSymbol event, IMethodSymbol accessor, SyntaxKind kind, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static AccessorDeclarationSyntax GenerateAccessorDeclaration(IMethodSymbol accessor, SyntaxKind kind, bool hasBody);
    private static BlockSyntax GenerateBlock(IMethodSymbol accessor);
    private static bool HasAccessorBodies(IEventSymbol event, CodeGenerationDestination destination, IMethodSymbol accessor);
    private static SyntaxTokenList GenerateModifiers(IEventSymbol event, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.ExpressionGenerator : object {
    public static ExpressionSyntax GenerateExpression(SyntaxGenerator generator, TypedConstant typedConstant);
    private static ExpressionSyntax GenerateNullLiteral();
    internal static ExpressionSyntax GenerateExpression(SyntaxGenerator generator, ITypeSymbol type, object value, bool canUseFieldReference);
    internal static ExpressionSyntax GenerateNonEnumValueExpression(SyntaxGenerator generator, ITypeSymbol type, object value, bool canUseFieldReference);
    private static ExpressionSyntax GenerateBooleanLiteralExpression(bool val);
    private static ExpressionSyntax GenerateStringLiteralExpression(string val);
    private static ExpressionSyntax GenerateCharLiteralExpression(char val);
    private static string DetermineSuffix(ITypeSymbol type, object value);
    private static ExpressionSyntax GenerateDoubleLiteralExpression(ITypeSymbol type, double value, bool canUseFieldReference);
    private static ExpressionSyntax GenerateSingleLiteralExpression(ITypeSymbol type, float value, bool canUseFieldReference);
    private static ExpressionSyntax GenerateNonNegativeLiteralExpression(ITypeSymbol type, T value, IEnumerable`1<KeyValuePair`2<T, string>> constants, string formatString, bool canUseFieldReference, Func`3<string, T, SyntaxToken> tokenFactory);
    private static ExpressionSyntax GenerateLiteralExpression(ITypeSymbol type, T value, IEnumerable`1<KeyValuePair`2<T, string>> constants, string formatString, bool canUseFieldReference, Func`3<string, T, SyntaxToken> tokenFactory, Func`2<T, bool> isNegative, Func`2<T, T> negate, string integerMinValueString);
    private static ExpressionSyntax GenerateFieldReference(ITypeSymbol type, T value, IEnumerable`1<KeyValuePair`2<T, string>> constants);
    private static ExpressionSyntax GenerateMemberAccess(String[] names);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.FieldGenerator : object {
    private static MemberDeclarationSyntax LastField(SyntaxList`1<MemberDeclarationSyntax> members, FieldDeclarationSyntax fieldDeclaration);
    internal static CompilationUnitSyntax AddFieldTo(CompilationUnitSyntax destination, IFieldSymbol field, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static TypeDeclarationSyntax AddFieldTo(TypeDeclarationSyntax destination, IFieldSymbol field, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static FieldDeclarationSyntax GenerateFieldDeclaration(IFieldSymbol field, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static EqualsValueClauseSyntax GenerateEqualsValue(SyntaxGenerator generator, IFieldSymbol field);
    private static SyntaxTokenList GenerateModifiers(IFieldSymbol field, CSharpCodeGenerationContextInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.MethodGenerator : object {
    private static TypeParameterConstraintSyntax s_classConstraint;
    private static TypeParameterConstraintSyntax s_structConstraint;
    private static TypeParameterConstraintSyntax s_defaultConstraint;
    private static MethodGenerator();
    internal static BaseNamespaceDeclarationSyntax AddMethodTo(BaseNamespaceDeclarationSyntax destination, IMethodSymbol method, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static CompilationUnitSyntax AddMethodTo(CompilationUnitSyntax destination, IMethodSymbol method, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static TypeDeclarationSyntax AddMethodTo(TypeDeclarationSyntax destination, IMethodSymbol method, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static MethodDeclarationSyntax GenerateMethodDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public static LocalFunctionStatementSyntax GenerateLocalFunctionDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static MethodDeclarationSyntax GenerateMethodDeclarationWorker(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static LocalFunctionStatementSyntax GenerateLocalFunctionDeclarationWorker(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static MethodDeclarationSyntax UseExpressionBodyIfDesired(CSharpCodeGenerationContextInfo info, MethodDeclarationSyntax methodDeclaration, CancellationToken cancellationToken);
    private static LocalFunctionStatementSyntax UseExpressionBodyIfDesired(CSharpCodeGenerationContextInfo info, LocalFunctionStatementSyntax localFunctionDeclaration, CancellationToken cancellationToken);
    private static SyntaxList`1<AttributeListSyntax> GenerateAttributes(IMethodSymbol method, CSharpCodeGenerationContextInfo info, bool isExplicit);
    private static SyntaxList`1<TypeParameterConstraintClauseSyntax> GenerateConstraintClauses(IMethodSymbol method);
    private static SyntaxList`1<TypeParameterConstraintClauseSyntax> GenerateDefaultConstraints(IMethodSymbol method);
    private static TypeParameterListSyntax GenerateTypeParameterList(IMethodSymbol method, CSharpCodeGenerationContextInfo info);
    private static SyntaxTokenList GenerateModifiers(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.NamedTypeGenerator : object {
    public static TypeDeclarationSyntax AddNamedTypeTo(ICodeGenerationService service, TypeDeclarationSyntax destination, INamedTypeSymbol namedType, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static BaseNamespaceDeclarationSyntax AddNamedTypeTo(ICodeGenerationService service, BaseNamespaceDeclarationSyntax destination, INamedTypeSymbol namedType, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static CompilationUnitSyntax AddNamedTypeTo(ICodeGenerationService service, CompilationUnitSyntax destination, INamedTypeSymbol namedType, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static MemberDeclarationSyntax GenerateNamedTypeDeclaration(ICodeGenerationService service, INamedTypeSymbol namedType, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static RecordDeclarationSyntax GenerateRecordMembers(ICodeGenerationService service, CSharpCodeGenerationContextInfo info, RecordDeclarationSyntax recordDeclaration, ImmutableArray`1<ISymbol> members, CancellationToken cancellationToken);
    public static MemberDeclarationSyntax UpdateNamedTypeDeclaration(ICodeGenerationService service, MemberDeclarationSyntax declaration, IList`1<ISymbol> newMembers, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static MemberDeclarationSyntax GetDeclarationSyntaxWithoutMembers(INamedTypeSymbol namedType, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static MemberDeclarationSyntax RemoveAllMembers(MemberDeclarationSyntax declaration);
    private static MemberDeclarationSyntax GetDeclarationSyntaxWithoutMembersWorker(INamedTypeSymbol namedType, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static DelegateDeclarationSyntax GenerateDelegateDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static EnumDeclarationSyntax GenerateEnumDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static SyntaxList`1<AttributeListSyntax> GenerateAttributeDeclarations(INamedTypeSymbol namedType, CSharpCodeGenerationContextInfo info);
    private static SyntaxTokenList GenerateModifiers(INamedTypeSymbol namedType, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static TypeParameterListSyntax GenerateTypeParameterList(INamedTypeSymbol namedType, CSharpCodeGenerationContextInfo info);
    private static BaseListSyntax GenerateBaseList(INamedTypeSymbol namedType);
    private static SyntaxList`1<TypeParameterConstraintClauseSyntax> GenerateConstraintClauses(INamedTypeSymbol namedType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.NamespaceGenerator : object {
    public static BaseNamespaceDeclarationSyntax AddNamespaceTo(ICodeGenerationService service, BaseNamespaceDeclarationSyntax destination, INamespaceSymbol namespace, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static CompilationUnitSyntax AddNamespaceTo(ICodeGenerationService service, CompilationUnitSyntax destination, INamespaceSymbol namespace, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static SyntaxNode GenerateNamespaceDeclaration(ICodeGenerationService service, INamespaceSymbol namespace, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public static SyntaxNode UpdateCompilationUnitOrNamespaceDeclaration(ICodeGenerationService service, SyntaxNode declaration, IList`1<ISymbol> newMembers, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static SyntaxNode GenerateNamespaceDeclarationWorker(string name, INamespaceSymbol innermostNamespace, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static SyntaxNode GetDeclarationSyntaxWithoutMembers(INamespaceSymbol namespace, INamespaceSymbol innermostNamespace, string name, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static SyntaxNode RemoveAllMembers(SyntaxNode declaration);
    private static SyntaxList`1<UsingDirectiveSyntax> GenerateUsingDirectives(INamespaceSymbol innermostNamespace);
    private static UsingDirectiveSyntax GenerateUsingDirective(ISymbol symbol);
    private static NameSyntax GenerateName(INamespaceOrTypeSymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.OperatorGenerator : object {
    internal static TypeDeclarationSyntax AddOperatorTo(TypeDeclarationSyntax destination, IMethodSymbol method, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static OperatorDeclarationSyntax GenerateOperatorDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static OperatorDeclarationSyntax UseExpressionBodyIfDesired(CSharpCodeGenerationContextInfo info, OperatorDeclarationSyntax declaration, CancellationToken cancellationToken);
    private static OperatorDeclarationSyntax GenerateOperatorDeclarationWorker(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static SyntaxTokenList GenerateModifiers(IMethodSymbol method, CodeGenerationDestination destination, bool hasNoBody);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.ParameterGenerator : object {
    public static ParameterListSyntax GenerateParameterList(ImmutableArray`1<IParameterSymbol> parameterDefinitions, bool isExplicit, CSharpCodeGenerationContextInfo info);
    public static BracketedParameterListSyntax GenerateBracketedParameterList(ImmutableArray`1<IParameterSymbol> parameterDefinitions, bool isExplicit, CSharpCodeGenerationContextInfo info);
    internal static ImmutableArray`1<ParameterSyntax> GetParameters(ImmutableArray`1<IParameterSymbol> parameterDefinitions, bool isExplicit, CSharpCodeGenerationContextInfo info);
    internal static ParameterSyntax GetParameter(IParameterSymbol parameter, CSharpCodeGenerationContextInfo info, bool isExplicit, bool isFirstParam, bool seenOptional);
    private static SyntaxTokenList GenerateModifiers(IParameterSymbol parameter, bool isFirstParam);
    private static EqualsValueClauseSyntax GenerateEqualsValueClause(SyntaxGenerator generator, IParameterSymbol parameter, bool isExplicit, bool seenOptional);
    private static ExpressionSyntax GenerateEqualsValueClauseWorker(SyntaxGenerator generator, IParameterSymbol parameter, object value);
    private static SyntaxList`1<AttributeListSyntax> GenerateAttributes(IParameterSymbol parameter, bool isExplicit, CSharpCodeGenerationContextInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.PropertyGenerator : object {
    public static bool CanBeGenerated(IPropertySymbol property);
    [NullableContextAttribute("2")]
private static MemberDeclarationSyntax LastPropertyOrField(SyntaxList`1<MemberDeclarationSyntax> members);
    internal static CompilationUnitSyntax AddPropertyTo(CompilationUnitSyntax destination, IPropertySymbol property, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static TypeDeclarationSyntax AddPropertyTo(TypeDeclarationSyntax destination, IPropertySymbol property, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static MemberDeclarationSyntax GeneratePropertyOrIndexer(IPropertySymbol property, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static MemberDeclarationSyntax GenerateIndexerDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static MemberDeclarationSyntax GeneratePropertyDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static TypeSyntax GenerateTypeSyntax(IPropertySymbol property);
    private static bool TryGetExpressionBody(BasePropertyDeclarationSyntax baseProperty, LanguageVersion languageVersion, ExpressionBodyPreference preference, CancellationToken cancellationToken, ArrowExpressionClauseSyntax& arrowExpression, SyntaxToken& semicolonToken);
    private static PropertyDeclarationSyntax UseExpressionBodyIfDesired(CSharpCodeGenerationContextInfo info, PropertyDeclarationSyntax declaration, CancellationToken cancellationToken);
    private static IndexerDeclarationSyntax UseExpressionBodyIfDesired(CSharpCodeGenerationContextInfo info, IndexerDeclarationSyntax declaration, CancellationToken cancellationToken);
    private static AccessorDeclarationSyntax UseExpressionBodyIfDesired(CSharpCodeGenerationContextInfo info, AccessorDeclarationSyntax declaration, CancellationToken cancellationToken);
    private static bool TryGetArrowExpressionBody(SyntaxKind declarationKind, AccessorDeclarationSyntax accessor, LanguageVersion languageVersion, ExpressionBodyPreference preference, CancellationToken cancellationToken, ArrowExpressionClauseSyntax& arrowExpression, SyntaxToken& semicolonToken);
    private static AccessorListSyntax GenerateAccessorList(IPropertySymbol property, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static AccessorDeclarationSyntax GenerateAccessorDeclaration(IPropertySymbol property, IMethodSymbol accessor, SyntaxKind kind, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static AccessorDeclarationSyntax GenerateAccessorDeclaration(IPropertySymbol property, IMethodSymbol accessor, SyntaxKind kind, bool hasBody, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static BlockSyntax GenerateBlock(IMethodSymbol accessor);
    private static bool HasAccessorBodies(IPropertySymbol property, CodeGenerationDestination destination, IMethodSymbol accessor);
    private static SyntaxTokenList GenerateAccessorModifiers(IPropertySymbol property, IMethodSymbol accessor, CSharpCodeGenerationContextInfo info);
    private static SyntaxTokenList GenerateModifiers(IPropertySymbol property, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.StatementGenerator : object {
    internal static SyntaxList`1<StatementSyntax> GenerateStatements(IEnumerable`1<SyntaxNode> statements);
    internal static BlockSyntax GenerateBlock(IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.TypeParameterGenerator : object {
    public static TypeParameterListSyntax GenerateTypeParameterList(ImmutableArray`1<ITypeParameterSymbol> typeParameters, CSharpCodeGenerationContextInfo info);
    private static TypeParameterSyntax GenerateTypeParameter(ITypeParameterSymbol symbol, CSharpCodeGenerationContextInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeStyle.CSharpCodeStyleOptionGroups : object {
    public static OptionGroup VarPreferences;
    public static OptionGroup ExpressionBodiedMembers;
    public static OptionGroup PatternMatching;
    public static OptionGroup NullCheckingPreferences;
    public static OptionGroup CodeBlockPreferences;
    public static OptionGroup UsingDirectivePreferences;
    private static CSharpCodeStyleOptionGroups();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeStyle.CSharpCodeStyleOptions : object {
    private static Builder<IOption2> s_allOptionsBuilder;
    public static Option2`1<CodeStyleOption2`1<bool>> VarForBuiltInTypes;
    public static Option2`1<CodeStyleOption2`1<bool>> VarWhenTypeIsApparent;
    public static Option2`1<CodeStyleOption2`1<bool>> VarElsewhere;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferConditionalDelegateCall;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferSwitchExpression;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferPatternMatching;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferPatternMatchingOverAsWithNullCheck;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferPatternMatchingOverIsWithCastCheck;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferNotPattern;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferExtendedPropertyPattern;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferThrowExpression;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferInlinedVariableDeclaration;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferDeconstructedVariableDeclaration;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferIndexOperator;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferRangeOperator;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferUtf8StringLiterals;
    public static CodeStyleOption2`1<ExpressionBodyPreference> NeverWithSilentEnforcement;
    public static CodeStyleOption2`1<ExpressionBodyPreference> NeverWithSuggestionEnforcement;
    public static CodeStyleOption2`1<ExpressionBodyPreference> WhenPossibleWithSilentEnforcement;
    public static CodeStyleOption2`1<ExpressionBodyPreference> WhenPossibleWithSuggestionEnforcement;
    public static CodeStyleOption2`1<ExpressionBodyPreference> WhenOnSingleLineWithSilentEnforcement;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedConstructors;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedMethods;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedOperators;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedProperties;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedIndexers;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedAccessors;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedLambdas;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedLocalFunctions;
    public static Option2`1<CodeStyleOption2`1<PreferBracesPreference>> PreferBraces;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferSimpleDefaultExpression;
    public static Option2`1<CodeStyleOption2`1<string>> PreferredModifierOrder;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferStaticLocalFunction;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferReadOnlyStruct;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferReadOnlyStructMember;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferSimpleUsingStatement;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferLocalOverAnonymousFunction;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferTupleSwap;
    public static Option2`1<CodeStyleOption2`1<AddImportPlacement>> PreferredUsingDirectivePlacement;
    internal static Option2`1<CodeStyleOption2`1<UnusedValuePreference>> UnusedValueExpressionStatement;
    internal static Option2`1<CodeStyleOption2`1<UnusedValuePreference>> UnusedValueAssignment;
    public static Option2`1<CodeStyleOption2`1<bool>> ImplicitObjectCreationWhenTypeIsApparent;
    internal static Option2`1<CodeStyleOption2`1<bool>> PreferNullCheckOverTypeCheck;
    [CompilerGeneratedAttribute]
private static Option2`1<CodeStyleOption2`1<bool>> <AllowEmbeddedStatementsOnSameLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<CodeStyleOption2`1<bool>> <AllowBlankLinesBetweenConsecutiveBraces>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<CodeStyleOption2`1<bool>> <AllowBlankLineAfterColonInConstructorInitializer>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<CodeStyleOption2`1<bool>> <AllowBlankLineAfterTokenInConditionalExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<CodeStyleOption2`1<bool>> <AllowBlankLineAfterTokenInArrowExpressionClause>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<CodeStyleOption2`1<NamespaceDeclarationPreference>> <NamespaceDeclarations>k__BackingField;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferMethodGroupConversion;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferTopLevelStatements;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferPrimaryConstructors;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<IOption2> AllOptions;
    public static Option2`1<CodeStyleOption2`1<bool>> AllowEmbeddedStatementsOnSameLine { get; }
    public static Option2`1<CodeStyleOption2`1<bool>> AllowBlankLinesBetweenConsecutiveBraces { get; }
    public static Option2`1<CodeStyleOption2`1<bool>> AllowBlankLineAfterColonInConstructorInitializer { get; }
    public static Option2`1<CodeStyleOption2`1<bool>> AllowBlankLineAfterTokenInConditionalExpression { get; }
    public static Option2`1<CodeStyleOption2`1<bool>> AllowBlankLineAfterTokenInArrowExpressionClause { get; }
    public static Option2`1<CodeStyleOption2`1<NamespaceDeclarationPreference>> NamespaceDeclarations { get; }
    private static CSharpCodeStyleOptions();
    private static Option2`1<CodeStyleOption2`1<T>> CreateOption(OptionGroup group, string name, CodeStyleOption2`1<T> defaultValue, Func`2<CodeStyleOption2`1<T>, EditorConfigValueSerializer`1<CodeStyleOption2`1<T>>> serializerFactory);
    private static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> CreatePreferExpressionBodyOption(CodeStyleOption2`1<ExpressionBodyPreference> defaultValue, string name);
    [CompilerGeneratedAttribute]
public static Option2`1<CodeStyleOption2`1<bool>> get_AllowEmbeddedStatementsOnSameLine();
    [CompilerGeneratedAttribute]
public static Option2`1<CodeStyleOption2`1<bool>> get_AllowBlankLinesBetweenConsecutiveBraces();
    [CompilerGeneratedAttribute]
public static Option2`1<CodeStyleOption2`1<bool>> get_AllowBlankLineAfterColonInConstructorInitializer();
    [CompilerGeneratedAttribute]
public static Option2`1<CodeStyleOption2`1<bool>> get_AllowBlankLineAfterTokenInConditionalExpression();
    [CompilerGeneratedAttribute]
public static Option2`1<CodeStyleOption2`1<bool>> get_AllowBlankLineAfterTokenInArrowExpressionClause();
    [CompilerGeneratedAttribute]
public static Option2`1<CodeStyleOption2`1<NamespaceDeclarationPreference>> get_NamespaceDeclarations();
    public static CodeStyleOption2`1<ExpressionBodyPreference> ParseExpressionBodyPreference(string optionString, CodeStyleOption2`1<ExpressionBodyPreference> default);
    private static string GetExpressionBodyPreferenceEditorConfigString(CodeStyleOption2`1<ExpressionBodyPreference> value, CodeStyleOption2`1<ExpressionBodyPreference> defaultValue);
    public static CodeStyleOption2`1<AddImportPlacement> ParseUsingDirectivesPlacement(string optionString, CodeStyleOption2`1<AddImportPlacement> default);
    public static string GetUsingDirectivesPlacementEditorConfigString(CodeStyleOption2`1<AddImportPlacement> value, CodeStyleOption2`1<AddImportPlacement> defaultValue);
    public static CodeStyleOption2`1<NamespaceDeclarationPreference> ParseNamespaceDeclaration(string optionString, CodeStyleOption2`1<NamespaceDeclarationPreference> default);
    public static string GetNamespaceDeclarationEditorConfigString(CodeStyleOption2`1<NamespaceDeclarationPreference> value, CodeStyleOption2`1<NamespaceDeclarationPreference> defaultValue);
    private static CodeStyleOption2`1<PreferBracesPreference> ParsePreferBracesPreference(string optionString, CodeStyleOption2`1<PreferBracesPreference> defaultValue);
    private static string GetPreferBracesPreferenceEditorConfigString(CodeStyleOption2`1<PreferBracesPreference> value, CodeStyleOption2`1<PreferBracesPreference> defaultValue);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CodeStyle.ICodeStyleService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeStyle.CSharpCodeStyleService : object {
    [NullableAttribute("1")]
public IdeCodeStyleOptions DefaultOptions { get; }
    [NullableContextAttribute("1")]
public sealed virtual IdeCodeStyleOptions get_DefaultOptions();
    [NullableContextAttribute("1")]
public sealed virtual IdeCodeStyleOptions GetIdeCodeStyleOptions(IOptionsReader options, IdeCodeStyleOptions fallbackOptions);
}
[EditorConfigGeneratorAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeStyle.CSharpEditorConfigFileGenerator : object {
    public sealed virtual IEnumerable`1<ValueTuple`2<string, ImmutableArray`1<IOption2>>> GetOptions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeStyle.CSharpIdeCodeStyleOptions : IdeCodeStyleOptions {
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> s_preferredModifierOrderDefault;
    private static CodeStyleOption2`1<UnusedValuePreference> s_discardVariableWithSilentEnforcement;
    private static CodeStyleOption2`1<UnusedValuePreference> s_discardVariableWithSuggestionEnforcement;
    private static CodeStyleOption2`1<string> s_defaultModifierOrder;
    private static CodeStyleOption2`1<ExpressionBodyPreference> s_whenPossibleWithSilentEnforcement;
    public static CSharpIdeCodeStyleOptions Default;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <ImplicitObjectCreationWhenTypeIsApparent>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferNullCheckOverTypeCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <AllowBlankLinesBetweenConsecutiveBraces>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <AllowBlankLineAfterColonInConstructorInitializer>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <AllowBlankLineAfterTokenInArrowExpressionClause>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <AllowBlankLineAfterTokenInConditionalExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferConditionalDelegateCall>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferSwitchExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferPatternMatching>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferPatternMatchingOverAsWithNullCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferPatternMatchingOverIsWithCastCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferNotPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferExtendedPropertyPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferInlinedVariableDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferDeconstructedVariableDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferIndexOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferRangeOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferUtf8StringLiterals>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<string> <PreferredModifierOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferSimpleUsingStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferLocalOverAnonymousFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferTupleSwap>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<UnusedValuePreference> <UnusedValueExpressionStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<UnusedValuePreference> <UnusedValueAssignment>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferMethodGroupConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferReadOnlyStruct>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferReadOnlyStructMember>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferStaticLocalFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ExpressionBodyPreference> <PreferExpressionBodiedLambdas>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferPrimaryConstructors>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> ImplicitObjectCreationWhenTypeIsApparent { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferNullCheckOverTypeCheck { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> AllowBlankLinesBetweenConsecutiveBraces { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> AllowBlankLineAfterColonInConstructorInitializer { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> AllowBlankLineAfterTokenInArrowExpressionClause { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> AllowBlankLineAfterTokenInConditionalExpression { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferConditionalDelegateCall { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferSwitchExpression { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferPatternMatching { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferPatternMatchingOverAsWithNullCheck { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferPatternMatchingOverIsWithCastCheck { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferNotPattern { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferExtendedPropertyPattern { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferInlinedVariableDeclaration { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferDeconstructedVariableDeclaration { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferIndexOperator { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferRangeOperator { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferUtf8StringLiterals { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<string> PreferredModifierOrder { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferSimpleUsingStatement { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferLocalOverAnonymousFunction { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferTupleSwap { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<UnusedValuePreference> UnusedValueExpressionStatement { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<UnusedValuePreference> UnusedValueAssignment { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferMethodGroupConversion { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferReadOnlyStruct { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferReadOnlyStructMember { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferStaticLocalFunction { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedLambdas { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferPrimaryConstructors { get; public set; }
    internal CSharpIdeCodeStyleOptions(IOptionsReader options, CSharpIdeCodeStyleOptions fallbackOptions);
    [CompilerGeneratedAttribute]
private CSharpIdeCodeStyleOptions(CSharpIdeCodeStyleOptions original);
    private static CSharpIdeCodeStyleOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_ImplicitObjectCreationWhenTypeIsApparent();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ImplicitObjectCreationWhenTypeIsApparent(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferNullCheckOverTypeCheck();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferNullCheckOverTypeCheck(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_AllowBlankLinesBetweenConsecutiveBraces();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AllowBlankLinesBetweenConsecutiveBraces(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_AllowBlankLineAfterColonInConstructorInitializer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AllowBlankLineAfterColonInConstructorInitializer(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_AllowBlankLineAfterTokenInArrowExpressionClause();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AllowBlankLineAfterTokenInArrowExpressionClause(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_AllowBlankLineAfterTokenInConditionalExpression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AllowBlankLineAfterTokenInConditionalExpression(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferConditionalDelegateCall();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferConditionalDelegateCall(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferSwitchExpression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferSwitchExpression(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferPatternMatching();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferPatternMatching(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferPatternMatchingOverAsWithNullCheck();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferPatternMatchingOverAsWithNullCheck(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferPatternMatchingOverIsWithCastCheck();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferPatternMatchingOverIsWithCastCheck(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferNotPattern();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferNotPattern(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferExtendedPropertyPattern();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExtendedPropertyPattern(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferInlinedVariableDeclaration();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferInlinedVariableDeclaration(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferDeconstructedVariableDeclaration();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferDeconstructedVariableDeclaration(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferIndexOperator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferIndexOperator(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferRangeOperator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferRangeOperator(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferUtf8StringLiterals();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferUtf8StringLiterals(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<string> get_PreferredModifierOrder();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferredModifierOrder(CodeStyleOption2`1<string> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferSimpleUsingStatement();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferSimpleUsingStatement(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferLocalOverAnonymousFunction();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferLocalOverAnonymousFunction(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferTupleSwap();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferTupleSwap(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<UnusedValuePreference> get_UnusedValueExpressionStatement();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UnusedValueExpressionStatement(CodeStyleOption2`1<UnusedValuePreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<UnusedValuePreference> get_UnusedValueAssignment();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UnusedValueAssignment(CodeStyleOption2`1<UnusedValuePreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferMethodGroupConversion();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferMethodGroupConversion(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferReadOnlyStruct();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferReadOnlyStruct(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferReadOnlyStructMember();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferReadOnlyStructMember(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferStaticLocalFunction();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferStaticLocalFunction(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedLambdas();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExpressionBodiedLambdas(CodeStyleOption2`1<ExpressionBodyPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferPrimaryConstructors();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferPrimaryConstructors(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CSharpIdeCodeStyleOptions left, CSharpIdeCodeStyleOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CSharpIdeCodeStyleOptions left, CSharpIdeCodeStyleOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(IdeCodeStyleOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CSharpIdeCodeStyleOptions other);
    [CompilerGeneratedAttribute]
public virtual IdeCodeStyleOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeStyle.TypeStyle.TypeStyleHelper : object {
    public static bool IsBuiltInType(ITypeSymbol type);
    public static bool IsTypeApparentInAssignmentExpression(UseVarPreference stylePreferences, ExpressionSyntax initializerExpression, SemanticModel semanticModel, ITypeSymbol typeInDeclaration, CancellationToken cancellationToken);
    private static bool IsPossibleCreationOrConversionMethod(IMethodSymbol methodSymbol, ITypeSymbol typeInDeclaration, SemanticModel semanticModel, ExpressionSyntax containingTypeName, CancellationToken cancellationToken);
    private static bool IsPossibleCreationMethod(IMethodSymbol methodSymbol, ITypeSymbol typeInDeclaration, ITypeSymbol containingType);
    private static bool IsPossibleConversionMethod(IMethodSymbol methodSymbol);
    private static bool IsContainerTypeEqualToReturnType(IMethodSymbol methodSymbol, ITypeSymbol typeInDeclaration, ITypeSymbol containingType);
    [NullableContextAttribute("2")]
private static ITypeSymbol UnwrapTupleType(ITypeSymbol symbol);
    private static ExpressionSyntax GetRightmostInvocationExpression(ExpressionSyntax node);
    public static bool IsPredefinedType(TypeSyntax type);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.CodeStyle.TypeStyle.UseVarPreference : Enum {
    public int value__;
    public static UseVarPreference None;
    public static UseVarPreference ForBuiltInTypes;
    public static UseVarPreference WhenTypeIsApparent;
    public static UseVarPreference Elsewhere;
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageService.IBlockFactsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpBlockFactsService : CSharpBlockFacts {
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Host.ICommandLineParserService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpCommandLineParserService : object {
    public sealed virtual CommandLineArguments Parse(IEnumerable`1<string> arguments, string baseDirectory, bool isInteractive, string sdkDirectory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Host.ICompilationFactoryService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpCompilationFactoryService : object {
    private static CSharpCompilationOptions s_defaultOptions;
    private static CSharpCompilationFactoryService();
    private sealed virtual override Compilation Microsoft.CodeAnalysis.Host.ICompilationFactoryService.CreateCompilation(string assemblyName, CompilationOptions options);
    private sealed virtual override Compilation Microsoft.CodeAnalysis.Host.ICompilationFactoryService.CreateSubmissionCompilation(string assemblyName, CompilationOptions options, Type hostObjectType);
    private sealed virtual override CompilationOptions Microsoft.CodeAnalysis.Host.ICompilationFactoryService.GetDefaultCompilationOptions();
    private sealed virtual override CompilationOptions Microsoft.CodeAnalysis.Host.ICompilationFactoryService.TryParsePdbCompilationOptions(IReadOnlyDictionary`2<string, string> compilationOptionsMetadata);
    private sealed virtual override GeneratorDriver Microsoft.CodeAnalysis.Host.ICompilationFactoryService.CreateGeneratorDriver(ParseOptions parseOptions, ImmutableArray`1<ISourceGenerator> generators, AnalyzerConfigOptionsProvider optionsProvider, ImmutableArray`1<AdditionalText> additionalTexts);
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpCompilerExtensionsResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string var_preferences { get; }
    internal static string Expression_bodied_members { get; }
    internal static string Pattern_matching_preferences { get; }
    internal static string Null_checking_preferences { get; }
    internal static string Code_block_preferences { get; }
    internal static string using_directive_preferences { get; }
    internal static string Expected_string_or_char_literal { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_var_preferences();
    internal static string get_Expression_bodied_members();
    internal static string get_Pattern_matching_preferences();
    internal static string get_Null_checking_preferences();
    internal static string get_Code_block_preferences();
    internal static string get_using_directive_preferences();
    internal static string get_Expected_string_or_char_literal();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageService.IFileBannerFactsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpFileBannerFactsService : CSharpFileBannerFacts {
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageService.IHeaderFactsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpHeaderFactsServices : CSharpHeaderFacts {
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ILinkedFileMergeConflictCommentAdditionService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpLinkedFileMergeConflictCommentAdditionService : AbstractLinkedFileMergeConflictCommentAdditionService {
    internal virtual string GetConflictCommentText(string header, string beforeString, string afterString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.CSharpSemanticFacts : object {
    internal static CSharpSemanticFacts Instance;
    public ISyntaxFacts SyntaxFacts { get; }
    public bool SupportsImplicitInterfaceImplementation { get; }
    public bool ExposesAnonymousFunctionParameterNames { get; }
    public bool SupportsParameterizedProperties { get; }
    private static CSharpSemanticFacts();
    public sealed virtual ISyntaxFacts get_SyntaxFacts();
    public sealed virtual bool get_SupportsImplicitInterfaceImplementation();
    public sealed virtual bool get_ExposesAnonymousFunctionParameterNames();
    public sealed virtual bool IsWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsOnlyWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsInOutContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsInRefContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsInInContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool CanReplaceWithRValue(SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    public sealed virtual ISymbol GetDeclaredSymbol(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    public sealed virtual bool LastEnumValueHasInitializer(INamedTypeSymbol namedTypeSymbol);
    public sealed virtual bool get_SupportsParameterizedProperties();
    public sealed virtual bool TryGetSpeculativeSemanticModel(SemanticModel oldSemanticModel, SyntaxNode oldNode, SyntaxNode newNode, SemanticModel& speculativeModel);
    public sealed virtual ImmutableHashSet`1<string> GetAliasNameSet(SemanticModel model, CancellationToken cancellationToken);
    private static void AppendAliasNames(SyntaxList`1<UsingDirectiveSyntax> usings, Builder<string> builder);
    private static void AppendAliasNames(IEnumerable`1<BaseNamespaceDeclarationSyntax> namespaces, Builder<string> builder, CancellationToken cancellationToken);
    public sealed virtual ForEachSymbols GetForEachSymbols(SemanticModel semanticModel, SyntaxNode forEachStatement);
    public sealed virtual SymbolInfo GetCollectionInitializerSymbolInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual IMethodSymbol GetGetAwaiterMethod(SemanticModel semanticModel, SyntaxNode node);
    public sealed virtual ImmutableArray`1<IMethodSymbol> GetDeconstructionAssignmentMethods(SemanticModel semanticModel, SyntaxNode node);
    public sealed virtual ImmutableArray`1<IMethodSymbol> GetDeconstructionForEachMethods(SemanticModel semanticModel, SyntaxNode node);
    private static void FlattenDeconstructionMethods(DeconstructionInfo deconstruction, TemporaryArray`1& builder);
    public sealed virtual bool IsPartial(INamedTypeSymbol typeSymbol, CancellationToken cancellationToken);
    public sealed virtual IEnumerable`1<ISymbol> GetDeclaredSymbols(SemanticModel semanticModel, SyntaxNode memberDeclaration, CancellationToken cancellationToken);
    public sealed virtual IParameterSymbol FindParameterForArgument(SemanticModel semanticModel, SyntaxNode argument, bool allowUncertainCandidates, bool allowParams, CancellationToken cancellationToken);
    public sealed virtual IParameterSymbol FindParameterForAttributeArgument(SemanticModel semanticModel, SyntaxNode argument, bool allowUncertainCandidates, bool allowParams, CancellationToken cancellationToken);
    public sealed virtual ISymbol FindFieldOrPropertyForArgument(SemanticModel semanticModel, SyntaxNode argument, CancellationToken cancellationToken);
    public sealed virtual ISymbol FindFieldOrPropertyForAttributeArgument(SemanticModel semanticModel, SyntaxNode argument, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<ISymbol> GetBestOrAllSymbols(SemanticModel semanticModel, SyntaxNode node, SyntaxToken token, CancellationToken cancellationToken);
    private static ImmutableArray`1<ISymbol> GetSymbolInfo(SemanticModel semanticModel, SyntaxNode node, SyntaxToken token, CancellationToken cancellationToken);
    public sealed virtual bool IsInsideNameOfExpression(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<IMethodSymbol> GetLocalFunctionSymbols(Compilation compilation, ISymbol symbol, CancellationToken cancellationToken);
    public sealed virtual bool IsInExpressionTree(SemanticModel semanticModel, SyntaxNode node, INamedTypeSymbol expressionType, CancellationToken cancellationToken);
    public sealed virtual string GenerateNameForExpression(SemanticModel semanticModel, SyntaxNode expression, bool capitalize, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<ISymbol> <GetBestOrAllSymbols>g__GetCallingConventionSymbols|34_0(SemanticModel model, FunctionPointerUnmanagedCallingConventionSyntax syntax);
}
internal class Microsoft.CodeAnalysis.CSharp.CSharpSemanticFactsService : AbstractSemanticFactsService {
    internal static CSharpSemanticFactsService Instance;
    public ISyntaxFacts SyntaxFacts { get; }
    public IBlockFacts BlockFacts { get; }
    protected ISemanticFacts SemanticFacts { get; }
    private static CSharpSemanticFactsService();
    public virtual ISyntaxFacts get_SyntaxFacts();
    public virtual IBlockFacts get_BlockFacts();
    protected virtual ISemanticFacts get_SemanticFacts();
    protected virtual SyntaxToken ToIdentifierToken(string identifier);
    protected virtual IEnumerable`1<ISymbol> GetCollidableSymbols(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, CancellationToken cancellationToken);
    public sealed virtual bool IsExpressionContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsStatementContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsTypeContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsNamespaceContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsNamespaceDeclarationNameContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsTypeDeclarationContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsMemberDeclarationContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsGlobalStatementContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsLabelContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsAttributeNameContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual CommonConversion ClassifyConversion(SemanticModel semanticModel, SyntaxNode expression, ITypeSymbol destination);
    [NullableContextAttribute("1")]
public sealed virtual IMethodSymbol TryGetDisposeMethod(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken Microsoft.CodeAnalysis.LanguageService.ISemanticFactsService.GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, string baseName, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken Microsoft.CodeAnalysis.LanguageService.ISemanticFactsService.GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, string baseName, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken Microsoft.CodeAnalysis.LanguageService.ISemanticFactsService.GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, string baseName, Func`2<ISymbol, bool> filter, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken Microsoft.CodeAnalysis.LanguageService.ISemanticFactsService.GenerateUniqueLocalName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, string baseName, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken Microsoft.CodeAnalysis.LanguageService.ISemanticFactsService.GenerateUniqueLocalName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, string baseName, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken Microsoft.CodeAnalysis.LanguageService.ISemanticFactsService.GenerateUniqueName(string baseName, IEnumerable`1<string> usedNames);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.LanguageService.ISemanticFactsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpSemanticFactsServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageService.ISymbolDeclarationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpSymbolDeclarationService : object {
    public sealed virtual ImmutableArray`1<SyntaxReference> GetDeclarations(ISymbol symbol);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxFactsServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Host.ISyntaxTreeFactoryService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTreeFactoryService : AbstractSyntaxTreeFactoryService {
    private static CSharpParseOptions _parseOptionWithLatestLanguageVersion;
    private static CSharpSyntaxTreeFactoryService();
    public virtual ParseOptions GetDefaultParseOptions();
    public virtual ParseOptions GetDefaultParseOptionsWithLatestLanguageVersion();
    public virtual ParseOptions TryParsePdbParseOptions(IReadOnlyDictionary`2<string, string> metadata);
    public virtual bool OptionsDifferOnlyByPreprocessorDirectives(ParseOptions options1, ParseOptions options2);
    public virtual SyntaxTree CreateSyntaxTree(string filePath, ParseOptions options, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, SyntaxNode root);
    public virtual SyntaxTree ParseSyntaxTree(string filePath, ParseOptions options, SourceText text, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageService.ITypeInferenceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpTypeInferenceService : AbstractTypeInferenceService {
    public static CSharpTypeInferenceService Instance;
    private static CSharpTypeInferenceService();
    protected virtual AbstractTypeInferrer CreateTypeInferrer(SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceExtensionsResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string EmptyResource { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_EmptyResource();
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Only_attributes_constructor_initializers_expressions_or_statements_can_be_made_explicit { get; }
    internal static string Implement_Interface { get; }
    internal static string Indentation_preferences { get; }
    internal static string Space_preferences { get; }
    internal static string Wrapping_preferences { get; }
    internal static string Remove_and_Sort_Usings { get; }
    internal static string Sort_Usings { get; }
    internal static string CSharp_Formatting_Rules { get; }
    internal static string CSharp_Coding_Conventions { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Only_attributes_constructor_initializers_expressions_or_statements_can_be_made_explicit();
    internal static string get_Implement_Interface();
    internal static string get_Indentation_preferences();
    internal static string get_Space_preferences();
    internal static string get_Wrapping_preferences();
    internal static string get_Remove_and_Sort_Usings();
    internal static string get_Sort_Usings();
    internal static string get_CSharp_Formatting_Rules();
    internal static string get_CSharp_Coding_Conventions();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Diagnostics.IDiagnosticPropertiesService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.CSharpDiagnosticPropertiesService : AbstractDiagnosticPropertiesService {
    private static Compilation s_compilation;
    private static CSharpDiagnosticPropertiesService();
    protected virtual Compilation GetCompilation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Editing.ImportAdderService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Editing.CSharpImportAdder : ImportAdderService {
    protected virtual INamespaceSymbol GetExplicitNamespaceSymbol(SyntaxNode node, SemanticModel model);
    protected virtual void AddPotentiallyConflictingImports(SemanticModel model, SyntaxNode container, ImmutableArray`1<INamespaceSymbol> namespaceSymbols, HashSet`1<INamespaceSymbol> conflicts, CancellationToken cancellationToken);
    private static INamespaceSymbol GetExplicitNamespaceSymbol(ExpressionSyntax fullName, ExpressionSyntax namespacePart, SemanticModel model);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.IVirtualCharLanguageService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.EmbeddedLanguages.VirtualChars.CSharpVirtualCharLanguageServiceFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EmbeddedLanguages.VirtualChars.CSharpVirtualCharService : AbstractVirtualCharService {
    public static IVirtualCharService Instance;
    protected ISyntaxFacts SyntaxFacts { get; }
    private static CSharpVirtualCharService();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual bool IsMultiLineRawStringToken(SyntaxToken token);
    protected virtual VirtualCharSequence TryConvertToVirtualCharsWorker(SyntaxToken token);
    [NullableContextAttribute("2")]
private static bool IsInDirective(SyntaxNode node);
    private static VirtualCharSequence TryConvertVerbatimStringToVirtualChars(SyntaxToken token, string startDelimiter, string endDelimiter, bool escapeBraces);
    private static VirtualCharSequence TryConvertSingleLineRawStringToVirtualChars(SyntaxToken token);
    private static VirtualCharSequence TryConvertMultiLineRawStringToVirtualChars(SyntaxToken token, ExpressionSyntax parentExpression, bool tokenIncludeDelimiters);
    private static VirtualCharSequence TryConvertStringToVirtualChars(SyntaxToken token, string startDelimiter, string endDelimiter, bool escapeBraces);
    private static VirtualCharSequence CreateVirtualCharSequence(string tokenText, int offset, int startIndexInclusive, int endIndexExclusive, ArrayBuilder`1<ValueTuple`2<char, TextSpan>> charResults);
    private static void ConvertCharactersToRunes(ArrayBuilder`1<ValueTuple`2<char, TextSpan>> charResults, Builder<VirtualChar> runeResults);
    private static bool TryAddEscape(ArrayBuilder`1<ValueTuple`2<char, TextSpan>> result, string tokenText, int offset, int index);
    public virtual bool TryGetEscapeCharacter(VirtualChar ch, Char& escapedChar);
    private static bool TryAddSingleCharacterEscape(ArrayBuilder`1<ValueTuple`2<char, TextSpan>> result, string tokenText, int offset, int index);
    private static bool TryAddMultiCharacterEscape(ArrayBuilder`1<ValueTuple`2<char, TextSpan>> result, string tokenText, int offset, int index);
    private static bool TryAddMultiCharacterEscape(ArrayBuilder`1<ValueTuple`2<char, TextSpan>> result, string tokenText, int offset, int index, char character);
    private static int HexValue(char c);
    private static bool IsHexDigit(char c);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.EmbeddedLanguages.VirtualChars.Extensions : object {
    [ExtensionAttribute]
public static bool TryGetEscapeCharacter(VirtualChar ch, Char& escapedChar);
    [ExtensionAttribute]
public static bool TryGetEscapeCharacter(Rune rune, Char& escapedChar);
    private static bool TryGetEscapeCharacter(int value, Char& escapedChar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ArgumentSyntaxExtensions : object {
    [ExtensionAttribute]
public static SyntaxTokenList GenerateParameterModifiers(ArgumentSyntax argument);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static RefKind GetRefKind(ArgumentSyntax argument);
    [ExtensionAttribute]
public static IParameterSymbol DetermineParameter(ArgumentSyntax argument, SemanticModel semanticModel, bool allowUncertainCandidates, bool allowParams, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ArrowExpressionClauseSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool TryConvertToBlock(ArrowExpressionClauseSyntax arrowExpression, SyntaxToken semicolonToken, bool createReturnStatementForExpression, BlockSyntax& block);
    [ExtensionAttribute]
public static bool TryConvertToStatement(ArrowExpressionClauseSyntax arrowExpression, SyntaxToken semicolonToken, bool createReturnStatementForExpression, StatementSyntax& statement);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.AssignmentExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
internal static bool IsDeconstruction(AssignmentExpressionSyntax assignment);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.AttributeArgumentSyntaxExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IParameterSymbol DetermineParameter(AttributeArgumentSyntax argument, SemanticModel semanticModel, bool allowUncertainCandidates, bool allowParams, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.BaseArgumentListSyntaxExtensions : object {
    [ExtensionAttribute]
public static SyntaxToken GetOpenToken(BaseArgumentListSyntax node);
    [ExtensionAttribute]
public static SyntaxToken GetCloseToken(BaseArgumentListSyntax node);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.BaseNamespaceDeclarationSyntaxExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static TNamespaceDeclarationSyntax AddUsingDirectives(TNamespaceDeclarationSyntax namespaceDeclaration, IList`1<UsingDirectiveSyntax> usingDirectives, bool placeSystemNamespaceFirst, SyntaxAnnotation[] annotations);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.BaseParameterListSyntaxExtensions : object {
    [ExtensionAttribute]
public static SyntaxToken GetOpenToken(BaseParameterListSyntax node);
    [ExtensionAttribute]
public static SyntaxToken GetCloseToken(BaseParameterListSyntax node);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.BasePropertyDeclarationSyntaxExtensions : object {
    [ExtensionAttribute]
public static SyntaxToken TryGetSemicolonToken(BasePropertyDeclarationSyntax node);
    [ExtensionAttribute]
public static BasePropertyDeclarationSyntax TryWithSemicolonToken(BasePropertyDeclarationSyntax node, SyntaxToken semicolonToken);
    [ExtensionAttribute]
public static BasePropertyDeclarationSyntax TryWithExpressionBody(BasePropertyDeclarationSyntax node, ArrowExpressionClauseSyntax expressionBody);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.BlockSyntaxExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryConvertToExpressionBody(BlockSyntax block, LanguageVersion languageVersion, ExpressionBodyPreference preference, CancellationToken cancellationToken, ExpressionSyntax& expression, SyntaxToken& semicolonToken);
    [ExtensionAttribute]
public static bool TryConvertToArrowExpressionBody(BlockSyntax block, SyntaxKind declarationKind, LanguageVersion languageVersion, ExpressionBodyPreference preference, CancellationToken cancellationToken, ArrowExpressionClauseSyntax& arrowExpression, SyntaxToken& semicolonToken);
    private static bool IsSupportedInCSharp6(SyntaxKind declarationKind);
    public static bool MatchesPreference(ExpressionSyntax expression, ExpressionBodyPreference preference);
    private static bool TryGetExpression(StatementSyntax firstStatement, LanguageVersion languageVersion, ExpressionSyntax& expression, SyntaxToken& semicolonToken);
    [CompilerGeneratedAttribute]
internal static bool <TryConvertToExpressionBody>g__IsAnyCodeDirective|0_1(SyntaxTrivia trivia);
    [CompilerGeneratedAttribute]
internal static bool <TryConvertToExpressionBody>g__HasAcceptableDirectiveShape|0_2(StatementSyntax statement, SyntaxToken closeBrace, <>c__DisplayClass0_0& );
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.CastExpressionSyntaxExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ExpressionSyntax Uncast(CastExpressionSyntax node);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.CompilationExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static LanguageVersion LanguageVersion(Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.CompilationUnitSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool IsTopLevelProgram(CompilationUnitSyntax compilationUnit);
    [ExtensionAttribute]
public static bool CanAddUsingDirectives(SyntaxNode contextNode, bool allowInHiddenRegions, CancellationToken cancellationToken);
    private static TextSpan GetUsingsSpan(CompilationUnitSyntax root, BaseNamespaceDeclarationSyntax namespaceDeclaration);
    [ExtensionAttribute]
public static CompilationUnitSyntax AddUsingDirective(CompilationUnitSyntax root, UsingDirectiveSyntax usingDirective, SyntaxNode contextNode, bool placeSystemNamespaceFirst, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static CompilationUnitSyntax AddUsingDirectives(CompilationUnitSyntax root, IList`1<UsingDirectiveSyntax> usingDirectives, SyntaxNode contextNode, bool placeSystemNamespaceFirst, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static CompilationUnitSyntax AddUsingDirectives(CompilationUnitSyntax root, IList`1<UsingDirectiveSyntax> usingDirectives, bool placeSystemNamespaceFirst, SyntaxAnnotation[] annotations);
    private static List`1<UsingDirectiveSyntax> AddUsingDirectives(CompilationUnitSyntax root, IList`1<UsingDirectiveSyntax> usingDirectives);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.CSharpSyntaxContext : SyntaxContext {
    [NullableAttribute("2")]
public TypeDeclarationSyntax ContainingTypeDeclaration;
    [NullableAttribute("2")]
public BaseTypeDeclarationSyntax ContainingTypeOrEnumDeclaration;
    public bool IsCatchFilterContext;
    public bool IsConstantExpressionContext;
    public bool IsCrefContext;
    public bool IsDefiniteCastTypeContext;
    public bool IsDelegateReturnTypeContext;
    public bool IsDestructorTypeContext;
    public bool IsFixedVariableDeclarationContext;
    public bool IsFunctionPointerTypeArgumentContext;
    public bool IsGenericTypeArgumentContext;
    public bool IsImplicitOrExplicitOperatorTypeContext;
    public bool IsInNonUserCode;
    public bool IsInstanceContext;
    public bool IsIsOrAsOrSwitchOrWithExpressionContext;
    public bool IsIsOrAsTypeContext;
    public bool IsLabelContext;
    public bool IsLeftSideOfImportAliasDirective;
    public bool IsLocalFunctionDeclarationContext;
    public bool IsLocalVariableDeclarationContext;
    public bool IsNonAttributeExpressionContext;
    public bool IsObjectCreationTypeContext;
    public bool IsParameterTypeContext;
    public bool IsPossibleLambdaOrAnonymousMethodParameterTypeContext;
    public bool IsPreProcessorKeywordContext;
    public bool IsPrimaryFunctionExpressionContext;
    public bool IsTypeArgumentOfConstraintContext;
    public bool IsTypeOfExpressionContext;
    public bool IsUsingAliasTypeContext;
    public ISet`1<SyntaxKind> PrecedingModifiers;
    private CSharpSyntaxContext(Document document, SemanticModel semanticModel, int position, SyntaxToken leftToken, SyntaxToken targetToken, TypeDeclarationSyntax containingTypeDeclaration, BaseTypeDeclarationSyntax containingTypeOrEnumDeclaration, bool isAnyExpressionContext, bool isAtEndOfPattern, bool isAtStartOfPattern, bool isAttributeNameContext, bool isAwaitKeywordContext, bool isCatchFilterContext, bool isConstantExpressionContext, bool isCrefContext, bool isDefiniteCastTypeContext, bool isDelegateReturnTypeContext, bool isDestructorTypeContext, bool isEnumBaseListContext, bool isEnumTypeMemberAccessContext, bool isFixedVariableDeclarationContext, bool isFunctionPointerTypeArgumentContext, bool isGenericConstraintContext, bool isGenericTypeArgumentContext, bool isGlobalStatementContext, bool isImplicitOrExplicitOperatorTypeContext, bool isInImportsDirective, bool isInNonUserCode, bool isInQuery, bool isInstanceContext, bool isTaskLikeTypeContext, bool isIsOrAsOrSwitchOrWithExpressionContext, bool isIsOrAsTypeContext, bool isLabelContext, bool isLeftSideOfImportAliasDirective, bool isLocalFunctionDeclarationContext, bool isLocalVariableDeclarationContext, bool isNameOfContext, bool isNamespaceContext, bool isNamespaceDeclarationNameContext, bool isNonAttributeExpressionContext, bool isObjectCreationTypeContext, bool isOnArgumentListBracketOrComma, bool isParameterTypeContext, bool isPossibleLambdaOrAnonymousMethodParameterTypeContext, bool isPossibleTupleContext, bool isPreProcessorDirectiveContext, bool isPreProcessorExpressionContext, bool isPreProcessorKeywordContext, bool isPrimaryFunctionExpressionContext, bool isRightAfterUsingOrImportDirective, bool isRightOfNameSeparator, bool isRightSideOfNumericType, bool isStatementContext, bool isTypeArgumentOfConstraintContext, bool isTypeContext, bool isTypeOfExpressionContext, bool isUsingAliasTypeContext, bool isWithinAsyncMethod, ISet`1<SyntaxKind> precedingModifiers, CancellationToken cancellationToken);
    public static CSharpSyntaxContext CreateContext(Document document, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    private static CSharpSyntaxContext CreateContextWorker(Document document, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    private static bool ComputeIsWithinAsyncMethod();
    public bool IsTypeAttributeContext(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public bool IsTypeDeclarationContext(ISet`1<SyntaxKind> validModifiers, ISet`1<SyntaxKind> validTypeDeclarations, bool canBePartial, CancellationToken cancellationToken);
    public bool IsRecordDeclarationContext(ISet`1<SyntaxKind> validModifiers, CancellationToken cancellationToken);
    public bool IsMemberAttributeContext(ISet`1<SyntaxKind> validTypeDeclarations, CancellationToken cancellationToken);
    public bool IsStatementAttributeContext();
    [NullableContextAttribute("2")]
public bool IsMemberDeclarationContext(ISet`1<SyntaxKind> validModifiers, ISet`1<SyntaxKind> validTypeDeclarations, bool canBePartial, CancellationToken cancellationToken);
    public bool IsRegularTopLevelStatementsContext();
    private static bool IsLeftSideOfUsingAliasDirective(SyntaxToken leftToken);
    internal bool IsAwaitStatementContext(int position, CancellationToken cancellationToken);
    private static bool ComputeIsAwaitKeywordContext(int position, SyntaxToken leftToken, SyntaxToken targetToken, bool isGlobalStatementContext, bool isAnyExpressionContext, bool isStatementContext);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.ISyntaxContextService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.CSharpSyntaxContextService : object {
    [NullableContextAttribute("1")]
public sealed virtual SyntaxContext CreateContext(Document document, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.SyntaxNodeExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDelegateOrConstructorOrLocalFunctionOrMethodOrOperatorParameterList(SyntaxNode node, bool includeOperators);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.SyntaxTokenExtensions : object {
    [ExtensionAttribute]
public static bool IsUsingOrExternKeyword(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsUsingKeywordInUsingDirective(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsStaticKeywordContextInUsingDirective(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsBeginningOfStatementContext(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsBeginningOfGlobalStatementContext(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsAfterPossibleCast(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsLastTokenOfQueryClause(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsPreProcessorExpressionContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsOrderByDirectionContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsSwitchLabelContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsXmlCrefParameterModifierContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsConstructorOrMethodParameterArgumentContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsUnaryOperatorContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsUnsafeContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsAfterYieldKeyword(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsAnyAccessorDeclarationContext(SyntaxToken targetToken, int position, SyntaxKind kind);
    [ExtensionAttribute]
public static bool IsAccessorDeclarationContext(SyntaxToken targetToken, int position, SyntaxKind kind);
    private static bool IsAccessorDeclarationContextWorker(SyntaxToken& targetToken);
    [NullableContextAttribute("2")]
private static bool IsGenericInterfaceOrDelegateTypeParameterList(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsTypeParameterVarianceContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsMandatoryNamedParameterPosition(SyntaxToken token);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsNumericTypeContext(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsTypeNamedDynamic(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.SyntaxTreeExtensions : object {
    private static ISet`1<SyntaxKind> s_validLocalFunctionModifiers;
    private static SyntaxTreeExtensions();
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool IsPreProcessorDirectiveContext(SyntaxTree syntaxTree, int position, SyntaxToken preProcessorTokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsAttributeNameContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsGlobalMemberDeclarationContext(SyntaxTree syntaxTree, int position, ISet`1<SyntaxKind> validModifiers, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsMemberDeclarationContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsMemberDeclarationContext(SyntaxTree syntaxTree, int position, CSharpSyntaxContext context, ISet`1<SyntaxKind> validModifiers, ISet`1<SyntaxKind> validTypeDeclarations, bool canBePartial, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsLambdaDeclarationContext(SyntaxTree syntaxTree, int position, SyntaxKind otherModifier, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsLocalFunctionDeclarationContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsLocalFunctionDeclarationContext(SyntaxTree syntaxTree, int position, ISet`1<SyntaxKind> validModifiers, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsTypeDeclarationContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsTypeDeclarationContext(SyntaxTree syntaxTree, int position, CSharpSyntaxContext context, ISet`1<SyntaxKind> validModifiers, ISet`1<SyntaxKind> validTypeDeclarations, bool canBePartial, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsNamespaceContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsNamespaceDeclarationNameContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPartialTypeDeclarationNameContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, TypeDeclarationSyntax& declarationSyntax);
    [ExtensionAttribute]
public static bool IsDefinitelyNotTypeContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsTypeContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsBaseClassOrInterfaceContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsUsingAliasTypeContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsUsingStaticContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsTypeArgumentOfConstraintClause(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsTypeParameterConstraintStartContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsTypeParameterConstraintContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsTypeOfExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsDefaultExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsSizeOfExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsFunctionPointerTypeArgumentContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsGenericConstraintContext(SyntaxTree syntaxTree, SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsGenericTypeArgumentContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken, SemanticModel semanticModelOpt);
    [ExtensionAttribute]
public static bool IsParameterModifierContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, bool includeOperators, Int32& parameterIndex, SyntaxKind& previousModifier);
    [ExtensionAttribute]
public static bool IsParamsModifierContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsDelegateReturnTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsImplicitOrExplicitOperatorTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsParameterTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsPossibleExtensionMethodContext(SyntaxTree syntaxTree, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsPossibleLambdaParameterModifierContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsAnonymousMethodParameterModifierContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsPossibleLambdaOrAnonymousMethodParameterTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPossibleTupleContext(SyntaxTree syntaxTree, SyntaxToken leftToken, int position);
    [ExtensionAttribute]
public static bool IsAtStartOfPattern(SyntaxTree syntaxTree, SyntaxToken leftToken, int position);
    [ExtensionAttribute]
public static bool IsAtEndOfPattern(SyntaxTree syntaxTree, SyntaxToken leftToken, int position);
    private static SyntaxToken FindTokenOnLeftOfNode(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsPossibleTupleOpenParenOrComma(SyntaxToken possibleCommaOrParen);
    [ExtensionAttribute]
public static bool IsPossibleDeconstructionDesignation(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static SyntaxNode UnwrapPossibleTuple(SyntaxNode node);
    private static bool IsPossibleVarDeconstructionOpenParenOrComma(SyntaxToken leftToken);
    [ExtensionAttribute]
public static bool HasNames(TupleExpressionSyntax tuple);
    [ExtensionAttribute]
public static bool IsValidContextForFromClause(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken, SemanticModel semanticModelOpt);
    [ExtensionAttribute]
public static bool IsValidContextForJoinClause(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsLocalVariableDeclarationContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsFixedVariableDeclarationContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsCatchVariableDeclarationContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsIsOrAsTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsObjectCreationTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    private static bool IsNonConstantExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPreProcessorDirectiveContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsStatementContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsGlobalStatementContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsInstanceContext(SyntaxTree syntaxTree, SyntaxToken targetToken, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPossibleCastTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsDefiniteCastTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsConstantExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsLabelContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, bool attributes, CancellationToken cancellationToken, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsInvocationOfVarExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsNameOfContext(SyntaxTree syntaxTree, int position, SemanticModel semanticModelOpt, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsIsOrAsOrSwitchOrWithExpressionContext(SyntaxTree syntaxTree, SemanticModel semanticModel, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    private static bool IsRightSideName(ExpressionSyntax name);
    [ExtensionAttribute]
public static bool IsCatchOrFinallyContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsCatchFilterContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsEnumBaseListContext(SyntaxTree syntaxTree, SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsEnumTypeMemberAccessContext(SyntaxTree syntaxTree, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsFunctionPointerCallingConventionContext(SyntaxTree syntaxTree, SyntaxToken targetToken);
    [CompilerGeneratedAttribute]
internal static bool <IsGlobalMemberDeclarationContext>g__IsGlobalAttributeList|3_0(AttributeListSyntax attributeList);
    [CompilerGeneratedAttribute]
internal static bool <IsAtEndOfPattern>g__IsAtEndOfSwitchStatementPattern|39_0(SyntaxToken leftToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ConversionExtensions : object {
    [ExtensionAttribute]
public static bool IsIdentityOrImplicitReference(Conversion conversion);
    [ExtensionAttribute]
public static bool IsImplicitUserDefinedConversion(Conversion conversion);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.DefaultExpressionSyntaxExtensions : object {
    private static LiteralExpressionSyntax s_defaultLiteralExpression;
    private static DefaultExpressionSyntaxExtensions();
    [ExtensionAttribute]
public static bool CanReplaceWithDefaultLiteral(DefaultExpressionSyntax defaultExpression, CSharpParseOptions parseOptions, bool preferSimpleDefaultExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static Nullable`1<bool> CanReplaceWithDefaultLiteralFast(DefaultExpressionSyntax defaultExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static TypeSyntax GetTypeSyntax(EqualsValueClauseSyntax equalsValueClause);
    private static bool CanReplaceWithDefaultLiteralSlow(DefaultExpressionSyntax defaultExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.DirectiveSyntaxExtensions : object {
    private static ConditionalWeakTable`2<SyntaxNode, DirectiveInfo`1<DirectiveTriviaSyntax>> s_rootToDirectiveInfo;
    private static DirectiveSyntaxExtensions();
    [ExtensionAttribute]
private static SyntaxNode GetAbsoluteRoot(SyntaxNode node);
    private static DirectiveInfo`1<DirectiveTriviaSyntax> GetDirectiveInfo(SyntaxNode node, CancellationToken cancellationToken);
    private static DirectiveInfo`1<DirectiveTriviaSyntax> GetDirectiveInfoForRoot(SyntaxNode root, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static DirectiveTriviaSyntax GetMatchingDirective(DirectiveTriviaSyntax directive, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<DirectiveTriviaSyntax> GetMatchingConditionalDirectives(DirectiveTriviaSyntax directive, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.DocumentationCommentExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ExpressionSyntax WalkUpParentheses(ExpressionSyntax expression);
    [ExtensionAttribute]
public static ExpressionSyntax WalkDownParentheses(ExpressionSyntax expression);
    [ExtensionAttribute]
public static ExpressionSyntax WalkDownSuppressions(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsQualifiedCrefName(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSimpleMemberAccessExpressionName(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAnyMemberAccessExpressionName(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsMemberBindingExpressionName(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsRightSideOfQualifiedName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsRightSideOfColonColon(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsRightSideOfDot(ExpressionSyntax name);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsRightSideOfDotOrArrow(ExpressionSyntax name);
    [ExtensionAttribute]
public static bool IsRightSideOfDotOrColonColon(ExpressionSyntax name);
    [ExtensionAttribute]
public static bool IsRightSideOfDotOrArrowOrColonColon(ExpressionSyntax name);
    [ExtensionAttribute]
public static bool IsRightOfCloseParen(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsLeftSideOfDot(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsLeftSideOfSimpleMemberAccessExpression(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsLeftSideOfDotOrArrow(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsLeftSideOfQualifiedName(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsLeftSideOfExplicitInterfaceSpecifier(NameSyntax name);
    [ExtensionAttribute]
public static bool IsExpressionOfInvocation(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool TryGetNameParts(ExpressionSyntax expression, IList`1& parts);
    [ExtensionAttribute]
public static bool TryGetNameParts(ExpressionSyntax expression, List`1<string> parts);
    private static bool AddSimpleName(SimpleNameSyntax simpleName, List`1<string> parts);
    [ExtensionAttribute]
public static bool IsAnyLiteralExpression(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInConstantContext(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInOutContext(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInRefContext(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInRefContext(ExpressionSyntax expression, SyntaxNode& refParent);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInInContext(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
private static ExpressionSyntax GetExpressionToAnalyzeForWrites(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsOnlyWrittenTo(ExpressionSyntax expression);
    private static bool IsExpressionOfArgumentInDeconstruction(ExpressionSyntax expr);
    [ExtensionAttribute]
public static bool IsWrittenTo(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAttributeNamedArgumentIdentifier(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsOperandOfIncrementOrDecrementExpression(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsNamedArgumentIdentifier(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsInsideNameOfExpression(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool CanReplace(ISymbol symbol);
    [ExtensionAttribute]
public static bool CanReplaceWithRValue(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool CanReplaceWithLValue(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsNameOfArgumentExpression(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsNameOfInvocation(InvocationExpressionSyntax invocation);
    [ExtensionAttribute]
public static SimpleNameSyntax GetRightmostName(ExpressionSyntax node);
    [ExtensionAttribute]
public static OperatorPrecedence GetOperatorPrecedence(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool TryConvertToStatement(ExpressionSyntax expression, Nullable`1<SyntaxToken> semicolonTokenOpt, bool createReturnStatementForExpression, StatementSyntax& statement);
    private static StatementSyntax ConvertToStatement(ExpressionSyntax expression, SyntaxToken semicolonToken, bool createReturnStatementForExpression);
    [ExtensionAttribute]
public static bool IsDirectChildOfMemberAccessExpression(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool InsideCrefReference(ExpressionSyntax expression);
    [ExtensionAttribute]
public static ExpressionSyntax Parenthesize(ExpressionSyntax expression, bool includeElasticTrivia, bool addSimplifierAnnotation);
    [ExtensionAttribute]
private static ExpressionSyntax ParenthesizeWorker(ExpressionSyntax expression, bool includeElasticTrivia);
    [ExtensionAttribute]
public static PatternSyntax Parenthesize(PatternSyntax pattern, bool includeElasticTrivia, bool addSimplifierAnnotation);
    [ExtensionAttribute]
public static CastExpressionSyntax Cast(ExpressionSyntax expression, ITypeSymbol targetType);
    [ExtensionAttribute]
public static ExpressionSyntax CastIfPossible(ExpressionSyntax expression, ITypeSymbol targetType, int position, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ShouldNameExpressionBeTreatedAsExpressionInsteadOfType(ExpressionSyntax name, SemanticModel semanticModel, SymbolInfo& leftHandBinding, ITypeSymbol& container);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ForEachStatementSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool IsTypeInferred(CommonForEachStatementSyntax forEachStatement, SemanticModel semanticModel);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ILocalSymbolExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool CanSafelyMoveLocalToBlock(ILocalSymbol localSymbol, SyntaxNode currentBlock, SyntaxNode destinationBlock);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <CanSafelyMoveLocalToBlock>g__HasTypeParameterWithName|0_0(SyntaxNode node, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ITypeParameterSymbolExtensions : object {
    [ExtensionAttribute]
public static SyntaxList`1<TypeParameterConstraintClauseSyntax> GenerateConstraintClauses(ImmutableArray`1<ITypeParameterSymbol> typeParameters);
    [ExtensionAttribute]
public static SyntaxList`1<TypeParameterConstraintClauseSyntax> GenerateConstraintClauses(IEnumerable`1<ITypeParameterSymbol> typeParameters);
    private static void AddConstraintClauses(List`1<TypeParameterConstraintClauseSyntax> clauses, ITypeParameterSymbol typeParameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ITypeSymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsIntrinsicType(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool TryGetPrimaryConstructor(INamedTypeSymbol typeSymbol, IMethodSymbol& primaryConstructor);
    [ExtensionAttribute]
public static ExpressionSyntax GenerateExpressionSyntax(ITypeSymbol typeSymbol, bool nameSyntax);
    [ExtensionAttribute]
public static NameSyntax GenerateNameSyntax(INamespaceOrTypeSymbol symbol, bool allowVar);
    [ExtensionAttribute]
public static TypeSyntax GenerateTypeSyntax(INamespaceOrTypeSymbol symbol, bool allowVar);
    private static TypeSyntax GenerateTypeSyntax(INamespaceOrTypeSymbol symbol, bool nameSyntax, bool allowVar);
    [ExtensionAttribute]
public static TypeSyntax GenerateRefTypeSyntax(INamespaceOrTypeSymbol symbol);
    [ExtensionAttribute]
public static TypeSyntax GenerateRefReadOnlyTypeSyntax(INamespaceOrTypeSymbol symbol);
    [ExtensionAttribute]
public static bool ContainingTypesOrSelfHasUnsafeKeyword(ITypeSymbol containingType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Extensions.ITypeSymbolExtensions/<FindApplicableAliasAsync>d__9")]
[ExtensionAttribute]
public static Task`1<ISymbol> FindApplicableAliasAsync(ITypeSymbol type, int position, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static IEnumerable`1<UsingDirectiveSyntax> GetApplicableUsings(int position, SyntaxNode root);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.MemberAccessExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static SimpleNameSyntax GetNameWithTriviaMoved(MemberAccessExpressionSyntax memberAccess);
    private static SyntaxTriviaList GetLeadingTriviaForSimplifiedMemberAccess(MemberAccessExpressionSyntax memberAccess);
    private static IEnumerable`1<SyntaxTrivia> WithoutElasticTrivia(IEnumerable`1<SyntaxTrivia> list);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.MemberDeclarationSyntaxExtensions : object {
    private static ConditionalWeakTable`2<MemberDeclarationSyntax, Dictionary`2<string, ImmutableArray`1<SyntaxToken>>> s_declarationCache;
    private static MemberDeclarationSyntaxExtensions();
    [ExtensionAttribute]
public static LocalDeclarationMap GetLocalDeclarationMap(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static SyntaxToken GetNameToken(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static int GetArity(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static TypeParameterListSyntax GetTypeParameterList(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static MemberDeclarationSyntax WithParameterList(MemberDeclarationSyntax member, BaseParameterListSyntax parameterList);
    [ExtensionAttribute]
public static TypeSyntax GetMemberType(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static bool HasMethodShape(MemberDeclarationSyntax memberDeclaration);
    [ExtensionAttribute]
public static BlockSyntax GetBody(MemberDeclarationSyntax memberDeclaration);
    [ExtensionAttribute]
public static ArrowExpressionClauseSyntax GetExpressionBody(MemberDeclarationSyntax memberDeclaration);
    [ExtensionAttribute]
public static MemberDeclarationSyntax WithBody(MemberDeclarationSyntax memberDeclaration, BlockSyntax body);
    [ExtensionAttribute]
public static SyntaxList`1<AttributeListSyntax> GetAttributes(MemberDeclarationSyntax member);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.NameSyntaxExtensions : object {
    [ExtensionAttribute]
public static IList`1<NameSyntax> GetNameParts(NameSyntax nameSyntax);
    [ExtensionAttribute]
public static NameSyntax GetLastDottedName(NameSyntax nameSyntax);
    [ExtensionAttribute]
public static SyntaxToken GetNameToken(NameSyntax nameSyntax);
    [ExtensionAttribute]
public static bool CanBeReplacedWithAnyName(NameSyntax nameSyntax);
}
internal enum Microsoft.CodeAnalysis.CSharp.Extensions.OperatorPrecedence : Enum {
    public int value__;
    public static OperatorPrecedence None;
    public static OperatorPrecedence AssignmentAndLambdaExpression;
    public static OperatorPrecedence Conditional;
    public static OperatorPrecedence NullCoalescing;
    public static OperatorPrecedence ConditionalOr;
    public static OperatorPrecedence ConditionalAnd;
    public static OperatorPrecedence LogicalOr;
    public static OperatorPrecedence LogicalXor;
    public static OperatorPrecedence LogicalAnd;
    public static OperatorPrecedence Equality;
    public static OperatorPrecedence RelationalAndTypeTesting;
    public static OperatorPrecedence Shift;
    public static OperatorPrecedence Additive;
    public static OperatorPrecedence Multiplicative;
    public static OperatorPrecedence Switch;
    public static OperatorPrecedence Range;
    public static OperatorPrecedence Unary;
    public static OperatorPrecedence Primary;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ParenthesizedExpressionSyntaxExtensions : object {
    private static ObjectPool`1<Stack`1<SyntaxNode>> s_nodeStackPool;
    private static ParenthesizedExpressionSyntaxExtensions();
    [ExtensionAttribute]
public static bool CanRemoveParentheses(ParenthesizedExpressionSyntax node, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool RemovalWouldChangeConstantReferenceToTypeReference(ParenthesizedExpressionSyntax node, ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool RemovalMayIntroduceInterpolationAmbiguity(ParenthesizedExpressionSyntax node);
    private static bool RemovalChangesAssociation(ParenthesizedExpressionSyntax node, ExpressionSyntax parentExpression, SemanticModel semanticModel);
    private static bool IsAssociative(SyntaxKind kind);
    private static bool RemovalMayIntroduceCastAmbiguity(ParenthesizedExpressionSyntax node);
    private static bool StartsWithAlias(NameSyntax name);
    private static bool RemovalMayIntroduceCommaListAmbiguity(ParenthesizedExpressionSyntax node);
    private static bool IsPreviousExpressionPotentiallyAmbiguous(ExpressionSyntax node);
    private static bool IsNextExpressionPotentiallyAmbiguous(ExpressionSyntax node);
    private static bool IsSimpleOrDottedName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool CanRemoveParentheses(ParenthesizedPatternSyntax node);
    private static bool RemovalChangesAssociation(ParenthesizedPatternSyntax node, PatternSyntax parentPattern);
    [ExtensionAttribute]
public static OperatorPrecedence GetOperatorPrecedence(PatternSyntax pattern);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ParseOptionsExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static LanguageVersion LanguageVersion(ParseOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.QueryExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static IList`1<SyntaxNode> GetAllClauses(QueryExpressionSyntax query);
    [ExtensionAttribute]
public static IList`1<SyntaxNode> GetAllClauses(QueryBodySyntax body);
    [ExtensionAttribute]
public static QueryExpressionSyntax WithAllClauses(QueryExpressionSyntax query, IList`1<SyntaxNode> allClauses);
    [ExtensionAttribute]
public static QueryBodySyntax WithAllClauses(QueryBodySyntax body, IEnumerable`1<SyntaxNode> allClauses);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SemanticModelExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<ParameterName> GenerateParameterNames(SemanticModel semanticModel, ArgumentListSyntax argumentList, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ParameterName> GenerateParameterNames(SemanticModel semanticModel, AttributeArgumentListSyntax argumentList, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ParameterName> GenerateParameterNames(SemanticModel semanticModel, IEnumerable`1<ArgumentSyntax> arguments, IList`1<string> reservedNames, CancellationToken cancellationToken);
    public static ImmutableArray`1<ParameterName> GenerateNames(IList`1<string> reservedNames, ImmutableArray`1<bool> isFixed, ImmutableArray`1<string> parameterNames);
    [ExtensionAttribute]
public static ImmutableArray`1<ParameterName> GenerateParameterNames(SemanticModel semanticModel, IEnumerable`1<AttributeArgumentSyntax> arguments, IList`1<string> reservedNames, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static string GenerateNameForArgument(SemanticModel semanticModel, ArgumentSyntax argument, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static string GenerateNameForArgument(SemanticModel semanticModel, AttributeArgumentSyntax argument, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> LookupTypeRegardlessOfArity(SemanticModel semanticModel, SyntaxToken name, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> LookupName(SemanticModel semanticModel, SyntaxToken name, CancellationToken cancellationToken);
    private static void DecomposeName(ExpressionSyntax expression, ExpressionSyntax& qualifier, String& name, Int32& arity);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> LookupName(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, SyntaxToken token);
    private static bool CanBindToken(SyntaxToken token);
    [ExtensionAttribute]
public static ISet`1<INamespaceSymbol> GetUsingNamespacesInScope(SemanticModel semanticModel, SyntaxNode location);
    [ExtensionAttribute]
public static Accessibility DetermineAccessibilityConstraint(SemanticModel semanticModel, TypeSyntax type, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool AllContainingTypesArePublicOrProtected(SemanticModel semanticModel, TypeSyntax type, CancellationToken cancellationToken);
    private static TypeSyntax GetOutermostType(TypeSyntax type);
    [ExtensionAttribute]
public static string GenerateNameForExpression(SemanticModel semanticModel, ExpressionSyntax expression, bool capitalize, CancellationToken cancellationToken);
    private static string TryGenerateNameForArgumentExpression(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol GetRequiredDeclaredSymbol(SemanticModel semanticModel, BaseTypeDeclarationSyntax syntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol GetRequiredDeclaredSymbol(SemanticModel semanticModel, ConstructorDeclarationSyntax syntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol GetRequiredDeclaredSymbol(SemanticModel semanticModel, LocalFunctionStatementSyntax syntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IParameterSymbol GetRequiredDeclaredSymbol(SemanticModel semanticModel, ParameterSyntax syntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IPropertySymbol GetRequiredDeclaredSymbol(SemanticModel semanticModel, PropertyDeclarationSyntax syntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISymbol GetRequiredDeclaredSymbol(SemanticModel semanticModel, VariableDeclaratorSyntax syntax, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SeparatedSyntaxListExtensions : object {
    [ExtensionAttribute]
public static SeparatedSyntaxList`1<T> AddRangeWithTrailingSeparator(SeparatedSyntaxList`1<T> separatedList, IEnumerable`1<T> nodes, SyntaxKind separator);
    [ExtensionAttribute]
public static SeparatedSyntaxList`1<T> InsertRangeWithTrailingSeparator(SeparatedSyntaxList`1<T> separatedList, int index, IEnumerable`1<T> nodes, SyntaxKind separator);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SimpleNameSyntaxExtensions : object {
    [ExtensionAttribute]
public static ExpressionSyntax GetLeftSideOfDot(SimpleNameSyntax name);
    [ExtensionAttribute]
public static bool LooksLikeStandaloneTypeName(SimpleNameSyntax simpleName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.StatementSyntaxExtensions : object {
    [ExtensionAttribute]
public static StatementSyntax WithoutLeadingBlankLinesInTrivia(StatementSyntax statement);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static StatementSyntax GetPreviousStatement(StatementSyntax statement);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static StatementSyntax GetNextStatement(StatementSyntax statement);
    private static bool AreSiblingStatements(StatementSyntax first, StatementSyntax second);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static string EscapeIdentifier(string identifier, bool isQueryContext);
    [ExtensionAttribute]
public static SyntaxToken ToIdentifierToken(string identifier, bool isQueryContext);
    [ExtensionAttribute]
public static IdentifierNameSyntax ToIdentifierName(string identifier);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SymbolDisplayPartExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SymbolDisplayPart MassageErrorTypeNames(SymbolDisplayPart part, string replacement);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxKindExtensions : object {
    [ExtensionAttribute]
public static bool Contains(SyntaxKind[] kinds, SyntaxKind kind);
    [ExtensionAttribute]
public static SyntaxKind MapCompoundAssignmentKindToBinaryExpressionKind(SyntaxKind syntaxKind);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxListExtensions : object {
    [ExtensionAttribute]
public static SyntaxList`1<T> RemoveRange(SyntaxList`1<T> syntaxList, int index, int count);
    [ExtensionAttribute]
public static SyntaxList`1<T> Insert(SyntaxList`1<T> list, int index, T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxNodeExtensions : object {
    [ExtensionAttribute]
public static LanguageVersion GetLanguageVersion(SyntaxNode node);
    [ExtensionAttribute]
public static void Deconstruct(SyntaxNode node, SyntaxKind& kind);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind, TNode& result);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind, TNode& result);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> GetAllPrecedingTriviaToPreviousToken(SyntaxNode node, SourceText sourceText, bool includePreviousTokenTrailingTriviaOnlyIfOnSameLine);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> GetAllPrecedingTriviaToPreviousToken(SyntaxToken token, SourceText sourceText, bool includePreviousTokenTrailingTriviaOnlyIfOnSameLine);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAnyArgumentList(SyntaxNode node);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetBraces(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEmbeddedStatementOwner(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static StatementSyntax GetEmbeddedStatement(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static BaseParameterListSyntax GetParameterList(SyntaxNode declaration);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxList`1<AttributeListSyntax> GetAttributeLists(SyntaxNode declaration);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ConditionalAccessExpressionSyntax GetParentConditionalAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ConditionalAccessExpressionSyntax GetRootConditionalAccessExpression(SyntaxNode node);
    [ExtensionAttribute]
public static ConditionalAccessExpressionSyntax GetInnerMostConditionalAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsCompoundAssignExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsLeftSideOfAssignExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsLeftSideOfAnyAssignExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsRightSideOfAnyAssignExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsLeftSideOfCompoundAssignExpression(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<UsingDirectiveSyntax> GetEnclosingUsingDirectives(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<ExternAliasDirectiveSyntax> GetEnclosingExternAliasDirectives(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsUnsafeContext(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsInStaticContext(SyntaxNode node);
    [ExtensionAttribute]
public static BaseNamespaceDeclarationSyntax GetInnermostNamespaceDeclarationWithUsings(SyntaxNode contextNode);
    [ExtensionAttribute]
public static bool IsBreakableConstruct(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsContinuableConstruct(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsReturnableConstruct(SyntaxNode node);
    [ExtensionAttribute]
public static bool ContainsYield(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsReturnableConstructOrTopLevelCompilationUnit(SyntaxNode node);
    [ExtensionAttribute]
public static bool SpansPreprocessorDirective(IEnumerable`1<TSyntaxNode> list);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TNode ConvertToSingleLine(TNode node, bool useElasticTrivia);
    [ExtensionAttribute]
public static bool ContainsInterleavedDirective(SyntaxNode syntaxNode, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ContainsInterleavedDirective(SyntaxNode syntaxNode, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ContainsInterleavedDirective(SyntaxToken token, TextSpan textSpan, CancellationToken cancellationToken);
    private static bool ContainsInterleavedDirective(TextSpan textSpan, SyntaxTriviaList list, CancellationToken cancellationToken);
    private static bool ContainsInterleavedDirective(TextSpan textSpan, SyntaxTrivia trivia, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IList`1<IList`1<TSyntaxNode>> SplitNodesOnPreprocessorBoundaries(IEnumerable`1<TSyntaxNode> nodes, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<SyntaxTrivia> GetLeadingBlankLines(TSyntaxNode node);
    [ExtensionAttribute]
public static TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node);
    [ExtensionAttribute]
public static TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node, ImmutableArray`1& strippedTrivia);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<SyntaxTrivia> GetLeadingBannerAndPreprocessorDirectives(TSyntaxNode node);
    [ExtensionAttribute]
public static TSyntaxNode GetNodeWithoutLeadingBannerAndPreprocessorDirectives(TSyntaxNode node);
    [ExtensionAttribute]
public static TSyntaxNode GetNodeWithoutLeadingBannerAndPreprocessorDirectives(TSyntaxNode node, ImmutableArray`1& strippedTrivia);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsVariableDeclaratorValue(SyntaxNode node);
    [ExtensionAttribute]
public static BlockSyntax FindInnermostCommonBlock(IEnumerable`1<SyntaxNode> nodes);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxNodeExtensions/<GetAncestorsOrThis>d__48")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> GetAncestorsOrThis(SyntaxNode node, Func`2<SyntaxNode, bool> predicate);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetParentheses(SyntaxNode node);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetBrackets(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxTokenList GetModifiers(SyntaxNode member);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxNode WithModifiers(SyntaxNode member, SyntaxTokenList modifiers);
    [ExtensionAttribute]
public static IEnumerable`1<MemberDeclarationSyntax> GetMembers(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInExpressionTree(SyntaxNode node, SemanticModel semanticModel, INamedTypeSymbol expressionType, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInDeconstructionLeft(SyntaxNode node, SyntaxNode& deconstructionLeft);
    [ExtensionAttribute]
public static T WithCommentsFrom(T node, SyntaxToken leadingToken, SyntaxToken trailingToken);
    [ExtensionAttribute]
public static T WithCommentsFrom(T node, IEnumerable`1<SyntaxToken> leadingTokens, IEnumerable`1<SyntaxToken> trailingTokens);
    [ExtensionAttribute]
public static T WithCommentsFrom(T node, IEnumerable`1<SyntaxTrivia> leadingTrivia, IEnumerable`1<SyntaxTrivia> trailingTrivia, SyntaxNodeOrToken[] trailingNodesOrTokens);
    [ExtensionAttribute]
public static T KeepCommentsAndAddElasticMarkers(T node);
    [ExtensionAttribute]
public static SyntaxNode WithPrependedNonIndentationTriviaFrom(SyntaxNode to, SyntaxNode from);
    [CompilerGeneratedAttribute]
internal static bool <IsInExpressionTree>g__TakesExpressionTree|54_0(SymbolInfo info, INamedTypeSymbol expressionType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTokenExtensions : object {
    [ExtensionAttribute]
public static void Deconstruct(SyntaxToken token, SyntaxKind& kind);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool IsLastTokenOfNode(SyntaxToken token);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool IsLastTokenOfNode(SyntaxToken token, T& node);
    [ExtensionAttribute]
public static bool IsKindOrHasMatchingText(SyntaxToken token, SyntaxKind kind);
    [ExtensionAttribute]
public static bool HasMatchingText(SyntaxToken token, SyntaxKind kind);
    [ExtensionAttribute]
public static bool IsOpenBraceOrCommaOfObjectInitializer(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsOpenBraceOfAccessorList(SyntaxToken token);
    [ExtensionAttribute]
public static bool CouldBeKeyword(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsPotentialModifier(SyntaxToken token, SyntaxKind& modifierKind);
    [ExtensionAttribute]
public static bool IsLiteral(SyntaxToken token);
    [ExtensionAttribute]
public static bool IntersectsWith(SyntaxToken token, int position);
    [ExtensionAttribute]
public static SyntaxToken GetPreviousTokenIfTouchingWord(SyntaxToken token, int position);
    private static bool IsWord(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken GetNextNonZeroWidthTokenOrEndOfFile(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsFirstTokenOnLine(SyntaxToken token, SourceText text);
    [ExtensionAttribute]
public static bool SpansPreprocessorDirective(IEnumerable`1<SyntaxToken> tokens);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTokenExtensions/<GetAllTrailingTrivia>d__16")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> GetAllTrailingTrivia(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsRegularStringLiteral(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsValidAttributeTarget(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken WithCommentsFrom(SyntaxToken token, IEnumerable`1<SyntaxTrivia> leadingTrivia, IEnumerable`1<SyntaxTrivia> trailingTrivia, SyntaxNodeOrToken[] trailingNodesOrTokens);
    [ExtensionAttribute]
public static SyntaxToken KeepCommentsAndAddElasticMarkers(SyntaxToken token);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryParseGenericName(SyntaxToken genericIdentifier, CancellationToken cancellationToken, GenericNameSyntax& genericName);
    [ExtensionAttribute]
public static SyntaxToken FindLastTokenOfPartialGenericName(SyntaxToken genericIdentifier);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTokenListExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxToken> SkipKinds(SyntaxTokenList tokenList, SyntaxKind[] kinds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTreeExtensions : object {
    private static Func`2<SyntaxKind, bool> s_isDotOrArrow;
    private static Func`2<SyntaxKind, bool> s_isDotOrArrowOrColonColon;
    private static SyntaxTreeExtensions();
    [ExtensionAttribute]
public static ISet`1<SyntaxKind> GetPrecedingModifiers(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISet`1<SyntaxKind> GetPrecedingModifiers(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, Int32& positionBeforeModifiers);
    [ExtensionAttribute]
public static TypeDeclarationSyntax GetContainingTypeDeclaration(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static BaseTypeDeclarationSyntax GetContainingTypeOrEnumDeclaration(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<TypeDeclarationSyntax> GetContainingTypeDeclarations(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static bool BaseTypeDeclarationContainsPosition(BaseTypeDeclarationSyntax declaration, int position);
    [ExtensionAttribute]
public static IEnumerable`1<BaseTypeDeclarationSyntax> GetContainingTypeOrEnumDeclarations(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsRightOfDotOrArrowOrColonColon(SyntaxTree syntaxTree, int position, SyntaxToken targetToken, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsRightOfDotOrArrow(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static bool IsRightOf(SyntaxTree syntaxTree, int position, Func`2<SyntaxKind, bool> predicate, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsRightOfNumericLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsAfterKeyword(SyntaxTree syntaxTree, int position, SyntaxKind kind, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinNonUserCodeComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsCrefContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinCrefSyntax(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinSingleLineDocComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinMultiLineDocComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinMultiLineComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinConflictMarker(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinTopLevelSingleLineComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinPreProcessorSingleLineComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static bool AtEndOfIncompleteStringOrCharLiteral(SyntaxToken token, int position, char lastChar, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinStringOrCharLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinStringLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinStringLiteral(SyntaxTree syntaxTree, int position, SyntaxToken& stringLiteral, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinCharLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsInInactiveRegion(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPreProcessorKeywordContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPreProcessorKeywordContext(SyntaxTree syntaxTree, int position, SyntaxToken preProcessorTokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsPrimaryFunctionExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsInNonUserCode(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsInPartiallyWrittenGeneric(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsInPartiallyWrittenGeneric(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, SyntaxToken& genericIdentifier);
    [ExtensionAttribute]
public static bool IsInPartiallyWrittenGeneric(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, SyntaxToken& genericIdentifier, SyntaxToken& lessThanToken);
    private static bool IsFullyWrittenGeneric(SyntaxToken token, SyntaxToken lessThanToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTriviaExtensions : object {
    [ExtensionAttribute]
public static void Deconstruct(SyntaxTrivia trivia, SyntaxKind& kind);
    [ExtensionAttribute]
public static bool IsSingleOrMultiLineComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsRegularComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsWhitespaceOrSingleOrMultiLineComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsRegularOrDocComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsSingleLineComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsMultiLineComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsShebangDirective(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsCompleteMultiLineComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsDocComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsSingleLineDocComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsMultiLineDocComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static string GetCommentText(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static string AsString(IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static int GetFullWidth(IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static SyntaxTriviaList AsTrivia(string s);
    [ExtensionAttribute]
public static bool IsWhitespaceOrEndOfLine(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsEndOfLine(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsWhitespace(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static SyntaxTrivia GetPreviousTrivia(SyntaxTrivia trivia, SyntaxTree syntaxTree, CancellationToken cancellationToken, bool findInsideTrivia);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTriviaExtensions/<FilterComments>d__20")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> FilterComments(IEnumerable`1<SyntaxTrivia> trivia, bool addElasticMarker);
    [ExtensionAttribute]
public static bool IsPragmaDirective(SyntaxTrivia trivia, Boolean& isDisable, Boolean& isActive, SeparatedSyntaxList`1& errorCodes);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTriviaListExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<SyntaxTrivia> GetFirstNewLine(SyntaxTriviaList triviaList);
    [ExtensionAttribute]
public static Nullable`1<SyntaxTrivia> GetLastComment(SyntaxTriviaList triviaList);
    [ExtensionAttribute]
public static Nullable`1<SyntaxTrivia> GetLastCommentOrWhitespace(SyntaxTriviaList triviaList);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> SkipInitialWhitespace(SyntaxTriviaList triviaList);
    private static ImmutableArray`1<ImmutableArray`1<SyntaxTrivia>> GetLeadingBlankLines(SyntaxTriviaList triviaList);
    [ExtensionAttribute]
public static SyntaxTriviaList WithoutLeadingBlankLines(SyntaxTriviaList triviaList);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTriviaListExtensions/<TakeRange>d__6")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> TakeRange(SyntaxTriviaList triviaList, int start, int end);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.TypeDeclarationSyntaxExtensions : object {
    [ExtensionAttribute]
public static IList`1<bool> GetInsertionIndices(TypeDeclarationSyntax destination, CancellationToken cancellationToken);
    private static SyntaxToken GetEndToken(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<BaseTypeSyntax> GetAllBaseListTypes(TypeDeclarationSyntax typeNode, SemanticModel model, CancellationToken cancellationToken);
    private static SyntaxToken EnsureToken(SyntaxToken token, SyntaxKind kind, bool prependNewLineIfMissing, bool appendNewLineIfMissing);
    private static BaseTypeDeclarationSyntax EnsureHasBraces(BaseTypeDeclarationSyntax typeDeclaration, bool hasMembers);
    [ExtensionAttribute]
public static TypeDeclarationSyntax EnsureOpenAndCloseBraceTokens(TypeDeclarationSyntax typeDeclaration);
    [ExtensionAttribute]
public static EnumDeclarationSyntax EnsureOpenAndCloseBraceTokens(EnumDeclarationSyntax typeDeclaration);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.TypeSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool IsVoid(TypeSyntax typeSyntax);
    [ExtensionAttribute]
public static bool IsPartial(TypeSyntax typeSyntax);
    [ExtensionAttribute]
public static bool IsTypeInferred(TypeSyntax typeSyntax, SemanticModel semanticModel);
    [ExtensionAttribute]
public static TypeSyntax StripRefIfNeeded(TypeSyntax type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsPotentialTypeName(TypeSyntax typeSyntax, SemanticModel semanticModelOpt, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static TypeSyntax GenerateReturnTypeSyntax(IMethodSymbol method);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.UsingDirectiveSyntaxExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void SortUsingDirectives(List`1<UsingDirectiveSyntax> usingDirectives, SyntaxList`1<UsingDirectiveSyntax> existingDirectives, bool placeSystemNamespaceFirst);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.VariableDeclaratorExtensions : object {
    [ExtensionAttribute]
public static TypeSyntax GetVariableType(VariableDeclaratorSyntax declarator);
    [ExtensionAttribute]
public static bool IsTypeInferred(VariableDeclaratorSyntax variable, SemanticModel semanticModel);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.FindSymbols.IDeclaredSymbolInfoFactoryService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.FindSymbols.CSharpDeclaredSymbolInfoFactoryService : AbstractDeclaredSymbolInfoFactoryService`10<CompilationUnitSyntax, UsingDirectiveSyntax, BaseNamespaceDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax, MethodDeclarationSyntax, MemberDeclarationSyntax, NameSyntax, QualifiedNameSyntax, IdentifierNameSyntax> {
    private static ImmutableArray`1<string> GetInheritanceNames(StringTable stringTable, BaseListSyntax baseList);
    private static void AddAliasMaps(SyntaxNode node, List`1<Dictionary`2<string, string>> aliasMaps);
    private static void ProcessUsings(List`1<Dictionary`2<string, string>> aliasMaps, SyntaxList`1<UsingDirectiveSyntax> usings);
    private static void AddInheritanceName(ArrayBuilder`1<string> builder, TypeSyntax type, List`1<Dictionary`2<string, string>> aliasMaps);
    protected virtual void AddLocalFunctionInfos(MemberDeclarationSyntax memberDeclaration, StringTable stringTable, ArrayBuilder`1<DeclaredSymbolInfo> declaredSymbolInfos, string containerDisplayName, string fullyQualifiedContainerName, CancellationToken cancellationToken);
    protected virtual Nullable`1<DeclaredSymbolInfo> GetTypeDeclarationInfo(SyntaxNode container, TypeDeclarationSyntax typeDeclaration, StringTable stringTable, string containerDisplayName, string fullyQualifiedContainerName);
    protected virtual DeclaredSymbolInfo GetEnumDeclarationInfo(SyntaxNode container, EnumDeclarationSyntax enumDeclaration, StringTable stringTable, string containerDisplayName, string fullyQualifiedContainerName);
    protected virtual void AddMemberDeclarationInfos(SyntaxNode container, MemberDeclarationSyntax node, StringTable stringTable, ArrayBuilder`1<DeclaredSymbolInfo> declaredSymbolInfos, string containerDisplayName, string fullyQualifiedContainerName);
    protected virtual void AddSynthesizedDeclaredSymbolInfos(SyntaxNode container, MemberDeclarationSyntax memberDeclaration, StringTable stringTable, ArrayBuilder`1<DeclaredSymbolInfo> declaredSymbolInfos, string containerDisplayName, string fullyQualifiedContainerName, CancellationToken cancellationToken);
    protected virtual SyntaxList`1<MemberDeclarationSyntax> GetChildren(CompilationUnitSyntax node);
    protected virtual SyntaxList`1<MemberDeclarationSyntax> GetChildren(BaseNamespaceDeclarationSyntax node);
    protected virtual SyntaxList`1<MemberDeclarationSyntax> GetChildren(TypeDeclarationSyntax node);
    protected virtual IEnumerable`1<MemberDeclarationSyntax> GetChildren(EnumDeclarationSyntax node);
    protected virtual SyntaxList`1<UsingDirectiveSyntax> GetUsingAliases(CompilationUnitSyntax node);
    protected virtual SyntaxList`1<UsingDirectiveSyntax> GetUsingAliases(BaseNamespaceDeclarationSyntax node);
    protected virtual NameSyntax GetName(BaseNamespaceDeclarationSyntax node);
    protected virtual NameSyntax GetLeft(QualifiedNameSyntax node);
    protected virtual NameSyntax GetRight(QualifiedNameSyntax node);
    protected virtual SyntaxToken GetIdentifier(IdentifierNameSyntax node);
    private static bool IsNestedType(BaseTypeDeclarationSyntax typeDecl);
    private static string GetConstructorSuffix(ConstructorDeclarationSyntax constructor);
    private static string GetMethodSuffix(MethodDeclarationSyntax method);
    private static string GetMethodSuffix(LocalFunctionStatementSyntax method);
    private static string GetIndexerSuffix(IndexerDeclarationSyntax indexer);
    private static string GetTypeParameterSuffix(TypeParameterListSyntax typeParameterList);
    private static string GetSuffix(char openBrace, char closeBrace, SeparatedSyntaxList`1<ParameterSyntax> parameters);
    private static void AppendParameters(SeparatedSyntaxList`1<ParameterSyntax> parameters, StringBuilder builder);
    protected virtual string GetContainerDisplayName(MemberDeclarationSyntax node);
    protected virtual string GetFullyQualifiedContainerName(MemberDeclarationSyntax node, string rootNamespace);
    private static Accessibility GetAccessibility(SyntaxNode container, SyntaxTokenList modifiers);
    private static string GetTypeName(TypeSyntax type);
    private static string GetSimpleTypeName(SimpleNameSyntax name);
    private static bool IsExtensionMethod(MethodDeclarationSyntax method);
    protected virtual string GetRootNamespace(CompilationOptions compilationOptions);
    protected virtual bool TryGetAliasesFromUsingDirective(UsingDirectiveSyntax usingDirectiveNode, ImmutableArray`1& aliases);
    protected virtual string GetReceiverTypeName(MethodDeclarationSyntax methodDeclaration);
    private static bool TryGetSimpleTypeName(SyntaxNode node, Nullable`1<ImmutableArray`1<string>> typeParameterNames, String& simpleTypeName, Boolean& isArray);
    private static string GetSpecialTypeName(PredefinedTypeSyntax predefinedTypeNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.AggregatedFormattingResult : AbstractAggregatedFormattingResult {
    public AggregatedFormattingResult(SyntaxNode node, IList`1<AbstractFormattingResult> results, TextSpanIntervalTree formattingSpans);
    protected virtual SyntaxNode Rewriter(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> map, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.AnchorIndentationFormattingRule : BaseFormattingRule {
    internal static string Name;
    public virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, NextAnchorIndentationOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static void AddAnchorIndentationOperation(List`1<AnchorIndentationOperation> list, SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Formatting.BaseFormattingRule : AbstractFormattingRule {
    protected static void AddUnindentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, IndentBlockOption option);
    protected static void AddUnindentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken startToken, SyntaxToken endToken, bool includeTriviaAtEnd, IndentBlockOption option);
    protected static void AddAbsoluteZeroIndentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken startToken, SyntaxToken endToken, IndentBlockOption option);
    protected static void AddIndentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken startToken, SyntaxToken endToken, IndentBlockOption option);
    protected static void AddIndentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, IndentBlockOption option);
    protected static void AddIndentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, IndentBlockOption option);
    protected static void SetAlignmentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, IndentBlockOption option);
    protected static void AddSuppressWrappingIfOnSingleLineOperation(List`1<SuppressOperation> list, SyntaxToken startToken, SyntaxToken endToken, SuppressOption extraOption);
    protected static void AddSuppressAllOperationIfOnMultipleLine(List`1<SuppressOperation> list, SyntaxToken startToken, SyntaxToken endToken, SuppressOption extraOption);
    protected static void AddSuppressOperation(List`1<SuppressOperation> list, SyntaxToken startToken, SyntaxToken endToken, SuppressOption option);
    protected static void AddAnchorIndentationOperation(List`1<AnchorIndentationOperation> list, SyntaxToken anchorToken, SyntaxToken endToken);
    protected static void AddAlignIndentationOfTokensToBaseTokenOperation(List`1<AlignTokensOperation> list, SyntaxNode containingNode, SyntaxToken baseNode, IEnumerable`1<SyntaxToken> tokens, AlignTokensOption option);
    protected static AdjustNewLinesOperation CreateAdjustNewLinesOperation(int line, AdjustNewLinesOption option);
    protected static AdjustSpacesOperation CreateAdjustSpacesOperation(int space, AdjustSpacesOption option);
    protected static void AddBraceSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
}
public enum Microsoft.CodeAnalysis.CSharp.Formatting.BinaryOperatorSpacingOptions : Enum {
    public int value__;
    public static BinaryOperatorSpacingOptions Single;
    public static BinaryOperatorSpacingOptions Ignore;
    public static BinaryOperatorSpacingOptions Remove;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormatEngine : AbstractFormatEngine {
    internal IHeaderFacts HeaderFacts { get; }
    public CSharpFormatEngine(SyntaxNode node, SyntaxFormattingOptions options, IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxToken startToken, SyntaxToken endToken);
    internal virtual IHeaderFacts get_HeaderFacts();
    protected virtual AbstractTriviaDataFactory CreateTriviaFactory();
    protected virtual AbstractFormattingResult CreateFormattingResult(TokenStream tokenStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormattingOptionGroups : object {
    public static OptionGroup Indentation;
    public static OptionGroup Spacing;
    public static OptionGroup Wrapping;
    private static CSharpFormattingOptionGroups();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormattingOptions : object {
    private static string PublicFeatureName;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpacingAfterMethodDeclarationName>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceWithinMethodDeclarationParenthesis>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceBetweenEmptyMethodDeclarationParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceAfterMethodCallName>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceWithinMethodCallParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceBetweenEmptyMethodCallParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceAfterControlFlowStatementKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceWithinExpressionParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceWithinCastParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceWithinOtherParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceAfterCast>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpacesIgnoreAroundVariableDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceBeforeOpenSquareBracket>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceBetweenEmptySquareBrackets>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceWithinSquareBrackets>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceAfterColonInBaseTypeDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceAfterComma>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceAfterDot>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceAfterSemicolonsInForStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceBeforeColonInBaseTypeDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceBeforeComma>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceBeforeDot>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceBeforeSemicolonsInForStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<BinaryOperatorSpacingOptions> <SpacingAroundBinaryOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <IndentBraces>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <IndentBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <IndentSwitchSection>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <IndentSwitchCaseSection>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <IndentSwitchCaseSectionWhenBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<LabelPositionOptions> <LabelPositioning>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <WrappingPreserveSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <WrappingKeepStatementsOnSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLinesForBracesInTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLinesForBracesInMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLinesForBracesInProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLinesForBracesInAccessors>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLinesForBracesInAnonymousMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLinesForBracesInControlBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLinesForBracesInAnonymousTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLinesForBracesInObjectCollectionArrayInitializers>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLinesForBracesInLambdaExpressionBody>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLineForElse>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLineForCatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLineForFinally>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLineForMembersInObjectInit>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLineForMembersInAnonymousTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLineForClausesInQuery>k__BackingField;
    public static Option`1<bool> SpacingAfterMethodDeclarationName { get; }
    public static Option`1<bool> SpaceWithinMethodDeclarationParenthesis { get; }
    public static Option`1<bool> SpaceBetweenEmptyMethodDeclarationParentheses { get; }
    public static Option`1<bool> SpaceAfterMethodCallName { get; }
    public static Option`1<bool> SpaceWithinMethodCallParentheses { get; }
    public static Option`1<bool> SpaceBetweenEmptyMethodCallParentheses { get; }
    public static Option`1<bool> SpaceAfterControlFlowStatementKeyword { get; }
    public static Option`1<bool> SpaceWithinExpressionParentheses { get; }
    public static Option`1<bool> SpaceWithinCastParentheses { get; }
    public static Option`1<bool> SpaceWithinOtherParentheses { get; }
    public static Option`1<bool> SpaceAfterCast { get; }
    public static Option`1<bool> SpacesIgnoreAroundVariableDeclaration { get; }
    public static Option`1<bool> SpaceBeforeOpenSquareBracket { get; }
    public static Option`1<bool> SpaceBetweenEmptySquareBrackets { get; }
    public static Option`1<bool> SpaceWithinSquareBrackets { get; }
    public static Option`1<bool> SpaceAfterColonInBaseTypeDeclaration { get; }
    public static Option`1<bool> SpaceAfterComma { get; }
    public static Option`1<bool> SpaceAfterDot { get; }
    public static Option`1<bool> SpaceAfterSemicolonsInForStatement { get; }
    public static Option`1<bool> SpaceBeforeColonInBaseTypeDeclaration { get; }
    public static Option`1<bool> SpaceBeforeComma { get; }
    public static Option`1<bool> SpaceBeforeDot { get; }
    public static Option`1<bool> SpaceBeforeSemicolonsInForStatement { get; }
    public static Option`1<BinaryOperatorSpacingOptions> SpacingAroundBinaryOperator { get; }
    public static Option`1<bool> IndentBraces { get; }
    public static Option`1<bool> IndentBlock { get; }
    public static Option`1<bool> IndentSwitchSection { get; }
    public static Option`1<bool> IndentSwitchCaseSection { get; }
    public static Option`1<bool> IndentSwitchCaseSectionWhenBlock { get; }
    public static Option`1<LabelPositionOptions> LabelPositioning { get; }
    public static Option`1<bool> WrappingPreserveSingleLine { get; }
    public static Option`1<bool> WrappingKeepStatementsOnSingleLine { get; }
    public static Option`1<bool> NewLinesForBracesInTypes { get; }
    public static Option`1<bool> NewLinesForBracesInMethods { get; }
    public static Option`1<bool> NewLinesForBracesInProperties { get; }
    public static Option`1<bool> NewLinesForBracesInAccessors { get; }
    public static Option`1<bool> NewLinesForBracesInAnonymousMethods { get; }
    public static Option`1<bool> NewLinesForBracesInControlBlocks { get; }
    public static Option`1<bool> NewLinesForBracesInAnonymousTypes { get; }
    public static Option`1<bool> NewLinesForBracesInObjectCollectionArrayInitializers { get; }
    public static Option`1<bool> NewLinesForBracesInLambdaExpressionBody { get; }
    public static Option`1<bool> NewLineForElse { get; }
    public static Option`1<bool> NewLineForCatch { get; }
    public static Option`1<bool> NewLineForFinally { get; }
    public static Option`1<bool> NewLineForMembersInObjectInit { get; }
    public static Option`1<bool> NewLineForMembersInAnonymousTypes { get; }
    public static Option`1<bool> NewLineForClausesInQuery { get; }
    private static CSharpFormattingOptions();
    private static Option`1<bool> CreateNewLineForBracesOption(string publicName, NewLineBeforeOpenBracePlacement flag);
    private static Option`1<bool> CreateSpaceWithinOption(string publicName, SpacePlacementWithinParentheses flag);
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpacingAfterMethodDeclarationName();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceWithinMethodDeclarationParenthesis();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceBetweenEmptyMethodDeclarationParentheses();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceAfterMethodCallName();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceWithinMethodCallParentheses();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceBetweenEmptyMethodCallParentheses();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceAfterControlFlowStatementKeyword();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceWithinExpressionParentheses();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceWithinCastParentheses();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceWithinOtherParentheses();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceAfterCast();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpacesIgnoreAroundVariableDeclaration();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceBeforeOpenSquareBracket();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceBetweenEmptySquareBrackets();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceWithinSquareBrackets();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceAfterColonInBaseTypeDeclaration();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceAfterComma();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceAfterDot();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceAfterSemicolonsInForStatement();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceBeforeColonInBaseTypeDeclaration();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceBeforeComma();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceBeforeDot();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceBeforeSemicolonsInForStatement();
    [CompilerGeneratedAttribute]
public static Option`1<BinaryOperatorSpacingOptions> get_SpacingAroundBinaryOperator();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_IndentBraces();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_IndentBlock();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_IndentSwitchSection();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_IndentSwitchCaseSection();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_IndentSwitchCaseSectionWhenBlock();
    [CompilerGeneratedAttribute]
public static Option`1<LabelPositionOptions> get_LabelPositioning();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_WrappingPreserveSingleLine();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_WrappingKeepStatementsOnSingleLine();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLinesForBracesInTypes();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLinesForBracesInMethods();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLinesForBracesInProperties();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLinesForBracesInAccessors();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLinesForBracesInAnonymousMethods();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLinesForBracesInControlBlocks();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLinesForBracesInAnonymousTypes();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLinesForBracesInObjectCollectionArrayInitializers();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLinesForBracesInLambdaExpressionBody();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLineForElse();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLineForCatch();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLineForFinally();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLineForMembersInObjectInit();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLineForMembersInAnonymousTypes();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLineForClausesInQuery();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormattingOptions2 : object {
    private static string PublicFeatureName;
    private static Builder<IOption2> s_allOptionsBuilder;
    private static BidirectionalMap`2<string, SpacePlacementWithinParentheses> s_spacingWithinParenthesisOptionsEditorConfigMap;
    private static BidirectionalMap`2<string, BinaryOperatorSpacingOptions> s_binaryOperatorSpacingOptionsEditorConfigMap;
    private static BidirectionalMap`2<string, LabelPositionOptions> s_labelPositionOptionsEditorConfigMap;
    private static BidirectionalMap`2<string, NewLineBeforeOpenBracePlacement> s_legacyNewLineOptionsEditorConfigMap;
    private static BidirectionalMap`2<string, NewLineBeforeOpenBracePlacement> s_newLineOptionsEditorConfigMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static ImmutableArray`1<IOption2> <AllOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpacingAfterMethodDeclarationName>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceWithinMethodDeclarationParenthesis>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBetweenEmptyMethodDeclarationParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterMethodCallName>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceWithinMethodCallParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBetweenEmptyMethodCallParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterControlFlowStatementKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<SpacePlacementWithinParentheses> <SpaceBetweenParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterCast>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpacesIgnoreAroundVariableDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBeforeOpenSquareBracket>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBetweenEmptySquareBrackets>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceWithinSquareBrackets>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterColonInBaseTypeDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterComma>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterDot>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterSemicolonsInForStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBeforeColonInBaseTypeDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBeforeComma>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBeforeDot>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBeforeSemicolonsInForStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<BinaryOperatorSpacingOptions> <SpacingAroundBinaryOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <IndentBraces>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <IndentBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <IndentSwitchSection>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <IndentSwitchCaseSection>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <IndentSwitchCaseSectionWhenBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<LabelPositionOptions> <LabelPositioning>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <WrappingPreserveSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <WrappingKeepStatementsOnSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<NewLineBeforeOpenBracePlacement> <NewLineBeforeOpenBrace>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLineForElse>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLineForCatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLineForFinally>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLineForMembersInObjectInit>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLineForMembersInAnonymousTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLineForClausesInQuery>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<IOption2> AllOptions { get; }
    public static Option2`1<bool> SpacingAfterMethodDeclarationName { get; }
    public static Option2`1<bool> SpaceWithinMethodDeclarationParenthesis { get; }
    public static Option2`1<bool> SpaceBetweenEmptyMethodDeclarationParentheses { get; }
    public static Option2`1<bool> SpaceAfterMethodCallName { get; }
    public static Option2`1<bool> SpaceWithinMethodCallParentheses { get; }
    public static Option2`1<bool> SpaceBetweenEmptyMethodCallParentheses { get; }
    public static Option2`1<bool> SpaceAfterControlFlowStatementKeyword { get; }
    public static Option2`1<SpacePlacementWithinParentheses> SpaceBetweenParentheses { get; }
    public static Option2`1<bool> SpaceAfterCast { get; }
    public static Option2`1<bool> SpacesIgnoreAroundVariableDeclaration { get; }
    public static Option2`1<bool> SpaceBeforeOpenSquareBracket { get; }
    public static Option2`1<bool> SpaceBetweenEmptySquareBrackets { get; }
    public static Option2`1<bool> SpaceWithinSquareBrackets { get; }
    public static Option2`1<bool> SpaceAfterColonInBaseTypeDeclaration { get; }
    public static Option2`1<bool> SpaceAfterComma { get; }
    public static Option2`1<bool> SpaceAfterDot { get; }
    public static Option2`1<bool> SpaceAfterSemicolonsInForStatement { get; }
    public static Option2`1<bool> SpaceBeforeColonInBaseTypeDeclaration { get; }
    public static Option2`1<bool> SpaceBeforeComma { get; }
    public static Option2`1<bool> SpaceBeforeDot { get; }
    public static Option2`1<bool> SpaceBeforeSemicolonsInForStatement { get; }
    public static Option2`1<BinaryOperatorSpacingOptions> SpacingAroundBinaryOperator { get; }
    public static Option2`1<bool> IndentBraces { get; }
    public static Option2`1<bool> IndentBlock { get; }
    public static Option2`1<bool> IndentSwitchSection { get; }
    public static Option2`1<bool> IndentSwitchCaseSection { get; }
    public static Option2`1<bool> IndentSwitchCaseSectionWhenBlock { get; }
    public static Option2`1<LabelPositionOptions> LabelPositioning { get; }
    public static Option2`1<bool> WrappingPreserveSingleLine { get; }
    public static Option2`1<bool> WrappingKeepStatementsOnSingleLine { get; }
    public static Option2`1<NewLineBeforeOpenBracePlacement> NewLineBeforeOpenBrace { get; }
    public static Option2`1<bool> NewLineForElse { get; }
    public static Option2`1<bool> NewLineForCatch { get; }
    public static Option2`1<bool> NewLineForFinally { get; }
    public static Option2`1<bool> NewLineForMembersInObjectInit { get; }
    public static Option2`1<bool> NewLineForMembersInAnonymousTypes { get; }
    public static Option2`1<bool> NewLineForClausesInQuery { get; }
    private static CSharpFormattingOptions2();
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<IOption2> get_AllOptions();
    private static Option2`1<T> CreateOption(OptionGroup group, string name, T defaultValue, EditorConfigValueSerializer`1<T> serializer);
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpacingAfterMethodDeclarationName();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceWithinMethodDeclarationParenthesis();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBetweenEmptyMethodDeclarationParentheses();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterMethodCallName();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceWithinMethodCallParentheses();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBetweenEmptyMethodCallParentheses();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterControlFlowStatementKeyword();
    [CompilerGeneratedAttribute]
public static Option2`1<SpacePlacementWithinParentheses> get_SpaceBetweenParentheses();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterCast();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpacesIgnoreAroundVariableDeclaration();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBeforeOpenSquareBracket();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBetweenEmptySquareBrackets();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceWithinSquareBrackets();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterColonInBaseTypeDeclaration();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterComma();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterDot();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterSemicolonsInForStatement();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBeforeColonInBaseTypeDeclaration();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBeforeComma();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBeforeDot();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBeforeSemicolonsInForStatement();
    [CompilerGeneratedAttribute]
public static Option2`1<BinaryOperatorSpacingOptions> get_SpacingAroundBinaryOperator();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_IndentBraces();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_IndentBlock();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_IndentSwitchSection();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_IndentSwitchCaseSection();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_IndentSwitchCaseSectionWhenBlock();
    [CompilerGeneratedAttribute]
public static Option2`1<LabelPositionOptions> get_LabelPositioning();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_WrappingPreserveSingleLine();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_WrappingKeepStatementsOnSingleLine();
    [CompilerGeneratedAttribute]
public static Option2`1<NewLineBeforeOpenBracePlacement> get_NewLineBeforeOpenBrace();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLineForElse();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLineForCatch();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLineForFinally();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLineForMembersInObjectInit();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLineForMembersInAnonymousTypes();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLineForClausesInQuery();
    public static int ParseEditorConfigFlags(string list, Func`2<string, int> map, string noneToken, string allToken, int allValue);
    internal static string ToEditorConfigFlagList(int flags, Func`2<int, string> map);
    internal static SpacePlacementWithinParentheses ParseSpacingWithinParenthesesList(string list);
    internal static string ToEditorConfigValue(SpacePlacementWithinParentheses value);
    internal static NewLineBeforeOpenBracePlacement ParseNewLineBeforeOpenBracePlacementList(string list);
    internal static string ToEditorConfigValue(NewLineBeforeOpenBracePlacement value);
    internal static BinaryOperatorSpacingOptions ParseEditorConfigSpacingAroundBinaryOperator(string binaryOperatorSpacingValue);
    private static string GetSpacingAroundBinaryOperatorEditorConfigString(BinaryOperatorSpacingOptions value);
    internal static LabelPositionOptions ParseEditorConfigLabelPositioning(string labelIndentationValue);
    private static string GetLabelPositionOptionEditorConfigString(LabelPositionOptions value);
    internal static bool DetermineIfIgnoreSpacesAroundVariableDeclarationIsSet(string value);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Formatting.IFormattingService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormattingService : AbstractFormattingService {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpStructuredTriviaFormatEngine : AbstractFormatEngine {
    internal IHeaderFacts HeaderFacts { get; }
    private CSharpStructuredTriviaFormatEngine(SyntaxTrivia trivia, int initialColumn, SyntaxFormattingOptions options, ChainedFormattingRules formattingRules, SyntaxToken startToken, SyntaxToken endToken);
    public static IFormattingResult Format(SyntaxTrivia trivia, int initialColumn, SyntaxFormattingOptions options, ChainedFormattingRules formattingRules, CancellationToken cancellationToken);
    internal virtual IHeaderFacts get_HeaderFacts();
    protected virtual AbstractTriviaDataFactory CreateTriviaFactory();
    protected virtual FormattingContext CreateFormattingContext(TokenStream tokenStream, CancellationToken cancellationToken);
    protected virtual NodeOperations CreateNodeOperations(CancellationToken cancellationToken);
    protected virtual AbstractFormattingResult CreateFormattingResult(TokenStream tokenStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpSyntaxFormatting : AbstractSyntaxFormatting {
    public static CSharpSyntaxFormatting Instance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _rules;
    public SyntaxFormattingOptions DefaultOptions { get; }
    private static CSharpSyntaxFormatting();
    public virtual ImmutableArray`1<AbstractFormattingRule> GetDefaultFormattingRules();
    public virtual SyntaxFormattingOptions get_DefaultOptions();
    public virtual SyntaxFormattingOptions GetFormattingOptions(IOptionsReader options, SyntaxFormattingOptions fallbackOptions);
    protected virtual IFormattingResult CreateAggregatedFormattingResult(SyntaxNode node, IList`1<AbstractFormattingResult> results, TextSpanIntervalTree formattingSpans);
    protected virtual AbstractFormattingResult Format(SyntaxNode node, SyntaxFormattingOptions options, IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxToken startToken, SyntaxToken endToken, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpSyntaxFormattingOptions : SyntaxFormattingOptions {
    private static CodeStyleOption2`1<NamespaceDeclarationPreference> s_defaultNamespaceDeclarations;
    private static CodeStyleOption2`1<bool> s_trueWithSilentEnforcement;
    public static SpacePlacement SpacingDefault;
    public static NewLinePlacement NewLinesDefault;
    public static IndentationPlacement IndentationDefault;
    public static CSharpSyntaxFormattingOptions Default;
    [CompilerGeneratedAttribute]
private SpacePlacement <Spacing>k__BackingField;
    [CompilerGeneratedAttribute]
private BinaryOperatorSpacingOptions <SpacingAroundBinaryOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private NewLinePlacement <NewLines>k__BackingField;
    [CompilerGeneratedAttribute]
private LabelPositionOptions <LabelPositioning>k__BackingField;
    [CompilerGeneratedAttribute]
private IndentationPlacement <Indentation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WrappingKeepStatementsOnSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WrappingPreserveSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<NamespaceDeclarationPreference> <NamespaceDeclarations>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferTopLevelStatements>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [DataMemberAttribute]
public SpacePlacement Spacing { get; public set; }
    [DataMemberAttribute]
public BinaryOperatorSpacingOptions SpacingAroundBinaryOperator { get; public set; }
    [DataMemberAttribute]
public NewLinePlacement NewLines { get; public set; }
    [DataMemberAttribute]
public LabelPositionOptions LabelPositioning { get; public set; }
    [DataMemberAttribute]
public IndentationPlacement Indentation { get; public set; }
    [DataMemberAttribute]
public bool WrappingKeepStatementsOnSingleLine { get; public set; }
    [DataMemberAttribute]
public bool WrappingPreserveSingleLine { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<NamespaceDeclarationPreference> NamespaceDeclarations { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferTopLevelStatements { get; public set; }
    public CSharpSyntaxFormattingOptions(IOptionsReader options, CSharpSyntaxFormattingOptions fallbackOptions);
    [CompilerGeneratedAttribute]
private CSharpSyntaxFormattingOptions(CSharpSyntaxFormattingOptions original);
    private static CSharpSyntaxFormattingOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public SpacePlacement get_Spacing();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Spacing(SpacePlacement value);
    [CompilerGeneratedAttribute]
public BinaryOperatorSpacingOptions get_SpacingAroundBinaryOperator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SpacingAroundBinaryOperator(BinaryOperatorSpacingOptions value);
    [CompilerGeneratedAttribute]
public NewLinePlacement get_NewLines();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NewLines(NewLinePlacement value);
    [CompilerGeneratedAttribute]
public LabelPositionOptions get_LabelPositioning();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LabelPositioning(LabelPositionOptions value);
    [CompilerGeneratedAttribute]
public IndentationPlacement get_Indentation();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Indentation(IndentationPlacement value);
    [CompilerGeneratedAttribute]
public bool get_WrappingKeepStatementsOnSingleLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WrappingKeepStatementsOnSingleLine(bool value);
    [CompilerGeneratedAttribute]
public bool get_WrappingPreserveSingleLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WrappingPreserveSingleLine(bool value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<NamespaceDeclarationPreference> get_NamespaceDeclarations();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NamespaceDeclarations(CodeStyleOption2`1<NamespaceDeclarationPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferTopLevelStatements();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferTopLevelStatements(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CSharpSyntaxFormattingOptions left, CSharpSyntaxFormattingOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CSharpSyntaxFormattingOptions left, CSharpSyntaxFormattingOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SyntaxFormattingOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CSharpSyntaxFormattingOptions other);
    [CompilerGeneratedAttribute]
public virtual SyntaxFormattingOptions <Clone>$();
}
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpSyntaxFormattingService : CSharpSyntaxFormatting {
    [NullableAttribute("1")]
private LanguageServices _services;
    [NullableContextAttribute("1")]
private CSharpSyntaxFormattingService(LanguageServices languageServices);
    public sealed virtual bool ShouldFormatOnTypedCharacter(ParsedDocument documentSyntax, char typedChar, int caretPosition, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<TextChange> GetFormattingChangesOnTypedCharacter(ParsedDocument document, int caretPosition, IndentationOptions indentationOptions, CancellationToken cancellationToken);
    private static bool OnlySmartIndentCloseBrace(AutoFormattingOptions& options);
    private static bool OnlySmartIndentOpenBrace(AutoFormattingOptions& options);
    [NullableContextAttribute("1")]
private static IList`1<TextChange> FormatToken(ParsedDocument document, IndentationOptions options, SyntaxToken token, ImmutableArray`1<AbstractFormattingRule> formattingRules, CancellationToken cancellationToken);
    private static ImmutableArray`1<TextChange> FormatRange(ParsedDocument document, IndentationOptions options, SyntaxToken endToken, ImmutableArray`1<AbstractFormattingRule> formattingRules, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private static IEnumerable`1<AbstractFormattingRule> GetTypingRules(SyntaxToken tokenBeforeCaret);
    private static bool IsEndToken(SyntaxToken endToken);
    private static bool ValidSingleOrMultiCharactersTokenKind(char typedChar, SyntaxKind kind);
    private static bool IsInvalidTokenKind(SyntaxToken token);
    private ImmutableArray`1<AbstractFormattingRule> GetFormattingRules(ParsedDocument document, int position, SyntaxToken tokenBeforeCaret);
    public sealed virtual ImmutableArray`1<TextChange> GetFormattingChangesOnPaste(ParsedDocument document, TextSpan textSpan, SyntaxFormattingOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpTriviaFormatter : AbstractTriviaFormatter {
    private bool _succeeded;
    private SyntaxTrivia _newLine;
    public CSharpTriviaFormatter(FormattingContext context, ChainedFormattingRules formattingRules, SyntaxToken token1, SyntaxToken token2, string originalString, int lineBreaks, int spaces);
    protected virtual bool Succeeded();
    protected virtual bool IsWhitespace(SyntaxTrivia trivia);
    protected virtual bool IsEndOfLine(SyntaxTrivia trivia);
    protected virtual bool IsWhitespace(char ch);
    protected virtual bool IsNewLine(char ch);
    protected virtual SyntaxTrivia CreateWhitespace(string text);
    protected virtual SyntaxTrivia CreateEndOfLine();
    protected virtual LineColumnRule GetLineColumnRuleBetween(SyntaxTrivia trivia1, LineColumnDelta existingWhitespaceBetween, bool implicitLineBreak, SyntaxTrivia trivia2, CancellationToken cancellationToken);
    protected virtual bool ContainsImplicitLineBreak(SyntaxTrivia trivia);
    private bool IsStartOrEndOfFile(SyntaxTrivia trivia1, SyntaxTrivia trivia2);
    private static bool IsMultilineComment(SyntaxTrivia trivia1);
    private bool TryFormatMultiLineCommentTrivia(LineColumn lineColumn, SyntaxTrivia trivia, SyntaxTrivia& result);
    protected virtual LineColumnDelta Format(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<SyntaxTrivia> changes, CancellationToken cancellationToken);
    protected virtual LineColumnDelta Format(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<TextChange> changes, CancellationToken cancellationToken);
    private SyntaxTrivia FormatDocumentComment(LineColumn lineColumn, SyntaxTrivia trivia);
    private LineColumnDelta FormatStructuredTrivia(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<SyntaxTrivia> changes, CancellationToken cancellationToken);
    private LineColumnDelta FormatStructuredTrivia(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<TextChange> changes, CancellationToken cancellationToken);
    protected virtual bool LineContinuationFollowedByWhitespaceComment(SyntaxTrivia trivia, SyntaxTrivia nextTrivia);
    protected virtual bool IsVisualBasicComment(SyntaxTrivia trivia);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.DefaultOperationProvider : AbstractFormattingRule {
    public static DefaultOperationProvider Instance;
    private static DefaultOperationProvider();
    public virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, NextAnchorIndentationOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddAlignTokensOperations(List`1<AlignTokensOperation> list, SyntaxNode node, NextAlignTokensOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.ElasticTriviaFormattingRule : BaseFormattingRule {
    internal static string Name;
    public virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static void AddPropertyDeclarationSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
    private static void AddInitializerSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
    private static void AddCollectionExpressionSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
    private static InitializerExpressionSyntax GetInitializerNode(SyntaxNode node);
    private static Nullable`1<SyntaxToken> GetLastTokenOfType(SyntaxNode node);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
private static AdjustNewLinesOperation GetAdjustNewLinesOperationAfterFileScopedNamespace(SyntaxToken previousToken, SyntaxToken currentToken);
    [NullableContextAttribute("2")]
private static AdjustNewLinesOperation GetAdjustNewLinesOperationBetweenMembers(SyntaxToken previousToken, SyntaxToken currentToken);
    [NullableContextAttribute("2")]
private static bool TryGetOperationBeforeDocComment(SyntaxToken currentToken, AdjustNewLinesOperation& operation);
    [NullableContextAttribute("2")]
public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static int LineBreaksAfter(SyntaxToken previousToken, SyntaxToken currentToken);
    private static int LineBreaksAfterCloseBrace(SyntaxToken nextToken);
    private static int LineBreaksAfterSemicolon(SyntaxToken previousToken, SyntaxToken currentToken);
    private static bool IsWhitespace(SyntaxTrivia trivia);
    private static int GetNumberOfLines(IEnumerable`1<SyntaxTrivia> triviaList);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.EndOfFileTokenFormattingRule : BaseFormattingRule {
    [NullableAttribute("1")]
internal static string Name;
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Formatting.Extensions : object {
    [ExtensionAttribute]
public static NewLineBeforeOpenBracePlacement ToNewLineBeforeOpenBracePlacement(NewLinePlacement value);
    [ExtensionAttribute]
public static NewLinePlacement ToNewLinePlacement(NewLineBeforeOpenBracePlacement value);
    [ExtensionAttribute]
public static NewLineBeforeOpenBracePlacement WithFlagValue(NewLineBeforeOpenBracePlacement flags, NewLineBeforeOpenBracePlacement flag, bool value);
    [ExtensionAttribute]
public static SpacePlacementWithinParentheses ToSpacingWithinParentheses(SpacePlacement placement);
    [ExtensionAttribute]
public static SpacePlacement ToSpacePlacement(SpacePlacementWithinParentheses placement);
    [ExtensionAttribute]
public static SpacePlacementWithinParentheses WithFlagValue(SpacePlacementWithinParentheses flags, SpacePlacementWithinParentheses flag, bool value);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Formatting.FormattingHelpers : object {
    [NullableAttribute("1")]
public static string NewLine;
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetIndent(SyntaxToken token);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ContentBeforeLastNewLine(IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetBracePair(SyntaxNode node);
    [ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetBracketPair(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsValidBracketOrBracePair(ValueTuple`2<SyntaxToken, SyntaxToken> bracketOrBracePair);
    [ExtensionAttribute]
public static bool IsOpenParenInParameterListOfAConversionOperatorDeclaration(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsOpenParenInParameterListOfAOperationDeclaration(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsOpenParenInParameterList(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCloseParenInParameterList(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsOpenParenInArgumentListOrPositionalPattern(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCloseParenInArgumentListOrPositionalPattern(SyntaxToken token);
    private static bool IsTokenInArgumentListOrPositionalPattern(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsColonInTypeBaseList(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCommaInArgumentOrParameterList(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsOpenParenInParameterListOfParenthesizedLambdaExpression(SyntaxToken token);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsLambdaBodyBlock(SyntaxNode node);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsAnonymousMethodBlock(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsSemicolonInForStatement(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsSemicolonOfEmbeddedStatement(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCloseBraceOfExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCloseBraceOfEmbeddedBlock(SyntaxToken token);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEmbeddedStatement(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsCommaInEnumDeclaration(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCommaInAnyArgumentsList(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsParenInParenthesizedExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsParenInArgumentList(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsEqualsTokenInAutoPropertyInitializers(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCloseParenInStatement(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsDotInMemberAccessOrQualifiedName(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsDotInMemberAccess(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsGenericGreaterThanToken(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCommaInInitializerExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsColonInCasePatternSwitchLabel(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsColonInSwitchExpressionArm(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCommaInSwitchExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCommaInPropertyPatternClause(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsIdentifierInLabeledStatement(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsColonInSwitchLabel(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsColonInLabeledStatement(SyntaxToken token);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEmbeddedStatementOwnerWithCloseParen(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsNestedQueryExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsFirstFromKeywordInExpression(SyntaxToken token);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInitializerForObjectOrAnonymousObjectCreationExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInitializerForArrayOrCollectionCreationExpression(SyntaxNode node);
    [ExtensionAttribute]
public static bool ParenOrBracketContainsNothing(SyntaxToken token1, SyntaxToken token2);
    [ExtensionAttribute]
public static bool IsLastTokenInLabelStatement(SyntaxToken token);
    [ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetFirstAndLastMemberDeclarationTokensAfterAttributes(MemberDeclarationSyntax node);
    [ExtensionAttribute]
public static bool IsPlusOrMinusExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsInterpolation(SyntaxToken currentToken);
    [ExtensionAttribute]
public static bool IsOpenParenInVarDeconstructionDeclaration(SyntaxToken currentToken);
    [ExtensionAttribute]
public static bool IsCommaInTupleExpression(SyntaxToken currentToken);
    [ExtensionAttribute]
public static bool IsCommaInCollectionExpression(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.FormattingResult : AbstractFormattingResult {
    internal FormattingResult(TreeData treeInfo, TokenStream tokenStream, TextSpan spanToFormat);
    protected virtual SyntaxNode Rewriter(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> changeMap, CancellationToken cancellationToken);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.Formatting.IndentationPlacement : Enum {
    public int value__;
    public static IndentationPlacement Braces;
    public static IndentationPlacement BlockContents;
    public static IndentationPlacement SwitchCaseContents;
    public static IndentationPlacement SwitchCaseContentsWhenBlock;
    public static IndentationPlacement SwitchSection;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.IndentBlockFormattingRule : BaseFormattingRule {
    internal static string Name;
    private CSharpSyntaxFormattingOptions _options;
    private IndentBlockFormattingRule(CSharpSyntaxFormattingOptions options);
    public virtual AbstractFormattingRule WithOptions(SyntaxFormattingOptions options);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static void AddTypeParameterConstraintClauseOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    private void AddSwitchIndentationOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    private void AddLabelIndentationOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    private static void AddAlignmentBlockOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    private static void SetAlignmentBlockOperation(List`1<IndentBlockOperation> list, SyntaxNode baseNode, SyntaxNode body);
    private void AddBlockIndentationOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    private static void AddBracketIndentationOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    [NullableContextAttribute("0")]
private static void AddAlignmentBlockOperationRelativeToFirstTokenOnBaseTokenLine(List`1<IndentBlockOperation> list, ValueTuple`2<SyntaxToken, SyntaxToken> bracePair);
    private static void AddEmbeddedStatementsIndentationOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    private static void AddEmbeddedStatementsIndentationOperation(List`1<IndentBlockOperation> list, StatementSyntax statement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.IndentUserSettingsFormattingRule : BaseFormattingRule {
    private CSharpSyntaxFormattingOptions _options;
    private IndentUserSettingsFormattingRule(CSharpSyntaxFormattingOptions options);
    public virtual AbstractFormattingRule WithOptions(SyntaxFormattingOptions options);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
public enum Microsoft.CodeAnalysis.CSharp.Formatting.LabelPositionOptions : Enum {
    public int value__;
    public static LabelPositionOptions LeftMost;
    public static LabelPositionOptions OneLess;
    public static LabelPositionOptions NoIndent;
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.Formatting.NewLineBeforeOpenBracePlacement : Enum {
    public int value__;
    public static NewLineBeforeOpenBracePlacement None;
    public static NewLineBeforeOpenBracePlacement Types;
    public static NewLineBeforeOpenBracePlacement Methods;
    public static NewLineBeforeOpenBracePlacement Properties;
    public static NewLineBeforeOpenBracePlacement AnonymousMethods;
    public static NewLineBeforeOpenBracePlacement ControlBlocks;
    public static NewLineBeforeOpenBracePlacement AnonymousTypes;
    public static NewLineBeforeOpenBracePlacement ObjectCollectionArrayInitializers;
    public static NewLineBeforeOpenBracePlacement LambdaExpressionBody;
    public static NewLineBeforeOpenBracePlacement Accessors;
    public static NewLineBeforeOpenBracePlacement All;
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.Formatting.NewLinePlacement : Enum {
    public int value__;
    public static NewLinePlacement BeforeMembersInObjectInitializers;
    public static NewLinePlacement BeforeMembersInAnonymousTypes;
    public static NewLinePlacement BeforeElse;
    public static NewLinePlacement BeforeCatch;
    public static NewLinePlacement BeforeFinally;
    public static NewLinePlacement BeforeOpenBraceInTypes;
    public static NewLinePlacement BeforeOpenBraceInAnonymousTypes;
    public static NewLinePlacement BeforeOpenBraceInObjectCollectionArrayInitializers;
    public static NewLinePlacement BeforeOpenBraceInProperties;
    public static NewLinePlacement BeforeOpenBraceInMethods;
    public static NewLinePlacement BeforeOpenBraceInAccessors;
    public static NewLinePlacement BeforeOpenBraceInAnonymousMethods;
    public static NewLinePlacement BeforeOpenBraceInLambdaExpressionBody;
    public static NewLinePlacement BeforeOpenBraceInControlBlocks;
    public static NewLinePlacement BetweenQueryExpressionClauses;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.NewLineUserSettingFormattingRule : BaseFormattingRule {
    private CSharpSyntaxFormattingOptions _options;
    private NewLineUserSettingFormattingRule(CSharpSyntaxFormattingOptions options);
    public virtual AbstractFormattingRule WithOptions(SyntaxFormattingOptions options);
    private static bool IsControlBlock(SyntaxNode node);
    [NullableContextAttribute("2")]
public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.QueryExpressionFormattingRule : BaseFormattingRule {
    internal static string Name;
    private CSharpSyntaxFormattingOptions _options;
    private QueryExpressionFormattingRule(CSharpSyntaxFormattingOptions options);
    public virtual AbstractFormattingRule WithOptions(SyntaxFormattingOptions options);
    public virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static void AddIndentBlockOperationsForFromClause(List`1<IndentBlockOperation> list, FromClauseSyntax fromClause);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, NextAnchorIndentationOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.Formatting.SpacePlacement : Enum {
    public int value__;
    public static SpacePlacement IgnoreAroundVariableDeclaration;
    public static SpacePlacement AfterMethodDeclarationName;
    public static SpacePlacement BetweenEmptyMethodDeclarationParentheses;
    public static SpacePlacement WithinMethodDeclarationParenthesis;
    public static SpacePlacement AfterMethodCallName;
    public static SpacePlacement BetweenEmptyMethodCallParentheses;
    public static SpacePlacement WithinMethodCallParentheses;
    public static SpacePlacement AfterControlFlowStatementKeyword;
    public static SpacePlacement WithinExpressionParentheses;
    public static SpacePlacement WithinCastParentheses;
    public static SpacePlacement BeforeSemicolonsInForStatement;
    public static SpacePlacement AfterSemicolonsInForStatement;
    public static SpacePlacement WithinOtherParentheses;
    public static SpacePlacement AfterCast;
    public static SpacePlacement BeforeOpenSquareBracket;
    public static SpacePlacement BetweenEmptySquareBrackets;
    public static SpacePlacement WithinSquareBrackets;
    public static SpacePlacement AfterColonInBaseTypeDeclaration;
    public static SpacePlacement BeforeColonInBaseTypeDeclaration;
    public static SpacePlacement AfterComma;
    public static SpacePlacement BeforeComma;
    public static SpacePlacement AfterDot;
    public static SpacePlacement BeforeDot;
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.Formatting.SpacePlacementWithinParentheses : Enum {
    public int value__;
    public static SpacePlacementWithinParentheses None;
    public static SpacePlacementWithinParentheses Expressions;
    public static SpacePlacementWithinParentheses TypeCasts;
    public static SpacePlacementWithinParentheses ControlFlowStatements;
    public static SpacePlacementWithinParentheses All;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.SpacingFormattingRule : BaseFormattingRule {
    private CSharpSyntaxFormattingOptions _options;
    private SpacingFormattingRule(CSharpSyntaxFormattingOptions options);
    public virtual AbstractFormattingRule WithOptions(SyntaxFormattingOptions options);
    [NullableContextAttribute("2")]
public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static bool IsEmptyForStatement(ForStatementSyntax forStatement);
    private void SuppressVariableDeclaration(List`1<SuppressOperation> list, SyntaxNode node);
    private static AdjustSpacesOperation AdjustSpacesOperationZeroOrOne(bool option, AdjustSpacesOption explicitOption);
    private static bool HasFormattableBracketParent(SyntaxToken token);
    private static bool IsFunctionLikeKeywordExpressionKind(SyntaxKind syntaxKind);
    private static bool IsControlFlowLikeKeywordStatementKind(SyntaxKind syntaxKind);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.StructuredTriviaFormattingRule : BaseFormattingRule {
    [NullableAttribute("1")]
internal static string Name;
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.SuppressFormattingRule : BaseFormattingRule {
    internal static string Name;
    public virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static void AddSpecificNodesSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
    private static void AddStatementExceptBlockSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
    private static void AddFormatSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
    [NullableContextAttribute("2")]
private static bool IsFormatDirective(DirectiveTriviaSyntax trivia, SyntaxKind disableOrRestoreKeyword);
    private static void AddInitializerSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
    private static void AddInitializerSuppressOperations(List`1<SuppressOperation> list, SyntaxNode parent, IEnumerable`1<SyntaxNode> items);
    private static InitializerExpressionSyntax GetInitializerNode(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static void <AddFormatSuppressOperations>g__ProcessTriviaList|4_0(List`1<SuppressOperation> list, SyntaxTriviaList triviaList);
    [CompilerGeneratedAttribute]
internal static void <AddFormatSuppressOperations>g__ProcessTrivia|4_1(List`1<SuppressOperation> list, SyntaxTrivia trivia);
    [CompilerGeneratedAttribute]
internal static void <AddFormatSuppressOperations>g__ProcessStructuredTrivia|4_2(List`1<SuppressOperation> list, SyntaxNode structure);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.TokenBasedFormattingRule : BaseFormattingRule {
    internal static string Name;
    private CSharpSyntaxFormattingOptions _options;
    private TokenBasedFormattingRule(CSharpSyntaxFormattingOptions options);
    public virtual AbstractFormattingRule WithOptions(SyntaxFormattingOptions options);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private AdjustNewLinesOperation AdjustNewLinesAfterSemicolonToken(SyntaxToken previousToken, SyntaxToken currentToken);
    private static SyntaxList`1<UsingDirectiveSyntax> GetUsings(SyntaxNode node);
    [NullableContextAttribute("2")]
public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.TriviaDataFactory : AbstractTriviaDataFactory {
    public TriviaDataFactory(TreeData treeInfo, SyntaxFormattingOptions options);
    private static bool IsCSharpWhitespace(char c);
    public virtual TriviaData CreateLeadingTrivia(SyntaxToken token);
    public virtual TriviaData CreateTrailingTrivia(SyntaxToken token);
    public virtual TriviaData Create(SyntaxToken token1, SyntaxToken token2);
    private static bool ContainsOnlyWhitespace(AnalysisResult result);
    [NullableContextAttribute("2")]
private TriviaData GetWhitespaceOnlyTriviaInfo(SyntaxToken token1, SyntaxToken token2, AnalysisResult result);
    private int CalculateSpaces(SyntaxToken token1, SyntaxToken token2);
    [NullableContextAttribute("0")]
private ValueTuple`3<bool, int, int> GetLineBreaksAndIndentation(AnalysisResult result);
    private static int GetSpaceOnSingleLine(AnalysisResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.TriviaRewriter : CSharpSyntaxRewriter {
    private SyntaxNode _node;
    private TextSpanIntervalTree _spans;
    private CancellationToken _cancellationToken;
    private Dictionary`2<SyntaxToken, SyntaxTriviaList> _trailingTriviaMap;
    private Dictionary`2<SyntaxToken, SyntaxTriviaList> _leadingTriviaMap;
    public TriviaRewriter(SyntaxNode node, TextSpanIntervalTree spanToFormat, Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> map, CancellationToken cancellationToken);
    public SyntaxNode Transform();
    private void PreprocessTriviaListMap(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> map, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private ValueTuple`2<SyntaxTriviaList, SyntaxTriviaList> GetTrailingAndLeadingTrivia(KeyValuePair`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> pair, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private TextSpan GetTextSpan(ValueTuple`2<SyntaxToken, SyntaxToken> pair);
    private static int GetFirstEndOfLineIndexOrRightBeforeComment(SyntaxTriviaList triviaList);
    [NullableContextAttribute("0")]
private SyntaxTriviaList GetLeadingTriviaAtBeginningOfTree(ValueTuple`2<SyntaxToken, SyntaxToken> pair, TriviaData triviaData, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public virtual SyntaxNode Visit(SyntaxNode node);
    public virtual SyntaxToken VisitToken(SyntaxToken token);
    private static SyntaxToken CreateNewToken(SyntaxTriviaList leadingTrivia, SyntaxToken token, SyntaxTriviaList trailingTrivia);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.TypingFormattingRule : BaseFormattingRule {
    public static TypingFormattingRule Instance;
    private static TypingFormattingRule();
    public virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static bool TryAddSuppressionOnMissingCloseBraceCase(List`1<SuppressOperation> list, SyntaxNode node);
    [NullableContextAttribute("2")]
private static bool SomeParentHasMissingCloseBrace(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.WrappingFormattingRule : BaseFormattingRule {
    private CSharpSyntaxFormattingOptions _options;
    private WrappingFormattingRule(CSharpSyntaxFormattingOptions options);
    public virtual AbstractFormattingRule WithOptions(SyntaxFormattingOptions options);
    public virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("0")]
private static ValueTuple`2<SyntaxToken, SyntaxToken> GetSpecificNodeSuppressionTokenRange(SyntaxNode node);
    private static void AddSpecificNodesSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
    private static void AddStatementExceptBlockSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
    private static void RemoveSuppressOperationForStatementMethodDeclaration(List`1<SuppressOperation> list, SyntaxNode node);
    private static void RemoveSuppressOperationForBlock(List`1<SuppressOperation> list, SyntaxNode node);
    [NullableContextAttribute("0")]
private static ValueTuple`2<SyntaxToken, SyntaxToken> GetBracePair(SyntaxNode node);
    private static void RemoveSuppressOperation(List`1<SuppressOperation> list, SyntaxToken startToken, SyntaxToken endToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GeneratedCodeRecognition.IGeneratedCodeRecognitionService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GeneratedCodeRecognition.CSharpGeneratedCodeRecognitionService : AbstractGeneratedCodeRecognitionService {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Indentation.IIndentationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Indentation.CSharpIndentationService : AbstractIndentationService`1<CompilationUnitSyntax> {
    public static CSharpIndentationService Instance;
    protected ISyntaxFacts SyntaxFacts { get; }
    protected IHeaderFacts HeaderFacts { get; }
    protected ISyntaxFormatting SyntaxFormatting { get; }
    private static CSharpIndentationService();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual IHeaderFacts get_HeaderFacts();
    protected virtual ISyntaxFormatting get_SyntaxFormatting();
    protected virtual AbstractFormattingRule GetSpecializedIndentationFormattingRule(IndentStyle indentStyle);
    public static bool ShouldUseSmartTokenFormatterInsteadOfIndenter(IEnumerable`1<AbstractFormattingRule> formattingRules, CompilationUnitSyntax root, TextLine line, IndentationOptions options, SyntaxToken& token);
    private static bool IsInvalidToken(SyntaxToken token);
    protected virtual bool ShouldUseTokenIndenter(Indenter<CompilationUnitSyntax> indenter, SyntaxToken& syntaxToken);
    protected virtual ISmartTokenFormatter CreateSmartTokenFormatter(CompilationUnitSyntax root, SourceText text, TextLine lineToBeIndented, IndentationOptions options, AbstractFormattingRule baseIndentationRule);
    protected virtual Nullable`1<IndentationResult> GetDesiredIndentationWorker(Indenter<CompilationUnitSyntax> indenter, Nullable`1<SyntaxToken> tokenOpt, Nullable`1<SyntaxTrivia> triviaOpt);
    private static Nullable`1<IndentationResult> TryGetDesiredIndentation(Indenter<CompilationUnitSyntax> indenter, Nullable`1<SyntaxTrivia> triviaOpt);
    private static Nullable`1<IndentationResult> TryGetDesiredIndentation(Indenter<CompilationUnitSyntax> indenter, Nullable`1<SyntaxToken> tokenOpt);
    private static IndentationResult GetIndentationBasedOnToken(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token);
    private static IndentationResult GetIndentationFromCommaSeparatedList(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token);
    [NullableContextAttribute("0")]
private static IndentationResult GetIndentationFromCommaSeparatedList(Indenter<CompilationUnitSyntax> indenter, SeparatedSyntaxList`1<T> list, SyntaxToken token);
    private static IndentationResult GetDefaultIndentationFromToken(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token);
    private static IndentationResult GetIndentationForQueryExpression(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token);
    [NullableContextAttribute("2")]
private static SyntaxNode GetQueryExpressionClause(SyntaxToken token);
    private static bool IsPartOfQueryExpression(SyntaxToken token);
    private static IndentationResult GetDefaultIndentationFromTokenLine(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token, Nullable`1<int> additionalSpace);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Indentation.CSharpSmartTokenFormatter : object {
    private IndentationOptions _options;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _formattingRules;
    private CompilationUnitSyntax _root;
    private SourceText _text;
    public CSharpSmartTokenFormatter(IndentationOptions options, ImmutableArray`1<AbstractFormattingRule> formattingRules, CompilationUnitSyntax root, SourceText text);
    public IList`1<TextChange> FormatRange(SyntaxToken startToken, SyntaxToken endToken, CancellationToken cancellationToken);
    private static bool CloseBraceOfTryOrDoBlock(SyntaxToken endToken);
    public sealed virtual IList`1<TextChange> FormatToken(SyntaxToken token, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.InternalExtensions : object {
    [ExtensionAttribute]
public static ITypeSymbol DetermineParameterType(ArgumentSyntax argument, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static ITypeSymbol DetermineParameterType(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.LanguageService.CSharpAccessibilityFacts : object {
    public static IAccessibilityFacts Instance;
    private static CSharpAccessibilityFacts();
    public sealed virtual bool CanHaveAccessibility(SyntaxNode declaration, bool ignoreDeclarationModifiers);
    public sealed virtual Accessibility GetAccessibility(SyntaxNode declaration);
    public static void GetAccessibilityAndModifiers(SyntaxTokenList modifierList, Accessibility& accessibility, DeclarationModifiers& modifiers, Boolean& isDefault);
    public static DeclarationKind GetDeclarationKind(SyntaxNode declaration);
    public static SyntaxTokenList GetModifierTokens(SyntaxNode declaration);
    [NullableContextAttribute("2")]
public static bool ParentIsFieldDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public static bool ParentIsEventFieldDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public static bool ParentIsLocalDeclarationStatement(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.LanguageService.CSharpBlockFacts : AbstractBlockFacts {
    public static IBlockFacts Instance;
    private static CSharpBlockFacts();
    [NullableContextAttribute("2")]
public virtual bool IsScopeBlock(SyntaxNode node);
    [NullableContextAttribute("2")]
public virtual bool IsExecutableBlock(SyntaxNode node);
    public virtual IReadOnlyList`1<SyntaxNode> GetExecutableBlockStatements(SyntaxNode node);
    public virtual SyntaxNode FindInnermostCommonExecutableBlock(IEnumerable`1<SyntaxNode> nodes);
    [NullableContextAttribute("2")]
public virtual bool IsStatementContainer(SyntaxNode node);
    public virtual IReadOnlyList`1<SyntaxNode> GetStatementContainerStatements(SyntaxNode node);
    [CompilerGeneratedAttribute]
private bool <FindInnermostCommonExecutableBlock>b__4_0(SyntaxNode node);
}
internal class Microsoft.CodeAnalysis.CSharp.LanguageService.CSharpDocumentationCommentService : AbstractDocumentationCommentService`10<DocumentationCommentTriviaSyntax, XmlNodeSyntax, XmlAttributeSyntax, CrefSyntax, XmlElementSyntax, XmlTextSyntax, XmlEmptyElementSyntax, XmlCrefAttributeSyntax, XmlNameAttributeSyntax, XmlTextAttributeSyntax> {
    public static IDocumentationCommentService Instance;
    private static CSharpDocumentationCommentService();
    protected virtual SyntaxList`1<XmlAttributeSyntax> GetAttributes(XmlEmptyElementSyntax xmlEmpty);
    protected virtual CrefSyntax GetCref(XmlCrefAttributeSyntax xmlCref);
    protected virtual SyntaxToken GetIdentifier(XmlNameAttributeSyntax xmlName);
    protected virtual SyntaxNode GetName(XmlElementSyntax xmlElement);
    protected virtual SyntaxTokenList GetTextTokens(XmlTextAttributeSyntax xmlTextAttribute);
    protected virtual SyntaxTokenList GetTextTokens(XmlTextSyntax xmlText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.LanguageService.CSharpFileBannerFacts : AbstractFileBannerFacts {
    public static IFileBannerFacts Instance;
    protected ISyntaxFacts SyntaxFacts { get; }
    protected IDocumentationCommentService DocumentationCommentService { get; }
    private static CSharpFileBannerFacts();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual IDocumentationCommentService get_DocumentationCommentService();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.LanguageService.CSharpHeaderFacts : AbstractHeaderFacts {
    public static IHeaderFacts Instance;
    protected ISyntaxFacts SyntaxFacts { get; }
    private static CSharpHeaderFacts();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    public virtual bool IsOnTypeHeader(SyntaxNode root, int position, bool fullHeader, SyntaxNode& typeDeclaration);
    public virtual bool IsOnPropertyDeclarationHeader(SyntaxNode root, int position, SyntaxNode& propertyDeclaration);
    public virtual bool IsOnParameterHeader(SyntaxNode root, int position, SyntaxNode& parameter);
    public virtual bool IsOnMethodHeader(SyntaxNode root, int position, SyntaxNode& method);
    public virtual bool IsOnLocalFunctionHeader(SyntaxNode root, int position, SyntaxNode& localFunction);
    public virtual bool IsOnLocalDeclarationHeader(SyntaxNode root, int position, SyntaxNode& localDeclaration);
    public virtual bool IsOnIfStatementHeader(SyntaxNode root, int position, SyntaxNode& ifStatement);
    public virtual bool IsOnWhileStatementHeader(SyntaxNode root, int position, SyntaxNode& whileStatement);
    public virtual bool IsOnForeachHeader(SyntaxNode root, int position, SyntaxNode& foreachStatement);
}
internal class Microsoft.CodeAnalysis.CSharp.LanguageService.CSharpSelectedMembers : AbstractSelectedMembers`5<MemberDeclarationSyntax, FieldDeclarationSyntax, PropertyDeclarationSyntax, TypeDeclarationSyntax, VariableDeclaratorSyntax> {
    public static CSharpSelectedMembers Instance;
    private static CSharpSelectedMembers();
    protected virtual ImmutableArray`1<ValueTuple`2<SyntaxNode, SyntaxToken>> GetDeclaratorsAndIdentifiers(MemberDeclarationSyntax member);
    protected virtual SyntaxList`1<MemberDeclarationSyntax> GetMembers(TypeDeclarationSyntax containingType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.LanguageService.CSharpSyntaxFacts : object {
    internal static CSharpSyntaxFacts Instance;
    [CompilerGeneratedAttribute]
private StringComparer <StringComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private ISyntaxKinds <SyntaxKinds>k__BackingField;
    private static string dotToken;
    public bool IsCaseSensitive { get; }
    public StringComparer StringComparer { get; }
    public SyntaxTrivia ElasticMarker { get; }
    public SyntaxTrivia ElasticCarriageReturnLineFeed { get; }
    public ISyntaxKinds SyntaxKinds { get; }
    private static CSharpSyntaxFacts();
    public sealed virtual bool get_IsCaseSensitive();
    [CompilerGeneratedAttribute]
public sealed virtual StringComparer get_StringComparer();
    public sealed virtual SyntaxTrivia get_ElasticMarker();
    public sealed virtual SyntaxTrivia get_ElasticCarriageReturnLineFeed();
    [CompilerGeneratedAttribute]
public sealed virtual ISyntaxKinds get_SyntaxKinds();
    public sealed virtual bool SupportsIndexingInitializer(ParseOptions options);
    public sealed virtual bool SupportsThrowExpression(ParseOptions options);
    public sealed virtual bool SupportsLocalFunctionDeclaration(ParseOptions options);
    public sealed virtual bool SupportsRecord(ParseOptions options);
    public sealed virtual bool SupportsRecordStruct(ParseOptions options);
    public sealed virtual bool SupportsTargetTypedConditionalExpression(ParseOptions options);
    public sealed virtual bool SupportsConstantInterpolatedStrings(ParseOptions options);
    public sealed virtual bool SupportsTupleDeconstruction(ParseOptions options);
    public sealed virtual bool SupportsCollectionExpressionNaturalType(ParseOptions options);
    public sealed virtual SyntaxToken ParseToken(string text);
    public sealed virtual SyntaxTriviaList ParseLeadingTrivia(string text);
    public sealed virtual string EscapeIdentifier(string identifier);
    public sealed virtual bool IsVerbatimIdentifier(SyntaxToken token);
    public sealed virtual bool IsOperator(SyntaxToken token);
    public sealed virtual bool IsReservedKeyword(SyntaxToken token);
    public sealed virtual bool IsContextualKeyword(SyntaxToken token);
    public sealed virtual bool IsPreprocessorKeyword(SyntaxToken token);
    public sealed virtual bool IsPreProcessorDirectiveContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public sealed virtual bool IsEntirelyWithinStringOrCharOrNumericLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public sealed virtual bool IsDirective(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool TryGetExternalSourceInfo(SyntaxNode node, ExternalSourceInfo& info);
    [NullableContextAttribute("2")]
public sealed virtual bool IsNameOfSimpleMemberAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsNameOfAnyMemberAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsNameOfMemberBindingExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode GetStandaloneExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode GetRootConditionalAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsDeclarationExpression(SyntaxNode node);
    public sealed virtual bool IsAttributeName(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsNamedArgument(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsNameOfNamedArgument(SyntaxNode node);
    public sealed virtual SyntaxNode GetParameterList(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsParameterList(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsUsingDirectiveName(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsUsingAliasDirective(SyntaxNode node);
    public sealed virtual void GetPartsOfUsingAliasDirective(SyntaxNode node, SyntaxToken& globalKeyword, SyntaxToken& alias, SyntaxNode& name);
    [NullableContextAttribute("2")]
public sealed virtual bool IsDeconstructionForEachStatement(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsDeconstructionAssignment(SyntaxNode node);
    public sealed virtual Location GetDeconstructionReferenceLocation(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsStatement(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsExecutableStatement(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsGlobalStatement(SyntaxNode node);
    public sealed virtual SyntaxNode GetStatementOfGlobalStatement(SyntaxNode node);
    public sealed virtual bool AreStatementsInSameContainer(SyntaxNode firstStatement, SyntaxNode secondStatement);
    [NullableContextAttribute("2")]
public sealed virtual bool IsMethodBody(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfRefExpression(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfReturnStatement(SyntaxNode node);
    public sealed virtual bool IsThisConstructorInitializer(SyntaxToken token);
    public sealed virtual bool IsBaseConstructorInitializer(SyntaxToken token);
    public sealed virtual bool IsQueryKeyword(SyntaxToken token);
    public sealed virtual bool IsPredefinedType(SyntaxToken token);
    public sealed virtual bool IsPredefinedType(SyntaxToken token, PredefinedType type);
    [NullableContextAttribute("2")]
public sealed virtual bool IsPredefinedType(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsPredefinedType(SyntaxNode node, PredefinedType type);
    public sealed virtual bool TryGetPredefinedType(SyntaxToken token, PredefinedType& type);
    private static PredefinedType GetPredefinedType(SyntaxToken token);
    public sealed virtual bool IsPredefinedOperator(SyntaxToken token);
    public sealed virtual bool IsPredefinedOperator(SyntaxToken token, PredefinedOperator op);
    public sealed virtual bool TryGetPredefinedOperator(SyntaxToken token, PredefinedOperator& op);
    private static PredefinedOperator GetPredefinedOperator(SyntaxToken token);
    public sealed virtual string GetText(int kind);
    public sealed virtual bool IsIdentifierStartCharacter(char c);
    public sealed virtual bool IsIdentifierPartCharacter(char c);
    public sealed virtual bool IsIdentifierEscapeCharacter(char c);
    public sealed virtual bool IsValidIdentifier(string identifier);
    public sealed virtual bool IsVerbatimIdentifier(string identifier);
    public sealed virtual bool IsTypeCharacter(char c);
    public sealed virtual bool IsStartOfUnicodeEscapeSequence(char c);
    public sealed virtual bool IsLiteral(SyntaxToken token);
    public sealed virtual bool IsStringLiteralOrInterpolatedStringLiteral(SyntaxToken token);
    public sealed virtual bool IsBindableToken(SyntaxToken token);
    [NullableContextAttribute("2")]
public sealed virtual bool IsPostfixUnaryExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsMemberBindingExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsPointerMemberAccessExpression(SyntaxNode node);
    public sealed virtual void GetNameAndArityOfSimpleName(SyntaxNode node, String& name, Int32& arity);
    public sealed virtual bool LooksGeneric(SyntaxNode simpleName);
    [NullableContextAttribute("2")]
public sealed virtual SeparatedSyntaxList`1<SyntaxNode> GetTypeArgumentsOfGenericName(SyntaxNode genericName);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode GetTargetOfMemberBinding(SyntaxNode node);
    public sealed virtual SyntaxNode GetNameOfMemberBindingExpression(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfMemberAccessExpression(SyntaxNode node, bool allowImplicitTarget);
    public sealed virtual void GetPartsOfElementAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxNode& argumentList);
    public sealed virtual SyntaxNode GetExpressionOfInterpolation(SyntaxNode node);
    public sealed virtual bool IsInStaticContext(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsInNamespaceOrTypeContext(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsBaseTypeList(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfArgument(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfAttributeArgument(SyntaxNode node);
    public sealed virtual RefKind GetRefKindOfArgument(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsArgument(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsAttributeArgument(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsSimpleArgument(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsInConstantContext(SyntaxNode node);
    public sealed virtual bool IsInConstructor(SyntaxNode node);
    public sealed virtual bool IsUnsafeContext(SyntaxNode node);
    public sealed virtual SyntaxNode GetNameOfAttribute(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsAttributeNamedArgumentIdentifier(SyntaxNode node);
    public sealed virtual SyntaxNode GetContainingTypeDeclaration(SyntaxNode root, int position);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode GetContainingVariableDeclaratorOfFieldDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsNameOfSubpattern(SyntaxNode node);
    public sealed virtual bool IsPropertyPatternClause(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsMemberInitializerNamedAssignmentIdentifier(SyntaxNode node, SyntaxNode& initializedInstance);
    [NullableContextAttribute("2")]
public sealed virtual bool IsAnyInitializerExpression(SyntaxNode node, SyntaxNode& creationExpression);
    [NullableContextAttribute("2")]
public sealed virtual bool IsElementAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode ConvertToSingleLine(SyntaxNode node, bool useElasticTrivia);
    public sealed virtual SyntaxNode GetContainingMemberDeclaration(SyntaxNode root, int position, bool useFullSpan);
    public sealed virtual SyntaxNode GetContainingMethodDeclaration(SyntaxNode root, int position, bool useFullSpan);
    private static SyntaxNode GetContainingMemberDeclaration(SyntaxNode root, int position, bool useFullSpan);
    [NullableContextAttribute("2")]
public sealed virtual bool IsMethodLevelMember(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsTopLevelNodeWithMembers(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual string GetDisplayName(SyntaxNode node, DisplayNameOptions options, string rootNamespace);
    private static string GetName(SyntaxNode node, DisplayNameOptions options);
    private static void AppendTypeParameterList(StringBuilder builder, TypeParameterListSyntax typeParameterList);
    public sealed virtual List`1<SyntaxNode> GetTopLevelAndMethodLevelMembers(SyntaxNode root);
    public sealed virtual List`1<SyntaxNode> GetMethodLevelMembers(SyntaxNode root);
    public sealed virtual SyntaxList`1<SyntaxNode> GetMembersOfTypeDeclaration(SyntaxNode typeDeclaration);
    private void AppendMembers(SyntaxNode node, List`1<SyntaxNode> list, bool topLevel, bool methodLevel);
    public sealed virtual TextSpan GetMemberBodySpanForSpeculativeBinding(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool ContainsInMemberBody(SyntaxNode node, TextSpan span);
    private static TextSpan GetBlockBodySpan(BlockSyntax body);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode TryGetBindableParent(SyntaxToken token);
    public sealed virtual IEnumerable`1<SyntaxNode> GetConstructors(SyntaxNode root, CancellationToken cancellationToken);
    private static void AppendConstructors(SyntaxList`1<MemberDeclarationSyntax> members, List`1<SyntaxNode> constructors, CancellationToken cancellationToken);
    public sealed virtual TextSpan GetInactiveRegionSpanAroundPosition(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public sealed virtual string GetNameForArgument(SyntaxNode argument);
    public sealed virtual string GetNameForAttributeArgument(SyntaxNode argument);
    [NullableContextAttribute("2")]
public sealed virtual bool IsLeftSideOfDot(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode GetRightSideOfDot(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode GetLeftSideOfDot(SyntaxNode node, bool allowImplicitTarget);
    [NullableContextAttribute("2")]
public sealed virtual bool IsLeftSideOfExplicitInterfaceSpecifier(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsLeftSideOfAssignment(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsLeftSideOfAnyAssignment(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsLeftSideOfCompoundAssignment(SyntaxNode node);
    public sealed virtual SyntaxNode GetRightHandSideOfAssignment(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsInferredAnonymousObjectMemberDeclarator(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsOperandOfIncrementExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public static bool IsOperandOfDecrementExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsOperandOfIncrementOrDecrementExpression(SyntaxNode node);
    public sealed virtual SyntaxList`1<SyntaxNode> GetContentsOfInterpolatedString(SyntaxNode interpolatedString);
    public sealed virtual bool IsVerbatimStringLiteral(SyntaxToken token);
    public sealed virtual bool IsNumericLiteral(SyntaxToken token);
    public sealed virtual SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfObjectCreationExpression(SyntaxNode objectCreationExpression);
    public sealed virtual SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfArgumentList(SyntaxNode argumentList);
    public sealed virtual SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfAttributeArgumentList(SyntaxNode argumentList);
    public sealed virtual bool IsRegularComment(SyntaxTrivia trivia);
    public sealed virtual bool IsDocumentationComment(SyntaxTrivia trivia);
    public sealed virtual bool IsElastic(SyntaxTrivia trivia);
    public sealed virtual bool IsPragmaDirective(SyntaxTrivia trivia, Boolean& isDisable, Boolean& isActive, SeparatedSyntaxList`1& errorCodes);
    public sealed virtual bool IsDocumentationCommentExteriorTrivia(SyntaxTrivia trivia);
    public sealed virtual bool IsDocumentationComment(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsUsingOrExternOrImport(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsGlobalAssemblyAttribute(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsGlobalModuleAttribute(SyntaxNode node);
    [NullableContextAttribute("2")]
private static bool IsGlobalAttribute(SyntaxNode node, SyntaxKind attributeTarget);
    [NullableContextAttribute("2")]
public sealed virtual bool IsDeclaration(SyntaxNode node);
    public sealed virtual bool IsTypeDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsSimpleAssignmentStatement(SyntaxNode statement);
    public sealed virtual void GetPartsOfAssignmentStatement(SyntaxNode statement, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public sealed virtual void GetPartsOfAssignmentExpressionOrStatement(SyntaxNode statement, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    [NullableContextAttribute("2")]
public sealed virtual bool IsAnyAssignmentStatement(SyntaxNode node);
    public sealed virtual SyntaxToken GetIdentifierOfSimpleName(SyntaxNode node);
    public sealed virtual SyntaxToken GetIdentifierOfVariableDeclarator(SyntaxNode node);
    public sealed virtual SyntaxToken GetIdentifierOfTypeDeclaration(SyntaxNode node);
    public sealed virtual bool IsDeclaratorOfLocalDeclarationStatement(SyntaxNode declarator, SyntaxNode localDeclarationStatement);
    public sealed virtual bool AreEquivalent(SyntaxToken token1, SyntaxToken token2);
    [NullableContextAttribute("2")]
public sealed virtual bool AreEquivalent(SyntaxNode node1, SyntaxNode node2);
    public static SyntaxNode GetExpressionOfInvocationExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsExpressionOfForeach(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfExpressionStatement(SyntaxNode node);
    public sealed virtual void GetPartsOfTupleExpression(SyntaxNode node, SyntaxToken& openParen, SeparatedSyntaxList`1& arguments, SyntaxToken& closeParen);
    public sealed virtual bool IsPreprocessorDirective(SyntaxTrivia trivia);
    public sealed virtual bool ContainsInterleavedDirective(TextSpan span, SyntaxToken token, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxTokenList GetModifiers(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode WithModifiers(SyntaxNode node, SyntaxTokenList modifiers);
    public sealed virtual SeparatedSyntaxList`1<SyntaxNode> GetVariablesOfLocalDeclarationStatement(SyntaxNode node);
    public sealed virtual SyntaxNode GetInitializerOfVariableDeclarator(SyntaxNode node);
    public sealed virtual SyntaxNode GetInitializerOfPropertyDeclaration(SyntaxNode node);
    public sealed virtual SyntaxNode GetTypeOfVariableDeclarator(SyntaxNode node);
    public sealed virtual SyntaxNode GetValueOfEqualsValueClause(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsEqualsValueOfPropertyDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsConversionExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsCastExpression(SyntaxNode node);
    public sealed virtual void GetPartsOfCastExpression(SyntaxNode node, SyntaxNode& type, SyntaxNode& expression);
    public sealed virtual Nullable`1<SyntaxToken> GetDeclarationIdentifierIfOverride(SyntaxToken token);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxList`1<SyntaxNode> GetAttributeLists(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsParameterNameXmlElementSyntax(SyntaxNode node);
    public sealed virtual SyntaxList`1<SyntaxNode> GetContentFromDocumentationCommentTriviaSyntax(SyntaxTrivia trivia);
    public sealed virtual void GetPartsOfAnyIsTypeExpression(SyntaxNode node, SyntaxNode& expression, SyntaxNode& type);
    public sealed virtual void GetPartsOfIsPatternExpression(SyntaxNode node, SyntaxNode& left, SyntaxToken& isToken, SyntaxNode& right);
    [NullableContextAttribute("2")]
public sealed virtual bool IsAnyPattern(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfConstantPattern(SyntaxNode node);
    public sealed virtual void GetPartsOfDeclarationPattern(SyntaxNode node, SyntaxNode& type, SyntaxNode& designation);
    [NullableContextAttribute("2")]
public sealed virtual void GetPartsOfRecursivePattern(SyntaxNode node, SyntaxNode& type, SyntaxNode& positionalPart, SyntaxNode& propertyPart, SyntaxNode& designation);
    public sealed virtual bool SupportsNotPattern(ParseOptions options);
    public sealed virtual bool SupportsIsNotTypeExpression(ParseOptions options);
    [NullableContextAttribute("2")]
public sealed virtual bool IsBinaryPattern(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsUnaryPattern(SyntaxNode node);
    public sealed virtual void GetPartsOfParenthesizedPattern(SyntaxNode node, SyntaxToken& openParen, SyntaxNode& pattern, SyntaxToken& closeParen);
    public sealed virtual void GetPartsOfBinaryPattern(SyntaxNode node, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public sealed virtual void GetPartsOfUnaryPattern(SyntaxNode node, SyntaxToken& operatorToken, SyntaxNode& pattern);
    public sealed virtual void GetPartsOfRelationalPattern(SyntaxNode node, SyntaxToken& operatorToken, SyntaxNode& expression);
    public sealed virtual SyntaxNode GetTypeOfTypePattern(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsVerbatimInterpolatedStringExpression(SyntaxNode node);
    public sealed virtual bool IsInInactiveRegion(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public sealed virtual bool IsAnonymousFunctionExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsBaseNamespaceDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsBinaryExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsLiteralExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsMemberAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsMethodDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsSimpleName(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsAnyName(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsAnyType(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsNamedMemberInitializer(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsElementAccessInitializer(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsObjectMemberInitializer(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsObjectCollectionInitializer(SyntaxNode node);
    public sealed virtual void GetPartsOfArgumentList(SyntaxNode node, SyntaxToken& openParenToken, SeparatedSyntaxList`1& arguments, SyntaxToken& closeParenToken);
    [NullableContextAttribute("2")]
public sealed virtual void GetPartsOfBaseObjectCreationExpression(SyntaxNode node, SyntaxNode& argumentList, SyntaxNode& initializer);
    public sealed virtual void GetPartsOfBinaryExpression(SyntaxNode node, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public sealed virtual void GetPartsOfCompilationUnit(SyntaxNode node, SyntaxList`1& imports, SyntaxList`1& attributeLists, SyntaxList`1& members);
    public sealed virtual void GetPartsOfConditionalAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxToken& operatorToken, SyntaxNode& whenNotNull);
    public sealed virtual void GetPartsOfConditionalExpression(SyntaxNode node, SyntaxNode& condition, SyntaxNode& whenTrue, SyntaxNode& whenFalse);
    public sealed virtual SyntaxNode GetExpressionOfForeachStatement(SyntaxNode statement);
    public sealed virtual void GetPartsOfGenericName(SyntaxNode node, SyntaxToken& identifier, SeparatedSyntaxList`1& typeArguments);
    public sealed virtual void GetPartsOfInterpolationExpression(SyntaxNode node, SyntaxToken& stringStartToken, SyntaxList`1& contents, SyntaxToken& stringEndToken);
    public sealed virtual void GetPartsOfInvocationExpression(SyntaxNode node, SyntaxNode& expression, SyntaxNode& argumentList);
    public sealed virtual void GetPartsOfMemberAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxToken& operatorToken, SyntaxNode& name);
    public sealed virtual void GetPartsOfBaseNamespaceDeclaration(SyntaxNode node, SyntaxNode& name, SyntaxList`1& imports, SyntaxList`1& members);
    public sealed virtual void GetPartsOfNamedMemberInitializer(SyntaxNode node, SyntaxNode& identifier, SyntaxNode& expression);
    public sealed virtual void GetPartsOfObjectCreationExpression(SyntaxNode node, SyntaxNode& type, SyntaxNode& argumentList, SyntaxNode& initializer);
    public sealed virtual void GetPartsOfParameter(SyntaxNode node, SyntaxToken& identifier, SyntaxNode& default);
    public sealed virtual void GetPartsOfParenthesizedExpression(SyntaxNode node, SyntaxToken& openParen, SyntaxNode& expression, SyntaxToken& closeParen);
    public sealed virtual void GetPartsOfPrefixUnaryExpression(SyntaxNode node, SyntaxToken& operatorToken, SyntaxNode& operand);
    public sealed virtual void GetPartsOfQualifiedName(SyntaxNode node, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public sealed virtual SyntaxNode GetArgumentListOfImplicitElementAccess(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfAwaitExpression(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfThrowExpression(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfThrowStatement(SyntaxNode node);
    public sealed virtual SeparatedSyntaxList`1<SyntaxNode> GetInitializersOfObjectMemberInitializer(SyntaxNode node);
    public sealed virtual SeparatedSyntaxList`1<SyntaxNode> GetExpressionsOfObjectCollectionInitializer(SyntaxNode node);
}
internal class Microsoft.CodeAnalysis.CSharp.LanguageService.CSharpSyntaxKinds : object {
    [NullableAttribute("1")]
public static CSharpSyntaxKinds Instance;
    public int ConflictMarkerTrivia { get; }
    public int DisabledTextTrivia { get; }
    public int EndOfLineTrivia { get; }
    public int SkippedTokensTrivia { get; }
    public int WhitespaceTrivia { get; }
    public int SingleLineCommentTrivia { get; }
    public Nullable`1<int> MultiLineCommentTrivia { get; }
    public int SingleLineDocCommentTrivia { get; }
    public Nullable`1<int> MultiLineDocCommentTrivia { get; }
    public int IfDirectiveTrivia { get; }
    public int ElifDirectiveTrivia { get; }
    public int ElseDirectiveTrivia { get; }
    public int EndIfDirectiveTrivia { get; }
    public int RegionDirectiveTrivia { get; }
    public int EndRegionDirectiveTrivia { get; }
    public Nullable`1<int> ShebangDirectiveTrivia { get; }
    public int CloseBraceToken { get; }
    public Nullable`1<int> CloseBracketToken { get; }
    public int CloseParenToken { get; }
    public int CommaToken { get; }
    public int ColonToken { get; }
    public int CharacterLiteralToken { get; }
    public int DotToken { get; }
    public int GreaterThanToken { get; }
    public int InterpolatedStringTextToken { get; }
    public int LessThanToken { get; }
    public int LessThanSlashToken { get; }
    public int OpenBraceToken { get; }
    public Nullable`1<int> OpenBracketToken { get; }
    public int OpenParenToken { get; }
    public int QuestionToken { get; }
    public int StringLiteralToken { get; }
    public Nullable`1<int> SingleLineRawStringLiteralToken { get; }
    public Nullable`1<int> MultiLineRawStringLiteralToken { get; }
    public Nullable`1<int> Utf8StringLiteralToken { get; }
    public Nullable`1<int> Utf8SingleLineRawStringLiteralToken { get; }
    public Nullable`1<int> Utf8MultiLineRawStringLiteralToken { get; }
    public int XmlTextLiteralToken { get; }
    public int DelegateKeyword { get; }
    public int IfKeyword { get; }
    public int TrueKeyword { get; }
    public int FalseKeyword { get; }
    public int UsingKeyword { get; }
    public int GenericName { get; }
    public int IdentifierName { get; }
    public int QualifiedName { get; }
    public int TupleType { get; }
    public int CharacterLiteralExpression { get; }
    public int DefaultLiteralExpression { get; }
    public int FalseLiteralExpression { get; }
    public int NullLiteralExpression { get; }
    public int NumericLiteralExpression { get; }
    public int StringLiteralExpression { get; }
    public int TrueLiteralExpression { get; }
    public int AddExpression { get; }
    public int AddressOfExpression { get; }
    public int AnonymousObjectCreationExpression { get; }
    public int ArrayCreationExpression { get; }
    public int AwaitExpression { get; }
    public int BaseExpression { get; }
    public int CollectionInitializerExpression { get; }
    public int ConditionalAccessExpression { get; }
    public int ConditionalExpression { get; }
    public Nullable`1<int> ImplicitArrayCreationExpression { get; }
    public Nullable`1<int> ImplicitObjectCreationExpression { get; }
    public Nullable`1<int> IndexExpression { get; }
    public int InvocationExpression { get; }
    public Nullable`1<int> IsPatternExpression { get; }
    public int IsTypeExpression { get; }
    public Nullable`1<int> IsNotTypeExpression { get; }
    public int LogicalAndExpression { get; }
    public int LogicalOrExpression { get; }
    public int LogicalNotExpression { get; }
    public int ObjectCreationExpression { get; }
    public int ParenthesizedExpression { get; }
    public int QueryExpression { get; }
    public Nullable`1<int> RangeExpression { get; }
    public Nullable`1<int> RefExpression { get; }
    public int ReferenceEqualsExpression { get; }
    public int ReferenceNotEqualsExpression { get; }
    public int SimpleMemberAccessExpression { get; }
    public int TernaryConditionalExpression { get; }
    public int ThisExpression { get; }
    public Nullable`1<int> ThrowExpression { get; }
    public int TupleExpression { get; }
    public Nullable`1<int> AndPattern { get; }
    public Nullable`1<int> ConstantPattern { get; }
    public Nullable`1<int> DeclarationPattern { get; }
    public Nullable`1<int> ListPattern { get; }
    public Nullable`1<int> NotPattern { get; }
    public Nullable`1<int> OrPattern { get; }
    public Nullable`1<int> ParenthesizedPattern { get; }
    public Nullable`1<int> RecursivePattern { get; }
    public Nullable`1<int> RelationalPattern { get; }
    public Nullable`1<int> TypePattern { get; }
    public Nullable`1<int> VarPattern { get; }
    public int EndOfFileToken { get; }
    public int AwaitKeyword { get; }
    public int AsyncKeyword { get; }
    public int IdentifierToken { get; }
    public int GlobalKeyword { get; }
    public int IncompleteMember { get; }
    public int HashToken { get; }
    public int ExpressionStatement { get; }
    public int ForEachStatement { get; }
    public int ForStatement { get; }
    public int IfStatement { get; }
    public int LocalDeclarationStatement { get; }
    public Nullable`1<int> LocalFunctionStatement { get; }
    public int LockStatement { get; }
    public int ReturnStatement { get; }
    public int ThrowStatement { get; }
    public int UsingStatement { get; }
    public int WhileStatement { get; }
    public int YieldReturnStatement { get; }
    public int Attribute { get; }
    public int ClassDeclaration { get; }
    public int ConstructorDeclaration { get; }
    public int EnumDeclaration { get; }
    public int InterfaceDeclaration { get; }
    public Nullable`1<int> StructDeclaration { get; }
    public int Parameter { get; }
    public int TypeConstraint { get; }
    public int VariableDeclarator { get; }
    public int FieldDeclaration { get; }
    public int PropertyDeclaration { get; }
    public int ParameterList { get; }
    public int TypeArgumentList { get; }
    public Nullable`1<int> GlobalStatement { get; }
    public int ElseClause { get; }
    public int EqualsValueClause { get; }
    public Nullable`1<int> ImplicitElementAccess { get; }
    public int Interpolation { get; }
    public int InterpolatedStringExpression { get; }
    public int InterpolatedStringText { get; }
    public Nullable`1<int> IndexerMemberCref { get; }
    private static CSharpSyntaxKinds();
    public sealed virtual TSyntaxKind Convert(int kind);
    public sealed virtual int Convert(TSyntaxKind kind);
    public sealed virtual int get_ConflictMarkerTrivia();
    public sealed virtual int get_DisabledTextTrivia();
    public sealed virtual int get_EndOfLineTrivia();
    public sealed virtual int get_SkippedTokensTrivia();
    public sealed virtual int get_WhitespaceTrivia();
    public sealed virtual int get_SingleLineCommentTrivia();
    public sealed virtual Nullable`1<int> get_MultiLineCommentTrivia();
    public sealed virtual int get_SingleLineDocCommentTrivia();
    public sealed virtual Nullable`1<int> get_MultiLineDocCommentTrivia();
    public sealed virtual int get_IfDirectiveTrivia();
    public sealed virtual int get_ElifDirectiveTrivia();
    public sealed virtual int get_ElseDirectiveTrivia();
    public sealed virtual int get_EndIfDirectiveTrivia();
    public sealed virtual int get_RegionDirectiveTrivia();
    public sealed virtual int get_EndRegionDirectiveTrivia();
    public sealed virtual Nullable`1<int> get_ShebangDirectiveTrivia();
    public sealed virtual int get_CloseBraceToken();
    public sealed virtual Nullable`1<int> get_CloseBracketToken();
    public sealed virtual int get_CloseParenToken();
    public sealed virtual int get_CommaToken();
    public sealed virtual int get_ColonToken();
    public sealed virtual int get_CharacterLiteralToken();
    public sealed virtual int get_DotToken();
    public sealed virtual int get_GreaterThanToken();
    public sealed virtual int get_InterpolatedStringTextToken();
    public sealed virtual int get_LessThanToken();
    public sealed virtual int get_LessThanSlashToken();
    public sealed virtual int get_OpenBraceToken();
    public sealed virtual Nullable`1<int> get_OpenBracketToken();
    public sealed virtual int get_OpenParenToken();
    public sealed virtual int get_QuestionToken();
    public sealed virtual int get_StringLiteralToken();
    public sealed virtual Nullable`1<int> get_SingleLineRawStringLiteralToken();
    public sealed virtual Nullable`1<int> get_MultiLineRawStringLiteralToken();
    public sealed virtual Nullable`1<int> get_Utf8StringLiteralToken();
    public sealed virtual Nullable`1<int> get_Utf8SingleLineRawStringLiteralToken();
    public sealed virtual Nullable`1<int> get_Utf8MultiLineRawStringLiteralToken();
    public sealed virtual int get_XmlTextLiteralToken();
    public sealed virtual int get_DelegateKeyword();
    public sealed virtual int get_IfKeyword();
    public sealed virtual int get_TrueKeyword();
    public sealed virtual int get_FalseKeyword();
    public sealed virtual int get_UsingKeyword();
    public sealed virtual int get_GenericName();
    public sealed virtual int get_IdentifierName();
    public sealed virtual int get_QualifiedName();
    public sealed virtual int get_TupleType();
    public sealed virtual int get_CharacterLiteralExpression();
    public sealed virtual int get_DefaultLiteralExpression();
    public sealed virtual int get_FalseLiteralExpression();
    public sealed virtual int get_NullLiteralExpression();
    public sealed virtual int get_NumericLiteralExpression();
    public sealed virtual int get_StringLiteralExpression();
    public sealed virtual int get_TrueLiteralExpression();
    public sealed virtual int get_AddExpression();
    public sealed virtual int get_AddressOfExpression();
    public sealed virtual int get_AnonymousObjectCreationExpression();
    public sealed virtual int get_ArrayCreationExpression();
    public sealed virtual int get_AwaitExpression();
    public sealed virtual int get_BaseExpression();
    public sealed virtual int get_CollectionInitializerExpression();
    public sealed virtual int get_ConditionalAccessExpression();
    public sealed virtual int get_ConditionalExpression();
    public sealed virtual Nullable`1<int> get_ImplicitArrayCreationExpression();
    public sealed virtual Nullable`1<int> get_ImplicitObjectCreationExpression();
    public sealed virtual Nullable`1<int> get_IndexExpression();
    public sealed virtual int get_InvocationExpression();
    public sealed virtual Nullable`1<int> get_IsPatternExpression();
    public sealed virtual int get_IsTypeExpression();
    public sealed virtual Nullable`1<int> get_IsNotTypeExpression();
    public sealed virtual int get_LogicalAndExpression();
    public sealed virtual int get_LogicalOrExpression();
    public sealed virtual int get_LogicalNotExpression();
    public sealed virtual int get_ObjectCreationExpression();
    public sealed virtual int get_ParenthesizedExpression();
    public sealed virtual int get_QueryExpression();
    public sealed virtual Nullable`1<int> get_RangeExpression();
    public sealed virtual Nullable`1<int> get_RefExpression();
    public sealed virtual int get_ReferenceEqualsExpression();
    public sealed virtual int get_ReferenceNotEqualsExpression();
    public sealed virtual int get_SimpleMemberAccessExpression();
    public sealed virtual int get_TernaryConditionalExpression();
    public sealed virtual int get_ThisExpression();
    public sealed virtual Nullable`1<int> get_ThrowExpression();
    public sealed virtual int get_TupleExpression();
    public sealed virtual Nullable`1<int> get_AndPattern();
    public sealed virtual Nullable`1<int> get_ConstantPattern();
    public sealed virtual Nullable`1<int> get_DeclarationPattern();
    public sealed virtual Nullable`1<int> get_ListPattern();
    public sealed virtual Nullable`1<int> get_NotPattern();
    public sealed virtual Nullable`1<int> get_OrPattern();
    public sealed virtual Nullable`1<int> get_ParenthesizedPattern();
    public sealed virtual Nullable`1<int> get_RecursivePattern();
    public sealed virtual Nullable`1<int> get_RelationalPattern();
    public sealed virtual Nullable`1<int> get_TypePattern();
    public sealed virtual Nullable`1<int> get_VarPattern();
    public sealed virtual int get_EndOfFileToken();
    public sealed virtual int get_AwaitKeyword();
    public sealed virtual int get_AsyncKeyword();
    public sealed virtual int get_IdentifierToken();
    public sealed virtual int get_GlobalKeyword();
    public sealed virtual int get_IncompleteMember();
    public sealed virtual int get_HashToken();
    public sealed virtual int get_ExpressionStatement();
    public sealed virtual int get_ForEachStatement();
    public sealed virtual int get_ForStatement();
    public sealed virtual int get_IfStatement();
    public sealed virtual int get_LocalDeclarationStatement();
    public sealed virtual Nullable`1<int> get_LocalFunctionStatement();
    public sealed virtual int get_LockStatement();
    public sealed virtual int get_ReturnStatement();
    public sealed virtual int get_ThrowStatement();
    public sealed virtual int get_UsingStatement();
    public sealed virtual int get_WhileStatement();
    public sealed virtual int get_YieldReturnStatement();
    public sealed virtual int get_Attribute();
    public sealed virtual int get_ClassDeclaration();
    public sealed virtual int get_ConstructorDeclaration();
    public sealed virtual int get_EnumDeclaration();
    public sealed virtual int get_InterfaceDeclaration();
    public sealed virtual Nullable`1<int> get_StructDeclaration();
    public sealed virtual int get_Parameter();
    public sealed virtual int get_TypeConstraint();
    public sealed virtual int get_VariableDeclarator();
    public sealed virtual int get_FieldDeclaration();
    public sealed virtual int get_PropertyDeclaration();
    public sealed virtual int get_ParameterList();
    public sealed virtual int get_TypeArgumentList();
    public sealed virtual Nullable`1<int> get_GlobalStatement();
    public sealed virtual int get_ElseClause();
    public sealed virtual int get_EqualsValueClause();
    public sealed virtual Nullable`1<int> get_ImplicitElementAccess();
    public sealed virtual int get_Interpolation();
    public sealed virtual int get_InterpolatedStringExpression();
    public sealed virtual int get_InterpolatedStringText();
    public sealed virtual Nullable`1<int> get_IndexerMemberCref();
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.LanguageService.ISyntaxKindsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.LanguageService.CSharpSyntaxKindsServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.MoveDeclarationNearReference.IMoveDeclarationNearReferenceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MoveDeclarationNearReference.CSharpMoveDeclarationNearReferenceService : AbstractMoveDeclarationNearReferenceService`4<CSharpMoveDeclarationNearReferenceService, StatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax> {
    protected virtual bool IsMeaningfulBlock(SyntaxNode node);
    protected virtual SyntaxNode GetVariableDeclaratorSymbolNode(VariableDeclaratorSyntax variableDeclarator);
    protected virtual bool IsValidVariableDeclarator(VariableDeclaratorSyntax variableDeclarator);
    protected virtual SyntaxToken GetIdentifierOfVariableDeclarator(VariableDeclaratorSyntax variableDeclarator);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MoveDeclarationNearReference.CSharpMoveDeclarationNearReferenceService/<TypesAreCompatibleAsync>d__5")]
protected virtual Task`1<bool> TypesAreCompatibleAsync(Document document, ILocalSymbol localSymbol, LocalDeclarationStatementSyntax declarationStatement, SyntaxNode right, CancellationToken cancellationToken);
    protected virtual bool CanMoveToBlock(ILocalSymbol localSymbol, SyntaxNode currentBlock, SyntaxNode destinationBlock);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.OrganizeImports.IOrganizeImportsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.OrganizeImports.CSharpOrganizeImportsService : object {
    public string SortImportsDisplayStringWithAccelerator { get; }
    public string SortAndRemoveUnusedImportsDisplayStringWithAccelerator { get; }
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.OrganizeImports.CSharpOrganizeImportsService/<OrganizeImportsAsync>d__1")]
public sealed virtual Task`1<Document> OrganizeImportsAsync(Document document, OrganizeImportsOptions options, CancellationToken cancellationToken);
    public sealed virtual string get_SortImportsDisplayStringWithAccelerator();
    public sealed virtual string get_SortAndRemoveUnusedImportsDisplayStringWithAccelerator();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Precedence.AbstractCSharpPrecedenceService`1 : AbstractPrecedenceService`2<TSyntax, OperatorPrecedence> {
    public sealed virtual PrecedenceKind GetPrecedenceKind(OperatorPrecedence precedence);
}
internal class Microsoft.CodeAnalysis.CSharp.Precedence.CSharpExpressionPrecedenceService : AbstractCSharpPrecedenceService`1<ExpressionSyntax> {
    public static CSharpExpressionPrecedenceService Instance;
    private static CSharpExpressionPrecedenceService();
    public virtual OperatorPrecedence GetOperatorPrecedence(ExpressionSyntax expression);
}
internal class Microsoft.CodeAnalysis.CSharp.Precedence.CSharpPatternPrecedenceService : AbstractCSharpPrecedenceService`1<PatternSyntax> {
    public static CSharpPatternPrecedenceService Instance;
    private static CSharpPatternPrecedenceService();
    public virtual OperatorPrecedence GetOperatorPrecedence(PatternSyntax pattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ReassignedVariable.IReassignedVariableService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ReassignedVariable.CSharpReassignedVariableService : AbstractReassignedVariableService`4<ParameterSyntax, VariableDeclaratorSyntax, SingleVariableDesignationSyntax, IdentifierNameSyntax> {
    protected virtual SyntaxToken GetIdentifierOfVariable(VariableDeclaratorSyntax variable);
    protected virtual SyntaxToken GetIdentifierOfSingleVariableDesignation(SingleVariableDesignationSyntax variable);
    protected virtual bool HasInitializer(SyntaxNode variable);
    protected virtual SyntaxNode GetMemberBlock(SyntaxNode methodOrPropertyDeclaration);
    protected virtual SyntaxNode GetParentScope(SyntaxNode localDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Recommendations.IRecommendationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Recommendations.CSharpRecommendationService : AbstractRecommendationService`2<CSharpSyntaxContext, AnonymousFunctionExpressionSyntax> {
    protected virtual AbstractRecommendationServiceRunner<CSharpSyntaxContext, AnonymousFunctionExpressionSyntax> CreateRunner(CSharpSyntaxContext context, bool filterOutOfScopeLocals, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.RemoveUnnecessaryImports.IRemoveUnnecessaryImportsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryImports.CSharpRemoveUnnecessaryImportsService : AbstractRemoveUnnecessaryImportsService`1<UsingDirectiveSyntax> {
    protected IUnnecessaryImportsProvider`1<UsingDirectiveSyntax> UnnecessaryImportsProvider { get; }
    protected virtual IUnnecessaryImportsProvider`1<UsingDirectiveSyntax> get_UnnecessaryImportsProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryImports.CSharpRemoveUnnecessaryImportsService/<RemoveUnnecessaryImportsAsync>d__3")]
public virtual Task`1<Document> RemoveUnnecessaryImportsAsync(Document document, Func`2<SyntaxNode, bool> predicate, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    private static void AddFormattingSpans(CompilationUnitSyntax compilationUnit, List`1<TextSpan> spans, CancellationToken cancellationToken);
    private static void AddFormattingSpans(BaseNamespaceDeclarationSyntax namespaceMember, List`1<TextSpan> spans, CancellationToken cancellationToken);
    private static int GetEndPosition(SyntaxNode container, SyntaxList`1<MemberDeclarationSyntax> list);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService : AbstractRenameRewriterLanguageService {
    public virtual SyntaxNode AnnotateAndRename(RenameRewriterParameters parameters);
    public virtual bool LocalVariableConflict(SyntaxToken token, IEnumerable`1<ISymbol> newReferencedSymbols);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService/<ComputeDeclarationConflictsAsync>d__4")]
public virtual Task`1<ImmutableArray`1<Location>> ComputeDeclarationConflictsAsync(string replacementText, ISymbol renamedSymbol, ISymbol renameSymbol, IEnumerable`1<ISymbol> referencedSymbols, Solution baseSolution, Solution newSolution, IDictionary`2<Location, Location> reverseMappedLocations, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService/<GetVBPropertyFromAccessorOrAnOverrideAsync>d__5")]
private static Task`1<ISymbol> GetVBPropertyFromAccessorOrAnOverrideAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    private static void AddSymbolSourceSpans(ArrayBuilder`1<Location> conflicts, IEnumerable`1<ISymbol> symbols, IDictionary`2<Location, Location> reverseMappedLocations);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService/<ComputeImplicitReferenceConflictsAsync>d__7")]
public virtual Task`1<ImmutableArray`1<Location>> ComputeImplicitReferenceConflictsAsync(ISymbol renameSymbol, ISymbol renamedSymbol, IEnumerable`1<ReferenceLocation> implicitReferenceLocations, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Location> ComputePossibleImplicitUsageConflicts(ISymbol renamedSymbol, SemanticModel semanticModel, Location originalDeclarationLocation, int newDeclarationLocationStartingPosition, CancellationToken cancellationToken);
    public virtual void TryAddPossibleNameConflicts(ISymbol symbol, string replacementText, ICollection`1<string> possibleNameConflicts);
    [NullableContextAttribute("2")]
public virtual SyntaxNode GetExpansionTargetForLocation(SyntaxToken token);
    [NullableContextAttribute("2")]
private static SyntaxNode GetExpansionTarget(SyntaxToken token);
    public virtual bool IsIdentifierValid(string replacementText, ISyntaxFactsService syntaxFactsService);
    public static SemanticModel GetSemanticModelForNode(SyntaxNode node, SemanticModel originalSemanticModel);
}
internal class Microsoft.CodeAnalysis.CSharp.Rename.LabelConflictVisitor : CSharpSyntaxVisitor {
    private ConflictingIdentifierTracker _tracker;
    public IEnumerable`1<SyntaxToken> ConflictingTokens { get; }
    public LabelConflictVisitor(SyntaxToken tokenBeingRenamed);
    public virtual void DefaultVisit(SyntaxNode node);
    public virtual void VisitBlock(BlockSyntax node);
    public IEnumerable`1<SyntaxToken> get_ConflictingTokens();
}
internal class Microsoft.CodeAnalysis.CSharp.Rename.LocalConflictVisitor : CSharpSyntaxVisitor {
    private ConflictingIdentifierTracker _tracker;
    public IEnumerable`1<SyntaxToken> ConflictingTokens { get; }
    public LocalConflictVisitor(SyntaxToken tokenBeingRenamed);
    public virtual void DefaultVisit(SyntaxNode node);
    public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node);
    public virtual void VisitBlock(BlockSyntax node);
    private void VisitBlockStatements(SyntaxNode node, IEnumerable`1<SyntaxNode> statements);
    public virtual void VisitForEachStatement(ForEachStatementSyntax node);
    public virtual void VisitForStatement(ForStatementSyntax node);
    public virtual void VisitUsingStatement(UsingStatementSyntax node);
    public virtual void VisitCatchClause(CatchClauseSyntax node);
    public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
    public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node);
    public virtual void VisitQueryExpression(QueryExpressionSyntax node);
    private void VisitQueryInternal(FromClauseSyntax fromClause, QueryBodySyntax body);
    public virtual void VisitQueryContinuation(QueryContinuationSyntax node);
    public virtual void VisitSwitchStatement(SwitchStatementSyntax node);
    public IEnumerable`1<SyntaxToken> get_ConflictingTokens();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ReplaceDiscardDeclarationsWithAssignments.IReplaceDiscardDeclarationsWithAssignmentsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ReplaceDiscardDeclarationsWithAssignments.CSharpReplaceDiscardDeclarationsWithAssignmentsService : object {
    private static string DiscardVariableName;
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ReplaceDiscardDeclarationsWithAssignments.CSharpReplaceDiscardDeclarationsWithAssignmentsService/<ReplaceAsync>d__2")]
public sealed virtual Task`1<SyntaxNode> ReplaceAsync(Document document, SyntaxNode memberDeclaration, CancellationToken cancellationToken);
    private static bool IsDiscardDeclaration(VariableDeclaratorSyntax variable);
    private static bool IsDiscardDeclaration(CatchDeclarationSyntax catchDeclaration);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.SemanticModelExtensions : object {
    [ExtensionAttribute]
public static INamespaceSymbol GetDeclaredSymbol(SemanticModel semanticModel, BaseNamespaceDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.SemanticModelReuse.ISemanticModelReuseLanguageService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SemanticModelReuse.CSharpSemanticModelReuseLanguageService : AbstractSemanticModelReuseLanguageService`3<MemberDeclarationSyntax, BasePropertyDeclarationSyntax, AccessorDeclarationSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual BasePropertyDeclarationSyntax GetBasePropertyDeclaration(AccessorDeclarationSyntax accessor);
    protected virtual SyntaxList`1<AccessorDeclarationSyntax> GetAccessors(BasePropertyDeclarationSyntax baseProperty);
    public virtual SyntaxNode TryGetContainingMethodBodyForSpeculation(SyntaxNode node);
    protected virtual SemanticModel TryGetSpeculativeSemanticModelWorker(SemanticModel previousSemanticModel, SyntaxNode previousBodyNode, SyntaxNode currentBodyNode);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Serialization.IOptionsSerializationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Serialization.CSharpOptionsSerializationService : AbstractOptionsSerializationService {
    public virtual void WriteTo(CompilationOptions options, ObjectWriter writer, CancellationToken cancellationToken);
    public virtual void WriteTo(ParseOptions options, ObjectWriter writer);
    public virtual CompilationOptions ReadCompilationOptionsFrom(ObjectReader reader, CancellationToken cancellationToken);
    public virtual ParseOptions ReadParseOptionsFrom(ObjectReader reader, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Shared.Extensions.LanguageVersionExtensions : object {
    internal static LanguageVersion CSharpNext;
    [ExtensionAttribute]
public static bool IsCSharp12OrAbove(LanguageVersion languageVersion);
    [ExtensionAttribute]
public static bool IsCSharp11OrAbove(LanguageVersion languageVersion);
    [ExtensionAttribute]
public static bool HasConstantInterpolatedStrings(LanguageVersion languageVersion);
    [ExtensionAttribute]
public static bool SupportsCollectionExpressions(LanguageVersion languageVersion);
    [ExtensionAttribute]
public static bool SupportsPrimaryConstructors(LanguageVersion languageVersion);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Shared.Lightup.NullableSyntaxAnnotationEx : object {
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <Oblivious>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <AnnotatedOrNotAnnotated>k__BackingField;
    public static SyntaxAnnotation Oblivious { get; }
    public static SyntaxAnnotation AnnotatedOrNotAnnotated { get; }
    private static NullableSyntaxAnnotationEx();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_Oblivious();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_AnnotatedOrNotAnnotated();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Simplification.AbstractCSharpReducer : AbstractReducer {
    protected AbstractCSharpReducer(ObjectPool`1<IReductionRewriter> pool);
    public sealed virtual bool IsApplicable(SimplifierOptions options);
    protected abstract virtual bool IsApplicable(CSharpSimplifierOptions options);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpCastReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<CastExpressionSyntax, SemanticModel, SimplifierOptions, CancellationToken, ExpressionSyntax> s_simplifyCast;
    private static CSharpCastReducer();
    protected virtual bool IsApplicable(CSharpSimplifierOptions options);
    private static ExpressionSyntax SimplifyCast(CastExpressionSyntax node, SemanticModel semanticModel, SimplifierOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpDefaultExpressionReducer : AbstractCSharpReducer {
    [NullableAttribute("1")]
private static ObjectPool`1<IReductionRewriter> s_pool;
    private static CSharpDefaultExpressionReducer();
    [NullableContextAttribute("1")]
protected virtual bool IsApplicable(CSharpSimplifierOptions options);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpEscapingReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<SyntaxToken, SemanticModel, CSharpSimplifierOptions, CancellationToken, SyntaxToken> s_simplifyIdentifierToken;
    private static CSharpEscapingReducer();
    protected virtual bool IsApplicable(CSharpSimplifierOptions options);
    private static SyntaxToken SimplifyIdentifierToken(SyntaxToken token, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    private static SyntaxToken CreateNewIdentifierTokenFromToken(SyntaxToken originalToken, bool escape);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpExtensionMethodReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<InvocationExpressionSyntax, SemanticModel, CSharpSimplifierOptions, CancellationToken, SyntaxNode> s_simplifyExtensionMethod;
    private static CSharpExtensionMethodReducer();
    protected virtual bool IsApplicable(CSharpSimplifierOptions options);
    private static SyntaxNode SimplifyExtensionMethod(InvocationExpressionSyntax node, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    private static InvocationExpressionSyntax TryReduceExtensionMethod(InvocationExpressionSyntax node, SemanticModel semanticModel, InvocationExpressionSyntax rewrittenNode, SimpleNameSyntax expressionName);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpInferredMemberNameReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static CSharpInferredMemberNameReducer();
    protected virtual bool IsApplicable(CSharpSimplifierOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpInferredMemberNameSimplifier : object {
    internal static bool CanSimplifyTupleElementName(ArgumentSyntax node, CSharpParseOptions parseOptions);
    internal static bool CanSimplifyAnonymousTypeMemberName(AnonymousObjectMemberDeclaratorSyntax node);
    private static bool RemovalCausesAmbiguity(SeparatedSyntaxList`1<ArgumentSyntax> arguments, ArgumentSyntax toRemove);
    private static bool RemovalCausesAmbiguity(SeparatedSyntaxList`1<AnonymousObjectMemberDeclaratorSyntax> initializers, AnonymousObjectMemberDeclaratorSyntax toRemove);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpMiscellaneousReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<ParameterSyntax, SemanticModel, SimplifierOptions, CancellationToken, SyntaxNode> s_simplifyParameter;
    private static Func`5<ParenthesizedLambdaExpressionSyntax, SemanticModel, SimplifierOptions, CancellationToken, SyntaxNode> s_simplifyParenthesizedLambdaExpression;
    private static Func`5<BlockSyntax, SemanticModel, CSharpSimplifierOptions, CancellationToken, SyntaxNode> s_simplifyBlock;
    private static CSharpMiscellaneousReducer();
    protected virtual bool IsApplicable(CSharpSimplifierOptions options);
    private static bool CanRemoveTypeFromParameter(ParameterSyntax parameterSyntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static SyntaxNode SimplifyParameter(ParameterSyntax node, SemanticModel semanticModel, SimplifierOptions options, CancellationToken cancellationToken);
    private static SyntaxNode SimplifyParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax parenthesizedLambda, SemanticModel semanticModel, SimplifierOptions options, CancellationToken cancellationToken);
    private static SyntaxNode SimplifyBlock(BlockSyntax node, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    private static bool CanHaveEmbeddedStatement(SyntaxNode node);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpNameReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<SyntaxNode, SemanticModel, CSharpSimplifierOptions, CancellationToken, SyntaxNode> s_simplifyName;
    private static CSharpNameReducer();
    protected virtual bool IsApplicable(CSharpSimplifierOptions options);
    private static SyntaxNode SimplifyName(SyntaxNode node, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpNullableAnnotationReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<NullableTypeSyntax, SemanticModel, SimplifierOptions, CancellationToken, SyntaxNode> s_simplifyNullableType;
    private static CSharpNullableAnnotationReducer();
    protected virtual bool IsApplicable(CSharpSimplifierOptions options);
    private static SyntaxNode SimplifyNullableType(NullableTypeSyntax node, SemanticModel semanticModel, SimplifierOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpParenthesizedExpressionReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<ParenthesizedExpressionSyntax, SemanticModel, SimplifierOptions, CancellationToken, SyntaxNode> s_simplifyParentheses;
    private static CSharpParenthesizedExpressionReducer();
    protected virtual bool IsApplicable(CSharpSimplifierOptions options);
    private static SyntaxNode SimplifyParentheses(ParenthesizedExpressionSyntax node, SemanticModel semanticModel, SimplifierOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpParenthesizedPatternReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<ParenthesizedPatternSyntax, SemanticModel, SimplifierOptions, CancellationToken, SyntaxNode> s_simplifyParentheses;
    private static CSharpParenthesizedPatternReducer();
    protected virtual bool IsApplicable(CSharpSimplifierOptions options);
    private static SyntaxNode SimplifyParentheses(ParenthesizedPatternSyntax node, SemanticModel semanticModel, SimplifierOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpSimplification : AbstractSimplification {
    public static CSharpSimplification Instance;
    public SimplifierOptions DefaultOptions { get; }
    private static CSharpSimplification();
    public virtual SimplifierOptions get_DefaultOptions();
    public virtual SimplifierOptions GetSimplifierOptions(IOptionsReader options, SimplifierOptions fallbackOptions);
}
internal static class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpSimplificationHelpers : object {
    public static SyntaxToken TryEscapeIdentifierToken(SyntaxToken syntaxToken, SyntaxNode parentOfToken);
    public static T AppendElasticTriviaIfNecessary(T rewrittenNode, T originalNode);
    public static bool TryAddLeadingElasticTriviaIfNecessary(SyntaxToken token, SyntaxToken originalToken, SyntaxToken& tokenWithLeadingWhitespace);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Simplification.ISimplificationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpSimplificationService : AbstractSimplificationService`3<ExpressionSyntax, StatementSyntax, CrefSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<AbstractReducer> s_reducers;
    private static string s_CS8019_UnusedUsingDirective;
    public SimplifierOptions DefaultOptions { get; }
    private static CSharpSimplificationService();
    public virtual SimplifierOptions get_DefaultOptions();
    public virtual SimplifierOptions GetSimplifierOptions(IOptionsReader options, SimplifierOptions fallbackOptions);
    public virtual SyntaxNode Expand(SyntaxNode node, SemanticModel semanticModel, SyntaxAnnotation annotationForReplacedAliasIdentifier, Func`2<SyntaxNode, bool> expandInsideNode, bool expandParameter, CancellationToken cancellationToken);
    public virtual SyntaxToken Expand(SyntaxToken token, SemanticModel semanticModel, Func`2<SyntaxNode, bool> expandInsideNode, CancellationToken cancellationToken);
    public static SyntaxToken TryEscapeIdentifierToken(SyntaxToken syntaxToken, SyntaxNode parentOfToken);
    public static T AppendElasticTriviaIfNecessary(T rewrittenNode, T originalNode);
    private static bool TryAddLeadingElasticTriviaIfNecessary(SyntaxToken token, SyntaxToken originalToken, SyntaxToken& tokenWithLeadingWhitespace);
    protected virtual SemanticModel GetSpeculativeSemanticModel(SyntaxNode& nodeToSpeculate, SemanticModel originalSemanticModel, SyntaxNode originalNode);
    protected virtual ImmutableArray`1<NodeOrTokenToReduce> GetNodesAndTokensToReduce(SyntaxNode root, Func`2<SyntaxNodeOrToken, bool> isNodeOrTokenOutsideSimplifySpans);
    protected virtual bool NodeRequiresNonSpeculativeSemanticModel(SyntaxNode node);
    protected virtual void GetUnusedNamespaceImports(SemanticModel model, HashSet`1<SyntaxNode> namespaceImports, CancellationToken cancellationToken);
    private static bool IsTupleInDeconstruction(SyntaxNode tuple);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpSimplifierOptions : SimplifierOptions {
    private static CodeStyleOption2`1<PreferBracesPreference> s_defaultPreferBraces;
    public static CSharpSimplifierOptions Default;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <VarForBuiltInTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <VarWhenTypeIsApparent>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <VarElsewhere>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferSimpleDefaultExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferParameterNullChecking>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <AllowEmbeddedStatementsOnSameLine>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<PreferBracesPreference> <PreferBraces>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferThrowExpression>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> VarForBuiltInTypes { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> VarWhenTypeIsApparent { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> VarElsewhere { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferSimpleDefaultExpression { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferParameterNullChecking { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> AllowEmbeddedStatementsOnSameLine { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<PreferBracesPreference> PreferBraces { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferThrowExpression { get; public set; }
    public CSharpSimplifierOptions(IOptionsReader options, CSharpSimplifierOptions fallbackOptions);
    [CompilerGeneratedAttribute]
private CSharpSimplifierOptions(CSharpSimplifierOptions original);
    private static CSharpSimplifierOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_VarForBuiltInTypes();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_VarForBuiltInTypes(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_VarWhenTypeIsApparent();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_VarWhenTypeIsApparent(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_VarElsewhere();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_VarElsewhere(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferSimpleDefaultExpression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferSimpleDefaultExpression(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferParameterNullChecking();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferParameterNullChecking(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_AllowEmbeddedStatementsOnSameLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AllowEmbeddedStatementsOnSameLine(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<PreferBracesPreference> get_PreferBraces();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferBraces(CodeStyleOption2`1<PreferBracesPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferThrowExpression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferThrowExpression(CodeStyleOption2`1<bool> value);
    public UseVarPreference GetUseVarPreference();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CSharpSimplifierOptions left, CSharpSimplifierOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CSharpSimplifierOptions left, CSharpSimplifierOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SimplifierOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CSharpSimplifierOptions other);
    [CompilerGeneratedAttribute]
public virtual SimplifierOptions <Clone>$();
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpVarReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static CSharpVarReducer();
    protected virtual bool IsApplicable(CSharpSimplifierOptions options);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Simplification.Simplifiers.AbstractCSharpSimplifier`2 : AbstractSimplifier`3<TSyntax, TSimplifiedSyntax, CSharpSimplifierOptions> {
    private static ConditionalWeakTable`2<SemanticModel, StrongBox`1<bool>> s_modelToHasUsingAliasesMap;
    private static AbstractCSharpSimplifier`2();
    protected static Nullable`1<SyntaxToken> TryGetPredefinedKeywordToken(SemanticModel semanticModel, SpecialType specialType);
    protected static bool TryReplaceExpressionWithAlias(ExpressionSyntax node, SemanticModel semanticModel, ISymbol symbol, CancellationToken cancellationToken, IAliasSymbol& aliasReplacement);
    private static bool HasUsingAliases(SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ComputeHasUsingAliases(SemanticModel model, CancellationToken cancellationToken);
    private static bool ValidateAliasForTarget(IAliasSymbol aliasReplacement, SemanticModel semanticModel, ExpressionSyntax node, ISymbol symbol);
    private static IAliasSymbol GetAliasForSymbol(INamespaceOrTypeSymbol symbol, SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static Nullable`1<int> GetNamespaceIdForAliasSearch(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    private static SyntaxNode GetStartNodeForNamespaceId(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    protected static TypeSyntax CreatePredefinedTypeSyntax(SyntaxNode nodeToReplace, SyntaxToken token);
    protected static bool InsideNameOfExpression(ExpressionSyntax expression, SemanticModel semanticModel);
    protected static bool PreferPredefinedTypeKeywordInMemberAccess(ExpressionSyntax expression, CSharpSimplifierOptions options, SemanticModel semanticModel);
    protected static bool WillConflictWithExistingLocal(ExpressionSyntax expression, ExpressionSyntax simplifiedNode, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
internal static bool <TryReplaceExpressionWithAlias>g__IsAliasReplaceableExpression|2_0(ExpressionSyntax expression);
    [CompilerGeneratedAttribute]
internal static bool <ComputeHasUsingAliases>g__HasUsingAliasDirective|4_1(SyntaxNode syntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Simplification.Simplifiers.CastSimplifier : object {
    public static bool IsUnnecessaryCast(ExpressionSyntax cast, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsUnnecessaryAsCast(BinaryExpressionSyntax cast, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsUnnecessaryCast(CastExpressionSyntax cast, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsEnumCastWithZeroCompare(CastExpressionSyntax castExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsRemovableBitwiseEnumNegation(CastExpressionSyntax castExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsCastSafeToRemove(ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, SemanticModel originalSemanticModel, CancellationToken cancellationToken);
    private static bool CastRemovalCouldCauseSignExtensionWarning(ExpressionSyntax castSyntax, IConversionOperation conversionOperation);
    private static bool IsDelegateCreationCastSafeToRemove(ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, SemanticModel originalSemanticModel, IDelegateCreationOperation originalDelegateCreationOperation, CancellationToken cancellationToken);
    private static bool IsConversionCastSafeToRemove(ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, SemanticModel originalSemanticModel, IConversionOperation originalConversionOperation, CancellationToken cancellationToken);
    private static bool IsCollectionExpressionCastThatMustBePreserved(ExpressionSyntax castNode, SemanticModel originalSemanticModel, ITypeSymbol originalConvertedType, CancellationToken cancellationToken);
    private static bool IsIdentityStructCastThatMustBePreserved(ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsMultipleImplicitNullableConversion(IConversionOperation originalConversionOperation);
    private static bool IsRemovableWideningSignedBitwiseNegation(ExpressionSyntax castNode, IConversionOperation originalConversionOperation, ExpressionSyntax rewrittenExpression, SemanticModel rewrittenSemanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool IsSignedIntegralOrIntPtrType(ITypeSymbol type);
    private static bool IsConditionalCastSafeToRemove(ExpressionSyntax castNode, SemanticModel originalSemanticModel, ExpressionSyntax rewrittenExpression, SemanticModel rewrittenSemanticModel, CancellationToken cancellationToken);
    private static bool IsNullOrErrorType(TypeInfo info);
    [NullableContextAttribute("2")]
private static bool IsNullOrErrorType(ITypeSymbol type);
    private static bool CastRemovalWouldCauseUnintendedReferenceComparisonWarning(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ConvertedHasUserDefinedEquals(BinaryOperatorKind operatorKind, IOperation operation);
    private static bool IsConstantNull(IOperation operation);
    private static bool IsExplicitCast(SyntaxNode node);
    private static bool IsExplicitCastThatMustBePreserved(SemanticModel semanticModel, ExpressionSyntax castOrAsNode, Conversion conversion, CancellationToken cancellationToken);
    private static bool IsIdentityFloatingPointCastThatMustBePreserved(ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool IsFloatingPointType(ITypeSymbol type);
    private static bool IsFieldOrArrayElement(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    private static bool IntroducedConditionalExpressionConversion(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IntroducedAmbiguity(ExpressionSyntax castNode, ExpressionSyntax rewrittenExpression, SemanticModel originalSemanticModel, SemanticModel rewrittenSemanticModel, CancellationToken cancellationToken);
    private static bool ChangedOverloadResolution(ExpressionSyntax castNode, ExpressionSyntax rewrittenExpression, SemanticModel originalSemanticModel, SemanticModel rewrittenSemanticModel, CancellationToken cancellationToken);
    private static bool ChangedForEachResolution(ExpressionSyntax castNode, ExpressionSyntax rewrittenExpression, SemanticModel originalSemanticModel, SemanticModel rewrittenSemanticModel);
    private static bool IsComplementaryMemberAccessAfterCastRemoval(MemberAccessExpressionSyntax memberAccessExpression, ExpressionSyntax rewrittenExpression, SemanticModel originalSemanticModel, SemanticModel rewrittenSemanticModel, CancellationToken cancellationToken);
    private static bool IsComplementaryInvocationAfterCastRemoval(InvocationExpressionSyntax memberAccessExpression, ExpressionSyntax rewrittenExpression, SemanticModel originalSemanticModel, SemanticModel rewrittenSemanticModel, CancellationToken cancellationToken);
    private static bool IsComplementaryDelegateInvoke(ISymbol originalMemberSymbol, ISymbol rewrittenMemberSymbol);
    private static bool IsIntrinsicOrEnum(ITypeSymbol rewrittenType);
    private static bool IsCopy(SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol rewrittenType, CancellationToken cancellationToken);
    private static bool ParameterNamesAndDefaultValuesAndReturnTypesMatch(MemberAccessExpressionSyntax memberAccessExpression, SemanticModel semanticModel, ISymbol originalMemberSymbol, ISymbol rewrittenMemberSymbol, CancellationToken cancellationToken);
    private static ValueTuple`2<ITypeSymbol, Conversion> GetRewrittenInfo(ExpressionSyntax castNode, ExpressionSyntax rewrittenExpression, SemanticModel originalSemanticModel, SemanticModel rewrittenSemanticModel, Conversion originalConversion, ITypeSymbol originalConvertedType, CancellationToken cancellationToken);
    private static ValueTuple`2<SemanticModel, ExpressionSyntax> GetSemanticModelWithCastRemoved(ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, SemanticModel originalSemanticModel, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <IsEnumCastWithZeroCompare>g__IsConstantZero|3_0(ExpressionSyntax child, <>c__DisplayClass3_0& );
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.Simplifiers.ExpressionSimplifier : AbstractCSharpSimplifier`2<ExpressionSyntax, ExpressionSyntax> {
    public static ExpressionSimplifier Instance;
    private static ExpressionSimplifier();
    public virtual bool TrySimplify(ExpressionSyntax expression, SemanticModel semanticModel, CSharpSimplifierOptions options, ExpressionSyntax& replacementNode, TextSpan& issueSpan, CancellationToken cancellationToken);
    private static bool TryReduceExplicitName(ExpressionSyntax expression, SemanticModel semanticModel, TypeSyntax& replacementNode, TextSpan& issueSpan, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    private static bool TryReduceMemberAccessExpression(MemberAccessExpressionSyntax memberAccess, SemanticModel semanticModel, TypeSyntax& replacementNode, TextSpan& issueSpan, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    private static void GetReplacementCandidates(SemanticModel semanticModel, MemberAccessExpressionSyntax memberAccess, ISymbol actualSymbol, ImmutableArray`1& speculativeSymbols, ImmutableArray`1& speculativeNamespacesAndTypes);
    private static bool IsReplacementCandidate(ISymbol actualSymbol, ImmutableArray`1<ISymbol> speculativeSymbols, ImmutableArray`1<ISymbol> speculativeNamespacesAndTypes);
    private static bool TrySimplify(ExpressionSyntax expression, SemanticModel semanticModel, ExpressionSyntax& replacementNode, TextSpan& issueSpan, CancellationToken cancellationToken);
    private static bool CanReplaceWithMemberAccessName(MemberAccessExpressionSyntax memberAccess, SemanticModel semanticModel, ISymbol symbol, CancellationToken cancellationToken);
    private static bool IsNonRemovablePartOfDynamicMethodInvocation(SemanticModel semanticModel, MemberAccessExpressionSyntax memberAccess, CancellationToken cancellationToken);
    private static bool AccessMethodWithDynamicArgumentInsideStructConstructor(MemberAccessExpressionSyntax memberAccess, SemanticModel semanticModel);
    private static bool TrySimplifyMemberAccessOrQualifiedName(ExpressionSyntax left, ExpressionSyntax right, SemanticModel semanticModel, ExpressionSyntax& replacementNode, TextSpan& issueSpan);
    protected static bool ReplacementChangesSemantics(ExpressionSyntax originalExpression, ExpressionSyntax replacedExpression, SemanticModel semanticModel);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Simplification.Simplifiers.MemberAccessExpressionSimplifier : AbstractMemberAccessExpressionSimplifier`3<ExpressionSyntax, MemberAccessExpressionSyntax, ThisExpressionSyntax> {
    public static MemberAccessExpressionSimplifier Instance;
    protected ISyntaxFacts SyntaxFacts { get; }
    private static MemberAccessExpressionSimplifier();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual ISpeculationAnalyzer GetSpeculationAnalyzer(SemanticModel semanticModel, MemberAccessExpressionSyntax memberAccessExpression, CancellationToken cancellationToken);
    protected virtual bool MayCauseParseDifference(MemberAccessExpressionSyntax memberAccessExpression);
    public static bool ParserWouldTreatReplacementWithNameAsCast(MemberAccessExpressionSyntax memberAccessExpression);
    private static bool IsEntirelySimpleNames(SyntaxNode node);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.Simplifiers.NameSimplifier : AbstractCSharpSimplifier`2<NameSyntax, TypeSyntax> {
    public static NameSimplifier Instance;
    private static NameSimplifier();
    public virtual bool TrySimplify(NameSyntax name, SemanticModel semanticModel, CSharpSimplifierOptions options, TypeSyntax& replacementNode, TextSpan& issueSpan, CancellationToken cancellationToken);
    private static bool TryReduceCrefColorColor(NameSyntax name, TypeSyntax replacement, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool CanSimplifyNullable(INamedTypeSymbol type, NameSyntax name, SemanticModel semanticModel);
    private static bool CanReplaceWithPredefinedTypeKeywordInContext(NameSyntax name, SemanticModel semanticModel, TypeSyntax& replacementNode, TextSpan& issueSpan, Nullable`1<SyntaxToken> keywordToken, string codeStyleOptionName);
    private static bool TryReduceAttributeSuffix(NameSyntax name, SyntaxToken identifierToken, TypeSyntax& replacementNode, TextSpan& issueSpan);
    private static bool IsPartOfNamespaceDeclarationName(SyntaxNode node);
    public static bool CanReplaceWithReducedNameInContext(NameSyntax name, TypeSyntax reducedName, SemanticModel semanticModel);
    private static bool ContainsOpenName(NameSyntax name);
    private static bool CanReplaceWithReducedName(NameSyntax name, TypeSyntax reducedName, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsNotNullableReplaceable(NameSyntax name, TypeSyntax reducedName);
    private static bool IsNullableTypeInPointerExpression(ExpressionSyntax simplifiedNode);
    private static bool IsNonNameSyntaxInUsingDirective(ExpressionSyntax expression, ExpressionSyntax simplifiedNode);
    private static bool IsAmbiguousCast(ExpressionSyntax expression, ExpressionSyntax simplifiedNode);
    private static bool IsNonReducableQualifiedNameInUsingDirective(SemanticModel model, NameSyntax name);
    private static bool IsQualifiedNameInUsingDirective(SemanticModel model, NameSyntax name);
    private static bool IsGlobalAliasQualifiedName(NameSyntax name);
    private static bool IsInScriptClass(SemanticModel model, NameSyntax name);
    private static bool PreferPredefinedTypeKeywordInDeclarations(NameSyntax name, CSharpSimplifierOptions options, SemanticModel semanticModel);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.Simplifiers.QualifiedCrefSimplifier : AbstractCSharpSimplifier`2<QualifiedCrefSyntax, CrefSyntax> {
    public static QualifiedCrefSimplifier Instance;
    private static QualifiedCrefSimplifier();
    public virtual bool TrySimplify(QualifiedCrefSyntax crefSyntax, SemanticModel semanticModel, CSharpSimplifierOptions options, CrefSyntax& replacementNode, TextSpan& issueSpan, CancellationToken cancellationToken);
    public static bool CanSimplifyWithReplacement(QualifiedCrefSyntax crefSyntax, SemanticModel semanticModel, CrefSyntax replacement, CancellationToken cancellationToken);
    private static bool CanSimplifyWithReplacement(QualifiedCrefSyntax crefSyntax, SemanticModel semanticModel, CrefSyntax replacement, CrefSyntax& replacementNode, TextSpan& issueSpan, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Utilities.CSharpTypeStyleHelper : object {
    protected abstract virtual bool IsStylePreferred(State& modreq(System.Runtime.InteropServices.InAttribute) state);
    public virtual TypeStyleResult AnalyzeTypeName(TypeSyntax typeName, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    internal abstract virtual bool TryAnalyzeVariableDeclaration(TypeSyntax typeName, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    protected abstract virtual bool AssignmentSupportsStylePreference(SyntaxToken identifier, TypeSyntax typeName, ExpressionSyntax initializer, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    internal TypeSyntax FindAnalyzableType(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    public virtual bool ShouldAnalyzeVariableDeclaration(VariableDeclarationSyntax variableDeclaration, CancellationToken cancellationToken);
    protected virtual bool ShouldAnalyzeForEachStatement(ForEachStatementSyntax forEachStatement, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual bool ShouldAnalyzeDeclarationExpression(DeclarationExpressionSyntax declaration, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.CSharpUseExplicitTypeHelper : CSharpTypeStyleHelper {
    public static CSharpUseExplicitTypeHelper Instance;
    private static CSharpUseExplicitTypeHelper();
    protected virtual bool IsStylePreferred(State& modreq(System.Runtime.InteropServices.InAttribute) state);
    public virtual bool ShouldAnalyzeVariableDeclaration(VariableDeclarationSyntax variableDeclaration, CancellationToken cancellationToken);
    protected virtual bool ShouldAnalyzeForEachStatement(ForEachStatementSyntax forEachStatement, SemanticModel semanticModel, CancellationToken cancellationToken);
    internal virtual bool TryAnalyzeVariableDeclaration(TypeSyntax typeName, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    protected virtual bool ShouldAnalyzeDeclarationExpression(DeclarationExpressionSyntax declaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual bool AssignmentSupportsStylePreference(SyntaxToken identifier, TypeSyntax typeName, ExpressionSyntax initializer, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.CSharpUseImplicitTypeHelper : CSharpTypeStyleHelper {
    public static CSharpUseImplicitTypeHelper Instance;
    private static CSharpUseImplicitTypeHelper();
    public virtual TypeStyleResult AnalyzeTypeName(TypeSyntax typeName, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    public virtual bool ShouldAnalyzeVariableDeclaration(VariableDeclarationSyntax variableDeclaration, CancellationToken cancellationToken);
    protected virtual bool ShouldAnalyzeForEachStatement(ForEachStatementSyntax forEachStatement, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual bool IsStylePreferred(State& modreq(System.Runtime.InteropServices.InAttribute) state);
    internal virtual bool TryAnalyzeVariableDeclaration(TypeSyntax typeName, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    private static bool TryAnalyzeDeclarationExpression(DeclarationExpressionSyntax declarationExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsSafeToSwitchToVarWithoutNeedingSpeculation(DeclarationExpressionSyntax declarationExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual bool AssignmentSupportsStylePreference(SyntaxToken identifier, TypeSyntax typeName, ExpressionSyntax initializer, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    internal static ExpressionSyntax GetInitializerExpression(ExpressionSyntax initializer);
    protected virtual bool ShouldAnalyzeDeclarationExpression(DeclarationExpressionSyntax declaration, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.Utilities.FormattingRangeHelper : object {
    public static Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> FindAppropriateRange(SyntaxToken endToken, bool useDefaultRange);
    private static Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> FixupOpenBrace(Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> tokenRange);
    private static Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> FindAppropriateRangeWorker(SyntaxToken endToken, bool useDefaultRange);
    private static Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> FindAppropriateRangeForSemicolon(SyntaxToken endToken);
    private static Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> FindAppropriateRangeForCloseBrace(SyntaxToken endToken);
    private static Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> FindAppropriateRangeForColon(SyntaxToken endToken);
    private static SyntaxToken GetPreviousTokenIfNotFirstTokenInTree(SyntaxToken token);
    public static bool AreTwoTokensOnSameLine(SyntaxToken token1, SyntaxToken token2);
    private static SyntaxToken GetAppropriatePreviousToken(SyntaxToken startToken, bool canTokenBeFirstInABlock);
    private static bool IsOpenBraceTokenOfABlockOrTypeOrNamespace(SyntaxToken previousToken);
    [NullableContextAttribute("1")]
private static bool IsSpecialContainingNode(SyntaxNode node);
    [NullableContextAttribute("2")]
private static SyntaxNode GetTopContainingNode(SyntaxNode node);
    public static bool IsColonInSwitchLabel(SyntaxToken token);
    public static bool InBetweenTwoMembers(SyntaxToken previousToken, SyntaxToken currentToken);
    [NullableContextAttribute("2")]
public static MemberDeclarationSyntax GetEnclosingMember(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.NameSyntaxComparer : object {
    private IComparer`1<SyntaxToken> _tokenComparer;
    internal TypeSyntaxComparer TypeComparer;
    internal NameSyntaxComparer(IComparer`1<SyntaxToken> tokenComparer);
    public static IComparer`1<NameSyntax> Create();
    public static IComparer`1<NameSyntax> Create(IComparer`1<SyntaxToken> tokenComparer);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(NameSyntax x, NameSyntax y);
    private static IList`1<SimpleNameSyntax> DecomposeNameParts(NameSyntax name);
    private static void DecomposeNameParts(NameSyntax name, List`1<SimpleNameSyntax> result);
    private int Compare(GenericNameSyntax x, GenericNameSyntax y);
    [CompilerGeneratedAttribute]
private int <Compare>g__DecomposeCompare|5_0(NameSyntax x, NameSyntax y);
}
internal class Microsoft.CodeAnalysis.CSharp.Utilities.NameSyntaxIterator : object {
    private NameSyntax _name;
    public NameSyntaxIterator(NameSyntax name);
    public sealed virtual IEnumerator`1<NameSyntax> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.CodeAnalysis.CSharp.Utilities.SpeculationAnalyzer : AbstractSpeculationAnalyzer`8<ExpressionSyntax, TypeSyntax, AttributeSyntax, ArgumentSyntax, CommonForEachStatementSyntax, ThrowStatementSyntax, InvocationExpressionSyntax, Conversion> {
    [CompilerGeneratedAttribute]
private ISyntaxFacts <SyntaxFactsService>k__BackingField;
    protected ISyntaxFacts SyntaxFactsService { get; }
    public SpeculationAnalyzer(ExpressionSyntax expression, ExpressionSyntax newExpression, SemanticModel semanticModel, CancellationToken cancellationToken, bool skipVerificationForReplacedNode, bool failOnOverloadResolutionFailuresInOriginalCode);
    [CompilerGeneratedAttribute]
protected virtual ISyntaxFacts get_SyntaxFactsService();
    protected virtual bool CanAccessInstanceMemberThrough(ExpressionSyntax expression);
    protected virtual SyntaxNode GetSemanticRootForSpeculation(ExpressionSyntax expression);
    public static bool CanSpeculateOnNode(SyntaxNode node);
    protected virtual void ValidateSpeculativeSemanticModel(SemanticModel speculativeSemanticModel, SyntaxNode nodeToSpeculate);
    protected virtual SemanticModel CreateSpeculativeSemanticModel(SyntaxNode originalNode, SyntaxNode nodeToSpeculate, SemanticModel semanticModel);
    public static SemanticModel CreateSpeculativeSemanticModelForNode(SyntaxNode originalNode, SyntaxNode nodeToSpeculate, SemanticModel semanticModel);
    public static SemanticModel CreateSpeculativeSemanticModelForNode(SyntaxNode nodeToSpeculate, SemanticModel semanticModel, int position, bool isInNamespaceOrTypeContext);
    public bool ReplacementChangesSemanticsOfUnchangedLambda(ExpressionSyntax originalLambda, ExpressionSyntax replacedLambda);
    private bool HaveSameParameterType(ParameterSyntax originalParam, ParameterSyntax replacedParam);
    private bool ReplacementChangesSemanticsForNodes(IEnumerable`1<IdentifierNameSyntax> originalIdentifierNodes, IEnumerable`1<IdentifierNameSyntax> replacedIdentifierNodes, SyntaxNode originalRoot);
    protected virtual bool ReplacementChangesSemanticsForNodeLanguageSpecific(SyntaxNode currentOriginalNode, SyntaxNode currentReplacedNode, SyntaxNode previousOriginalNode, SyntaxNode previousReplacedNode);
    private bool ReplacementBreaksBoxingInConditionalExpression(TypeInfo originalExpressionTypeInfo, TypeInfo newExpressionTypeInfo, ExpressionSyntax previousOriginalNode, ExpressionSyntax previousReplacedNode);
    private bool ReplacementBreaksAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax originalAnonymousObjectMemberDeclarator, AnonymousObjectMemberDeclaratorSyntax replacedAnonymousObjectMemberDeclarator);
    private bool ReplacementBreaksConstructorInitializer(ConstructorInitializerSyntax ctorInitializer, ConstructorInitializerSyntax newCtorInitializer);
    private bool ReplacementBreaksCollectionInitializerAddMethod(ExpressionSyntax originalInitializer, ExpressionSyntax newInitializer);
    protected virtual bool ExpressionMightReferenceMember(SyntaxNode node);
    protected virtual ImmutableArray`1<ArgumentSyntax> GetArguments(ExpressionSyntax expression);
    private static BaseArgumentListSyntax GetArgumentList(ExpressionSyntax expression);
    protected virtual ExpressionSyntax GetReceiver(ExpressionSyntax expression);
    protected virtual bool IsInNamespaceOrTypeContext(ExpressionSyntax node);
    protected virtual ExpressionSyntax GetForEachStatementExpression(CommonForEachStatementSyntax forEachStatement);
    protected virtual ExpressionSyntax GetThrowStatementExpression(ThrowStatementSyntax throwStatement);
    protected virtual bool IsForEachTypeInferred(CommonForEachStatementSyntax forEachStatement, SemanticModel semanticModel);
    protected virtual bool IsParenthesizedExpression(SyntaxNode node);
    protected virtual bool IsNamedArgument(ArgumentSyntax argument);
    protected virtual string GetNamedArgumentIdentifierValueText(ArgumentSyntax argument);
    private bool ReplacementBreaksBinaryExpression(BinaryExpressionSyntax binaryExpression, BinaryExpressionSyntax newBinaryExpression);
    private bool ReplacementBreaksConditionalAccessExpression(ConditionalAccessExpressionSyntax conditionalAccessExpression, ConditionalAccessExpressionSyntax newConditionalAccessExpression);
    private bool ReplacementBreaksIsOrAsExpression(BinaryExpressionSyntax originalIsOrAsExpression, BinaryExpressionSyntax newIsOrAsExpression);
    private bool ReplacementBreaksAssignmentExpression(AssignmentExpressionSyntax assignmentExpression, AssignmentExpressionSyntax newAssignmentExpression);
    private bool ReplacementBreaksQueryClause(QueryClauseSyntax originalClause, QueryClauseSyntax newClause);
    protected virtual bool ReplacementIntroducesDisallowedNullType(ExpressionSyntax originalExpression, ExpressionSyntax newExpression, TypeInfo originalTypeInfo, TypeInfo newTypeInfo);
    protected virtual bool ConversionsAreCompatible(SemanticModel originalModel, ExpressionSyntax originalExpression, SemanticModel newModel, ExpressionSyntax newExpression);
    private static bool ConditionalExpressionConversionsAreAllowed(ExpressionSyntax originalExpression);
    protected virtual bool ConversionsAreCompatible(ExpressionSyntax originalExpression, ITypeSymbol originalTargetType, ExpressionSyntax newExpression, ITypeSymbol newTargetType);
    private bool ConversionsAreCompatible(Conversion originalConversion, Conversion newConversion);
    protected virtual bool ForEachConversionsAreCompatible(SemanticModel originalModel, CommonForEachStatementSyntax originalForEach, SemanticModel newModel, CommonForEachStatementSyntax newForEach);
    protected virtual void GetForEachSymbols(SemanticModel model, CommonForEachStatementSyntax forEach, IMethodSymbol& getEnumeratorMethod, ITypeSymbol& elementType);
    protected virtual bool IsReferenceConversion(Compilation compilation, ITypeSymbol sourceType, ITypeSymbol targetType);
    protected virtual Conversion ClassifyConversion(SemanticModel model, ExpressionSyntax expression, ITypeSymbol targetType);
    protected virtual Conversion ClassifyConversion(SemanticModel model, ITypeSymbol originalType, ITypeSymbol targetType);
    [CompilerGeneratedAttribute]
private bool <ReplacementIntroducesDisallowedNullType>g__IsSupportedConstructWithNullType|35_0(<>c__DisplayClass35_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.SyntaxKindSet : object {
    public static ISet`1<SyntaxKind> AllTypeModifiers;
    public static ISet`1<SyntaxKind> AllMemberModifiers;
    public static ISet`1<SyntaxKind> AllGlobalMemberModifiers;
    public static ISet`1<SyntaxKind> AccessibilityModifiers;
    public static ISet`1<SyntaxKind> AllTypeDeclarations;
    public static ISet`1<SyntaxKind> ClassInterfaceStructRecordTypeDeclarations;
    public static ISet`1<SyntaxKind> ClassInterfaceRecordTypeDeclarations;
    public static ISet`1<SyntaxKind> ClassRecordTypeDeclarations;
    public static ISet`1<SyntaxKind> ClassStructRecordTypeDeclarations;
    public static ISet`1<SyntaxKind> StructOnlyTypeDeclarations;
    public static ISet`1<SyntaxKind> InterfaceOnlyTypeDeclarations;
    private static SyntaxKindSet();
}
internal class Microsoft.CodeAnalysis.CSharp.Utilities.TokenComparer : object {
    [NullableAttribute("1")]
public static IComparer`1<SyntaxToken> NormalInstance;
    [NullableAttribute("1")]
public static IComparer`1<SyntaxToken> SystemFirstInstance;
    private bool _specialCaseSystem;
    private TokenComparer(bool specialCaseSystem);
    private static TokenComparer();
    public sealed virtual int Compare(SyntaxToken x, SyntaxToken y);
    private static int CompareWorker(SyntaxToken x, SyntaxToken y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.TypeStyleResult : ValueType {
    private CSharpTypeStyleHelper _helper;
    private TypeSyntax _typeName;
    private SemanticModel _semanticModel;
    private CSharpSimplifierOptions _options;
    private CancellationToken _cancellationToken;
    public bool IsStylePreferred;
    public NotificationOption2 Notification;
    public TypeStyleResult(CSharpTypeStyleHelper helper, TypeSyntax typeName, SemanticModel semanticModel, CSharpSimplifierOptions options, bool isStylePreferred, NotificationOption2 notificationOption, CancellationToken cancellationToken);
    public bool CanConvert();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.TypeSyntaxComparer : object {
    private IComparer`1<SyntaxToken> _tokenComparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IComparer`1<NameSyntax> NameComparer;
    internal TypeSyntaxComparer(IComparer`1<SyntaxToken> tokenComparer, IComparer`1<NameSyntax> nameComparer);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(TypeSyntax x, TypeSyntax y);
    private static TypeSyntax UnwrapType(TypeSyntax type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.UsingsAndExternAliasesDirectiveComparer : object {
    public static IComparer`1<SyntaxNode> NormalInstance;
    public static IComparer`1<SyntaxNode> SystemFirstInstance;
    private IComparer`1<NameSyntax> _nameComparer;
    private IComparer`1<SyntaxToken> _tokenComparer;
    private UsingsAndExternAliasesDirectiveComparer(IComparer`1<NameSyntax> nameComparer, IComparer`1<SyntaxToken> tokenComparer);
    private static UsingsAndExternAliasesDirectiveComparer();
    [NullableContextAttribute("2")]
private static UsingKind GetUsingKind(UsingDirectiveSyntax usingDirective, ExternAliasDirectiveSyntax externDirective);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(SyntaxNode directive1, SyntaxNode directive2);
    [CompilerGeneratedAttribute]
internal static bool <Compare>g__IsGlobal|7_0(UsingKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Utilities.UsingsAndExternAliasesOrganizer : object {
    public static void Organize(SyntaxList`1<ExternAliasDirectiveSyntax> externAliasList, SyntaxList`1<UsingDirectiveSyntax> usingList, bool placeSystemNamespaceFirst, bool separateGroups, SyntaxTrivia newLineTrivia, SyntaxList`1& organizedExternAliasList, SyntaxList`1& organizedUsingList);
    public static bool NeedsGrouping(UsingDirectiveSyntax using1, UsingDirectiveSyntax using2);
    private static void OrganizeWorker(SyntaxList`1<ExternAliasDirectiveSyntax> externAliasList, SyntaxList`1<UsingDirectiveSyntax> usingList, bool placeSystemNamespaceFirst, SyntaxTrivia newLineTrivia, SyntaxList`1& organizedExternAliasList, SyntaxList`1& organizedUsingList);
    private static void EnsureNewLines(IList`1<SyntaxNode> list, SyntaxTrivia newLineTrivia);
    private static SyntaxNode TrimLeadingNewLines(SyntaxNode node);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaSymbolExtensions : object {
    [ExtensionAttribute]
public static string ToNameDisplayString(ISymbol symbol);
    [ExtensionAttribute]
public static ITypeSymbol GetMemberType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ITypeSymbol GetSymbolType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ISymbol GetAnySymbol(SymbolInfo info);
    [ExtensionAttribute]
public static ImmutableArray`1<T> FilterToVisibleAndBrowsableSymbols(ImmutableArray`1<T> symbols, bool hideAdvancedMembers, Compilation compilation);
    [ExtensionAttribute]
public static bool IsAccessibleWithin(ISymbol symbol, ISymbol within, ITypeSymbol throughType);
    [ExtensionAttribute]
public static Nullable`1<bool> IsMoreSpecificThan(IMethodSymbol method1, IMethodSymbol method2);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ISymbol GetOriginalUnreducedDefinition(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAwaitableNonDynamic(ISymbol symbol, SemanticModel semanticModel, int position);
    [ExtensionAttribute]
public static bool IsExtensionMethod(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool IsInNonUserCode(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxToken GetPreviousTokenIfTouchingWord(SyntaxToken token, int position);
    [ExtensionAttribute]
public static SyntaxToken FindTokenOnLeftOfPosition(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static bool IsFoundUnder(SyntaxNode node, Func`2<TParent, SyntaxNode> childGetter);
    [ExtensionAttribute]
public static SimpleNameSyntax GetRightmostName(ExpressionSyntax node);
    [ExtensionAttribute]
public static bool IsInStaticContext(SyntaxNode node);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.NullableExtensions : object {
    [ExtensionAttribute]
public static ITypeSymbol GetConvertedTypeWithAnnotatedNullability(TypeInfo typeInfo);
    [ExtensionAttribute]
public static ITypeSymbol GetTypeWithAnnotatedNullability(TypeInfo typeInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.NullableHelpers : object {
    public static bool IsDeclaredSymbolAssignedPossiblyNullValue(SemanticModel semanticModel, SyntaxNode declarationSyntax, CancellationToken cancellationToken);
    public static Nullable`1<bool> IsSymbolAssignedPossiblyNullValue(SemanticModel semanticModel, IOperation operation, ISymbol symbol);
    private static bool IsSymbolReferencedByOperation(IOperation operation, ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.RemoveUnnecessaryImports.CSharpUnnecessaryImportsProvider : AbstractUnnecessaryImportsProvider`1<UsingDirectiveSyntax> {
    public static CSharpUnnecessaryImportsProvider Instance;
    private static CSharpUnnecessaryImportsProvider();
    public virtual ImmutableArray`1<UsingDirectiveSyntax> GetUnnecessaryImports(SemanticModel model, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
