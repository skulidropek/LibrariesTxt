public class CommandLine.BadFormatConversionError : NamedError {
    internal BadFormatConversionError(NameInfo nameInfo);
}
public class CommandLine.BadFormatTokenError : TokenError {
    internal BadFormatTokenError(string token);
}
public class CommandLine.BadVerbSelectedError : TokenError {
    internal BadVerbSelectedError(string token);
}
public abstract class CommandLine.BaseAttribute : Attribute {
    private int min;
    private int max;
    private object default;
    private LocalizableAttributeProperty helpText;
    private string metaValue;
    private Type resourceType;
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Hidden>k__BackingField;
    public bool Required { get; public set; }
    public int Min { get; public set; }
    public int Max { get; public set; }
    public object Default { get; public set; }
    public string HelpText { get; public set; }
    public string MetaValue { get; public set; }
    public bool Hidden { get; public set; }
    public Type ResourceType { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(bool value);
    public int get_Min();
    public void set_Min(int value);
    public int get_Max();
    public void set_Max(int value);
    public object get_Default();
    public void set_Default(object value);
    public string get_HelpText();
    public void set_HelpText(string value);
    public string get_MetaValue();
    public void set_MetaValue(string value);
    [CompilerGeneratedAttribute]
public bool get_Hidden();
    [CompilerGeneratedAttribute]
public void set_Hidden(bool value);
    public Type get_ResourceType();
    public void set_ResourceType(Type value);
}
[ExtensionAttribute]
public static class CommandLine.CastExtensions : object {
    private static string ImplicitCastMethodName;
    private static string ExplicitCastMethodName;
    [ExtensionAttribute]
public static bool CanCast(Type baseType);
    [ExtensionAttribute]
public static bool CanCast(object obj);
    [ExtensionAttribute]
public static T Cast(object obj);
    [ExtensionAttribute]
private static bool CanImplicitCast(Type baseType);
    [ExtensionAttribute]
private static bool CanImplicitCast(object obj);
    [ExtensionAttribute]
private static bool CanExplicitCast(Type baseType);
    [ExtensionAttribute]
private static bool CanExplicitCast(object obj);
    [ExtensionAttribute]
private static bool CanCast(Type baseType, string castMethodName);
    [ExtensionAttribute]
private static T ImplicitCast(object obj);
    [ExtensionAttribute]
private static T ExplicitCast(object obj);
    [ExtensionAttribute]
private static T Cast(object obj, string castMethodName);
}
[ExtensionAttribute]
internal static class CommandLine.Core.ArgumentsExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Error> Preprocess(IEnumerable`1<string> arguments, IEnumerable`1<Func`2<IEnumerable`1<string>, IEnumerable`1<Error>>> preprocessorLookup);
}
internal static class CommandLine.Core.GetoptTokenizer : object {
    public static Result`2<IEnumerable`1<Token>, Error> Tokenize(IEnumerable`1<string> arguments, Func`2<string, NameLookupResult> nameLookup);
    public static Result`2<IEnumerable`1<Token>, Error> Tokenize(IEnumerable`1<string> arguments, Func`2<string, NameLookupResult> nameLookup, bool ignoreUnknownArguments, bool allowDashDash, bool posixlyCorrect);
    public static Result`2<IEnumerable`1<Token>, Error> ExplodeOptionList(Result`2<IEnumerable`1<Token>, Error> tokenizerResult, Func`2<string, Maybe`1<char>> optionSequenceWithSeparatorLookup);
    public static Func`3<IEnumerable`1<string>, IEnumerable`1<OptionSpecification>, Result`2<IEnumerable`1<Token>, Error>> ConfigureTokenizer(StringComparer nameComparer, bool ignoreUnknownArguments, bool enableDashDash, bool posixlyCorrect);
    private static IEnumerable`1<Token> TokenizeShortName(string arg, Func`2<string, NameLookupResult> nameLookup, Action`1<string> onUnknownOption, Action`1<int> onConsumeNext);
    private static IEnumerable`1<Token> TokenizeLongName(string arg, Func`2<string, NameLookupResult> nameLookup, Action`1<string> onBadFormatToken, Action`1<string> onUnknownOption, Action`1<int> onConsumeNext);
}
internal static class CommandLine.Core.InstanceBuilder : object {
    public static ParserResult`1<T> Build(Maybe`1<Func`1<T>> factory, Func`3<IEnumerable`1<string>, IEnumerable`1<OptionSpecification>, Result`2<IEnumerable`1<Token>, Error>> tokenizer, IEnumerable`1<string> arguments, StringComparer nameComparer, bool ignoreValueCase, CultureInfo parsingCulture, bool autoHelp, bool autoVersion, IEnumerable`1<ErrorType> nonFatalErrors);
    public static ParserResult`1<T> Build(Maybe`1<Func`1<T>> factory, Func`3<IEnumerable`1<string>, IEnumerable`1<OptionSpecification>, Result`2<IEnumerable`1<Token>, Error>> tokenizer, IEnumerable`1<string> arguments, StringComparer nameComparer, bool ignoreValueCase, CultureInfo parsingCulture, bool autoHelp, bool autoVersion, bool allowMultiInstance, IEnumerable`1<ErrorType> nonFatalErrors);
    private static T BuildMutable(Maybe`1<Func`1<T>> factory, IEnumerable`1<SpecificationProperty> specPropsWithValue, List`1<Error> setPropertyErrors);
    private static T BuildImmutable(Type typeInfo, Maybe`1<Func`1<T>> factory, IEnumerable`1<SpecificationProperty> specProps, IEnumerable`1<SpecificationProperty> specPropsWithValue, List`1<Error> setPropertyErrors);
}
internal static class CommandLine.Core.InstanceChooser : object {
    public static ParserResult`1<object> Choose(Func`3<IEnumerable`1<string>, IEnumerable`1<OptionSpecification>, Result`2<IEnumerable`1<Token>, Error>> tokenizer, IEnumerable`1<Type> types, IEnumerable`1<string> arguments, StringComparer nameComparer, bool ignoreValueCase, CultureInfo parsingCulture, bool autoHelp, bool autoVersion, IEnumerable`1<ErrorType> nonFatalErrors);
    public static ParserResult`1<object> Choose(Func`3<IEnumerable`1<string>, IEnumerable`1<OptionSpecification>, Result`2<IEnumerable`1<Token>, Error>> tokenizer, IEnumerable`1<Type> types, IEnumerable`1<string> arguments, StringComparer nameComparer, bool ignoreValueCase, CultureInfo parsingCulture, bool autoHelp, bool autoVersion, bool allowMultiInstance, IEnumerable`1<ErrorType> nonFatalErrors);
    private static ParserResult`1<object> MatchDefaultVerb(Func`3<IEnumerable`1<string>, IEnumerable`1<OptionSpecification>, Result`2<IEnumerable`1<Token>, Error>> tokenizer, IEnumerable`1<Tuple`2<Verb, Type>> verbs, Tuple`2<Verb, Type> defaultVerb, IEnumerable`1<string> arguments, StringComparer nameComparer, bool ignoreValueCase, CultureInfo parsingCulture, bool autoHelp, bool autoVersion, IEnumerable`1<ErrorType> nonFatalErrors);
    private static ParserResult`1<object> MatchVerb(Func`3<IEnumerable`1<string>, IEnumerable`1<OptionSpecification>, Result`2<IEnumerable`1<Token>, Error>> tokenizer, IEnumerable`1<Tuple`2<Verb, Type>> verbs, Tuple`2<Verb, Type> defaultVerb, IEnumerable`1<string> arguments, StringComparer nameComparer, bool ignoreValueCase, CultureInfo parsingCulture, bool autoHelp, bool autoVersion, bool allowMultiInstance, IEnumerable`1<ErrorType> nonFatalErrors);
    private static HelpVerbRequestedError MakeHelpVerbRequestedError(IEnumerable`1<Tuple`2<Verb, Type>> verbs, string verb, StringComparer nameComparer);
    private static NotParsed`1<object> MakeNotParsed(IEnumerable`1<Type> types, Error[] errors);
    [CompilerGeneratedAttribute]
internal static ParserResult`1<object> <Choose>g__choose|1_1(<>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static bool <Choose>g__preprocCompare|1_2(string command, <>c__DisplayClass1_0& , <>c__DisplayClass1_1& );
}
[ExtensionAttribute]
internal static class CommandLine.Core.KeyValuePairHelper : object {
    public static IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> ForSwitch(IEnumerable`1<Token> tokens);
    public static IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> ForScalar(IEnumerable`1<Token> tokens);
    public static IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> ForSequence(IEnumerable`1<Token> tokens);
    [ExtensionAttribute]
private static KeyValuePair`2<string, IEnumerable`1<string>> ToKeyValuePair(string value, String[] values);
}
internal class CommandLine.Core.Name : Token {
    public Name(string text);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Name other);
}
[ExtensionAttribute]
internal static class CommandLine.Core.NameExtensions : object {
    [ExtensionAttribute]
public static bool MatchName(string value, string shortName, string longName, StringComparer comparer);
    [ExtensionAttribute]
public static NameInfo FromOptionSpecification(OptionSpecification specification);
    [ExtensionAttribute]
public static NameInfo FromSpecification(Specification specification);
}
internal static class CommandLine.Core.NameLookup : object {
    public static NameLookupResult Contains(string name, IEnumerable`1<OptionSpecification> specifications, StringComparer comparer);
    public static Maybe`1<char> HavingSeparator(string name, IEnumerable`1<OptionSpecification> specifications, StringComparer comparer);
}
internal enum CommandLine.Core.NameLookupResult : Enum {
    public int value__;
    public static NameLookupResult NoOptionFound;
    public static NameLookupResult BooleanOptionFound;
    public static NameLookupResult OtherOptionFound;
}
internal static class CommandLine.Core.OptionMapper : object {
    public static Result`2<IEnumerable`1<SpecificationProperty>, Error> MapValues(IEnumerable`1<SpecificationProperty> propertyTuples, IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> options, Func`5<IEnumerable`1<string>, Type, bool, bool, Maybe`1<object>> converter, StringComparer comparer);
}
internal class CommandLine.Core.OptionSpecification : Specification {
    private string shortName;
    private string longName;
    private char separator;
    private string setName;
    private string group;
    private bool flagCounter;
    public string ShortName { get; }
    public string LongName { get; }
    public char Separator { get; }
    public string SetName { get; }
    public string Group { get; }
    public bool FlagCounter { get; }
    public OptionSpecification(string shortName, string longName, bool required, string setName, Maybe`1<int> min, Maybe`1<int> max, char separator, Maybe`1<object> defaultValue, string helpText, string metaValue, IEnumerable`1<string> enumValues, Type conversionType, TargetType targetType, string group, bool flagCounter, bool hidden);
    public static OptionSpecification FromAttribute(OptionAttribute attribute, Type conversionType, IEnumerable`1<string> enumValues);
    public static OptionSpecification NewSwitch(string shortName, string longName, bool required, string helpText, string metaValue, bool hidden);
    public string get_ShortName();
    public string get_LongName();
    public char get_Separator();
    public string get_SetName();
    public string get_Group();
    public bool get_FlagCounter();
}
[ExtensionAttribute]
internal static class CommandLine.Core.PartitionExtensions : object {
    [ExtensionAttribute]
public static Tuple`2<IEnumerable`1<T>, IEnumerable`1<T>> PartitionByPredicate(IEnumerable`1<T> items, Func`2<T, bool> pred);
}
internal static class CommandLine.Core.PreprocessorGuards : object {
    public static IEnumerable`1<Func`2<IEnumerable`1<string>, IEnumerable`1<Error>>> Lookup(StringComparer nameComparer, bool autoHelp, bool autoVersion);
    public static Func`2<IEnumerable`1<string>, IEnumerable`1<Error>> HelpCommand(StringComparer nameComparer);
    public static Func`2<IEnumerable`1<string>, IEnumerable`1<Error>> VersionCommand(StringComparer nameComparer);
}
[ExtensionAttribute]
internal static class CommandLine.Core.ReflectionExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> GetSpecifications(Type type, Func`2<PropertyInfo, T> selector);
    [ExtensionAttribute]
public static Maybe`1<VerbAttribute> GetVerbSpecification(Type type);
    [ExtensionAttribute]
public static Maybe`1<Tuple`2<PropertyInfo, UsageAttribute>> GetUsageData(Type type);
    [ExtensionAttribute]
private static IEnumerable`1<Type> FlattenHierarchy(Type type);
    [ExtensionAttribute]
private static IEnumerable`1<Type> SafeGetInterfaces(Type type);
    [ExtensionAttribute]
public static TargetType ToTargetType(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<Error> SetProperties(T instance, IEnumerable`1<SpecificationProperty> specProps, Func`2<SpecificationProperty, bool> predicate, Func`2<SpecificationProperty, object> selector);
    [ExtensionAttribute]
private static IEnumerable`1<Error> SetValue(SpecificationProperty specProp, T instance, object value);
    [ExtensionAttribute]
public static object CreateEmptyArray(Type type);
    [ExtensionAttribute]
public static object GetDefaultValue(Type type);
    [ExtensionAttribute]
public static bool IsMutable(Type type);
    [ExtensionAttribute]
public static object CreateDefaultForImmutable(Type type);
    [ExtensionAttribute]
public static object AutoDefault(Type type);
    [ExtensionAttribute]
public static TypeInfo ToTypeInfo(Type type);
    [ExtensionAttribute]
public static object StaticMethod(Type type, string name, Object[] args);
    [ExtensionAttribute]
public static object StaticProperty(Type type, string name);
    [ExtensionAttribute]
public static object InstanceProperty(Type type, string name, object target);
    [ExtensionAttribute]
public static bool IsPrimitiveEx(Type type);
    [ExtensionAttribute]
public static bool IsCustomStruct(Type type);
}
internal abstract class CommandLine.Core.Specification : object {
    private SpecificationType tag;
    private bool required;
    private bool hidden;
    private Maybe`1<int> min;
    private Maybe`1<int> max;
    private Maybe`1<object> defaultValue;
    private string helpText;
    private string metaValue;
    private IEnumerable`1<string> enumValues;
    private Type conversionType;
    private TargetType targetType;
    public SpecificationType Tag { get; }
    public bool Required { get; }
    public Maybe`1<int> Min { get; }
    public Maybe`1<int> Max { get; }
    public Maybe`1<object> DefaultValue { get; }
    public string HelpText { get; }
    public string MetaValue { get; }
    public IEnumerable`1<string> EnumValues { get; }
    public Type ConversionType { get; }
    public TargetType TargetType { get; }
    public bool Hidden { get; }
    protected Specification(SpecificationType tag, bool required, Maybe`1<int> min, Maybe`1<int> max, Maybe`1<object> defaultValue, string helpText, string metaValue, IEnumerable`1<string> enumValues, Type conversionType, TargetType targetType, bool hidden);
    public SpecificationType get_Tag();
    public bool get_Required();
    public Maybe`1<int> get_Min();
    public Maybe`1<int> get_Max();
    public Maybe`1<object> get_DefaultValue();
    public string get_HelpText();
    public string get_MetaValue();
    public IEnumerable`1<string> get_EnumValues();
    public Type get_ConversionType();
    public TargetType get_TargetType();
    public bool get_Hidden();
    public static Specification FromProperty(PropertyInfo property);
}
[ExtensionAttribute]
internal static class CommandLine.Core.SpecificationExtensions : object {
    [ExtensionAttribute]
public static bool IsOption(Specification specification);
    [ExtensionAttribute]
public static bool IsValue(Specification specification);
    [ExtensionAttribute]
public static OptionSpecification WithLongName(OptionSpecification specification, string newLongName);
    [ExtensionAttribute]
public static string UniqueName(OptionSpecification specification);
    [ExtensionAttribute]
public static IEnumerable`1<Specification> ThrowingValidate(IEnumerable`1<Specification> specifications, IEnumerable`1<Tuple`2<Func`2<Specification, bool>, string>> guardsLookup);
    [ExtensionAttribute]
public static bool HavingRange(Specification specification, Func`3<int, int, bool> predicate);
    [ExtensionAttribute]
public static bool HavingMin(Specification specification, Func`2<int, bool> predicate);
    [ExtensionAttribute]
public static bool HavingMax(Specification specification, Func`2<int, bool> predicate);
}
internal static class CommandLine.Core.SpecificationGuards : object {
    public static IEnumerable`1<Tuple`2<Func`2<Specification, bool>, string>> Lookup;
    private static SpecificationGuards();
    private static Func`2<Specification, bool> GuardAgainstScalarWithRange();
    private static Func`2<Specification, bool> GuardAgainstSequenceWithWrongRange();
    private static Func`2<Specification, bool> GuardAgainstOneCharLongName();
    private static Func`2<Specification, bool> GuardAgainstSequenceWithZeroRange();
}
internal class CommandLine.Core.SpecificationProperty : object {
    private Specification specification;
    private PropertyInfo property;
    private Maybe`1<object> value;
    public Specification Specification { get; }
    public PropertyInfo Property { get; }
    public Maybe`1<object> Value { get; }
    private SpecificationProperty(Specification specification, PropertyInfo property, Maybe`1<object> value);
    public static SpecificationProperty Create(Specification specification, PropertyInfo property, Maybe`1<object> value);
    public Specification get_Specification();
    public PropertyInfo get_Property();
    public Maybe`1<object> get_Value();
}
[ExtensionAttribute]
internal static class CommandLine.Core.SpecificationPropertyExtensions : object {
    [ExtensionAttribute]
public static SpecificationProperty WithSpecification(SpecificationProperty specProp, Specification newSpecification);
    [ExtensionAttribute]
public static SpecificationProperty WithValue(SpecificationProperty specProp, Maybe`1<object> newValue);
    [ExtensionAttribute]
public static Type GetConversionType(SpecificationProperty specProp);
    [ExtensionAttribute]
public static IEnumerable`1<Error> Validate(IEnumerable`1<SpecificationProperty> specProps, IEnumerable`1<Func`2<IEnumerable`1<SpecificationProperty>, IEnumerable`1<Error>>> rules);
}
[ExtensionAttribute]
internal static class CommandLine.Core.SpecificationPropertyRules : object {
    public static IEnumerable`1<Func`2<IEnumerable`1<SpecificationProperty>, IEnumerable`1<Error>>> Lookup(IEnumerable`1<Token> tokens);
    public static IEnumerable`1<Func`2<IEnumerable`1<SpecificationProperty>, IEnumerable`1<Error>>> Lookup(IEnumerable`1<Token> tokens, bool allowMultiInstance);
    private static Func`2<IEnumerable`1<SpecificationProperty>, IEnumerable`1<Error>> EnforceMutuallyExclusiveSetAndGroupAreNotUsedTogether();
    private static Func`2<IEnumerable`1<SpecificationProperty>, IEnumerable`1<Error>> EnforceGroup();
    private static Func`2<IEnumerable`1<SpecificationProperty>, IEnumerable`1<Error>> EnforceMutuallyExclusiveSet();
    private static Func`2<IEnumerable`1<SpecificationProperty>, IEnumerable`1<Error>> EnforceRequired();
    private static Func`2<IEnumerable`1<SpecificationProperty>, IEnumerable`1<Error>> EnforceRange();
    private static Func`2<IEnumerable`1<SpecificationProperty>, IEnumerable`1<Error>> EnforceSingle(IEnumerable`1<Token> tokens, bool allowMultiInstance);
    [ExtensionAttribute]
private static bool ContainsIfNotEmpty(IEnumerable`1<T> sequence, T value);
}
internal enum CommandLine.Core.SpecificationType : Enum {
    public int value__;
    public static SpecificationType Option;
    public static SpecificationType Value;
}
internal enum CommandLine.Core.TargetType : Enum {
    public int value__;
    public static TargetType Switch;
    public static TargetType Scalar;
    public static TargetType Sequence;
}
internal abstract class CommandLine.Core.Token : object {
    private TokenType tag;
    private string text;
    public TokenType Tag { get; }
    public string Text { get; }
    protected Token(TokenType tag, string text);
    public static Token Name(string text);
    public static Token Value(string text);
    public static Token Value(string text, bool explicitlyAssigned);
    public static Token ValueForced(string text);
    public static Token ValueFromSeparator(string text);
    public TokenType get_Tag();
    public string get_Text();
}
[ExtensionAttribute]
internal static class CommandLine.Core.TokenExtensions : object {
    [ExtensionAttribute]
public static bool IsName(Token token);
    [ExtensionAttribute]
public static bool IsValue(Token token);
    [ExtensionAttribute]
public static bool IsValueFromSeparator(Token token);
    [ExtensionAttribute]
public static bool IsValueForced(Token token);
}
internal static class CommandLine.Core.Tokenizer : object {
    public static Result`2<IEnumerable`1<Token>, Error> Tokenize(IEnumerable`1<string> arguments, Func`2<string, NameLookupResult> nameLookup);
    public static Result`2<IEnumerable`1<Token>, Error> Tokenize(IEnumerable`1<string> arguments, Func`2<string, NameLookupResult> nameLookup, Func`2<IEnumerable`1<Token>, IEnumerable`1<Token>> normalize);
    public static Result`2<IEnumerable`1<Token>, Error> PreprocessDashDash(IEnumerable`1<string> arguments, Func`2<IEnumerable`1<string>, Result`2<IEnumerable`1<Token>, Error>> tokenizer);
    public static Result`2<IEnumerable`1<Token>, Error> ExplodeOptionList(Result`2<IEnumerable`1<Token>, Error> tokenizerResult, Func`2<string, Maybe`1<char>> optionSequenceWithSeparatorLookup);
    public static IEnumerable`1<Token> Normalize(IEnumerable`1<Token> tokens, Func`2<string, bool> nameLookup);
    public static Func`3<IEnumerable`1<string>, IEnumerable`1<OptionSpecification>, Result`2<IEnumerable`1<Token>, Error>> ConfigureTokenizer(StringComparer nameComparer, bool ignoreUnknownArguments, bool enableDashDash);
    private static IEnumerable`1<Token> TokenizeShortName(string value, Func`2<string, NameLookupResult> nameLookup);
    private static IEnumerable`1<Token> TokenizeLongName(string value, Action`1<Error> onError);
}
internal static class CommandLine.Core.TokenPartitioner : object {
    public static Tuple`3<IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>>, IEnumerable`1<string>, IEnumerable`1<Token>> Partition(IEnumerable`1<Token> tokens, Func`2<string, Maybe`1<TypeDescriptor>> typeLookup);
    public static Tuple`4<IEnumerable`1<Token>, IEnumerable`1<Token>, IEnumerable`1<Token>, IEnumerable`1<Token>> PartitionTokensByType(IEnumerable`1<Token> tokens, Func`2<string, Maybe`1<TypeDescriptor>> typeLookup);
}
internal enum CommandLine.Core.TokenType : Enum {
    public int value__;
    public static TokenType Name;
    public static TokenType Value;
}
[ExtensionAttribute]
internal static class CommandLine.Core.TypeConverter : object {
    public static Maybe`1<object> ChangeType(IEnumerable`1<string> values, Type conversionType, bool scalar, bool isFlag, CultureInfo conversionCulture, bool ignoreValueCase);
    private static Maybe`1<object> ChangeTypeSequence(IEnumerable`1<string> values, Type conversionType, CultureInfo conversionCulture, bool ignoreValueCase);
    private static Maybe`1<object> ChangeTypeScalar(string value, Type conversionType, CultureInfo conversionCulture, bool ignoreValueCase);
    private static Maybe`1<object> ChangeTypeFlagCounter(IEnumerable`1<string> values, Type conversionType, CultureInfo conversionCulture, bool ignoreValueCase);
    private static object ConvertString(string value, Type type, CultureInfo conversionCulture);
    private static Result`2<object, Exception> ChangeTypeScalarImpl(string value, Type conversionType, CultureInfo conversionCulture, bool ignoreValueCase);
    [ExtensionAttribute]
private static object ToEnum(string value, Type conversionType, bool ignoreValueCase);
    private static bool IsDefinedEx(object enumValue);
}
internal class CommandLine.Core.TypeDescriptor : ValueType {
    private TargetType targetType;
    private Maybe`1<int> maxItems;
    private Maybe`1<TypeDescriptor> nextValue;
    public TargetType TargetType { get; }
    public Maybe`1<int> MaxItems { get; }
    public Maybe`1<TypeDescriptor> NextValue { get; }
    private TypeDescriptor(TargetType targetType, Maybe`1<int> maxItems, Maybe`1<TypeDescriptor> nextValue);
    public TargetType get_TargetType();
    public Maybe`1<int> get_MaxItems();
    public Maybe`1<TypeDescriptor> get_NextValue();
    public static TypeDescriptor Create(TargetType tag, Maybe`1<int> maximumItems, TypeDescriptor next);
}
[ExtensionAttribute]
internal static class CommandLine.Core.TypeDescriptorExtensions : object {
    [ExtensionAttribute]
public static TypeDescriptor WithNextValue(TypeDescriptor descriptor, Maybe`1<TypeDescriptor> nextValue);
}
internal static class CommandLine.Core.TypeLookup : object {
    public static Maybe`1<TypeDescriptor> FindTypeDescriptorAndSibling(string name, IEnumerable`1<OptionSpecification> specifications, StringComparer comparer);
}
internal class CommandLine.Core.Value : Token {
    private bool explicitlyAssigned;
    private bool forced;
    private bool fromSeparator;
    public bool ExplicitlyAssigned { get; }
    public bool FromSeparator { get; }
    public bool Forced { get; }
    public Value(string text);
    public Value(string text, bool explicitlyAssigned);
    public Value(string text, bool explicitlyAssigned, bool forced, bool fromSeparator);
    public bool get_ExplicitlyAssigned();
    public bool get_FromSeparator();
    public bool get_Forced();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Value other);
}
[ExtensionAttribute]
internal static class CommandLine.Core.ValueMapper : object {
    public static Result`2<IEnumerable`1<SpecificationProperty>, Error> MapValues(IEnumerable`1<SpecificationProperty> specProps, IEnumerable`1<string> values, Func`4<IEnumerable`1<string>, Type, bool, Maybe`1<object>> converter);
    private static IEnumerable`1<Tuple`2<SpecificationProperty, Maybe`1<Error>>> MapValuesImpl(IEnumerable`1<SpecificationProperty> specProps, IEnumerable`1<string> values, Func`4<IEnumerable`1<string>, Type, bool, Maybe`1<object>> converter);
    [ExtensionAttribute]
private static Maybe`1<int> CountOfMaxNumberOfValues(Specification specification);
    [ExtensionAttribute]
private static Maybe`1<Error> MakeErrorInCaseOfMinConstraint(Specification specification);
}
internal class CommandLine.Core.ValueSpecification : Specification {
    private int index;
    private string metaName;
    public int Index { get; }
    public string MetaName { get; }
    public ValueSpecification(int index, string metaName, bool required, Maybe`1<int> min, Maybe`1<int> max, Maybe`1<object> defaultValue, string helpText, string metaValue, IEnumerable`1<string> enumValues, Type conversionType, TargetType targetType, bool hidden);
    public static ValueSpecification FromAttribute(ValueAttribute attribute, Type conversionType, IEnumerable`1<string> enumValues);
    public int get_Index();
    public string get_MetaName();
}
internal class CommandLine.Core.Verb : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpText>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Hidden>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Aliases>k__BackingField;
    public string Name { get; private set; }
    public string HelpText { get; private set; }
    public bool Hidden { get; private set; }
    public bool IsDefault { get; private set; }
    public String[] Aliases { get; private set; }
    public Verb(string name, string helpText, bool hidden, bool isDefault, String[] aliases);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_HelpText();
    [CompilerGeneratedAttribute]
private void set_HelpText(string value);
    [CompilerGeneratedAttribute]
public bool get_Hidden();
    [CompilerGeneratedAttribute]
private void set_Hidden(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDefault();
    [CompilerGeneratedAttribute]
private void set_IsDefault(bool value);
    [CompilerGeneratedAttribute]
public String[] get_Aliases();
    [CompilerGeneratedAttribute]
private void set_Aliases(String[] value);
    public static Verb FromAttribute(VerbAttribute attribute);
    public static IEnumerable`1<Tuple`2<Verb, Type>> SelectFromTypes(IEnumerable`1<Type> types);
}
public abstract class CommandLine.Error : object {
    private ErrorType tag;
    private bool stopsProcessing;
    public ErrorType Tag { get; }
    public bool StopsProcessing { get; }
    protected internal Error(ErrorType tag, bool stopsProcessing);
    protected internal Error(ErrorType tag);
    public ErrorType get_Tag();
    public bool get_StopsProcessing();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Error other);
}
[ExtensionAttribute]
internal static class CommandLine.ErrorExtensions : object {
    [ExtensionAttribute]
public static ParserResult`1<T> ToParserResult(IEnumerable`1<Error> errors, T instance);
    [ExtensionAttribute]
public static IEnumerable`1<Error> OnlyMeaningfulOnes(IEnumerable`1<Error> errors);
}
public enum CommandLine.ErrorType : Enum {
    public int value__;
    public static ErrorType BadFormatTokenError;
    public static ErrorType MissingValueOptionError;
    public static ErrorType UnknownOptionError;
    public static ErrorType MissingRequiredOptionError;
    public static ErrorType MutuallyExclusiveSetError;
    public static ErrorType BadFormatConversionError;
    public static ErrorType SequenceOutOfRangeError;
    public static ErrorType RepeatedOptionError;
    public static ErrorType NoVerbSelectedError;
    public static ErrorType BadVerbSelectedError;
    public static ErrorType HelpRequestedError;
    public static ErrorType HelpVerbRequestedError;
    public static ErrorType VersionRequestedError;
    public static ErrorType SetValueExceptionError;
    public static ErrorType InvalidAttributeConfigurationError;
    public static ErrorType MissingGroupOptionError;
    public static ErrorType GroupOptionAmbiguityError;
    public static ErrorType MultipleDefaultVerbsError;
}
public class CommandLine.GroupOptionAmbiguityError : NamedError {
    public NameInfo Option;
    internal GroupOptionAmbiguityError(NameInfo option);
}
public class CommandLine.HelpRequestedError : Error {
}
[ExtensionAttribute]
public static class CommandLine.HelpTextExtensions : object {
    [ExtensionAttribute]
public static bool IsHelp(IEnumerable`1<Error> errs);
    [ExtensionAttribute]
public static bool IsVersion(IEnumerable`1<Error> errs);
    [ExtensionAttribute]
public static TextWriter Output(IEnumerable`1<Error> errs);
}
public class CommandLine.HelpVerbRequestedError : Error {
    private string verb;
    private Type type;
    private bool matched;
    public string Verb { get; }
    public Type Type { get; }
    public bool Matched { get; }
    internal HelpVerbRequestedError(string verb, Type type, bool matched);
    public string get_Verb();
    public Type get_Type();
    public bool get_Matched();
}
[ExtensionAttribute]
internal static class CommandLine.Infrastructure.EnumerableExtensions : object {
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static object ToUntypedArray(IEnumerable`1<object> value, Type type);
    [ExtensionAttribute]
public static bool Empty(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IEnumerable`1<T[]> Group(IEnumerable`1<T> source, int groupSize);
}
[ExtensionAttribute]
internal static class CommandLine.Infrastructure.ExceptionExtensions : object {
    [ExtensionAttribute]
public static void RethrowWhenAbsentIn(Exception exception, IEnumerable`1<Type> validExceptions);
}
internal class CommandLine.Infrastructure.LocalizableAttributeProperty : object {
    private string _propertyName;
    private string _value;
    private Type _type;
    private PropertyInfo _localizationPropertyInfo;
    public string Value { get; public set; }
    unknown Type ResourceType {public set; }
    public LocalizableAttributeProperty(string propertyName);
    public string get_Value();
    public void set_Value(string value);
    public void set_ResourceType(Type value);
    private string GetLocalizedValue();
}
internal static class CommandLine.Infrastructure.PopsicleSetter : object {
    public static void Set(bool consumed, T& field, T value);
}
internal class CommandLine.Infrastructure.ReferenceEqualityComparer : object {
    public static ReferenceEqualityComparer Default;
    private static ReferenceEqualityComparer();
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
internal static class CommandLine.Infrastructure.ReflectionHelper : object {
    [ThreadStaticAttribute]
private static IDictionary`2<Type, Attribute> _overrides;
    public static void SetAttributeOverride(IEnumerable`1<Attribute> overrides);
    public static Maybe`1<TAttribute> GetAttribute();
    public static string GetAssemblyName();
    public static string GetAssemblyVersion();
    public static bool IsFSharpOptionType(Type type);
    public static T CreateDefaultImmutableInstance(Type[] constructorTypes);
    public static object CreateDefaultImmutableInstance(Type type, Type[] constructorTypes);
    private static Assembly GetExecutingOrEntryAssembly();
    public static IEnumerable`1<string> GetNamesOfEnum(Type t);
}
[ExtensionAttribute]
internal static class CommandLine.Infrastructure.StringBuilderExtensions : object {
    [ExtensionAttribute]
public static StringBuilder AppendWhen(StringBuilder builder, bool condition, String[] values);
    [ExtensionAttribute]
public static StringBuilder AppendWhen(StringBuilder builder, bool condition, Char[] values);
    [ExtensionAttribute]
public static StringBuilder AppendFormatWhen(StringBuilder builder, bool condition, string format, Object[] args);
    [ExtensionAttribute]
public static StringBuilder AppendIf(StringBuilder builder, bool condition, string ifTrue, string ifFalse);
    [ExtensionAttribute]
public static StringBuilder BimapIf(StringBuilder builder, bool condition, Func`2<StringBuilder, StringBuilder> ifTrue, Func`2<StringBuilder, StringBuilder> ifFalse);
    [ExtensionAttribute]
public static StringBuilder MapIf(StringBuilder builder, bool condition, Func`2<StringBuilder, StringBuilder> ifTrue);
    [ExtensionAttribute]
public static StringBuilder AppendIfNotEmpty(StringBuilder builder, String[] values);
    [ExtensionAttribute]
public static string SafeToString(StringBuilder builder);
    [ExtensionAttribute]
public static int SafeLength(StringBuilder builder);
    [ExtensionAttribute]
public static StringBuilder TrimEnd(StringBuilder builder, char c);
    [ExtensionAttribute]
public static StringBuilder TrimEndIfMatch(StringBuilder builder, char c);
    [ExtensionAttribute]
public static StringBuilder TrimEndIfMatchWhen(StringBuilder builder, bool condition, char c);
    [ExtensionAttribute]
public static int TrailingSpaces(StringBuilder builder);
    [ExtensionAttribute]
public static bool SafeStartsWith(StringBuilder builder, string s);
    [ExtensionAttribute]
public static bool SafeEndsWith(StringBuilder builder, string s);
}
[ExtensionAttribute]
internal static class CommandLine.Infrastructure.StringExtensions : object {
    [ExtensionAttribute]
public static string ToOneCharString(char c);
    [ExtensionAttribute]
public static string ToStringInvariant(T value);
    [ExtensionAttribute]
public static string ToStringLocal(T value);
    [ExtensionAttribute]
public static string FormatInvariant(string value, Object[] arguments);
    [ExtensionAttribute]
public static string FormatLocal(string value, Object[] arguments);
    [ExtensionAttribute]
public static string Spaces(int value);
    [ExtensionAttribute]
public static bool EqualsOrdinal(string strA, string strB);
    [ExtensionAttribute]
public static bool EqualsOrdinalIgnoreCase(string strA, string strB);
    [ExtensionAttribute]
public static int SafeLength(string value);
    [ExtensionAttribute]
public static string JoinTo(string value, String[] others);
    [ExtensionAttribute]
public static bool IsBooleanString(string value);
    [ExtensionAttribute]
public static bool ToBoolean(string value);
    [ExtensionAttribute]
public static bool ToBooleanLoose(string value);
}
public class CommandLine.InvalidAttributeConfigurationError : Error {
    public static string ErrorMessage;
}
public class CommandLine.MissingGroupOptionError : Error {
    public static string ErrorMessage;
    private string group;
    private IEnumerable`1<NameInfo> names;
    public string Group { get; }
    public IEnumerable`1<NameInfo> Names { get; }
    internal MissingGroupOptionError(string group, IEnumerable`1<NameInfo> names);
    public string get_Group();
    public IEnumerable`1<NameInfo> get_Names();
    public sealed virtual bool Equals(Error obj);
    public sealed virtual bool Equals(MissingGroupOptionError other);
}
public class CommandLine.MissingRequiredOptionError : NamedError {
    internal MissingRequiredOptionError(NameInfo nameInfo);
}
public class CommandLine.MissingValueOptionError : NamedError {
    internal MissingValueOptionError(NameInfo nameInfo);
}
public class CommandLine.MultipleDefaultVerbsError : Error {
    public static string ErrorMessage;
}
public class CommandLine.MutuallyExclusiveSetError : NamedError {
    private string setName;
    public string SetName { get; }
    internal MutuallyExclusiveSetError(NameInfo nameInfo, string setName);
    public string get_SetName();
}
public abstract class CommandLine.NamedError : Error {
    private NameInfo nameInfo;
    public NameInfo NameInfo { get; }
    protected internal NamedError(ErrorType tag, NameInfo nameInfo);
    public NameInfo get_NameInfo();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(NamedError other);
}
public class CommandLine.NameInfo : object {
    public static NameInfo EmptyName;
    private string longName;
    private string shortName;
    public string ShortName { get; }
    public string LongName { get; }
    public string NameText { get; }
    internal NameInfo(string shortName, string longName);
    private static NameInfo();
    public string get_ShortName();
    public string get_LongName();
    public string get_NameText();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(NameInfo other);
}
public class CommandLine.NotParsed`1 : ParserResult`1<T> {
    internal NotParsed`1(TypeInfo typeInfo, IEnumerable`1<Error> errors);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(NotParsed`1<T> other);
}
public class CommandLine.NoVerbSelectedError : Error {
}
public class CommandLine.NullInstance : object {
}
[AttributeUsageAttribute("128")]
public class CommandLine.OptionAttribute : BaseAttribute {
    private string longName;
    private string shortName;
    private string setName;
    private bool flagCounter;
    private char separator;
    private string group;
    public string LongName { get; }
    public string ShortName { get; }
    public string SetName { get; public set; }
    public bool FlagCounter { get; public set; }
    public char Separator { get; public set; }
    public string Group { get; public set; }
    private OptionAttribute(string shortName, string longName);
    public OptionAttribute(string longName);
    public OptionAttribute(char shortName, string longName);
    public OptionAttribute(char shortName);
    public string get_LongName();
    public string get_ShortName();
    public string get_SetName();
    public void set_SetName(string value);
    public bool get_FlagCounter();
    public void set_FlagCounter(bool value);
    public char get_Separator();
    public void set_Separator(char value);
    public string get_Group();
    public void set_Group(string value);
}
public class CommandLine.Parsed`1 : ParserResult`1<T> {
    internal Parsed`1(T value, TypeInfo typeInfo);
    internal Parsed`1(T value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Parsed`1<T> other);
}
public class CommandLine.Parser : object {
    private bool disposed;
    private ParserSettings settings;
    private static Lazy`1<Parser> DefaultParser;
    public static Parser Default { get; }
    public ParserSettings Settings { get; }
    public Parser(Action`1<ParserSettings> configuration);
    internal Parser(ParserSettings settings);
    private static Parser();
    protected virtual override void Finalize();
    public static Parser get_Default();
    public ParserSettings get_Settings();
    public ParserResult`1<T> ParseArguments(IEnumerable`1<string> args);
    public ParserResult`1<T> ParseArguments(Func`1<T> factory, IEnumerable`1<string> args);
    public ParserResult`1<object> ParseArguments(IEnumerable`1<string> args, Type[] types);
    public sealed virtual void Dispose();
    private static Result`2<IEnumerable`1<Token>, Error> Tokenize(IEnumerable`1<string> arguments, IEnumerable`1<OptionSpecification> optionSpecs, ParserSettings settings);
    private static ParserResult`1<T> MakeParserResult(ParserResult`1<T> parserResult, ParserSettings settings);
    private static ParserResult`1<T> DisplayHelp(ParserResult`1<T> parserResult, TextWriter helpWriter, int maxDisplayWidth);
    private static IEnumerable`1<ErrorType> HandleUnknownArguments(bool ignoreUnknownArguments);
    private void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private Result`2<IEnumerable`1<Token>, Error> <ParseArguments>b__11_0(IEnumerable`1<string> arguments, IEnumerable`1<OptionSpecification> optionSpecs);
    [CompilerGeneratedAttribute]
private Result`2<IEnumerable`1<Token>, Error> <ParseArguments>b__12_0(IEnumerable`1<string> arguments, IEnumerable`1<OptionSpecification> optionSpecs);
    [CompilerGeneratedAttribute]
private Result`2<IEnumerable`1<Token>, Error> <ParseArguments>b__13_0(IEnumerable`1<string> arguments, IEnumerable`1<OptionSpecification> optionSpecs);
}
[ExtensionAttribute]
public static class CommandLine.ParserExtensions : object {
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
}
public abstract class CommandLine.ParserResult`1 : object {
    private ParserResultType tag;
    private TypeInfo typeInfo;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Error> <Errors>k__BackingField;
    public ParserResultType Tag { get; }
    public TypeInfo TypeInfo { get; }
    public T Value { get; }
    public IEnumerable`1<Error> Errors { get; }
    internal ParserResult`1(IEnumerable`1<Error> errors, TypeInfo typeInfo);
    internal ParserResult`1(T value, TypeInfo typeInfo);
    public ParserResultType get_Tag();
    public TypeInfo get_TypeInfo();
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Error> get_Errors();
}
[ExtensionAttribute]
public static class CommandLine.ParserResultExtensions : object {
    [ExtensionAttribute]
public static ParserResult`1<T> WithParsed(ParserResult`1<T> result, Action`1<T> action);
    [ExtensionAttribute]
public static ParserResult`1<object> WithParsed(ParserResult`1<object> result, Action`1<T> action);
    [ExtensionAttribute]
public static ParserResult`1<T> WithNotParsed(ParserResult`1<T> result, Action`1<IEnumerable`1<Error>> action);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<TSource> result, Func`2<TSource, TResult> parsedFunc, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<T8, TResult> parsedFunc8, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<T8, TResult> parsedFunc8, Func`2<T9, TResult> parsedFunc9, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<T8, TResult> parsedFunc8, Func`2<T9, TResult> parsedFunc9, Func`2<T10, TResult> parsedFunc10, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<T8, TResult> parsedFunc8, Func`2<T9, TResult> parsedFunc9, Func`2<T10, TResult> parsedFunc10, Func`2<T11, TResult> parsedFunc11, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<T8, TResult> parsedFunc8, Func`2<T9, TResult> parsedFunc9, Func`2<T10, TResult> parsedFunc10, Func`2<T11, TResult> parsedFunc11, Func`2<T12, TResult> parsedFunc12, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<T8, TResult> parsedFunc8, Func`2<T9, TResult> parsedFunc9, Func`2<T10, TResult> parsedFunc10, Func`2<T11, TResult> parsedFunc11, Func`2<T12, TResult> parsedFunc12, Func`2<T13, TResult> parsedFunc13, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<T8, TResult> parsedFunc8, Func`2<T9, TResult> parsedFunc9, Func`2<T10, TResult> parsedFunc10, Func`2<T11, TResult> parsedFunc11, Func`2<T12, TResult> parsedFunc12, Func`2<T13, TResult> parsedFunc13, Func`2<T14, TResult> parsedFunc14, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<T8, TResult> parsedFunc8, Func`2<T9, TResult> parsedFunc9, Func`2<T10, TResult> parsedFunc10, Func`2<T11, TResult> parsedFunc11, Func`2<T12, TResult> parsedFunc12, Func`2<T13, TResult> parsedFunc13, Func`2<T14, TResult> parsedFunc14, Func`2<T15, TResult> parsedFunc15, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<T8, TResult> parsedFunc8, Func`2<T9, TResult> parsedFunc9, Func`2<T10, TResult> parsedFunc10, Func`2<T11, TResult> parsedFunc11, Func`2<T12, TResult> parsedFunc12, Func`2<T13, TResult> parsedFunc13, Func`2<T14, TResult> parsedFunc14, Func`2<T15, TResult> parsedFunc15, Func`2<T16, TResult> parsedFunc16, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
}
public enum CommandLine.ParserResultType : Enum {
    public int value__;
    public static ParserResultType Parsed;
    public static ParserResultType NotParsed;
}
public class CommandLine.ParserSettings : object {
    private static int DefaultMaximumLength;
    private bool disposed;
    private bool caseSensitive;
    private bool caseInsensitiveEnumValues;
    private TextWriter helpWriter;
    private bool ignoreUnknownArguments;
    private bool autoHelp;
    private bool autoVersion;
    private CultureInfo parsingCulture;
    private Maybe`1<bool> enableDashDash;
    private int maximumDisplayWidth;
    private Maybe`1<bool> allowMultiInstance;
    private bool getoptMode;
    private Maybe`1<bool> posixlyCorrect;
    [CompilerGeneratedAttribute]
private bool <Consumed>k__BackingField;
    public bool CaseSensitive { get; public set; }
    public bool CaseInsensitiveEnumValues { get; public set; }
    public CultureInfo ParsingCulture { get; public set; }
    public TextWriter HelpWriter { get; public set; }
    public bool IgnoreUnknownArguments { get; public set; }
    public bool AutoHelp { get; public set; }
    public bool AutoVersion { get; public set; }
    public bool EnableDashDash { get; public set; }
    public int MaximumDisplayWidth { get; public set; }
    public bool AllowMultiInstance { get; public set; }
    public bool GetoptMode { get; public set; }
    public bool PosixlyCorrect { get; public set; }
    internal StringComparer NameComparer { get; }
    internal bool Consumed { get; internal set; }
    private int GetWindowWidth();
    protected virtual override void Finalize();
    public bool get_CaseSensitive();
    public void set_CaseSensitive(bool value);
    public bool get_CaseInsensitiveEnumValues();
    public void set_CaseInsensitiveEnumValues(bool value);
    public CultureInfo get_ParsingCulture();
    public void set_ParsingCulture(CultureInfo value);
    public TextWriter get_HelpWriter();
    public void set_HelpWriter(TextWriter value);
    public bool get_IgnoreUnknownArguments();
    public void set_IgnoreUnknownArguments(bool value);
    public bool get_AutoHelp();
    public void set_AutoHelp(bool value);
    public bool get_AutoVersion();
    public void set_AutoVersion(bool value);
    public bool get_EnableDashDash();
    public void set_EnableDashDash(bool value);
    public int get_MaximumDisplayWidth();
    public void set_MaximumDisplayWidth(int value);
    public bool get_AllowMultiInstance();
    public void set_AllowMultiInstance(bool value);
    public bool get_GetoptMode();
    public void set_GetoptMode(bool value);
    public bool get_PosixlyCorrect();
    public void set_PosixlyCorrect(bool value);
    internal StringComparer get_NameComparer();
    [CompilerGeneratedAttribute]
internal bool get_Consumed();
    [CompilerGeneratedAttribute]
internal void set_Consumed(bool value);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
public class CommandLine.RepeatedOptionError : NamedError {
    internal RepeatedOptionError(NameInfo nameInfo);
}
public class CommandLine.SequenceOutOfRangeError : NamedError {
    internal SequenceOutOfRangeError(NameInfo nameInfo);
}
public class CommandLine.SetValueExceptionError : NamedError {
    private Exception exception;
    private object value;
    public Exception Exception { get; }
    public object Value { get; }
    internal SetValueExceptionError(NameInfo nameInfo, Exception exception, object value);
    public Exception get_Exception();
    public object get_Value();
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("False")]
public class CommandLine.Text.AssemblyLicenseAttribute : MultilineTextAttribute {
    public AssemblyLicenseAttribute(string line1);
    public AssemblyLicenseAttribute(string line1, string line2);
    public AssemblyLicenseAttribute(string line1, string line2, string line3);
    public AssemblyLicenseAttribute(string line1, string line2, string line3, string line4);
    public AssemblyLicenseAttribute(string line1, string line2, string line3, string line4, string line5);
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("False")]
public class CommandLine.Text.AssemblyUsageAttribute : MultilineTextAttribute {
    public AssemblyUsageAttribute(string line1);
    public AssemblyUsageAttribute(string line1, string line2);
    public AssemblyUsageAttribute(string line1, string line2, string line3);
    public AssemblyUsageAttribute(string line1, string line2, string line3, string line4);
    public AssemblyUsageAttribute(string line1, string line2, string line3, string line4, string line5);
}
public class CommandLine.Text.ComparableOption : ValueType {
    public bool Required;
    public bool IsOption;
    public bool IsValue;
    public string LongName;
    public string ShortName;
    public int Index;
}
public class CommandLine.Text.CopyrightInfo : object {
    private static string DefaultCopyrightWord;
    private static string SymbolLower;
    private static string SymbolUpper;
    private AssemblyCopyrightAttribute attribute;
    private bool isSymbolUpper;
    private Int32[] copyrightYears;
    private string author;
    private int builderSize;
    public static CopyrightInfo Empty { get; }
    public static CopyrightInfo Default { get; }
    protected string CopyrightWord { get; }
    public CopyrightInfo(string author, int year);
    public CopyrightInfo(string author, Int32[] years);
    public CopyrightInfo(bool isSymbolUpper, string author, Int32[] copyrightYears);
    private CopyrightInfo(AssemblyCopyrightAttribute attribute);
    public static CopyrightInfo get_Empty();
    public static CopyrightInfo get_Default();
    protected virtual string get_CopyrightWord();
    public static string op_Implicit(CopyrightInfo info);
    public virtual string ToString();
    protected virtual string FormatYears(Int32[] years);
}
public class CommandLine.Text.Example : object {
    private string helpText;
    private IEnumerable`1<UnParserSettings> formatStyles;
    private object sample;
    public string HelpText { get; }
    public IEnumerable`1<UnParserSettings> FormatStyles { get; }
    public object Sample { get; }
    public Example(string helpText, IEnumerable`1<UnParserSettings> formatStyles, object sample);
    public Example(string helpText, UnParserSettings formatStyle, object sample);
    public Example(string helpText, object sample);
    public string get_HelpText();
    public IEnumerable`1<UnParserSettings> get_FormatStyles();
    public object get_Sample();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Example other);
}
[ExtensionAttribute]
internal static class CommandLine.Text.ExampleExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<UnParserSettings> GetFormatStylesOrDefault(Example example);
}
public class CommandLine.Text.HeadingInfo : object {
    private string programName;
    private string version;
    public static HeadingInfo Empty { get; }
    public static HeadingInfo Default { get; }
    public HeadingInfo(string programName, string version);
    public static HeadingInfo get_Empty();
    public static HeadingInfo get_Default();
    public static string op_Implicit(HeadingInfo info);
    public virtual string ToString();
    public void WriteMessage(string message, TextWriter writer);
    public void WriteMessage(string message);
    public void WriteError(string message);
}
public class CommandLine.Text.HelpText : object {
    [CompilerGeneratedAttribute]
private Comparison`1<ComparableOption> <OptionComparison>k__BackingField;
    public static Comparison`1<ComparableOption> RequiredThenAlphaComparison;
    private static int BuilderCapacity;
    private static int DefaultMaximumLength;
    private static int OptionToHelpTextSeparatorWidth;
    private static int OptionPrefixWidth;
    private static int TotalOptionPadding;
    private StringBuilder preOptionsHelp;
    private StringBuilder postOptionsHelp;
    private SentenceBuilder sentenceBuilder;
    private int maximumDisplayWidth;
    private string heading;
    private string copyright;
    private bool additionalNewLineAfterOption;
    private StringBuilder optionsHelp;
    private bool addDashesToOption;
    private bool addEnumValuesToHelpText;
    private bool autoHelp;
    private bool autoVersion;
    private bool addNewLineBetweenHelpSections;
    public Comparison`1<ComparableOption> OptionComparison { get; public set; }
    public string Heading { get; public set; }
    public string Copyright { get; public set; }
    public int MaximumDisplayWidth { get; public set; }
    public bool AddDashesToOption { get; public set; }
    public bool AdditionalNewLineAfterOption { get; public set; }
    public bool AddNewLineBetweenHelpSections { get; public set; }
    public bool AddEnumValuesToHelpText { get; public set; }
    public bool AutoHelp { get; public set; }
    public bool AutoVersion { get; public set; }
    public SentenceBuilder SentenceBuilder { get; }
    public HelpText(SentenceBuilder sentenceBuilder);
    public HelpText(string heading);
    public HelpText(SentenceBuilder sentenceBuilder, string heading);
    public HelpText(string heading, string copyright);
    public HelpText(SentenceBuilder sentenceBuilder, string heading, string copyright);
    private static HelpText();
    private ComparableOption ToComparableOption(Specification spec, int index);
    [CompilerGeneratedAttribute]
public Comparison`1<ComparableOption> get_OptionComparison();
    [CompilerGeneratedAttribute]
public void set_OptionComparison(Comparison`1<ComparableOption> value);
    public string get_Heading();
    public void set_Heading(string value);
    public string get_Copyright();
    public void set_Copyright(string value);
    public int get_MaximumDisplayWidth();
    public void set_MaximumDisplayWidth(int value);
    public bool get_AddDashesToOption();
    public void set_AddDashesToOption(bool value);
    public bool get_AdditionalNewLineAfterOption();
    public void set_AdditionalNewLineAfterOption(bool value);
    public bool get_AddNewLineBetweenHelpSections();
    public void set_AddNewLineBetweenHelpSections(bool value);
    public bool get_AddEnumValuesToHelpText();
    public void set_AddEnumValuesToHelpText(bool value);
    public bool get_AutoHelp();
    public void set_AutoHelp(bool value);
    public bool get_AutoVersion();
    public void set_AutoVersion(bool value);
    public SentenceBuilder get_SentenceBuilder();
    public static HelpText AutoBuild(ParserResult`1<T> parserResult, Func`2<HelpText, HelpText> onError, Func`2<Example, Example> onExample, bool verbsIndex, int maxDisplayWidth);
    public static HelpText AutoBuild(ParserResult`1<T> parserResult, int maxDisplayWidth);
    public static HelpText AutoBuild(ParserResult`1<T> parserResult, Func`2<HelpText, HelpText> onError, int maxDisplayWidth);
    public static HelpText DefaultParsingErrorsHandler(ParserResult`1<T> parserResult, HelpText current);
    public static string op_Implicit(HelpText info);
    public HelpText AddPreOptionsLine(string value);
    public HelpText AddPostOptionsLine(string value);
    public HelpText AddPreOptionsLines(IEnumerable`1<string> lines);
    public HelpText AddPostOptionsLines(IEnumerable`1<string> lines);
    public HelpText AddPreOptionsText(string text);
    public HelpText AddPostOptionsText(string text);
    public HelpText AddOptions(ParserResult`1<T> result);
    public HelpText AddVerbs(Type[] types);
    public HelpText AddOptions(int maximumLength, ParserResult`1<T> result);
    public HelpText AddVerbs(int maximumLength, Type[] types);
    public static string RenderParsingErrorsText(ParserResult`1<T> parserResult, Func`2<Error, string> formatError, Func`2<IEnumerable`1<MutuallyExclusiveSetError>, string> formatMutuallyExclusiveSetErrors, int indent);
    public static IEnumerable`1<string> RenderParsingErrorsTextAsLines(ParserResult`1<T> parserResult, Func`2<Error, string> formatError, Func`2<IEnumerable`1<MutuallyExclusiveSetError>, string> formatMutuallyExclusiveSetErrors, int indent);
    public static string RenderUsageText(ParserResult`1<T> parserResult);
    public static string RenderUsageText(ParserResult`1<T> parserResult, Func`2<Example, Example> mapperFunc);
    public static IEnumerable`1<string> RenderUsageTextAsLines(ParserResult`1<T> parserResult, Func`2<Example, Example> mapperFunc);
    public virtual string ToString();
    internal static void AddLine(StringBuilder builder, string value, int maximumLength);
    private IEnumerable`1<Specification> GetSpecificationsFromType(Type type);
    private static Maybe`1<Tuple`2<UsageAttribute, IEnumerable`1<Example>>> GetUsageFromType(Type type);
    private IEnumerable`1<Specification> AdaptVerbsToSpecifications(IEnumerable`1<Type> types);
    private HelpText AddOptionsImpl(IEnumerable`1<Specification> specifications, string requiredWord, string optionGroupWord, int maximumLength);
    private OptionSpecification MakeHelpEntry();
    private OptionSpecification MakeVersionEntry();
    private HelpText AddPreOptionsLine(string value, int maximumLength);
    private HelpText AddOption(string requiredWord, string optionGroupWord, int maxLength, Specification specification, int widthOfHelpText);
    private string AddOptionName(int maxLength, OptionSpecification specification);
    private string AddValueName(int maxLength, ValueSpecification specification);
    private HelpText AddLine(StringBuilder builder, string value);
    private int GetMaxLength(IEnumerable`1<Specification> specifications);
    private int GetMaxOptionLength(OptionSpecification spec);
    private int GetMaxValueLength(ValueSpecification spec);
    private static string FormatDefaultValue(T value);
    [CompilerGeneratedAttribute]
private void <AddPreOptionsLines>b__66_0(string line);
    [CompilerGeneratedAttribute]
private void <AddPostOptionsLines>b__67_0(string line);
    [CompilerGeneratedAttribute]
private void <AddPreOptionsText>b__68_0(string line);
    [CompilerGeneratedAttribute]
private void <AddPostOptionsText>b__69_0(string line);
    [CompilerGeneratedAttribute]
private string <ToString>g__NewLineIfNeededBefore|79_0(StringBuilder sb, <>c__DisplayClass79_0& );
    [CompilerGeneratedAttribute]
private int <GetMaxLength>b__92_0(int length, Specification spec);
}
public abstract class CommandLine.Text.MultilineTextAttribute : Attribute {
    private string line1;
    private string line2;
    private string line3;
    private string line4;
    private string line5;
    public string Value { get; }
    public string Line1 { get; }
    public string Line2 { get; }
    public string Line3 { get; }
    public string Line4 { get; }
    public string Line5 { get; }
    protected MultilineTextAttribute(string line1);
    protected MultilineTextAttribute(string line1, string line2);
    protected MultilineTextAttribute(string line1, string line2, string line3);
    protected MultilineTextAttribute(string line1, string line2, string line3, string line4);
    protected MultilineTextAttribute(string line1, string line2, string line3, string line4, string line5);
    public virtual string get_Value();
    public string get_Line1();
    public string get_Line2();
    public string get_Line3();
    public string get_Line4();
    public string get_Line5();
    internal HelpText AddToHelpText(HelpText helpText, Func`2<string, HelpText> func);
    internal HelpText AddToHelpText(HelpText helpText, bool before);
    protected virtual int GetLastLineWithText(String[] value);
}
public abstract class CommandLine.Text.SentenceBuilder : object {
    [CompilerGeneratedAttribute]
private static Func`1<SentenceBuilder> <Factory>k__BackingField;
    public static Func`1<SentenceBuilder> Factory { get; public set; }
    public Func`1<string> RequiredWord { get; }
    public Func`1<string> OptionGroupWord { get; }
    public Func`1<string> ErrorsHeadingText { get; }
    public Func`1<string> UsageHeadingText { get; }
    public Func`2<bool, string> HelpCommandText { get; }
    public Func`2<bool, string> VersionCommandText { get; }
    public Func`2<Error, string> FormatError { get; }
    public Func`2<IEnumerable`1<MutuallyExclusiveSetError>, string> FormatMutuallyExclusiveSetErrors { get; }
    private static SentenceBuilder();
    public static SentenceBuilder Create();
    [CompilerGeneratedAttribute]
public static Func`1<SentenceBuilder> get_Factory();
    [CompilerGeneratedAttribute]
public static void set_Factory(Func`1<SentenceBuilder> value);
    public abstract virtual Func`1<string> get_RequiredWord();
    public abstract virtual Func`1<string> get_OptionGroupWord();
    public abstract virtual Func`1<string> get_ErrorsHeadingText();
    public abstract virtual Func`1<string> get_UsageHeadingText();
    public abstract virtual Func`2<bool, string> get_HelpCommandText();
    public abstract virtual Func`2<bool, string> get_VersionCommandText();
    public abstract virtual Func`2<Error, string> get_FormatError();
    public abstract virtual Func`2<IEnumerable`1<MutuallyExclusiveSetError>, string> get_FormatMutuallyExclusiveSetErrors();
}
public class CommandLine.Text.TextWrapper : object {
    private String[] lines;
    public TextWrapper(string input);
    public TextWrapper WordWrap(int columnWidth);
    public TextWrapper Indent(int numberOfSpaces);
    public string ToText();
    public static string WrapAndIndentText(string input, int indentLevel, int columnWidth);
    private String[] WordWrapLine(string line, int columnWidth);
    private static List`1<StringBuilder> AddWordToLastLineOrCreateNewLineIfNecessary(List`1<StringBuilder> lines, string word, int columnWidth);
    private static string RightString(string str, int n);
    private static string LeftString(string str, int n);
}
[AttributeUsageAttribute("128")]
public class CommandLine.Text.UsageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ApplicationAlias>k__BackingField;
    public string ApplicationAlias { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ApplicationAlias();
    [CompilerGeneratedAttribute]
public void set_ApplicationAlias(string value);
}
public abstract class CommandLine.TokenError : Error {
    private string token;
    public string Token { get; }
    protected internal TokenError(ErrorType tag, string token);
    public string get_Token();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(TokenError other);
}
public class CommandLine.TypeInfo : object {
    private Type current;
    private IEnumerable`1<Type> choices;
    public Type Current { get; }
    public IEnumerable`1<Type> Choices { get; }
    private TypeInfo(Type current, IEnumerable`1<Type> choices);
    public Type get_Current();
    public IEnumerable`1<Type> get_Choices();
    internal static TypeInfo Create(Type current);
    internal static TypeInfo Create(Type current, IEnumerable`1<Type> choices);
}
public class CommandLine.UnknownOptionError : TokenError {
    internal UnknownOptionError(string token);
}
[ExtensionAttribute]
public static class CommandLine.UnParserExtensions : object {
    [ExtensionAttribute]
public static string FormatCommandLine(Parser parser, T options);
    [ExtensionAttribute]
public static String[] FormatCommandLineArgs(Parser parser, T options);
    [ExtensionAttribute]
public static string FormatCommandLine(Parser parser, T options, Action`1<UnParserSettings> configuration);
    [ExtensionAttribute]
public static String[] FormatCommandLineArgs(Parser parser, T options, Action`1<UnParserSettings> configuration);
    private static string FormatValue(Specification spec, object value);
    private static object FormatWithQuotesIfString(object value);
    [ExtensionAttribute]
private static char SeperatorOrSpace(Specification spec);
    private static string FormatOption(OptionSpecification spec, object value, UnParserSettings settings);
    [ExtensionAttribute]
private static string FormatName(OptionSpecification optionSpec, object value, UnParserSettings settings);
    [ExtensionAttribute]
private static object NormalizeValue(object value);
    [ExtensionAttribute]
private static bool IsEmpty(object value, Specification specification, bool skipDefault);
    [ExtensionAttribute]
public static String[] SplitArgs(string command, bool keepQuote);
}
public class CommandLine.UnParserSettings : object {
    private bool preferShortName;
    private bool groupSwitches;
    private bool useEqualToken;
    private bool showHidden;
    private bool skipDefault;
    [CompilerGeneratedAttribute]
private bool <Consumed>k__BackingField;
    public bool PreferShortName { get; public set; }
    public bool GroupSwitches { get; public set; }
    public bool UseEqualToken { get; public set; }
    public bool ShowHidden { get; public set; }
    public bool SkipDefault { get; public set; }
    internal bool Consumed { get; internal set; }
    public bool get_PreferShortName();
    public void set_PreferShortName(bool value);
    public bool get_GroupSwitches();
    public void set_GroupSwitches(bool value);
    public bool get_UseEqualToken();
    public void set_UseEqualToken(bool value);
    public bool get_ShowHidden();
    public void set_ShowHidden(bool value);
    public bool get_SkipDefault();
    public void set_SkipDefault(bool value);
    public static UnParserSettings WithGroupSwitchesOnly();
    public static UnParserSettings WithUseEqualTokenOnly();
    [CompilerGeneratedAttribute]
internal bool get_Consumed();
    [CompilerGeneratedAttribute]
internal void set_Consumed(bool value);
}
[AttributeUsageAttribute("128")]
public class CommandLine.ValueAttribute : BaseAttribute {
    private int index;
    private string metaName;
    public int Index { get; }
    public string MetaName { get; public set; }
    public ValueAttribute(int index);
    public int get_Index();
    public string get_MetaName();
    public void set_MetaName(string value);
}
[AttributeUsageAttribute("12")]
public class CommandLine.VerbAttribute : Attribute {
    private LocalizableAttributeProperty helpText;
    private Type resourceType;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Hidden>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Aliases>k__BackingField;
    public string Name { get; private set; }
    public bool Hidden { get; public set; }
    public string HelpText { get; public set; }
    public Type ResourceType { get; public set; }
    public bool IsDefault { get; private set; }
    public String[] Aliases { get; private set; }
    public VerbAttribute(string name, bool isDefault, String[] aliases);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Hidden();
    [CompilerGeneratedAttribute]
public void set_Hidden(bool value);
    public string get_HelpText();
    public void set_HelpText(string value);
    public Type get_ResourceType();
    public void set_ResourceType(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsDefault();
    [CompilerGeneratedAttribute]
private void set_IsDefault(bool value);
    [CompilerGeneratedAttribute]
public String[] get_Aliases();
    [CompilerGeneratedAttribute]
private void set_Aliases(String[] value);
}
public class CommandLine.VersionRequestedError : Error {
}
[ExtensionAttribute]
internal static class CSharpx.Either : object {
    public static Either`2<TLeft, TRight> Left(TLeft value);
    public static Either`2<TLeft, TRight> Right(TRight value);
    public static Either`2<string, TRight> Return(TRight value);
    public static Either`2<string, TRight> Fail(string message);
    public static Either`2<TLeft, TResult> Bind(Either`2<TLeft, TRight> either, Func`2<TRight, Either`2<TLeft, TResult>> func);
    public static Either`2<TLeft, TResult> Map(Either`2<TLeft, TRight> either, Func`2<TRight, TResult> func);
    public static Either`2<TLeft1, TRight1> Bimap(Either`2<TLeft, TRight> either, Func`2<TLeft, TLeft1> mapLeft, Func`2<TRight, TRight1> mapRight);
    [ExtensionAttribute]
public static Either`2<TLeft, TResult> Select(Either`2<TLeft, TRight> either, Func`2<TRight, TResult> selector);
    [ExtensionAttribute]
public static Either`2<TLeft, TResult> SelectMany(Either`2<TLeft, TRight> result, Func`2<TRight, Either`2<TLeft, TResult>> func);
    public static TRight GetOrFail(Either`2<TLeft, TRight> either);
    public static TLeft GetLeftOrDefault(Either`2<TLeft, TRight> either, TLeft default);
    public static TRight GetRightOrDefault(Either`2<TLeft, TRight> either, TRight default);
    public static Either`2<Exception, TRight> Try(Func`1<TRight> func);
    public static Either`2<Exception, TRight> Cast(object obj);
    public static Either`2<TLeft, TRight> FromMaybe(Maybe`1<TRight> maybe, TLeft left);
    [ExtensionAttribute]
private static TLeft GetLeft(Either`2<TLeft, TRight> either);
}
internal abstract class CSharpx.Either`2 : object {
    private EitherType tag;
    public EitherType Tag { get; }
    protected Either`2(EitherType tag);
    public EitherType get_Tag();
    public bool MatchLeft(TLeft& value);
    public bool MatchRight(TRight& value);
}
[ExtensionAttribute]
internal static class CSharpx.EitherExtensions : object {
    [ExtensionAttribute]
public static void Match(Either`2<TLeft, TRight> either, Action`1<TLeft> ifLeft, Action`1<TRight> ifRight);
    [ExtensionAttribute]
public static Either`2<string, TRight> ToEither(TRight value);
    [ExtensionAttribute]
public static Either`2<TLeft, TResult> Bind(Either`2<TLeft, TRight> either, Func`2<TRight, Either`2<TLeft, TResult>> func);
    [ExtensionAttribute]
public static Either`2<TLeft, TResult> Map(Either`2<TLeft, TRight> either, Func`2<TRight, TResult> func);
    [ExtensionAttribute]
public static Either`2<TLeft1, TRight1> Bimap(Either`2<TLeft, TRight> either, Func`2<TLeft, TLeft1> mapLeft, Func`2<TRight, TRight1> mapRight);
    [ExtensionAttribute]
public static bool IsLeft(Either`2<TLeft, TRight> either);
    [ExtensionAttribute]
public static bool IsRight(Either`2<TLeft, TRight> either);
}
internal enum CSharpx.EitherType : Enum {
    public int value__;
    public static EitherType Left;
    public static EitherType Right;
}
[ExtensionAttribute]
internal static class CSharpx.EnumerableExtensions : object {
    private static Func`3<int, int, Exception> OnFolderSourceSizeErrorSelector;
    private static EnumerableExtensions();
    [ExtensionAttribute]
public static Maybe`1<T> TryHead(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static Maybe`1<IEnumerable`1<T>> ToMaybe(IEnumerable`1<T> source);
    private static IEnumerable`1<TSource> AssertCountImpl(IEnumerable`1<TSource> source, int count, Func`3<int, int, Exception> errorSelector);
    private static IEnumerable`1<TSource> ExpectingCountYieldingImpl(IEnumerable`1<TSource> source, int count, Func`3<int, int, Exception> errorSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Cartesian(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Prepend(IEnumerable`1<TSource> source, TSource value);
    [ExtensionAttribute]
public static IEnumerable`1<T> Concat(T head, IEnumerable`1<T> tail);
    [ExtensionAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> head, T tail);
    [ExtensionAttribute]
public static IEnumerable`1<T> Exclude(IEnumerable`1<T> sequence, int startIndex, int count);
    private static IEnumerable`1<T> ExcludeImpl(IEnumerable`1<T> sequence, int startIndex, int count);
    [ExtensionAttribute]
public static IEnumerable`1<KeyValuePair`2<int, TSource>> Index(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IEnumerable`1<KeyValuePair`2<int, TSource>> Index(IEnumerable`1<TSource> source, int startIndex);
    [ExtensionAttribute]
public static TResult Fold(IEnumerable`1<T> source, Func`2<T, TResult> folder);
    [ExtensionAttribute]
public static TResult Fold(IEnumerable`1<T> source, Func`3<T, T, TResult> folder);
    [ExtensionAttribute]
public static TResult Fold(IEnumerable`1<T> source, Func`4<T, T, T, TResult> folder);
    [ExtensionAttribute]
public static TResult Fold(IEnumerable`1<T> source, Func`5<T, T, T, T, TResult> folder);
    private static TResult FoldImpl(IEnumerable`1<T> source, int count, Func`2<T, TResult> folder1, Func`3<T, T, TResult> folder2, Func`4<T, T, T, TResult> folder3, Func`5<T, T, T, T, TResult> folder4);
    private static Exception OnFolderSourceSizeError(int cmp, int count);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> source, Action`1<T> action);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Pairwise(IEnumerable`1<TSource> source, Func`3<TSource, TSource, TResult> resultSelector);
    [ExtensionAttribute]
private static IEnumerable`1<TResult> PairwiseImpl(IEnumerable`1<TSource> source, Func`3<TSource, TSource, TResult> resultSelector);
    [ExtensionAttribute]
public static string ToDelimitedString(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static string ToDelimitedString(IEnumerable`1<TSource> source, string delimiter);
    private static string ToDelimitedStringImpl(IEnumerable`1<T> source, string delimiter, Func`3<StringBuilder, T, StringBuilder> append);
    [ExtensionAttribute]
public static IEnumerable`1<T> Tail(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> TailNoFail(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Memoize(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Materialize(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T Choice(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Intersperse(IEnumerable`1<T> source, T element);
    [ExtensionAttribute]
public static IEnumerable`1<T> FlattenOnce(IEnumerable`1<IEnumerable`1<T>> source);
    [ExtensionAttribute]
public static IEnumerable`1<string> FlattenOnce(IEnumerable`1<string> source);
}
internal class CSharpx.Just`1 : Maybe`1<T> {
    private T value;
    public T Value { get; }
    internal Just`1(T value);
    public T get_Value();
}
internal class CSharpx.Left`2 : Either`2<TLeft, TRight> {
    private TLeft value;
    public TLeft Value { get; }
    internal Left`2(TLeft value);
    public TLeft get_Value();
}
internal static class CSharpx.Maybe : object {
    public static Maybe`1<T> Nothing();
    public static Just`1<T> Just(T value);
    public static Maybe`1<T> Return(T value);
    public static Maybe`1<T2> Bind(Maybe`1<T1> maybe, Func`2<T1, Maybe`1<T2>> func);
    public static Maybe`1<T2> Map(Maybe`1<T1> maybe, Func`2<T1, T2> func);
    public static Maybe`1<Tuple`2<T1, T2>> Merge(Maybe`1<T1> first, Maybe`1<T2> second);
}
internal abstract class CSharpx.Maybe`1 : object {
    private MaybeType tag;
    public MaybeType Tag { get; }
    protected Maybe`1(MaybeType tag);
    public MaybeType get_Tag();
    public bool MatchJust(T& value);
    public bool MatchNothing();
}
[ExtensionAttribute]
internal static class CSharpx.MaybeExtensions : object {
    [ExtensionAttribute]
public static void Match(Maybe`1<T> maybe, Action`1<T> ifJust, Action ifNothing);
    [ExtensionAttribute]
public static void Match(Maybe`1<Tuple`2<T1, T2>> maybe, Action`2<T1, T2> ifJust, Action ifNothing);
    [ExtensionAttribute]
public static bool MatchJust(Maybe`1<Tuple`2<T1, T2>> maybe, T1& value1, T2& value2);
    [ExtensionAttribute]
public static Maybe`1<T> ToMaybe(T value);
    [ExtensionAttribute]
public static Maybe`1<T2> Bind(Maybe`1<T1> maybe, Func`2<T1, Maybe`1<T2>> func);
    [ExtensionAttribute]
public static Maybe`1<T2> Map(Maybe`1<T1> maybe, Func`2<T1, T2> func);
    [ExtensionAttribute]
public static Maybe`1<TResult> Select(Maybe`1<TSource> maybe, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static Maybe`1<TResult> SelectMany(Maybe`1<TSource> maybe, Func`2<TSource, Maybe`1<TValue>> valueSelector, Func`3<TSource, TValue, TResult> resultSelector);
    [ExtensionAttribute]
public static void Do(Maybe`1<T> maybe, Action`1<T> action);
    [ExtensionAttribute]
public static void Do(Maybe`1<Tuple`2<T1, T2>> maybe, Action`2<T1, T2> action);
    [ExtensionAttribute]
public static bool IsJust(Maybe`1<T> maybe);
    [ExtensionAttribute]
public static bool IsNothing(Maybe`1<T> maybe);
    [ExtensionAttribute]
public static T FromJust(Maybe`1<T> maybe);
    [ExtensionAttribute]
public static T FromJustOrFail(Maybe`1<T> maybe, Exception exceptionToThrow);
    [ExtensionAttribute]
public static T GetValueOrDefault(Maybe`1<T> maybe, T noneValue);
    [ExtensionAttribute]
public static T2 MapValueOrDefault(Maybe`1<T1> maybe, Func`2<T1, T2> func, T2 noneValue);
    [ExtensionAttribute]
public static T2 MapValueOrDefault(Maybe`1<T1> maybe, Func`2<T1, T2> func, Func`1<T2> noneValueFactory);
    [ExtensionAttribute]
public static IEnumerable`1<T> ToEnumerable(Maybe`1<T> maybe);
}
internal enum CSharpx.MaybeType : Enum {
    public int value__;
    public static MaybeType Just;
    public static MaybeType Nothing;
}
internal class CSharpx.Nothing`1 : Maybe`1<T> {
}
internal class CSharpx.Right`2 : Either`2<TLeft, TRight> {
    private TRight value;
    public TRight Value { get; }
    internal Right`2(TRight value);
    public TRight get_Value();
}
internal class RailwaySharp.ErrorHandling.Bad`2 : Result`2<TSuccess, TMessage> {
    private IEnumerable`1<TMessage> _messages;
    public IEnumerable`1<TMessage> Messages { get; }
    public Bad`2(IEnumerable`1<TMessage> messages);
    public IEnumerable`1<TMessage> get_Messages();
}
internal class RailwaySharp.ErrorHandling.Ok`2 : Result`2<TSuccess, TMessage> {
    private Tuple`2<TSuccess, IEnumerable`1<TMessage>> _value;
    public TSuccess Success { get; }
    public IEnumerable`1<TMessage> Messages { get; }
    public Ok`2(TSuccess success, IEnumerable`1<TMessage> messages);
    public TSuccess get_Success();
    public IEnumerable`1<TMessage> get_Messages();
}
internal static class RailwaySharp.ErrorHandling.Result : object {
    public static Result`2<TSuccess, TMessage> FailWith(IEnumerable`1<TMessage> messages);
    public static Result`2<TSuccess, TMessage> FailWith(TMessage message);
    public static Result`2<TSuccess, TMessage> Succeed(TSuccess value);
    public static Result`2<TSuccess, TMessage> Succeed(TSuccess value, TMessage message);
    public static Result`2<TSuccess, TMessage> Succeed(TSuccess value, IEnumerable`1<TMessage> messages);
    public static Result`2<TSuccess, Exception> Try(Func`1<TSuccess> func);
}
internal abstract class RailwaySharp.ErrorHandling.Result`2 : object {
    private ResultType _tag;
    public ResultType Tag { get; }
    protected Result`2(ResultType tag);
    public ResultType get_Tag();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class RailwaySharp.ErrorHandling.ResultExtensions : object {
    [ExtensionAttribute]
public static void Match(Result`2<TSuccess, TMessage> result, Action`2<TSuccess, IEnumerable`1<TMessage>> ifSuccess, Action`1<IEnumerable`1<TMessage>> ifFailure);
    [ExtensionAttribute]
public static TResult Either(Result`2<TSuccess, TMessage> result, Func`3<TSuccess, IEnumerable`1<TMessage>, TResult> ifSuccess, Func`2<IEnumerable`1<TMessage>, TResult> ifFailure);
    [ExtensionAttribute]
public static Result`2<TResult, TMessage> Map(Result`2<TSuccess, TMessage> result, Func`2<TSuccess, TResult> func);
    [ExtensionAttribute]
public static Result`2<IEnumerable`1<TSuccess>, TMessage> Collect(IEnumerable`1<Result`2<TSuccess, TMessage>> values);
    [ExtensionAttribute]
public static Result`2<IEnumerable`1<TSuccess>, TMessage> Flatten(Result`2<IEnumerable`1<Result`2<TSuccess, TMessage>>, TMessage> result);
    [ExtensionAttribute]
public static Result`2<TResult, TMessage> SelectMany(Result`2<TSuccess, TMessage> result, Func`2<TSuccess, Result`2<TResult, TMessage>> func);
    [ExtensionAttribute]
public static Result`2<TResult, TMessage> SelectMany(Result`2<TSuccess, TMessage> result, Func`2<TSuccess, Result`2<TValue, TMessage>> func, Func`3<TSuccess, TValue, TResult> mapperFunc);
    [ExtensionAttribute]
public static Result`2<TResult, TMessage> Select(Result`2<TSuccess, TMessage> result, Func`2<TSuccess, TResult> func);
    [ExtensionAttribute]
public static IEnumerable`1<TMessage> FailedWith(Result`2<TSuccess, TMessage> result);
    [ExtensionAttribute]
public static TSuccess SucceededWith(Result`2<TSuccess, TMessage> result);
    [ExtensionAttribute]
public static IEnumerable`1<TMessage> SuccessMessages(Result`2<TSuccess, TMessage> result);
    [ExtensionAttribute]
public static Maybe`1<TSuccess> ToMaybe(Result`2<TSuccess, TMessage> result);
}
internal enum RailwaySharp.ErrorHandling.ResultType : Enum {
    public int value__;
    public static ResultType Ok;
    public static ResultType Bad;
}
internal static class RailwaySharp.ErrorHandling.Trial : object {
    public static Result`2<TSuccess, TMessage> Ok(TSuccess value);
    public static Result`2<TSuccess, TMessage> Pass(TSuccess value);
    public static Result`2<TSuccess, TMessage> Warn(TMessage message, TSuccess value);
    public static Result`2<TSuccess, TMessage> Fail(TMessage message);
    public static bool Failed(Result`2<TSuccess, TMessage> result);
    public static TResult Either(Func`3<TSuccess, IEnumerable`1<TMessage>, TResult> successFunc, Func`2<IEnumerable`1<TMessage>, TResult> failureFunc, Result`2<TSuccess, TMessage> trialResult);
    public static TSuccess ReturnOrFail(Result`2<TSuccess, TMessage> result);
    public static Result`2<TSuccess, TMessage> MergeMessages(IEnumerable`1<TMessage> messages, Result`2<TSuccess, TMessage> result);
    public static Result`2<TSuccess, TMessage> Bind(Func`2<TValue, Result`2<TSuccess, TMessage>> func, Result`2<TValue, TMessage> result);
    public static Result`2<TSuccess, TMessage> Flatten(Result`2<Result`2<TSuccess, TMessage>, TMessage> result);
    public static Result`2<TSuccess, TMessage> Apply(Result`2<Func`2<TValue, TSuccess>, TMessage> wrappedFunction, Result`2<TValue, TMessage> result);
    public static Result`2<TSuccess, TMessage> Lift(Func`2<TValue, TSuccess> func, Result`2<TValue, TMessage> result);
    public static Result`2<TSuccess1, TMessage1> Lift2(Func`2<TSuccess, Func`2<TMessage, TSuccess1>> func, Result`2<TSuccess, TMessage1> first, Result`2<TMessage, TMessage1> second);
    public static Result`2<IEnumerable`1<TSuccess>, TMessage> Collect(IEnumerable`1<Result`2<TSuccess, TMessage>> xs);
}
