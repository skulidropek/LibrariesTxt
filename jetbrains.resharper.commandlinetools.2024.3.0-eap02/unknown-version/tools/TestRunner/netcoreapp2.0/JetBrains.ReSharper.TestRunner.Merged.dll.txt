public class Autofac.Builder.ConcreteReflectionActivatorData : ReflectionActivatorData {
    public IInstanceActivator Activator { get; }
    public ConcreteReflectionActivatorData(Type implementer);
    public sealed virtual IInstanceActivator get_Activator();
}
[FlagsAttribute]
public enum Autofac.Builder.ContainerBuildOptions : Enum {
    public int value__;
    public static ContainerBuildOptions None;
    public static ContainerBuildOptions ExcludeDefaultModules;
    public static ContainerBuildOptions IgnoreStartableComponents;
}
public class Autofac.Builder.DeferredCallback : object {
    private Action`1<IComponentRegistry> _callback;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    public Action`1<IComponentRegistry> Callback { get; public set; }
    public Guid Id { get; }
    public DeferredCallback(Action`1<IComponentRegistry> callback);
    public Action`1<IComponentRegistry> get_Callback();
    public void set_Callback(Action`1<IComponentRegistry> value);
    [CompilerGeneratedAttribute]
public Guid get_Id();
}
public class Autofac.Builder.DynamicRegistrationStyle : object {
}
public interface Autofac.Builder.IConcreteActivatorData {
    public IInstanceActivator Activator { get; }
    public abstract virtual IInstanceActivator get_Activator();
}
[EditorBrowsableAttribute("1")]
public interface Autofac.Builder.IHideObjectMembers {
    [EditorBrowsableAttribute("1")]
public abstract virtual Type GetType();
    [EditorBrowsableAttribute("1")]
public abstract virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public abstract virtual string ToString();
    [EditorBrowsableAttribute("1")]
public abstract virtual bool Equals(object other);
}
public interface Autofac.Builder.IRegistrationBuilder`3 {
    [EditorBrowsableAttribute("1")]
public TActivatorData ActivatorData { get; }
    [EditorBrowsableAttribute("1")]
public TRegistrationStyle RegistrationStyle { get; }
    [EditorBrowsableAttribute("1")]
public RegistrationData RegistrationData { get; }
    public abstract virtual TActivatorData get_ActivatorData();
    public abstract virtual TRegistrationStyle get_RegistrationStyle();
    public abstract virtual RegistrationData get_RegistrationData();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> ExternallyOwned();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OwnedByLifetimeScope();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerDependency();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> SingleInstance();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerLifetimeScope();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerMatchingLifetimeScope(Object[] lifetimeScopeTag);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned(Type serviceType);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned(object serviceKey);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned(object serviceKey, Type serviceType);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As(Type[] services);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As(Service[] services);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Named(string serviceName, Type serviceType);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Named(string serviceName);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Keyed(object serviceKey, Type serviceType);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Keyed(object serviceKey);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnPreparing(Action`1<PreparingEventArgs> handler);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnActivating(Action`1<IActivatingEventArgs`1<TLimit>> handler);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnActivated(Action`1<IActivatedEventArgs`1<TLimit>> handler);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> PropertiesAutowired(IPropertySelector propertySelector, bool allowCircularDependencies);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> WithMetadata(string key, object value);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> WithMetadata(IEnumerable`1<KeyValuePair`2<string, object>> properties);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> WithMetadata(Action`1<MetadataConfiguration`1<TMetadata>> configurationAction);
}
public class Autofac.Builder.MetadataConfiguration`1 : object {
    private IDictionary`2<string, object> _properties;
    internal IEnumerable`1<KeyValuePair`2<string, object>> Properties { get; }
    internal IEnumerable`1<KeyValuePair`2<string, object>> get_Properties();
    public MetadataConfiguration`1<TMetadata> For(Expression`1<Func`2<TMetadata, TProperty>> propertyAccessor, TProperty value);
}
internal static class Autofac.Builder.MetadataKeys : object {
    internal static string RegistrationOrderMetadataKey;
    internal static string AutoActivated;
    internal static string StartOnActivatePropertyKey;
    internal static string ContainerBuildOptions;
    internal static string RegisteredPropertyKey;
}
public class Autofac.Builder.ReflectionActivatorData : object {
    private Type _implementer;
    private IConstructorFinder _constructorFinder;
    private IConstructorSelector _constructorSelector;
    private static IConstructorFinder DefaultConstructorFinder;
    private static IConstructorSelector DefaultConstructorSelector;
    [CompilerGeneratedAttribute]
private IList`1<Parameter> <ConfiguredParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Parameter> <ConfiguredProperties>k__BackingField;
    public Type ImplementationType { get; public set; }
    public IConstructorFinder ConstructorFinder { get; public set; }
    public IConstructorSelector ConstructorSelector { get; public set; }
    public IList`1<Parameter> ConfiguredParameters { get; }
    public IList`1<Parameter> ConfiguredProperties { get; }
    public ReflectionActivatorData(Type implementer);
    private static ReflectionActivatorData();
    public Type get_ImplementationType();
    public void set_ImplementationType(Type value);
    public IConstructorFinder get_ConstructorFinder();
    public void set_ConstructorFinder(IConstructorFinder value);
    public IConstructorSelector get_ConstructorSelector();
    public void set_ConstructorSelector(IConstructorSelector value);
    [CompilerGeneratedAttribute]
public IList`1<Parameter> get_ConfiguredParameters();
    [CompilerGeneratedAttribute]
public IList`1<Parameter> get_ConfiguredProperties();
}
[ExtensionAttribute]
public static class Autofac.Builder.RegistrationBuilder : object {
    public static IRegistrationBuilder`3<T, SimpleActivatorData, SingleRegistrationStyle> ForDelegate(Func`3<IComponentContext, IEnumerable`1<Parameter>, T> delegate);
    public static IRegistrationBuilder`3<object, SimpleActivatorData, SingleRegistrationStyle> ForDelegate(Type limitType, Func`3<IComponentContext, IEnumerable`1<Parameter>, object> delegate);
    public static IRegistrationBuilder`3<TImplementer, ConcreteReflectionActivatorData, SingleRegistrationStyle> ForType();
    public static IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle> ForType(Type implementationType);
    [ExtensionAttribute]
public static IComponentRegistration CreateRegistration(IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> builder);
    public static IComponentRegistration CreateRegistration(Guid id, RegistrationData data, IInstanceActivator activator, Service[] services);
    public static IComponentRegistration CreateRegistration(Guid id, RegistrationData data, IInstanceActivator activator, Service[] services, IComponentRegistration target);
    public static void RegisterSingleComponent(IComponentRegistry cr, IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> builder);
}
internal class Autofac.Builder.RegistrationBuilder`3 : object {
    [CompilerGeneratedAttribute]
private TActivatorData <ActivatorData>k__BackingField;
    [CompilerGeneratedAttribute]
private TRegistrationStyle <RegistrationStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private RegistrationData <RegistrationData>k__BackingField;
    [EditorBrowsableAttribute("1")]
public TActivatorData ActivatorData { get; }
    [EditorBrowsableAttribute("1")]
public TRegistrationStyle RegistrationStyle { get; }
    [EditorBrowsableAttribute("1")]
public RegistrationData RegistrationData { get; }
    public RegistrationBuilder`3(Service defaultService, TActivatorData activatorData, TRegistrationStyle style);
    [CompilerGeneratedAttribute]
public sealed virtual TActivatorData get_ActivatorData();
    [CompilerGeneratedAttribute]
public sealed virtual TRegistrationStyle get_RegistrationStyle();
    [CompilerGeneratedAttribute]
public sealed virtual RegistrationData get_RegistrationData();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> ExternallyOwned();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OwnedByLifetimeScope();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerDependency();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> SingleInstance();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerLifetimeScope();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerMatchingLifetimeScope(Object[] lifetimeScopeTag);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned(Type serviceType);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned(object serviceKey);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned(object serviceKey, Type serviceType);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As(Type[] services);
    public IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As(Type service);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As(Service[] services);
    public IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As(Service service);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Named(string serviceName, Type serviceType);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Named(string serviceName);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Keyed(object serviceKey, Type serviceType);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Keyed(object serviceKey);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnPreparing(Action`1<PreparingEventArgs> handler);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnActivating(Action`1<IActivatingEventArgs`1<TLimit>> handler);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnActivated(Action`1<IActivatedEventArgs`1<TLimit>> handler);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> PropertiesAutowired(IPropertySelector propertySelector, bool allowCircularDependencies);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> WithMetadata(string key, object value);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> WithMetadata(IEnumerable`1<KeyValuePair`2<string, object>> properties);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> WithMetadata(Action`1<MetadataConfiguration`1<TMetadata>> configurationAction);
    private sealed virtual override Type Autofac.Builder.IHideObjectMembers.GetType();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Builder.RegistrationBuilderResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ComponentDoesNotSupportService { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ComponentDoesNotSupportService();
}
public class Autofac.Builder.RegistrationData : object {
    private bool _defaultServiceOverridden;
    private Service _defaultService;
    private ICollection`1<Service> _services;
    private IComponentLifetime _lifetime;
    [CompilerGeneratedAttribute]
private InstanceOwnership <Ownership>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceSharing <Sharing>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private DeferredCallback <DeferredCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<EventHandler`1<PreparingEventArgs>> <PreparingHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<EventHandler`1<ActivatingEventArgs`1<object>>> <ActivatingHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<EventHandler`1<ActivatedEventArgs`1<object>>> <ActivatedHandlers>k__BackingField;
    public IEnumerable`1<Service> Services { get; }
    public InstanceOwnership Ownership { get; public set; }
    public IComponentLifetime Lifetime { get; public set; }
    public InstanceSharing Sharing { get; public set; }
    public IDictionary`2<string, object> Metadata { get; }
    public DeferredCallback DeferredCallback { get; public set; }
    public ICollection`1<EventHandler`1<PreparingEventArgs>> PreparingHandlers { get; }
    public ICollection`1<EventHandler`1<ActivatingEventArgs`1<object>>> ActivatingHandlers { get; }
    public ICollection`1<EventHandler`1<ActivatedEventArgs`1<object>>> ActivatedHandlers { get; }
    public RegistrationData(Service defaultService);
    public IEnumerable`1<Service> get_Services();
    public void AddServices(IEnumerable`1<Service> services);
    public void AddService(Service service);
    [CompilerGeneratedAttribute]
public InstanceOwnership get_Ownership();
    [CompilerGeneratedAttribute]
public void set_Ownership(InstanceOwnership value);
    public IComponentLifetime get_Lifetime();
    public void set_Lifetime(IComponentLifetime value);
    [CompilerGeneratedAttribute]
public InstanceSharing get_Sharing();
    [CompilerGeneratedAttribute]
public void set_Sharing(InstanceSharing value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Metadata();
    [CompilerGeneratedAttribute]
public DeferredCallback get_DeferredCallback();
    [CompilerGeneratedAttribute]
public void set_DeferredCallback(DeferredCallback value);
    [CompilerGeneratedAttribute]
public ICollection`1<EventHandler`1<PreparingEventArgs>> get_PreparingHandlers();
    [CompilerGeneratedAttribute]
public ICollection`1<EventHandler`1<ActivatingEventArgs`1<object>>> get_ActivatingHandlers();
    [CompilerGeneratedAttribute]
public ICollection`1<EventHandler`1<ActivatedEventArgs`1<object>>> get_ActivatedHandlers();
    public void CopyFrom(RegistrationData that, bool includeDefaultService);
    private static void AddAll(ICollection`1<T> to, IEnumerable`1<T> from);
    public void ClearServices();
}
[ExtensionAttribute]
public static class Autofac.Builder.RegistrationExtensions : object {
    [ExtensionAttribute]
public static IRegistrationBuilder`3<Delegate, GeneratedFactoryActivatorData, SingleRegistrationStyle> RegisterGeneratedFactory(ContainerBuilder builder, Type delegateType);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<Delegate, GeneratedFactoryActivatorData, SingleRegistrationStyle> RegisterGeneratedFactory(ContainerBuilder builder, Type delegateType, Service service);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TDelegate, GeneratedFactoryActivatorData, SingleRegistrationStyle> RegisterGeneratedFactory(ContainerBuilder builder, Service service);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TDelegate, GeneratedFactoryActivatorData, SingleRegistrationStyle> RegisterGeneratedFactory(ContainerBuilder builder);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TDelegate, TGeneratedFactoryActivatorData, TSingleRegistrationStyle> NamedParameterMapping(IRegistrationBuilder`3<TDelegate, TGeneratedFactoryActivatorData, TSingleRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TDelegate, TGeneratedFactoryActivatorData, TSingleRegistrationStyle> PositionalParameterMapping(IRegistrationBuilder`3<TDelegate, TGeneratedFactoryActivatorData, TSingleRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TDelegate, TGeneratedFactoryActivatorData, TSingleRegistrationStyle> TypedParameterMapping(IRegistrationBuilder`3<TDelegate, TGeneratedFactoryActivatorData, TSingleRegistrationStyle> registration);
}
[ExtensionAttribute]
internal static class Autofac.Builder.RegistrationOrderExtensions : object {
    [ExtensionAttribute]
internal static long GetRegistrationOrder(IComponentRegistration registration);
    [ExtensionAttribute]
internal static IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> InheritRegistrationOrderFrom(IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> registration, IComponentRegistration source);
}
public class Autofac.Builder.SimpleActivatorData : object {
    [CompilerGeneratedAttribute]
private IInstanceActivator <Activator>k__BackingField;
    public IInstanceActivator Activator { get; }
    public SimpleActivatorData(IInstanceActivator activator);
    [CompilerGeneratedAttribute]
public sealed virtual IInstanceActivator get_Activator();
}
public class Autofac.Builder.SingleRegistrationStyle : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<EventHandler`1<ComponentRegisteredEventArgs>> <RegisteredHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveDefaults>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistration <Target>k__BackingField;
    public Guid Id { get; public set; }
    public ICollection`1<EventHandler`1<ComponentRegisteredEventArgs>> RegisteredHandlers { get; }
    public bool PreserveDefaults { get; public set; }
    public IComponentRegistration Target { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Guid value);
    [CompilerGeneratedAttribute]
public ICollection`1<EventHandler`1<ComponentRegisteredEventArgs>> get_RegisteredHandlers();
    [CompilerGeneratedAttribute]
public bool get_PreserveDefaults();
    [CompilerGeneratedAttribute]
public void set_PreserveDefaults(bool value);
    [CompilerGeneratedAttribute]
public IComponentRegistration get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(IComponentRegistration value);
}
internal static class Autofac.Builder.StartableManager : object {
    internal static void StartStartableComponents(IComponentContext componentContext);
}
public class Autofac.ContainerBuilder : object {
    private IList`1<DeferredCallback> _configurationCallbacks;
    private bool _wasBuilt;
    private static string BuildCallbackPropertyKey;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    public IDictionary`2<string, object> Properties { get; }
    internal ContainerBuilder(IDictionary`2<string, object> properties);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Properties();
    public virtual DeferredCallback RegisterCallback(Action`1<IComponentRegistry> configurationCallback);
    public ContainerBuilder RegisterBuildCallback(Action`1<IContainer> buildCallback);
    public IContainer Build(ContainerBuildOptions options);
    [ObsoleteAttribute("Containers should generally be considered immutable. Register all of your dependencies before building/resolving. If you need to change the contents of a container, you technically should rebuild the container. This method may be removed in a future major release.")]
public void Update(IContainer container);
    [ObsoleteAttribute("Containers should generally be considered immutable. Register all of your dependencies before building/resolving. If you need to change the contents of a container, you technically should rebuild the container. This method may be removed in a future major release.")]
public void Update(IContainer container, ContainerBuildOptions options);
    [ObsoleteAttribute("Containers should generally be considered immutable. Register all of your dependencies before building/resolving. If you need to change the contents of a container, you technically should rebuild the container. This method may be removed in a future major release.")]
public void Update(IComponentRegistry componentRegistry);
    internal void UpdateRegistry(IComponentRegistry componentRegistry);
    private void Build(IComponentRegistry componentRegistry, bool excludeDefaultModules);
    private void RegisterDefaultAdapters(IComponentRegistry componentRegistry);
    private List`1<Action`1<IContainer>> GetBuildCallbacks();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.ContainerBuilderResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string BuildCanOnlyBeCalledOnce { get; }
    internal static string ErrorAutoActivating { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_BuildCanOnlyBeCalledOnce();
    internal static string get_ErrorAutoActivating();
}
public class Autofac.Core.ActivatedEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private IComponentContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistration <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Parameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Instance>k__BackingField;
    public IComponentContext Context { get; }
    public IComponentRegistration Component { get; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public T Instance { get; }
    public ActivatedEventArgs`1(IComponentContext context, IComponentRegistration component, IEnumerable`1<Parameter> parameters, T instance);
    [CompilerGeneratedAttribute]
public sealed virtual IComponentContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual IComponentRegistration get_Component();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Parameter> get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual T get_Instance();
}
public class Autofac.Core.ActivatingEventArgs`1 : EventArgs {
    private T _instance;
    [CompilerGeneratedAttribute]
private IComponentContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistration <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Parameter> <Parameters>k__BackingField;
    public IComponentContext Context { get; }
    public IComponentRegistration Component { get; }
    public T Instance { get; public set; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public ActivatingEventArgs`1(IComponentContext context, IComponentRegistration component, IEnumerable`1<Parameter> parameters, T instance);
    [CompilerGeneratedAttribute]
public sealed virtual IComponentContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual IComponentRegistration get_Component();
    public sealed virtual T get_Instance();
    public void set_Instance(T value);
    public sealed virtual void ReplaceInstance(object instance);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Parameter> get_Parameters();
}
public class Autofac.Core.Activators.Delegate.DelegateActivator : InstanceActivator {
    private Func`3<IComponentContext, IEnumerable`1<Parameter>, object> _activationFunction;
    public DelegateActivator(Type limitType, Func`3<IComponentContext, IEnumerable`1<Parameter>, object> activationFunction);
    public sealed virtual object ActivateInstance(IComponentContext context, IEnumerable`1<Parameter> parameters);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.Delegate.DelegateActivatorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NullFromActivationDelegateFor { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NullFromActivationDelegateFor();
}
public abstract class Autofac.Core.Activators.InstanceActivator : Disposable {
    [CompilerGeneratedAttribute]
private Type <LimitType>k__BackingField;
    public Type LimitType { get; }
    protected InstanceActivator(Type limitType);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_LimitType();
    public virtual string ToString();
    protected void CheckNotDisposed();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.InstanceActivatorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string InstanceActivatorDisposed { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_InstanceActivatorDisposed();
}
public class Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivator : InstanceActivator {
    private object _instance;
    private bool _activated;
    [CompilerGeneratedAttribute]
private bool <DisposeInstance>k__BackingField;
    public bool DisposeInstance { get; public set; }
    public ProvidedInstanceActivator(object instance);
    public sealed virtual object ActivateInstance(IComponentContext context, IEnumerable`1<Parameter> parameters);
    [CompilerGeneratedAttribute]
public bool get_DisposeInstance();
    [CompilerGeneratedAttribute]
public void set_DisposeInstance(bool value);
    protected virtual void Dispose(bool disposing);
    private static Type GetType(object instance);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivatorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string InstanceAlreadyActivated { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_InstanceAlreadyActivated();
}
public class Autofac.Core.Activators.Reflection.AutowiringParameter : Parameter {
    public virtual bool CanSupplyValue(ParameterInfo pi, IComponentContext context, Func`1& valueProvider);
}
internal static class Autofac.Core.Activators.Reflection.AutowiringPropertyInjector : object {
    public static string InstanceTypeNamedParameter;
    private static ConcurrentDictionary`2<PropertyInfo, Action`2<object, object>> PropertySetters;
    private static ConcurrentDictionary`2<Type, PropertyInfo[]> InjectableProperties;
    private static MethodInfo CallPropertySetterOpenGenericMethod;
    private static AutowiringPropertyInjector();
    public static void InjectProperties(IComponentContext context, object instance, IPropertySelector propertySelector, IEnumerable`1<Parameter> parameters);
    [IteratorStateMachineAttribute("Autofac.Core.Activators.Reflection.AutowiringPropertyInjector/<GetInjectableProperties>d__5")]
private static IEnumerable`1<PropertyInfo> GetInjectableProperties(Type instanceType);
    private static Action`2<object, object> MakeFastPropertySetter(PropertyInfo propertyInfo);
    private static void CallPropertySetter(Action`2<TDeclaringType, TValue> setter, object target, object value);
}
public class Autofac.Core.Activators.Reflection.ConstructorParameterBinding : object {
    private ConstructorInfo _ci;
    private Func`1[] _valueRetrievers;
    private static ConcurrentDictionary`2<ConstructorInfo, Func`2<Object[], object>> ConstructorInvokers;
    private ParameterInfo _firstNonBindableParameter;
    [CompilerGeneratedAttribute]
private bool <CanInstantiate>k__BackingField;
    public ConstructorInfo TargetConstructor { get; }
    public bool CanInstantiate { get; }
    public string Description { get; }
    public ConstructorParameterBinding(ConstructorInfo ci, IEnumerable`1<Parameter> availableParameters, IComponentContext context);
    private static ConstructorParameterBinding();
    public ConstructorInfo get_TargetConstructor();
    [CompilerGeneratedAttribute]
public bool get_CanInstantiate();
    public object Instantiate();
    public string get_Description();
    public virtual string ToString();
    private static Func`2<Object[], object> GetConstructorInvoker(ConstructorInfo constructorInfo);
    public static MethodCallExpression ConvertPrimitiveType(Expression valueExpression, Type conversionType);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.Reflection.ConstructorParameterBindingResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string BoundConstructor { get; }
    internal static string CannotInstantitate { get; }
    internal static string ExceptionDuringInstantiation { get; }
    internal static string NonBindableConstructor { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_BoundConstructor();
    internal static string get_CannotInstantitate();
    internal static string get_ExceptionDuringInstantiation();
    internal static string get_NonBindableConstructor();
}
public class Autofac.Core.Activators.Reflection.DefaultConstructorFinder : object {
    private Func`2<Type, ConstructorInfo[]> _finder;
    private static ConcurrentDictionary`2<Type, ConstructorInfo[]> DefaultPublicConstructorsCache;
    public DefaultConstructorFinder(Func`2<Type, ConstructorInfo[]> finder);
    private static DefaultConstructorFinder();
    public sealed virtual ConstructorInfo[] FindConstructors(Type targetType);
    private static ConstructorInfo[] GetDefaultPublicConstructors(Type type);
}
public class Autofac.Core.Activators.Reflection.DefaultValueParameter : Parameter {
    public virtual bool CanSupplyValue(ParameterInfo pi, IComponentContext context, Func`1& valueProvider);
}
public interface Autofac.Core.Activators.Reflection.IConstructorFinder {
    public abstract virtual ConstructorInfo[] FindConstructors(Type targetType);
}
public interface Autofac.Core.Activators.Reflection.IConstructorSelector {
    public abstract virtual ConstructorParameterBinding SelectConstructorBinding(ConstructorParameterBinding[] constructorBindings, IEnumerable`1<Parameter> parameters);
}
public class Autofac.Core.Activators.Reflection.MatchingSignatureConstructorSelector : object {
    private Type[] _signature;
    public MatchingSignatureConstructorSelector(Type[] signature);
    public sealed virtual ConstructorParameterBinding SelectConstructorBinding(ConstructorParameterBinding[] constructorBindings, IEnumerable`1<Parameter> parameters);
    [CompilerGeneratedAttribute]
private bool <SelectConstructorBinding>b__2_0(ConstructorParameterBinding b);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.Reflection.MatchingSignatureConstructorSelectorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AtLeastOneBindingRequired { get; }
    internal static string RequiredConstructorNotAvailable { get; }
    internal static string TooManyConstructorsMatch { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AtLeastOneBindingRequired();
    internal static string get_RequiredConstructorNotAvailable();
    internal static string get_TooManyConstructorsMatch();
}
public class Autofac.Core.Activators.Reflection.MostParametersConstructorSelector : object {
    public sealed virtual ConstructorParameterBinding SelectConstructorBinding(ConstructorParameterBinding[] constructorBindings, IEnumerable`1<Parameter> parameters);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.Reflection.MostParametersConstructorSelectorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string UnableToChooseFromMultipleConstructors { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_UnableToChooseFromMultipleConstructors();
}
public class Autofac.Core.Activators.Reflection.NoConstructorsFoundException : Exception {
    [CompilerGeneratedAttribute]
private Type <OffendingType>k__BackingField;
    public Type OffendingType { get; private set; }
    public NoConstructorsFoundException(Type offendingType);
    public NoConstructorsFoundException(Type offendingType, string message);
    public NoConstructorsFoundException(Type offendingType, Exception innerException);
    public NoConstructorsFoundException(Type offendingType, string message, Exception innerException);
    [CompilerGeneratedAttribute]
public Type get_OffendingType();
    [CompilerGeneratedAttribute]
private void set_OffendingType(Type value);
    private static string FormatMessage(Type offendingType);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.Reflection.NoConstructorsFoundExceptionResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Message { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Message();
}
public class Autofac.Core.Activators.Reflection.ReflectionActivator : InstanceActivator {
    private Type _implementationType;
    private Parameter[] _configuredProperties;
    private Parameter[] _defaultParameters;
    private ConstructorInfo[] _availableConstructors;
    private object _availableConstructorsLock;
    [CompilerGeneratedAttribute]
private IConstructorFinder <ConstructorFinder>k__BackingField;
    [CompilerGeneratedAttribute]
private IConstructorSelector <ConstructorSelector>k__BackingField;
    public IConstructorFinder ConstructorFinder { get; }
    public IConstructorSelector ConstructorSelector { get; }
    public ReflectionActivator(Type implementationType, IConstructorFinder constructorFinder, IConstructorSelector constructorSelector, IEnumerable`1<Parameter> configuredParameters, IEnumerable`1<Parameter> configuredProperties);
    [CompilerGeneratedAttribute]
public IConstructorFinder get_ConstructorFinder();
    [CompilerGeneratedAttribute]
public IConstructorSelector get_ConstructorSelector();
    public sealed virtual object ActivateInstance(IComponentContext context, IEnumerable`1<Parameter> parameters);
    private ConstructorParameterBinding[] GetValidConstructorBindings(IComponentContext context, IEnumerable`1<Parameter> parameters);
    private string GetBindingFailureMessage(IEnumerable`1<ConstructorParameterBinding> constructorBindings);
    private void InjectProperties(object instance, IComponentContext context);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.Reflection.ReflectionActivatorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NoConstructorsAvailable { get; }
    internal static string NoConstructorsBindable { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NoConstructorsAvailable();
    internal static string get_NoConstructorsBindable();
}
internal class Autofac.Core.AutoActivateService : Service {
    public string Description { get; }
    public virtual string get_Description();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Autofac.Core.ComponentRegisteredEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IComponentRegistry <ComponentRegistry>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistration <ComponentRegistration>k__BackingField;
    public IComponentRegistry ComponentRegistry { get; }
    public IComponentRegistration ComponentRegistration { get; }
    public ComponentRegisteredEventArgs(IComponentRegistry registry, IComponentRegistration componentRegistration);
    [CompilerGeneratedAttribute]
public IComponentRegistry get_ComponentRegistry();
    [CompilerGeneratedAttribute]
public IComponentRegistration get_ComponentRegistration();
}
[ExtensionAttribute]
public static class Autofac.Core.ComponentRegistrationExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<object> MatchingLifetimeScopeTags(IComponentRegistration registration);
}
public abstract class Autofac.Core.ConstantParameter : Parameter {
    private Predicate`1<ParameterInfo> _predicate;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    protected ConstantParameter(object value, Predicate`1<ParameterInfo> predicate);
    [CompilerGeneratedAttribute]
public object get_Value();
    public virtual bool CanSupplyValue(ParameterInfo pi, IComponentContext context, Func`1& valueProvider);
    [CompilerGeneratedAttribute]
private object <CanSupplyValue>b__5_0();
}
[DebuggerDisplayAttribute("Tag = {Tag}, IsDisposed = {IsDisposed}")]
public class Autofac.Core.Container : Disposable {
    private ILifetimeScope _rootLifetimeScope;
    [CompilerGeneratedAttribute]
private IComponentRegistry <ComponentRegistry>k__BackingField;
    public IDisposer Disposer { get; }
    public object Tag { get; }
    public IComponentRegistry ComponentRegistry { get; }
    internal Container(IDictionary`2<string, object> properties);
    public sealed virtual ILifetimeScope BeginLifetimeScope();
    public sealed virtual ILifetimeScope BeginLifetimeScope(object tag);
    public sealed virtual ILifetimeScope BeginLifetimeScope(Action`1<ContainerBuilder> configurationAction);
    public sealed virtual ILifetimeScope BeginLifetimeScope(object tag, Action`1<ContainerBuilder> configurationAction);
    public sealed virtual IDisposer get_Disposer();
    public sealed virtual object get_Tag();
    public sealed virtual void add_ChildLifetimeScopeBeginning(EventHandler`1<LifetimeScopeBeginningEventArgs> value);
    public sealed virtual void remove_ChildLifetimeScopeBeginning(EventHandler`1<LifetimeScopeBeginningEventArgs> value);
    public sealed virtual void add_CurrentScopeEnding(EventHandler`1<LifetimeScopeEndingEventArgs> value);
    public sealed virtual void remove_CurrentScopeEnding(EventHandler`1<LifetimeScopeEndingEventArgs> value);
    public sealed virtual void add_ResolveOperationBeginning(EventHandler`1<ResolveOperationBeginningEventArgs> value);
    public sealed virtual void remove_ResolveOperationBeginning(EventHandler`1<ResolveOperationBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual IComponentRegistry get_ComponentRegistry();
    public sealed virtual object ResolveComponent(IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    protected virtual void Dispose(bool disposing);
    public sealed virtual object GetService(Type serviceType);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.ContainerResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string SelfRegistrationCannotBeActivated { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_SelfRegistrationCannotBeActivated();
}
public class Autofac.Core.DefaultPropertySelector : object {
    [CompilerGeneratedAttribute]
private bool <PreserveSetValues>k__BackingField;
    [CompilerGeneratedAttribute]
private static IPropertySelector <OverwriteSetValueInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private static IPropertySelector <PreserveSetValueInstance>k__BackingField;
    public bool PreserveSetValues { get; protected set; }
    internal static IPropertySelector OverwriteSetValueInstance { get; }
    internal static IPropertySelector PreserveSetValueInstance { get; }
    public DefaultPropertySelector(bool preserveSetValues);
    private static DefaultPropertySelector();
    [CompilerGeneratedAttribute]
public bool get_PreserveSetValues();
    [CompilerGeneratedAttribute]
protected void set_PreserveSetValues(bool value);
    [CompilerGeneratedAttribute]
internal static IPropertySelector get_OverwriteSetValueInstance();
    [CompilerGeneratedAttribute]
internal static IPropertySelector get_PreserveSetValueInstance();
    public virtual bool InjectProperty(PropertyInfo propertyInfo, object instance);
}
public class Autofac.Core.DelegatePropertySelector : object {
    private Func`3<PropertyInfo, object, bool> _finder;
    public DelegatePropertySelector(Func`3<PropertyInfo, object, bool> finder);
    public sealed virtual bool InjectProperty(PropertyInfo property, object instance);
}
public class Autofac.Core.DependencyResolutionException : Exception {
    protected DependencyResolutionException(SerializationInfo info, StreamingContext context);
    public DependencyResolutionException(string message);
    public DependencyResolutionException(string message, Exception innerException);
}
[ObsoleteAttribute("Use the more general Autofac.IStartable interface instead. The IContainer parameter can be emulated when implementing IStartable by taking a dependency on IComponentContext or ILifetimeScope.", "True")]
public interface Autofac.Core.Diagnostics.IContainerAwareComponent {
    public abstract virtual void SetContainer(IContainer container);
}
internal class Autofac.Core.Disposer : Disposable {
    private Stack`1<IDisposable> _items;
    private object _synchRoot;
    protected virtual void Dispose(bool disposing);
    public sealed virtual void AddInstanceForDisposal(IDisposable instance);
}
public interface Autofac.Core.IActivatedEventArgs`1 {
    public IComponentContext Context { get; }
    public IComponentRegistration Component { get; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public T Instance { get; }
    public abstract virtual IComponentContext get_Context();
    public abstract virtual IComponentRegistration get_Component();
    public abstract virtual IEnumerable`1<Parameter> get_Parameters();
    public abstract virtual T get_Instance();
}
public interface Autofac.Core.IActivatingEventArgs`1 {
    public IComponentContext Context { get; }
    public IComponentRegistration Component { get; }
    public T Instance { get; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public abstract virtual IComponentContext get_Context();
    public abstract virtual IComponentRegistration get_Component();
    public abstract virtual T get_Instance();
    public abstract virtual void ReplaceInstance(object instance);
    public abstract virtual IEnumerable`1<Parameter> get_Parameters();
}
public interface Autofac.Core.IComponentLifetime {
    public abstract virtual ISharingLifetimeScope FindScope(ISharingLifetimeScope mostNestedVisibleScope);
}
public interface Autofac.Core.IComponentRegistration {
    public Guid Id { get; }
    public IInstanceActivator Activator { get; }
    public IComponentLifetime Lifetime { get; }
    public InstanceSharing Sharing { get; }
    public InstanceOwnership Ownership { get; }
    public IEnumerable`1<Service> Services { get; }
    public IDictionary`2<string, object> Metadata { get; }
    public IComponentRegistration Target { get; }
    public abstract virtual Guid get_Id();
    public abstract virtual IInstanceActivator get_Activator();
    public abstract virtual IComponentLifetime get_Lifetime();
    public abstract virtual InstanceSharing get_Sharing();
    public abstract virtual InstanceOwnership get_Ownership();
    public abstract virtual IEnumerable`1<Service> get_Services();
    public abstract virtual IDictionary`2<string, object> get_Metadata();
    public abstract virtual IComponentRegistration get_Target();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Preparing(EventHandler`1<PreparingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Preparing(EventHandler`1<PreparingEventArgs> value);
    public abstract virtual void RaisePreparing(IComponentContext context, IEnumerable`1& parameters);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Activating(EventHandler`1<ActivatingEventArgs`1<object>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Activating(EventHandler`1<ActivatingEventArgs`1<object>> value);
    public abstract virtual void RaiseActivating(IComponentContext context, IEnumerable`1<Parameter> parameters, Object& instance);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Activated(EventHandler`1<ActivatedEventArgs`1<object>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Activated(EventHandler`1<ActivatedEventArgs`1<object>> value);
    public abstract virtual void RaiseActivated(IComponentContext context, IEnumerable`1<Parameter> parameters, object instance);
}
public interface Autofac.Core.IComponentRegistry {
    public IDictionary`2<string, object> Properties { get; }
    public IEnumerable`1<IComponentRegistration> Registrations { get; }
    public IEnumerable`1<IRegistrationSource> Sources { get; }
    public bool HasLocalComponents { get; }
    public abstract virtual IDictionary`2<string, object> get_Properties();
    public abstract virtual bool TryGetRegistration(Service service, IComponentRegistration& registration);
    public abstract virtual bool IsRegistered(Service service);
    public abstract virtual void Register(IComponentRegistration registration);
    public abstract virtual void Register(IComponentRegistration registration, bool preserveDefaults);
    public abstract virtual IEnumerable`1<IComponentRegistration> get_Registrations();
    public abstract virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service);
    public abstract virtual IEnumerable`1<IComponentRegistration> DecoratorsFor(IComponentRegistration registration);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Registered(EventHandler`1<ComponentRegisteredEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Registered(EventHandler`1<ComponentRegisteredEventArgs> value);
    public abstract virtual void AddRegistrationSource(IRegistrationSource source);
    public abstract virtual IEnumerable`1<IRegistrationSource> get_Sources();
    public abstract virtual bool get_HasLocalComponents();
    [CompilerGeneratedAttribute]
public abstract virtual void add_RegistrationSourceAdded(EventHandler`1<RegistrationSourceAddedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_RegistrationSourceAdded(EventHandler`1<RegistrationSourceAddedEventArgs> value);
}
public interface Autofac.Core.IDisposer {
    public abstract virtual void AddInstanceForDisposal(IDisposable instance);
}
public interface Autofac.Core.IInstanceActivator {
    public Type LimitType { get; }
    public abstract virtual object ActivateInstance(IComponentContext context, IEnumerable`1<Parameter> parameters);
    public abstract virtual Type get_LimitType();
}
public interface Autofac.Core.IModule {
    public abstract virtual void Configure(IComponentRegistry componentRegistry);
}
public enum Autofac.Core.InstanceOwnership : Enum {
    public int value__;
    public static InstanceOwnership ExternallyOwned;
    public static InstanceOwnership OwnedByLifetimeScope;
}
public enum Autofac.Core.InstanceSharing : Enum {
    public int value__;
    public static InstanceSharing None;
    public static InstanceSharing Shared;
}
public interface Autofac.Core.IPropertySelector {
    public abstract virtual bool InjectProperty(PropertyInfo propertyInfo, object instance);
}
public interface Autofac.Core.IRegistrationSource {
    public bool IsAdapterForIndividualComponents { get; }
    public abstract virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public abstract virtual bool get_IsAdapterForIndividualComponents();
}
public interface Autofac.Core.IServiceWithType {
    public Type ServiceType { get; }
    public abstract virtual Type get_ServiceType();
    public abstract virtual Service ChangeType(Type newType);
}
public interface Autofac.Core.ISharingLifetimeScope {
    public ISharingLifetimeScope RootLifetimeScope { get; }
    public ISharingLifetimeScope ParentLifetimeScope { get; }
    public abstract virtual ISharingLifetimeScope get_RootLifetimeScope();
    public abstract virtual ISharingLifetimeScope get_ParentLifetimeScope();
    public abstract virtual object GetOrCreateAndShare(Guid id, Func`1<object> creator);
}
public class Autofac.Core.KeyedService : Service {
    [CompilerGeneratedAttribute]
private object <ServiceKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    public object ServiceKey { get; }
    public Type ServiceType { get; }
    public string Description { get; }
    public KeyedService(object serviceKey, Type serviceType);
    [CompilerGeneratedAttribute]
public object get_ServiceKey();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ServiceType();
    public virtual string get_Description();
    public sealed virtual bool Equals(KeyedService other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual Service ChangeType(Type newType);
}
public class Autofac.Core.Lifetime.CurrentScopeLifetime : object {
    public sealed virtual ISharingLifetimeScope FindScope(ISharingLifetimeScope mostNestedVisibleScope);
}
[DebuggerDisplayAttribute("Tag = {Tag}, IsDisposed = {IsDisposed}")]
public class Autofac.Core.Lifetime.LifetimeScope : Disposable {
    private object _synchRoot;
    private ConcurrentDictionary`2<Guid, object> _sharedInstances;
    [CompilerGeneratedAttribute]
private static Guid <SelfRegistrationId>k__BackingField;
    private static Action`1<ContainerBuilder> NoConfiguration;
    public static object RootTag;
    [CompilerGeneratedAttribute]
private ISharingLifetimeScope <ParentLifetimeScope>k__BackingField;
    [CompilerGeneratedAttribute]
private ISharingLifetimeScope <RootLifetimeScope>k__BackingField;
    [CompilerGeneratedAttribute]
private IDisposer <Disposer>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistry <ComponentRegistry>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<LifetimeScopeBeginningEventArgs> ChildLifetimeScopeBeginning;
    [CompilerGeneratedAttribute]
private EventHandler`1<LifetimeScopeEndingEventArgs> CurrentScopeEnding;
    [CompilerGeneratedAttribute]
private EventHandler`1<ResolveOperationBeginningEventArgs> ResolveOperationBeginning;
    internal static Guid SelfRegistrationId { get; }
    public ISharingLifetimeScope ParentLifetimeScope { get; }
    public ISharingLifetimeScope RootLifetimeScope { get; }
    public IDisposer Disposer { get; }
    public object Tag { get; }
    public IComponentRegistry ComponentRegistry { get; }
    protected LifetimeScope(IComponentRegistry componentRegistry, LifetimeScope parent, object tag);
    public LifetimeScope(IComponentRegistry componentRegistry, object tag);
    public LifetimeScope(IComponentRegistry componentRegistry);
    private static LifetimeScope();
    [CompilerGeneratedAttribute]
internal static Guid get_SelfRegistrationId();
    private static object MakeAnonymousTag();
    public sealed virtual ILifetimeScope BeginLifetimeScope();
    public sealed virtual ILifetimeScope BeginLifetimeScope(object tag);
    private void CheckTagIsUnique(object tag);
    private void RaiseBeginning(ILifetimeScope scope);
    public sealed virtual ILifetimeScope BeginLifetimeScope(Action`1<ContainerBuilder> configurationAction);
    public sealed virtual ILifetimeScope BeginLifetimeScope(object tag, Action`1<ContainerBuilder> configurationAction);
    private ScopeRestrictedRegistry CreateScopeRestrictedRegistry(object tag, Action`1<ContainerBuilder> configurationAction);
    public sealed virtual object ResolveComponent(IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    [CompilerGeneratedAttribute]
public sealed virtual ISharingLifetimeScope get_ParentLifetimeScope();
    [CompilerGeneratedAttribute]
public sealed virtual ISharingLifetimeScope get_RootLifetimeScope();
    public sealed virtual object GetOrCreateAndShare(Guid id, Func`1<object> creator);
    [CompilerGeneratedAttribute]
public sealed virtual IDisposer get_Disposer();
    [CompilerGeneratedAttribute]
public sealed virtual object get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual IComponentRegistry get_ComponentRegistry();
    protected virtual void Dispose(bool disposing);
    private void CheckNotDisposed();
    public sealed virtual object GetService(Type serviceType);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ChildLifetimeScopeBeginning(EventHandler`1<LifetimeScopeBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ChildLifetimeScopeBeginning(EventHandler`1<LifetimeScopeBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CurrentScopeEnding(EventHandler`1<LifetimeScopeEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CurrentScopeEnding(EventHandler`1<LifetimeScopeEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ResolveOperationBeginning(EventHandler`1<ResolveOperationBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ResolveOperationBeginning(EventHandler`1<ResolveOperationBeginningEventArgs> value);
}
public class Autofac.Core.Lifetime.LifetimeScopeBeginningEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ILifetimeScope <LifetimeScope>k__BackingField;
    public ILifetimeScope LifetimeScope { get; }
    public LifetimeScopeBeginningEventArgs(ILifetimeScope lifetimeScope);
    [CompilerGeneratedAttribute]
public ILifetimeScope get_LifetimeScope();
}
public class Autofac.Core.Lifetime.LifetimeScopeEndingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ILifetimeScope <LifetimeScope>k__BackingField;
    public ILifetimeScope LifetimeScope { get; }
    public LifetimeScopeEndingEventArgs(ILifetimeScope lifetimeScope);
    [CompilerGeneratedAttribute]
public ILifetimeScope get_LifetimeScope();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Lifetime.LifetimeScopeResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string DuplicateTagDetected { get; }
    internal static string ScopeIsDisposed { get; }
    internal static string SelfConstructingDependencyDetected { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_DuplicateTagDetected();
    internal static string get_ScopeIsDisposed();
    internal static string get_SelfConstructingDependencyDetected();
}
public class Autofac.Core.Lifetime.MatchingScopeLifetime : object {
    private Object[] _tagsToMatch;
    public IEnumerable`1<object> TagsToMatch { get; }
    public MatchingScopeLifetime(Object[] lifetimeScopeTagsToMatch);
    public IEnumerable`1<object> get_TagsToMatch();
    public sealed virtual ISharingLifetimeScope FindScope(ISharingLifetimeScope mostNestedVisibleScope);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Lifetime.MatchingScopeLifetimeResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MatchingScopeNotFound { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MatchingScopeNotFound();
}
public static class Autofac.Core.Lifetime.MatchingScopeLifetimeTags : object {
    public static object RequestLifetimeScopeTag;
    private static MatchingScopeLifetimeTags();
}
public class Autofac.Core.Lifetime.RootScopeLifetime : object {
    public sealed virtual ISharingLifetimeScope FindScope(ISharingLifetimeScope mostNestedVisibleScope);
}
public class Autofac.Core.NamedPropertyParameter : ConstantParameter {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public NamedPropertyParameter(string name, object value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
public abstract class Autofac.Core.Parameter : object {
    public abstract virtual bool CanSupplyValue(ParameterInfo pi, IComponentContext context, Func`1& valueProvider);
}
public class Autofac.Core.PreparingEventArgs : EventArgs {
    private IEnumerable`1<Parameter> _parameters;
    [CompilerGeneratedAttribute]
private IComponentContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistration <Component>k__BackingField;
    public IComponentContext Context { get; }
    public IComponentRegistration Component { get; }
    public IEnumerable`1<Parameter> Parameters { get; public set; }
    public PreparingEventArgs(IComponentContext context, IComponentRegistration component, IEnumerable`1<Parameter> parameters);
    [CompilerGeneratedAttribute]
public IComponentContext get_Context();
    [CompilerGeneratedAttribute]
public IComponentRegistration get_Component();
    public IEnumerable`1<Parameter> get_Parameters();
    public void set_Parameters(IEnumerable`1<Parameter> value);
}
internal class Autofac.Core.Registration.AdaptationSandbox : object {
    private IEnumerable`1<IRegistrationSource> _adapters;
    private IComponentRegistration _registration;
    private IEnumerable`1<Service> _adapterServices;
    private IDictionary`2<Service, IList`1<IRegistrationSource>> _adaptersToQuery;
    private IList`1<IComponentRegistration> _registrations;
    public AdaptationSandbox(IEnumerable`1<IRegistrationSource> adapters, IComponentRegistration registration, IEnumerable`1<Service> adapterServices);
    public IEnumerable`1<IComponentRegistration> GetAdapters();
    private IEnumerable`1<IComponentRegistration> GetAndInitialiseRegistrationsFor(Service service);
    [CompilerGeneratedAttribute]
private bool <GetAdapters>b__6_0(IComponentRegistration r);
}
public class Autofac.Core.Registration.ComponentNotRegisteredException : DependencyResolutionException {
    public ComponentNotRegisteredException(Service service);
    public ComponentNotRegisteredException(Service service, Exception innerException);
    private static string FormatMessage(Service service);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Registration.ComponentNotRegisteredExceptionResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Message { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Message();
}
public class Autofac.Core.Registration.ComponentRegistration : Disposable {
    private IComponentRegistration _target;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IInstanceActivator <Activator>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentLifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceSharing <Sharing>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceOwnership <Ownership>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Service> <Services>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<PreparingEventArgs> Preparing;
    [CompilerGeneratedAttribute]
private EventHandler`1<ActivatingEventArgs`1<object>> Activating;
    [CompilerGeneratedAttribute]
private EventHandler`1<ActivatedEventArgs`1<object>> Activated;
    public IComponentRegistration Target { get; }
    public Guid Id { get; }
    public IInstanceActivator Activator { get; public set; }
    public IComponentLifetime Lifetime { get; }
    public InstanceSharing Sharing { get; }
    public InstanceOwnership Ownership { get; }
    public IEnumerable`1<Service> Services { get; }
    public IDictionary`2<string, object> Metadata { get; }
    public ComponentRegistration(Guid id, IInstanceActivator activator, IComponentLifetime lifetime, InstanceSharing sharing, InstanceOwnership ownership, IEnumerable`1<Service> services, IDictionary`2<string, object> metadata);
    public ComponentRegistration(Guid id, IInstanceActivator activator, IComponentLifetime lifetime, InstanceSharing sharing, InstanceOwnership ownership, IEnumerable`1<Service> services, IDictionary`2<string, object> metadata, IComponentRegistration target);
    public sealed virtual IComponentRegistration get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual IInstanceActivator get_Activator();
    [CompilerGeneratedAttribute]
public void set_Activator(IInstanceActivator value);
    [CompilerGeneratedAttribute]
public sealed virtual IComponentLifetime get_Lifetime();
    [CompilerGeneratedAttribute]
public sealed virtual InstanceSharing get_Sharing();
    [CompilerGeneratedAttribute]
public sealed virtual InstanceOwnership get_Ownership();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Service> get_Services();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_Metadata();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Preparing(EventHandler`1<PreparingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Preparing(EventHandler`1<PreparingEventArgs> value);
    public sealed virtual void RaisePreparing(IComponentContext context, IEnumerable`1& parameters);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Activating(EventHandler`1<ActivatingEventArgs`1<object>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Activating(EventHandler`1<ActivatingEventArgs`1<object>> value);
    public sealed virtual void RaiseActivating(IComponentContext context, IEnumerable`1<Parameter> parameters, Object& instance);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Activated(EventHandler`1<ActivatedEventArgs`1<object>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Activated(EventHandler`1<ActivatedEventArgs`1<object>> value);
    public sealed virtual void RaiseActivated(IComponentContext context, IEnumerable`1<Parameter> parameters, object instance);
    public virtual string ToString();
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
internal static class Autofac.Core.Registration.ComponentRegistrationExtensions : object {
    [ExtensionAttribute]
public static bool IsAdapting(IComponentRegistration componentRegistration);
}
internal class Autofac.Core.Registration.ComponentRegistrationLifetimeDecorator : Disposable {
    private IComponentRegistration _inner;
    [CompilerGeneratedAttribute]
private IComponentLifetime <Lifetime>k__BackingField;
    public Guid Id { get; }
    public IInstanceActivator Activator { get; }
    public IComponentLifetime Lifetime { get; }
    public InstanceSharing Sharing { get; }
    public InstanceOwnership Ownership { get; }
    public IEnumerable`1<Service> Services { get; }
    public IDictionary`2<string, object> Metadata { get; }
    public IComponentRegistration Target { get; }
    public ComponentRegistrationLifetimeDecorator(IComponentRegistration inner, IComponentLifetime lifetime);
    public sealed virtual Guid get_Id();
    public sealed virtual IInstanceActivator get_Activator();
    [CompilerGeneratedAttribute]
public sealed virtual IComponentLifetime get_Lifetime();
    public sealed virtual InstanceSharing get_Sharing();
    public sealed virtual InstanceOwnership get_Ownership();
    public sealed virtual IEnumerable`1<Service> get_Services();
    public sealed virtual IDictionary`2<string, object> get_Metadata();
    public sealed virtual IComponentRegistration get_Target();
    public sealed virtual void add_Preparing(EventHandler`1<PreparingEventArgs> value);
    public sealed virtual void remove_Preparing(EventHandler`1<PreparingEventArgs> value);
    public sealed virtual void RaisePreparing(IComponentContext context, IEnumerable`1& parameters);
    public sealed virtual void add_Activating(EventHandler`1<ActivatingEventArgs`1<object>> value);
    public sealed virtual void remove_Activating(EventHandler`1<ActivatingEventArgs`1<object>> value);
    public sealed virtual void RaiseActivating(IComponentContext context, IEnumerable`1<Parameter> parameters, Object& instance);
    public sealed virtual void add_Activated(EventHandler`1<ActivatedEventArgs`1<object>> value);
    public sealed virtual void remove_Activated(EventHandler`1<ActivatedEventArgs`1<object>> value);
    public sealed virtual void RaiseActivated(IComponentContext context, IEnumerable`1<Parameter> parameters, object instance);
    protected virtual void Dispose(bool disposing);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Registration.ComponentRegistrationResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ToStringFormat { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ToStringFormat();
}
public class Autofac.Core.Registration.ComponentRegistry : Disposable {
    private object _synchRoot;
    private List`1<IRegistrationSource> _dynamicRegistrationSources;
    private List`1<IComponentRegistration> _registrations;
    private ConcurrentDictionary`2<Service, ServiceRegistrationInfo> _serviceInfo;
    private ConcurrentDictionary`2<IComponentRegistration, IEnumerable`1<IComponentRegistration>> _decorators;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<RegistrationSourceAddedEventArgs> RegistrationSourceAdded;
    public IDictionary`2<string, object> Properties { get; }
    public IEnumerable`1<IComponentRegistration> Registrations { get; }
    public IEnumerable`1<IRegistrationSource> Sources { get; }
    public bool HasLocalComponents { get; }
    internal ComponentRegistry(IDictionary`2<string, object> properties);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_Properties();
    protected virtual void Dispose(bool disposing);
    public sealed virtual bool TryGetRegistration(Service service, IComponentRegistration& registration);
    public sealed virtual bool IsRegistered(Service service);
    public sealed virtual void Register(IComponentRegistration registration);
    public sealed virtual void Register(IComponentRegistration registration, bool preserveDefaults);
    private void UpdateInitialisedAdapters(IComponentRegistration registration);
    protected virtual void AddRegistration(IComponentRegistration registration, bool preserveDefaults, bool originatedFromSource);
    public sealed virtual IEnumerable`1<IComponentRegistration> get_Registrations();
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service);
    public sealed virtual IEnumerable`1<IComponentRegistration> DecoratorsFor(IComponentRegistration registration);
    public sealed virtual void add_Registered(EventHandler`1<ComponentRegisteredEventArgs> value);
    public sealed virtual void remove_Registered(EventHandler`1<ComponentRegisteredEventArgs> value);
    public sealed virtual void AddRegistrationSource(IRegistrationSource source);
    public sealed virtual IEnumerable`1<IRegistrationSource> get_Sources();
    public sealed virtual bool get_HasLocalComponents();
    [CompilerGeneratedAttribute]
public sealed virtual void add_RegistrationSourceAdded(EventHandler`1<RegistrationSourceAddedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_RegistrationSourceAdded(EventHandler`1<RegistrationSourceAddedEventArgs> value);
    private ServiceRegistrationInfo GetInitializedServiceInfo(Service service);
    private ServiceRegistrationInfo GetServiceInfo(Service service);
    private ServiceRegistrationInfo GetInitializedServiceInfoOrDefault(Service service);
    private EventHandler`1<ComponentRegisteredEventArgs> GetRegistered();
    [CompilerGeneratedAttribute]
private IEnumerable`1<IComponentRegistration> <DecoratorsFor>b__20_0(IComponentRegistration r);
}
internal class Autofac.Core.Registration.CopyOnWriteRegistry : object {
    private IComponentRegistry _readRegistry;
    private Func`1<IComponentRegistry> _createWriteRegistry;
    private IComponentRegistry _writeRegistry;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    private IComponentRegistry Registry { get; }
    private IComponentRegistry WriteRegistry { get; }
    public IDictionary`2<string, object> Properties { get; public set; }
    public IEnumerable`1<IComponentRegistration> Registrations { get; }
    public IEnumerable`1<IRegistrationSource> Sources { get; }
    public bool HasLocalComponents { get; }
    public CopyOnWriteRegistry(IComponentRegistry readRegistry, Func`1<IComponentRegistry> createWriteRegistry);
    private IComponentRegistry get_Registry();
    private IComponentRegistry get_WriteRegistry();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, object> value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual bool TryGetRegistration(Service service, IComponentRegistration& registration);
    public sealed virtual bool IsRegistered(Service service);
    public sealed virtual void Register(IComponentRegistration registration);
    public sealed virtual void Register(IComponentRegistration registration, bool preserveDefaults);
    public sealed virtual IEnumerable`1<IComponentRegistration> get_Registrations();
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service);
    public sealed virtual IEnumerable`1<IComponentRegistration> DecoratorsFor(IComponentRegistration registration);
    public sealed virtual void add_Registered(EventHandler`1<ComponentRegisteredEventArgs> value);
    public sealed virtual void remove_Registered(EventHandler`1<ComponentRegisteredEventArgs> value);
    public sealed virtual void AddRegistrationSource(IRegistrationSource source);
    public sealed virtual IEnumerable`1<IRegistrationSource> get_Sources();
    public sealed virtual bool get_HasLocalComponents();
    public sealed virtual void add_RegistrationSourceAdded(EventHandler`1<RegistrationSourceAddedEventArgs> value);
    public sealed virtual void remove_RegistrationSourceAdded(EventHandler`1<RegistrationSourceAddedEventArgs> value);
}
internal class Autofac.Core.Registration.ExternalRegistrySource : object {
    private IComponentRegistry _registry;
    public bool IsAdapterForIndividualComponents { get; }
    public ExternalRegistrySource(IComponentRegistry registry);
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
}
public interface Autofac.Core.Registration.IModuleRegistrar {
    public abstract virtual IModuleRegistrar RegisterModule(IModule module);
}
public interface Autofac.Core.Registration.ISourceRegistrar {
    public abstract virtual ISourceRegistrar RegisterSource(IRegistrationSource registrationSource);
}
internal class Autofac.Core.Registration.ModuleRegistrar : object {
    private ContainerBuilder _builder;
    public ModuleRegistrar(ContainerBuilder builder);
    public sealed virtual IModuleRegistrar RegisterModule(IModule module);
}
internal class Autofac.Core.Registration.ScopeRestrictedRegistry : ComponentRegistry {
    private IComponentLifetime _restrictedRootScopeLifetime;
    internal ScopeRestrictedRegistry(object scopeTag, IDictionary`2<string, object> properties);
    protected virtual void AddRegistration(IComponentRegistration registration, bool preserveDefaults, bool originatedFromSource);
}
internal class Autofac.Core.Registration.ServiceRegistrationInfo : object {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isInitialized;
    private Service _service;
    private List`1<IComponentRegistration> _defaultImplementations;
    private List`1<IComponentRegistration> _sourceImplementations;
    private List`1<IComponentRegistration> _preserveDefaultImplementations;
    private IComponentRegistration _defaultImplementation;
    private Queue`1<IRegistrationSource> _sourcesToQuery;
    public bool IsInitialized { get; private set; }
    public IEnumerable`1<IComponentRegistration> Implementations { get; }
    public bool IsRegistered { get; }
    private bool Any { get; }
    public bool IsInitializing { get; }
    public bool HasSourcesToQuery { get; }
    public ServiceRegistrationInfo(Service service);
    public bool get_IsInitialized();
    private void set_IsInitialized(bool value);
    public IEnumerable`1<IComponentRegistration> get_Implementations();
    private void RequiresInitialization();
    public bool get_IsRegistered();
    private bool get_Any();
    public void AddImplementation(IComponentRegistration registration, bool preserveDefaults, bool originatedFromSource);
    public bool TryGetRegistration(IComponentRegistration& registration);
    public void Include(IRegistrationSource source);
    public bool get_IsInitializing();
    public bool get_HasSourcesToQuery();
    public void BeginInitialization(IEnumerable`1<IRegistrationSource> sources);
    public void SkipSource(IRegistrationSource source);
    private void EnforceDuringInitialization();
    public IRegistrationSource DequeueNextSource();
    public void CompleteInitialization();
    public bool ShouldRecalculateAdaptersOn(IComponentRegistration registration);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Registration.ServiceRegistrationInfoResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NotDuringInitialization { get; }
    internal static string NotInitialized { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NotDuringInitialization();
    internal static string get_NotInitialized();
}
internal class Autofac.Core.Registration.SourceRegistrar : object {
    private ContainerBuilder _builder;
    public SourceRegistrar(ContainerBuilder builder);
    public sealed virtual ISourceRegistrar RegisterSource(IRegistrationSource registrationSource);
}
public class Autofac.Core.RegistrationSourceAddedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IRegistrationSource <RegistrationSource>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistry <ComponentRegistry>k__BackingField;
    public IRegistrationSource RegistrationSource { get; }
    public IComponentRegistry ComponentRegistry { get; }
    public RegistrationSourceAddedEventArgs(IComponentRegistry componentRegistry, IRegistrationSource registrationSource);
    [CompilerGeneratedAttribute]
public IRegistrationSource get_RegistrationSource();
    [CompilerGeneratedAttribute]
public IComponentRegistry get_ComponentRegistry();
}
public class Autofac.Core.ResolvedParameter : Parameter {
    private Func`3<ParameterInfo, IComponentContext, bool> _predicate;
    private Func`3<ParameterInfo, IComponentContext, object> _valueAccessor;
    public ResolvedParameter(Func`3<ParameterInfo, IComponentContext, bool> predicate, Func`3<ParameterInfo, IComponentContext, object> valueAccessor);
    public virtual bool CanSupplyValue(ParameterInfo pi, IComponentContext context, Func`1& valueProvider);
    public static ResolvedParameter ForNamed(string serviceName);
    public static ResolvedParameter ForKeyed(object serviceKey);
}
[ExtensionAttribute]
internal static class Autofac.Core.Resolving.ActivatorExtensions : object {
    [ExtensionAttribute]
public static string DisplayName(IInstanceActivator activator);
}
internal class Autofac.Core.Resolving.CircularDependencyDetector : object {
    private static int MaxResolveDepth;
    private static CircularDependencyDetector();
    private static string CreateDependencyGraphTo(IComponentRegistration registration, Stack`1<InstanceLookup> activationStack);
    private static string Display(IComponentRegistration registration);
    public static void CheckForCircularDependency(IComponentRegistration registration, Stack`1<InstanceLookup> activationStack, int callDepth);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Resolving.CircularDependencyDetectorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CircularDependency { get; }
    internal static string MaxDepthExceeded { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CircularDependency();
    internal static string get_MaxDepthExceeded();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Resolving.ComponentActivationResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ActivationAlreadyExecuted { get; }
    internal static string ErrorDuringActivation { get; }
    internal static string UnableToLocateLifetimeScope { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ActivationAlreadyExecuted();
    internal static string get_ErrorDuringActivation();
    internal static string get_UnableToLocateLifetimeScope();
}
public interface Autofac.Core.Resolving.IInstanceLookup {
    public IComponentRegistration ComponentRegistration { get; }
    public ILifetimeScope ActivationScope { get; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public abstract virtual IComponentRegistration get_ComponentRegistration();
    public abstract virtual ILifetimeScope get_ActivationScope();
    public abstract virtual IEnumerable`1<Parameter> get_Parameters();
    [CompilerGeneratedAttribute]
public abstract virtual void add_InstanceLookupEnding(EventHandler`1<InstanceLookupEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_InstanceLookupEnding(EventHandler`1<InstanceLookupEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CompletionBeginning(EventHandler`1<InstanceLookupCompletionBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CompletionBeginning(EventHandler`1<InstanceLookupCompletionBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CompletionEnding(EventHandler`1<InstanceLookupCompletionEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CompletionEnding(EventHandler`1<InstanceLookupCompletionEndingEventArgs> value);
}
internal class Autofac.Core.Resolving.InstanceLookup : object {
    private IResolveOperation _context;
    private ISharingLifetimeScope _activationScope;
    private object _newInstance;
    private bool _executed;
    private static string ActivatorChainExceptionData;
    [CompilerGeneratedAttribute]
private IComponentRegistration <ComponentRegistration>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Parameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<InstanceLookupEndingEventArgs> InstanceLookupEnding;
    [CompilerGeneratedAttribute]
private EventHandler`1<InstanceLookupCompletionBeginningEventArgs> CompletionBeginning;
    [CompilerGeneratedAttribute]
private EventHandler`1<InstanceLookupCompletionEndingEventArgs> CompletionEnding;
    private bool NewInstanceActivated { get; }
    public IComponentRegistry ComponentRegistry { get; }
    public IComponentRegistration ComponentRegistration { get; }
    public ILifetimeScope ActivationScope { get; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public InstanceLookup(IComponentRegistration registration, IResolveOperation context, ISharingLifetimeScope mostNestedVisibleScope, IEnumerable`1<Parameter> parameters);
    public object Execute();
    private void StartStartableComponent(object instance);
    private bool get_NewInstanceActivated();
    private object Activate(IEnumerable`1<Parameter> parameters, Object& decoratorTarget);
    private static DependencyResolutionException PropagateActivationException(IInstanceActivator activator, Exception exception);
    public void Complete();
    public sealed virtual IComponentRegistry get_ComponentRegistry();
    public sealed virtual object ResolveComponent(IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    [CompilerGeneratedAttribute]
public sealed virtual IComponentRegistration get_ComponentRegistration();
    public sealed virtual ILifetimeScope get_ActivationScope();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Parameter> get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void add_InstanceLookupEnding(EventHandler`1<InstanceLookupEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_InstanceLookupEnding(EventHandler`1<InstanceLookupEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CompletionBeginning(EventHandler`1<InstanceLookupCompletionBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CompletionBeginning(EventHandler`1<InstanceLookupCompletionBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CompletionEnding(EventHandler`1<InstanceLookupCompletionEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CompletionEnding(EventHandler`1<InstanceLookupCompletionEndingEventArgs> value);
}
public class Autofac.Core.Resolving.InstanceLookupBeginningEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IInstanceLookup <InstanceLookup>k__BackingField;
    public IInstanceLookup InstanceLookup { get; }
    public InstanceLookupBeginningEventArgs(IInstanceLookup instanceLookup);
    [CompilerGeneratedAttribute]
public IInstanceLookup get_InstanceLookup();
}
public class Autofac.Core.Resolving.InstanceLookupCompletionBeginningEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IInstanceLookup <InstanceLookup>k__BackingField;
    public IInstanceLookup InstanceLookup { get; }
    public InstanceLookupCompletionBeginningEventArgs(IInstanceLookup instanceLookup);
    [CompilerGeneratedAttribute]
public IInstanceLookup get_InstanceLookup();
}
public class Autofac.Core.Resolving.InstanceLookupCompletionEndingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IInstanceLookup <InstanceLookup>k__BackingField;
    public IInstanceLookup InstanceLookup { get; }
    public InstanceLookupCompletionEndingEventArgs(IInstanceLookup instanceLookup);
    [CompilerGeneratedAttribute]
public IInstanceLookup get_InstanceLookup();
}
public class Autofac.Core.Resolving.InstanceLookupEndingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <NewInstanceActivated>k__BackingField;
    [CompilerGeneratedAttribute]
private IInstanceLookup <InstanceLookup>k__BackingField;
    public bool NewInstanceActivated { get; }
    public IInstanceLookup InstanceLookup { get; }
    public InstanceLookupEndingEventArgs(IInstanceLookup instanceLookup, bool newInstanceActivated);
    [CompilerGeneratedAttribute]
public bool get_NewInstanceActivated();
    [CompilerGeneratedAttribute]
public IInstanceLookup get_InstanceLookup();
}
public interface Autofac.Core.Resolving.IResolveOperation {
    public abstract virtual object GetOrCreateInstance(ISharingLifetimeScope currentOperationScope, IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CurrentOperationEnding(EventHandler`1<ResolveOperationEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CurrentOperationEnding(EventHandler`1<ResolveOperationEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_InstanceLookupBeginning(EventHandler`1<InstanceLookupBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_InstanceLookupBeginning(EventHandler`1<InstanceLookupBeginningEventArgs> value);
}
internal class Autofac.Core.Resolving.ResolveOperation : object {
    private Stack`1<InstanceLookup> _activationStack;
    private List`1<InstanceLookup> _successfulActivations;
    private ISharingLifetimeScope _mostNestedLifetimeScope;
    private int _callDepth;
    private bool _ended;
    [CompilerGeneratedAttribute]
private EventHandler`1<ResolveOperationEndingEventArgs> CurrentOperationEnding;
    [CompilerGeneratedAttribute]
private EventHandler`1<InstanceLookupBeginningEventArgs> InstanceLookupBeginning;
    public IComponentRegistry ComponentRegistry { get; }
    public ResolveOperation(ISharingLifetimeScope mostNestedLifetimeScope);
    public sealed virtual object ResolveComponent(IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    public object Execute(IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    public sealed virtual object GetOrCreateInstance(ISharingLifetimeScope currentOperationScope, IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CurrentOperationEnding(EventHandler`1<ResolveOperationEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CurrentOperationEnding(EventHandler`1<ResolveOperationEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_InstanceLookupBeginning(EventHandler`1<InstanceLookupBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_InstanceLookupBeginning(EventHandler`1<InstanceLookupBeginningEventArgs> value);
    private void CompleteActivations();
    private void ResetSuccessfulActivations();
    public sealed virtual IComponentRegistry get_ComponentRegistry();
    private void End(Exception exception);
}
public class Autofac.Core.Resolving.ResolveOperationBeginningEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IResolveOperation <ResolveOperation>k__BackingField;
    public IResolveOperation ResolveOperation { get; }
    public ResolveOperationBeginningEventArgs(IResolveOperation resolveOperation);
    [CompilerGeneratedAttribute]
public IResolveOperation get_ResolveOperation();
}
public class Autofac.Core.Resolving.ResolveOperationEndingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private IResolveOperation <ResolveOperation>k__BackingField;
    public Exception Exception { get; }
    public IResolveOperation ResolveOperation { get; }
    public ResolveOperationEndingEventArgs(IResolveOperation resolveOperation, Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public IResolveOperation get_ResolveOperation();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Resolving.ResolveOperationResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ExceptionDuringResolve { get; }
    internal static string MaxDepthExceeded { get; }
    internal static string TemporaryContextDisposed { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ExceptionDuringResolve();
    internal static string get_MaxDepthExceeded();
    internal static string get_TemporaryContextDisposed();
}
public abstract class Autofac.Core.Service : object {
    public string Description { get; }
    public abstract virtual string get_Description();
    public virtual string ToString();
    public static bool op_Equality(Service left, Service right);
    public static bool op_Inequality(Service left, Service right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.ServiceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MustOverrideEquals { get; }
    internal static string MustOverrideGetHashCode { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MustOverrideEquals();
    internal static string get_MustOverrideGetHashCode();
}
public class Autofac.Core.TypedService : Service {
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    public Type ServiceType { get; }
    public string Description { get; }
    public TypedService(Type serviceType);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ServiceType();
    public virtual string get_Description();
    public sealed virtual bool Equals(TypedService other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual Service ChangeType(Type newType);
}
public class Autofac.Core.UniqueService : Service {
    private Guid _id;
    public string Description { get; }
    public UniqueService(Guid id);
    public virtual string get_Description();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Autofac.Features.AttributeFilters.KeyFilterAttribute : ParameterFilterAttribute {
    [CompilerGeneratedAttribute]
private object <Key>k__BackingField;
    public object Key { get; }
    public KeyFilterAttribute(object key);
    [CompilerGeneratedAttribute]
public object get_Key();
    public virtual object ResolveParameter(ParameterInfo parameter, IComponentContext context);
}
public class Autofac.Features.AttributeFilters.MetadataFilterAttribute : ParameterFilterAttribute {
    private static MethodInfo FilterOneMethod;
    private static MethodInfo FilterAllMethod;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string Key { get; }
    public object Value { get; private set; }
    public MetadataFilterAttribute(string key, object value);
    private static MetadataFilterAttribute();
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    public virtual object ResolveParameter(ParameterInfo parameter, IComponentContext context);
    private static Type GetElementType(Type type);
    private static T FilterOne(IComponentContext context, string metadataKey, object metadataValue);
    private static IEnumerable`1<T> FilterAll(IComponentContext context, string metadataKey, object metadataValue);
}
[AttributeUsageAttribute("2048")]
public abstract class Autofac.Features.AttributeFilters.ParameterFilterAttribute : Attribute {
    public abstract virtual object ResolveParameter(ParameterInfo parameter, IComponentContext context);
}
[ExtensionAttribute]
public static class Autofac.Features.AttributeFilters.RegistrationExtensions : object {
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TRegistrationStyle> WithAttributeFiltering(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TRegistrationStyle> builder);
}
internal class Autofac.Features.Collections.CollectionRegistrationSource : object {
    public bool IsAdapterForIndividualComponents { get; }
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
    private static Func`2<IEnumerable`1<object>, object> BuildGenerator(Type elementType, string methodName);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.Collections.CollectionRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CollectionRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CollectionRegistrationSourceDescription();
}
public class Autofac.Features.Decorators.DecoratorContext : object {
    [CompilerGeneratedAttribute]
private Type <ImplementationType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Type> <AppliedDecoratorTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<object> <AppliedDecorators>k__BackingField;
    [CompilerGeneratedAttribute]
private object <CurrentInstance>k__BackingField;
    public Type ImplementationType { get; private set; }
    public Type ServiceType { get; private set; }
    public IReadOnlyList`1<Type> AppliedDecoratorTypes { get; private set; }
    public IReadOnlyList`1<object> AppliedDecorators { get; private set; }
    public object CurrentInstance { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ImplementationType();
    [CompilerGeneratedAttribute]
private void set_ImplementationType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ServiceType();
    [CompilerGeneratedAttribute]
private void set_ServiceType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<Type> get_AppliedDecoratorTypes();
    [CompilerGeneratedAttribute]
private void set_AppliedDecoratorTypes(IReadOnlyList`1<Type> value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<object> get_AppliedDecorators();
    [CompilerGeneratedAttribute]
private void set_AppliedDecorators(IReadOnlyList`1<object> value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_CurrentInstance();
    [CompilerGeneratedAttribute]
private void set_CurrentInstance(object value);
    internal static DecoratorContext Create(Type implementationType, Type serviceType, object implementationInstance);
    internal DecoratorContext UpdateContext(object decoratorInstance);
}
public class Autofac.Features.Decorators.DecoratorService : Service {
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IDecoratorContext, bool> <Condition>k__BackingField;
    public Type ServiceType { get; }
    public Func`2<IDecoratorContext, bool> Condition { get; }
    public string Description { get; }
    public DecoratorService(Type serviceType, Func`2<IDecoratorContext, bool> condition);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ServiceType();
    [CompilerGeneratedAttribute]
public Func`2<IDecoratorContext, bool> get_Condition();
    public virtual string get_Description();
    public sealed virtual Service ChangeType(Type newType);
    public sealed virtual bool Equals(DecoratorService other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface Autofac.Features.Decorators.IDecoratorContext {
    public Type ImplementationType { get; }
    public Type ServiceType { get; }
    public IReadOnlyList`1<Type> AppliedDecoratorTypes { get; }
    public IReadOnlyList`1<object> AppliedDecorators { get; }
    public object CurrentInstance { get; }
    public abstract virtual Type get_ImplementationType();
    public abstract virtual Type get_ServiceType();
    public abstract virtual IReadOnlyList`1<Type> get_AppliedDecoratorTypes();
    public abstract virtual IReadOnlyList`1<object> get_AppliedDecorators();
    public abstract virtual object get_CurrentInstance();
}
internal static class Autofac.Features.Decorators.InstanceDecorator : object {
    internal static object TryDecorateRegistration(IComponentRegistration registration, object instance, IComponentContext context, IEnumerable`1<Parameter> parameters);
}
public class Autofac.Features.GeneratedFactories.FactoryGenerator : object {
    private Func`3<IComponentContext, IEnumerable`1<Parameter>, Delegate> _generator;
    public FactoryGenerator(Type delegateType, Service service, ParameterMapping parameterMapping);
    public FactoryGenerator(Type delegateType, IComponentRegistration productRegistration, ParameterMapping parameterMapping);
    private static ParameterMapping GetParameterMapping(Type delegateType, ParameterMapping configuredParameterMapping);
    private static bool DelegateTypeIsFunc(Type delegateType);
    private static Func`3<IComponentContext, IEnumerable`1<Parameter>, Delegate> CreateGenerator(Func`3<Expression, Expression[], Expression> makeResolveCall, Type delegateType, ParameterMapping pm);
    private static Expression[] MapParameters(IEnumerable`1<ParameterExpression> creatorParams, ParameterMapping pm);
    public Delegate GenerateFactory(IComponentContext context, IEnumerable`1<Parameter> parameters);
    public TDelegate GenerateFactory(IComponentContext context, IEnumerable`1<Parameter> parameters);
}
public class Autofac.Features.GeneratedFactories.GeneratedFactoryActivatorData : object {
    private Type _delegateType;
    private Service _productService;
    [CompilerGeneratedAttribute]
private ParameterMapping <ParameterMapping>k__BackingField;
    public ParameterMapping ParameterMapping { get; public set; }
    public IInstanceActivator Activator { get; }
    public GeneratedFactoryActivatorData(Type delegateType, Service productService);
    [CompilerGeneratedAttribute]
public ParameterMapping get_ParameterMapping();
    [CompilerGeneratedAttribute]
public void set_ParameterMapping(ParameterMapping value);
    public sealed virtual IInstanceActivator get_Activator();
}
internal static class Autofac.Features.GeneratedFactories.GeneratedFactoryRegistrationExtensions : object {
    internal static IRegistrationBuilder`3<TLimit, GeneratedFactoryActivatorData, SingleRegistrationStyle> RegisterGeneratedFactory(ContainerBuilder builder, Type delegateType, Service service);
}
internal class Autofac.Features.GeneratedFactories.GeneratedFactoryRegistrationSource : object {
    public bool IsAdapterForIndividualComponents { get; }
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.GeneratedFactories.GeneratedFactoryRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string DuplicateTypesInTypeMappedFuncParameterList { get; }
    internal static string GeneratedFactoryRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_DuplicateTypesInTypeMappedFuncParameterList();
    internal static string get_GeneratedFactoryRegistrationSourceDescription();
}
public enum Autofac.Features.GeneratedFactories.ParameterMapping : Enum {
    public int value__;
    public static ParameterMapping Adaptive;
    public static ParameterMapping ByName;
    public static ParameterMapping ByType;
    public static ParameterMapping ByPosition;
}
[DefaultMemberAttribute("Item")]
public interface Autofac.Features.Indexed.IIndex`2 {
    public TValue Item { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
[DefaultMemberAttribute("Item")]
internal class Autofac.Features.Indexed.KeyedServiceIndex`2 : object {
    private IComponentContext _context;
    public TValue Item { get; }
    public KeyedServiceIndex`2(IComponentContext context);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private static KeyedService GetService(TKey key);
}
internal class Autofac.Features.LazyDependencies.LazyRegistrationSource : object {
    private static MethodInfo CreateLazyRegistrationMethod;
    public bool IsAdapterForIndividualComponents { get; }
    private static LazyRegistrationSource();
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
    private static IComponentRegistration CreateLazyRegistration(Service providedService, IComponentRegistration valueRegistration);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.LazyDependencies.LazyRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string LazyRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_LazyRegistrationSourceDescription();
}
internal class Autofac.Features.LazyDependencies.LazyWithMetadataRegistrationSource : object {
    private static MethodInfo CreateLazyRegistrationMethod;
    public bool IsAdapterForIndividualComponents { get; }
    private static LazyWithMetadataRegistrationSource();
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
    private static IComponentRegistration CreateLazyRegistration(Service providedService, IComponentRegistration valueRegistration);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.LazyDependencies.LazyWithMetadataRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string LazyWithMetadataRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_LazyWithMetadataRegistrationSourceDescription();
}
public class Autofac.Features.LightweightAdapters.LightweightAdapterActivatorData : object {
    [CompilerGeneratedAttribute]
private Func`4<IComponentContext, IEnumerable`1<Parameter>, object, object> <Adapter>k__BackingField;
    [CompilerGeneratedAttribute]
private Service <FromService>k__BackingField;
    public Func`4<IComponentContext, IEnumerable`1<Parameter>, object, object> Adapter { get; }
    public Service FromService { get; }
    public LightweightAdapterActivatorData(Service fromService, Func`4<IComponentContext, IEnumerable`1<Parameter>, object, object> adapter);
    [CompilerGeneratedAttribute]
public Func`4<IComponentContext, IEnumerable`1<Parameter>, object, object> get_Adapter();
    [CompilerGeneratedAttribute]
public Service get_FromService();
}
internal static class Autofac.Features.LightweightAdapters.LightweightAdapterRegistrationExtensions : object {
    public static IRegistrationBuilder`3<TTo, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterAdapter(ContainerBuilder builder, Func`4<IComponentContext, IEnumerable`1<Parameter>, TFrom, TTo> adapter);
    public static IRegistrationBuilder`3<TService, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterDecorator(ContainerBuilder builder, Func`4<IComponentContext, IEnumerable`1<Parameter>, TService, TService> decorator, object fromKey, object toKey);
    private static Service ServiceWithKey(object key);
    private static IRegistrationBuilder`3<TTo, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterAdapter(ContainerBuilder builder, Func`4<IComponentContext, IEnumerable`1<Parameter>, TFrom, TTo> adapter, Service fromService, Service toService);
}
internal class Autofac.Features.LightweightAdapters.LightweightAdapterRegistrationSource : object {
    private RegistrationData _registrationData;
    private LightweightAdapterActivatorData _activatorData;
    public bool IsAdapterForIndividualComponents { get; }
    public LightweightAdapterRegistrationSource(RegistrationData registrationData, LightweightAdapterActivatorData activatorData);
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.LightweightAdapters.LightweightAdapterRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AdapterFromToDescription { get; }
    internal static string FromAndToMustDiffer { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AdapterFromToDescription();
    internal static string get_FromAndToMustDiffer();
}
public class Autofac.Features.Metadata.Meta`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Metadata>k__BackingField;
    public T Value { get; }
    public IDictionary`2<string, object> Metadata { get; }
    public Meta`1(T value, IDictionary`2<string, object> metadata);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Metadata();
}
public class Autofac.Features.Metadata.Meta`2 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private TMetadata <Metadata>k__BackingField;
    public T Value { get; }
    public TMetadata Metadata { get; }
    public Meta`2(T value, TMetadata metadata);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public TMetadata get_Metadata();
}
internal static class Autofac.Features.Metadata.MetadataViewProvider : object {
    private static MethodInfo GetMetadataValueMethod;
    private static MetadataViewProvider();
    public static Func`2<IDictionary`2<string, object>, TMetadata> GetMetadataViewProvider();
    private static TValue GetMetadataValue(IDictionary`2<string, object> metadata, string name, DefaultValueAttribute defaultValue);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.Metadata.MetadataViewProviderResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string InvalidViewImplementation { get; }
    internal static string MissingMetadata { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_InvalidViewImplementation();
    internal static string get_MissingMetadata();
}
internal class Autofac.Features.Metadata.MetaRegistrationSource : object {
    private static MethodInfo CreateMetaRegistrationMethod;
    public bool IsAdapterForIndividualComponents { get; }
    private static MetaRegistrationSource();
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
    private static IComponentRegistration CreateMetaRegistration(Service providedService, IComponentRegistration valueRegistration);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.Metadata.MetaRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MetaRegistrationSourceDescription { get; }
    internal static string StronglyTypedMetaRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MetaRegistrationSourceDescription();
    internal static string get_StronglyTypedMetaRegistrationSourceDescription();
}
internal class Autofac.Features.Metadata.StronglyTypedMetaRegistrationSource : object {
    private static MethodInfo CreateMetaRegistrationMethod;
    public bool IsAdapterForIndividualComponents { get; }
    private static StronglyTypedMetaRegistrationSource();
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
    private static IComponentRegistration CreateMetaRegistration(Service providedService, IComponentRegistration valueRegistration);
}
public class Autofac.Features.OpenGenerics.OpenGenericDecoratorActivatorData : ReflectionActivatorData {
    [CompilerGeneratedAttribute]
private IServiceWithType <FromService>k__BackingField;
    public IServiceWithType FromService { get; }
    public OpenGenericDecoratorActivatorData(Type implementer, IServiceWithType fromService);
    [CompilerGeneratedAttribute]
public IServiceWithType get_FromService();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.OpenGenerics.OpenGenericDecoratorActivatorDataResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string DecoratedServiceIsNotOpenGeneric { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_DecoratedServiceIsNotOpenGeneric();
}
internal class Autofac.Features.OpenGenerics.OpenGenericDecoratorRegistrationSource : object {
    private RegistrationData _registrationData;
    private OpenGenericDecoratorActivatorData _activatorData;
    public bool IsAdapterForIndividualComponents { get; }
    public OpenGenericDecoratorRegistrationSource(RegistrationData registrationData, OpenGenericDecoratorActivatorData activatorData);
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    private static Parameter[] AddDecoratedComponentParameter(Type decoratedParameterType, IComponentRegistration decoratedComponent, IList`1<Parameter> configuredParameters);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.OpenGenerics.OpenGenericDecoratorRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string FromAndToMustDiffer { get; }
    internal static string OpenGenericDecoratorRegistrationSourceImplFromTo { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_FromAndToMustDiffer();
    internal static string get_OpenGenericDecoratorRegistrationSourceImplFromTo();
}
internal static class Autofac.Features.OpenGenerics.OpenGenericRegistrationExtensions : object {
    public static IRegistrationBuilder`3<object, ReflectionActivatorData, DynamicRegistrationStyle> RegisterGeneric(ContainerBuilder builder, Type implementor);
    public static IRegistrationBuilder`3<object, OpenGenericDecoratorActivatorData, DynamicRegistrationStyle> RegisterGenericDecorator(ContainerBuilder builder, Type decoratorType, Type decoratedServiceType, object fromKey, object toKey);
    private static IServiceWithType GetServiceWithKey(Type serviceType, object key);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.OpenGenerics.OpenGenericRegistrationExtensionsResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ImplementorMustBeOpenGenericType { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ImplementorMustBeOpenGenericType();
}
internal class Autofac.Features.OpenGenerics.OpenGenericRegistrationSource : object {
    private RegistrationData _registrationData;
    private ReflectionActivatorData _activatorData;
    public bool IsAdapterForIndividualComponents { get; }
    public OpenGenericRegistrationSource(RegistrationData registrationData, ReflectionActivatorData activatorData);
    [IteratorStateMachineAttribute("Autofac.Features.OpenGenerics.OpenGenericRegistrationSource/<RegistrationsFor>d__3")]
public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.OpenGenerics.OpenGenericRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string OpenGenericRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_OpenGenericRegistrationSourceDescription();
}
internal static class Autofac.Features.OpenGenerics.OpenGenericServiceBinder : object {
    public static bool TryBindServiceType(Service service, IEnumerable`1<Service> configuredOpenGenericServices, Type openGenericImplementationType, Type& constructedImplementationType, Service[]& constructedServices);
    private static Type[] TryMapImplementationGenericArguments(Type implementationType, Type serviceType, Type serviceTypeDefinition, Type[] serviceGenericArguments);
    private static Type GetInterface(Type implementationType, Type serviceType);
    private static Type TryFindServiceArgumentForImplementationArgumentDefinition(Type implementationGenericArgumentDefinition, IEnumerable`1<KeyValuePair`2<Type, Type>> serviceArgumentDefinitionToArgument);
    public static void EnforceBindable(Type implementationType, IEnumerable`1<Service> services);
    private static bool IsCompatibleGenericClassDefinition(Type implementor, Type serviceType);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.OpenGenerics.OpenGenericServiceBinderResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ImplementorDoesntImplementService { get; }
    internal static string ImplementorMustBeOpenGenericTypeDefinition { get; }
    internal static string InterfaceIsNotImplemented { get; }
    internal static string ServiceTypeMustBeOpenGenericTypeDefinition { get; }
    internal static string TypesAreNotConvertible { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ImplementorDoesntImplementService();
    internal static string get_ImplementorMustBeOpenGenericTypeDefinition();
    internal static string get_InterfaceIsNotImplemented();
    internal static string get_ServiceTypeMustBeOpenGenericTypeDefinition();
    internal static string get_TypesAreNotConvertible();
}
public class Autofac.Features.OwnedInstances.Owned`1 : Disposable {
    private IDisposable _lifetime;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; public set; }
    public Owned`1(T value, IDisposable lifetime);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
    protected virtual void Dispose(bool disposing);
}
internal class Autofac.Features.OwnedInstances.OwnedInstanceRegistrationSource : object {
    public bool IsAdapterForIndividualComponents { get; }
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.OwnedInstances.OwnedInstanceRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string OwnedInstanceRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_OwnedInstanceRegistrationSourceDescription();
}
public class Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource : object {
    private Func`2<Type, bool> _predicate;
    [CompilerGeneratedAttribute]
private Action`1<IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>> <RegistrationConfiguration>k__BackingField;
    public bool IsAdapterForIndividualComponents { get; }
    public Action`1<IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>> RegistrationConfiguration { get; public set; }
    public AnyConcreteTypeNotAlreadyRegisteredSource(Func`2<Type, bool> predicate);
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    [CompilerGeneratedAttribute]
public Action`1<IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>> get_RegistrationConfiguration();
    [CompilerGeneratedAttribute]
public void set_RegistrationConfiguration(Action`1<IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>> value);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSourceExtensions : object {
    [ExtensionAttribute]
public static AnyConcreteTypeNotAlreadyRegisteredSource WithRegistrationsAs(AnyConcreteTypeNotAlreadyRegisteredSource source, Action`1<IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>> configurationAction);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AnyConcreteTypeNotAlreadyRegisteredSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AnyConcreteTypeNotAlreadyRegisteredSourceDescription();
}
public class Autofac.Features.Scanning.ScanningActivatorData : ReflectionActivatorData {
    [CompilerGeneratedAttribute]
private ICollection`1<Func`2<Type, bool>> <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<Action`2<Type, IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>>> <ConfigurationActions>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<Action`1<IComponentRegistry>> <PostScanningCallbacks>k__BackingField;
    public ICollection`1<Func`2<Type, bool>> Filters { get; }
    public ICollection`1<Action`2<Type, IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>>> ConfigurationActions { get; }
    public ICollection`1<Action`1<IComponentRegistry>> PostScanningCallbacks { get; }
    [CompilerGeneratedAttribute]
public ICollection`1<Func`2<Type, bool>> get_Filters();
    [CompilerGeneratedAttribute]
public ICollection`1<Action`2<Type, IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>>> get_ConfigurationActions();
    [CompilerGeneratedAttribute]
public ICollection`1<Action`1<IComponentRegistry>> get_PostScanningCallbacks();
}
[ExtensionAttribute]
internal static class Autofac.Features.Scanning.ScanningRegistrationExtensions : object {
    public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> RegisterAssemblyTypes(ContainerBuilder builder, Assembly[] assemblies);
    public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> RegisterTypes(ContainerBuilder builder, Type[] types);
    private static void ScanAssemblies(IEnumerable`1<Assembly> assemblies, IComponentRegistry cr, IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> rb);
    private static void ScanTypes(IEnumerable`1<Type> types, IComponentRegistry cr, IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> rb);
    public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AsClosedTypesOf(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type openGenericServiceType);
    public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AsClosedTypesOf(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type openGenericServiceType, object serviceKey);
    public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AsClosedTypesOf(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type openGenericServiceType, Func`2<Type, object> serviceKeyMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AssignableTo(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type type);
    public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> As(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, IEnumerable`1<Service>> serviceMapping);
    public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> PreserveExistingDefaults(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration);
}
public class Autofac.Features.Variance.ContravariantRegistrationSource : object {
    private static string IsContravariantAdapter;
    public bool IsAdapterForIndividualComponents { get; }
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    private static Type[] SubstituteArrayElementAt(Type[] array, Type newElement, int index);
    private static IEnumerable`1<Type> GetTypesAssignableFrom(Type type);
    [IteratorStateMachineAttribute("Autofac.Features.Variance.ContravariantRegistrationSource/<GetBagOfTypesAssignableFrom>d__4")]
private static IEnumerable`1<Type> GetBagOfTypesAssignableFrom(Type type);
    private static bool IsCompatibleInterfaceType(Type type, Int32& contravariantParameterIndex);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
}
public interface Autofac.IComponentContext {
    public IComponentRegistry ComponentRegistry { get; }
    public abstract virtual IComponentRegistry get_ComponentRegistry();
    public abstract virtual object ResolveComponent(IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
}
public interface Autofac.IContainer {
}
public interface Autofac.ILifetimeScope {
    public IDisposer Disposer { get; }
    public object Tag { get; }
    public abstract virtual ILifetimeScope BeginLifetimeScope();
    public abstract virtual ILifetimeScope BeginLifetimeScope(object tag);
    public abstract virtual ILifetimeScope BeginLifetimeScope(Action`1<ContainerBuilder> configurationAction);
    public abstract virtual ILifetimeScope BeginLifetimeScope(object tag, Action`1<ContainerBuilder> configurationAction);
    public abstract virtual IDisposer get_Disposer();
    public abstract virtual object get_Tag();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ChildLifetimeScopeBeginning(EventHandler`1<LifetimeScopeBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ChildLifetimeScopeBeginning(EventHandler`1<LifetimeScopeBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CurrentScopeEnding(EventHandler`1<LifetimeScopeEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CurrentScopeEnding(EventHandler`1<LifetimeScopeEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ResolveOperationBeginning(EventHandler`1<ResolveOperationBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ResolveOperationBeginning(EventHandler`1<ResolveOperationBeginningEventArgs> value);
}
public interface Autofac.IStartable {
    public abstract virtual void Start();
}
public abstract class Autofac.Module : object {
    protected Assembly ThisAssembly { get; }
    public sealed virtual void Configure(IComponentRegistry componentRegistry);
    protected virtual void Load(ContainerBuilder builder);
    protected virtual void AttachToComponentRegistration(IComponentRegistry componentRegistry, IComponentRegistration registration);
    protected virtual void AttachToRegistrationSource(IComponentRegistry componentRegistry, IRegistrationSource registrationSource);
    private void AttachToRegistrations(IComponentRegistry componentRegistry);
    private void AttachToSources(IComponentRegistry componentRegistry);
    protected virtual Assembly get_ThisAssembly();
    [CompilerGeneratedAttribute]
private void <AttachToRegistrations>b__4_0(object sender, ComponentRegisteredEventArgs e);
    [CompilerGeneratedAttribute]
private void <AttachToSources>b__5_0(object sender, RegistrationSourceAddedEventArgs e);
}
[ExtensionAttribute]
public static class Autofac.ModuleRegistrationExtensions : object {
    [ExtensionAttribute]
public static IModuleRegistrar RegisterAssemblyModules(ContainerBuilder builder, Assembly[] assemblies);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterAssemblyModules(IModuleRegistrar registrar, Assembly[] assemblies);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterAssemblyModules(ContainerBuilder builder, Assembly[] assemblies);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterAssemblyModules(IModuleRegistrar registrar, Assembly[] assemblies);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterAssemblyModules(ContainerBuilder builder, Type moduleType, Assembly[] assemblies);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterAssemblyModules(IModuleRegistrar registrar, Type moduleType, Assembly[] assemblies);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterModule(ContainerBuilder builder);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterModule(IModuleRegistrar registrar);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterModule(ContainerBuilder builder, IModule module);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.ModuleResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ThisAssemblyUnavailable { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ThisAssemblyUnavailable();
}
public class Autofac.NamedParameter : ConstantParameter {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public NamedParameter(string name, object value);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[ExtensionAttribute]
public static class Autofac.ParameterExtensions : object {
    [ExtensionAttribute]
public static T Named(IEnumerable`1<Parameter> parameters, string name);
    [ExtensionAttribute]
public static T Positional(IEnumerable`1<Parameter> parameters, int position);
    [ExtensionAttribute]
public static T TypedAs(IEnumerable`1<Parameter> parameters);
    private static TValue ConstantValue(IEnumerable`1<Parameter> parameters, Func`2<TParameter, bool> predicate);
}
public class Autofac.PositionalParameter : ConstantParameter {
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public int Position { get; private set; }
    public PositionalParameter(int position, object value);
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
}
[FlagsAttribute]
public enum Autofac.PropertyWiringOptions : Enum {
    public int value__;
    public static PropertyWiringOptions None;
    public static PropertyWiringOptions AllowCircularDependencies;
    public static PropertyWiringOptions PreserveSetValues;
}
[ExtensionAttribute]
public static class Autofac.RegistrationExtensions : object {
    [ExtensionAttribute]
public static void RegisterComponent(ContainerBuilder builder, IComponentRegistration registration);
    [ExtensionAttribute]
public static void RegisterSource(ContainerBuilder builder, IRegistrationSource registrationSource);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<T, SimpleActivatorData, SingleRegistrationStyle> RegisterInstance(ContainerBuilder builder, T instance);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TImplementer, ConcreteReflectionActivatorData, SingleRegistrationStyle> RegisterType(ContainerBuilder builder);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle> RegisterType(ContainerBuilder builder, Type implementationType);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<T, SimpleActivatorData, SingleRegistrationStyle> Register(ContainerBuilder builder, Func`2<IComponentContext, T> delegate);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<T, SimpleActivatorData, SingleRegistrationStyle> Register(ContainerBuilder builder, Func`3<IComponentContext, IEnumerable`1<Parameter>, T> delegate);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ReflectionActivatorData, DynamicRegistrationStyle> RegisterGeneric(ContainerBuilder builder, Type implementer);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> PreserveExistingDefaults(IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, ScanningActivatorData, TRegistrationStyle> PreserveExistingDefaults(IRegistrationBuilder`3<TLimit, ScanningActivatorData, TRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> RegisterAssemblyTypes(ContainerBuilder builder, Assembly[] assemblies);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> RegisterTypes(ContainerBuilder builder, Type[] types);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> Where(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, bool> predicate);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> As(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, IEnumerable`1<Service>> serviceMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> As(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, Service> serviceMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> As(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, Type> serviceMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> As(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, IEnumerable`1<Type>> serviceMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, ScanningActivatorData, DynamicRegistrationStyle> AsSelf(IRegistrationBuilder`3<TLimit, ScanningActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TConcreteActivatorData, SingleRegistrationStyle> AsSelf(IRegistrationBuilder`3<TLimit, TConcreteActivatorData, SingleRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, ReflectionActivatorData, DynamicRegistrationStyle> AsSelf(IRegistrationBuilder`3<TLimit, ReflectionActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> WithMetadata(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, IEnumerable`1<KeyValuePair`2<string, object>>> metadataMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> WithMetadataFrom(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> WithMetadata(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, string metadataKey, Func`2<Type, object> metadataValueMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> Named(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration, Func`2<Type, string> serviceNameMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> Named(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, string> serviceNameMapping, Type serviceType);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> Keyed(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration, Func`2<Type, object> serviceKeyMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> Keyed(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, object> serviceKeyMapping, Type serviceType);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, ScanningActivatorData, DynamicRegistrationStyle> AsImplementedInterfaces(IRegistrationBuilder`3<TLimit, ScanningActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TConcreteActivatorData, SingleRegistrationStyle> AsImplementedInterfaces(IRegistrationBuilder`3<TLimit, TConcreteActivatorData, SingleRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, ReflectionActivatorData, DynamicRegistrationStyle> AsImplementedInterfaces(IRegistrationBuilder`3<TLimit, ReflectionActivatorData, DynamicRegistrationStyle> registration);
    private static Type[] GetImplementedInterfaces(Type type);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> FindConstructorsWith(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, IConstructorFinder constructorFinder);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> FindConstructorsWith(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, Func`2<Type, ConstructorInfo[]> finder);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> PropertiesAutowired(IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> registration, PropertyWiringOptions wiringFlags);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> PropertiesAutowired(IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> registration, Func`3<PropertyInfo, object, bool> propertySelector);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> UsingConstructor(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, Type[] signature);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> UsingConstructor(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, IConstructorSelector constructorSelector);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> UsingConstructor(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, Expression`1<Func`1<TLimit>> constructorSelector);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithParameter(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, string parameterName, object parameterValue);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithParameter(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, Parameter parameter);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithParameter(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, Func`3<ParameterInfo, IComponentContext, bool> parameterSelector, Func`3<ParameterInfo, IComponentContext, object> valueProvider);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithParameters(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithProperty(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, string propertyName, object propertyValue);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithProperty(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, Parameter property);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithProperties(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, IEnumerable`1<Parameter> properties);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> Targeting(IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> registration, IComponentRegistration target);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> OnRegistered(IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> registration, Action`1<ComponentRegisteredEventArgs> handler);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, ScanningActivatorData, TRegistrationStyle> OnRegistered(IRegistrationBuilder`3<TLimit, ScanningActivatorData, TRegistrationStyle> registration, Action`1<ComponentRegisteredEventArgs> handler);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AsClosedTypesOf(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type openGenericServiceType);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AsClosedTypesOf(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type openGenericServiceType, object serviceKey);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AsClosedTypesOf(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type openGenericServiceType, Func`2<Type, object> serviceKeyMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AssignableTo(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type type);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> AssignableTo(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> Except(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> Except(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration, Action`1<IRegistrationBuilder`3<T, ConcreteReflectionActivatorData, SingleRegistrationStyle>> customizedRegistration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> InNamespaceOf(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> InNamespace(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, string ns);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TTo, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterAdapter(ContainerBuilder builder, Func`4<IComponentContext, IEnumerable`1<Parameter>, TFrom, TTo> adapter);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TTo, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterAdapter(ContainerBuilder builder, Func`3<IComponentContext, TFrom, TTo> adapter);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TTo, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterAdapter(ContainerBuilder builder, Func`2<TFrom, TTo> adapter);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, OpenGenericDecoratorActivatorData, DynamicRegistrationStyle> RegisterGenericDecorator(ContainerBuilder builder, Type decoratorType, Type decoratedServiceType, object fromKey, object toKey);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TService, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterDecorator(ContainerBuilder builder, Func`4<IComponentContext, IEnumerable`1<Parameter>, TService, TService> decorator, object fromKey, object toKey);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TService, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterDecorator(ContainerBuilder builder, Func`3<IComponentContext, TService, TService> decorator, object fromKey, object toKey);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TService, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterDecorator(ContainerBuilder builder, Func`2<TService, TService> decorator, object fromKey, object toKey);
    [ExtensionAttribute]
public static void RegisterDecorator(ContainerBuilder builder, Func`2<IDecoratorContext, bool> condition);
    [ExtensionAttribute]
public static void RegisterDecorator(ContainerBuilder builder, Type decoratorType, Type serviceType, Func`2<IDecoratorContext, bool> condition);
    [ExtensionAttribute]
public static void RegisterDecorator(ContainerBuilder builder, Func`4<IComponentContext, IEnumerable`1<Parameter>, TService, TService> decorator, Func`2<IDecoratorContext, bool> condition);
    [ExtensionAttribute]
public static void RegisterGenericDecorator(ContainerBuilder builder, Type decoratorType, Type serviceType, Func`2<IDecoratorContext, bool> condition);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnRelease(IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> registration, Action`1<TLimit> releaseAction);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> AutoActivate(IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> InstancePerRequest(IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> registration, Object[] lifetimeScopeTags);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> OnlyIf(IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> registration, Predicate`1<IComponentRegistry> predicate);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> IfNotRegistered(IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> registration, Type serviceType);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.RegistrationExtensionsResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string DecoratorRequiresInstanceParameter { get; }
    internal static string InstanceRegistrationsAreSingleInstanceOnly { get; }
    internal static string MetadataAttributeNotFound { get; }
    internal static string MultipleMetadataAttributesSameType { get; }
    internal static string NoMatchingConstructorExists { get; }
    internal static string OnlyIfRequiresCallbackContainer { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_DecoratorRequiresInstanceParameter();
    internal static string get_InstanceRegistrationsAreSingleInstanceOnly();
    internal static string get_MetadataAttributeNotFound();
    internal static string get_MultipleMetadataAttributesSameType();
    internal static string get_NoMatchingConstructorExists();
    internal static string get_OnlyIfRequiresCallbackContainer();
}
[ExtensionAttribute]
public static class Autofac.ResolutionExtensions : object {
    public static string PropertyInjectedInstanceTypeNamedParameter;
    private static IEnumerable`1<Parameter> NoParameters;
    private static ResolutionExtensions();
    [ExtensionAttribute]
public static TService InjectProperties(IComponentContext context, TService instance);
    [ExtensionAttribute]
public static TService InjectProperties(IComponentContext context, TService instance, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService InjectProperties(IComponentContext context, TService instance, Parameter[] parameters);
    [ExtensionAttribute]
public static TService InjectProperties(IComponentContext context, TService instance, IPropertySelector propertySelector);
    [ExtensionAttribute]
public static TService InjectProperties(IComponentContext context, TService instance, IPropertySelector propertySelector, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService InjectProperties(IComponentContext context, TService instance, IPropertySelector propertySelector, Parameter[] parameters);
    [ExtensionAttribute]
public static TService InjectUnsetProperties(IComponentContext context, TService instance);
    [ExtensionAttribute]
public static TService InjectUnsetProperties(IComponentContext context, TService instance, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService InjectUnsetProperties(IComponentContext context, TService instance, Parameter[] parameters);
    [ExtensionAttribute]
public static bool IsRegistered(IComponentContext context);
    [ExtensionAttribute]
public static bool IsRegistered(IComponentContext context, Type serviceType);
    [ExtensionAttribute]
public static bool IsRegisteredService(IComponentContext context, Service service);
    [ExtensionAttribute]
public static bool IsRegisteredWithKey(IComponentContext context, object serviceKey);
    [ExtensionAttribute]
public static bool IsRegisteredWithKey(IComponentContext context, object serviceKey, Type serviceType);
    [ExtensionAttribute]
public static bool IsRegisteredWithName(IComponentContext context, string serviceName);
    [ExtensionAttribute]
public static bool IsRegisteredWithName(IComponentContext context, string serviceName, Type serviceType);
    [ExtensionAttribute]
public static TService Resolve(IComponentContext context);
    [ExtensionAttribute]
public static TService Resolve(IComponentContext context, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService Resolve(IComponentContext context, Parameter[] parameters);
    [ExtensionAttribute]
public static object Resolve(IComponentContext context, Type serviceType);
    [ExtensionAttribute]
public static object Resolve(IComponentContext context, Type serviceType, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static object Resolve(IComponentContext context, Type serviceType, Parameter[] parameters);
    [ExtensionAttribute]
public static TService ResolveKeyed(IComponentContext context, object serviceKey);
    [ExtensionAttribute]
public static TService ResolveKeyed(IComponentContext context, object serviceKey, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService ResolveKeyed(IComponentContext context, object serviceKey, Parameter[] parameters);
    [ExtensionAttribute]
public static object ResolveKeyed(IComponentContext context, object serviceKey, Type serviceType);
    [ExtensionAttribute]
public static object ResolveKeyed(IComponentContext context, object serviceKey, Type serviceType, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static object ResolveKeyed(IComponentContext context, object serviceKey, Type serviceType, Parameter[] parameters);
    [ExtensionAttribute]
public static TService ResolveNamed(IComponentContext context, string serviceName);
    [ExtensionAttribute]
public static TService ResolveNamed(IComponentContext context, string serviceName, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService ResolveNamed(IComponentContext context, string serviceName, Parameter[] parameters);
    [ExtensionAttribute]
public static object ResolveNamed(IComponentContext context, string serviceName, Type serviceType);
    [ExtensionAttribute]
public static object ResolveNamed(IComponentContext context, string serviceName, Type serviceType, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static object ResolveNamed(IComponentContext context, string serviceName, Type serviceType, Parameter[] parameters);
    [ExtensionAttribute]
public static TService ResolveOptional(IComponentContext context);
    [ExtensionAttribute]
public static TService ResolveOptional(IComponentContext context, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService ResolveOptional(IComponentContext context, Parameter[] parameters);
    [ExtensionAttribute]
public static object ResolveOptional(IComponentContext context, Type serviceType);
    [ExtensionAttribute]
public static object ResolveOptional(IComponentContext context, Type serviceType, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static object ResolveOptional(IComponentContext context, Type serviceType, Parameter[] parameters);
    [ExtensionAttribute]
public static TService ResolveOptionalKeyed(IComponentContext context, object serviceKey);
    [ExtensionAttribute]
public static TService ResolveOptionalKeyed(IComponentContext context, object serviceKey, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService ResolveOptionalKeyed(IComponentContext context, object serviceKey, Parameter[] parameters);
    [ExtensionAttribute]
public static TService ResolveOptionalNamed(IComponentContext context, string serviceName);
    [ExtensionAttribute]
public static TService ResolveOptionalNamed(IComponentContext context, string serviceName, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService ResolveOptionalNamed(IComponentContext context, string serviceName, Parameter[] parameters);
    [ExtensionAttribute]
public static object ResolveOptionalService(IComponentContext context, Service service);
    [ExtensionAttribute]
public static object ResolveOptionalService(IComponentContext context, Service service, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static object ResolveOptionalService(IComponentContext context, Service service, Parameter[] parameters);
    [ExtensionAttribute]
public static object ResolveService(IComponentContext context, Service service);
    [ExtensionAttribute]
public static object ResolveService(IComponentContext context, Service service, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static object ResolveService(IComponentContext context, Service service, Parameter[] parameters);
    [ExtensionAttribute]
public static bool TryResolve(IComponentContext context, T& instance);
    [ExtensionAttribute]
public static bool TryResolve(IComponentContext context, Type serviceType, Object& instance);
    [ExtensionAttribute]
public static bool TryResolveKeyed(IComponentContext context, object serviceKey, Type serviceType, Object& instance);
    [ExtensionAttribute]
public static bool TryResolveNamed(IComponentContext context, string serviceName, Type serviceType, Object& instance);
    [ExtensionAttribute]
public static bool TryResolveService(IComponentContext context, Service service, Object& instance);
    [ExtensionAttribute]
public static bool TryResolveService(IComponentContext context, Service service, IEnumerable`1<Parameter> parameters, Object& instance);
}
[ExtensionAttribute]
public static class Autofac.ScanningFilterExtensions : object {
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> PublicOnly(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration);
}
[ExtensionAttribute]
public static class Autofac.SourceRegistrationExtensions : object {
    [ExtensionAttribute]
public static ISourceRegistrar RegisterSource(ContainerBuilder builder);
    [ExtensionAttribute]
public static ISourceRegistrar RegisterSource(ISourceRegistrar registrar);
}
public class Autofac.TypedParameter : ConstantParameter {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; private set; }
    public TypedParameter(Type type, object value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    public static TypedParameter From(T value);
}
[ExtensionAttribute]
public static class Autofac.TypeExtensions : object {
    [ExtensionAttribute]
public static bool IsInNamespace(Type this, string namespace);
    [ExtensionAttribute]
public static bool IsInNamespaceOf(Type this);
    [ExtensionAttribute]
public static bool IsClosedTypeOf(Type this, Type openGeneric);
    [ExtensionAttribute]
public static bool IsAssignableTo(Type this);
    [ExtensionAttribute]
public static ConstructorInfo GetMatchingConstructor(Type type, Type[] constructorParameterTypes);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.TypeExtensionsResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NotOpenGenericType { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NotOpenGenericType();
}
[ExtensionAttribute]
public static class Autofac.Util.AssemblyExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetLoadableTypes(Assembly assembly);
}
public class Autofac.Util.Disposable : object {
    private static int DisposedFlag;
    private int _isDisposed;
    protected bool IsDisposed { get; }
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected bool get_IsDisposed();
}
internal static class Autofac.Util.Enforce : object {
    public static IEnumerable`1<T> ArgumentElementNotNull(IEnumerable`1<T> value, string name);
    public static T NotNull(T value);
    public static string ArgumentNotNullOrEmpty(string value, string description);
    public static void ArgumentTypeIsFunction(Type delegateType);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Util.EnforceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CannotBeEmpty { get; }
    internal static string CannotBeNull { get; }
    internal static string DelegateReturnsVoid { get; }
    internal static string ElementCannotBeNull { get; }
    internal static string NotDelegate { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CannotBeEmpty();
    internal static string get_CannotBeNull();
    internal static string get_DelegateReturnsVoid();
    internal static string get_ElementCannotBeNull();
    internal static string get_NotDelegate();
}
[DefaultMemberAttribute("Item")]
internal class Autofac.Util.FallbackDictionary`2 : object {
    private IDictionary`2<TKey, TValue> _localValues;
    [CompilerGeneratedAttribute]
private IDictionary`2<TKey, TValue> <Parent>k__BackingField;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public IDictionary`2<TKey, TValue> Parent { get; private set; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public FallbackDictionary`2(IDictionary`2<TKey, TValue> parent);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    [CompilerGeneratedAttribute]
public IDictionary`2<TKey, TValue> get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(IDictionary`2<TKey, TValue> value);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    [IteratorStateMachineAttribute("Autofac.Util.FallbackDictionary`2/<GetEnumerator>d__24")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IEnumerable`1<TKey> OrderedKeys();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Util.FallbackDictionaryResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string DuplicateItem { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_DuplicateItem();
}
[ExtensionAttribute]
internal static class Autofac.Util.ReflectionExtensions : object {
    [ExtensionAttribute]
public static bool TryGetDeclaringProperty(ParameterInfo pi, PropertyInfo& prop);
    public static PropertyInfo GetProperty(Expression`1<Func`2<TDeclaring, TProperty>> propertyAccessor);
    public static MethodInfo GetMethod(Expression`1<Action`1<TDeclaring>> methodCallExpression);
    public static ConstructorInfo GetConstructor(Expression`1<Func`1<TDeclaring>> constructorCallExpression);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Util.ReflectionExtensionsResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ExpressionNotConstructorCall { get; }
    internal static string ExpressionNotMethodCall { get; }
    internal static string ExpressionNotPropertyAccessor { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ExpressionNotConstructorCall();
    internal static string get_ExpressionNotMethodCall();
    internal static string get_ExpressionNotPropertyAccessor();
}
internal class Autofac.Util.ReleaseAction`1 : Disposable {
    private Action`1<TLimit> _action;
    private Func`1<TLimit> _factory;
    public ReleaseAction`1(Action`1<TLimit> action, Func`1<TLimit> factory);
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
internal static class Autofac.Util.SequenceExtensions : object {
    [ExtensionAttribute]
public static string JoinWith(IEnumerable`1<string> elements, string separator);
    [IteratorStateMachineAttribute("Autofac.Util.SequenceExtensions/<AppendItem>d__1`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> AppendItem(IEnumerable`1<T> sequence, T trailingItem);
    [IteratorStateMachineAttribute("Autofac.Util.SequenceExtensions/<Prepend>d__2`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Prepend(IEnumerable`1<T> sequence, T leadingItem);
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> items);
}
internal static class Autofac.Util.SequenceGenerator : object {
    private static long _lastSequence;
    internal static long GetNextUniqueSequence();
}
internal static class Autofac.Util.Traverse : object {
    [IteratorStateMachineAttribute("Autofac.Util.Traverse/<Across>d__0`1")]
public static IEnumerable`1<T> Across(T first, Func`2<T, T> next);
}
[ExtensionAttribute]
internal static class Autofac.Util.TypeExtensions : object {
    private static ConcurrentDictionary`2<Type, bool> IsGenericEnumerableInterfaceCache;
    private static ConcurrentDictionary`2<Type, bool> IsGenericListOrCollectionInterfaceTypeCache;
    private static ConcurrentDictionary`2<Tuple`2<Type, Type>, bool> IsGenericTypeDefinedByCache;
    private static TypeExtensions();
    [ExtensionAttribute]
public static Type FunctionReturnType(Type type);
    [ExtensionAttribute]
public static bool IsOpenGeneric(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetTypesThatClose(Type this, Type openGeneric);
    [ExtensionAttribute]
public static bool IsClosedTypeOf(Type this, Type openGeneric);
    [ExtensionAttribute]
public static bool IsCompatibleWithGenericParameterConstraints(Type genericTypeDefinition, Type[] parameters);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(Type type);
    [ExtensionAttribute]
public static bool IsDelegate(Type type);
    [ExtensionAttribute]
public static bool IsGenericEnumerableInterfaceType(Type type);
    [ExtensionAttribute]
public static bool IsGenericListOrCollectionInterfaceType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinedBy(Type this, Type openGeneric);
    private static IEnumerable`1<Type> FindAssignableTypesThatClose(Type candidateType, Type openGenericServiceType);
    private static Type SubstituteGenericParameterConstraint(Type[] parameters, Type constraint);
    private static bool ParameterCompatibleWithTypeConstraint(Type parameter, Type constraint);
    private static bool ParameterEqualsConstraint(Type parameter, Type constraint);
    private static IEnumerable`1<Type> TypesAssignableFrom(Type candidateType);
}
[AttributeUsageAttribute("2048")]
internal class Autofac.Util.ValidatedNotNullAttribute : Attribute {
}
public class CommandLine.BadFormatConversionError : NamedError {
    internal BadFormatConversionError(NameInfo nameInfo);
}
public class CommandLine.BadFormatTokenError : TokenError {
    internal BadFormatTokenError(string token);
}
public class CommandLine.BadVerbSelectedError : TokenError {
    internal BadVerbSelectedError(string token);
}
public abstract class CommandLine.BaseAttribute : Attribute {
    private int min;
    private int max;
    private object default;
    private LocalizableAttributeProperty helpText;
    private string metaValue;
    private Type resourceType;
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Hidden>k__BackingField;
    public bool Required { get; public set; }
    public int Min { get; public set; }
    public int Max { get; public set; }
    public object Default { get; public set; }
    public string HelpText { get; public set; }
    public string MetaValue { get; public set; }
    public bool Hidden { get; public set; }
    public Type ResourceType { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(bool value);
    public int get_Min();
    public void set_Min(int value);
    public int get_Max();
    public void set_Max(int value);
    public object get_Default();
    public void set_Default(object value);
    public string get_HelpText();
    public void set_HelpText(string value);
    public string get_MetaValue();
    public void set_MetaValue(string value);
    [CompilerGeneratedAttribute]
public bool get_Hidden();
    [CompilerGeneratedAttribute]
public void set_Hidden(bool value);
    public Type get_ResourceType();
    public void set_ResourceType(Type value);
}
[ExtensionAttribute]
public static class CommandLine.CastExtensions : object {
    private static string ImplicitCastMethodName;
    private static string ExplicitCastMethodName;
    [ExtensionAttribute]
public static bool CanCast(Type baseType);
    [ExtensionAttribute]
public static bool CanCast(object obj);
    [ExtensionAttribute]
public static T Cast(object obj);
    [ExtensionAttribute]
private static bool CanImplicitCast(Type baseType);
    [ExtensionAttribute]
private static bool CanImplicitCast(object obj);
    [ExtensionAttribute]
private static bool CanExplicitCast(Type baseType);
    [ExtensionAttribute]
private static bool CanExplicitCast(object obj);
    [ExtensionAttribute]
private static bool CanCast(Type baseType, string castMethodName);
    [ExtensionAttribute]
private static T ImplicitCast(object obj);
    [ExtensionAttribute]
private static T ExplicitCast(object obj);
    [ExtensionAttribute]
private static T Cast(object obj, string castMethodName);
}
[ExtensionAttribute]
internal static class CommandLine.Core.ArgumentsExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Error> Preprocess(IEnumerable`1<string> arguments, IEnumerable`1<Func`2<IEnumerable`1<string>, IEnumerable`1<Error>>> preprocessorLookup);
}
internal static class CommandLine.Core.GetoptTokenizer : object {
    public static Result`2<IEnumerable`1<Token>, Error> Tokenize(IEnumerable`1<string> arguments, Func`2<string, NameLookupResult> nameLookup);
    public static Result`2<IEnumerable`1<Token>, Error> Tokenize(IEnumerable`1<string> arguments, Func`2<string, NameLookupResult> nameLookup, bool ignoreUnknownArguments, bool allowDashDash, bool posixlyCorrect);
    public static Result`2<IEnumerable`1<Token>, Error> ExplodeOptionList(Result`2<IEnumerable`1<Token>, Error> tokenizerResult, Func`2<string, Maybe`1<char>> optionSequenceWithSeparatorLookup);
    public static Func`3<IEnumerable`1<string>, IEnumerable`1<OptionSpecification>, Result`2<IEnumerable`1<Token>, Error>> ConfigureTokenizer(StringComparer nameComparer, bool ignoreUnknownArguments, bool enableDashDash, bool posixlyCorrect);
    [IteratorStateMachineAttribute("CommandLine.Core.GetoptTokenizer/<TokenizeShortName>d__4")]
private static IEnumerable`1<Token> TokenizeShortName(string arg, Func`2<string, NameLookupResult> nameLookup, Action`1<string> onUnknownOption, Action`1<int> onConsumeNext);
    [IteratorStateMachineAttribute("CommandLine.Core.GetoptTokenizer/<TokenizeLongName>d__5")]
private static IEnumerable`1<Token> TokenizeLongName(string arg, Func`2<string, NameLookupResult> nameLookup, Action`1<string> onBadFormatToken, Action`1<string> onUnknownOption, Action`1<int> onConsumeNext);
}
internal static class CommandLine.Core.InstanceBuilder : object {
    public static ParserResult`1<T> Build(Maybe`1<Func`1<T>> factory, Func`3<IEnumerable`1<string>, IEnumerable`1<OptionSpecification>, Result`2<IEnumerable`1<Token>, Error>> tokenizer, IEnumerable`1<string> arguments, StringComparer nameComparer, bool ignoreValueCase, CultureInfo parsingCulture, bool autoHelp, bool autoVersion, IEnumerable`1<ErrorType> nonFatalErrors);
    public static ParserResult`1<T> Build(Maybe`1<Func`1<T>> factory, Func`3<IEnumerable`1<string>, IEnumerable`1<OptionSpecification>, Result`2<IEnumerable`1<Token>, Error>> tokenizer, IEnumerable`1<string> arguments, StringComparer nameComparer, bool ignoreValueCase, CultureInfo parsingCulture, bool autoHelp, bool autoVersion, bool allowMultiInstance, IEnumerable`1<ErrorType> nonFatalErrors);
    private static T BuildMutable(Maybe`1<Func`1<T>> factory, IEnumerable`1<SpecificationProperty> specPropsWithValue, List`1<Error> setPropertyErrors);
    private static T BuildImmutable(Type typeInfo, Maybe`1<Func`1<T>> factory, IEnumerable`1<SpecificationProperty> specProps, IEnumerable`1<SpecificationProperty> specPropsWithValue, List`1<Error> setPropertyErrors);
}
internal static class CommandLine.Core.InstanceChooser : object {
    public static ParserResult`1<object> Choose(Func`3<IEnumerable`1<string>, IEnumerable`1<OptionSpecification>, Result`2<IEnumerable`1<Token>, Error>> tokenizer, IEnumerable`1<Type> types, IEnumerable`1<string> arguments, StringComparer nameComparer, bool ignoreValueCase, CultureInfo parsingCulture, bool autoHelp, bool autoVersion, IEnumerable`1<ErrorType> nonFatalErrors);
    public static ParserResult`1<object> Choose(Func`3<IEnumerable`1<string>, IEnumerable`1<OptionSpecification>, Result`2<IEnumerable`1<Token>, Error>> tokenizer, IEnumerable`1<Type> types, IEnumerable`1<string> arguments, StringComparer nameComparer, bool ignoreValueCase, CultureInfo parsingCulture, bool autoHelp, bool autoVersion, bool allowMultiInstance, IEnumerable`1<ErrorType> nonFatalErrors);
    private static ParserResult`1<object> MatchDefaultVerb(Func`3<IEnumerable`1<string>, IEnumerable`1<OptionSpecification>, Result`2<IEnumerable`1<Token>, Error>> tokenizer, IEnumerable`1<Tuple`2<Verb, Type>> verbs, Tuple`2<Verb, Type> defaultVerb, IEnumerable`1<string> arguments, StringComparer nameComparer, bool ignoreValueCase, CultureInfo parsingCulture, bool autoHelp, bool autoVersion, IEnumerable`1<ErrorType> nonFatalErrors);
    private static ParserResult`1<object> MatchVerb(Func`3<IEnumerable`1<string>, IEnumerable`1<OptionSpecification>, Result`2<IEnumerable`1<Token>, Error>> tokenizer, IEnumerable`1<Tuple`2<Verb, Type>> verbs, Tuple`2<Verb, Type> defaultVerb, IEnumerable`1<string> arguments, StringComparer nameComparer, bool ignoreValueCase, CultureInfo parsingCulture, bool autoHelp, bool autoVersion, bool allowMultiInstance, IEnumerable`1<ErrorType> nonFatalErrors);
    private static HelpVerbRequestedError MakeHelpVerbRequestedError(IEnumerable`1<Tuple`2<Verb, Type>> verbs, string verb, StringComparer nameComparer);
    private static NotParsed`1<object> MakeNotParsed(IEnumerable`1<Type> types, Error[] errors);
    [CompilerGeneratedAttribute]
internal static ParserResult`1<object> <Choose>g__choose|1_1(<>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static bool <Choose>g__preprocCompare|1_2(string command, <>c__DisplayClass1_0& , <>c__DisplayClass1_1& );
}
[ExtensionAttribute]
internal static class CommandLine.Core.KeyValuePairHelper : object {
    public static IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> ForSwitch(IEnumerable`1<Token> tokens);
    public static IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> ForScalar(IEnumerable`1<Token> tokens);
    public static IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> ForSequence(IEnumerable`1<Token> tokens);
    [ExtensionAttribute]
private static KeyValuePair`2<string, IEnumerable`1<string>> ToKeyValuePair(string value, String[] values);
}
internal class CommandLine.Core.Name : Token {
    public Name(string text);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Name other);
}
[ExtensionAttribute]
internal static class CommandLine.Core.NameExtensions : object {
    [ExtensionAttribute]
public static bool MatchName(string value, string shortName, string longName, StringComparer comparer);
    [ExtensionAttribute]
public static NameInfo FromOptionSpecification(OptionSpecification specification);
    [ExtensionAttribute]
public static NameInfo FromSpecification(Specification specification);
}
internal static class CommandLine.Core.NameLookup : object {
    public static NameLookupResult Contains(string name, IEnumerable`1<OptionSpecification> specifications, StringComparer comparer);
    public static Maybe`1<char> HavingSeparator(string name, IEnumerable`1<OptionSpecification> specifications, StringComparer comparer);
}
internal enum CommandLine.Core.NameLookupResult : Enum {
    public int value__;
    public static NameLookupResult NoOptionFound;
    public static NameLookupResult BooleanOptionFound;
    public static NameLookupResult OtherOptionFound;
}
internal static class CommandLine.Core.OptionMapper : object {
    public static Result`2<IEnumerable`1<SpecificationProperty>, Error> MapValues(IEnumerable`1<SpecificationProperty> propertyTuples, IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> options, Func`5<IEnumerable`1<string>, Type, bool, bool, Maybe`1<object>> converter, StringComparer comparer);
}
internal class CommandLine.Core.OptionSpecification : Specification {
    private string shortName;
    private string longName;
    private char separator;
    private string setName;
    private string group;
    private bool flagCounter;
    public string ShortName { get; }
    public string LongName { get; }
    public char Separator { get; }
    public string SetName { get; }
    public string Group { get; }
    public bool FlagCounter { get; }
    public OptionSpecification(string shortName, string longName, bool required, string setName, Maybe`1<int> min, Maybe`1<int> max, char separator, Maybe`1<object> defaultValue, string helpText, string metaValue, IEnumerable`1<string> enumValues, Type conversionType, TargetType targetType, string group, bool flagCounter, bool hidden);
    public static OptionSpecification FromAttribute(OptionAttribute attribute, Type conversionType, IEnumerable`1<string> enumValues);
    public static OptionSpecification NewSwitch(string shortName, string longName, bool required, string helpText, string metaValue, bool hidden);
    public string get_ShortName();
    public string get_LongName();
    public char get_Separator();
    public string get_SetName();
    public string get_Group();
    public bool get_FlagCounter();
}
[ExtensionAttribute]
internal static class CommandLine.Core.PartitionExtensions : object {
    [ExtensionAttribute]
public static Tuple`2<IEnumerable`1<T>, IEnumerable`1<T>> PartitionByPredicate(IEnumerable`1<T> items, Func`2<T, bool> pred);
}
internal static class CommandLine.Core.PreprocessorGuards : object {
    public static IEnumerable`1<Func`2<IEnumerable`1<string>, IEnumerable`1<Error>>> Lookup(StringComparer nameComparer, bool autoHelp, bool autoVersion);
    public static Func`2<IEnumerable`1<string>, IEnumerable`1<Error>> HelpCommand(StringComparer nameComparer);
    public static Func`2<IEnumerable`1<string>, IEnumerable`1<Error>> VersionCommand(StringComparer nameComparer);
}
[ExtensionAttribute]
internal static class CommandLine.Core.ReflectionExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> GetSpecifications(Type type, Func`2<PropertyInfo, T> selector);
    [ExtensionAttribute]
public static Maybe`1<VerbAttribute> GetVerbSpecification(Type type);
    [ExtensionAttribute]
public static Maybe`1<Tuple`2<PropertyInfo, UsageAttribute>> GetUsageData(Type type);
    [IteratorStateMachineAttribute("CommandLine.Core.ReflectionExtensions/<FlattenHierarchy>d__3")]
[ExtensionAttribute]
private static IEnumerable`1<Type> FlattenHierarchy(Type type);
    [ExtensionAttribute]
private static IEnumerable`1<Type> SafeGetInterfaces(Type type);
    [ExtensionAttribute]
public static TargetType ToTargetType(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<Error> SetProperties(T instance, IEnumerable`1<SpecificationProperty> specProps, Func`2<SpecificationProperty, bool> predicate, Func`2<SpecificationProperty, object> selector);
    [ExtensionAttribute]
private static IEnumerable`1<Error> SetValue(SpecificationProperty specProp, T instance, object value);
    [ExtensionAttribute]
public static object CreateEmptyArray(Type type);
    [ExtensionAttribute]
public static object GetDefaultValue(Type type);
    [ExtensionAttribute]
public static bool IsMutable(Type type);
    [ExtensionAttribute]
public static object CreateDefaultForImmutable(Type type);
    [ExtensionAttribute]
public static object AutoDefault(Type type);
    [ExtensionAttribute]
public static TypeInfo ToTypeInfo(Type type);
    [ExtensionAttribute]
public static object StaticMethod(Type type, string name, Object[] args);
    [ExtensionAttribute]
public static object StaticProperty(Type type, string name);
    [ExtensionAttribute]
public static object InstanceProperty(Type type, string name, object target);
    [ExtensionAttribute]
public static bool IsPrimitiveEx(Type type);
    [ExtensionAttribute]
public static bool IsCustomStruct(Type type);
}
internal abstract class CommandLine.Core.Specification : object {
    private SpecificationType tag;
    private bool required;
    private bool hidden;
    private Maybe`1<int> min;
    private Maybe`1<int> max;
    private Maybe`1<object> defaultValue;
    private string helpText;
    private string metaValue;
    private IEnumerable`1<string> enumValues;
    private Type conversionType;
    private TargetType targetType;
    public SpecificationType Tag { get; }
    public bool Required { get; }
    public Maybe`1<int> Min { get; }
    public Maybe`1<int> Max { get; }
    public Maybe`1<object> DefaultValue { get; }
    public string HelpText { get; }
    public string MetaValue { get; }
    public IEnumerable`1<string> EnumValues { get; }
    public Type ConversionType { get; }
    public TargetType TargetType { get; }
    public bool Hidden { get; }
    protected Specification(SpecificationType tag, bool required, Maybe`1<int> min, Maybe`1<int> max, Maybe`1<object> defaultValue, string helpText, string metaValue, IEnumerable`1<string> enumValues, Type conversionType, TargetType targetType, bool hidden);
    public SpecificationType get_Tag();
    public bool get_Required();
    public Maybe`1<int> get_Min();
    public Maybe`1<int> get_Max();
    public Maybe`1<object> get_DefaultValue();
    public string get_HelpText();
    public string get_MetaValue();
    public IEnumerable`1<string> get_EnumValues();
    public Type get_ConversionType();
    public TargetType get_TargetType();
    public bool get_Hidden();
    public static Specification FromProperty(PropertyInfo property);
}
[ExtensionAttribute]
internal static class CommandLine.Core.SpecificationExtensions : object {
    [ExtensionAttribute]
public static bool IsOption(Specification specification);
    [ExtensionAttribute]
public static bool IsValue(Specification specification);
    [ExtensionAttribute]
public static OptionSpecification WithLongName(OptionSpecification specification, string newLongName);
    [ExtensionAttribute]
public static string UniqueName(OptionSpecification specification);
    [ExtensionAttribute]
public static IEnumerable`1<Specification> ThrowingValidate(IEnumerable`1<Specification> specifications, IEnumerable`1<Tuple`2<Func`2<Specification, bool>, string>> guardsLookup);
    [ExtensionAttribute]
public static bool HavingRange(Specification specification, Func`3<int, int, bool> predicate);
    [ExtensionAttribute]
public static bool HavingMin(Specification specification, Func`2<int, bool> predicate);
    [ExtensionAttribute]
public static bool HavingMax(Specification specification, Func`2<int, bool> predicate);
}
internal static class CommandLine.Core.SpecificationGuards : object {
    public static IEnumerable`1<Tuple`2<Func`2<Specification, bool>, string>> Lookup;
    private static SpecificationGuards();
    private static Func`2<Specification, bool> GuardAgainstScalarWithRange();
    private static Func`2<Specification, bool> GuardAgainstSequenceWithWrongRange();
    private static Func`2<Specification, bool> GuardAgainstOneCharLongName();
    private static Func`2<Specification, bool> GuardAgainstSequenceWithZeroRange();
}
internal class CommandLine.Core.SpecificationProperty : object {
    private Specification specification;
    private PropertyInfo property;
    private Maybe`1<object> value;
    public Specification Specification { get; }
    public PropertyInfo Property { get; }
    public Maybe`1<object> Value { get; }
    private SpecificationProperty(Specification specification, PropertyInfo property, Maybe`1<object> value);
    public static SpecificationProperty Create(Specification specification, PropertyInfo property, Maybe`1<object> value);
    public Specification get_Specification();
    public PropertyInfo get_Property();
    public Maybe`1<object> get_Value();
}
[ExtensionAttribute]
internal static class CommandLine.Core.SpecificationPropertyExtensions : object {
    [ExtensionAttribute]
public static SpecificationProperty WithSpecification(SpecificationProperty specProp, Specification newSpecification);
    [ExtensionAttribute]
public static SpecificationProperty WithValue(SpecificationProperty specProp, Maybe`1<object> newValue);
    [ExtensionAttribute]
public static Type GetConversionType(SpecificationProperty specProp);
    [ExtensionAttribute]
public static IEnumerable`1<Error> Validate(IEnumerable`1<SpecificationProperty> specProps, IEnumerable`1<Func`2<IEnumerable`1<SpecificationProperty>, IEnumerable`1<Error>>> rules);
}
[ExtensionAttribute]
internal static class CommandLine.Core.SpecificationPropertyRules : object {
    public static IEnumerable`1<Func`2<IEnumerable`1<SpecificationProperty>, IEnumerable`1<Error>>> Lookup(IEnumerable`1<Token> tokens);
    public static IEnumerable`1<Func`2<IEnumerable`1<SpecificationProperty>, IEnumerable`1<Error>>> Lookup(IEnumerable`1<Token> tokens, bool allowMultiInstance);
    private static Func`2<IEnumerable`1<SpecificationProperty>, IEnumerable`1<Error>> EnforceMutuallyExclusiveSetAndGroupAreNotUsedTogether();
    private static Func`2<IEnumerable`1<SpecificationProperty>, IEnumerable`1<Error>> EnforceGroup();
    private static Func`2<IEnumerable`1<SpecificationProperty>, IEnumerable`1<Error>> EnforceMutuallyExclusiveSet();
    private static Func`2<IEnumerable`1<SpecificationProperty>, IEnumerable`1<Error>> EnforceRequired();
    private static Func`2<IEnumerable`1<SpecificationProperty>, IEnumerable`1<Error>> EnforceRange();
    private static Func`2<IEnumerable`1<SpecificationProperty>, IEnumerable`1<Error>> EnforceSingle(IEnumerable`1<Token> tokens, bool allowMultiInstance);
    [ExtensionAttribute]
private static bool ContainsIfNotEmpty(IEnumerable`1<T> sequence, T value);
}
internal enum CommandLine.Core.SpecificationType : Enum {
    public int value__;
    public static SpecificationType Option;
    public static SpecificationType Value;
}
internal enum CommandLine.Core.TargetType : Enum {
    public int value__;
    public static TargetType Switch;
    public static TargetType Scalar;
    public static TargetType Sequence;
}
internal abstract class CommandLine.Core.Token : object {
    private TokenType tag;
    private string text;
    public TokenType Tag { get; }
    public string Text { get; }
    protected Token(TokenType tag, string text);
    public static Token Name(string text);
    public static Token Value(string text);
    public static Token Value(string text, bool explicitlyAssigned);
    public static Token ValueForced(string text);
    public static Token ValueFromSeparator(string text);
    public TokenType get_Tag();
    public string get_Text();
}
[ExtensionAttribute]
internal static class CommandLine.Core.TokenExtensions : object {
    [ExtensionAttribute]
public static bool IsName(Token token);
    [ExtensionAttribute]
public static bool IsValue(Token token);
    [ExtensionAttribute]
public static bool IsValueFromSeparator(Token token);
    [ExtensionAttribute]
public static bool IsValueForced(Token token);
}
internal static class CommandLine.Core.Tokenizer : object {
    public static Result`2<IEnumerable`1<Token>, Error> Tokenize(IEnumerable`1<string> arguments, Func`2<string, NameLookupResult> nameLookup);
    public static Result`2<IEnumerable`1<Token>, Error> Tokenize(IEnumerable`1<string> arguments, Func`2<string, NameLookupResult> nameLookup, Func`2<IEnumerable`1<Token>, IEnumerable`1<Token>> normalize);
    public static Result`2<IEnumerable`1<Token>, Error> PreprocessDashDash(IEnumerable`1<string> arguments, Func`2<IEnumerable`1<string>, Result`2<IEnumerable`1<Token>, Error>> tokenizer);
    public static Result`2<IEnumerable`1<Token>, Error> ExplodeOptionList(Result`2<IEnumerable`1<Token>, Error> tokenizerResult, Func`2<string, Maybe`1<char>> optionSequenceWithSeparatorLookup);
    public static IEnumerable`1<Token> Normalize(IEnumerable`1<Token> tokens, Func`2<string, bool> nameLookup);
    public static Func`3<IEnumerable`1<string>, IEnumerable`1<OptionSpecification>, Result`2<IEnumerable`1<Token>, Error>> ConfigureTokenizer(StringComparer nameComparer, bool ignoreUnknownArguments, bool enableDashDash);
    [IteratorStateMachineAttribute("CommandLine.Core.Tokenizer/<TokenizeShortName>d__6")]
private static IEnumerable`1<Token> TokenizeShortName(string value, Func`2<string, NameLookupResult> nameLookup);
    [IteratorStateMachineAttribute("CommandLine.Core.Tokenizer/<TokenizeLongName>d__7")]
private static IEnumerable`1<Token> TokenizeLongName(string value, Action`1<Error> onError);
}
internal static class CommandLine.Core.TokenPartitioner : object {
    public static Tuple`3<IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>>, IEnumerable`1<string>, IEnumerable`1<Token>> Partition(IEnumerable`1<Token> tokens, Func`2<string, Maybe`1<TypeDescriptor>> typeLookup);
    public static Tuple`4<IEnumerable`1<Token>, IEnumerable`1<Token>, IEnumerable`1<Token>, IEnumerable`1<Token>> PartitionTokensByType(IEnumerable`1<Token> tokens, Func`2<string, Maybe`1<TypeDescriptor>> typeLookup);
}
internal enum CommandLine.Core.TokenType : Enum {
    public int value__;
    public static TokenType Name;
    public static TokenType Value;
}
[ExtensionAttribute]
internal static class CommandLine.Core.TypeConverter : object {
    public static Maybe`1<object> ChangeType(IEnumerable`1<string> values, Type conversionType, bool scalar, bool isFlag, CultureInfo conversionCulture, bool ignoreValueCase);
    private static Maybe`1<object> ChangeTypeSequence(IEnumerable`1<string> values, Type conversionType, CultureInfo conversionCulture, bool ignoreValueCase);
    private static Maybe`1<object> ChangeTypeScalar(string value, Type conversionType, CultureInfo conversionCulture, bool ignoreValueCase);
    private static Maybe`1<object> ChangeTypeFlagCounter(IEnumerable`1<string> values, Type conversionType, CultureInfo conversionCulture, bool ignoreValueCase);
    private static object ConvertString(string value, Type type, CultureInfo conversionCulture);
    private static Result`2<object, Exception> ChangeTypeScalarImpl(string value, Type conversionType, CultureInfo conversionCulture, bool ignoreValueCase);
    [ExtensionAttribute]
private static object ToEnum(string value, Type conversionType, bool ignoreValueCase);
    private static bool IsDefinedEx(object enumValue);
}
internal class CommandLine.Core.TypeDescriptor : ValueType {
    private TargetType targetType;
    private Maybe`1<int> maxItems;
    private Maybe`1<TypeDescriptor> nextValue;
    public TargetType TargetType { get; }
    public Maybe`1<int> MaxItems { get; }
    public Maybe`1<TypeDescriptor> NextValue { get; }
    private TypeDescriptor(TargetType targetType, Maybe`1<int> maxItems, Maybe`1<TypeDescriptor> nextValue);
    public TargetType get_TargetType();
    public Maybe`1<int> get_MaxItems();
    public Maybe`1<TypeDescriptor> get_NextValue();
    public static TypeDescriptor Create(TargetType tag, Maybe`1<int> maximumItems, TypeDescriptor next);
}
[ExtensionAttribute]
internal static class CommandLine.Core.TypeDescriptorExtensions : object {
    [ExtensionAttribute]
public static TypeDescriptor WithNextValue(TypeDescriptor descriptor, Maybe`1<TypeDescriptor> nextValue);
}
internal static class CommandLine.Core.TypeLookup : object {
    public static Maybe`1<TypeDescriptor> FindTypeDescriptorAndSibling(string name, IEnumerable`1<OptionSpecification> specifications, StringComparer comparer);
}
internal class CommandLine.Core.Value : Token {
    private bool explicitlyAssigned;
    private bool forced;
    private bool fromSeparator;
    public bool ExplicitlyAssigned { get; }
    public bool FromSeparator { get; }
    public bool Forced { get; }
    public Value(string text);
    public Value(string text, bool explicitlyAssigned);
    public Value(string text, bool explicitlyAssigned, bool forced, bool fromSeparator);
    public bool get_ExplicitlyAssigned();
    public bool get_FromSeparator();
    public bool get_Forced();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Value other);
}
[ExtensionAttribute]
internal static class CommandLine.Core.ValueMapper : object {
    public static Result`2<IEnumerable`1<SpecificationProperty>, Error> MapValues(IEnumerable`1<SpecificationProperty> specProps, IEnumerable`1<string> values, Func`4<IEnumerable`1<string>, Type, bool, Maybe`1<object>> converter);
    [IteratorStateMachineAttribute("CommandLine.Core.ValueMapper/<MapValuesImpl>d__1")]
private static IEnumerable`1<Tuple`2<SpecificationProperty, Maybe`1<Error>>> MapValuesImpl(IEnumerable`1<SpecificationProperty> specProps, IEnumerable`1<string> values, Func`4<IEnumerable`1<string>, Type, bool, Maybe`1<object>> converter);
    [ExtensionAttribute]
private static Maybe`1<int> CountOfMaxNumberOfValues(Specification specification);
    [ExtensionAttribute]
private static Maybe`1<Error> MakeErrorInCaseOfMinConstraint(Specification specification);
}
internal class CommandLine.Core.ValueSpecification : Specification {
    private int index;
    private string metaName;
    public int Index { get; }
    public string MetaName { get; }
    public ValueSpecification(int index, string metaName, bool required, Maybe`1<int> min, Maybe`1<int> max, Maybe`1<object> defaultValue, string helpText, string metaValue, IEnumerable`1<string> enumValues, Type conversionType, TargetType targetType, bool hidden);
    public static ValueSpecification FromAttribute(ValueAttribute attribute, Type conversionType, IEnumerable`1<string> enumValues);
    public int get_Index();
    public string get_MetaName();
}
internal class CommandLine.Core.Verb : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpText>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Hidden>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Aliases>k__BackingField;
    public string Name { get; private set; }
    public string HelpText { get; private set; }
    public bool Hidden { get; private set; }
    public bool IsDefault { get; private set; }
    public String[] Aliases { get; private set; }
    public Verb(string name, string helpText, bool hidden, bool isDefault, String[] aliases);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_HelpText();
    [CompilerGeneratedAttribute]
private void set_HelpText(string value);
    [CompilerGeneratedAttribute]
public bool get_Hidden();
    [CompilerGeneratedAttribute]
private void set_Hidden(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDefault();
    [CompilerGeneratedAttribute]
private void set_IsDefault(bool value);
    [CompilerGeneratedAttribute]
public String[] get_Aliases();
    [CompilerGeneratedAttribute]
private void set_Aliases(String[] value);
    public static Verb FromAttribute(VerbAttribute attribute);
    public static IEnumerable`1<Tuple`2<Verb, Type>> SelectFromTypes(IEnumerable`1<Type> types);
}
public abstract class CommandLine.Error : object {
    private ErrorType tag;
    private bool stopsProcessing;
    public ErrorType Tag { get; }
    public bool StopsProcessing { get; }
    protected internal Error(ErrorType tag, bool stopsProcessing);
    protected internal Error(ErrorType tag);
    public ErrorType get_Tag();
    public bool get_StopsProcessing();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Error other);
}
[ExtensionAttribute]
internal static class CommandLine.ErrorExtensions : object {
    [ExtensionAttribute]
public static ParserResult`1<T> ToParserResult(IEnumerable`1<Error> errors, T instance);
    [ExtensionAttribute]
public static IEnumerable`1<Error> OnlyMeaningfulOnes(IEnumerable`1<Error> errors);
}
public enum CommandLine.ErrorType : Enum {
    public int value__;
    public static ErrorType BadFormatTokenError;
    public static ErrorType MissingValueOptionError;
    public static ErrorType UnknownOptionError;
    public static ErrorType MissingRequiredOptionError;
    public static ErrorType MutuallyExclusiveSetError;
    public static ErrorType BadFormatConversionError;
    public static ErrorType SequenceOutOfRangeError;
    public static ErrorType RepeatedOptionError;
    public static ErrorType NoVerbSelectedError;
    public static ErrorType BadVerbSelectedError;
    public static ErrorType HelpRequestedError;
    public static ErrorType HelpVerbRequestedError;
    public static ErrorType VersionRequestedError;
    public static ErrorType SetValueExceptionError;
    public static ErrorType InvalidAttributeConfigurationError;
    public static ErrorType MissingGroupOptionError;
    public static ErrorType GroupOptionAmbiguityError;
    public static ErrorType MultipleDefaultVerbsError;
}
public class CommandLine.GroupOptionAmbiguityError : NamedError {
    public NameInfo Option;
    internal GroupOptionAmbiguityError(NameInfo option);
}
public class CommandLine.HelpRequestedError : Error {
}
[ExtensionAttribute]
public static class CommandLine.HelpTextExtensions : object {
    [ExtensionAttribute]
public static bool IsHelp(IEnumerable`1<Error> errs);
    [ExtensionAttribute]
public static bool IsVersion(IEnumerable`1<Error> errs);
    [ExtensionAttribute]
public static TextWriter Output(IEnumerable`1<Error> errs);
}
public class CommandLine.HelpVerbRequestedError : Error {
    private string verb;
    private Type type;
    private bool matched;
    public string Verb { get; }
    public Type Type { get; }
    public bool Matched { get; }
    internal HelpVerbRequestedError(string verb, Type type, bool matched);
    public string get_Verb();
    public Type get_Type();
    public bool get_Matched();
}
[ExtensionAttribute]
internal static class CommandLine.Infrastructure.EnumerableExtensions : object {
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static object ToUntypedArray(IEnumerable`1<object> value, Type type);
    [ExtensionAttribute]
public static bool Empty(IEnumerable`1<TSource> source);
    [IteratorStateMachineAttribute("CommandLine.Infrastructure.EnumerableExtensions/<Group>d__3`1")]
[ExtensionAttribute]
public static IEnumerable`1<T[]> Group(IEnumerable`1<T> source, int groupSize);
}
[ExtensionAttribute]
internal static class CommandLine.Infrastructure.ExceptionExtensions : object {
    [ExtensionAttribute]
public static void RethrowWhenAbsentIn(Exception exception, IEnumerable`1<Type> validExceptions);
}
internal class CommandLine.Infrastructure.LocalizableAttributeProperty : object {
    private string _propertyName;
    private string _value;
    private Type _type;
    private PropertyInfo _localizationPropertyInfo;
    public string Value { get; public set; }
    unknown Type ResourceType {public set; }
    public LocalizableAttributeProperty(string propertyName);
    public string get_Value();
    public void set_Value(string value);
    public void set_ResourceType(Type value);
    private string GetLocalizedValue();
}
internal static class CommandLine.Infrastructure.PopsicleSetter : object {
    public static void Set(bool consumed, T& field, T value);
}
internal class CommandLine.Infrastructure.ReferenceEqualityComparer : object {
    public static ReferenceEqualityComparer Default;
    private static ReferenceEqualityComparer();
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
internal static class CommandLine.Infrastructure.ReflectionHelper : object {
    [ThreadStaticAttribute]
private static IDictionary`2<Type, Attribute> _overrides;
    public static void SetAttributeOverride(IEnumerable`1<Attribute> overrides);
    public static Maybe`1<TAttribute> GetAttribute();
    public static string GetAssemblyName();
    public static string GetAssemblyVersion();
    public static bool IsFSharpOptionType(Type type);
    public static T CreateDefaultImmutableInstance(Type[] constructorTypes);
    public static object CreateDefaultImmutableInstance(Type type, Type[] constructorTypes);
    private static Assembly GetExecutingOrEntryAssembly();
    public static IEnumerable`1<string> GetNamesOfEnum(Type t);
}
[ExtensionAttribute]
internal static class CommandLine.Infrastructure.StringBuilderExtensions : object {
    [ExtensionAttribute]
public static StringBuilder AppendWhen(StringBuilder builder, bool condition, String[] values);
    [ExtensionAttribute]
public static StringBuilder AppendWhen(StringBuilder builder, bool condition, Char[] values);
    [ExtensionAttribute]
public static StringBuilder AppendFormatWhen(StringBuilder builder, bool condition, string format, Object[] args);
    [ExtensionAttribute]
public static StringBuilder AppendIf(StringBuilder builder, bool condition, string ifTrue, string ifFalse);
    [ExtensionAttribute]
public static StringBuilder BimapIf(StringBuilder builder, bool condition, Func`2<StringBuilder, StringBuilder> ifTrue, Func`2<StringBuilder, StringBuilder> ifFalse);
    [ExtensionAttribute]
public static StringBuilder MapIf(StringBuilder builder, bool condition, Func`2<StringBuilder, StringBuilder> ifTrue);
    [ExtensionAttribute]
public static StringBuilder AppendIfNotEmpty(StringBuilder builder, String[] values);
    [ExtensionAttribute]
public static string SafeToString(StringBuilder builder);
    [ExtensionAttribute]
public static int SafeLength(StringBuilder builder);
    [ExtensionAttribute]
public static StringBuilder TrimEnd(StringBuilder builder, char c);
    [ExtensionAttribute]
public static StringBuilder TrimEndIfMatch(StringBuilder builder, char c);
    [ExtensionAttribute]
public static StringBuilder TrimEndIfMatchWhen(StringBuilder builder, bool condition, char c);
    [ExtensionAttribute]
public static int TrailingSpaces(StringBuilder builder);
    [ExtensionAttribute]
public static bool SafeStartsWith(StringBuilder builder, string s);
    [ExtensionAttribute]
public static bool SafeEndsWith(StringBuilder builder, string s);
}
[ExtensionAttribute]
internal static class CommandLine.Infrastructure.StringExtensions : object {
    [ExtensionAttribute]
public static string ToOneCharString(char c);
    [ExtensionAttribute]
public static string ToStringInvariant(T value);
    [ExtensionAttribute]
public static string ToStringLocal(T value);
    [ExtensionAttribute]
public static string FormatInvariant(string value, Object[] arguments);
    [ExtensionAttribute]
public static string FormatLocal(string value, Object[] arguments);
    [ExtensionAttribute]
public static string Spaces(int value);
    [ExtensionAttribute]
public static bool EqualsOrdinal(string strA, string strB);
    [ExtensionAttribute]
public static bool EqualsOrdinalIgnoreCase(string strA, string strB);
    [ExtensionAttribute]
public static int SafeLength(string value);
    [ExtensionAttribute]
public static string JoinTo(string value, String[] others);
    [ExtensionAttribute]
public static bool IsBooleanString(string value);
    [ExtensionAttribute]
public static bool ToBoolean(string value);
    [ExtensionAttribute]
public static bool ToBooleanLoose(string value);
}
public class CommandLine.InvalidAttributeConfigurationError : Error {
    public static string ErrorMessage;
}
public class CommandLine.MissingGroupOptionError : Error {
    public static string ErrorMessage;
    private string group;
    private IEnumerable`1<NameInfo> names;
    public string Group { get; }
    public IEnumerable`1<NameInfo> Names { get; }
    internal MissingGroupOptionError(string group, IEnumerable`1<NameInfo> names);
    public string get_Group();
    public IEnumerable`1<NameInfo> get_Names();
    public sealed virtual bool Equals(Error obj);
    public sealed virtual bool Equals(MissingGroupOptionError other);
}
public class CommandLine.MissingRequiredOptionError : NamedError {
    internal MissingRequiredOptionError(NameInfo nameInfo);
}
public class CommandLine.MissingValueOptionError : NamedError {
    internal MissingValueOptionError(NameInfo nameInfo);
}
public class CommandLine.MultipleDefaultVerbsError : Error {
    public static string ErrorMessage;
}
public class CommandLine.MutuallyExclusiveSetError : NamedError {
    private string setName;
    public string SetName { get; }
    internal MutuallyExclusiveSetError(NameInfo nameInfo, string setName);
    public string get_SetName();
}
public abstract class CommandLine.NamedError : Error {
    private NameInfo nameInfo;
    public NameInfo NameInfo { get; }
    protected internal NamedError(ErrorType tag, NameInfo nameInfo);
    public NameInfo get_NameInfo();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(NamedError other);
}
public class CommandLine.NameInfo : object {
    public static NameInfo EmptyName;
    private string longName;
    private string shortName;
    public string ShortName { get; }
    public string LongName { get; }
    public string NameText { get; }
    internal NameInfo(string shortName, string longName);
    private static NameInfo();
    public string get_ShortName();
    public string get_LongName();
    public string get_NameText();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(NameInfo other);
}
public class CommandLine.NotParsed`1 : ParserResult`1<T> {
    internal NotParsed`1(TypeInfo typeInfo, IEnumerable`1<Error> errors);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(NotParsed`1<T> other);
}
public class CommandLine.NoVerbSelectedError : Error {
}
public class CommandLine.NullInstance : object {
}
[AttributeUsageAttribute("128")]
public class CommandLine.OptionAttribute : BaseAttribute {
    private string longName;
    private string shortName;
    private string setName;
    private bool flagCounter;
    private char separator;
    private string group;
    public string LongName { get; }
    public string ShortName { get; }
    public string SetName { get; public set; }
    public bool FlagCounter { get; public set; }
    public char Separator { get; public set; }
    public string Group { get; public set; }
    private OptionAttribute(string shortName, string longName);
    public OptionAttribute(string longName);
    public OptionAttribute(char shortName, string longName);
    public OptionAttribute(char shortName);
    public string get_LongName();
    public string get_ShortName();
    public string get_SetName();
    public void set_SetName(string value);
    public bool get_FlagCounter();
    public void set_FlagCounter(bool value);
    public char get_Separator();
    public void set_Separator(char value);
    public string get_Group();
    public void set_Group(string value);
}
public class CommandLine.Parsed`1 : ParserResult`1<T> {
    internal Parsed`1(T value, TypeInfo typeInfo);
    internal Parsed`1(T value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Parsed`1<T> other);
}
public class CommandLine.Parser : object {
    private bool disposed;
    private ParserSettings settings;
    private static Lazy`1<Parser> DefaultParser;
    public static Parser Default { get; }
    public ParserSettings Settings { get; }
    public Parser(Action`1<ParserSettings> configuration);
    internal Parser(ParserSettings settings);
    private static Parser();
    protected virtual override void Finalize();
    public static Parser get_Default();
    public ParserSettings get_Settings();
    public ParserResult`1<T> ParseArguments(IEnumerable`1<string> args);
    public ParserResult`1<T> ParseArguments(Func`1<T> factory, IEnumerable`1<string> args);
    public ParserResult`1<object> ParseArguments(IEnumerable`1<string> args, Type[] types);
    public sealed virtual void Dispose();
    private static Result`2<IEnumerable`1<Token>, Error> Tokenize(IEnumerable`1<string> arguments, IEnumerable`1<OptionSpecification> optionSpecs, ParserSettings settings);
    private static ParserResult`1<T> MakeParserResult(ParserResult`1<T> parserResult, ParserSettings settings);
    private static ParserResult`1<T> DisplayHelp(ParserResult`1<T> parserResult, TextWriter helpWriter, int maxDisplayWidth);
    private static IEnumerable`1<ErrorType> HandleUnknownArguments(bool ignoreUnknownArguments);
    private void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private Result`2<IEnumerable`1<Token>, Error> <ParseArguments>b__11_0(IEnumerable`1<string> arguments, IEnumerable`1<OptionSpecification> optionSpecs);
    [CompilerGeneratedAttribute]
private Result`2<IEnumerable`1<Token>, Error> <ParseArguments>b__12_0(IEnumerable`1<string> arguments, IEnumerable`1<OptionSpecification> optionSpecs);
    [CompilerGeneratedAttribute]
private Result`2<IEnumerable`1<Token>, Error> <ParseArguments>b__13_0(IEnumerable`1<string> arguments, IEnumerable`1<OptionSpecification> optionSpecs);
}
[ExtensionAttribute]
public static class CommandLine.ParserExtensions : object {
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
    [ExtensionAttribute]
public static ParserResult`1<object> ParseArguments(Parser parser, IEnumerable`1<string> args);
}
public abstract class CommandLine.ParserResult`1 : object {
    private ParserResultType tag;
    private TypeInfo typeInfo;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Error> <Errors>k__BackingField;
    public ParserResultType Tag { get; }
    public TypeInfo TypeInfo { get; }
    public T Value { get; }
    public IEnumerable`1<Error> Errors { get; }
    internal ParserResult`1(IEnumerable`1<Error> errors, TypeInfo typeInfo);
    internal ParserResult`1(T value, TypeInfo typeInfo);
    public ParserResultType get_Tag();
    public TypeInfo get_TypeInfo();
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Error> get_Errors();
}
[ExtensionAttribute]
public static class CommandLine.ParserResultExtensions : object {
    [ExtensionAttribute]
public static ParserResult`1<T> WithParsed(ParserResult`1<T> result, Action`1<T> action);
    [ExtensionAttribute]
public static ParserResult`1<object> WithParsed(ParserResult`1<object> result, Action`1<T> action);
    [ExtensionAttribute]
public static ParserResult`1<T> WithNotParsed(ParserResult`1<T> result, Action`1<IEnumerable`1<Error>> action);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<TSource> result, Func`2<TSource, TResult> parsedFunc, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<T8, TResult> parsedFunc8, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<T8, TResult> parsedFunc8, Func`2<T9, TResult> parsedFunc9, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<T8, TResult> parsedFunc8, Func`2<T9, TResult> parsedFunc9, Func`2<T10, TResult> parsedFunc10, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<T8, TResult> parsedFunc8, Func`2<T9, TResult> parsedFunc9, Func`2<T10, TResult> parsedFunc10, Func`2<T11, TResult> parsedFunc11, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<T8, TResult> parsedFunc8, Func`2<T9, TResult> parsedFunc9, Func`2<T10, TResult> parsedFunc10, Func`2<T11, TResult> parsedFunc11, Func`2<T12, TResult> parsedFunc12, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<T8, TResult> parsedFunc8, Func`2<T9, TResult> parsedFunc9, Func`2<T10, TResult> parsedFunc10, Func`2<T11, TResult> parsedFunc11, Func`2<T12, TResult> parsedFunc12, Func`2<T13, TResult> parsedFunc13, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<T8, TResult> parsedFunc8, Func`2<T9, TResult> parsedFunc9, Func`2<T10, TResult> parsedFunc10, Func`2<T11, TResult> parsedFunc11, Func`2<T12, TResult> parsedFunc12, Func`2<T13, TResult> parsedFunc13, Func`2<T14, TResult> parsedFunc14, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<T8, TResult> parsedFunc8, Func`2<T9, TResult> parsedFunc9, Func`2<T10, TResult> parsedFunc10, Func`2<T11, TResult> parsedFunc11, Func`2<T12, TResult> parsedFunc12, Func`2<T13, TResult> parsedFunc13, Func`2<T14, TResult> parsedFunc14, Func`2<T15, TResult> parsedFunc15, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [ExtensionAttribute]
public static TResult MapResult(ParserResult`1<object> result, Func`2<T1, TResult> parsedFunc1, Func`2<T2, TResult> parsedFunc2, Func`2<T3, TResult> parsedFunc3, Func`2<T4, TResult> parsedFunc4, Func`2<T5, TResult> parsedFunc5, Func`2<T6, TResult> parsedFunc6, Func`2<T7, TResult> parsedFunc7, Func`2<T8, TResult> parsedFunc8, Func`2<T9, TResult> parsedFunc9, Func`2<T10, TResult> parsedFunc10, Func`2<T11, TResult> parsedFunc11, Func`2<T12, TResult> parsedFunc12, Func`2<T13, TResult> parsedFunc13, Func`2<T14, TResult> parsedFunc14, Func`2<T15, TResult> parsedFunc15, Func`2<T16, TResult> parsedFunc16, Func`2<IEnumerable`1<Error>, TResult> notParsedFunc);
    [AsyncStateMachineAttribute("CommandLine.ParserResultExtensions/<WithParsedAsync>d__20`1")]
[ExtensionAttribute]
public static Task`1<ParserResult`1<T>> WithParsedAsync(ParserResult`1<T> result, Func`2<T, Task> action);
    [AsyncStateMachineAttribute("CommandLine.ParserResultExtensions/<WithParsedAsync>d__21`1")]
[ExtensionAttribute]
public static Task`1<ParserResult`1<object>> WithParsedAsync(ParserResult`1<object> result, Func`2<T, Task> action);
    [AsyncStateMachineAttribute("CommandLine.ParserResultExtensions/<WithNotParsedAsync>d__22`1")]
[ExtensionAttribute]
public static Task`1<ParserResult`1<T>> WithNotParsedAsync(ParserResult`1<T> result, Func`2<IEnumerable`1<Error>, Task> action);
}
public enum CommandLine.ParserResultType : Enum {
    public int value__;
    public static ParserResultType Parsed;
    public static ParserResultType NotParsed;
}
public class CommandLine.ParserSettings : object {
    private static int DefaultMaximumLength;
    private bool disposed;
    private bool caseSensitive;
    private bool caseInsensitiveEnumValues;
    private TextWriter helpWriter;
    private bool ignoreUnknownArguments;
    private bool autoHelp;
    private bool autoVersion;
    private CultureInfo parsingCulture;
    private Maybe`1<bool> enableDashDash;
    private int maximumDisplayWidth;
    private Maybe`1<bool> allowMultiInstance;
    private bool getoptMode;
    private Maybe`1<bool> posixlyCorrect;
    [CompilerGeneratedAttribute]
private bool <Consumed>k__BackingField;
    public bool CaseSensitive { get; public set; }
    public bool CaseInsensitiveEnumValues { get; public set; }
    public CultureInfo ParsingCulture { get; public set; }
    public TextWriter HelpWriter { get; public set; }
    public bool IgnoreUnknownArguments { get; public set; }
    public bool AutoHelp { get; public set; }
    public bool AutoVersion { get; public set; }
    public bool EnableDashDash { get; public set; }
    public int MaximumDisplayWidth { get; public set; }
    public bool AllowMultiInstance { get; public set; }
    public bool GetoptMode { get; public set; }
    public bool PosixlyCorrect { get; public set; }
    internal StringComparer NameComparer { get; }
    internal bool Consumed { get; internal set; }
    private int GetWindowWidth();
    protected virtual override void Finalize();
    public bool get_CaseSensitive();
    public void set_CaseSensitive(bool value);
    public bool get_CaseInsensitiveEnumValues();
    public void set_CaseInsensitiveEnumValues(bool value);
    public CultureInfo get_ParsingCulture();
    public void set_ParsingCulture(CultureInfo value);
    public TextWriter get_HelpWriter();
    public void set_HelpWriter(TextWriter value);
    public bool get_IgnoreUnknownArguments();
    public void set_IgnoreUnknownArguments(bool value);
    public bool get_AutoHelp();
    public void set_AutoHelp(bool value);
    public bool get_AutoVersion();
    public void set_AutoVersion(bool value);
    public bool get_EnableDashDash();
    public void set_EnableDashDash(bool value);
    public int get_MaximumDisplayWidth();
    public void set_MaximumDisplayWidth(int value);
    public bool get_AllowMultiInstance();
    public void set_AllowMultiInstance(bool value);
    public bool get_GetoptMode();
    public void set_GetoptMode(bool value);
    public bool get_PosixlyCorrect();
    public void set_PosixlyCorrect(bool value);
    internal StringComparer get_NameComparer();
    [CompilerGeneratedAttribute]
internal bool get_Consumed();
    [CompilerGeneratedAttribute]
internal void set_Consumed(bool value);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
public class CommandLine.RepeatedOptionError : NamedError {
    internal RepeatedOptionError(NameInfo nameInfo);
}
public class CommandLine.SequenceOutOfRangeError : NamedError {
    internal SequenceOutOfRangeError(NameInfo nameInfo);
}
public class CommandLine.SetValueExceptionError : NamedError {
    private Exception exception;
    private object value;
    public Exception Exception { get; }
    public object Value { get; }
    internal SetValueExceptionError(NameInfo nameInfo, Exception exception, object value);
    public Exception get_Exception();
    public object get_Value();
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("False")]
public class CommandLine.Text.AssemblyLicenseAttribute : MultilineTextAttribute {
    public AssemblyLicenseAttribute(string line1);
    public AssemblyLicenseAttribute(string line1, string line2);
    public AssemblyLicenseAttribute(string line1, string line2, string line3);
    public AssemblyLicenseAttribute(string line1, string line2, string line3, string line4);
    public AssemblyLicenseAttribute(string line1, string line2, string line3, string line4, string line5);
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("False")]
public class CommandLine.Text.AssemblyUsageAttribute : MultilineTextAttribute {
    public AssemblyUsageAttribute(string line1);
    public AssemblyUsageAttribute(string line1, string line2);
    public AssemblyUsageAttribute(string line1, string line2, string line3);
    public AssemblyUsageAttribute(string line1, string line2, string line3, string line4);
    public AssemblyUsageAttribute(string line1, string line2, string line3, string line4, string line5);
}
public class CommandLine.Text.ComparableOption : ValueType {
    public bool Required;
    public bool IsOption;
    public bool IsValue;
    public string LongName;
    public string ShortName;
    public int Index;
}
public class CommandLine.Text.CopyrightInfo : object {
    private static string DefaultCopyrightWord;
    private static string SymbolLower;
    private static string SymbolUpper;
    private AssemblyCopyrightAttribute attribute;
    private bool isSymbolUpper;
    private Int32[] copyrightYears;
    private string author;
    private int builderSize;
    public static CopyrightInfo Empty { get; }
    public static CopyrightInfo Default { get; }
    protected string CopyrightWord { get; }
    public CopyrightInfo(string author, int year);
    public CopyrightInfo(string author, Int32[] years);
    public CopyrightInfo(bool isSymbolUpper, string author, Int32[] copyrightYears);
    private CopyrightInfo(AssemblyCopyrightAttribute attribute);
    public static CopyrightInfo get_Empty();
    public static CopyrightInfo get_Default();
    protected virtual string get_CopyrightWord();
    public static string op_Implicit(CopyrightInfo info);
    public virtual string ToString();
    protected virtual string FormatYears(Int32[] years);
}
public class CommandLine.Text.Example : object {
    private string helpText;
    private IEnumerable`1<UnParserSettings> formatStyles;
    private object sample;
    public string HelpText { get; }
    public IEnumerable`1<UnParserSettings> FormatStyles { get; }
    public object Sample { get; }
    public Example(string helpText, IEnumerable`1<UnParserSettings> formatStyles, object sample);
    public Example(string helpText, UnParserSettings formatStyle, object sample);
    public Example(string helpText, object sample);
    public string get_HelpText();
    public IEnumerable`1<UnParserSettings> get_FormatStyles();
    public object get_Sample();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Example other);
}
[ExtensionAttribute]
internal static class CommandLine.Text.ExampleExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<UnParserSettings> GetFormatStylesOrDefault(Example example);
}
public class CommandLine.Text.HeadingInfo : object {
    private string programName;
    private string version;
    public static HeadingInfo Empty { get; }
    public static HeadingInfo Default { get; }
    public HeadingInfo(string programName, string version);
    public static HeadingInfo get_Empty();
    public static HeadingInfo get_Default();
    public static string op_Implicit(HeadingInfo info);
    public virtual string ToString();
    public void WriteMessage(string message, TextWriter writer);
    public void WriteMessage(string message);
    public void WriteError(string message);
}
public class CommandLine.Text.HelpText : object {
    [CompilerGeneratedAttribute]
private Comparison`1<ComparableOption> <OptionComparison>k__BackingField;
    public static Comparison`1<ComparableOption> RequiredThenAlphaComparison;
    private static int BuilderCapacity;
    private static int DefaultMaximumLength;
    private static int OptionToHelpTextSeparatorWidth;
    private static int OptionPrefixWidth;
    private static int TotalOptionPadding;
    private StringBuilder preOptionsHelp;
    private StringBuilder postOptionsHelp;
    private SentenceBuilder sentenceBuilder;
    private int maximumDisplayWidth;
    private string heading;
    private string copyright;
    private bool additionalNewLineAfterOption;
    private StringBuilder optionsHelp;
    private bool addDashesToOption;
    private bool addEnumValuesToHelpText;
    private bool autoHelp;
    private bool autoVersion;
    private bool addNewLineBetweenHelpSections;
    public Comparison`1<ComparableOption> OptionComparison { get; public set; }
    public string Heading { get; public set; }
    public string Copyright { get; public set; }
    public int MaximumDisplayWidth { get; public set; }
    public bool AddDashesToOption { get; public set; }
    public bool AdditionalNewLineAfterOption { get; public set; }
    public bool AddNewLineBetweenHelpSections { get; public set; }
    public bool AddEnumValuesToHelpText { get; public set; }
    public bool AutoHelp { get; public set; }
    public bool AutoVersion { get; public set; }
    public SentenceBuilder SentenceBuilder { get; }
    public HelpText(SentenceBuilder sentenceBuilder);
    public HelpText(string heading);
    public HelpText(SentenceBuilder sentenceBuilder, string heading);
    public HelpText(string heading, string copyright);
    public HelpText(SentenceBuilder sentenceBuilder, string heading, string copyright);
    private static HelpText();
    private ComparableOption ToComparableOption(Specification spec, int index);
    [CompilerGeneratedAttribute]
public Comparison`1<ComparableOption> get_OptionComparison();
    [CompilerGeneratedAttribute]
public void set_OptionComparison(Comparison`1<ComparableOption> value);
    public string get_Heading();
    public void set_Heading(string value);
    public string get_Copyright();
    public void set_Copyright(string value);
    public int get_MaximumDisplayWidth();
    public void set_MaximumDisplayWidth(int value);
    public bool get_AddDashesToOption();
    public void set_AddDashesToOption(bool value);
    public bool get_AdditionalNewLineAfterOption();
    public void set_AdditionalNewLineAfterOption(bool value);
    public bool get_AddNewLineBetweenHelpSections();
    public void set_AddNewLineBetweenHelpSections(bool value);
    public bool get_AddEnumValuesToHelpText();
    public void set_AddEnumValuesToHelpText(bool value);
    public bool get_AutoHelp();
    public void set_AutoHelp(bool value);
    public bool get_AutoVersion();
    public void set_AutoVersion(bool value);
    public SentenceBuilder get_SentenceBuilder();
    public static HelpText AutoBuild(ParserResult`1<T> parserResult, Func`2<HelpText, HelpText> onError, Func`2<Example, Example> onExample, bool verbsIndex, int maxDisplayWidth);
    public static HelpText AutoBuild(ParserResult`1<T> parserResult, int maxDisplayWidth);
    public static HelpText AutoBuild(ParserResult`1<T> parserResult, Func`2<HelpText, HelpText> onError, int maxDisplayWidth);
    public static HelpText DefaultParsingErrorsHandler(ParserResult`1<T> parserResult, HelpText current);
    public static string op_Implicit(HelpText info);
    public HelpText AddPreOptionsLine(string value);
    public HelpText AddPostOptionsLine(string value);
    public HelpText AddPreOptionsLines(IEnumerable`1<string> lines);
    public HelpText AddPostOptionsLines(IEnumerable`1<string> lines);
    public HelpText AddPreOptionsText(string text);
    public HelpText AddPostOptionsText(string text);
    public HelpText AddOptions(ParserResult`1<T> result);
    public HelpText AddVerbs(Type[] types);
    public HelpText AddOptions(int maximumLength, ParserResult`1<T> result);
    public HelpText AddVerbs(int maximumLength, Type[] types);
    public static string RenderParsingErrorsText(ParserResult`1<T> parserResult, Func`2<Error, string> formatError, Func`2<IEnumerable`1<MutuallyExclusiveSetError>, string> formatMutuallyExclusiveSetErrors, int indent);
    [IteratorStateMachineAttribute("CommandLine.Text.HelpText/<RenderParsingErrorsTextAsLines>d__75`1")]
public static IEnumerable`1<string> RenderParsingErrorsTextAsLines(ParserResult`1<T> parserResult, Func`2<Error, string> formatError, Func`2<IEnumerable`1<MutuallyExclusiveSetError>, string> formatMutuallyExclusiveSetErrors, int indent);
    public static string RenderUsageText(ParserResult`1<T> parserResult);
    public static string RenderUsageText(ParserResult`1<T> parserResult, Func`2<Example, Example> mapperFunc);
    [IteratorStateMachineAttribute("CommandLine.Text.HelpText/<RenderUsageTextAsLines>d__78`1")]
public static IEnumerable`1<string> RenderUsageTextAsLines(ParserResult`1<T> parserResult, Func`2<Example, Example> mapperFunc);
    public virtual string ToString();
    internal static void AddLine(StringBuilder builder, string value, int maximumLength);
    private IEnumerable`1<Specification> GetSpecificationsFromType(Type type);
    private static Maybe`1<Tuple`2<UsageAttribute, IEnumerable`1<Example>>> GetUsageFromType(Type type);
    private IEnumerable`1<Specification> AdaptVerbsToSpecifications(IEnumerable`1<Type> types);
    private HelpText AddOptionsImpl(IEnumerable`1<Specification> specifications, string requiredWord, string optionGroupWord, int maximumLength);
    private OptionSpecification MakeHelpEntry();
    private OptionSpecification MakeVersionEntry();
    private HelpText AddPreOptionsLine(string value, int maximumLength);
    private HelpText AddOption(string requiredWord, string optionGroupWord, int maxLength, Specification specification, int widthOfHelpText);
    private string AddOptionName(int maxLength, OptionSpecification specification);
    private string AddValueName(int maxLength, ValueSpecification specification);
    private HelpText AddLine(StringBuilder builder, string value);
    private int GetMaxLength(IEnumerable`1<Specification> specifications);
    private int GetMaxOptionLength(OptionSpecification spec);
    private int GetMaxValueLength(ValueSpecification spec);
    private static string FormatDefaultValue(T value);
    [CompilerGeneratedAttribute]
private void <AddPreOptionsLines>b__66_0(string line);
    [CompilerGeneratedAttribute]
private void <AddPostOptionsLines>b__67_0(string line);
    [CompilerGeneratedAttribute]
private void <AddPreOptionsText>b__68_0(string line);
    [CompilerGeneratedAttribute]
private void <AddPostOptionsText>b__69_0(string line);
    [CompilerGeneratedAttribute]
private string <ToString>g__NewLineIfNeededBefore|79_0(StringBuilder sb, <>c__DisplayClass79_0& );
    [CompilerGeneratedAttribute]
private int <GetMaxLength>b__92_0(int length, Specification spec);
}
public abstract class CommandLine.Text.MultilineTextAttribute : Attribute {
    private string line1;
    private string line2;
    private string line3;
    private string line4;
    private string line5;
    public string Value { get; }
    public string Line1 { get; }
    public string Line2 { get; }
    public string Line3 { get; }
    public string Line4 { get; }
    public string Line5 { get; }
    protected MultilineTextAttribute(string line1);
    protected MultilineTextAttribute(string line1, string line2);
    protected MultilineTextAttribute(string line1, string line2, string line3);
    protected MultilineTextAttribute(string line1, string line2, string line3, string line4);
    protected MultilineTextAttribute(string line1, string line2, string line3, string line4, string line5);
    public virtual string get_Value();
    public string get_Line1();
    public string get_Line2();
    public string get_Line3();
    public string get_Line4();
    public string get_Line5();
    internal HelpText AddToHelpText(HelpText helpText, Func`2<string, HelpText> func);
    internal HelpText AddToHelpText(HelpText helpText, bool before);
    protected virtual int GetLastLineWithText(String[] value);
}
public abstract class CommandLine.Text.SentenceBuilder : object {
    [CompilerGeneratedAttribute]
private static Func`1<SentenceBuilder> <Factory>k__BackingField;
    public static Func`1<SentenceBuilder> Factory { get; public set; }
    public Func`1<string> RequiredWord { get; }
    public Func`1<string> OptionGroupWord { get; }
    public Func`1<string> ErrorsHeadingText { get; }
    public Func`1<string> UsageHeadingText { get; }
    public Func`2<bool, string> HelpCommandText { get; }
    public Func`2<bool, string> VersionCommandText { get; }
    public Func`2<Error, string> FormatError { get; }
    public Func`2<IEnumerable`1<MutuallyExclusiveSetError>, string> FormatMutuallyExclusiveSetErrors { get; }
    private static SentenceBuilder();
    public static SentenceBuilder Create();
    [CompilerGeneratedAttribute]
public static Func`1<SentenceBuilder> get_Factory();
    [CompilerGeneratedAttribute]
public static void set_Factory(Func`1<SentenceBuilder> value);
    public abstract virtual Func`1<string> get_RequiredWord();
    public abstract virtual Func`1<string> get_OptionGroupWord();
    public abstract virtual Func`1<string> get_ErrorsHeadingText();
    public abstract virtual Func`1<string> get_UsageHeadingText();
    public abstract virtual Func`2<bool, string> get_HelpCommandText();
    public abstract virtual Func`2<bool, string> get_VersionCommandText();
    public abstract virtual Func`2<Error, string> get_FormatError();
    public abstract virtual Func`2<IEnumerable`1<MutuallyExclusiveSetError>, string> get_FormatMutuallyExclusiveSetErrors();
}
public class CommandLine.Text.TextWrapper : object {
    private String[] lines;
    public TextWrapper(string input);
    public TextWrapper WordWrap(int columnWidth);
    public TextWrapper Indent(int numberOfSpaces);
    public string ToText();
    public static string WrapAndIndentText(string input, int indentLevel, int columnWidth);
    private String[] WordWrapLine(string line, int columnWidth);
    private static List`1<StringBuilder> AddWordToLastLineOrCreateNewLineIfNecessary(List`1<StringBuilder> lines, string word, int columnWidth);
    private static string RightString(string str, int n);
    private static string LeftString(string str, int n);
}
[AttributeUsageAttribute("128")]
public class CommandLine.Text.UsageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ApplicationAlias>k__BackingField;
    public string ApplicationAlias { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ApplicationAlias();
    [CompilerGeneratedAttribute]
public void set_ApplicationAlias(string value);
}
public abstract class CommandLine.TokenError : Error {
    private string token;
    public string Token { get; }
    protected internal TokenError(ErrorType tag, string token);
    public string get_Token();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(TokenError other);
}
public class CommandLine.TypeInfo : object {
    private Type current;
    private IEnumerable`1<Type> choices;
    public Type Current { get; }
    public IEnumerable`1<Type> Choices { get; }
    private TypeInfo(Type current, IEnumerable`1<Type> choices);
    public Type get_Current();
    public IEnumerable`1<Type> get_Choices();
    internal static TypeInfo Create(Type current);
    internal static TypeInfo Create(Type current, IEnumerable`1<Type> choices);
}
public class CommandLine.UnknownOptionError : TokenError {
    internal UnknownOptionError(string token);
}
[ExtensionAttribute]
public static class CommandLine.UnParserExtensions : object {
    [ExtensionAttribute]
public static string FormatCommandLine(Parser parser, T options);
    [ExtensionAttribute]
public static String[] FormatCommandLineArgs(Parser parser, T options);
    [ExtensionAttribute]
public static string FormatCommandLine(Parser parser, T options, Action`1<UnParserSettings> configuration);
    [ExtensionAttribute]
public static String[] FormatCommandLineArgs(Parser parser, T options, Action`1<UnParserSettings> configuration);
    private static string FormatValue(Specification spec, object value);
    private static object FormatWithQuotesIfString(object value);
    [ExtensionAttribute]
private static char SeperatorOrSpace(Specification spec);
    private static string FormatOption(OptionSpecification spec, object value, UnParserSettings settings);
    [ExtensionAttribute]
private static string FormatName(OptionSpecification optionSpec, object value, UnParserSettings settings);
    [ExtensionAttribute]
private static object NormalizeValue(object value);
    [ExtensionAttribute]
private static bool IsEmpty(object value, Specification specification, bool skipDefault);
    [ExtensionAttribute]
public static String[] SplitArgs(string command, bool keepQuote);
}
public class CommandLine.UnParserSettings : object {
    private bool preferShortName;
    private bool groupSwitches;
    private bool useEqualToken;
    private bool showHidden;
    private bool skipDefault;
    [CompilerGeneratedAttribute]
private bool <Consumed>k__BackingField;
    public bool PreferShortName { get; public set; }
    public bool GroupSwitches { get; public set; }
    public bool UseEqualToken { get; public set; }
    public bool ShowHidden { get; public set; }
    public bool SkipDefault { get; public set; }
    internal bool Consumed { get; internal set; }
    public bool get_PreferShortName();
    public void set_PreferShortName(bool value);
    public bool get_GroupSwitches();
    public void set_GroupSwitches(bool value);
    public bool get_UseEqualToken();
    public void set_UseEqualToken(bool value);
    public bool get_ShowHidden();
    public void set_ShowHidden(bool value);
    public bool get_SkipDefault();
    public void set_SkipDefault(bool value);
    public static UnParserSettings WithGroupSwitchesOnly();
    public static UnParserSettings WithUseEqualTokenOnly();
    [CompilerGeneratedAttribute]
internal bool get_Consumed();
    [CompilerGeneratedAttribute]
internal void set_Consumed(bool value);
}
[AttributeUsageAttribute("128")]
public class CommandLine.ValueAttribute : BaseAttribute {
    private int index;
    private string metaName;
    public int Index { get; }
    public string MetaName { get; public set; }
    public ValueAttribute(int index);
    public int get_Index();
    public string get_MetaName();
    public void set_MetaName(string value);
}
[AttributeUsageAttribute("12")]
public class CommandLine.VerbAttribute : Attribute {
    private LocalizableAttributeProperty helpText;
    private Type resourceType;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Hidden>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Aliases>k__BackingField;
    public string Name { get; private set; }
    public bool Hidden { get; public set; }
    public string HelpText { get; public set; }
    public Type ResourceType { get; public set; }
    public bool IsDefault { get; private set; }
    public String[] Aliases { get; private set; }
    public VerbAttribute(string name, bool isDefault, String[] aliases);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Hidden();
    [CompilerGeneratedAttribute]
public void set_Hidden(bool value);
    public string get_HelpText();
    public void set_HelpText(string value);
    public Type get_ResourceType();
    public void set_ResourceType(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsDefault();
    [CompilerGeneratedAttribute]
private void set_IsDefault(bool value);
    [CompilerGeneratedAttribute]
public String[] get_Aliases();
    [CompilerGeneratedAttribute]
private void set_Aliases(String[] value);
}
public class CommandLine.VersionRequestedError : Error {
}
[ExtensionAttribute]
internal static class CSharpx.Either : object {
    public static Either`2<TLeft, TRight> Left(TLeft value);
    public static Either`2<TLeft, TRight> Right(TRight value);
    public static Either`2<string, TRight> Return(TRight value);
    public static Either`2<string, TRight> Fail(string message);
    public static Either`2<TLeft, TResult> Bind(Either`2<TLeft, TRight> either, Func`2<TRight, Either`2<TLeft, TResult>> func);
    public static Either`2<TLeft, TResult> Map(Either`2<TLeft, TRight> either, Func`2<TRight, TResult> func);
    public static Either`2<TLeft1, TRight1> Bimap(Either`2<TLeft, TRight> either, Func`2<TLeft, TLeft1> mapLeft, Func`2<TRight, TRight1> mapRight);
    [ExtensionAttribute]
public static Either`2<TLeft, TResult> Select(Either`2<TLeft, TRight> either, Func`2<TRight, TResult> selector);
    [ExtensionAttribute]
public static Either`2<TLeft, TResult> SelectMany(Either`2<TLeft, TRight> result, Func`2<TRight, Either`2<TLeft, TResult>> func);
    public static TRight GetOrFail(Either`2<TLeft, TRight> either);
    public static TLeft GetLeftOrDefault(Either`2<TLeft, TRight> either, TLeft default);
    public static TRight GetRightOrDefault(Either`2<TLeft, TRight> either, TRight default);
    public static Either`2<Exception, TRight> Try(Func`1<TRight> func);
    public static Either`2<Exception, TRight> Cast(object obj);
    public static Either`2<TLeft, TRight> FromMaybe(Maybe`1<TRight> maybe, TLeft left);
    [ExtensionAttribute]
private static TLeft GetLeft(Either`2<TLeft, TRight> either);
}
internal abstract class CSharpx.Either`2 : object {
    private EitherType tag;
    public EitherType Tag { get; }
    protected Either`2(EitherType tag);
    public EitherType get_Tag();
    public bool MatchLeft(TLeft& value);
    public bool MatchRight(TRight& value);
}
[ExtensionAttribute]
internal static class CSharpx.EitherExtensions : object {
    [ExtensionAttribute]
public static void Match(Either`2<TLeft, TRight> either, Action`1<TLeft> ifLeft, Action`1<TRight> ifRight);
    [ExtensionAttribute]
public static Either`2<string, TRight> ToEither(TRight value);
    [ExtensionAttribute]
public static Either`2<TLeft, TResult> Bind(Either`2<TLeft, TRight> either, Func`2<TRight, Either`2<TLeft, TResult>> func);
    [ExtensionAttribute]
public static Either`2<TLeft, TResult> Map(Either`2<TLeft, TRight> either, Func`2<TRight, TResult> func);
    [ExtensionAttribute]
public static Either`2<TLeft1, TRight1> Bimap(Either`2<TLeft, TRight> either, Func`2<TLeft, TLeft1> mapLeft, Func`2<TRight, TRight1> mapRight);
    [ExtensionAttribute]
public static bool IsLeft(Either`2<TLeft, TRight> either);
    [ExtensionAttribute]
public static bool IsRight(Either`2<TLeft, TRight> either);
}
internal enum CSharpx.EitherType : Enum {
    public int value__;
    public static EitherType Left;
    public static EitherType Right;
}
[ExtensionAttribute]
internal static class CSharpx.EnumerableExtensions : object {
    private static Func`3<int, int, Exception> OnFolderSourceSizeErrorSelector;
    private static EnumerableExtensions();
    [ExtensionAttribute]
public static Maybe`1<T> TryHead(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static Maybe`1<IEnumerable`1<T>> ToMaybe(IEnumerable`1<T> source);
    private static IEnumerable`1<TSource> AssertCountImpl(IEnumerable`1<TSource> source, int count, Func`3<int, int, Exception> errorSelector);
    [IteratorStateMachineAttribute("CSharpx.EnumerableExtensions/<ExpectingCountYieldingImpl>d__3`1")]
private static IEnumerable`1<TSource> ExpectingCountYieldingImpl(IEnumerable`1<TSource> source, int count, Func`3<int, int, Exception> errorSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Cartesian(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Prepend(IEnumerable`1<TSource> source, TSource value);
    [ExtensionAttribute]
public static IEnumerable`1<T> Concat(T head, IEnumerable`1<T> tail);
    [ExtensionAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> head, T tail);
    [ExtensionAttribute]
public static IEnumerable`1<T> Exclude(IEnumerable`1<T> sequence, int startIndex, int count);
    [IteratorStateMachineAttribute("CSharpx.EnumerableExtensions/<ExcludeImpl>d__9`1")]
private static IEnumerable`1<T> ExcludeImpl(IEnumerable`1<T> sequence, int startIndex, int count);
    [ExtensionAttribute]
public static IEnumerable`1<KeyValuePair`2<int, TSource>> Index(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IEnumerable`1<KeyValuePair`2<int, TSource>> Index(IEnumerable`1<TSource> source, int startIndex);
    [ExtensionAttribute]
public static TResult Fold(IEnumerable`1<T> source, Func`2<T, TResult> folder);
    [ExtensionAttribute]
public static TResult Fold(IEnumerable`1<T> source, Func`3<T, T, TResult> folder);
    [ExtensionAttribute]
public static TResult Fold(IEnumerable`1<T> source, Func`4<T, T, T, TResult> folder);
    [ExtensionAttribute]
public static TResult Fold(IEnumerable`1<T> source, Func`5<T, T, T, T, TResult> folder);
    private static TResult FoldImpl(IEnumerable`1<T> source, int count, Func`2<T, TResult> folder1, Func`3<T, T, TResult> folder2, Func`4<T, T, T, TResult> folder3, Func`5<T, T, T, T, TResult> folder4);
    private static Exception OnFolderSourceSizeError(int cmp, int count);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> source, Action`1<T> action);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Pairwise(IEnumerable`1<TSource> source, Func`3<TSource, TSource, TResult> resultSelector);
    [IteratorStateMachineAttribute("CSharpx.EnumerableExtensions/<PairwiseImpl>d__21`2")]
[ExtensionAttribute]
private static IEnumerable`1<TResult> PairwiseImpl(IEnumerable`1<TSource> source, Func`3<TSource, TSource, TResult> resultSelector);
    [ExtensionAttribute]
public static string ToDelimitedString(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static string ToDelimitedString(IEnumerable`1<TSource> source, string delimiter);
    private static string ToDelimitedStringImpl(IEnumerable`1<T> source, string delimiter, Func`3<StringBuilder, T, StringBuilder> append);
    [IteratorStateMachineAttribute("CSharpx.EnumerableExtensions/<Tail>d__25`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Tail(IEnumerable`1<T> source);
    [IteratorStateMachineAttribute("CSharpx.EnumerableExtensions/<TailNoFail>d__26`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> TailNoFail(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Memoize(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Materialize(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T Choice(IEnumerable`1<T> source);
    [IteratorStateMachineAttribute("CSharpx.EnumerableExtensions/<Intersperse>d__31`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Intersperse(IEnumerable`1<T> source, T element);
    [IteratorStateMachineAttribute("CSharpx.EnumerableExtensions/<FlattenOnce>d__32`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> FlattenOnce(IEnumerable`1<IEnumerable`1<T>> source);
    [IteratorStateMachineAttribute("CSharpx.EnumerableExtensions/<FlattenOnce>d__33")]
[ExtensionAttribute]
public static IEnumerable`1<string> FlattenOnce(IEnumerable`1<string> source);
}
internal class CSharpx.Just`1 : Maybe`1<T> {
    private T value;
    public T Value { get; }
    internal Just`1(T value);
    public T get_Value();
}
internal class CSharpx.Left`2 : Either`2<TLeft, TRight> {
    private TLeft value;
    public TLeft Value { get; }
    internal Left`2(TLeft value);
    public TLeft get_Value();
}
internal static class CSharpx.Maybe : object {
    public static Maybe`1<T> Nothing();
    public static Just`1<T> Just(T value);
    public static Maybe`1<T> Return(T value);
    public static Maybe`1<T2> Bind(Maybe`1<T1> maybe, Func`2<T1, Maybe`1<T2>> func);
    public static Maybe`1<T2> Map(Maybe`1<T1> maybe, Func`2<T1, T2> func);
    public static Maybe`1<Tuple`2<T1, T2>> Merge(Maybe`1<T1> first, Maybe`1<T2> second);
}
internal abstract class CSharpx.Maybe`1 : object {
    private MaybeType tag;
    public MaybeType Tag { get; }
    protected Maybe`1(MaybeType tag);
    public MaybeType get_Tag();
    public bool MatchJust(T& value);
    public bool MatchNothing();
}
[ExtensionAttribute]
internal static class CSharpx.MaybeExtensions : object {
    [ExtensionAttribute]
public static void Match(Maybe`1<T> maybe, Action`1<T> ifJust, Action ifNothing);
    [ExtensionAttribute]
public static void Match(Maybe`1<Tuple`2<T1, T2>> maybe, Action`2<T1, T2> ifJust, Action ifNothing);
    [ExtensionAttribute]
public static bool MatchJust(Maybe`1<Tuple`2<T1, T2>> maybe, T1& value1, T2& value2);
    [ExtensionAttribute]
public static Maybe`1<T> ToMaybe(T value);
    [ExtensionAttribute]
public static Maybe`1<T2> Bind(Maybe`1<T1> maybe, Func`2<T1, Maybe`1<T2>> func);
    [ExtensionAttribute]
public static Maybe`1<T2> Map(Maybe`1<T1> maybe, Func`2<T1, T2> func);
    [ExtensionAttribute]
public static Maybe`1<TResult> Select(Maybe`1<TSource> maybe, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static Maybe`1<TResult> SelectMany(Maybe`1<TSource> maybe, Func`2<TSource, Maybe`1<TValue>> valueSelector, Func`3<TSource, TValue, TResult> resultSelector);
    [ExtensionAttribute]
public static void Do(Maybe`1<T> maybe, Action`1<T> action);
    [ExtensionAttribute]
public static void Do(Maybe`1<Tuple`2<T1, T2>> maybe, Action`2<T1, T2> action);
    [ExtensionAttribute]
public static bool IsJust(Maybe`1<T> maybe);
    [ExtensionAttribute]
public static bool IsNothing(Maybe`1<T> maybe);
    [ExtensionAttribute]
public static T FromJust(Maybe`1<T> maybe);
    [ExtensionAttribute]
public static T FromJustOrFail(Maybe`1<T> maybe, Exception exceptionToThrow);
    [ExtensionAttribute]
public static T GetValueOrDefault(Maybe`1<T> maybe, T noneValue);
    [ExtensionAttribute]
public static T2 MapValueOrDefault(Maybe`1<T1> maybe, Func`2<T1, T2> func, T2 noneValue);
    [ExtensionAttribute]
public static T2 MapValueOrDefault(Maybe`1<T1> maybe, Func`2<T1, T2> func, Func`1<T2> noneValueFactory);
    [ExtensionAttribute]
public static IEnumerable`1<T> ToEnumerable(Maybe`1<T> maybe);
}
internal enum CSharpx.MaybeType : Enum {
    public int value__;
    public static MaybeType Just;
    public static MaybeType Nothing;
}
internal class CSharpx.Nothing`1 : Maybe`1<T> {
}
internal class CSharpx.Right`2 : Either`2<TLeft, TRight> {
    private TRight value;
    public TRight Value { get; }
    internal Right`2(TRight value);
    public TRight get_Value();
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.AssertionMethodAttribute : Attribute {
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[AttributeUsageAttribute("4")]
[BaseTypeRequiredAttribute("System.Attribute")]
internal class JetBrains.Annotations.BaseTypeRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    [NotNullAttribute]
public Type BaseType { get; private set; }
    public BaseTypeRequiredAttribute(Type baseType);
    [CompilerGeneratedAttribute]
public Type get_BaseType();
    [CompilerGeneratedAttribute]
private void set_BaseType(Type value);
}
[AttributeUsageAttribute("24516")]
internal class JetBrains.Annotations.CanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("1036")]
internal class JetBrains.Annotations.CannotApplyEqualityOperatorAttribute : Attribute {
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[AttributeUsageAttribute("2044")]
internal class JetBrains.Annotations.CodeTemplateAttribute : Attribute {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <SearchTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplaceTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplaceMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FormatAfterReplace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MatchSimilarConstructs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShortenReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SuppressionKey>k__BackingField;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("1")]
public string SearchTemplate { get; }
    public string Message { get; public set; }
    public string ReplaceTemplate { get; public set; }
    public string ReplaceMessage { get; public set; }
    public bool FormatAfterReplace { get; public set; }
    public bool MatchSimilarConstructs { get; public set; }
    public bool ShortenReferences { get; public set; }
    public string SuppressionKey { get; public set; }
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public CodeTemplateAttribute(string searchTemplate);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_SearchTemplate();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_ReplaceTemplate();
    [CompilerGeneratedAttribute]
public void set_ReplaceTemplate(string value);
    [CompilerGeneratedAttribute]
public string get_ReplaceMessage();
    [CompilerGeneratedAttribute]
public void set_ReplaceMessage(string value);
    [CompilerGeneratedAttribute]
public bool get_FormatAfterReplace();
    [CompilerGeneratedAttribute]
public void set_FormatAfterReplace(bool value);
    [CompilerGeneratedAttribute]
public bool get_MatchSimilarConstructs();
    [CompilerGeneratedAttribute]
public void set_MatchSimilarConstructs(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShortenReferences();
    [CompilerGeneratedAttribute]
public void set_ShortenReferences(bool value);
    [CompilerGeneratedAttribute]
public string get_SuppressionKey();
    [CompilerGeneratedAttribute]
public void set_SuppressionKey(string value);
}
[AttributeUsageAttribute("224")]
internal class JetBrains.Annotations.CollectionAccessAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CollectionAccessType <CollectionAccessType>k__BackingField;
    public CollectionAccessType CollectionAccessType { get; private set; }
    public CollectionAccessAttribute(CollectionAccessType collectionAccessType);
    [CompilerGeneratedAttribute]
public CollectionAccessType get_CollectionAccessType();
    [CompilerGeneratedAttribute]
private void set_CollectionAccessType(CollectionAccessType value);
}
[FlagsAttribute]
internal enum JetBrains.Annotations.CollectionAccessType : Enum {
    public int value__;
    public static CollectionAccessType None;
    public static CollectionAccessType Read;
    public static CollectionAccessType ModifyExistingContent;
    public static CollectionAccessType UpdatedContent;
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.ContractAnnotationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Contract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceFullStates>k__BackingField;
    [NotNullAttribute]
public string Contract { get; private set; }
    public bool ForceFullStates { get; private set; }
    public ContractAnnotationAttribute(string contract);
    public ContractAnnotationAttribute(string contract, bool forceFullStates);
    [CompilerGeneratedAttribute]
public string get_Contract();
    [CompilerGeneratedAttribute]
private void set_Contract(string value);
    [CompilerGeneratedAttribute]
public bool get_ForceFullStates();
    [CompilerGeneratedAttribute]
private void set_ForceFullStates(bool value);
}
[AttributeUsageAttribute("1037")]
internal class JetBrains.Annotations.ImplicitNotNullAttribute : Attribute {
}
[FlagsAttribute]
internal enum JetBrains.Annotations.ImplicitUseKindFlags : Enum {
    public int value__;
    public static ImplicitUseKindFlags Default;
    public static ImplicitUseKindFlags Access;
    public static ImplicitUseKindFlags Assign;
    public static ImplicitUseKindFlags InstantiatedWithFixedConstructorSignature;
    public static ImplicitUseKindFlags InstantiatedNoFixedConstructorSignature;
}
[FlagsAttribute]
internal enum JetBrains.Annotations.ImplicitUseTargetFlags : Enum {
    public int value__;
    public static ImplicitUseTargetFlags Default;
    public static ImplicitUseTargetFlags Itself;
    public static ImplicitUseTargetFlags Members;
    public static ImplicitUseTargetFlags WithMembers;
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.InstantHandleAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.InvokerParameterNameAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
internal class JetBrains.Annotations.ItemCanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
internal class JetBrains.Annotations.ItemNotNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.LinqTunnelAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class JetBrains.Annotations.LocalizationRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    public bool Required { get; private set; }
    public LocalizationRequiredAttribute(bool required);
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
private void set_Required(bool value);
}
[AttributeUsageAttribute("16388")]
internal class JetBrains.Annotations.MeansImplicitUseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    [UsedImplicitlyAttribute]
public ImplicitUseKindFlags UseKindFlags { get; private set; }
    [UsedImplicitlyAttribute]
public ImplicitUseTargetFlags TargetFlags { get; private set; }
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags);
    public MeansImplicitUseAttribute(ImplicitUseTargetFlags targetFlags);
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
private void set_UseKindFlags(ImplicitUseKindFlags value);
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
    [CompilerGeneratedAttribute]
private void set_TargetFlags(ImplicitUseTargetFlags value);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.MustUseReturnValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    public string Justification { get; private set; }
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public MustUseReturnValueAttribute(string justification);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
private void set_Justification(string value);
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.NoEnumerationAttribute : Attribute {
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; private set; }
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public NotifyPropertyChangedInvocatorAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
private void set_ParameterName(string value);
}
[AttributeUsageAttribute("24516")]
internal class JetBrains.Annotations.NotNullAttribute : Attribute {
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.PathReferenceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    public string BasePath { get; private set; }
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public PathReferenceAttribute(string basePath);
    [CompilerGeneratedAttribute]
public string get_BasePath();
    [CompilerGeneratedAttribute]
private void set_BasePath(string value);
}
[AttributeUsageAttribute("19916")]
internal class JetBrains.Annotations.ProvidesContextAttribute : Attribute {
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[MeansImplicitUseAttribute("3")]
internal class JetBrains.Annotations.PublicAPIAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    public string Comment { get; private set; }
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public PublicAPIAttribute(string comment);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
private void set_Comment(string value);
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.PureAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.RegexPatternAttribute : Attribute {
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[AttributeUsageAttribute("4320")]
internal class JetBrains.Annotations.StringFormatMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FormatParameterName>k__BackingField;
    [NotNullAttribute]
public string FormatParameterName { get; private set; }
    public StringFormatMethodAttribute(string formatParameterName);
    [CompilerGeneratedAttribute]
public string get_FormatParameterName();
    [CompilerGeneratedAttribute]
private void set_FormatParameterName(string value);
}
[AttributeUsageAttribute("32767")]
internal class JetBrains.Annotations.UsedImplicitlyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    public ImplicitUseKindFlags UseKindFlags { get; private set; }
    public ImplicitUseTargetFlags TargetFlags { get; private set; }
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags);
    public UsedImplicitlyAttribute(ImplicitUseTargetFlags targetFlags);
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
private void set_UseKindFlags(ImplicitUseKindFlags value);
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
    [CompilerGeneratedAttribute]
private void set_TargetFlags(ImplicitUseTargetFlags value);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.ValueProviderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; private set; }
    public ValueProviderAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.BlockingPriorityQueue`1 : object {
    private Lifetime myLifetime;
    private JetPriorityQueue`1<T> myQueue;
    private object mySentry;
    public int Count { get; }
    public bool IsReadOnly { get; }
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public BlockingPriorityQueue`1(Lifetime lifetime, int initialCapacity, IComparer`1<T> comparer);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public sealed virtual bool TryExtract(T& res);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public sealed virtual bool TryPeek(T& res);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[PublicAPIAttribute]
public bool TryExtract(T& res, int intervalMs);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[PublicAPIAttribute]
public bool TryPeek(T& res, int intervalMs);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[PublicAPIAttribute]
public T ExtractOrBlock();
    [PublicAPIAttribute]
public int Enqueue(T item);
    [PublicAPIAttribute]
public T[] ToArray();
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Collections.CollectionEx : object {
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static int ContentHashCode(ICollection`1<T> collection, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool TryDequeue(Queue`1<T> queue, T& res);
    [ExtensionAttribute]
public static T Enqueued(Queue`1<T> queue, T toEnqueue);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class JetBrains.Collections.CompactList`1 : ValueType {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<T> SingleMarker;
    private T mySingleValue;
    private List`1<T> myMultipleValues;
    public int Count { get; }
    public T Item { get; }
    private static CompactList`1();
    public CompactListEnumerator`1<T> GetEnumerator();
    public int get_Count();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public void Add(T item);
    public void Clear();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public int LastIndexOf(T item, IEqualityComparer`1<T> comparer);
    public bool RemoveAt(int index);
    public T[] ToArray();
    public T get_Item(int index);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.CompactListEnumerator`1 : ValueType {
    private T mySingleValue;
    private List`1<T> myMultipleValues;
    private int myIndex;
    private T myCurrent;
    private object System.Collections.IEnumerator.Current { get; }
    public T Current { get; }
    internal CompactListEnumerator`1(T singleValue, List`1<T> multipleValues);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual T get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class JetBrains.Collections.CopyOnWriteList`1 : object {
    private T[] modreq(System.Runtime.CompilerServices.IsVolatile) myStorage;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    internal T[] GetStorageUnsafe();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void Modify(TParam param, Func`3<T[], TParam, T[]> action);
    private TOut Modify(TParam param, Func`3<T[], TParam, KeyValuePair`2<T[], TOut>> action);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.EmptyEnumerator`1 : object {
    public static EmptyEnumerator`1<T> Instance;
    public T Current { get; }
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    private static EmptyEnumerator`1();
    public sealed virtual T get_Current();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    public IEnumerator`1<T> GetEnumerator();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public interface JetBrains.Collections.IPriorityQueue`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool TryExtract(T& res);
    public abstract virtual bool TryPeek(T& res);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Collections.JetKeyValuePair : object {
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static KeyValuePair`2<TKey, TValue> Of(TKey key, TValue value);
    [ExtensionAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.JetPriorityQueue`1 : object {
    public static int DefaultCapacity;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<T> myStorage;
    private List`1<long> myVersions;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IComparer`1<T> myComparer;
    private long myVersionAcc;
    public int Count { get; }
    public bool IsReadOnly { get; }
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public JetPriorityQueue`1(int initialCapacity, IComparer`1<T> comparer);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public sealed virtual bool TryExtract(T& res);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public sealed virtual bool TryPeek(T& res);
    private void Swap(Int32& i, int j);
    private int Compare(int left, int right);
    private void HeapDown(int idx);
    private void HeapUp(int idx);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Collections.PriorityQueueEx : object {
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[ExtensionAttribute]
[PublicAPIAttribute]
public static void Enqueue(IPriorityQueue`1<T> queue, T val);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static T ExtractOrDefault(IPriorityQueue`1<T> queue);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static T Extract(IPriorityQueue`1<T> queue);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static T Peek(IPriorityQueue`1<T> queue);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.ReferenceEqualityComparer`1 : object {
    private static ReferenceEqualityComparer`1<T> ourDefault;
    public static IEqualityComparer`1<T> Default { get; }
    private static ReferenceEqualityComparer`1();
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
    public static IEqualityComparer`1<T> get_Default();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.SingletonEnumerator`1 : ValueType {
    private bool myHasNext;
    [CompilerGeneratedAttribute]
private T <Current>k__BackingField;
    public T Current { get; }
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    public SingletonEnumerator`1(T next);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual T get_Current();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
[ExtensionAttribute]
public static class JetBrains.Collections.SmartListExtensions : object {
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[ExtensionAttribute]
public static CompactList`1<T> ToSmartList(IEnumerable`1<T> source);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[PublicAPIAttribute]
public class JetBrains.Collections.Synchronized.SynchronizedDictionary`2 : object {
    private Dictionary`2<TK, TV> myImpl;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private SynchronizedValues<TK, TV> myValues;
    private object myLocker;
    private int myIsUnderReadingCount;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TK,TV>>.IsReadOnly { get; }
    public TV Item { get; public set; }
    public ICollection`1<TK> Keys { get; }
    public ICollection`1<TV> Values { get; }
    private bool System.Collections.Generic.ICollection<TK>.IsReadOnly { get; }
    public SynchronizedDictionary`2(IEqualityComparer`1<TK> comparer);
    public SynchronizedDictionary`2(int capacity, IEqualityComparer`1<TK> comparer);
    [IteratorStateMachineAttribute("JetBrains.Collections.Synchronized.SynchronizedDictionary`2/<GetEnumerator>d__6")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TK, TV>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TK,TV>>.Add(KeyValuePair`2<TK, TV> item);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TK,TV>>.Contains(KeyValuePair`2<TK, TV> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TK,TV>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private static void CopyToNoLock(ICollection`1<T> source, T[] destination, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TK,TV>>.Remove(KeyValuePair`2<TK, TV> item);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TK,TV>>.get_IsReadOnly();
    public sealed virtual bool ContainsKey(TK key);
    public sealed virtual void Add(TK key, TV value);
    public sealed virtual bool Remove(TK key);
    public sealed virtual bool TryGetValue(TK key, TV& value);
    public sealed virtual TV get_Item(TK key);
    public sealed virtual void set_Item(TK key, TV value);
    public sealed virtual ICollection`1<TK> get_Keys();
    public sealed virtual ICollection`1<TV> get_Values();
    private Dictionary`2<TK, TV> GetOrCloneMapNoLock();
    private sealed virtual override void System.Collections.Generic.ICollection<TK>.Add(TK item);
    private sealed virtual override bool System.Collections.Generic.ICollection<TK>.Contains(TK item);
    private sealed virtual override void System.Collections.Generic.ICollection<TK>.CopyTo(TK[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<TK>.get_IsReadOnly();
    [IteratorStateMachineAttribute("JetBrains.Collections.Synchronized.SynchronizedDictionary`2/<System-Collections-Generic-IEnumerable<TK>-GetEnumerator>d__35")]
private sealed virtual override IEnumerator`1<TK> System.Collections.Generic.IEnumerable<TK>.GetEnumerator();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[PublicAPIAttribute]
public class JetBrains.Collections.Synchronized.SynchronizedList`1 : object {
    private List`1<T> myList;
    private object myLocker;
    private int myIsUnderReadingCount;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public SynchronizedList`1(IEnumerable`1<T> values, int capacity);
    [IteratorStateMachineAttribute("JetBrains.Collections.Synchronized.SynchronizedList`1/<GetEnumerator>d__4")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private List`1<T> GetOrCloneListNoLock();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[PublicAPIAttribute]
public class JetBrains.Collections.Synchronized.SynchronizedSet`1 : object {
    private HashSet`1<T> mySet;
    private object myLocker;
    private int myIsUnderReadingCount;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public SynchronizedSet`1(IEnumerable`1<T> values);
    public SynchronizedSet`1(IEqualityComparer`1<T> comparer);
    public SynchronizedSet`1(IEnumerable`1<T> values, IEqualityComparer`1<T> comparer);
    [IteratorStateMachineAttribute("JetBrains.Collections.Synchronized.SynchronizedSet`1/<GetEnumerator>d__7")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public T[] ExtractAll();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public T ExtractOneOrDefault();
    private HashSet`1<T> GetOrCloneSetNoLock();
    [CompilerGeneratedAttribute]
internal static T[] <ExtractAll>g__CopyToArray|30_0(HashSet`1<T> set);
}
public enum JetBrains.Collections.Viewable.AddRemove : Enum {
    public int value__;
    public static AddRemove Add;
    public static AddRemove Remove;
}
public enum JetBrains.Collections.Viewable.AddUpdateRemove : Enum {
    public int value__;
    public static AddUpdateRemove Add;
    public static AddUpdateRemove Update;
    public static AddUpdateRemove Remove;
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
internal class JetBrains.Collections.Viewable.AsyncSignal`1 : object {
    private ISignal`1<T> mySignal;
    public sealed virtual void AdviseOn(Lifetime lifetime, IScheduler scheduler, Action`1<T> action);
    public void Fire(T value);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.Viewable.DefaultScheduler : TaskSchedulerWrapper {
    public static DefaultScheduler Instance { get; }
    public static DefaultScheduler get_Instance();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public interface JetBrains.Collections.Viewable.IAppendOnlyViewableConcurrentSet`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool Add(T value);
    public abstract virtual bool Contains(T value);
    public abstract virtual void View(Lifetime lifetime, Action`2<Lifetime, T> action);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public interface JetBrains.Collections.Viewable.IAsyncProperty`1 {
    public T Value { get; public set; }
    public abstract virtual T get_Value();
    public abstract virtual void set_Value(T value);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public interface JetBrains.Collections.Viewable.IAsyncSource`1 {
    public abstract virtual void AdviseOn(Lifetime lifetime, IScheduler scheduler, Action`1<T> action);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public interface JetBrains.Collections.Viewable.IReadonlyAsyncProperty`1 {
    public IAsyncSource`1<T> Change { get; }
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Maybe`1<T> Maybe { get; }
    public T Value { get; }
    [NotNullAttribute]
public abstract virtual IAsyncSource`1<T> get_Change();
    [NotNullAttribute]
public abstract virtual Maybe`1<T> get_Maybe();
    public abstract virtual T get_Value();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public interface JetBrains.Collections.Viewable.IReadonlyProperty`1 {
    public ISource`1<T> Change { get; }
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Maybe`1<T> Maybe { get; }
    public T Value { get; }
    [NotNullAttribute]
public abstract virtual ISource`1<T> get_Change();
    [NotNullAttribute]
public abstract virtual Maybe`1<T> get_Maybe();
    public abstract virtual T get_Value();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public interface JetBrains.Collections.Viewable.IScheduler {
    public bool IsActive { get; }
    public bool OutOfOrderExecution { get; }
    public abstract virtual void Queue(Action action);
    public abstract virtual bool get_IsActive();
    public abstract virtual bool get_OutOfOrderExecution();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public interface JetBrains.Collections.Viewable.ISignal`1 {
    public IScheduler Scheduler { get; public set; }
    public abstract virtual IScheduler get_Scheduler();
    public abstract virtual void set_Scheduler(IScheduler value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public abstract virtual void Fire(T value);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public interface JetBrains.Collections.Viewable.ISource`1 {
    public abstract virtual void Advise(Lifetime lifetime, Action`1<T> handler);
}
public interface JetBrains.Collections.Viewable.IViewableConcurrentSet`1 {
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public abstract virtual bool Remove(T value);
}
public interface JetBrains.Collections.Viewable.IViewableList`1 {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ISource`1<ListEvent`1<T>> Change { get; }
    public abstract virtual ISource`1<ListEvent`1<T>> get_Change();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface JetBrains.Collections.Viewable.IViewableMap`2 {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ISource`1<MapEvent`2<K, V>> Change { get; }
    public int Count { get; }
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public V Item { get; public set; }
    public abstract virtual ISource`1<MapEvent`2<K, V>> get_Change();
    public abstract virtual int get_Count();
    public abstract virtual ICollection`1<K> get_Keys();
    public abstract virtual ICollection`1<V> get_Values();
    public abstract virtual bool ContainsKey(K key);
    public abstract virtual V get_Item(K key);
    public abstract virtual void set_Item(K key, V value);
    public abstract virtual bool TryGetValue(K key, V& value);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public interface JetBrains.Collections.Viewable.IViewableProperty`1 {
    public T Value { get; public set; }
    public abstract virtual T get_Value();
    public abstract virtual void set_Value(T value);
}
public interface JetBrains.Collections.Viewable.IViewableSet`1 {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ISource`1<SetEvent`1<T>> Change { get; }
    public abstract virtual ISource`1<SetEvent`1<T>> get_Change();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.Viewable.ListEvent`1 : ValueType {
    [CompilerGeneratedAttribute]
private AddUpdateRemove <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private V <OldValue>k__BackingField;
    [CompilerGeneratedAttribute]
private V <NewValue>k__BackingField;
    public AddUpdateRemove Kind { get; private set; }
    public int Index { get; private set; }
    public V OldValue { get; private set; }
    public V NewValue { get; private set; }
    private ListEvent`1(AddUpdateRemove kind, int index, V oldValue, V newValue);
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public AddUpdateRemove get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(AddUpdateRemove value);
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(int value);
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public V get_OldValue();
    [CompilerGeneratedAttribute]
private void set_OldValue(V value);
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public V get_NewValue();
    [CompilerGeneratedAttribute]
private void set_NewValue(V value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public static ListEvent`1<V> Add(int index, V newValue);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public static ListEvent`1<V> Update(int index, V oldValue, V newValue);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public static ListEvent`1<V> Remove(int index, V oldValue);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public virtual string ToString();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.Viewable.MapEvent`2 : ValueType {
    [CompilerGeneratedAttribute]
private AddUpdateRemove <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private K <Key>k__BackingField;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
[CompilerGeneratedAttribute]
private V <OldValue>k__BackingField;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
[CompilerGeneratedAttribute]
private V <NewValue>k__BackingField;
    public AddUpdateRemove Kind { get; private set; }
    public K Key { get; private set; }
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
public V OldValue { get; private set; }
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
public V NewValue { get; private set; }
    [<8c2af8bd-0e45-408b-bda9-968e24137dbc>MemberNotNullWhenAttribute("True", "NewValue")]
public bool IsAdd { get; }
    [<8c2af8bd-0e45-408b-bda9-968e24137dbc>MemberNotNullWhenAttribute("True", "NewValue")]
[<8c2af8bd-0e45-408b-bda9-968e24137dbc>MemberNotNullWhenAttribute("True", "OldValue")]
public bool IsUpdate { get; }
    [<8c2af8bd-0e45-408b-bda9-968e24137dbc>MemberNotNullWhenAttribute("True", "OldValue")]
public bool IsRemove { get; }
    private MapEvent`2(AddUpdateRemove kind, K key, V oldValue, V newValue);
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public AddUpdateRemove get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(AddUpdateRemove value);
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public K get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(K value);
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public V get_OldValue();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_OldValue(V value);
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public V get_NewValue();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_NewValue(V value);
    [<8c2af8bd-0e45-408b-bda9-968e24137dbc>MemberNotNullWhenAttribute("True", "NewValue")]
public bool get_IsAdd();
    [<8c2af8bd-0e45-408b-bda9-968e24137dbc>MemberNotNullWhenAttribute("True", "NewValue")]
[<8c2af8bd-0e45-408b-bda9-968e24137dbc>MemberNotNullWhenAttribute("True", "OldValue")]
public bool get_IsUpdate();
    [<8c2af8bd-0e45-408b-bda9-968e24137dbc>MemberNotNullWhenAttribute("True", "OldValue")]
public bool get_IsRemove();
    public static MapEvent`2<K, V> Add(K key, V newValue);
    public static MapEvent`2<K, V> Update(K key, V oldValue, V newValue);
    public static MapEvent`2<K, V> Remove(K key, V oldValue);
    public virtual string ToString();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.Viewable.ModificationCookieViewableSet`2 : object {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<TCookie> myCookieFactory;
    private IViewableSet`1<T> myBackingSet;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ISource`1<SetEvent`1<T>> Change { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ModificationCookieViewableSet`2(Func`1<TCookie> cookieFactory, IViewableSet`1<T> backingSet);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual ISource`1<SetEvent`1<T>> get_Change();
    public sealed virtual void Advise(Lifetime lifetime, Action`1<SetEvent`1<T>> handler);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual bool Contains(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual bool Add(T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void Clear();
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.Viewable.PrioritizedAction : object {
    public static int HighPriority;
    public static int NormalPriority;
    public static int LowPriority;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <Action>k__BackingField;
    public int Priority { get; }
    public Action Action { get; }
    public PrioritizedAction(Action action, int priority);
    [CompilerGeneratedAttribute]
public int get_Priority();
    [CompilerGeneratedAttribute]
public Action get_Action();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public sealed virtual int CompareTo(PrioritizedAction other);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Collections.Viewable.ReactiveEx : object {
    [ExtensionAttribute]
public static void Fire(ISignal`1<Unit> me);
    [ExtensionAttribute]
public static void AddLifetimed(ICollection`1<T> me, Lifetime lifetime, T item);
    [ExtensionAttribute]
public static void Advise(ISource`1<Unit> me, Lifetime lifetime, Action handler);
    [ExtensionAttribute]
public static void AdviseNotNull(ISource`1<T> me, Lifetime lifetime, Action`1<T> handler);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("0")]
[ExtensionAttribute]
public static void AdviseNotNull(ISource`1<Nullable`1<T>> me, Lifetime lifetime, Action`1<T> handler);
    [ExtensionAttribute]
public static void AdviseUntil(ISource`1<T> me, Lifetime lifetime, Func`2<T, bool> handler);
    [ExtensionAttribute]
public static void AdviseOnce(ISource`1<T> me, Lifetime lifetime, Action`1<T> handler);
    [ExtensionAttribute]
public static void View(IReadonlyProperty`1<T> me, Lifetime lifetime, Action`2<Lifetime, T> handler);
    [ExtensionAttribute]
public static void ViewNotNull(IReadonlyProperty`1<T> me, Lifetime lifetime, Action`2<Lifetime, T> handler);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("0")]
[ExtensionAttribute]
public static void ViewNotNull(IReadonlyProperty`1<Nullable`1<T>> me, Lifetime lifetime, Action`2<Lifetime, T> handler);
    [ExtensionAttribute]
public static void ViewNull(IReadonlyProperty`1<T> me, Lifetime lifetime, Action`1<Lifetime> handler);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("0")]
[ExtensionAttribute]
public static void ViewNull(IReadonlyProperty`1<Nullable`1<T>> me, Lifetime lifetime, Action`1<Lifetime> handler);
    [ExtensionAttribute]
public static void View(IViewableMap`2<K, V> me, Lifetime lifetime, Action`2<Lifetime, KeyValuePair`2<K, V>> handler);
    [ExtensionAttribute]
public static void FlowInto(IViewableMap`2<K, V> me, Lifetime lifetime, IDictionary`2<K, V> storage);
    [ExtensionAttribute]
[ObsoleteAttribute("This method has horrible performance when adding 100+ items")]
public static void AddOrReplaceLifetimed(IViewableMap`2<K, V> me, Lifetime lifetime, K k, Func`2<Lifetime, V> vfun);
    [ExtensionAttribute]
public static void AdviseAddRemove(IViewableMap`2<K, V> me, Lifetime lifetime, Action`3<AddRemove, K, V> handler);
    [ExtensionAttribute]
public static void Advise(IViewableSet`1<T> me, Lifetime lifetime, Action`2<AddRemove, T> handler);
    [ExtensionAttribute]
public static void View(IViewableSet`1<T> me, Lifetime lifetime, Action`2<Lifetime, T> handler);
    [ExtensionAttribute]
public static void View(IViewableMap`2<K, V> me, Lifetime lifetime, Action`3<Lifetime, K, V> handler);
    [ExtensionAttribute]
public static void AdviseAddRemove(IViewableList`1<V> me, Lifetime lifetime, Action`3<AddRemove, int, V> handler);
    [ExtensionAttribute]
public static void View(IViewableList`1<V> me, Lifetime lifetime, Action`3<Lifetime, int, V> handler);
    [ExtensionAttribute]
public static bool HasValue(IReadonlyProperty`1<T> me);
    [ExtensionAttribute]
public static bool HasTrueValue(IReadonlyProperty`1<bool> me);
    [ExtensionAttribute]
public static void Compose(IReadonlyProperty`1<T1> first, Lifetime lifetime, IReadonlyProperty`1<T2> second, Action`2<T1, T2> composer);
    [ExtensionAttribute]
public static IReadonlyProperty`1<T> Compose(IReadonlyProperty`1<T1> first, Lifetime lifetime, IReadonlyProperty`1<T2> second, Func`3<T1, T2, T> composer);
    [ExtensionAttribute]
public static void WhenTrue(IReadonlyProperty`1<bool> property, Lifetime lifetime, Action`1<Lifetime> handler);
    [ExtensionAttribute]
public static void WhenFalse(IReadonlyProperty`1<bool> property, Lifetime lifetime, Action`1<Lifetime> handler);
    [ExtensionAttribute]
public static IReadonlyProperty`1<R> Select(IViewableProperty`1<T> source, Func`2<T, R> f);
    [ExtensionAttribute]
public static Task`1<T> NextNotNullValueAsync(ISource`1<T> source, Lifetime lifetime);
    [ExtensionAttribute]
public static Task`1<bool> NextTrueValueAsync(ISource`1<bool> source, Lifetime lifetime);
    [ExtensionAttribute]
public static Task`1<bool> NextFalseValueAsync(ISource`1<bool> source, Lifetime lifetime);
    [ExtensionAttribute]
public static Task`1<T> NextValueAsync(ISource`1<T> source, Lifetime lifetime);
    [ExtensionAttribute]
public static Task`1<T> NextValueAsync(ISource`1<T> source, Lifetime lifetime, Func`2<T, bool> condition);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Collections.Viewable.SchedulerEx : object {
    [ExtensionAttribute]
public static void AssertThread(IScheduler scheduler, object debugInfo);
    [ExtensionAttribute]
public static void InvokeOrQueue(IScheduler sc, Action action);
    [ExtensionAttribute]
public static void InvokeOrQueue(IScheduler sc, Lifetime lifetime, Action action);
    [ExtensionAttribute]
public static void InvokeSync(IScheduler sc, Action action);
    [ExtensionAttribute]
public static TaskScheduler AsTaskScheduler(IScheduler scheduler);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.Viewable.SchedulerWrapper : TaskScheduler {
    private SyncContext mySyncContext;
    private IScheduler myRealScheduler;
    public SchedulerWrapper(IScheduler realScheduler);
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    private bool TryExecuteTaskWithContext(Task task);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.Viewable.SetEvent`1 : ValueType {
    [CompilerGeneratedAttribute]
private AddRemove <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public AddRemove Kind { get; private set; }
    public T Value { get; private set; }
    private SetEvent`1(AddRemove kind, T value);
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public AddRemove get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(AddRemove value);
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[NotNullAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    public static SetEvent`1<T> Add(T value);
    public static SetEvent`1<T> Remove(T value);
    public virtual string ToString();
}
public class JetBrains.Collections.Viewable.Signal : object {
    [ThreadStaticAttribute]
private static int ourPriorityCookie;
    internal static bool IsPriorityAdvise { get; }
    internal static bool get_IsPriorityAdvise();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Collections.Viewable.Signal`1 : SignalBase`1<T> {
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.Viewable.SignalBase`1 : object {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private LifetimedList`1<Action`1<T>> myListeners;
    [CompilerGeneratedAttribute]
private IScheduler <Scheduler>k__BackingField;
    public IScheduler Scheduler { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IScheduler get_Scheduler();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Scheduler(IScheduler value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public virtual void Fire(T value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public virtual void Advise(Lifetime lifetime, Action`1<T> handler);
    public sealed virtual void OnTermination(Lifetime lifetime);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.Viewable.SingleThreadScheduler : TaskScheduler {
    private ILog myLog;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ActionPriority>k__BackingField;
    [CompilerGeneratedAttribute]
private Thread <Thread>k__BackingField;
    private ActionQueue myQueue;
    public string Name { get; }
    public int ActionPriority { get; }
    public Thread Thread { get; private set; }
    public bool IsIdle { get; }
    public bool IsActive { get; }
    public bool OutOfOrderExecution { get; }
    private SingleThreadScheduler(string name, ActionQueue queue, int actionPriority);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_ActionPriority();
    [CompilerGeneratedAttribute]
public Thread get_Thread();
    [CompilerGeneratedAttribute]
private void set_Thread(Thread value);
    [PublicAPIAttribute]
public static void RunInCurrentStackframe(Lifetime lifetime, string name, Action`1<SingleThreadScheduler> beforeStart);
    [PublicAPIAttribute]
public static SingleThreadScheduler RunOnSeparateThread(Lifetime lifetime, string name, Action`1<SingleThreadScheduler> beforeStart);
    public static SingleThreadScheduler CreateOverExisting(SingleThreadScheduler existingScheduler, string name, int actionPriority);
    public bool get_IsIdle();
    private void ExecuteOneAction(bool blockIfNoActionAvailable);
    private void Run();
    public bool PumpAndWaitFor(Lifetime lifetime, TimeSpan timeout, Func`1<bool> condition);
    public bool PumpAndWaitFor(Lifetime lifetime, Func`1<bool> condition);
    public bool PumpAndWaitFor(Func`1<bool> condition);
    public virtual string ToString();
    public sealed virtual void Queue(Action action);
    public sealed virtual bool get_IsActive();
    public sealed virtual bool get_OutOfOrderExecution();
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    [IteratorStateMachineAttribute("JetBrains.Collections.Viewable.SingleThreadScheduler/<GetScheduledTasks>d__32")]
protected virtual IEnumerable`1<Task> GetScheduledTasks();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.Viewable.SynchronousScheduler : TaskScheduler {
    public static SynchronousScheduler Instance;
    [ThreadStaticAttribute]
private static int ourActive;
    public bool IsActive { get; }
    public bool OutOfOrderExecution { get; }
    private static SynchronousScheduler();
    public void SetActive(Lifetime lifetime);
    public sealed virtual void Queue(Action action);
    private static void Execute(Action action);
    public sealed virtual bool get_IsActive();
    public sealed virtual bool get_OutOfOrderExecution();
    [IteratorStateMachineAttribute("JetBrains.Collections.Viewable.SynchronousScheduler/<GetScheduledTasks>d__10")]
protected virtual IEnumerable`1<Task> GetScheduledTasks();
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.Viewable.TaskSchedulerWrapper : object {
    private ThreadLocal`1<int> myExecutionCount;
    private TaskScheduler myScheduler;
    [CompilerGeneratedAttribute]
private bool <OutOfOrderExecution>k__BackingField;
    public bool IsActive { get; }
    public bool OutOfOrderExecution { get; }
    public TaskSchedulerWrapper(TaskScheduler scheduler, bool outOfOrderExecution);
    public sealed virtual bool get_IsActive();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_OutOfOrderExecution();
    public sealed virtual void Queue(Action action);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.Viewable.ViewableConcurrentSet`1 : object {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Signal`1<VersionedData<T>> mySignal;
    private Dictionary`2<T, LifetimeDefinition> myMap;
    private object myLocker;
    private int myCount;
    private int myAddVersion;
    private int myIsUnderReadingCount;
    public int Count { get; }
    public ViewableConcurrentSet`1(IEqualityComparer`1<T> comparer);
    public sealed virtual int get_Count();
    public sealed virtual bool Add(T value);
    public sealed virtual bool Remove(T value);
    public sealed virtual bool Contains(T value);
    public bool TryGetLifetime(T value, Lifetime& lifetime);
    private Dictionary`2<T, LifetimeDefinition> GetOrCloneMapNoLock();
    public sealed virtual void View(Lifetime lifetime, Action`2<Lifetime, T> action);
    [IteratorStateMachineAttribute("JetBrains.Collections.Viewable.ViewableConcurrentSet`1/<GetEnumerator>d__17")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class JetBrains.Collections.Viewable.ViewableList`1 : object {
    private IList`1<T> myStorage;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Signal`1<ListEvent`1<T>> myChange;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PublicAPIAttribute]
public ISource`1<ListEvent`1<T>> Change { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public ViewableList`1(IList`1<T> list);
    public sealed virtual ISource`1<ListEvent`1<T>> get_Change();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Advise(Lifetime lifetime, Action`1<ListEvent`1<T>> handler);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class JetBrains.Collections.Viewable.ViewableMap`2 : object {
    private IDictionary`2<TK, TV> myStorage;
    private IEqualityComparer`1<TV> myValueComparer;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Signal`1<MapEvent`2<TK, TV>> myChange;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ISource`1<MapEvent`2<TK, TV>> Change { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TV Item { get; public set; }
    public ICollection`1<TK> Keys { get; }
    public ICollection`1<TV> Values { get; }
    [PublicAPIAttribute]
public ViewableMap`2(IEqualityComparer`1<TV> valueComparer);
    [PublicAPIAttribute]
public ViewableMap`2(IDictionary`2<TK, TV> storage, IEqualityComparer`1<TV> valueComparer);
    public sealed virtual ISource`1<MapEvent`2<TK, TV>> get_Change();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TK, TV>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TK, TV> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TK, TV> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TK, TV> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool ContainsKey(TK key);
    public sealed virtual void Add(TK key, TV value);
    public sealed virtual bool Remove(TK key);
    public sealed virtual bool TryGetValue(TK key, TV& value);
    public sealed virtual TV get_Item(TK key);
    public sealed virtual void set_Item(TK key, TV value);
    public sealed virtual ICollection`1<TK> get_Keys();
    public sealed virtual ICollection`1<TV> get_Values();
    public sealed virtual void Advise(Lifetime lifetime, Action`1<MapEvent`2<TK, TV>> handler);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.Viewable.ViewableProperty`1 : object {
    private Signal`1<T> myChange;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Maybe`1<T> <Maybe>k__BackingField;
    public ISource`1<T> Change { get; }
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Maybe`1<T> Maybe { get; private set; }
    public T Value { get; public set; }
    public ViewableProperty`1(T value);
    public sealed virtual ISource`1<T> get_Change();
    [CompilerGeneratedAttribute]
public sealed virtual Maybe`1<T> get_Maybe();
    [CompilerGeneratedAttribute]
private void set_Maybe(Maybe`1<T> value);
    public virtual T get_Value();
    public virtual void set_Value(T value);
    public sealed virtual void Advise(Lifetime lifetime, Action`1<T> handler);
    public bool SetIfEmpty(T value);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.Viewable.ViewableSet`1 : object {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Signal`1<SetEvent`1<T>> myChange;
    private ISet`1<T> myStorage;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ISource`1<SetEvent`1<T>> Change { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    [PublicAPIAttribute]
public ViewableSet`1(ISet`1<T> storage);
    public sealed virtual ISource`1<SetEvent`1<T>> get_Change();
    public sealed virtual void Advise(Lifetime lifetime, Action`1<SetEvent`1<T>> handler);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual bool Add(T item);
    public sealed virtual bool Remove(T item);
    private void BulkFire(AddRemove kind, IEnumerable`1<T> values);
    public sealed virtual void Clear();
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Collections.Viewable.WriteOnceProperty`1 : object {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private WriteOnceSignal<T> mySignal;
    private object myLock;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Maybe`1<T> myMaybe;
    public ISource`1<T> Change { get; }
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Maybe`1<T> Maybe { get; }
    public T Value { get; public set; }
    public sealed virtual ISource`1<T> get_Change();
    public sealed virtual Maybe`1<T> get_Maybe();
    public sealed virtual T get_Value();
    public sealed virtual void set_Value(T value);
    public bool SetIfEmpty(T newValue);
    public sealed virtual void Advise(Lifetime lifetime, Action`1<T> handler);
    internal void fireInternal(T value);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Core.Maybe`1 : ValueType {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PublicAPIAttribute]
public static Maybe`1<T> None;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    private T myValue;
    public bool HasValue { get; }
    public T Value { get; }
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
public T ValueOrDefault { get; }
    public Maybe`1(T value);
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_HasValue();
    public T get_Value();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public T get_ValueOrDefault();
    public T OrElseThrow(Func`1<Exception> func);
    public Maybe`1<TK> Select(Func`2<T, TK> map);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Maybe`1<T> other);
    public virtual int GetHashCode();
    public static bool op_Equality(Maybe`1<T> left, Maybe`1<T> right);
    public static bool op_Inequality(Maybe`1<T> left, Maybe`1<T> right);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Core.Nothing : object {
    [PublicAPIAttribute]
public T As();
    public static T Unreachable();
    public static Nothing Unreachable();
}
[ExtensionAttribute]
[PublicAPIAttribute]
public static class JetBrains.Core.Result : object {
    public static string EmptyFailMessage;
    public static Result`1<Unit> Unit;
    private static Result();
    public static Result`1<T> Success(T value);
    public static Result`1<Nothing> Fail(Exception exception, bool captureStackTrace);
    public static Result`2<Nothing, TFailure> Fail(Exception exception, TFailure failValue, bool captureStackTrace);
    public static Result`1<Nothing> Fail(string message);
    public static Result`2<Nothing, TFailure> Fail(string message, TFailure failValue);
    public static Result`2<Nothing, TFailure> FailWithValue(TFailure failValue);
    public static Result`1<Nothing> Canceled();
    public static Result`1<Nothing> Canceled(OperationCanceledException exception, bool captureStackTrace);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static Result`1<TRes> Wrap(Func`1<TRes> f);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static Result`1<Unit> Wrap(Action f);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static Result`1<Unit> Wrap(Action`1<T> f, T param);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static Result`1<TRes> Wrap(Func`2<T, TRes> f, T param);
    [ExtensionAttribute]
public static Task UnwrapTask(Result`1<Task> result);
    [ExtensionAttribute]
public static Task`1<T> UnwrapTask(Result`1<Task`1<T>> result);
    public static Result`1<T> FromCompletedTask(Task`1<T> task);
}
[<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[PublicAPIAttribute]
public class JetBrains.Core.Result`1 : ValueType {
    public T Value;
    internal object ExceptionOrExceptionDispatchInfo;
    public Exception Exception { get; }
    public string FailMessage { get; }
    public bool Succeed { get; }
    public bool FailedNotCanceled { get; }
    public bool Canceled { get; }
    internal Result`1(T success, object failure);
    public Exception get_Exception();
    public string get_FailMessage();
    public bool get_Succeed();
    public bool get_FailedNotCanceled();
    public bool get_Canceled();
    public static Result`1<T> op_Implicit(Result`1<Nothing> me);
    public Result`1<TRes> Map(Func`2<T, TRes> transform);
    public Result`1<TRes> Map(TRes successValue);
    public T Unwrap();
    public Task`1<T> AsCompletedTask();
    public virtual string ToString();
    public sealed virtual bool Equals(Result`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Result`1<T> left, Result`1<T> right);
    public static bool op_Inequality(Result`1<T> left, Result`1<T> right);
}
[<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[PublicAPIAttribute]
public class JetBrains.Core.Result`2 : ValueType {
    public TSuccess Value;
    internal object ExceptionOrExceptionDispatchInfo;
    public TFailure FailValue;
    public Exception Exception { get; }
    public string FailMessage { get; }
    public bool Succeed { get; }
    public bool FailedNotCanceled { get; }
    public bool Canceled { get; }
    internal Result`2(TSuccess success, object failure, TFailure failValue);
    public Exception get_Exception();
    public string get_FailMessage();
    public bool get_Succeed();
    public bool get_FailedNotCanceled();
    public bool get_Canceled();
    public static Result`2<TSuccess, TFailure> op_Implicit(Result`2<Nothing, TFailure> me);
    public static Result`1<TSuccess> op_Implicit(Result`2<TSuccess, TFailure> me);
    public static Result`2<TSuccess, TFailure> op_Implicit(Result`1<TSuccess> me);
    public TSuccess Unwrap();
    public virtual string ToString();
    public sealed virtual bool Equals(Result`2<TSuccess, TFailure> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Result`2<TSuccess, TFailure> left, Result`2<TSuccess, TFailure> right);
    public static bool op_Inequality(Result`2<TSuccess, TFailure> left, Result`2<TSuccess, TFailure> right);
}
public class JetBrains.Core.ResultException : Exception {
    public ResultException(string message);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Core.Unit : object {
    public static Unit Instance;
    private static Unit();
    public virtual string ToString();
    public sealed virtual bool Equals(Unit other);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public static bool op_Equality(Unit left, Unit right);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public static bool op_Inequality(Unit left, Unit right);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[ExtensionAttribute]
[LocalizableAttribute("False")]
public static class JetBrains.Diagnostics.Assertion : object {
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message);
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, JetConditionalInterpolatedStringHandler& handler);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertCurrentThread(Thread thread);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, T arg);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, T1 arg1, T2 arg2);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, T1 arg1, T2 arg2, T3 arg3);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, Object[] args);
    [ContractAnnotationAttribute("=>void")]
[AssertionMethodAttribute]
[<f65dc85a-eee6-406b-bb85-472d872eae7c>DoesNotReturnAttribute]
public static void Fail(string message);
    [ContractAnnotationAttribute("=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[<f65dc85a-eee6-406b-bb85-472d872eae7c>DoesNotReturnAttribute]
public static void Fail(string message, object arg);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[ContractAnnotationAttribute("=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[<f65dc85a-eee6-406b-bb85-472d872eae7c>DoesNotReturnAttribute]
public static void Fail(string message, object arg1, object arg2);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[ContractAnnotationAttribute("=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[<f65dc85a-eee6-406b-bb85-472d872eae7c>DoesNotReturnAttribute]
public static void Fail(string message, object arg1, object arg2, object arg3);
    [ContractAnnotationAttribute("=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[<f65dc85a-eee6-406b-bb85-472d872eae7c>DoesNotReturnAttribute]
public static void Fail(string message, Object[] args);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, JetNotNullConditionalInterpolatedStringHandler& messageHandler);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, object arg);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, object arg1, object arg2);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, object arg1, object arg2, object arg3);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Object[] args);
    [ExtensionAttribute]
[ContractAnnotationAttribute("value:null => void; => value:notnull, notnull")]
public static T NotNull(T value, string message);
    [ExtensionAttribute]
[ContractAnnotationAttribute("value:null => void; => value:notnull, notnull")]
public static T NotNull(T value, JetNotNullConditionalInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
[ContractAnnotationAttribute("value:null => void; => value:notnull, notnull")]
[StringFormatMethodAttribute("args")]
public static T NotNull(T value, string message, Object[] args);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("0")]
[ExtensionAttribute]
[ContractAnnotationAttribute("value:null => void; => value:notnull")]
public static T NotNull(Nullable`1<T> value, string message);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("0")]
[ExtensionAttribute]
[ContractAnnotationAttribute("value:null => void; => value:notnull")]
public static T NotNull(Nullable`1<T> value, JetNotNullConditionalInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
[ContractAnnotationAttribute("value:null => void; => value:notnull, notnull")]
public static T NotNull(T value, object debugMessage);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
public static void Require(bool value, string message);
    [StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
public static void Require(bool value, JetConditionalInterpolatedStringHandler& messageHandler);
    [StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
public static void Require(bool value, string message, object arg1);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
public static void Require(bool value, string message, object arg1, object arg2);
    [StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
public static void Require(bool value, string message, Object[] args);
    [ContractAnnotationAttribute("=> halt")]
[StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
[<f65dc85a-eee6-406b-bb85-472d872eae7c>DoesNotReturnAttribute]
public static T FailWithResult(T result, string message);
    [ContractAnnotationAttribute("=> halt")]
[StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
[<f65dc85a-eee6-406b-bb85-472d872eae7c>DoesNotReturnAttribute]
public static T FailWithResult(T result, string message, object arg);
    [ContractAnnotationAttribute("=> halt")]
[StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
[<f65dc85a-eee6-406b-bb85-472d872eae7c>DoesNotReturnAttribute]
public static T FailWithResult(T result, string message, object arg1, object arg2);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[ContractAnnotationAttribute("=> halt")]
[StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
[<f65dc85a-eee6-406b-bb85-472d872eae7c>DoesNotReturnAttribute]
public static T FailWithResult(T result, string message, object arg1, object arg2, object arg3);
    [ContractAnnotationAttribute("=> halt")]
[StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
[<f65dc85a-eee6-406b-bb85-472d872eae7c>DoesNotReturnAttribute]
public static T FailWithResult(T result, string message, Object[] args);
}
public static class JetBrains.Diagnostics.FirstChanceExceptionInterceptor : object {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
[ThreadStaticAttribute]
private static Stack ourThreadLocalDebugInfo;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("1")]
public static string ExceptionDataKey;
    private static FirstChanceExceptionInterceptor();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
private static Object[] GetThreadLocalDebugInfo();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public interface JetBrains.Diagnostics.ILog {
    public string Category { get; }
    public abstract virtual string get_Category();
    public abstract virtual bool IsEnabled(LoggingLevel level);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public abstract virtual void Log(LoggingLevel level, string message, Exception exception);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public interface JetBrains.Diagnostics.ILogFactory {
    public abstract virtual ILog GetLog(string category);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Diagnostics.Internal.LeveledMessage : ValueType {
    [CompilerGeneratedAttribute]
private LoggingLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormattedMessage>k__BackingField;
    public LoggingLevel Level { get; }
    public string FormattedMessage { get; }
    public LeveledMessage(LoggingLevel level, string formattedMessage);
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public LoggingLevel get_Level();
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_FormattedMessage();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public abstract class JetBrains.Diagnostics.Internal.LogBase : object {
    [CompilerGeneratedAttribute]
private Action`1<LeveledMessage> Handlers;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggingLevel <EnabledLevel>k__BackingField;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("1")]
public string Category { get; }
    public LoggingLevel EnabledLevel { get; public set; }
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
protected LogBase(string category, LoggingLevel enabledLevel);
    [CompilerGeneratedAttribute]
public void add_Handlers(Action`1<LeveledMessage> value);
    [CompilerGeneratedAttribute]
public void remove_Handlers(Action`1<LeveledMessage> value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_Category();
    [CompilerGeneratedAttribute]
public LoggingLevel get_EnabledLevel();
    [CompilerGeneratedAttribute]
public void set_EnabledLevel(LoggingLevel value);
    public sealed virtual bool IsEnabled(LoggingLevel level);
    protected abstract virtual string Format(LoggingLevel level, string message, Exception exception);
    public virtual void Log(LoggingLevel level, string message, Exception exception);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public abstract class JetBrains.Diagnostics.Internal.LogFactoryBase : object {
    [CompilerGeneratedAttribute]
private Action`1<LeveledMessage> Handlers;
    [CompilerGeneratedAttribute]
public void add_Handlers(Action`1<LeveledMessage> value);
    [CompilerGeneratedAttribute]
public void remove_Handlers(Action`1<LeveledMessage> value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public sealed virtual ILog GetLog(string category);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
protected abstract virtual LogBase GetLogBase(string category);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Diagnostics.Internal.NullLog : object {
    public static NullLog Instance;
    private string JetBrains.Diagnostics.ILog.Category { get; }
    private static NullLog();
    private sealed virtual override string JetBrains.Diagnostics.ILog.get_Category();
    private sealed virtual override bool JetBrains.Diagnostics.ILog.IsEnabled(LoggingLevel level);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
private sealed virtual override void JetBrains.Diagnostics.ILog.Log(LoggingLevel level, string message, Exception exception);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Diagnostics.Internal.SingletonLogFactory : object {
    private ILog myLog;
    public SingletonLogFactory(ILog log);
    public sealed virtual ILog GetLog(string category);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Diagnostics.Internal.TextWriterLog : LogBase {
    [CompilerGeneratedAttribute]
private TextWriter <Writer>k__BackingField;
    [PublicAPIAttribute]
public TextWriter Writer { get; }
    public TextWriterLog(TextWriter writer, string category, LoggingLevel enabledLevel);
    [CompilerGeneratedAttribute]
public TextWriter get_Writer();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
protected virtual string Format(LoggingLevel level, string message, Exception exception);
    private void WriteMessage(LeveledMessage msg);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Diagnostics.Internal.TextWriterLogFactory : LogFactoryBase {
    [CompilerGeneratedAttribute]
private LoggingLevel <EnabledLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <Writer>k__BackingField;
    public LoggingLevel EnabledLevel { get; }
    public TextWriter Writer { get; }
    public TextWriterLogFactory(TextWriter writer, LoggingLevel enabledLevel);
    [CompilerGeneratedAttribute]
public LoggingLevel get_EnabledLevel();
    [CompilerGeneratedAttribute]
public TextWriter get_Writer();
    protected virtual LogBase GetLogBase(string category);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Diagnostics.Log : object {
    private static StaticsForType`1<ILogFactory> ourStatics;
    private static ILogFactory modreq(System.Runtime.CompilerServices.IsVolatile) ourCurrentFactory;
    public static ILog Root;
    public static ILogFactory ConsoleVerboseFactory;
    public static string DefaultDateFormat;
    public static ILogFactory DefaultFactory { get; public set; }
    private static Log();
    public static ILogFactory get_DefaultFactory();
    public static void set_DefaultFactory(ILogFactory value);
    public static IDisposable UsingLogFactory(ILogFactory factory);
    public static ILog GetLog(string category);
    public static ILog GetLog(Type type);
    public static ILog GetLog();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public static string DefaultFormat(Nullable`1<DateTime> date, LoggingLevel loggingLevel, string category, Thread thread, string message, Exception exception);
    public static TextWriterLogFactory CreateFileLogFactory(Lifetime lifetime, string path, bool append, LoggingLevel enabledLevel);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Diagnostics.LogEx : object {
    [ExtensionAttribute]
public static ILog GetSublogger(ILog log, string subcategory);
    [ExtensionAttribute]
public static bool IsTraceEnabled(ILog this);
    [ExtensionAttribute]
public static bool IsVersboseEnabled(ILog this);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogFormat(ILog this, LoggingLevel level, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogFormat(ILog this, LoggingLevel level, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogFormat(ILog this, LoggingLevel level, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogFormat(ILog this, LoggingLevel level, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogFormat(ILog this, LoggingLevel level, string message, Object[] args);
    [ExtensionAttribute]
public static void Trace(ILog this, string message);
    [ExtensionAttribute]
public static void Trace(ILog logger, JetLogTraceInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILog this, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILog this, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILog this, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILog this, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILog this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILog this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6);
    [ExtensionAttribute]
public static void Verbose(ILog this, string message);
    [ExtensionAttribute]
public static void Verbose(ILog logger, JetLogVerboseInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
public static void Verbose(ILog logger, Exception ex, JetLogVerboseInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILog this, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILog this, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILog this, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILog this, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILog this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILog this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILog this, string message, Object[] args);
    [ExtensionAttribute]
public static void Verbose(ILog this, Exception ex, string message);
    [ExtensionAttribute]
public static void Info(ILog this, string message);
    [ExtensionAttribute]
public static void Info(ILog logger, JetLogInfoInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
public static void Info(ILog logger, Exception ex, JetLogInfoInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Info(ILog this, string message, Object[] args);
    [ExtensionAttribute]
public static void Info(ILog this, Exception ex, string message);
    [ExtensionAttribute]
public static void Warn(ILog this, string message);
    [ExtensionAttribute]
public static void Warn(ILog logger, JetLogWarnInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
public static void Warn(ILog logger, Exception ex, JetLogWarnInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Warn(ILog this, string message, Object[] args);
    [ExtensionAttribute]
public static void Warn(ILog this, Exception ex, string message);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILog this, string message);
    [ExtensionAttribute]
public static void Error(ILog logger, JetLogErrorInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILog logger, Exception ex, JetLogErrorInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILog this, string message, Object[] args);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILog this, string message, Exception e);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILog this, Exception ex, string message);
    [ExtensionAttribute]
public static void Assert(ILog this, bool condition, string message);
    [ExtensionAttribute]
public static void Assert(ILog this, bool condition, string message, T t1);
    [ExtensionAttribute]
public static void Assert(ILog this, bool condition, string message, Object[] args);
    [ExtensionAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void Catch(ILog log, Action action);
    [ExtensionAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[PublicAPIAttribute]
public static T Catch(ILog log, Func`1<T> action);
    [ExtensionAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[PublicAPIAttribute]
public static void CatchAndDrop(ILog log, Action action);
    [ExtensionAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[PublicAPIAttribute]
public static T CatchAndDrop(ILog log, Func`1<T> action);
    [ExtensionAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[PublicAPIAttribute]
public static void CatchWarn(ILog log, Action action);
    [ExtensionAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[PublicAPIAttribute]
public static T CatchWarn(ILog log, Func`1<T> action);
    private static void DropException(Exception e);
    [ExtensionAttribute]
[StringFormatMethodAttribute("s")]
private static string FormatEx(string s, Object[] p);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static Nullable`1<LogWithLevel> WhenTrace(ILog logger);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static Nullable`1<LogWithLevel> WhenVerbose(ILog logger);
    [ExtensionAttribute]
[ObsoleteAttribute("Renamed to WhenTrace")]
public static Nullable`1<LogWithLevel> Trace(ILog logger);
    [ExtensionAttribute]
[ObsoleteAttribute("Renamed to WhenVerbose")]
public static Nullable`1<LogWithLevel> Verbose(ILog logger);
}
public enum JetBrains.Diagnostics.LoggingLevel : Enum {
    public int value__;
    public static LoggingLevel OFF;
    public static LoggingLevel FATAL;
    public static LoggingLevel ERROR;
    public static LoggingLevel WARN;
    public static LoggingLevel INFO;
    public static LoggingLevel VERBOSE;
    public static LoggingLevel TRACE;
}
[ExtensionAttribute]
public static class JetBrains.Diagnostics.LoggingLevelEx : object {
    [ExtensionAttribute]
public static bool IsSeriousError(LoggingLevel level);
    [ExtensionAttribute]
public static LoggingLevel AtLeast(Nullable`1<LoggingLevel> level, LoggingLevel least);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public static class JetBrains.Diagnostics.LogLog : object {
    private static LoggingLevel modreq(System.Runtime.CompilerServices.IsVolatile) ourSeverityFilter;
    private static object ourLock;
    private static List`1<Action`1<LogLogRecord>> ourEventListeners;
    [ThreadStaticAttribute]
private static bool ourReentrancyGuard;
    private static int MaxRecordsToStore;
    private static LinkedList`1<LogLogRecord> ourRecords;
    public static LoggingLevel SeverityFilter { get; public set; }
    public static List`1<LogLogRecord> StoredRecords { get; }
    private static LogLog();
    public static LoggingLevel get_SeverityFilter();
    public static void set_SeverityFilter(LoggingLevel value);
    public static void add_RecordsChanged(Action`1<LogLogRecord> value);
    public static void remove_RecordsChanged(Action`1<LogLogRecord> value);
    private static void Fire(string category, string msg, LoggingLevel severity);
    private static void RecordsStoreListener(LogLogRecord record);
    public static List`1<LogLogRecord> get_StoredRecords();
    public static void Error(Exception ex, string comment);
    public static void Error(string error);
    public static void Warn(string message);
    [StringFormatMethodAttribute("format")]
public static void Warn(string format, Object[] args);
    public static void Info(string message);
    [StringFormatMethodAttribute("format")]
public static void Info(string format, Object[] args);
    public static void Verbose(string category, string message);
    [StringFormatMethodAttribute("format")]
public static void Verbose(string category, string format, Object[] args);
    public static void Trace(string category, string message);
    [StringFormatMethodAttribute("format")]
public static void Trace(string category, string format, Object[] args);
    [StringFormatMethodAttribute("format")]
public static void Trace(string category, string format, T1 arg);
    [StringFormatMethodAttribute("format")]
public static void Trace(string category, string format, T1 arg1, T2 arg2);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static void Catch(string comment, Action action);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static void Catch(Action action);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[HandleProcessCorruptedStateExceptionsAttribute]
public static T Catch(Func`1<T> action);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Diagnostics.LogLogRecord : object {
    [CompilerGeneratedAttribute]
private DateTime <Time>k__BackingField;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggingLevel <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public DateTime Time { get; }
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
public string Category { get; }
    public LoggingLevel Severity { get; }
    public string Message { get; }
    public LogLogRecord(string category, LoggingLevel severity, string message);
    [CompilerGeneratedAttribute]
public DateTime get_Time();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public LoggingLevel get_Severity();
    [CompilerGeneratedAttribute]
public string get_Message();
    public string Format(bool includeDate);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Diagnostics.LogWithLevel : ValueType {
    [CompilerGeneratedAttribute]
private ILog <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggingLevel <Level>k__BackingField;
    [PublicAPIAttribute]
public ILog Logger { get; }
    [PublicAPIAttribute]
public LoggingLevel Level { get; }
    [PublicAPIAttribute]
public LogWithLevel(ILog logger, LoggingLevel level);
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ILog get_Logger();
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public LoggingLevel get_Level();
    [PublicAPIAttribute]
public void Log(string message);
    [PublicAPIAttribute]
public static Nullable`1<LogWithLevel> CreateIfEnabled(ILog logger, LoggingLevel level);
}
public static class JetBrains.Diagnostics.Mode : object {
    public static bool IsAssertion;
    public static bool IsAssertionUndefined;
    private static Mode();
}
public static class JetBrains.Diagnostics.ModeInitializer : object {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("1")]
public static string AssertionEnabledVariableName;
    public static bool Init(bool isAssertionEnabled);
    public static bool GetIsAssertion();
    public static bool GetIsAssertionUndefined();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[PublicAPIAttribute]
public static class JetBrains.Diagnostics.ProcessWatchdog : object {
    private static ILog ourLogger;
    private static int DELAY_BEFORE_RETRY;
    private static int ERROR_INVALID_PARAMETER;
    private static ProcessWatchdog();
    public static void StartWatchdogForPidEnvironmentVariable(string envVarName, Action beforeProcessKill);
    public static void StartWatchdogForPidEnvironmentVariable(string envVarName, Lifetime lifetime, Nullable`1<TimeSpan> gracefulShutdownPeriod, Action beforeProcessKill);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public static void StartWatchdogForPid(int pid, Action beforeProcessKill);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public static void StartWatchdogForPid(int pid, Lifetime lifetime, Nullable`1<TimeSpan> gracefulShutdownPeriod, Action beforeProcessKill);
    private static int kill(int pid, int sig);
    public static bool ProcessExists(int pid, Boolean& useWinApi);
    private static bool ProcessExists_Windows(int pid);
    private static bool ProcessExists_SystemDiagnostics(int pid);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Diagnostics.RName : object {
    [PublicAPIAttribute]
public static RName Empty;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
[PublicAPIAttribute]
public object Parent;
    [PublicAPIAttribute]
public string Separator;
    [PublicAPIAttribute]
public object LocalName;
    public RName(object parent, object localName, string separator);
    public RName(object localName);
    private static RName();
    public RName Sub(object localName, string separator);
    public RName GetNonEmptyRoot();
    public RName DropNonEmptyRoot();
    public virtual string ToString();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[<38a4eff7-7a49-47b5-aea6-62ba43680c54>IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
public class JetBrains.Diagnostics.StringInterpolation.JetConditionalInterpolatedStringHandler : ValueType {
    private JetDefaultInterpolatedStringHandler myHandler;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    public bool IsEnabled { get; }
    public JetConditionalInterpolatedStringHandler(int literalLength, int formattedCount, bool condition, Boolean& isEnabled);
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsEnabled();
    public virtual string ToString();
    public string ToStringAndClear();
    public void AppendLiteral(string value);
    public void AppendFormatted(T value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    public void AppendFormatted(T value, int alignment);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(string value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(string value, int alignment, string format);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(object value, int alignment, string format);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
internal class JetBrains.Diagnostics.StringInterpolation.JetDefaultInterpolatedStringHandler : ValueType {
    private StringBuilder myBuffer;
    public JetDefaultInterpolatedStringHandler(int literalLength, int formattedCount);
    public string ToStringAndClear();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendLiteral(string value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
private string ToStringFormatted(T value, string format);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    public void AppendFormatted(T value, int alignment);
    public void AppendFormatted(T value);
    public virtual string ToString();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[<38a4eff7-7a49-47b5-aea6-62ba43680c54>IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
public class JetBrains.Diagnostics.StringInterpolation.JetLogErrorInterpolatedStringHandler : ValueType {
    private JetLogLevelInterpolatedStringHandler myHandler;
    public bool IsEnabled { get; }
    public JetLogErrorInterpolatedStringHandler(int literalLength, int formattedCount, ILog logger, Boolean& isEnabled);
    public bool get_IsEnabled();
    public virtual string ToString();
    public string ToStringAndClear();
    public void AppendLiteral(string value);
    public void AppendFormatted(T value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    public void AppendFormatted(T value, int alignment);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(string value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(string value, int alignment, string format);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(object value, int alignment, string format);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[<38a4eff7-7a49-47b5-aea6-62ba43680c54>IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
public class JetBrains.Diagnostics.StringInterpolation.JetLogInfoInterpolatedStringHandler : ValueType {
    private JetLogLevelInterpolatedStringHandler myHandler;
    public bool IsEnabled { get; }
    public JetLogInfoInterpolatedStringHandler(int literalLength, int formattedCount, ILog logger, Boolean& isEnabled);
    public bool get_IsEnabled();
    public virtual string ToString();
    public string ToStringAndClear();
    public void AppendLiteral(string value);
    public void AppendFormatted(T value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    public void AppendFormatted(T value, int alignment);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(string value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(string value, int alignment, string format);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(object value, int alignment, string format);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[<38a4eff7-7a49-47b5-aea6-62ba43680c54>IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
public class JetBrains.Diagnostics.StringInterpolation.JetLogLevelInterpolatedStringHandler : ValueType {
    private JetConditionalInterpolatedStringHandler myHandler;
    public bool IsEnabled { get; }
    public JetLogLevelInterpolatedStringHandler(int literalLength, int formattedCount, ILog logger, LoggingLevel logLevel, Boolean& isEnabled);
    public bool get_IsEnabled();
    public virtual string ToString();
    public string ToStringAndClear();
    public void AppendLiteral(string value);
    public void AppendFormatted(T value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    public void AppendFormatted(T value, int alignment);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(string value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(string value, int alignment, string format);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(object value, int alignment, string format);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[<38a4eff7-7a49-47b5-aea6-62ba43680c54>IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
public class JetBrains.Diagnostics.StringInterpolation.JetLogTraceInterpolatedStringHandler : ValueType {
    private JetLogLevelInterpolatedStringHandler myHandler;
    public bool IsEnabled { get; }
    public JetLogTraceInterpolatedStringHandler(int literalLength, int formattedCount, ILog logger, Boolean& isEnabled);
    public bool get_IsEnabled();
    public virtual string ToString();
    public string ToStringAndClear();
    public void AppendLiteral(string value);
    public void AppendFormatted(T value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    public void AppendFormatted(T value, int alignment);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(string value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(string value, int alignment, string format);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(object value, int alignment, string format);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[<38a4eff7-7a49-47b5-aea6-62ba43680c54>IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
public class JetBrains.Diagnostics.StringInterpolation.JetLogVerboseInterpolatedStringHandler : ValueType {
    private JetLogLevelInterpolatedStringHandler myHandler;
    public bool IsEnabled { get; }
    public JetLogVerboseInterpolatedStringHandler(int literalLength, int formattedCount, ILog logger, Boolean& isEnabled);
    public bool get_IsEnabled();
    public virtual string ToString();
    public string ToStringAndClear();
    public void AppendLiteral(string value);
    public void AppendFormatted(T value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    public void AppendFormatted(T value, int alignment);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(string value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(string value, int alignment, string format);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(object value, int alignment, string format);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[<38a4eff7-7a49-47b5-aea6-62ba43680c54>IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
public class JetBrains.Diagnostics.StringInterpolation.JetLogWarnInterpolatedStringHandler : ValueType {
    private JetLogLevelInterpolatedStringHandler myHandler;
    public bool IsEnabled { get; }
    public JetLogWarnInterpolatedStringHandler(int literalLength, int formattedCount, ILog logger, Boolean& isEnabled);
    public bool get_IsEnabled();
    public virtual string ToString();
    public string ToStringAndClear();
    public void AppendLiteral(string value);
    public void AppendFormatted(T value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    public void AppendFormatted(T value, int alignment);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(string value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(string value, int alignment, string format);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void AppendFormatted(object value, int alignment, string format);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[<38a4eff7-7a49-47b5-aea6-62ba43680c54>IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
public class JetBrains.Diagnostics.StringInterpolation.JetNotNullConditionalInterpolatedStringHandler : ValueType {
    private JetConditionalInterpolatedStringHandler myHandler;
    public bool IsEnabled { get; }
    public JetNotNullConditionalInterpolatedStringHandler(int literalLength, int formattedCount, object obj, Boolean& isEnabled);
    public bool get_IsEnabled();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public virtual string ToString();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public string ToStringAndClear();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public void AppendLiteral(string value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public void AppendFormatted(T value);
    public void AppendFormatted(T value, string format);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public void AppendFormatted(T value, int alignment);
    public void AppendFormatted(T value, int alignment, string format);
    public void AppendFormatted(string value);
    public void AppendFormatted(string value, int alignment, string format);
    public void AppendFormatted(object value, int alignment, string format);
}
internal static class JetBrains.Interop.Kernel32 : object {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("1")]
private static string DllName;
    public static IntPtr OpenProcess(ProcessAccessRights dwDesiredAccess, bool bInheritHandle, int dwProcessId);
    public static bool GetExitCodeProcess(IntPtr hProcess, ProcessExitCode& lpExitCode);
    public static bool CloseHandle(IntPtr handle);
}
[FlagsAttribute]
internal enum JetBrains.Interop.ProcessAccessRights : Enum {
    public int value__;
    public static ProcessAccessRights DELETE;
    public static ProcessAccessRights READ_CONTROL;
    public static ProcessAccessRights SYNCHRONIZE;
    public static ProcessAccessRights WRITE_DAC;
    public static ProcessAccessRights WRITE_OWNER;
    public static ProcessAccessRights PROCESS_CREATE_PROCESS;
    public static ProcessAccessRights PROCESS_CREATE_THREAD;
    public static ProcessAccessRights PROCESS_DUP_HANDLE;
    public static ProcessAccessRights PROCESS_QUERY_INFORMATION;
    public static ProcessAccessRights PROCESS_QUERY_LIMITED_INFORMATION;
    public static ProcessAccessRights PROCESS_SET_INFORMATION;
    public static ProcessAccessRights PROCESS_SET_QUOTA;
    public static ProcessAccessRights PROCESS_SUSPEND_RESUME;
    public static ProcessAccessRights PROCESS_TERMINATE;
    public static ProcessAccessRights PROCESS_VM_OPERATION;
    public static ProcessAccessRights PROCESS_VM_READ;
    public static ProcessAccessRights PROCESS_VM_WRITE;
}
internal enum JetBrains.Interop.ProcessExitCode : Enum {
    public int value__;
    public static ProcessExitCode STILL_ALIVE;
}
public interface JetBrains.Lifetimes.ITerminationHandler {
    public abstract virtual void OnTermination(Lifetime lifetime);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
public class JetBrains.Lifetimes.Lifetime : ValueType {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
private LifetimeDefinition myDefinition;
    public static AsyncLocal`1<Lifetime> AsyncLocal;
    internal LifetimeDefinition Definition { get; }
    [PublicAPIAttribute]
public static Lifetime Eternal { get; }
    [PublicAPIAttribute]
public static Lifetime Terminated { get; }
    [PublicAPIAttribute]
public LifetimeStatus Status { get; }
    [PublicAPIAttribute]
public bool IsEternal { get; }
    [PublicAPIAttribute]
public bool IsAlive { get; }
    [PublicAPIAttribute]
public bool IsNotAlive { get; }
    [PublicAPIAttribute]
public LifetimeTerminationTimeoutKind TerminationTimeoutKind { get; }
    [PublicAPIAttribute]
public bool AllowTerminationUnderExecution { get; }
    [PublicAPIAttribute]
public int ExecutingCount { get; }
    [ObsoleteAttribute("For most cases you need `IsNotAlive` which means lifetime is terminated or soon will be terminated (somebody called Terminate() on this lifetime or its parent). If your operation makes sense in Canceling status (but must be stopped when resources termination already began) use Status < Terminating ")]
public bool IsTerminated { get; }
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
[PublicAPIAttribute]
public object Id { get; public set; }
    internal Lifetime(LifetimeDefinition definition);
    private static Lifetime();
    internal LifetimeDefinition get_Definition();
    public static Lifetime get_Eternal();
    public static Lifetime get_Terminated();
    public LifetimeStatus get_Status();
    public bool get_IsEternal();
    public bool get_IsAlive();
    public bool get_IsNotAlive();
    public LifetimeTerminationTimeoutKind get_TerminationTimeoutKind();
    public bool get_AllowTerminationUnderExecution();
    [PublicAPIAttribute]
public Lifetime OnTermination(Action action);
    [PublicAPIAttribute]
public Lifetime OnTermination(IDisposable disposable);
    [PublicAPIAttribute]
public Lifetime OnTermination(ITerminationHandler terminationHandler);
    [PublicAPIAttribute]
public bool TryOnTermination(Action action);
    [PublicAPIAttribute]
public bool TryOnTermination(IDisposable disposable);
    [PublicAPIAttribute]
public bool TryOnTermination(ITerminationHandler disposable);
    [PublicAPIAttribute]
public void Attach(LifetimeDefinition child, bool inheritTimeoutKind);
    public int get_ExecutingCount();
    [PublicAPIAttribute]
public AllowTerminationUnderExecutionCookie UsingAllowTerminationUnderExecution();
    [PublicAPIAttribute]
public ExecuteIfAliveCookie UsingExecuteIfAlive(bool allowTerminationUnderExecution);
    [PublicAPIAttribute]
public Result`1<T> TryExecute(Func`1<T> action, bool wrapExceptions);
    [PublicAPIAttribute]
public Result`1<Unit> TryExecute(Action action, bool wrapExceptions);
    [PublicAPIAttribute]
public T Execute(Func`1<T> action);
    [PublicAPIAttribute]
public void Execute(Action action);
    [PublicAPIAttribute]
public Result`1<Unit> TryBracket(Action opening, Action closing, bool wrapExceptions);
    [PublicAPIAttribute]
public Result`1<T> TryBracket(Func`1<T> opening, Action closing, bool wrapExceptions);
    [PublicAPIAttribute]
public Result`1<T> TryBracket(Func`1<T> opening, Action`1<T> closing, bool wrapExceptions);
    [PublicAPIAttribute]
public void Bracket(Action opening, Action closing);
    [PublicAPIAttribute]
public T Bracket(Func`1<T> opening, Action closing);
    [PublicAPIAttribute]
public T Bracket(Func`1<T> opening, Action`1<T> closing);
    [PublicAPIAttribute]
public CancellationToken ToCancellationToken();
    [PublicAPIAttribute]
public static CancellationToken op_Implicit(Lifetime lifetime);
    [PublicAPIAttribute]
public void ThrowIfNotAlive();
    [PublicAPIAttribute]
public static void Using(Action`1<Lifetime> action);
    [PublicAPIAttribute]
public static T Using(Func`2<Lifetime, T> action);
    [PublicAPIAttribute]
public void UsingNested(Action`1<Lifetime> action);
    [PublicAPIAttribute]
public T UsingNested(Func`2<Lifetime, T> action);
    [AsyncStateMachineAttribute("JetBrains.Lifetimes.Lifetime/<UsingAsync>d__49")]
[PublicAPIAttribute]
public static Task UsingAsync(Func`2<Lifetime, Task> action);
    [AsyncStateMachineAttribute("JetBrains.Lifetimes.Lifetime/<UsingAsync>d__50`1")]
[PublicAPIAttribute]
public static Task`1<T> UsingAsync(Func`2<Lifetime, Task`1<T>> action);
    [AsyncStateMachineAttribute("JetBrains.Lifetimes.Lifetime/<UsingAsync>d__51")]
[PublicAPIAttribute]
public static Task UsingAsync(OuterLifetime parent, Func`2<Lifetime, Task> action);
    [AsyncStateMachineAttribute("JetBrains.Lifetimes.Lifetime/<UsingAsync>d__52`1")]
[PublicAPIAttribute]
public static Task`1<T> UsingAsync(OuterLifetime parent, Func`2<Lifetime, Task`1<T>> action);
    [AsyncStateMachineAttribute("JetBrains.Lifetimes.Lifetime/<UsingNestedAsync>d__53`1")]
[PublicAPIAttribute]
public Task`1<TRetVal> UsingNestedAsync(Func`2<Lifetime, Task`1<TRetVal>> action);
    [AsyncStateMachineAttribute("JetBrains.Lifetimes.Lifetime/<UsingNestedAsync>d__54")]
public Task UsingNestedAsync(Func`2<Lifetime, Task> action);
    [PublicAPIAttribute]
public LifetimeDefinition CreateNested();
    [PublicAPIAttribute]
public LifetimeDefinition CreateNested(Action`1<LifetimeDefinition> atomicAction);
    [PublicAPIAttribute]
public Lifetime KeepAlive(object object);
    [PublicAPIAttribute]
public Lifetime AddDispose(IDisposable disposable);
    [ObsoleteAttribute("Use `Bracket` method instead")]
public Lifetime AddBracket(Action FOpening, Action FClosing);
    [ObsoleteAttribute("Use `OnTermination()` instead")]
public Lifetime AddAction(Action action);
    public bool get_IsTerminated();
    [ObsoleteAttribute("Use `KeepAlive() instead`")]
public Lifetime AddRef(object object);
    [ObsoleteAttribute("Reconsider your architecture and use Intersect")]
public static void Synchronize(LifetimeDefinition[] definitions);
    [PublicAPIAttribute]
public Lifetime Intersect(Lifetime other);
    [PublicAPIAttribute]
public static Lifetime Intersect(Lifetime lifetime1, Lifetime lifetime2);
    [PublicAPIAttribute]
public static Lifetime Intersect(Lifetime[] lifetimes);
    public static LifetimeDefinition DefineIntersection(Lifetime lifetime1, Lifetime lifetime2);
    [PublicAPIAttribute]
public static LifetimeDefinition DefineIntersection(Lifetime[] lifetimes);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public object get_Id();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void set_Id(object value);
    [PublicAPIAttribute]
public void EnableTerminationLogging();
    public virtual string ToString();
    public static LifetimeDefinition Define(Lifetime lifetime, string id, Action`1<LifetimeDefinition> atomicAction);
    public static LifetimeDefinition Define(Lifetime lifetime, Action`1<Lifetime> atomicAction);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public static LifetimeDefinition Define(Lifetime lifetime, string id, Action`1<Lifetime> atomicAction);
    [PureAttribute]
public static LifetimeDefinition Define(string id);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("0")]
private ScopedAsyncLocal`1<Lifetime> UsingAsyncLocal();
    [PublicAPIAttribute]
public Task ExecuteAsync(Func`1<Task> closure);
    [PublicAPIAttribute]
public Task`1<T> ExecuteAsync(Func`1<Task`1<T>> closure);
    [PublicAPIAttribute]
public Task TryExecuteAsync(Func`1<Task> closure, bool wrapExceptions);
    [PublicAPIAttribute]
public Task`1<T> TryExecuteAsync(Func`1<Task`1<T>> closure, bool wrapExceptions);
    [PublicAPIAttribute]
public Task Start(TaskScheduler scheduler, Action action, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task Start(TaskScheduler scheduler, Action`1<object> action, object state, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task`1<T> Start(TaskScheduler scheduler, Func`1<T> action, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task`1<T> Start(TaskScheduler scheduler, Func`2<object, T> action, object state, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task StartAsync(TaskScheduler scheduler, Func`1<Task> action, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task StartAsync(TaskScheduler scheduler, Func`2<object, Task> action, object state, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task`1<T> StartAsync(TaskScheduler scheduler, Func`1<Task`1<T>> action, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task`1<T> StartAsync(TaskScheduler scheduler, Func`2<object, Task`1<T>> action, object state, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task StartAttached(TaskScheduler scheduler, Action action, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task StartAttached(TaskScheduler scheduler, Action`1<object> action, object state, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task`1<T> StartAttached(TaskScheduler scheduler, Func`1<T> action, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task`1<T> StartAttached(TaskScheduler scheduler, Func`2<object, T> action, object state, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task StartAttachedAsync(TaskScheduler scheduler, Func`1<Task> action, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task StartAttachedAsync(TaskScheduler scheduler, Func`2<object, Task> action, object state, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task`1<T> StartAttachedAsync(TaskScheduler scheduler, Func`1<Task`1<T>> action, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task`1<T> StartAttachedAsync(TaskScheduler scheduler, Func`2<object, Task`1<T>> action, object state, TaskCreationOptions options);
    [PublicAPIAttribute]
public TaskCompletionSource`1<T> CreateTaskCompletionSource(TaskCreationOptions options);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[PublicAPIAttribute]
public Lifetime CreateTerminatedAfter(TimeSpan timeSpan, TaskScheduler terminationScheduler);
    public static bool op_Equality(Lifetime left, Lifetime right);
    public static bool op_Inequality(Lifetime left, Lifetime right);
    public sealed virtual bool Equals(Lifetime other);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [PublicAPIAttribute]
public static object WrapAsObject(Lifetime lifetime);
    [PublicAPIAttribute]
public static bool TryUnwrapAsObject(object obj, Lifetime& lifetime);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public Lifetime AssertEverTerminated(string comment);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[AsyncStateMachineAttribute("JetBrains.Lifetimes.Lifetime/<AssertTerminatesIn>d__110")]
public void AssertTerminatesIn(TimeSpan timeout, string comment);
    [AsyncStateMachineAttribute("JetBrains.Lifetimes.Lifetime/<RetryWhileOperationCancellingAsync>d__111")]
[PublicAPIAttribute]
public Task RetryWhileOperationCancellingAsync(Func`1<Task> task);
    [AsyncStateMachineAttribute("JetBrains.Lifetimes.Lifetime/<RetryWhileOperationCancellingAsync>d__112`1")]
[PublicAPIAttribute]
public Task`1<T> RetryWhileOperationCancellingAsync(Func`1<Task`1<T>> task);
}
public class JetBrains.Lifetimes.LifetimeCanceledException : OperationCanceledException {
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [PublicAPIAttribute]
public Lifetime Lifetime { get; }
    public LifetimeCanceledException(Lifetime lifetime);
    [CompilerGeneratedAttribute]
public Lifetime get_Lifetime();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Lifetimes.Lifetimed`1 : object {
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public Lifetime Lifetime { get; }
    public T Value { get; private set; }
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public Lifetimed`1(Lifetime lifetime, T value);
    [PublicAPIAttribute]
public void Deconstruct(Lifetime& lifetime, T& value);
    [CompilerGeneratedAttribute]
public Lifetime get_Lifetime();
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    private sealed virtual override void JetBrains.Lifetimes.ITerminationHandler.OnTermination(Lifetime lifetime);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Lifetimes.LifetimeDefinition : object {
    private static Signal`1<Lifetime> ourExecutionWasNotCancelledByTimeout;
    internal static ILog Log;
    [PublicAPIAttribute]
internal static LifetimeDefinition Eternal;
    [PublicAPIAttribute]
internal static LifetimeDefinition Terminated;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ThreadStaticAttribute]
private static Dictionary`2<LifetimeDefinition, int> ourThreadLocalExecuting;
    [ThreadStaticAttribute]
private static int ourAllowTerminationUnderExecutionThreadStatic;
    private static int WaitForExecutingInTerminationTimeoutMsDefault;
    [PublicAPIAttribute]
public static int WaitForExecutingInTerminationTimeoutMs;
    private static IntBitSlice ourExecutingSlice;
    private static Enum32BitSlice`1<LifetimeStatus> ourStatusSlice;
    private static BoolBitSlice ourMutexSlice;
    private static BoolBitSlice ourVerboseDiagnosticsSlice;
    private static BoolBitSlice ourAllowTerminationUnderExecutionSlice;
    private static BoolBitSlice ourLogErrorAfterExecution;
    private static Enum32BitSlice`1<LifetimeTerminationTimeoutKind> ourTerminationTimeoutKindSlice;
    private static Int32[] ourTerminationTimeoutMs;
    private static int ResourcesInitialCapacity;
    private int myResCount;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
private Object[] myResources;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myState;
    [PublicAPIAttribute]
public static string AnonymousLifetimeId;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
private CancellationTokenSource myCts;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
private object myId;
    public static ISource`1<Lifetime> ExecutionWasNotCancelledByTimeout { get; }
    public Lifetime Lifetime { get; }
    [PublicAPIAttribute]
public LifetimeStatus Status { get; }
    [PublicAPIAttribute]
public bool IsEternal { get; }
    public bool AllowTerminationUnderExecution { get; public set; }
    public LifetimeTerminationTimeoutKind TerminationTimeoutKind { get; public set; }
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
[PublicAPIAttribute]
public object Id { get; public set; }
    private bool IsVerboseLoggingEnabled { get; }
    [ObsoleteAttribute("Use `Lifetime.IsAlive` or `Status` field instead")]
public bool IsTerminated { get; }
    public int ExecutingCount { get; }
    private static LifetimeDefinition();
    public LifetimeDefinition(Lifetime parent);
    public LifetimeDefinition(Lifetime parent, Action`1<LifetimeDefinition> atomicAction);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public LifetimeDefinition(Lifetime parent, Action`1<Lifetime> atomicAction);
    public static ISource`1<Lifetime> get_ExecutionWasNotCancelledByTimeout();
    private int ThreadLocalExecuting(int increment);
    [PublicAPIAttribute]
public static int GetTerminationTimeoutMs(LifetimeTerminationTimeoutKind timeoutKind);
    [PublicAPIAttribute]
public static void SetTerminationTimeoutMs(LifetimeTerminationTimeoutKind timeoutKind, int milliseconds);
    public Lifetime get_Lifetime();
    public LifetimeStatus get_Status();
    public bool get_IsEternal();
    [PublicAPIAttribute]
public bool get_AllowTerminationUnderExecution();
    [PublicAPIAttribute]
public void set_AllowTerminationUnderExecution(bool value);
    [PublicAPIAttribute]
public LifetimeTerminationTimeoutKind get_TerminationTimeoutKind();
    [PublicAPIAttribute]
public void set_TerminationTimeoutKind(LifetimeTerminationTimeoutKind value);
    [HandleProcessCorruptedStateExceptionsAttribute]
internal void ExecuteOrTerminateOnFail(Action`1<LifetimeDefinition> atomicAction);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[HandleProcessCorruptedStateExceptionsAttribute]
internal void ExecuteOrTerminateOnFail(Action`1<Lifetime> atomicAction);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public object get_Id();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void set_Id(object value);
    private bool get_IsVerboseLoggingEnabled();
    public void EnableTerminationLogging();
    public virtual string ToString();
    private bool IncrementStatusIfEqualsTo(LifetimeStatus status);
    public sealed virtual void Dispose();
    public bool get_IsTerminated();
    private void Diagnostics(string msg);
    [PublicAPIAttribute]
public void Terminate();
    private void MarkCancelingRecursively();
    [HandleProcessCorruptedStateExceptionsAttribute]
private void Destruct();
    internal bool TryAdd(object action);
    internal Task Attached(Task task);
    internal Task`1<T> Attached(Task`1<T> task);
    internal void Attach(LifetimeDefinition child, bool inheritTimeoutKind);
    internal void OnTermination(object action);
    public int get_ExecutingCount();
    private void CheckNotNull(object action);
    private static Result`1<Unit> WrapOrThrow(Action action, bool wrap);
    private static Result`1<T> WrapOrThrow(Func`1<T> action, bool wrap);
    internal ExecuteIfAliveCookie UsingExecuteIfAlive(bool allowTerminationUnderExecution, bool disableIncrementThreadLocalExecuting);
    internal Result`1<T> TryExecute(Func`1<T> action, bool wrapExceptions);
    internal Result`1<Unit> TryExecute(Action action, bool wrapExceptions);
    internal Task TryExecuteAsync(Func`1<Task> closure, bool wrapExceptions);
    internal Task`1<T> TryExecuteAsync(Func`1<Task`1<T>> closure, bool wrapExceptions);
    internal T Execute(Func`1<T> action);
    internal void Execute(Action action);
    internal Task ExecuteAsync(Func`1<Task> closure);
    internal Task`1<T> ExecuteAsync(Func`1<Task`1<T>> closure);
    private void CheckNotNull(object opening, object closing);
    internal Result`1<Unit> TryBracket(Action opening, Action closing, bool wrapExceptions);
    internal Result`1<T> TryBracket(Func`1<T> opening, Action closing, bool wrapExceptions);
    internal Result`1<T> TryBracket(Func`1<T> opening, Action`1<T> closing, bool wrapExceptions);
    internal void Bracket(Action opening, Action closing);
    internal T Bracket(Func`1<T> opening, Action closing);
    internal T Bracket(Func`1<T> opening, Action`1<T> closing);
    private LifetimeCanceledException CanceledException();
    private Result`1<Nothing> CanceledResult();
    private CancellationTokenSource CreateCtsLazily();
    public void ThrowIfNotAlive();
    internal CancellationToken ToCancellationToken(bool doNotCreateCts);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[PublicAPIAttribute]
public void AssertEverTerminated(string comment);
    [PublicAPIAttribute]
public void SynchronizeWith(TaskCompletionSource`1<T> taskCompletionSource);
    [CompilerGeneratedAttribute]
private bool <Terminate>b__59_0();
    [CompilerGeneratedAttribute]
private bool <Terminate>b__59_1();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Lifetimes.LifetimedList`1 : ValueType {
    private int myState;
    private int mySize;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueLifetimed`1[] myItems;
    public void Add(Lifetime lifetime, T value);
    public void AddPriorityItem(Lifetime lifetime, T value);
    public void Add(ValueLifetimed`1<T> item);
    public void AddPriorityItem(ValueLifetimed`1<T> item);
    private bool EnsureCapacityNoLock(bool priority, ValueLifetimed`1[]& items, Int32& marker, Int32& size);
    public void ClearValuesIfNotAlive();
    private void EnterGlobalLock();
    private void ReleaseGlobalLock();
    private void EnterLocalLock();
    private void ReleaseLocalLock();
    private void EnterLock(BoolBitSlice slice);
    private void ReleaseLock(BoolBitSlice slice);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Lifetimes.LifetimedListEx : object {
    internal static BoolBitSlice GlobalMutexSlice;
    internal static BoolBitSlice LocalMutexSlice;
    internal static IntBitSlice MarkerMutexSlice;
    private static LifetimedListEx();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[IteratorStateMachineAttribute("JetBrains.Lifetimes.LifetimedListEx/<Select>d__3`2")]
[ExtensionAttribute]
public static IEnumerable`1<TOut> Select(LifetimedList`1<TIn> source, Func`2<ValueLifetimed`1<TIn>, TOut> selector);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[IteratorStateMachineAttribute("JetBrains.Lifetimes.LifetimedListEx/<Where>d__4`1")]
[ExtensionAttribute]
public static IEnumerable`1<ValueLifetimed`1<T>> Where(LifetimedList`1<T> source, Func`2<ValueLifetimed`1<T>, bool> predicate);
}
public enum JetBrains.Lifetimes.LifetimeStatus : Enum {
    public int value__;
    public static LifetimeStatus Alive;
    public static LifetimeStatus Canceling;
    public static LifetimeStatus Terminating;
    public static LifetimeStatus Terminated;
}
public enum JetBrains.Lifetimes.LifetimeTerminationTimeoutKind : Enum {
    public int value__;
    public static LifetimeTerminationTimeoutKind Default;
    public static LifetimeTerminationTimeoutKind Short;
    public static LifetimeTerminationTimeoutKind Long;
    public static LifetimeTerminationTimeoutKind ExtraLong;
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Lifetimes.OuterLifetime : ValueType {
    private Lifetime myLifetime;
    public bool IsTerminated { get; }
    internal LifetimeDefinition Def { get; }
    private OuterLifetime(Lifetime lifetime);
    public bool get_IsTerminated();
    public static OuterLifetime op_Implicit(Lifetime lifetime);
    public static OuterLifetime op_Implicit(LifetimeDefinition lifetime);
    public void AssertNotNull();
    public Task`1<TRetVal> UsingNestedAsync(Func`2<Lifetime, Task`1<TRetVal>> action);
    public Task UsingNestedAsync(Func`2<Lifetime, Task> action);
    internal LifetimeDefinition get_Def();
    public static LifetimeDefinition Define(OuterLifetime lifetime, string id, Action`2<LifetimeDefinition, Lifetime> atomicAction);
    [PublicAPIAttribute]
public static LifetimeDefinition DefineIntersection(OuterLifetime[] lifetimes);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Lifetimes.SequentialLifetimes : object {
    private Lifetime myParentLifetime;
    private LifetimeDefinition myCurrentDef;
    public bool IsCurrentTerminated { get; }
    public SequentialLifetimes(Lifetime lifetime);
    public Lifetime Next();
    public void Next(Action`1<Lifetime> atomicAction);
    public void DefineNext(Action`1<LifetimeDefinition> atomicAction);
    public void TerminateCurrent();
    public bool get_IsCurrentTerminated();
    private LifetimeDefinition TrySetNewAndTerminateOld(LifetimeDefinition newLifetimeDefinition, Action`1<LifetimeDefinition> actionWithNewLifetime);
    [CompilerGeneratedAttribute]
internal static void <TrySetNewAndTerminateOld>g__TerminateLifetimeDefinition|9_0(LifetimeDefinition lifetimeDefinition);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Lifetimes.ValueLifetimed`1 : ValueType {
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public Lifetime Lifetime { get; }
    public T Value { get; private set; }
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public ValueLifetimed`1(Lifetime lifetime, T value);
    public void Deconstruct(Lifetime& lifetime, T& value);
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Lifetime get_Lifetime();
    [<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    public void ClearValueIfNotAlive();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[<eef56720-e327-4776-9dd8-204dd3e85bc0>IsReadOnlyAttribute]
internal class JetBrains.Rd.Base.AllowBindCookie : ValueType {
    private bool myCreated;
    [ThreadStaticAttribute]
public static int IsBindAllowedCount;
    public static bool IsBindAllowed { get; }
    public static bool IsBindNotAllowed { get; }
    private AllowBindCookie(bool created);
    public static bool get_IsBindAllowed();
    public static bool get_IsBindNotAllowed();
    public static AllowBindCookie Create();
    public void Dispose();
}
public enum JetBrains.Rd.Base.BindState : Enum {
    public int value__;
    public static BindState NotBound;
    public static BindState PreBound;
    public static BindState Bound;
}
internal class JetBrains.Rd.Base.ExtWire : object {
    internal ViewableProperty`1<bool> Connected;
    public IWire RealWire;
    private Queue`1<QueueItem> mySendQ;
    public bool IsStub { get; }
    public ProtocolContexts Contexts { get; public set; }
    public sealed virtual bool get_IsStub();
    public sealed virtual ProtocolContexts get_Contexts();
    public sealed virtual void set_Contexts(ProtocolContexts value);
    public sealed virtual void Send(RdId id, TContext param, Action`2<TContext, UnsafeWriter> writer);
    public sealed virtual void Advise(Lifetime lifetime, IRdWireable entity);
    public sealed virtual IRdWireable TryGetById(RdId rdId);
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_0(Lifetime _);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface JetBrains.Rd.Base.IPerContextMap`2 {
    public RdContext`1<K> Context { get; }
    public V Item { get; }
    public abstract virtual RdContext`1<K> get_Context();
    public abstract virtual V GetForCurrentContext();
    public abstract virtual void View(Lifetime lifetime, Action`2<Lifetime, KeyValuePair`2<K, V>> handler);
    public abstract virtual void View(Lifetime lifetime, Action`3<Lifetime, K, V> handler);
    public abstract virtual V get_Item(K key);
    public abstract virtual bool TryGetValue(K key, V& value);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public interface JetBrains.Rd.Base.IPrintable {
    public abstract virtual void Print(PrettyPrinter printer);
}
public interface JetBrains.Rd.Base.IRdBindable {
    public RdId RdId { get; public set; }
    public abstract virtual RdId get_RdId();
    public abstract virtual void set_RdId(RdId value);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public abstract virtual void PreBind(Lifetime lf, IRdDynamic parent, string name);
    public abstract virtual void Bind();
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public abstract virtual void Identify(IIdentities identities, RdId id);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public interface JetBrains.Rd.Base.IRdDynamic {
    public RName Location { get; }
    public abstract virtual RName get_Location();
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public abstract virtual IProtocol TryGetProto();
    public abstract virtual bool TryGetSerializationContext(SerializationCtx& ctx);
}
public interface JetBrains.Rd.Base.IRdReactive {
    public bool Async { get; public set; }
    public abstract virtual bool get_Async();
    public abstract virtual void set_Async(bool value);
}
public interface JetBrains.Rd.Base.IRdWireable {
    public RdId RdId { get; }
    public abstract virtual RdId get_RdId();
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public abstract virtual void OnWireReceived(UnsafeReader reader, IRdWireableDispatchHelper dispatchHelper);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public interface JetBrains.Rd.Base.IRdWireableDispatchHelper {
    public RdId RdId { get; }
    public Lifetime Lifetime { get; }
    public abstract virtual RdId get_RdId();
    public abstract virtual Lifetime get_Lifetime();
    public abstract virtual void Dispatch(IScheduler scheduler, Action action);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
internal interface JetBrains.Rd.Base.ISingleContextHandler {
    public RdContextBase ContextBase { get; }
    public abstract virtual void WriteValue(SerializationCtx context, UnsafeWriter writer);
    public abstract virtual void RegisterValueInValueSet();
    public abstract virtual object ReadValueBoxed(SerializationCtx context, UnsafeReader reader);
    public abstract virtual RdContextBase get_ContextBase();
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
internal interface JetBrains.Rd.Base.ISingleContextHandler`1 {
    public RdContext`1<T> Context { get; }
    public abstract virtual RdContext`1<T> get_Context();
    public abstract virtual T ReadValue(SerializationCtx context, UnsafeReader reader);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Rd.Base.PrintableEx : object {
    [ExtensionAttribute]
public static void PrintEx(object me, PrettyPrinter printer);
    [ExtensionAttribute]
public static string PrintToString(object me);
    [ExtensionAttribute]
public static string PrintToStringNoLimits(object me);
}
public class JetBrains.Rd.Base.ProtocolNotBoundException : Exception {
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public ProtocolNotBoundException(string id);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public abstract class JetBrains.Rd.Base.RdBindableBase : object {
    [CompilerGeneratedAttribute]
private RdId <RdId>k__BackingField;
    internal static RName NotBound;
    [CompilerGeneratedAttribute]
private RName <Location>k__BackingField;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("2")]
protected IRdDynamic Parent;
    private Lifetime myBindLifetime;
    [CompilerGeneratedAttribute]
private BindState <BindState>k__BackingField;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected List`1<KeyValuePair`2<string, object>> BindableChildren;
    private IDictionary`2<string, object> myExtensions;
    public RdId RdId { get; public set; }
    public RName Location { get; private set; }
    public bool IsBound { get; }
    public BindState BindState { get; private set; }
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("2")]
public RdExtBase ContainingExt { get; }
    protected string ShortName { get; }
    private static RdBindableBase();
    [CompilerGeneratedAttribute]
public sealed virtual RdId get_RdId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RdId(RdId value);
    [CompilerGeneratedAttribute]
public sealed virtual RName get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(RName value);
    public bool get_IsBound();
    [CompilerGeneratedAttribute]
public BindState get_BindState();
    [CompilerGeneratedAttribute]
private void set_BindState(BindState value);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public virtual IProtocol TryGetProto();
    public virtual bool TryGetSerializationContext(SerializationCtx& ctx);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public RdExtBase get_ContainingExt();
    public sealed virtual void PreBind(Lifetime lf, IRdDynamic parent, string name);
    public sealed virtual void Bind();
    protected virtual void Unbind();
    public sealed virtual void OnTermination(Lifetime lifetime);
    protected virtual void AssertBindingThread();
    protected virtual void PreInit(Lifetime lifetime, IProtocol proto);
    protected virtual void Init(Lifetime lifetime, IProtocol proto, SerializationCtx ctx);
    protected virtual void PreInitBindableFields(Lifetime lifetime);
    protected virtual void InitBindableFields(Lifetime lifetime);
    public virtual void Identify(IIdentities identities, RdId id);
    public virtual RdBindableBase FindByRName(RName rName);
    protected virtual string get_ShortName();
    public virtual void Print(PrettyPrinter printer);
    public virtual string ToString();
    public T GetExtension(string name);
    public T GetOrCreateExtension(string name, Func`1<T> create);
    internal T GetOrCreateHighPriorityExtension(string name, Func`1<T> create);
    private T GetOrCreateExtension(string name, bool highPriorityExtension, Func`1<T> create);
    public virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Rd.Base.RdBindableEx : object {
    [ExtensionAttribute]
internal static void PreBindPolymorphic(object value, Lifetime lifetime, IRdDynamic parent, string name);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
[ExtensionAttribute]
internal static void BindPolymorphic(object value);
    [ExtensionAttribute]
internal static bool IsBindable(T obj);
    [ExtensionAttribute]
private static void PreBind0(IEnumerable items, Lifetime lifetime, IRdDynamic parent, string name);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
[ExtensionAttribute]
private static void Bind0(IEnumerable items);
    [ExtensionAttribute]
public static void PreBindEx(T value, Lifetime lifetime, IRdDynamic parent, string name);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("0")]
[ExtensionAttribute]
public static void BindEx(T value);
    [ExtensionAttribute]
public static void BindTopLevel(T value, Lifetime lifetime, IProtocol parent, string name);
    [ExtensionAttribute]
internal static void IdentifyPolymorphic(object value, IIdentities ids, RdId id);
    [ExtensionAttribute]
private static void Identify0(IEnumerable items, IIdentities ids, RdId id);
    [ExtensionAttribute]
public static void IdentifyEx(T value, IIdentities ids, RdId id);
    [ExtensionAttribute]
public static void IdentifyEx(List`1<T> items, IIdentities ids, RdId id);
    [ExtensionAttribute]
public static void IdentifyEx(T[] items, IIdentities ids, RdId id);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Base.RdDelegateBase`1 : object {
    [CompilerGeneratedAttribute]
private T <Delegate>k__BackingField;
    public T Delegate { get; }
    public RName Location { get; }
    public RdId RdId { get; public set; }
    public RdDelegateBase`1(T delegate);
    [CompilerGeneratedAttribute]
public T get_Delegate();
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public sealed virtual IProtocol TryGetProto();
    public sealed virtual bool TryGetSerializationContext(SerializationCtx& ctx);
    public sealed virtual RName get_Location();
    public sealed virtual void Print(PrettyPrinter printer);
    public virtual void PreBind(Lifetime lf, IRdDynamic parent, string name);
    public virtual void Bind();
    public sealed virtual void Identify(IIdentities identities, RdId id);
    public sealed virtual RdId get_RdId();
    public sealed virtual void set_RdId(RdId value);
}
[ExtensionAttribute]
public static class JetBrains.Rd.Base.RdDynamicEx : object {
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[ExtensionAttribute]
public static IProtocol GetProtoOrThrow(IRdDynamic dynamic);
}
public abstract class JetBrains.Rd.Base.RdExtBase : RdReactiveBase {
    private ExtWire myExtWire;
    [CanBeNullAttribute]
private IProtocol myExtProtocol;
    public IReadonlyProperty`1<bool> Connected;
    protected Action`1<ISerializers> Register { get; }
    protected long SerializationHash { get; }
    protected string ShortName { get; }
    public sealed virtual IProtocol TryGetProto();
    protected abstract virtual Action`1<ISerializers> get_Register();
    protected virtual long get_SerializationHash();
    protected virtual void PreInit(Lifetime lifetime, IProtocol parentProto);
    protected virtual void Init(Lifetime lifetime, IProtocol parentProto, SerializationCtx ctx);
    public virtual void OnWireReceived(IProtocol proto, SerializationCtx ctx, UnsafeReader reader, IRdWireableDispatchHelper dispatchHelper);
    private void SendState(IWire parentWire, ExtState state);
    protected virtual void InitBindableFields(Lifetime lifetime);
    protected virtual string get_ShortName();
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__0(Lifetime lifetime, IProtocol proto);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__1(Lifetime lifetime, IProtocol proto, SerializationCtx ctx);
}
public abstract class JetBrains.Rd.Base.RdReactiveBase : RdBindableBase {
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("1")]
internal static ILog ourLogReceived;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("1")]
internal static ILog ourLogSend;
    [CompilerGeneratedAttribute]
private bool <Async>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValueCanBeNull>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLocalChange>k__BackingField;
    internal static Nullable`1<LogWithLevel> ReceiveTrace { get; }
    internal static Nullable`1<LogWithLevel> SendTrace { get; }
    public bool Async { get; public set; }
    public bool ValueCanBeNull { get; public set; }
    public bool IsLocalChange { get; protected set; }
    private static RdReactiveBase();
    internal static Nullable`1<LogWithLevel> get_ReceiveTrace();
    internal static Nullable`1<LogWithLevel> get_SendTrace();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Async();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Async(bool value);
    [AssertionMethodAttribute]
protected virtual void AssertThreading();
    [CompilerGeneratedAttribute]
public bool get_ValueCanBeNull();
    [CompilerGeneratedAttribute]
public void set_ValueCanBeNull(bool value);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
protected internal void AssertNullability(T value);
    [AssertionMethodAttribute]
protected void AssertBound();
    [CompilerGeneratedAttribute]
public bool get_IsLocalChange();
    [CompilerGeneratedAttribute]
protected void set_IsLocalChange(bool value);
    protected internal ThreadLocalDebugInfo UsingDebugInfo();
    protected internal LocalChangeCookie UsingLocalChange();
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public sealed virtual void OnWireReceived(UnsafeReader reader, IRdWireableDispatchHelper dispatchHelper);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public abstract virtual void OnWireReceived(IProtocol proto, SerializationCtx ctx, UnsafeReader reader, IRdWireableDispatchHelper dispatchHelper);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Rd.Base.RdReactiveEx : object {
    [ExtensionAttribute]
public static void SetValue(IViewableProperty`1<T> p, T value);
    [ExtensionAttribute]
public static void Set(IViewableProperty`1<T> p, T value);
    [ExtensionAttribute]
public static T WithId(T thIs, RdId id);
    [ExtensionAttribute]
public static T Static(T thIs, int id);
    [ExtensionAttribute]
public static T WithIdFromName(T thIs, string name);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Rd.Base.RdWireableDispatchHelperEx : object {
    [ExtensionAttribute]
public static void Dispatch(IRdWireableDispatchHelper helper, IScheduler scheduler, Action action);
    [ExtensionAttribute]
public static void Dispatch(IRdWireableDispatchHelper helper, Action action);
}
public class JetBrains.Rd.CtxReadDelegate`1 : MulticastDelegate {
    public CtxReadDelegate`1(object object, IntPtr method);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public virtual T Invoke(SerializationCtx ctx, UnsafeReader reader);
    public virtual IAsyncResult BeginInvoke(SerializationCtx ctx, UnsafeReader reader, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
public class JetBrains.Rd.CtxWriteDelegate`1 : MulticastDelegate {
    public CtxWriteDelegate`1(object object, IntPtr method);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public virtual void Invoke(SerializationCtx ctx, UnsafeWriter writer, T value);
    public virtual IAsyncResult BeginInvoke(SerializationCtx ctx, UnsafeWriter writer, T value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.ExtCreationInfo : ValueType {
    public RName Name;
    public Nullable`1<RdId> Id;
    public long Hash;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("2")]
public RdExtBase Ext;
    public ExtCreationInfo(RName name, Nullable`1<RdId> id, long hash, RdExtBase ext);
}
public enum JetBrains.Rd.IdKind : Enum {
    public int value__;
    public static IdKind Client;
    public static IdKind Server;
}
public interface JetBrains.Rd.IIdentities {
    public abstract virtual RdId Next(RdId parent);
}
public interface JetBrains.Rd.IInternRoot`1 {
    public abstract virtual InternId TryGetInterned(TBase value);
    public abstract virtual InternId Intern(TBase value);
    public abstract virtual T UnIntern(InternId id);
    public abstract virtual bool TryUnIntern(InternId id, T& result);
    public abstract virtual void Remove(TBase value);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class JetBrains.Rd.Impl.AsyncRdMap`2 : object {
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private RdMapBackend<K, V> myMap;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncSignal`1<MapEvent`2<K, V>> mySignal;
    public bool IsMaster;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IAsyncSource`1<MapEvent`2<K, V>> Change { get; }
    public RdId RdId { get; public set; }
    public bool OptimizeNested { get; public set; }
    public bool ValueCanBeNull { get; public set; }
    public bool Async { get; public set; }
    public RName Location { get; }
    public V Item { get; public set; }
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    [PublicAPIAttribute]
public CtxReadDelegate`1<K> ReadKeyDelegate { get; }
    [PublicAPIAttribute]
public CtxWriteDelegate`1<K> WriteKeyDelegate { get; }
    [PublicAPIAttribute]
public CtxReadDelegate`1<V> ReadValueDelegate { get; }
    [PublicAPIAttribute]
public CtxWriteDelegate`1<V> WriteValueDelegate { get; }
    public AsyncRdMap`2(CtxReadDelegate`1<K> readKey, CtxWriteDelegate`1<K> writeKey, CtxReadDelegate`1<V> readValue, CtxWriteDelegate`1<V> writeValue);
    public IAsyncSource`1<MapEvent`2<K, V>> get_Change();
    public sealed virtual RdId get_RdId();
    public sealed virtual void set_RdId(RdId value);
    public sealed virtual void PreBind(Lifetime lf, IRdDynamic parent, string name);
    public sealed virtual void Bind();
    public sealed virtual void Identify(IIdentities identities, RdId id);
    public bool get_OptimizeNested();
    public void set_OptimizeNested(bool value);
    public bool get_ValueCanBeNull();
    public void set_ValueCanBeNull(bool value);
    public bool get_Async();
    public void set_Async(bool value);
    public sealed virtual RName get_Location();
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public sealed virtual IProtocol TryGetProto();
    public sealed virtual bool TryGetSerializationContext(SerializationCtx& ctx);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual void Add(K key, V value);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PublicAPIAttribute]
public static AsyncRdMap`2<K, V> Read(SerializationCtx ctx, UnsafeReader reader);
    [PublicAPIAttribute]
public static AsyncRdMap`2<K, V> Read(SerializationCtx ctx, UnsafeReader reader, CtxReadDelegate`1<K> readKey, CtxWriteDelegate`1<K> writeKey, CtxReadDelegate`1<V> readValue, CtxWriteDelegate`1<V> writeValue);
    [PublicAPIAttribute]
public static void Write(SerializationCtx ctx, UnsafeWriter writer, AsyncRdMap`2<K, V> value);
    public CtxReadDelegate`1<K> get_ReadKeyDelegate();
    public CtxWriteDelegate`1<K> get_WriteKeyDelegate();
    public CtxReadDelegate`1<V> get_ReadValueDelegate();
    public CtxWriteDelegate`1<V> get_WriteValueDelegate();
    public sealed virtual void Print(PrettyPrinter printer);
    public sealed virtual void AdviseOn(Lifetime lifetime, IScheduler scheduler, Action`1<MapEvent`2<K, V>> action);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(MapEvent`2<K, V> x);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Impl.AsyncRdProperty`1 : object {
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private CtxReadDelegate`1<T> <ReadValueDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private CtxWriteDelegate`1<T> <WriteValueDelegate>k__BackingField;
    public bool IsMaster;
    private int myMasterVersion;
    [CompilerGeneratedAttribute]
private RdId <RdId>k__BackingField;
    [CompilerGeneratedAttribute]
private RName <Location>k__BackingField;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("2")]
private IRdDynamic myParent;
    private Lifetime myBindLifetime;
    private ThreadLocal`1<bool> myIsLocalChange;
    [CompilerGeneratedAttribute]
private bool <ValueCanBeNull>k__BackingField;
    private IViewableProperty`1<T> myProperty;
    private AsyncSignal`1<T> myChange;
    public CtxReadDelegate`1<T> ReadValueDelegate { get; private set; }
    public CtxWriteDelegate`1<T> WriteValueDelegate { get; private set; }
    public bool OptimizeNested { get; public set; }
    public bool Async { get; public set; }
    public RdId RdId { get; public set; }
    public RName Location { get; private set; }
    public IAsyncSource`1<T> Change { get; }
    public bool ValueCanBeNull { get; public set; }
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Maybe`1<T> Maybe { get; }
    public T Value { get; public set; }
    public AsyncRdProperty`1(CtxReadDelegate`1<T> readValue, CtxWriteDelegate`1<T> writeValue);
    [PublicAPIAttribute]
public AsyncRdProperty`1(CtxReadDelegate`1<T> readValue, CtxWriteDelegate`1<T> writeValue, T defaultValue);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public CtxReadDelegate`1<T> get_ReadValueDelegate();
    [CompilerGeneratedAttribute]
private void set_ReadValueDelegate(CtxReadDelegate`1<T> value);
    [CompilerGeneratedAttribute]
public CtxWriteDelegate`1<T> get_WriteValueDelegate();
    [CompilerGeneratedAttribute]
private void set_WriteValueDelegate(CtxWriteDelegate`1<T> value);
    public static AsyncRdProperty`1<T> Read(SerializationCtx ctx, UnsafeReader reader);
    public static AsyncRdProperty`1<T> Read(SerializationCtx ctx, UnsafeReader reader, CtxReadDelegate`1<T> readValue, CtxWriteDelegate`1<T> writeValue);
    public static void Write(SerializationCtx ctx, UnsafeWriter writer, AsyncRdProperty`1<T> value);
    private void Write(SerializationCtx ctx, UnsafeWriter writer);
    public bool get_OptimizeNested();
    public void set_OptimizeNested(bool value);
    public sealed virtual bool get_Async();
    public sealed virtual void set_Async(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual RdId get_RdId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RdId(RdId value);
    [CompilerGeneratedAttribute]
public sealed virtual RName get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(RName value);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public sealed virtual IProtocol TryGetProto();
    public sealed virtual bool TryGetSerializationContext(SerializationCtx& ctx);
    public sealed virtual IAsyncSource`1<T> get_Change();
    public sealed virtual void Identify(IIdentities identities, RdId id);
    public sealed virtual void OnTermination(Lifetime lifetime);
    public sealed virtual void PreBind(Lifetime lifetime, IRdDynamic parent, string name);
    public sealed virtual void Bind();
    public sealed virtual void OnWireReceived(UnsafeReader reader, IRdWireableDispatchHelper dispatchHelper);
    [CompilerGeneratedAttribute]
public bool get_ValueCanBeNull();
    [CompilerGeneratedAttribute]
public void set_ValueCanBeNull(bool value);
    private void AssertNullability(T value);
    public sealed virtual Maybe`1<T> get_Maybe();
    public sealed virtual T get_Value();
    public sealed virtual void set_Value(T value);
    public sealed virtual void AdviseOn(Lifetime lifetime, IScheduler scheduler, Action`1<T> action);
    public sealed virtual void Print(PrettyPrinter printer);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0(T value);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Impl.AsyncRdSet`1 : object {
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private RdSetBackend<T> mySet;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncSignal`1<SetEvent`1<T>> mySignal;
    public bool IsMaster;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IAsyncSource`1<SetEvent`1<T>> Change { get; }
    public RdId RdId { get; public set; }
    public bool OptimizeNested { get; public set; }
    public bool ValueCanBeNull { get; public set; }
    public bool Async { get; public set; }
    public RName Location { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public CtxReadDelegate`1<T> ReadValueDelegate { get; }
    public CtxWriteDelegate`1<T> WriteValueDelegate { get; }
    public AsyncRdSet`1(CtxReadDelegate`1<T> readValue, CtxWriteDelegate`1<T> writeValue);
    public IAsyncSource`1<SetEvent`1<T>> get_Change();
    public sealed virtual RdId get_RdId();
    public sealed virtual void set_RdId(RdId value);
    public sealed virtual void PreBind(Lifetime lf, IRdDynamic parent, string name);
    public sealed virtual void Bind();
    public sealed virtual void Identify(IIdentities identities, RdId id);
    public bool get_OptimizeNested();
    public void set_OptimizeNested(bool value);
    public bool get_ValueCanBeNull();
    public void set_ValueCanBeNull(bool value);
    public bool get_Async();
    public void set_Async(bool value);
    public sealed virtual RName get_Location();
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public sealed virtual IProtocol TryGetProto();
    public sealed virtual bool TryGetSerializationContext(SerializationCtx& ctx);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public static AsyncRdSet`1<T> Read(SerializationCtx ctx, UnsafeReader reader);
    public static AsyncRdSet`1<T> Read(SerializationCtx ctx, UnsafeReader reader, CtxReadDelegate`1<T> readValue, CtxWriteDelegate`1<T> writeValue);
    public static void Write(SerializationCtx ctx, UnsafeWriter writer, AsyncRdSet`1<T> value);
    public CtxReadDelegate`1<T> get_ReadValueDelegate();
    public CtxWriteDelegate`1<T> get_WriteValueDelegate();
    public sealed virtual void Print(PrettyPrinter printer);
    public sealed virtual void AdviseOn(Lifetime lifetime, IScheduler scheduler, Action`1<SetEvent`1<T>> action);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(SetEvent`1<T> x);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Impl.BufferWindow : ValueType {
    public Byte[] Data;
    public int Lo;
    public int Hi;
    public int Available { get; }
    public BufferWindow(int length);
    public int get_Available();
    public void Clear();
    public void MoveTo(Byte[] dst, int offset, int size);
    public bool Read(BufferWindow& helper, Receiver receiver);
    public bool Read(BufferWindow& helper, Receiver receiver, int size);
}
internal class JetBrains.Rd.Impl.ConcurrentRdSet`1 : RdReactiveBase {
    private ProtocolContexts myProtocolContexts;
    private ViewableConcurrentSet`1<T> mySet;
    private ThreadLocal`1<bool> myIsThreadLocal;
    [CompilerGeneratedAttribute]
private CtxReadDelegate`1<T> <ReadValueDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private CtxWriteDelegate`1<T> <WriteValueDelegate>k__BackingField;
    public int Count { get; }
    public CtxReadDelegate`1<T> ReadValueDelegate { get; }
    public CtxWriteDelegate`1<T> WriteValueDelegate { get; }
    public ConcurrentRdSet`1(CtxReadDelegate`1<T> readValue, CtxWriteDelegate`1<T> writeValue, ProtocolContexts protocolContexts, IEqualityComparer`1<T> comparer);
    public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
public CtxReadDelegate`1<T> get_ReadValueDelegate();
    [CompilerGeneratedAttribute]
public CtxWriteDelegate`1<T> get_WriteValueDelegate();
    protected virtual void PreInit(Lifetime lifetime, IProtocol proto);
    protected virtual void Init(Lifetime bindLifetime, IProtocol proto, SerializationCtx ctx);
    private void SendAdd(IWire wire, SendContext`2<T, ConcurrentRdSet`1<T>> context);
    public virtual void Print(PrettyPrinter printer);
    public sealed virtual bool Add(T value);
    public sealed virtual bool Contains(T value);
    public sealed virtual void View(Lifetime lifetime, Action`2<Lifetime, T> action);
    public virtual void OnWireReceived(IProtocol proto, SerializationCtx ctx, UnsafeReader reader, IRdWireableDispatchHelper dispatchHelper);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Rd.Impl.ExtCreatedUtils : object {
    [ExtensionAttribute]
public static RdSignal`1<ExtCreationInfo> CreateExtSignal(IRdDynamic this);
    internal static RName ReadRName(UnsafeReader reader);
    internal static void WriteRName(UnsafeWriter writer, RName value);
    private static void TraverseRName(RName rName, bool last, Action`2<RName, bool> handler);
}
internal class JetBrains.Rd.Impl.HeavySingleContextHandler`1 : RdReactiveBase {
    private ProtocolContexts myHandler;
    private InternRoot`1<T> myInternRoot;
    private ConcurrentRdSet`1<T> myProtocolValueSet;
    [CompilerGeneratedAttribute]
private RdContext`1<T> <Context>k__BackingField;
    internal IAppendOnlyViewableConcurrentSet`1<T> LocalValueSet { get; }
    public RdContextBase ContextBase { get; }
    public RdContext`1<T> Context { get; }
    public HeavySingleContextHandler`1(RdContext`1<T> context, ProtocolContexts handler);
    internal IAppendOnlyViewableConcurrentSet`1<T> get_LocalValueSet();
    public sealed virtual object ReadValueBoxed(SerializationCtx context, UnsafeReader reader);
    public sealed virtual RdContextBase get_ContextBase();
    [CompilerGeneratedAttribute]
public sealed virtual RdContext`1<T> get_Context();
    protected virtual void PreInit(Lifetime lifetime, IProtocol proto);
    protected virtual void Init(Lifetime lifetime, IProtocol proto, SerializationCtx ctx);
    private void HandleProtocolSetEvent(Lifetime lifetime, T value);
    public sealed virtual void WriteValue(SerializationCtx context, UnsafeWriter writer);
    private void AddValueToProtocolValueSetImpl(T value);
    public sealed virtual void RegisterValueInValueSet();
    public sealed virtual T ReadValue(SerializationCtx context, UnsafeReader reader);
    public virtual void OnWireReceived(IProtocol proto, SerializationCtx ctx, UnsafeReader reader, IRdWireableDispatchHelper dispatchHelper);
}
public class JetBrains.Rd.Impl.Identities : object {
    private IdKind Kind;
    private int myId;
    private static int BaseClientId;
    private static int BaseServerId;
    public Identities(IdKind kind);
    public sealed virtual RdId Next(RdId parent);
}
public class JetBrains.Rd.Impl.InternRoot`1 : object {
    private ConcurrentDictionary`2<InternId, TBase> myDirectMap;
    private ConcurrentDictionary`2<TBase, IdPair<TBase>> myInverseMap;
    private int myInternedIdCounter;
    private CtxReadDelegate`1<TBase> myReadDelegate;
    private CtxWriteDelegate`1<TBase> myWriteDelegate;
    [CanBeNullAttribute]
private IRdDynamic myParent;
    [CompilerGeneratedAttribute]
private RName <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private RdId <RdId>k__BackingField;
    public RName Location { get; private set; }
    public RdId RdId { get; public set; }
    public bool IsBound { get; }
    public bool Async { get; public set; }
    public InternRoot`1(CtxReadDelegate`1<TBase> readDelegate, CtxWriteDelegate`1<TBase> writeDelegate);
    public sealed virtual InternId TryGetInterned(TBase value);
    public sealed virtual InternId Intern(TBase value);
    private object TryGetValue(InternId id);
    public sealed virtual bool TryUnIntern(InternId id, T& result);
    public sealed virtual void Remove(TBase value);
    public sealed virtual T UnIntern(InternId id);
    public sealed virtual IProtocol TryGetProto();
    public sealed virtual bool TryGetSerializationContext(SerializationCtx& ctx);
    [CompilerGeneratedAttribute]
public sealed virtual RName get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(RName value);
    public sealed virtual void Print(PrettyPrinter printer);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual RdId get_RdId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RdId(RdId value);
    public bool get_IsBound();
    public sealed virtual void PreBind(Lifetime lf, IRdDynamic parent, string name);
    public sealed virtual void Bind();
    public sealed virtual void Identify(IIdentities identities, RdId id);
    public sealed virtual bool get_Async();
    public sealed virtual void set_Async(bool value);
    public sealed virtual void OnWireReceived(UnsafeReader reader, IRdWireableDispatchHelper dispatchHelper);
}
internal class JetBrains.Rd.Impl.LightSingleContextHandler`1 : object {
    [CompilerGeneratedAttribute]
private RdContext`1<T> <Context>k__BackingField;
    public RdContext`1<T> Context { get; }
    public RdContextBase ContextBase { get; }
    public LightSingleContextHandler`1(RdContext`1<T> context);
    [CompilerGeneratedAttribute]
public sealed virtual RdContext`1<T> get_Context();
    public sealed virtual RdContextBase get_ContextBase();
    public sealed virtual object ReadValueBoxed(SerializationCtx context, UnsafeReader reader);
    public sealed virtual void WriteValue(SerializationCtx context, UnsafeWriter writer);
    public sealed virtual void RegisterValueInValueSet();
    public sealed virtual T ReadValue(SerializationCtx context, UnsafeReader reader);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Impl.MessageBroker : object {
    private ILog myLogger;
    public bool BackwardsCompatibleWireFormat;
    private object myLock;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<RdId, ValueLifetimed`1<IRdWireable>> mySubscriptions;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Queue`1<Byte[]> myUnprocessedMessages;
    public MessageBroker(bool withholdMessageDeliveryInitially);
    public void StartDeliveringMessages();
    public void Dispatch(Byte[] msg);
    private void DispatchImpl(Byte[] msg);
    private static ThreadLocalDebugInfo UsingDebugInfoCookie(IRdWireable reactive);
    public void Advise(Lifetime lifetime, IRdWireable reactive);
    public bool TryGetById(RdId rdId, ValueLifetimed`1& subscription);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public static class JetBrains.Rd.Impl.Polymorphic`1 : object {
    public static CtxReadDelegate`1<T> Read;
    public static CtxWriteDelegate`1<T> Write;
    private static Polymorphic`1();
    public static CtxReadDelegate`1<T> ReadAbstract(CtxReadDelegate`1<T> unknownInstanceReader);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Impl.Protocol : object {
    public static ILog Logger;
    public static ILog InitLogger;
    public static Nullable`1<LogWithLevel> InitTrace;
    private static string ProtocolInternRootRdId;
    private static string ContextHandlerRdId;
    internal static string ProtocolExtCreatedRdId;
    private static string ProtocolInternScopeStringId;
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IWire <Wire>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerializers <Serializers>k__BackingField;
    [CompilerGeneratedAttribute]
private IIdentities <Identities>k__BackingField;
    [CompilerGeneratedAttribute]
private IScheduler <Scheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private SerializationCtx <SerializationContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ViewableSet`1<RdExtBase> <OutOfSyncModels>k__BackingField;
    [CompilerGeneratedAttribute]
private ProtocolContexts <Contexts>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignal`1<ExtCreationInfo> <ExtCreated>k__BackingField;
    [CompilerGeneratedAttribute]
private RdSignal`1<ExtCreationInfo> <ExtConfirmation>k__BackingField;
    [CompilerGeneratedAttribute]
private ThreadLocal`1<bool> <ExtIsLocal>k__BackingField;
    [PublicAPIAttribute]
public bool ThrowErrorOnOutOfSyncModels;
    [CompilerGeneratedAttribute]
private RName <Location>k__BackingField;
    public Lifetime Lifetime { get; }
    public string Name { get; }
    public IWire Wire { get; }
    public ISerializers Serializers { get; }
    public IIdentities Identities { get; }
    public IScheduler Scheduler { get; }
    public SerializationCtx SerializationContext { get; }
    public ViewableSet`1<RdExtBase> OutOfSyncModels { get; }
    public ProtocolContexts Contexts { get; }
    public ISignal`1<ExtCreationInfo> ExtCreated { get; }
    private RdSignal`1<ExtCreationInfo> ExtConfirmation { get; }
    private ThreadLocal`1<bool> ExtIsLocal { get; }
    public RName Location { get; }
    public Protocol(string name, ISerializers serializers, IIdentities identities, IScheduler scheduler, IWire wire, Lifetime lifetime, RdContextBase[] initialContexts);
    internal Protocol(string name, ISerializers serializers, IIdentities identities, IScheduler scheduler, IWire wire, Lifetime lifetime, Nullable`1<SerializationCtx> serializationCtx, ProtocolContexts parentContexts, ISignal`1<ExtCreationInfo> parentExtCreated, RdSignal`1<ExtCreationInfo> parentExtConfirmation, RdContextBase[] initialContexts);
    private static Protocol();
    [CompilerGeneratedAttribute]
public sealed virtual Lifetime get_Lifetime();
    public sealed virtual bool TryGetSerializationContext(SerializationCtx& ctx);
    private InternRoot`1<object> CreateProtocolInternRoot(Lifetime lifetime);
    private void BindContexts(Lifetime lifetime);
    internal void SubmitExtCreated(ExtCreationInfo info);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual IWire get_Wire();
    [CompilerGeneratedAttribute]
public sealed virtual ISerializers get_Serializers();
    [CompilerGeneratedAttribute]
public sealed virtual IIdentities get_Identities();
    [CompilerGeneratedAttribute]
public sealed virtual IScheduler get_Scheduler();
    [CompilerGeneratedAttribute]
public sealed virtual SerializationCtx get_SerializationContext();
    [CompilerGeneratedAttribute]
public sealed virtual ViewableSet`1<RdExtBase> get_OutOfSyncModels();
    [CompilerGeneratedAttribute]
public sealed virtual ProtocolContexts get_Contexts();
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<ExtCreationInfo> get_ExtCreated();
    [CompilerGeneratedAttribute]
private RdSignal`1<ExtCreationInfo> get_ExtConfirmation();
    [CompilerGeneratedAttribute]
private ThreadLocal`1<bool> get_ExtIsLocal();
    [CompilerGeneratedAttribute]
public sealed virtual RName get_Location();
    private sealed virtual override IProtocol JetBrains.Rd.Base.IRdDynamic.TryGetProto();
    [CompilerGeneratedAttribute]
private void <.ctor>b__11_1(ExtCreationInfo message);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Impl.ProtocolContexts : RdReactiveBase {
    private CopyOnWriteList`1<ISingleContextHandler> myCounterpartHandlers;
    private CopyOnWriteList`1<ISingleContextHandler> myHandlersToWrite;
    private IViewableList`1<ISingleContextHandler> myHandlerOrder;
    private ConcurrentDictionary`2<RdContextBase, ISingleContextHandler> myHandlersMap;
    private object myOrderingLock;
    private ThreadLocal`1<bool> mySendWithoutContexts;
    private SerializationCtx mySerializationCtx;
    public bool IsSendWithoutContexts { get; }
    public ICollection`1<RdContextBase> RegisteredContexts { get; }
    public ProtocolContexts(SerializationCtx serializationCtx);
    internal SendWithoutContextsCookie CreateSendWithoutContextsCookie();
    public bool get_IsSendWithoutContexts();
    public ICollection`1<RdContextBase> get_RegisteredContexts();
    internal ISingleContextHandler`1<T> GetHandlerForContext(RdContext`1<T> context);
    public virtual void OnWireReceived(IProtocol proto, SerializationCtx ctx, UnsafeReader reader, IRdWireableDispatchHelper dispatchHelper);
    private void DoAddHandler(RdContext`1<T> context, ISingleContextHandler`1<T> handler);
    private void PreBindHandler(Lifetime lifetime, string key, ISingleContextHandler handler);
    private void BindHandler(ISingleContextHandler handler);
    private void SendContextToRemote(RdContextBase context);
    private void EnsureHeavyHandlerExists(RdContext`1<T> context);
    private void EnsureLightHandlerExists(RdContext`1<T> context);
    public IAppendOnlyViewableConcurrentSet`1<T> GetValueSet(RdContext`1<T> context);
    public void RegisterContext(RdContext`1<T> context);
    protected virtual void PreInit(Lifetime lifetime, IProtocol proto);
    protected virtual void Init(Lifetime lifetime, IProtocol proto, SerializationCtx ctx);
    internal MessageContext ReadContextsIntoCookie(UnsafeReader reader);
    public void WriteContexts(UnsafeWriter writer);
    public void RegisterCurrentValuesInValueSets();
    public static void WriteEmptyContexts(UnsafeWriter writer);
    private void BindAndSendHandler(ISingleContextHandler handler);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <PreInit>b__24_0(Lifetime handlerLt, int _, ISingleContextHandler handler);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <Init>b__25_0(Lifetime handlerLt, int _, ISingleContextHandler handler);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Rd.Impl.RdList`1 : RdReactiveBase {
    private ViewableList`1<V> myList;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private CtxReadDelegate`1<V> <ReadValueDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private CtxWriteDelegate`1<V> <WriteValueDelegate>k__BackingField;
    private static int versionedFlagShift;
    private long myNextVersion;
    [CompilerGeneratedAttribute]
private bool <OptimizeNested>k__BackingField;
    [ItemCanBeNullAttribute]
private SynchronizedList`1 modreq(System.Runtime.CompilerServices.IsVolatile) myBindDefinitions;
    [PublicAPIAttribute]
public CtxReadDelegate`1<V> ReadValueDelegate { get; private set; }
    [PublicAPIAttribute]
public CtxWriteDelegate`1<V> WriteValueDelegate { get; private set; }
    public bool OptimizeNested { get; public set; }
    protected string ShortName { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ISource`1<ListEvent`1<V>> Change { get; }
    public V Item { get; public set; }
    public RdList`1(CtxReadDelegate`1<V> readValue, CtxWriteDelegate`1<V> writeValue, long nextVersion);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public CtxReadDelegate`1<V> get_ReadValueDelegate();
    [CompilerGeneratedAttribute]
private void set_ReadValueDelegate(CtxReadDelegate`1<V> value);
    [CompilerGeneratedAttribute]
public CtxWriteDelegate`1<V> get_WriteValueDelegate();
    [CompilerGeneratedAttribute]
private void set_WriteValueDelegate(CtxWriteDelegate`1<V> value);
    [PublicAPIAttribute]
public static RdList`1<V> Read(SerializationCtx ctx, UnsafeReader reader);
    [PublicAPIAttribute]
public static RdList`1<V> Read(SerializationCtx ctx, UnsafeReader reader, CtxReadDelegate`1<V> readValue, CtxWriteDelegate`1<V> writeValue);
    [PublicAPIAttribute]
public static void Write(SerializationCtx ctx, UnsafeWriter writer, RdList`1<V> value);
    [CompilerGeneratedAttribute]
[PublicAPIAttribute]
public bool get_OptimizeNested();
    [CompilerGeneratedAttribute]
public void set_OptimizeNested(bool value);
    protected virtual void Unbind();
    protected virtual void PreInit(Lifetime lifetime, IProtocol proto);
    protected virtual void Init(Lifetime lifetime, IProtocol proto, SerializationCtx ctx);
    protected virtual string get_ShortName();
    public virtual void OnWireReceived(IProtocol proto, SerializationCtx ctx, UnsafeReader stream, IRdWireableDispatchHelper dispatchHelper);
    [CanBeNullAttribute]
[ItemCanBeNullAttribute]
private SynchronizedList`1<LifetimeDefinition> TryGetBindDefinitions(Lifetime lifetime);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
private LifetimeDefinition TryPreBindValue(Lifetime lifetime, V value, int index, bool bindAlso);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<V> GetEnumerator();
    public sealed virtual bool Contains(V item);
    public sealed virtual void CopyTo(V[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(V item);
    public sealed virtual ISource`1<ListEvent`1<V>> get_Change();
    public sealed virtual void Insert(int index, V value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual V get_Item(int index);
    public sealed virtual void set_Item(int index, V value);
    public sealed virtual bool Remove(V item);
    public sealed virtual void Add(V item);
    public sealed virtual void Clear();
    public sealed virtual void Advise(Lifetime lifetime, Action`1<ListEvent`1<V>> handler);
    public virtual RdBindableBase FindByRName(RName rName);
    public virtual void Print(PrettyPrinter printer);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(AddRemove kind, int idx, V v);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class JetBrains.Rd.Impl.RdMap`2 : RdReactiveBase {
    private ViewableMap`2<K, V> myMap;
    [CompilerGeneratedAttribute]
private CtxReadDelegate`1<K> <ReadKeyDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private CtxWriteDelegate`1<K> <WriteKeyDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private CtxReadDelegate`1<V> <ReadValueDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private CtxWriteDelegate`1<V> <WriteValueDelegate>k__BackingField;
    private static int versionedFlagShift;
    private static int Ack;
    public bool IsMaster;
    private long myNextVersion;
    private Dictionary`2<K, long> myPendingForAck;
    [CompilerGeneratedAttribute]
private bool <OptimizeNested>k__BackingField;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private SynchronizedDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) myBindDefinitions;
    [PublicAPIAttribute]
public CtxReadDelegate`1<K> ReadKeyDelegate { get; private set; }
    [PublicAPIAttribute]
public CtxWriteDelegate`1<K> WriteKeyDelegate { get; private set; }
    [PublicAPIAttribute]
public CtxReadDelegate`1<V> ReadValueDelegate { get; private set; }
    [PublicAPIAttribute]
public CtxWriteDelegate`1<V> WriteValueDelegate { get; private set; }
    public bool OptimizeNested { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ISource`1<MapEvent`2<K, V>> Change { get; }
    public V Item { get; public set; }
    protected string ShortName { get; }
    public RdMap`2(CtxReadDelegate`1<K> readKey, CtxWriteDelegate`1<K> writeKey, CtxReadDelegate`1<V> readValue, CtxWriteDelegate`1<V> writeValue);
    [CompilerGeneratedAttribute]
public CtxReadDelegate`1<K> get_ReadKeyDelegate();
    [CompilerGeneratedAttribute]
private void set_ReadKeyDelegate(CtxReadDelegate`1<K> value);
    [CompilerGeneratedAttribute]
public CtxWriteDelegate`1<K> get_WriteKeyDelegate();
    [CompilerGeneratedAttribute]
private void set_WriteKeyDelegate(CtxWriteDelegate`1<K> value);
    [CompilerGeneratedAttribute]
public CtxReadDelegate`1<V> get_ReadValueDelegate();
    [CompilerGeneratedAttribute]
private void set_ReadValueDelegate(CtxReadDelegate`1<V> value);
    [CompilerGeneratedAttribute]
public CtxWriteDelegate`1<V> get_WriteValueDelegate();
    [CompilerGeneratedAttribute]
private void set_WriteValueDelegate(CtxWriteDelegate`1<V> value);
    [PublicAPIAttribute]
public static RdMap`2<K, V> Read(SerializationCtx ctx, UnsafeReader reader);
    [PublicAPIAttribute]
public static RdMap`2<K, V> Read(SerializationCtx ctx, UnsafeReader reader, CtxReadDelegate`1<K> readKey, CtxWriteDelegate`1<K> writeKey, CtxReadDelegate`1<V> readValue, CtxWriteDelegate`1<V> writeValue);
    [PublicAPIAttribute]
public static void Write(SerializationCtx ctx, UnsafeWriter writer, RdMap`2<K, V> value);
    [CompilerGeneratedAttribute]
[PublicAPIAttribute]
public bool get_OptimizeNested();
    [CompilerGeneratedAttribute]
public void set_OptimizeNested(bool value);
    protected virtual void PreInit(Lifetime lifetime, IProtocol proto);
    protected virtual void Init(Lifetime lifetime, IProtocol proto, SerializationCtx ctx);
    protected virtual void Unbind();
    public virtual void OnWireReceived(IProtocol proto, SerializationCtx ctx, UnsafeReader stream, IRdWireableDispatchHelper dispatchHelper);
    private SynchronizedDictionary`2<K, LifetimeDefinition> TryGetBindDefinitions(Lifetime lifetime);
    private bool IsPendingForAck(K key);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
private LifetimeDefinition TryPreBindValue(Lifetime lifetime, K key, V value, bool bindAlso);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual ISource`1<MapEvent`2<K, V>> get_Change();
    public sealed virtual void Add(K key, V value);
    public sealed virtual bool Remove(K key);
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual void Advise(Lifetime lifetime, Action`1<MapEvent`2<K, V>> handler);
    public virtual RdBindableBase FindByRName(RName rName);
    protected virtual string get_ShortName();
    public virtual void Print(PrettyPrinter printer);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class JetBrains.Rd.Impl.RdPerContextMap`2 : RdReactiveBase {
    [CompilerGeneratedAttribute]
private RdContext`1<K> <Context>k__BackingField;
    private Func`2<bool, V> myValueFactory;
    private IViewableMap`2<K, V> myMap;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ReactiveQueue`1<K, V, KeyValuePair`2<K, V>> myQueue;
    public bool IsMaster;
    public RdContext`1<K> Context { get; }
    public V Item { get; }
    public RdPerContextMap`2(RdContext`1<K> context, Func`2<bool, V> valueFactory);
    [CompilerGeneratedAttribute]
public sealed virtual RdContext`1<K> get_Context();
    public virtual void OnWireReceived(IProtocol proto, SerializationCtx ctx, UnsafeReader stream, IRdWireableDispatchHelper dispatchHelper);
    protected virtual void PreInit(Lifetime lifetime, IProtocol proto);
    protected virtual void Init(Lifetime lifetime, IProtocol proto, SerializationCtx ctx);
    public sealed virtual V GetForCurrentContext();
    public sealed virtual void View(Lifetime lifetime, Action`2<Lifetime, KeyValuePair`2<K, V>> handler);
    public sealed virtual void View(Lifetime lifetime, Action`3<Lifetime, K, V> handler);
    public sealed virtual V get_Item(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public static void Write(SerializationCtx context, UnsafeWriter writer, RdPerContextMap`2<K, V> value);
    public static RdPerContextMap`2<K, V> Read(SerializationCtx context, UnsafeReader reader, RdContext`1<K> key, Func`2<bool, V> func);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Impl.RdProperty`1 : RdPropertyBase {
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private CtxReadDelegate`1<T> <ReadValueDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private CtxWriteDelegate`1<T> <WriteValueDelegate>k__BackingField;
    public bool IsMaster;
    private int myMasterVersion;
    public bool OptimizeNested;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("2")]
private LifetimeDefinition myBindDefinition;
    private IViewableProperty`1<T> myProperty;
    public CtxReadDelegate`1<T> ReadValueDelegate { get; private set; }
    public CtxWriteDelegate`1<T> WriteValueDelegate { get; private set; }
    public ISource`1<T> Change { get; }
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Maybe`1<T> Maybe { get; }
    public T Value { get; public set; }
    protected string ShortName { get; }
    public RdProperty`1(CtxReadDelegate`1<T> readValue, CtxWriteDelegate`1<T> writeValue);
    [PublicAPIAttribute]
public RdProperty`1(CtxReadDelegate`1<T> readValue, CtxWriteDelegate`1<T> writeValue, T defaultValue);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public CtxReadDelegate`1<T> get_ReadValueDelegate();
    [CompilerGeneratedAttribute]
private void set_ReadValueDelegate(CtxReadDelegate`1<T> value);
    [CompilerGeneratedAttribute]
public CtxWriteDelegate`1<T> get_WriteValueDelegate();
    [CompilerGeneratedAttribute]
private void set_WriteValueDelegate(CtxWriteDelegate`1<T> value);
    public static RdProperty`1<T> Read(SerializationCtx ctx, UnsafeReader reader);
    public static RdProperty`1<T> Read(SerializationCtx ctx, UnsafeReader reader, CtxReadDelegate`1<T> readValue, CtxWriteDelegate`1<T> writeValue);
    public static void Write(SerializationCtx ctx, UnsafeWriter writer, RdProperty`1<T> value);
    public virtual void Identify(IIdentities identities, RdId id);
    protected virtual void PreInit(Lifetime lifetime, IProtocol proto);
    protected virtual void Init(Lifetime lifetime, IProtocol proto, SerializationCtx ctx);
    protected virtual void Unbind();
    public virtual void OnWireReceived(IProtocol proto, SerializationCtx ctx, UnsafeReader reader, IRdWireableDispatchHelper dispatchHelper);
    private LifetimeDefinition TryPreBindValue(Lifetime lifetime, T value, bool bindAlso);
    public sealed virtual ISource`1<T> get_Change();
    public sealed virtual Maybe`1<T> get_Maybe();
    public sealed virtual T get_Value();
    public sealed virtual void set_Value(T value);
    public sealed virtual void Advise(Lifetime lifetime, Action`1<T> handler);
    public virtual RdBindableBase FindByRName(RName rName);
    protected virtual string get_ShortName();
    public virtual void Print(PrettyPrinter printer);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0(T _);
}
public abstract class JetBrains.Rd.Impl.RdPropertyBase : RdReactiveBase {
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Impl.RdSecureString : ValueType {
    public string Contents;
    public RdSecureString(string contents);
    public virtual string ToString();
    public sealed virtual bool Equals(RdSecureString other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(RdSecureString left, RdSecureString right);
    public static bool op_Inequality(RdSecureString left, RdSecureString right);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Impl.RdSet`1 : RdReactiveBase {
    private IViewableSet`1<T> mySet;
    [CompilerGeneratedAttribute]
private CtxReadDelegate`1<T> <ReadValueDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private CtxWriteDelegate`1<T> <WriteValueDelegate>k__BackingField;
    public bool IsMaster;
    [CompilerGeneratedAttribute]
private bool <OptimizeNested>k__BackingField;
    public CtxReadDelegate`1<T> ReadValueDelegate { get; private set; }
    public CtxWriteDelegate`1<T> WriteValueDelegate { get; private set; }
    public bool OptimizeNested { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ISource`1<SetEvent`1<T>> Change { get; }
    protected string ShortName { get; }
    public RdSet`1(CtxReadDelegate`1<T> readValue, CtxWriteDelegate`1<T> writeValue);
    [CompilerGeneratedAttribute]
public CtxReadDelegate`1<T> get_ReadValueDelegate();
    [CompilerGeneratedAttribute]
private void set_ReadValueDelegate(CtxReadDelegate`1<T> value);
    [CompilerGeneratedAttribute]
public CtxWriteDelegate`1<T> get_WriteValueDelegate();
    [CompilerGeneratedAttribute]
private void set_WriteValueDelegate(CtxWriteDelegate`1<T> value);
    public static RdSet`1<T> Read(SerializationCtx ctx, UnsafeReader reader);
    public static RdSet`1<T> Read(SerializationCtx ctx, UnsafeReader reader, CtxReadDelegate`1<T> readValue, CtxWriteDelegate`1<T> writeValue);
    public static void Write(SerializationCtx ctx, UnsafeWriter writer, RdSet`1<T> value);
    [CompilerGeneratedAttribute]
[PublicAPIAttribute]
public bool get_OptimizeNested();
    [CompilerGeneratedAttribute]
public void set_OptimizeNested(bool value);
    protected virtual void PreInit(Lifetime lifetime, IProtocol proto);
    protected virtual void Init(Lifetime lifetime, IProtocol proto, SerializationCtx ctx);
    public virtual void OnWireReceived(IProtocol proto, SerializationCtx ctx, UnsafeReader stream, IRdWireableDispatchHelper dispatchHelper);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ISource`1<SetEvent`1<T>> get_Change();
    public sealed virtual bool Remove(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual bool Add(T item);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void Clear();
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual void Advise(Lifetime lifetime, Action`1<SetEvent`1<T>> handler);
    protected virtual string get_ShortName();
    public virtual void Print(PrettyPrinter printer);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Impl.RdSignal`1 : RdReactiveBase {
    [CompilerGeneratedAttribute]
private CtxReadDelegate`1<T> <ReadValueDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private CtxWriteDelegate`1<T> <WriteValueDelegate>k__BackingField;
    private Signal`1<T> mySignal;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IScheduler <Scheduler>k__BackingField;
    public CtxReadDelegate`1<T> ReadValueDelegate { get; }
    public CtxWriteDelegate`1<T> WriteValueDelegate { get; }
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("2")]
public IScheduler Scheduler { get; public set; }
    protected string ShortName { get; }
    public RdSignal`1(CtxReadDelegate`1<T> readValue, CtxWriteDelegate`1<T> writeValue);
    [CompilerGeneratedAttribute]
public CtxReadDelegate`1<T> get_ReadValueDelegate();
    [CompilerGeneratedAttribute]
public CtxWriteDelegate`1<T> get_WriteValueDelegate();
    public static RdSignal`1<T> Read(SerializationCtx ctx, UnsafeReader reader);
    public static RdSignal`1<T> Read(SerializationCtx _, UnsafeReader reader, CtxReadDelegate`1<T> readValue, CtxWriteDelegate`1<T> writeValue);
    public static void Write(SerializationCtx ctx, UnsafeWriter writer, RdSignal`1<T> value);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual IScheduler get_Scheduler();
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_Scheduler(IScheduler value);
    protected virtual void PreInit(Lifetime lifetime, IProtocol proto);
    public virtual void OnWireReceived(IProtocol proto, SerializationCtx ctx, UnsafeReader reader, IRdWireableDispatchHelper dispatchHelper);
    public sealed virtual void Fire(T value);
    public sealed virtual void Advise(Lifetime lifetime, Action`1<T> handler);
    protected virtual string get_ShortName();
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Impl.RdSimpleDispatcher : object {
    private Lifetime myLifetime;
    private ILog myLogger;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("2")]
private string myId;
    private Queue`1<Action> myTasks;
    private AutoResetEvent myEvent;
    public Nullable`1<TimeSpan> MessageTimeout;
    public bool IsActive { get; }
    public bool OutOfOrderExecution { get; }
    public RdSimpleDispatcher(Lifetime lifetime, ILog logger, string id);
    public virtual void Run();
    public virtual bool get_IsActive();
    public virtual bool get_OutOfOrderExecution();
    public sealed virtual void Queue(Action action);
    private string FormatLogMessage(string message);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0();
}
internal static class JetBrains.Rd.Impl.SendContext : object {
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
internal static SendContext`2<TEvt, TReactive> Of(SerializationCtx serializationContext, TEvt event, TReactive me);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
internal class JetBrains.Rd.Impl.SendContext`2 : ValueType {
    internal SerializationCtx SzrCtx;
    internal TEvt Event;
    internal TReactive This;
    public SendContext`2(SerializationCtx serializationContext, TEvt event, TReactive me);
    public void Deconstruct(SerializationCtx& serializationContext, TEvt& event, TReactive& map);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Impl.Serializers : object {
    private Dictionary`2<Type, RdId> myTypeMapping;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<RdId, CtxReadDelegate`1<object>> myReaders;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<RdId, CtxWriteDelegate`1<object>> myWriters;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("2")]
private ITypesRegistrar myRegistrar;
    private object myLock;
    private StealingScheduler myBackgroundRegistrar;
    public static CtxReadDelegate`1<byte> ReadByte;
    public static CtxReadDelegate`1<short> ReadShort;
    public static CtxReadDelegate`1<int> ReadInt;
    public static CtxReadDelegate`1<long> ReadLong;
    public static CtxReadDelegate`1<float> ReadFloat;
    public static CtxReadDelegate`1<double> ReadDouble;
    public static CtxReadDelegate`1<char> ReadChar;
    public static CtxReadDelegate`1<bool> ReadBool;
    public static CtxReadDelegate`1<Unit> ReadVoid;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxReadDelegate`1<string> ReadString;
    public static CtxReadDelegate`1<Guid> ReadGuid;
    public static CtxReadDelegate`1<DateTime> ReadDateTime;
    public static CtxReadDelegate`1<TimeSpan> ReadTimeSpan;
    public static CtxReadDelegate`1<Uri> ReadUri;
    public static CtxReadDelegate`1<RdId> ReadRdId;
    public static CtxReadDelegate`1<RdSecureString> ReadSecureString;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxReadDelegate`1<Byte[]> ReadByteArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxReadDelegate`1<Int16[]> ReadShortArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxReadDelegate`1<Int32[]> ReadIntArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxReadDelegate`1<Int64[]> ReadLongArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxReadDelegate`1<Single[]> ReadFloatArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxReadDelegate`1<Double[]> ReadDoubleArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxReadDelegate`1<Char[]> ReadCharArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxReadDelegate`1<Boolean[]> ReadBoolArray;
    public static CtxReadDelegate`1<byte> ReadUByte;
    public static CtxReadDelegate`1<ushort> ReadUShort;
    public static CtxReadDelegate`1<UInt32> ReadUInt;
    public static CtxReadDelegate`1<ulong> ReadULong;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxReadDelegate`1<Byte[]> ReadUByteArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxReadDelegate`1<UInt16[]> ReadUShortArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxReadDelegate`1<UInt32[]> ReadUIntArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxReadDelegate`1<UInt64[]> ReadULongArray;
    public static CtxWriteDelegate`1<byte> WriteByte;
    public static CtxWriteDelegate`1<short> WriteShort;
    public static CtxWriteDelegate`1<int> WriteInt;
    public static CtxWriteDelegate`1<long> WriteLong;
    public static CtxWriteDelegate`1<float> WriteFloat;
    public static CtxWriteDelegate`1<double> WriteDouble;
    public static CtxWriteDelegate`1<char> WriteChar;
    public static CtxWriteDelegate`1<bool> WriteBool;
    public static CtxWriteDelegate`1<Unit> WriteVoid;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxWriteDelegate`1<string> WriteString;
    public static CtxWriteDelegate`1<Guid> WriteGuid;
    public static CtxWriteDelegate`1<DateTime> WriteDateTime;
    public static CtxWriteDelegate`1<TimeSpan> WriteTimeSpan;
    public static CtxWriteDelegate`1<Uri> WriteUri;
    public static CtxWriteDelegate`1<RdId> WriteRdId;
    public static CtxWriteDelegate`1<RdSecureString> WriteSecureString;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxWriteDelegate`1<Byte[]> WriteByteArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxWriteDelegate`1<Int16[]> WriteShortArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxWriteDelegate`1<Int32[]> WriteIntArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxWriteDelegate`1<Int64[]> WriteLongArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxWriteDelegate`1<Single[]> WriteFloatArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxWriteDelegate`1<Double[]> WriteDoubleArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxWriteDelegate`1<Char[]> WriteCharArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxWriteDelegate`1<Boolean[]> WriteBoolArray;
    public static CtxWriteDelegate`1<byte> WriteUByte;
    public static CtxWriteDelegate`1<ushort> WriteUShort;
    public static CtxWriteDelegate`1<UInt32> WriteUInt;
    public static CtxWriteDelegate`1<ulong> WriteULong;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxWriteDelegate`1<Byte[]> WriteUByteArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxWriteDelegate`1<UInt16[]> WriteUShortArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxWriteDelegate`1<UInt32[]> WriteUIntArray;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxWriteDelegate`1<UInt64[]> WriteULongArray;
    private HashSet`1<Type> myRegisteredToplevels;
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public Serializers(TaskScheduler scheduler, ITypesRegistrar registrar);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public Serializers(ITypesRegistrar registrar);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
[ObsoleteAttribute("Lifetime is not required anymore", "False")]
public Serializers(Lifetime lifetime, TaskScheduler scheduler, ITypesRegistrar registrar);
    private static Serializers();
    public static void RegisterFrameworkMarshallers(ISerializersContainer serializers);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("0")]
public static T ReadEnum(SerializationCtx ctx, UnsafeReader reader);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("0")]
public static void WriteEnum(SerializationCtx ctx, UnsafeWriter writer, T value);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("0")]
public sealed virtual void RegisterEnum();
    public sealed virtual void Register(CtxReadDelegate`1<T> reader, CtxWriteDelegate`1<T> writer, Nullable`1<long> predefinedId);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public sealed virtual T Read(SerializationCtx ctx, UnsafeReader reader, CtxReadDelegate`1<T> unknownInstanceReader);
    public sealed virtual void Write(SerializationCtx ctx, UnsafeWriter writer, T value);
    public sealed virtual void RegisterToplevelOnce(Type toplevelType, Action`1<ISerializers> registerDeclaredTypesSerializers);
    private void RegisterToplevelInternal(Type type, Action`1<ISerializers> register);
    [CompilerGeneratedAttribute]
private bool <Write>g__TryGetTypeMapping|80_0(Type type1, RdId& rdId);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Rd.Impl.SerializersEx : object {
    [ExtensionAttribute]
public static List`1<T> ReadList(UnsafeReader reader, CtxReadDelegate`1<T> itemReader, SerializationCtx ctx);
    [ExtensionAttribute]
public static void WriteList(UnsafeWriter writer, CtxWriteDelegate`1<T> itemWriter, SerializationCtx ctx, List`1<T> value);
    [ExtensionAttribute]
public static void WriteEnumerable(UnsafeWriter writer, CtxWriteDelegate`1<T> itemWriter, SerializationCtx ctx, IEnumerable`1<T> value);
    [ExtensionAttribute]
public static T[] ReadArray(UnsafeReader reader, CtxReadDelegate`1<T> itemReader, SerializationCtx ctx);
    [ExtensionAttribute]
public static void WriteArray(UnsafeWriter writer, CtxWriteDelegate`1<T> itemWriter, SerializationCtx ctx, T[] value);
    [ExtensionAttribute]
public static T ReadNullableClass(UnsafeReader reader, CtxReadDelegate`1<T> itemReader, SerializationCtx ctx);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("0")]
[ExtensionAttribute]
public static Nullable`1<T> ReadNullableStruct(UnsafeReader reader, CtxReadDelegate`1<T> itemReader, SerializationCtx ctx);
    [ExtensionAttribute]
public static void WriteNullableClass(UnsafeWriter writer, CtxWriteDelegate`1<T> itemWriter, SerializationCtx ctx, T value);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("0")]
[ExtensionAttribute]
public static void WriteNullableStruct(UnsafeWriter writer, CtxWriteDelegate`1<T> itemWriter, SerializationCtx ctx, Nullable`1<T> value);
    [ExtensionAttribute]
public static RdSecureString ReadSecureString(UnsafeReader reader);
    [ExtensionAttribute]
public static void Write(UnsafeWriter writer, RdSecureString string);
    [ExtensionAttribute]
public static RdId ReadRdId(UnsafeReader reader);
    [ExtensionAttribute]
public static void Write(UnsafeWriter writer, RdId id);
    [ExtensionAttribute]
public static Unit ReadVoid(UnsafeReader reader);
    [ExtensionAttribute]
public static void Write(UnsafeWriter writer, Unit value);
    [ExtensionAttribute]
public static CtxReadDelegate`1<T[]> Array(CtxReadDelegate`1<T> inner);
    [ExtensionAttribute]
public static CtxReadDelegate`1<List`1<T>> List(CtxReadDelegate`1<T> inner);
    [ExtensionAttribute]
public static CtxReadDelegate`1<T> NullableClass(CtxReadDelegate`1<T> inner);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("0")]
[ExtensionAttribute]
public static CtxReadDelegate`1<Nullable`1<T>> NullableStruct(CtxReadDelegate`1<T> inner);
    [ExtensionAttribute]
public static CtxReadDelegate`1<T> Interned(CtxReadDelegate`1<T> inner, string internKey);
    [ExtensionAttribute]
public static CtxWriteDelegate`1<T[]> Array(CtxWriteDelegate`1<T> inner);
    [ExtensionAttribute]
public static CtxWriteDelegate`1<List`1<T>> List(CtxWriteDelegate`1<T> inner);
    [ExtensionAttribute]
public static CtxWriteDelegate`1<T> NullableClass(CtxWriteDelegate`1<T> inner);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("0")]
[ExtensionAttribute]
public static CtxWriteDelegate`1<Nullable`1<T>> NullableStruct(CtxWriteDelegate`1<T> inner);
    [ExtensionAttribute]
public static CtxWriteDelegate`1<T> Interned(CtxWriteDelegate`1<T> inner, string internKey);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public static class JetBrains.Rd.Impl.SocketWire : object {
    private static ILog ourStaticLog;
    private static SocketWire();
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Impl.StealingScheduler : TaskScheduler {
    private bool myAllowParallelJoin;
    private TaskScheduler myScheduler;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myActive;
    private ConcurrentQueue`1<Task> myActions;
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public StealingScheduler(TaskScheduler scheduler, bool allowParallelJoin);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    public void Join();
    private void ProcessTasks();
    private bool ExecuteOne();
    [CompilerGeneratedAttribute]
private bool <Join>b__8_0();
}
[<eef56720-e327-4776-9dd8-204dd3e85bc0>IsReadOnlyAttribute]
public class JetBrains.Rd.InternId : ValueType {
    private static int InvalidId;
    private int myValue;
    public static InternId Invalid;
    public bool IsValid { get; }
    public bool IsLocal { get; }
    internal InternId(int value);
    private static InternId();
    public bool get_IsValid();
    public bool get_IsLocal();
    public static InternId Read(UnsafeReader reader);
    public static void Write(UnsafeWriter writer, InternId value);
    public sealed virtual bool Equals(InternId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(InternId left, InternId right);
    public static bool op_Inequality(InternId left, InternId right);
    public virtual string ToString();
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public interface JetBrains.Rd.IProtocol {
    public Lifetime Lifetime { get; }
    public SerializationCtx SerializationContext { get; }
    public ViewableSet`1<RdExtBase> OutOfSyncModels { get; }
    public string Name { get; }
    public ISerializers Serializers { get; }
    public IIdentities Identities { get; }
    public IScheduler Scheduler { get; }
    public IWire Wire { get; }
    public ProtocolContexts Contexts { get; }
    public ISignal`1<ExtCreationInfo> ExtCreated { get; }
    public abstract virtual Lifetime get_Lifetime();
    public abstract virtual SerializationCtx get_SerializationContext();
    public abstract virtual ViewableSet`1<RdExtBase> get_OutOfSyncModels();
    public abstract virtual string get_Name();
    public abstract virtual ISerializers get_Serializers();
    public abstract virtual IIdentities get_Identities();
    public abstract virtual IScheduler get_Scheduler();
    public abstract virtual IWire get_Wire();
    public abstract virtual ProtocolContexts get_Contexts();
    public abstract virtual ISignal`1<ExtCreationInfo> get_ExtCreated();
}
public interface JetBrains.Rd.ISerializers {
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public abstract virtual T Read(SerializationCtx ctx, UnsafeReader reader, CtxReadDelegate`1<T> unknownInstanceReader);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public abstract virtual void Write(SerializationCtx ctx, UnsafeWriter writer, T value);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public interface JetBrains.Rd.ISerializersContainer {
    public abstract virtual void Register(CtxReadDelegate`1<T> reader, CtxWriteDelegate`1<T> writer, Nullable`1<long> predefinedType);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("0")]
public abstract virtual void RegisterEnum();
    public abstract virtual void RegisterToplevelOnce(Type toplevelType, Action`1<ISerializers> registerDeclaredTypesSerializers);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public interface JetBrains.Rd.ITypesRegistrar {
    public abstract virtual void TryRegister(RdId id, ISerializers serializers);
    public abstract virtual void TryRegister(Type clrType, ISerializers serializers);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public interface JetBrains.Rd.IWire {
    public bool IsStub { get; }
    public ProtocolContexts Contexts { get; public set; }
    public abstract virtual bool get_IsStub();
    public abstract virtual void Send(RdId id, TParam param, Action`2<TParam, UnsafeWriter> writer);
    public abstract virtual void Advise(Lifetime lifetime, IRdWireable entity);
    public abstract virtual ProtocolContexts get_Contexts();
    public abstract virtual void set_Contexts(ProtocolContexts value);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public abstract virtual IRdWireable TryGetById(RdId rdId);
}
public interface JetBrains.Rd.IWireWithDelayedDelivery {
    public abstract virtual void StartDeliveringMessages();
}
public abstract class JetBrains.Rd.RdContext`1 : RdContextBase {
    [NotNullAttribute]
public CtxReadDelegate`1<T> ReadDelegate;
    [NotNullAttribute]
public CtxWriteDelegate`1<T> WriteDelegate;
    public T Value { get; }
    public T ValueForPerContextEntity { get; }
    internal object ValueBoxed { get; }
    protected RdContext`1(string key, bool isHeavy, CtxReadDelegate`1<T> readDelegate, CtxWriteDelegate`1<T> writeDelegate);
    public abstract virtual T get_Value();
    public virtual T get_ValueForPerContextEntity();
    internal sealed virtual object get_ValueBoxed();
    public abstract virtual IDisposable UpdateValue(T newValue);
    public virtual IDisposable UpdateValueBoxed(object newValue);
    protected internal sealed virtual void RegisterOn(ProtocolContexts contexts);
}
public abstract class JetBrains.Rd.RdContextBase : object {
    [NotNullAttribute]
public string Key;
    public bool IsHeavy;
    internal object ValueBoxed { get; }
    protected RdContextBase(string key, bool isHeavy);
    public static RdContextBase Read(SerializationCtx ctx, UnsafeReader reader);
    public static void Write(SerializationCtx ctx, UnsafeWriter writer, RdContextBase value);
    public sealed virtual bool Equals(RdContextBase other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(RdContextBase left, RdContextBase right);
    public static bool op_Inequality(RdContextBase left, RdContextBase right);
    protected internal abstract virtual void RegisterOn(ProtocolContexts contexts);
    protected internal abstract virtual void RegisterOn(ISerializers serializers);
    internal abstract virtual object get_ValueBoxed();
    public abstract virtual IDisposable UpdateValueBoxed(object newValue);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.RdId : ValueType {
    public static RdId Nil;
    public static RdId Root;
    public static RdId TestValue;
    public static int MaxStaticId;
    private long myValue;
    public bool IsNil { get; }
    public long Value { get; }
    public RdId(long value);
    private static RdId();
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public static RdId Define(Nullable`1<long> id);
    public static RdId Define(Type type, Nullable`1<long> id);
    public static RdId DefineByFqn(Type type);
    [PureAttribute]
public RdId Mix(string tail);
    [PureAttribute]
public RdId Mix(int tail);
    [PureAttribute]
public RdId Mix(long tail);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public static long Hash(string s, long initValue);
    public bool get_IsNil();
    public long get_Value();
    public sealed virtual bool Equals(RdId other);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [PureAttribute]
public void Write(UnsafeWriter writer);
    public static RdId Read(UnsafeReader reader);
    public static void Write(UnsafeWriter writer, RdId value);
    public static bool op_Equality(RdId left, RdId right);
    public static bool op_Inequality(RdId left, RdId right);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
internal static class JetBrains.Rd.Reflection.BindableChildrenUtil : object {
    private static Dictionary`2<Type, Action`2<IReflectionBindable, PrettyPrinter>> ourPrettyPrinters;
    private static Dictionary`2<Type, Action`1<IReflectionBindable>> ourFillBindableChildren;
    private static object ourPrettyPrintersLock;
    private static BindableChildrenUtil();
    internal static void PrettyPrint(PrettyPrinter p, IReflectionBindable instance);
    internal static void FillBindableFields(IReflectionBindable instance);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
public static class JetBrains.Rd.Reflection.BuiltInSerializers : object {
    public static bool Has(TypeInfo t);
    public static BuiltInType GetBuiltInType(TypeInfo t);
    public static SerializerPair TryGet(TypeInfo typeInfo, Func`2<Type, SerializerPair> getInstanceSerializer, Nullable`1<BuiltInType> type);
    public static bool HasBuiltInAttribute(TypeInfo t);
    public static bool HasBuiltInFields(TypeInfo t);
    private static SerializerPair GetPairFromFields(TypeInfo typeInfo);
    public static MethodInfo GetReadStaticProtocolMethod(TypeInfo typeInfo);
    public static MethodInfo GetReadStaticMethod(TypeInfo typeInfo);
    public static MethodInfo GetReadStaticSerializer(TypeInfo typeInfo, Type argumentType);
    public static MethodInfo GetReadStaticSerializer(TypeInfo typeInfo, Type key, Type value);
    public static MethodInfo GetWriteProtocolMethod(TypeInfo typeInfo);
    public static MethodInfo GetWriteProtocolStaticMethod(TypeInfo typeInfo);
    private static MethodInfo GetWriteMethod(TypeInfo typeInfo);
    public static MethodInfo GetWriteStaticMethod(TypeInfo typeInfo);
    [CompilerGeneratedAttribute]
internal static BuiltInType <GetBuiltInType>g__CheckWriteMethod|2_0(Type ownerType, MethodInfo methodInfo);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
internal class JetBrains.Rd.Reflection.CollectionSerializers : object {
    public static SerializerPair CreateListSerializerPair(SerializerPair itemSerializer);
    public static SerializerPair CreateDictionarySerializerPair(SerializerPair keySerializer, SerializerPair valueSerializer);
    public static SerializerPair CreateReadOnlyDictionarySerializerPair(SerializerPair keySerializer, SerializerPair valueSerializer);
    private static CtxReadDelegate`1<Dictionary`2<TKey, TValue>> CreateReadDictionary(SerializerPair keySerializer, SerializerPair valueSerializer);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
public interface JetBrains.Rd.Reflection.IBuiltInMarshaller`1 {
    public abstract virtual T Read(SerializationCtx ctx, UnsafeReader reader);
    public abstract virtual void Write(SerializationCtx ctx, UnsafeWriter writer, T value);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
public interface JetBrains.Rd.Reflection.IProxyGenerator {
    public abstract virtual Type CreateType(Type interfaceType);
    public abstract virtual DynamicMethod CreateAdapter(Type selfType, MethodInfo method);
}
public interface JetBrains.Rd.Reflection.IProxyTypeMarker {
}
internal interface JetBrains.Rd.Reflection.IReflectionBindable {
    [<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<KeyValuePair`2<string, object>> BindableChildren { get; }
    public abstract virtual List`1<KeyValuePair`2<string, object>> get_BindableChildren();
    public abstract virtual void OnActivated();
    public abstract virtual void EnsureBindableChildren();
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
public interface JetBrains.Rd.Reflection.IScalarSerializers {
    public abstract virtual SerializerPair CreateSerializer(Type type, ISerializersSource serializers);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
public interface JetBrains.Rd.Reflection.ISerializersSource {
    public abstract virtual SerializerPair GetOrRegisterSerializerPair(Type type, bool instance);
    public abstract virtual SerializerPair GetPolymorphic();
    public abstract virtual SerializerPair GetPolymorphic(Type type);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
public interface JetBrains.Rd.Reflection.ITypesCatalog {
    [<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("2")]
public abstract virtual Type GetById(RdId id);
    public abstract virtual RdId GetByType(Type type);
    public abstract virtual void AddType(Type type);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
public class JetBrains.Rd.Reflection.ProxyGenerator : object {
    private static ILog ourLog;
    private static string DynamicAssemblyName;
    private bool myAllowSave;
    public static Type[] ValueTuples;
    public static int MaxTuplePayload;
    private Lazy`1<AssemblyBuilder> myAssemblyBuilder;
    private Lazy`1<ModuleBuilder> myModuleBuilder;
    private static Lazy`1<ProxyGeneratorMembers> ourLazyMembers { get; }
    private static ProxyGeneratorMembers Members { get; }
    public AssemblyBuilder DynamicAssembly { get; }
    public ModuleBuilder DynamicModule { get; }
    public ProxyGenerator(bool allowSave);
    private static ProxyGenerator();
    private static Lazy`1<ProxyGeneratorMembers> get_ourLazyMembers();
    private static ProxyGeneratorMembers get_Members();
    public AssemblyBuilder get_DynamicAssembly();
    public ModuleBuilder get_DynamicModule();
    public sealed virtual Type CreateType(Type interfaceType);
    public sealed virtual DynamicMethod CreateAdapter(Type selfType, MethodInfo method);
    public static bool IsSync(MethodInfo impl);
    private void ImplementMember(TypeBuilderContext ctx, MemberInfo member);
    private void ImplementProperty(TypeBuilderContext ctx, PropertyInfo propertyInfo);
    public static Type[] GetRequstType(MethodInfo method);
    public static Type GetResponseType(MethodInfo method, bool unwrapTask);
    private void ImplementMethod(TypeBuilderContext ctx, MethodInfo method);
    private static string MakeBackingFieldName(string propertyName);
    public static string ProxyFieldName(MethodInfo method);
    [IteratorStateMachineAttribute("JetBrains.Rd.Reflection.ProxyGenerator/<GetBindableFieldsNames>d__34")]
public static IEnumerable`1<string> GetBindableFieldsNames(Type rpcInterface);
    private static void LoadArgument(ILGenerator ilgen, int nArg);
    [CompilerGeneratedAttribute]
private ModuleBuilder <.ctor>b__23_1();
    [CompilerGeneratedAttribute]
private void <CreateType>g__ImplementInterface|24_0(Type baseInterface, TypeBuilderContext ctx);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
public class JetBrains.Rd.Reflection.ProxyGeneratorCache : object {
    private ProxyGenerator myGenerator;
    private ConcurrentDictionary`2<Type, Type> myTypesCache;
    private ConcurrentDictionary`2<Type, SortedList`2<MethodInfo, DynamicMethod>> myAdaptersCache;
    public ProxyGeneratorCache(ProxyGenerator generator);
    public sealed virtual Type CreateType(Type interfaceType);
    public sealed virtual DynamicMethod CreateAdapter(Type selfType, MethodInfo method);
}
[ExtensionAttribute]
public static class JetBrains.Rd.Reflection.ProxyGeneratorEx : object {
    [<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[ExtensionAttribute]
public static Type CreateType(IProxyGenerator proxyGenerator);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
internal class JetBrains.Rd.Reflection.ProxyGeneratorMembers : object {
    public ConstructorInfo RdExtConstructor;
    public FieldInfo UnitInstance;
    public MethodInfo EternalLifetimeGet;
    public MethodInfo SyncNested4;
    public MethodInfo ToTask;
    public static MethodInfo CreateRpcTimeoutMethod;
    private static ProxyGeneratorMembers();
    public static MethodInfo StartRdCall(Type rdCallType);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
[UsedImplicitlyAttribute("2")]
public static class JetBrains.Rd.Reflection.ProxyGeneratorUtil : object {
    public static Task`1<T> ToTask(IRdTask`1<T> task);
    public static TRes SyncNested(RdCall`2<TReq, TRes> call, TReq request, RpcTimeouts timeouts);
    public static TRes SyncNested(RdCall`2<TReq, TRes> call, Lifetime lifetime, TReq request, RpcTimeouts timeouts);
    public static RpcTimeouts CreateRpcTimeouts(long ticksWarning, long ticksError);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("2")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
[AttributeUsageAttribute("4")]
[MeansImplicitUseAttribute("3")]
[BaseTypeRequiredAttribute("JetBrains.Rd.Reflection.RdExtReflectionBindableBase")]
public class JetBrains.Rd.Reflection.RdExtAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <RdRpcInterface>k__BackingField;
    public Type RdRpcInterface { get; }
    [<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
public RdExtAttribute(Type rdRpcInterface);
    [CompilerGeneratedAttribute]
public Type get_RdRpcInterface();
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
public class JetBrains.Rd.Reflection.RdExtReflectionBindableBase : RdExtBase {
    private bool myBindableChildrenFilled;
    [CompilerGeneratedAttribute]
private Action`1<ISerializers> <Register>k__BackingField;
    [<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<KeyValuePair`2<string, object>> JetBrains.Rd.Reflection.IReflectionBindable.BindableChildren { get; }
    protected Action`1<ISerializers> Register { get; }
    private sealed virtual override List`1<KeyValuePair`2<string, object>> JetBrains.Rd.Reflection.IReflectionBindable.get_BindableChildren();
    [CompilerGeneratedAttribute]
protected virtual Action`1<ISerializers> get_Register();
    private sealed virtual override void JetBrains.Rd.Reflection.IReflectionBindable.EnsureBindableChildren();
    public virtual void OnActivated();
    protected virtual void PreInitBindableFields(Lifetime lifetime);
    protected virtual void InitBindableFields(Lifetime lifetime);
    public virtual void Identify(IIdentities identities, RdId id);
    public virtual string ToString();
    public virtual void Print(PrettyPrinter p);
}
[MeansImplicitUseAttribute("3")]
[AttributeUsageAttribute("20")]
[BaseTypeRequiredAttribute("JetBrains.Rd.Reflection.RdReflectionBindableBase")]
public class JetBrains.Rd.Reflection.RdModelAttribute : Attribute {
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
public class JetBrains.Rd.Reflection.RdReflectionBindableBase : RdBindableBase {
    private bool bindableChildrenFilled;
    [<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<KeyValuePair`2<string, object>> JetBrains.Rd.Reflection.IReflectionBindable.BindableChildren { get; }
    private sealed virtual override List`1<KeyValuePair`2<string, object>> JetBrains.Rd.Reflection.IReflectionBindable.get_BindableChildren();
    private sealed virtual override void JetBrains.Rd.Reflection.IReflectionBindable.EnsureBindableChildren();
    public virtual void OnActivated();
    protected virtual void AssertBindingThread();
    protected virtual void InitBindableFields(Lifetime lifetime);
    protected virtual void PreInitBindableFields(Lifetime lifetime);
    public virtual void Identify(IIdentities identities, RdId id);
    public virtual string ToString();
    public virtual void Print(PrettyPrinter p);
}
[AttributeUsageAttribute("1024")]
[MeansImplicitUseAttribute("3")]
public class JetBrains.Rd.Reflection.RdRpcAttribute : Attribute {
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("2")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
[MeansImplicitUseAttribute("3")]
[AttributeUsageAttribute("1052")]
public class JetBrains.Rd.Reflection.RdScalarAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Marshaller>k__BackingField;
    public Type Marshaller { get; }
    [<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
public RdScalarAttribute(Type marshaller);
    [CompilerGeneratedAttribute]
public Type get_Marshaller();
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
public class JetBrains.Rd.Reflection.ReflectionRdActivator : object {
    private static ILog ourLog;
    private ReflectionSerializers mySerializers;
    private IProxyGenerator myProxyGenerator;
    [<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("2")]
private ITypesCatalog myTypesCatalog;
    [<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ThreadStaticAttribute]
private static Queue`1<Type> myCurrentActivationChain;
    public ReflectionSerializers Serializers { get; }
    public IProxyGenerator Generator { get; }
    [<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("2")]
public ITypesCatalog TypesCatalog { get; }
    public ReflectionRdActivator(ReflectionSerializers serializers, ITypesCatalog typesCatalog);
    public ReflectionRdActivator(ReflectionSerializers serializers, IProxyGenerator proxyGenerator, ITypesCatalog typesCatalog);
    private static ReflectionRdActivator();
    public ReflectionSerializers get_Serializers();
    public IProxyGenerator get_Generator();
    [<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("2")]
public ITypesCatalog get_TypesCatalog();
    public T ActivateBind(Lifetime lifetime, IProtocol protocol);
    [PublicAPIAttribute]
public RdExtReflectionBindableBase ActivateBind(Type type, Lifetime lifetime, IProtocol protocol);
    public T Activate();
    public object Activate(Type type, string name);
    public object Activate(Type type);
    private object ActivateRd(Type type);
    public object ReflectionInit(object instance);
    private object ReflectionInitInternal(object instance);
    private void EnsureFakeTupleRegistered(Type type);
    public static void SetHandlerTask(RdCall`2<TReq, TRes> endpoint, Func`3<Lifetime, TReq, Task`1<TRes>> handler);
    public static void SetHandlerTaskVoid(RdCall`2<TReq, Unit> endpoint, Func`3<Lifetime, TReq, Task> handler);
    public static void SetHandler(RdCall`2<TReq, TRes> endpoint, Func`3<Lifetime, TReq, RdTask`1<TRes>> handler);
    private object ActivateMember(Type memberType, string memberName);
    [<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("2")]
private static void SetAsync(object result);
    private SerializerPair GetProperSerializer(Type type);
    private object ActivateGenericMember(string memberName, TypeInfo memberType);
    [UsedImplicitlyAttribute]
private static void SetOptimizeNested1(object container);
    [UsedImplicitlyAttribute]
private static void SetOptimizeNested2(object container);
    public static string GetTypeName(Type type);
    [CompilerGeneratedAttribute]
internal static bool <ActivateGenericMember>g__IsMonomorphic|28_0(Type type);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
public class JetBrains.Rd.Reflection.ReflectionSerializers : object {
    private Dictionary`2<Type, SerializerPair> myStaticSerializers;
    private Dictionary`2<Type, SerializerPair> myInstanceSerializers;
    private bool myPolySerializersSealed;
    private ITypesCatalog myCatalog;
    private IScalarSerializers myScalars;
    private object myLock;
    private Queue`1<Type> myCurrentSerializersChain;
    [CompilerGeneratedAttribute]
private ISignal`1<Type> <BeforeCreation>k__BackingField;
    private static MethodInfo ourGetPolymorphicGenericMethodInfo;
    public IScalarSerializers Scalars { get; }
    public ISignal`1<Type> BeforeCreation { get; }
    public ReflectionSerializers(ITypesCatalog typeCatalog, IScalarSerializers scalars, Predicate`1<Type> blackListChecker, bool withExtensions);
    private static ReflectionSerializers();
    public IScalarSerializers get_Scalars();
    [CompilerGeneratedAttribute]
public ISignal`1<Type> get_BeforeCreation();
    public sealed virtual SerializerPair GetOrRegisterSerializerPair(Type type, bool instance);
    private SerializerPair CreateScalar(Type serializerType, bool instanceSerializer);
    [<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("2")]
private void RegisterModelSerializer();
    private SerializerPair CreateGenericSerializer(TypeInfo type, TypeInfo implementation);
    public sealed virtual void Register(CtxReadDelegate`1<T> reader, CtxWriteDelegate`1<T> writer, Nullable`1<long> predefinedId);
    public void Register(Type type, SerializerPair pair);
    [<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("0")]
public sealed virtual void RegisterEnum();
    public sealed virtual void RegisterToplevelOnce(Type toplevelType, Action`1<ISerializers> registerDeclaredTypesSerializers);
    [<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("2")]
public sealed virtual T Read(SerializationCtx ctx, UnsafeReader reader, CtxReadDelegate`1<T> unknownInstanceReader);
    public sealed virtual void Write(SerializationCtx ctx, UnsafeWriter writer, T value);
    public sealed virtual SerializerPair GetPolymorphic(Type type);
    public sealed virtual SerializerPair GetPolymorphic();
    [<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("2")]
private T ReadPolymorphic(SerializationCtx ctx, UnsafeReader reader);
    private void WritePolymorphic(SerializationCtx ctx, UnsafeWriter writer, T value);
    [CompilerGeneratedAttribute]
private SerializerPair <GetOrRegisterSerializerPair>b__13_1(Type t);
    [CompilerGeneratedAttribute]
private SerializerPair <GetOrRegisterSerializerPair>b__13_2(Type t);
    [CompilerGeneratedAttribute]
private SerializerPair <CreateGenericSerializer>b__16_0(Type t);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
public class JetBrains.Rd.Reflection.ReflectionSerializersFacade : object {
    [CompilerGeneratedAttribute]
private ReflectionRdActivator <Activator>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypesCatalog <TypesCatalog>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSerializers <ScalarSerializers>k__BackingField;
    [CompilerGeneratedAttribute]
private ReflectionSerializers <Serializers>k__BackingField;
    [CompilerGeneratedAttribute]
private IProxyGenerator <ProxyGenerator>k__BackingField;
    public ReflectionRdActivator Activator { get; }
    public ITypesCatalog TypesCatalog { get; }
    public IScalarSerializers ScalarSerializers { get; }
    public ReflectionSerializers Serializers { get; }
    public IProxyGenerator ProxyGenerator { get; }
    [<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("2")]
public ReflectionSerializersFacade(ITypesCatalog typesCatalog, IScalarSerializers scalarSerializers, ReflectionSerializers reflectionSerializers, IProxyGenerator proxyGenerator, ReflectionRdActivator activator, bool allowSave, Predicate`1<Type> blackListChecker);
    [CompilerGeneratedAttribute]
public ReflectionRdActivator get_Activator();
    [CompilerGeneratedAttribute]
public ITypesCatalog get_TypesCatalog();
    [CompilerGeneratedAttribute]
public IScalarSerializers get_ScalarSerializers();
    [CompilerGeneratedAttribute]
public ReflectionSerializers get_Serializers();
    [CompilerGeneratedAttribute]
public IProxyGenerator get_ProxyGenerator();
    public TInterface ActivateProxy(Lifetime lifetime, IProtocol protocol);
    public T InitBind(T instance, Lifetime lifetime, IProtocol protocol);
    private static void Bind(IRdBindable instance, Lifetime lifetime, IProtocol protocol);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
public static class JetBrains.Rd.Reflection.ReflectionSerializerVerifier : object {
    private static HashSet`1<Type> ourPrimitiveTypes;
    private static string ourFakeTupleFullName;
    private static ReflectionSerializerVerifier();
    public static bool IsPrimitive(Type typeInfo);
    public static bool IsModelMemberDeclaration(MemberInfo memberInfo);
    public static bool CanBeNull(Type type);
    private static bool IsFieldType(TypeInfo typeInfo, bool canBeArray);
    private static bool IsNullable(TypeInfo typeInfo, Func`2<Type, bool> filter);
    public static bool IsMemberDeclaration(MemberInfo memberInfo);
    public static bool IsMemberType(TypeInfo typeInfo);
    public static bool IsScalar(Type type);
    public static void AssertEitherExtModelAttribute(TypeInfo type);
    public static void AssertRoot(TypeInfo type);
    public static bool IsValueTuple(TypeInfo type);
    public static bool HasRdExtAttribute(TypeInfo type);
    public static void AssertValidRdExt(TypeInfo type);
    public static void AssertMemberDeclaration(MemberInfo member);
    public static void AssertValidRdModel(TypeInfo type);
    public static bool HasRdModelAttribute(TypeInfo type);
    private static void AssertValidScalar(TypeInfo type);
    public static void AssertDataMemberDeclaration(MemberInfo member);
    public static Type GetImplementingType(TypeInfo typeInfo);
    public static bool IsRpcAttributeDefined(Type interface);
    public static Type GetRpcInterface(TypeInfo typeInfo);
    [IteratorStateMachineAttribute("JetBrains.Rd.Reflection.ReflectionSerializerVerifier/<GetMethodsMap>d__23")]
public static IEnumerable`1<MethodInfo> GetMethodsMap(TypeInfo typeInfo, Type rpcInterface);
    [CompilerGeneratedAttribute]
internal static bool <IsFieldType>g__IsValidArray|5_0(<>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<MethodInfo> <GetMethodsMap>g__GetInterfaceMap|23_0(Type baseInterface, <>c__DisplayClass23_0& );
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
[AttributeUsageAttribute("1088")]
public class JetBrains.Rd.Reflection.RpcTimeoutAttribute : Attribute {
    [UsedImplicitlyAttribute]
public RpcTimeouts myTimeout;
    public RpcTimeouts Timeout { get; }
    public RpcTimeoutAttribute(double errorMilliseconds, double warnMilliseconds);
    public RpcTimeoutAttribute(bool rawValues, long errorTicks, long warnTicks);
    public RpcTimeouts get_Timeout();
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Rd.Reflection.ScalarCollectionExtension : object {
    [ExtensionAttribute]
[ObsoleteAttribute("NOP method. Basic collection serializers are enabled by default")]
public static ReflectionSerializers WithBasicCollectionSerializers(ReflectionSerializers self);
    public static void AttachCollectionSerializers(ReflectionSerializers self);
    private static SerializerPair CreateArraySerializer(ISerializersSource serializersSource);
    public static bool IsList(Type t);
    public static bool IsDictionary(Type t);
    public static bool IsReadOnlyDictionary(Type t);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
public class JetBrains.Rd.Reflection.ScalarSerializer : object {
    [<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("2")]
private ITypesCatalog myTypesCatalog;
    private Predicate`1<Type> myBlackListChecker;
    [<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("2")]
public ScalarSerializer(ITypesCatalog typesCatalog, Predicate`1<Type> blackListChecker);
    public sealed virtual SerializerPair CreateSerializer(Type type, ISerializersSource serializers);
    private SerializerPair CreateCustomScalar(ISerializersSource serializers);
    private SerializerPair CreateEnumSerializer();
    private SerializerPair RegisterNullable(ISerializersSource serializers);
    private SerializerPair CreateValueTupleSerializer(ISerializersSource serializers);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
[DebuggerDisplayAttribute("TR: {ReaderTypeString}, TW: {WriterTypeString}, Polymorphic: {IsPolymorphic}")]
public class JetBrains.Rd.Reflection.SerializerPair : object {
    private object myReader;
    private object myWriter;
    [CompilerGeneratedAttribute]
private bool <IsPolymorphic>k__BackingField;
    public object Reader { get; }
    public object Writer { get; }
    public bool IsPolymorphic { get; }
    public Type ReaderType { get; }
    public Type WriterType { get; }
    private string WriterTypeString { get; }
    private string ReaderTypeString { get; }
    public SerializerPair(object reader, object writer, bool isPolymorphic);
    public object get_Reader();
    public object get_Writer();
    [CompilerGeneratedAttribute]
public bool get_IsPolymorphic();
    public Type get_ReaderType();
    public Type get_WriterType();
    private string get_WriterTypeString();
    private string get_ReaderTypeString();
    public CtxReadDelegate`1<T> GetReader();
    public CtxWriteDelegate`1<T> GetWriter();
    public static SerializerPair CreateFromMethods(MethodInfo readMethod, MethodInfo writeMethod);
    public static SerializerPair CreateFromNonProtocolMethods(MethodInfo readMethod, MethodInfo writeMethod);
    public static SerializerPair CreateFromMethods(MethodInfo readMethod, MethodInfo writeMethod, SerializerPair argumentSerializer);
    public static SerializerPair CreateFromMethods(MethodInfo readMethod, MethodInfo writeMethod, SerializerPair keySerializer, SerializerPair valueSerializer);
    private static SerializerPair CreateFromMethodsImpl0(MethodInfo readMethod, MethodInfo writeMethod);
    private static SerializerPair CreateFromMethodsImpl1(MethodInfo readMethod, MethodInfo writeMethod, SerializerPair keySerializer);
    private static SerializerPair CreateFromMethodsImpl2(MethodInfo readMethod, MethodInfo writeMethod, SerializerPair keySerializer, SerializerPair valueSerializer);
    public static SerializerPair FromMarshaller(IBuiltInMarshaller`1<T> marshaller);
    private static SerializerPair CreateFromNonProtocolMethodsT(MethodInfo readMethod, MethodInfo writeMethod);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
public class JetBrains.Rd.Reflection.SerializerReflectionUtil : object {
    private static MethodInfo ourConvertSerializerPair;
    private static MethodInfo ourConvertTypedCtxRead;
    private static MethodInfo ourConvertTypedCtxWrite;
    private static SerializerReflectionUtil();
    internal static FieldInfo[] GetBindableFields(TypeInfo typeInfo);
    [IteratorStateMachineAttribute("JetBrains.Rd.Reflection.SerializerReflectionUtil/<GetFields>d__1")]
private static IEnumerable`1<FieldInfo> GetFields(Type type, Type baseType);
    internal static SerializerPair ConvertPair(SerializerPair serializers, Type desiredType);
    private static SerializerPair ConvertPairGeneric(SerializerPair serializers);
    internal static CtxReadDelegate`1<TOut> ConvertReader(object reader);
    internal static CtxWriteDelegate`1<TOut> ConvertWriter(object writer);
    private static CtxReadDelegate`1<TOut> CtxReadTypedToObject(CtxReadDelegate`1<TIn> typedDelegate);
    private static CtxWriteDelegate`1<TOut> CtxWriteTypedToObject(CtxWriteDelegate`1<TIn> typedDelegate);
    public static bool CanBePolymorphic(Type type);
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
public class JetBrains.Rd.Reflection.SimpleTypesCatalog : object {
    private ConcurrentDictionary`2<RdId, Type> myRdIdToTypeMapping;
    public ICollection`1<Type> Types { get; }
    public ICollection`1<Type> get_Types();
    [<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("2")]
public sealed virtual Type GetById(RdId id);
    public sealed virtual RdId GetByType(Type type);
    public sealed virtual void AddType(Type type);
    [<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("2")]
public void Register();
}
[<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute("1")]
[<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute("0")]
public class JetBrains.Rd.Reflection.SwitchingScheduler : object {
    private IRdDynamic myFallbackSchedulerSource;
    private static object ourLock;
    private static int ourDisable;
    private static Stack`1<IScheduler> ourSchedulersOverride;
    public bool IsActive { get; }
    public bool OutOfOrderExecution { get; }
    public IScheduler ActiveScheduler { get; }
    public SwitchingScheduler(IRdDynamic fallbackSchedulerSource);
    private static SwitchingScheduler();
    public sealed virtual bool get_IsActive();
    public sealed virtual bool get_OutOfOrderExecution();
    public IScheduler get_ActiveScheduler();
    public sealed virtual void Queue(Action action);
    public static void Disable(Lifetime time);
}
public class JetBrains.Rd.SerializationCtx : ValueType {
    [CompilerGeneratedAttribute]
private ISerializers <Serializers>k__BackingField;
    [NotNullAttribute]
public IDictionary`2<string, IInternRoot`1<object>> InternRoots;
    public ISerializers Serializers { get; private set; }
    public SerializationCtx(ISerializers serializers, IDictionary`2<string, IInternRoot`1<object>> internRoots);
    public SerializationCtx(IProtocol protocol, IDictionary`2<string, IInternRoot`1<object>> internRoots);
    [<eef56720-e327-4776-9dd8-204dd3e85bc0>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ISerializers get_Serializers();
    [CompilerGeneratedAttribute]
private void set_Serializers(ISerializers value);
    public SerializationCtx WithInternRootsHere(RdBindableBase owner, String[] keys);
    public T ReadInterned(UnsafeReader stream, string internKey, CtxReadDelegate`1<T> readValueDelegate);
    public void WriteInterned(UnsafeWriter stream, T value, string internKey, CtxWriteDelegate`1<T> writeValueDelegate);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public interface JetBrains.Rd.Tasks.IRdCall`2 {
    public abstract virtual TRes Sync(TReq request, RpcTimeouts timeouts);
    [ObsoleteAttribute("Use overload with Lifetime")]
public abstract virtual IRdTask`1<TRes> Start(TReq request, IScheduler responseScheduler);
    public abstract virtual IRdTask`1<TRes> Start(Lifetime lifetime, TReq request, IScheduler responseScheduler);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public interface JetBrains.Rd.Tasks.IRdEndpoint`2 {
    [ObsoleteAttribute("This is an internal API. It is preferable to use SetSync or SetAsync extension methods")]
public abstract virtual void Set(Func`3<Lifetime, TReq, RdTask`1<TRes>> handler, IScheduler cancellationScheduler, IScheduler handlerScheduler);
    public abstract virtual void SetRdTask(Func`3<Lifetime, TReq, RdTask`1<TRes>> handler, IScheduler cancellationScheduler, IScheduler handlerScheduler);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[PublicAPIAttribute]
public interface JetBrains.Rd.Tasks.IRdTask`1 {
    public IReadonlyProperty`1<RdTaskResult`1<T>> Result { get; }
    public abstract virtual IReadonlyProperty`1<RdTaskResult`1<T>> get_Result();
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Tasks.RdCall`2 : RdReactiveBase {
    [CompilerGeneratedAttribute]
private CtxReadDelegate`1<TReq> <ReadRequestDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private CtxWriteDelegate`1<TReq> <WriteRequestDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private CtxReadDelegate`1<TRes> <ReadResponseDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private CtxWriteDelegate`1<TRes> <WriteResponseDelegate>k__BackingField;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`3<Lifetime, TReq, RdTask`1<TRes>> <Handler>k__BackingField;
    private Lifetime myBindLifetime;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("2")]
private IScheduler myCancellationScheduler;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("2")]
private IScheduler myHandlerScheduler;
    [PublicAPIAttribute]
public CtxReadDelegate`1<TReq> ReadRequestDelegate { get; }
    [PublicAPIAttribute]
public CtxWriteDelegate`1<TReq> WriteRequestDelegate { get; }
    [PublicAPIAttribute]
public CtxReadDelegate`1<TRes> ReadResponseDelegate { get; }
    [PublicAPIAttribute]
public CtxWriteDelegate`1<TRes> WriteResponseDelegate { get; }
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PublicAPIAttribute]
public Func`3<Lifetime, TReq, RdTask`1<TRes>> Handler { get; private set; }
    protected string ShortName { get; }
    public RdCall`2(CtxReadDelegate`1<TReq> readRequest, CtxWriteDelegate`1<TReq> writeRequest, CtxReadDelegate`1<TRes> readResponse, CtxWriteDelegate`1<TRes> writeResponse);
    [CompilerGeneratedAttribute]
public CtxReadDelegate`1<TReq> get_ReadRequestDelegate();
    [CompilerGeneratedAttribute]
public CtxWriteDelegate`1<TReq> get_WriteRequestDelegate();
    [CompilerGeneratedAttribute]
public CtxReadDelegate`1<TRes> get_ReadResponseDelegate();
    [CompilerGeneratedAttribute]
public CtxWriteDelegate`1<TRes> get_WriteResponseDelegate();
    [CompilerGeneratedAttribute]
public Func`3<Lifetime, TReq, RdTask`1<TRes>> get_Handler();
    [CompilerGeneratedAttribute]
private void set_Handler(Func`3<Lifetime, TReq, RdTask`1<TRes>> value);
    protected virtual void PreInit(Lifetime lifetime, IProtocol proto);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public sealed virtual void SetRdTask(Func`3<Lifetime, TReq, RdTask`1<TRes>> handler, IScheduler cancellationScheduler, IScheduler handlerScheduler);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
[ObsoleteAttribute("This is an internal API. It is preferable to use SetSync or SetAsync extension methods")]
public sealed virtual void Set(Func`3<Lifetime, TReq, RdTask`1<TRes>> handler, IScheduler cancellationScheduler, IScheduler handlerScheduler);
    [PublicAPIAttribute]
public virtual void OnWireReceived(IProtocol proto, SerializationCtx ctx, UnsafeReader reader, IRdWireableDispatchHelper dispatchHelper);
    private void OnWireReceived(SerializationCtx ctx, UnsafeReader reader, Endpoint<TReq, TRes> wiredTask, IRdWireableDispatchHelper dispatchHelper);
    private RdTask`1<TRes> RunHandler(TReq value, Lifetime externalCancellation, object moniker);
    public sealed virtual TRes Sync(TReq request, RpcTimeouts timeouts);
    public sealed virtual IRdTask`1<TRes> Start(TReq request, IScheduler responseScheduler);
    public sealed virtual IRdTask`1<TRes> Start(Lifetime lifetime, TReq request, IScheduler responseScheduler);
    private IRdTask`1<TRes> StartInternal(Lifetime requestLifetime, TReq request, IScheduler scheduler);
    private CallSite<TReq, TRes> CreateCallSite(Lifetime requestLifetime, Func`2<Lifetime, CallSite<TReq, TRes>> createTask);
    public static RdCall`2<TReq, TRes> Read(SerializationCtx ctx, UnsafeReader reader, CtxReadDelegate`1<TReq> readRequest, CtxWriteDelegate`1<TReq> writeRequest, CtxReadDelegate`1<TRes> readResponse, CtxWriteDelegate`1<TRes> writeResponse);
    public static void Write(SerializationCtx ctx, UnsafeWriter writer, RdCall`2<TReq, TRes> value);
    protected virtual string get_ShortName();
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
[PublicAPIAttribute]
public class JetBrains.Rd.Tasks.RdFault : Exception {
    [CompilerGeneratedAttribute]
private string <ReasonTypeFqn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReasonText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReasonMessage>k__BackingField;
    public string ReasonTypeFqn { get; private set; }
    public string ReasonText { get; private set; }
    public string ReasonMessage { get; private set; }
    public RdFault(Exception inner);
    protected RdFault(SerializationInfo info, StreamingContext context);
    public RdFault(string reasonTypeFqn, string reasonMessage, string reasonText, Exception reason);
    [CompilerGeneratedAttribute]
public string get_ReasonTypeFqn();
    [CompilerGeneratedAttribute]
private void set_ReasonTypeFqn(string value);
    [CompilerGeneratedAttribute]
public string get_ReasonText();
    [CompilerGeneratedAttribute]
private void set_ReasonText(string value);
    [CompilerGeneratedAttribute]
public string get_ReasonMessage();
    [CompilerGeneratedAttribute]
private void set_ReasonMessage(string value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static RdFault Read(SerializationCtx ctx, UnsafeReader reader);
    public static void Write(SerializationCtx ctx, UnsafeWriter writer, RdFault value);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public static class JetBrains.Rd.Tasks.RdTask : object {
    [PublicAPIAttribute]
public static RdTask`1<T> Successful(T result);
    [PublicAPIAttribute]
public static RdTask`1<T> Faulted(Exception exception);
    [PublicAPIAttribute]
public static RdTask`1<T> Cancelled();
    private static RdTask`1<T> FromResult(RdTaskResult`1<T> result);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Tasks.RdTask`1 : object {
    internal WriteOnceProperty`1<RdTaskResult`1<T>> ResultInternal;
    public IReadonlyProperty`1<RdTaskResult`1<T>> Result { get; }
    public sealed virtual IReadonlyProperty`1<RdTaskResult`1<T>> get_Result();
    public void Set(T value);
    public void SetCancelled();
    public void Set(Exception e);
    [ObsoleteAttribute("Use 'RdTask.Successful<T>(T)' instead")]
public static RdTask`1<T> Successful(T result);
    [ObsoleteAttribute("Use 'RdTask.Faulted<T>(Exception)' instead")]
public static RdTask`1<T> Faulted(Exception exception);
    [ObsoleteAttribute("Use 'RdTask.Cancelled<T>()' instead")]
public static RdTask`1<T> Cancelled();
    [PublicAPIAttribute]
public static Task`1<T> op_Implicit(RdTask`1<T> task);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Rd.Tasks.RdTaskEx : object {
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[ExtensionAttribute]
[PublicAPIAttribute]
public static bool IsSucceed(IRdTask`1<T> task);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[ExtensionAttribute]
[PublicAPIAttribute]
public static bool IsCanceled(IRdTask`1<T> task);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[ExtensionAttribute]
[PublicAPIAttribute]
public static bool IsFaulted(IRdTask`1<T> task);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool Wait(IRdTask`1<T> task, TimeSpan timeout);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[ExtensionAttribute]
public static RdTask`1<T> ToRdTask(Task`1<T> task);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[ExtensionAttribute]
public static RdTask`1<Unit> ToRdTask(Task task);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static void Set(IRdEndpoint`2<TReq, TRes> endpoint, Func`3<Lifetime, TReq, Task`1<TRes>> handler, IScheduler cancellationScheduler, IScheduler handlerScheduler);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static void SetAsync(IRdEndpoint`2<TReq, TRes> endpoint, Func`3<Lifetime, TReq, Task`1<TRes>> handler, IScheduler cancellationScheduler, IScheduler handlerScheduler);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static void SetVoidAsync(IRdEndpoint`2<TReq, Unit> endpoint, Func`3<Lifetime, TReq, Task> handler, IScheduler cancellationScheduler, IScheduler handlerScheduler);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static void Set(IRdEndpoint`2<TReq, TRes> endpoint, Func`3<Lifetime, TReq, TRes> handler, IScheduler cancellationScheduler, IScheduler handlerScheduler);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static void SetSync(IRdEndpoint`2<TReq, TRes> endpoint, Func`3<Lifetime, TReq, TRes> handler, IScheduler cancellationScheduler, IScheduler handlerScheduler);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static void Set(IRdEndpoint`2<TReq, TRes> endpoint, Func`2<TReq, TRes> handler, IScheduler cancellationScheduler, IScheduler handlerScheduler);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static void SetSync(IRdEndpoint`2<TReq, TRes> endpoint, Func`2<TReq, TRes> handler, IScheduler cancellationScheduler, IScheduler handlerScheduler);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static void SetVoid(IRdEndpoint`2<TReq, Unit> endpoint, Action`1<TReq> handler, IScheduler cancellationScheduler, IScheduler handlerScheduler);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[ExtensionAttribute]
[PublicAPIAttribute]
public static Task`1<T> AsTask(IRdTask`1<T> task);
}
public class JetBrains.Rd.Tasks.RdTaskResult`1 : object {
    [CompilerGeneratedAttribute]
private RdTaskStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private RdFault <Error>k__BackingField;
    public RdTaskStatus Status { get; }
    public T Result { get; }
    public RdFault Error { get; }
    private RdTaskResult`1(RdTaskStatus status, T result, RdFault error);
    [CompilerGeneratedAttribute]
public RdTaskStatus get_Status();
    [CompilerGeneratedAttribute]
public T get_Result();
    [CompilerGeneratedAttribute]
public RdFault get_Error();
    internal static RdTaskResult`1<T> Success(T result);
    internal static RdTaskResult`1<T> Cancelled();
    internal static RdTaskResult`1<T> Faulted(Exception exception);
    public T Unwrap();
    public static RdTaskResult`1<T> Read(CtxReadDelegate`1<T> readDelegate, SerializationCtx ctx, UnsafeReader reader);
    public static void Write(CtxWriteDelegate`1<T> writeDelegate, SerializationCtx ctx, UnsafeWriter writer, RdTaskResult`1<T> value);
    public sealed virtual void Print(PrettyPrinter printer);
    public virtual string ToString();
}
public enum JetBrains.Rd.Tasks.RdTaskStatus : Enum {
    public int value__;
    public static RdTaskStatus Success;
    public static RdTaskStatus Canceled;
    public static RdTaskStatus Faulted;
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Tasks.RpcTimeouts : object {
    public static RpcTimeouts Default;
    public static RpcTimeouts Maximal;
    public static bool RespectRpcTimeouts;
    public TimeSpan WarnAwaitTime;
    public TimeSpan ErrorAwaitTime;
    public RpcTimeouts(TimeSpan warnAwaitTime, TimeSpan errorAwaitTime);
    private static RpcTimeouts();
    public static RpcTimeouts Max(RpcTimeouts x, RpcTimeouts y);
    public static RpcTimeouts GetRpcTimeouts(RpcTimeouts timeouts);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class JetBrains.Rd.Tasks.WiredRdTask`2 : RdTask`1<TRes> {
    private RdCall`2<TReq, TRes> myCall;
    [CompilerGeneratedAttribute]
private RdId <RdId>k__BackingField;
    [CompilerGeneratedAttribute]
private IScheduler <WireScheduler>k__BackingField;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("2")]
public IWire Wire;
    [CompilerGeneratedAttribute]
private RName <Location>k__BackingField;
    public RdId RdId { get; }
    public bool IsBound { get; }
    public IScheduler WireScheduler { get; }
    public RName Location { get; }
    protected WiredRdTask`2(RdCall`2<TReq, TRes> call, RdId rdId, IScheduler wireScheduler);
    [CompilerGeneratedAttribute]
public sealed virtual RdId get_RdId();
    public bool get_IsBound();
    [CompilerGeneratedAttribute]
public IScheduler get_WireScheduler();
    [CompilerGeneratedAttribute]
public sealed virtual RName get_Location();
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public sealed virtual IProtocol TryGetProto();
    public sealed virtual bool TryGetSerializationContext(SerializationCtx& ctx);
    public sealed virtual void OnWireReceived(UnsafeReader reader, IRdWireableDispatchHelper dispatchHelper);
    public abstract virtual void OnWireReceived(IProtocol proto, SerializationCtx ctx, UnsafeReader reader, IRdWireableDispatchHelper dispatchHelper);
    protected void Trace(ILog log, string message, object additional);
    public virtual string ToString();
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Text.Impl.Intrinsics.RdAssertion : object {
    [CompilerGeneratedAttribute]
private int <MasterVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SlaveVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public static CtxReadDelegate`1<RdAssertion> Read;
    public static CtxWriteDelegate`1<RdAssertion> Write;
    public int MasterVersion { get; private set; }
    public int SlaveVersion { get; private set; }
    public string Text { get; private set; }
    public RdAssertion(int masterVersion, int slaveVersion, string text);
    private static RdAssertion();
    [CompilerGeneratedAttribute]
public int get_MasterVersion();
    [CompilerGeneratedAttribute]
private void set_MasterVersion(int value);
    [CompilerGeneratedAttribute]
public int get_SlaveVersion();
    [CompilerGeneratedAttribute]
private void set_SlaveVersion(int value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(string value);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public sealed virtual bool Equals(RdAssertion other);
    public virtual int GetHashCode();
    public sealed virtual void Print(PrettyPrinter printer);
    public virtual string ToString();
}
public enum JetBrains.Rd.Text.Impl.Intrinsics.RdChangeOrigin : Enum {
    public int value__;
    public static RdChangeOrigin Slave;
    public static RdChangeOrigin Master;
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Text.Impl.Intrinsics.RdTextBufferChange : object {
    public RdTextChange Change;
    public TextBufferVersion Version;
    public RdChangeOrigin Origin;
    public static CtxReadDelegate`1<RdTextBufferChange> ReadDelegate;
    public static CtxWriteDelegate`1<RdTextBufferChange> WriteDelegate;
    public RdTextBufferChange(TextBufferVersion version, RdChangeOrigin origin, RdTextChange change);
    private static RdTextBufferChange();
    public sealed virtual void Print(PrettyPrinter printer);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Text.Impl.Intrinsics.RdTextBufferState : RdBindableBase {
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private RdProperty`1<RdTextBufferChange> _Changes;
    private RdProperty`1<TextBufferVersion> _VersionBeforeTypingSession;
    private RdProperty`1<RdAssertion> _AssertedMasterText;
    private RdProperty`1<RdAssertion> _AssertedSlaveText;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxReadDelegate`1<RdTextBufferChange> ReadRdTextBufferChangeNullable;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CtxWriteDelegate`1<RdTextBufferChange> WriteRdTextBufferChangeNullable;
    public static CtxReadDelegate`1<RdTextBufferState> Read;
    public static CtxWriteDelegate`1<RdTextBufferState> Write;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IViewableProperty`1<RdTextBufferChange> Changes { get; }
    public IViewableProperty`1<TextBufferVersion> VersionBeforeTypingSession { get; }
    public IViewableProperty`1<RdAssertion> AssertedMasterText { get; }
    public IViewableProperty`1<RdAssertion> AssertedSlaveText { get; }
    private RdTextBufferState(RdProperty`1<RdTextBufferChange> changes, RdProperty`1<TextBufferVersion> versionBeforeTypingSession, RdProperty`1<RdAssertion> assertedMasterText, RdProperty`1<RdAssertion> assertedSlaveText);
    private static RdTextBufferState();
    public IViewableProperty`1<RdTextBufferChange> get_Changes();
    public IViewableProperty`1<TextBufferVersion> get_VersionBeforeTypingSession();
    public IViewableProperty`1<RdAssertion> get_AssertedMasterText();
    public IViewableProperty`1<RdAssertion> get_AssertedSlaveText();
    public virtual void Print(PrettyPrinter printer);
    public virtual string ToString();
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Rd.Text.Impl.RdTextBuffer : RdDelegateBase`1<RdTextBufferState> {
    [CompilerGeneratedAttribute]
private bool <IsMaster>k__BackingField;
    private RdChangeOrigin myLocalOrigin;
    private List`1<RdTextBufferChange> myChangesToConfirmOrRollback;
    private IViewableProperty`1<RdTextChange> myTextChanged;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("2")]
private TextBufferTypingSession myActiveSession;
    [CompilerGeneratedAttribute]
private TextBufferVersion <BufferVersion>k__BackingField;
    private Lifetime myBindLifetime;
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IScheduler <Scheduler>k__BackingField;
    public bool IsMaster { get; }
    public bool IsCommitting { get; }
    public TextBufferVersion BufferVersion { get; private set; }
    [<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("2")]
public IScheduler Scheduler { get; public set; }
    public RdTextBuffer(RdTextBufferState state, bool isMaster);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsMaster();
    public bool get_IsCommitting();
    [CompilerGeneratedAttribute]
public sealed virtual TextBufferVersion get_BufferVersion();
    [CompilerGeneratedAttribute]
private void set_BufferVersion(TextBufferVersion value);
    public virtual void PreBind(Lifetime lf, IRdDynamic parent, string name);
    public virtual void Bind();
    private void ReceiveChange(RdTextBufferChange rdTextBufferChange);
    private void ClearState();
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual IScheduler get_Scheduler();
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_Scheduler(IScheduler value);
    public sealed virtual void Fire(RdTextChange change);
    private void IncrementBufferVersion();
    public sealed virtual void Advise(Lifetime lifetime, Action`1<RdTextChange> change);
    public sealed virtual void Reset(string text);
    public sealed virtual void AssertState(string allText);
    public sealed virtual ITypingSession StartTypingSession(Lifetime lifetime);
    [CompilerGeneratedAttribute]
private void <Bind>b__17_0(RdTextBufferChange change);
    [CompilerGeneratedAttribute]
private void <StartTypingSession>b__29_0();
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Text.Intrinsics.RdTextChange : object {
    public int FullTextLength;
    public RdTextChangeKind Kind;
    public string New;
    public string Old;
    public int StartOffset;
    public RdTextChange(RdTextChangeKind kind, int startOffset, string old, string new, int fullTextLength);
    public sealed virtual void Print(PrettyPrinter printer);
    public RdTextChange Reverse();
    private static RdTextChangeKind ReverseKind(RdTextChangeKind kind);
    private static string Escape(string s);
    public virtual string ToString();
}
public enum JetBrains.Rd.Text.Intrinsics.RdTextChangeKind : Enum {
    public int value__;
    public static RdTextChangeKind Insert;
    public static RdTextChangeKind Remove;
    public static RdTextChangeKind Replace;
    public static RdTextChangeKind Reset;
    public static RdTextChangeKind PromoteVersion;
    public static RdTextChangeKind InsertLeftSide;
    public static RdTextChangeKind InsertRightSide;
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public static class JetBrains.Rd.Text.Intrinsics.RdTextChangeSerializer : object {
    public static CtxReadDelegate`1<RdTextChange> ReadDelegate;
    public static CtxWriteDelegate`1<RdTextChange> WriteDelegate;
    private static RdTextChangeSerializer();
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Text.Intrinsics.TextBufferVersion : ValueType {
    public static TextBufferVersion InitVersion;
    [CompilerGeneratedAttribute]
private int <Master>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Slave>k__BackingField;
    private static IEqualityComparer`1<TextBufferVersion> ourMasterVersionSlaveVersionComparerInstance;
    public int Master { get; }
    public int Slave { get; }
    public static IEqualityComparer`1<TextBufferVersion> MasterVersionSlaveVersionComparer { get; }
    public TextBufferVersion(int master, int slave);
    private static TextBufferVersion();
    [<eef56720-e327-4776-9dd8-204dd3e85bc0>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Master();
    [<eef56720-e327-4776-9dd8-204dd3e85bc0>IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Slave();
    public bool Equals(TextBufferVersion other);
    public static bool op_Equality(TextBufferVersion left, TextBufferVersion right);
    public static bool op_Inequality(TextBufferVersion left, TextBufferVersion right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static IEqualityComparer`1<TextBufferVersion> get_MasterVersionSlaveVersionComparer();
    public TextBufferVersion IncrementMaster();
    public TextBufferVersion IncrementSlave();
    public virtual string ToString();
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public static class JetBrains.Rd.Text.Intrinsics.TextBufferVersionSerializer : object {
    public static CtxReadDelegate`1<TextBufferVersion> ReadDelegate;
    public static CtxWriteDelegate`1<TextBufferVersion> WriteDelegate;
    private static TextBufferVersionSerializer();
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public interface JetBrains.Rd.Text.ITextBuffer {
    public TextBufferVersion BufferVersion { get; }
    public bool IsMaster { get; }
    public abstract virtual TextBufferVersion get_BufferVersion();
    public abstract virtual bool get_IsMaster();
    public abstract virtual void Reset(string text);
    public abstract virtual void AssertState(string allText);
}
public interface JetBrains.Rd.Text.ITextBufferWithTypingSession {
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public abstract virtual ITypingSession StartTypingSession(Lifetime lifetime);
}
public interface JetBrains.Rd.Text.ITypingSession {
    public abstract virtual void CommitRemoteChanges();
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Rd.Text.RdTextChangeEx : object {
    [ExtensionAttribute]
public static int GetDelta(RdTextChange that);
    [ExtensionAttribute]
public static void AssertDocumentLength(RdTextChange that, int currentLen);
}
public abstract class JetBrains.Rd.ThreadLocalRdContext`1 : RdContext`1<T> {
    [ThreadStaticAttribute]
[CanBeNullAttribute]
private static SingleThreadObjectPool`1<UpdateValueCookie<T>> ourPool;
    private AsyncLocal`1<T> myValue;
    public T Value { get; }
    protected ThreadLocalRdContext`1(string key, bool isHeavy, CtxReadDelegate`1<T> readDelegate, CtxWriteDelegate`1<T> writeDelegate);
    public virtual T get_Value();
    public virtual IDisposable UpdateValue(T newValue);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
internal class JetBrains.Rd.Util.ConcurrentSet`1 : object {
    private ConcurrentDictionary`2<T, bool> myDictionary;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[ExtensionAttribute]
internal static class JetBrains.Rd.Util.DictionaryEx : object {
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
internal static TValue GetOrDefault(Dictionary`2<TKey, TValue> dictionary, TKey key, TValue default);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
internal static TValue GetOrCreate(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`1<TValue> factory);
    [ExtensionAttribute]
public static void BlockingAddUnique(IDictionary`2<TKey, TValue> dictionary, Lifetime lifetime, object lock, TKey key, TValue value);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public class JetBrains.Rd.Util.PrettyPrinter : object {
    private bool myNeedIndent;
    private int myIndent;
    private StringBuilder myBuilder;
    [PublicAPIAttribute]
public static int InfiniteCapacity;
    [CompilerGeneratedAttribute]
private int <BufferCapacity>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Step>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CollectionMaxLength>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrintContent>k__BackingField;
    [PublicAPIAttribute]
public int BufferCapacity { get; public set; }
    [PublicAPIAttribute]
public int Step { get; public set; }
    [PublicAPIAttribute]
public int CollectionMaxLength { get; public set; }
    [PublicAPIAttribute]
public bool PrintContent { get; public set; }
    public bool BufferExceeded { get; }
    [CompilerGeneratedAttribute]
public int get_BufferCapacity();
    [CompilerGeneratedAttribute]
public void set_BufferCapacity(int value);
    [CompilerGeneratedAttribute]
public int get_Step();
    [CompilerGeneratedAttribute]
public void set_Step(int value);
    [CompilerGeneratedAttribute]
public int get_CollectionMaxLength();
    [CompilerGeneratedAttribute]
public void set_CollectionMaxLength(int value);
    [CompilerGeneratedAttribute]
public bool get_PrintContent();
    [CompilerGeneratedAttribute]
public void set_PrintContent(bool value);
    public bool get_BufferExceeded();
    public PrettyPrinterIndentCookie IndentCookie();
    public void Print(string str);
    public void Println();
    public void Println(string str);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Rd.Util.PrintableEx : object {
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[ExtensionAttribute]
public static string PrintToString(IPrintable printable, Nullable`1<int> collectionMaxLength);
}
public class JetBrains.Rd.Util.SingleLinePrettyPrinter : PrettyPrinter {
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
public virtual string ToString();
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
public abstract class JetBrains.Rd.WireBase : object {
    protected MessageBroker MessageBroker;
    private ProtocolContexts myContexts;
    private bool myBackwardsCompatibleWireFormat;
    public bool IsStub { get; }
    public ProtocolContexts Contexts { get; public set; }
    public bool BackwardsCompatibleWireFormat { get; public set; }
    [ObsoleteAttribute]
protected WireBase(IScheduler scheduler);
    public sealed virtual bool get_IsStub();
    public sealed virtual ProtocolContexts get_Contexts();
    public sealed virtual void set_Contexts(ProtocolContexts value);
    public sealed virtual void StartDeliveringMessages();
    public bool get_BackwardsCompatibleWireFormat();
    public void set_BackwardsCompatibleWireFormat(bool value);
    protected void Receive(Byte[] msg);
    protected abstract virtual void SendPkg(Cookie pkg);
    public sealed virtual void Send(RdId id, TParam param, Action`2<TParam, UnsafeWriter> writer);
    public sealed virtual void Advise(Lifetime lifetime, IRdWireable reactive);
    [<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("2")]
public sealed virtual IRdWireable TryGetById(RdId rdId);
}
[<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute("1")]
[<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Rd.WireEx : object {
    [ExtensionAttribute]
public static int GetServerPort(IWire wire);
    [ExtensionAttribute]
public static void Send(IWire wire, RdId id, Action`1<UnsafeWriter> writer);
    [ExtensionAttribute]
public static void WriteContext(IWire wire, UnsafeWriter writer);
}
internal class JetBrains.ReSharper.TestRunner.Application : LongLivedMarshalByRefObject {
    private ILifetimeScope myScope;
    private IApplicationOptions myOptions;
    private ILogger myLogger;
    public Application(ILifetimeScope scope, IApplicationOptions options);
    public sealed virtual void Run();
    private void RegisterApplicationParts(ContainerBuilder builder);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.TestRunner.ApplicationOptionsExtensions : object {
    [ExtensionAttribute]
internal static bool IsLoggingToFileEnabled(IApplicationOptions options);
    [ExtensionAttribute]
internal static string LogFile(IApplicationOptions options);
}
internal class JetBrains.ReSharper.TestRunner.Bootstrapper`1 : object {
    private IApplicationOptions myOptions;
    private ILogger myLogger;
    protected Bootstrapper`1(IApplicationOptions options);
    public void Run();
    private void TryHideOurProbingDir();
    private void TrySetupTraceListener();
    private void TryAttachDebugger();
    private void TryWatchForParentProcessExit();
    private static void RunAppInSeparateLoadContext(ILifetimeScope scope);
    internal IContainer BuildContainer(LifetimeDefinition ltd);
    public static int Run(IApplicationOptions options);
}
public static class JetBrains.ReSharper.TestRunner.EntryPoint : object {
    public static int Run(String[] args);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.TestRunner.Extensions.AutofacExtensions : object {
    [ExtensionAttribute]
public static T ResolveUnregistered(ILifetimeScope scope);
    [ExtensionAttribute]
public static T ResolveUnregistered(ILifetimeScope scope, Parameter[] parameters);
    [ExtensionAttribute]
public static object ResolveUnregistered(ILifetimeScope scope, Type serviceType, Parameter[] parameters);
    [ExtensionAttribute]
public static void RegisterAssemblyModulesFast(ContainerBuilder builder, Assembly assembly);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<Type> <RegisterAssemblyModulesFast>g__GetLoadableTypes|3_0(Assembly asm);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.TestRunner.Extensions.CustomAttributeProviderExtensions : object {
    [ExtensionAttribute]
public static T GetAttribute(ICustomAttributeProvider provider, bool inherit);
    [ExtensionAttribute]
public static T[] GetAttributes(ICustomAttributeProvider provider, bool inherit);
    [ExtensionAttribute]
public static bool HasAttribute(ICustomAttributeProvider provider, bool inherit);
    [ExtensionAttribute]
public static bool HasAttribute(ICustomAttributeProvider provider, Type attributeType, bool inherit);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.TestRunner.Extensions.LoadContextExtensions : object {
    [ExtensionAttribute]
public static void RunInContext(ILoadContext ctx, Expression`1<Action`1<T>> expression, T1 p1);
    [ExtensionAttribute]
public static void RunInContext(ILoadContext ctx, Expression`1<Action`1<T>> expression, T1 p1, T2 p2);
    [ExtensionAttribute]
public static void RunInContext(ILoadContext ctx, Expression`1<Action`1<T>> expression, T1 p1, T2 p2, T3 p3);
    [ExtensionAttribute]
public static void RunInContext(ILoadContext ctx, Expression`1<Action`1<T>> expression, Object[] args);
    [ExtensionAttribute]
public static TResult RunInContext(ILoadContext ctx, Expression`1<Func`2<T, TResult>> expression, Object[] args);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.TestRunner.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static string EnsureWellformedDirectoryPath(string str);
    [ExtensionAttribute]
public static bool EndsWith(string str, char value);
}
public static class JetBrains.ReSharper.TestRunner.Extensions.TaskEx : object {
    public static Task CompletedTask;
    private static TaskEx();
    public static Task`1<TResult> FromException(Exception exception);
    public static Task Delay(TimeSpan delay, CancellationToken cancellationToken);
    public static Task Delay(int millisecondsDelay, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.TestRunner.Extensions.TypeExtensions : object {
    [ExtensionAttribute]
public static bool IsGenericDefinedAs(Type type, Type template, bool recursive);
    [ExtensionAttribute]
public static bool IsAssignableFrom(Type type);
    [ExtensionAttribute]
public static bool IsAssignableTo(Type type);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.TestRunner.Extensions.TypeExtensions/<GetHierarchy>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<Type> GetHierarchy(Type type, bool includeSelf);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.TestRunner.Extensions.TypeExtensions/<GetInterfaces>d__4")]
[ExtensionAttribute]
public static IEnumerable`1<Type> GetInterfaces(Type type, bool includeSelf);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetInterfaces(Type type, Type template);
    [ExtensionAttribute]
public static bool Inherits(Type type);
    [ExtensionAttribute]
public static bool Inherits(Type type, Type parentType);
    [ExtensionAttribute]
public static bool Implements(Type type);
    [ExtensionAttribute]
public static bool Implements(Type type, Type interface);
    [ExtensionAttribute]
public static Type[] GetGenericArgumentsOf(Type type, Type template);
}
public interface JetBrains.ReSharper.TestRunner.IApplication {
    public abstract virtual void Run();
}
public interface JetBrains.ReSharper.TestRunner.IApplicationOptions {
    public string LogFolder { get; }
    public LoggingLevel LogLevel { get; }
    public bool WaitForDebugger { get; }
    public Assembly EntryPoint { get; }
    public abstract virtual string get_LogFolder();
    public abstract virtual LoggingLevel get_LogLevel();
    public abstract virtual bool get_WaitForDebugger();
    public abstract virtual Assembly get_EntryPoint();
}
public interface JetBrains.ReSharper.TestRunner.IConnectOptions {
    public string Host { get; }
    public int Port { get; }
    public abstract virtual string get_Host();
    public abstract virtual int get_Port();
}
public interface JetBrains.ReSharper.TestRunner.IListenOptions {
    public RemoteAgentMode Mode { get; }
    public abstract virtual RemoteAgentMode get_Mode();
}
internal class JetBrains.ReSharper.TestRunner.Implementation.BatchingTestExecutionSink : RejectingCallContextObject {
    private IMessageBroker myServer;
    private ITestRunnerClientController myClientController;
    private TimeSpan myProlongationPeriod;
    private TimeSpan myNonProlongationPeriod;
    private ILogger myLogger;
    private CollectedResults modreq(System.Runtime.CompilerServices.IsVolatile) myCollectedResults;
    public BatchingTestExecutionSink(IMessageBroker server, ITestRunnerClientController clientController, TimeSpan prolongationPeriod, TimeSpan nonProlongationPeriod, ILogger logger);
    public sealed virtual void RunStarting();
    public sealed virtual void RunFinished();
    public virtual void TestStarting(RemoteTask task);
    public virtual void TestException(RemoteTask task, ExceptionInfo[] exceptions);
    public sealed virtual void TestFinished(RemoteTask task, TestOutcome outcome, string message, Nullable`1<TimeSpan> duration);
    public virtual void TestOutput(RemoteTask task, string text, TestOutputType outputType);
    public virtual void DynamicTestDiscovered(RemoteTask task);
    private Task Flush();
    private sealed virtual override void System.IDisposable.Dispose();
}
[RdExtAttribute("JetBrains.ReSharper.TestRunner.Abstractions.IClientEndpoint")]
internal class JetBrains.ReSharper.TestRunner.Implementation.ClientEndpoint : RdExtReflectionBindableBase {
    private TaskFactory myFactory;
    private IDictionary`2<Type, Func`2<IAutoRegisterInProtocol, Task`1<IAutoRegisterInProtocol>>> myHandlers;
    private ILogger myLogger;
    public ClientEndpoint(IEnumerable`1<IMessageHandlerMarker> markers, TaskScheduler scheduler);
    private bool TryRegisterHandler(IMessageHandlerMarker marker);
    private bool TryRegisterHandlerWithResult(IMessageHandlerMarker marker);
    private bool TryRegisterAsyncHandler(IMessageHandlerMarker marker);
    private bool TryRegisterAsyncHandlerWithResult(IMessageHandlerMarker marker);
    private void RegisterGeneric(IMessageHandlerMarker marker);
    public sealed virtual Task`1<IAutoRegisterInProtocol> SendMessage(IAutoRegisterInProtocol message);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.TestRunner.Implementation.ClientEndpoint/<RunAndLog>d__10")]
private Task`1<IAutoRegisterInProtocol> RunAndLog(Func`2<IAutoRegisterInProtocol, Task`1<IAutoRegisterInProtocol>> handler, IAutoRegisterInProtocol message);
}
internal class JetBrains.ReSharper.TestRunner.Implementation.ClientMessageBroker : LongLivedMarshalByRefObject {
    private IServerEndpoint myServer;
    private ILogger myLogger;
    public ClientMessageBroker(IServerEndpoint server);
    public sealed virtual Task SendMessage(IMessage message);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.TestRunner.Implementation.ClientMessageBroker/<SendMessage>d__4`1")]
public sealed virtual Task`1<TResult> SendMessage(IMessage`1<TResult> message);
}
internal class JetBrains.ReSharper.TestRunner.Implementation.DefaultTestAdapterLoadContextFactory : object {
    private TestAdapterInfo myInfo;
    private ILifetimeScope myScope;
    private IAssemblyResolver myAssemblyResolver;
    private ILogger myLogger;
    public DefaultTestAdapterLoadContextFactory(TestAdapterInfo info, ILifetimeScope scope, IAssemblyResolver assemblyResolver, ILogger logger);
    public sealed virtual ITestAdapterLoadContext Initialize(TestRequest request);
}
public class JetBrains.ReSharper.TestRunner.Implementation.DummyClientController : object {
    public sealed virtual void BeforeRunStarted();
    public sealed virtual void AfterRunFinished();
    public sealed virtual void BeforeTestStarted(RemoteTask task);
    public sealed virtual void AfterTestFinished(RemoteTask remoteTask, String& message, TestOutcome& outcome);
}
internal class JetBrains.ReSharper.TestRunner.Implementation.FileSystem : LongLivedMarshalByRefObject {
    private IFileSystemRoot myRoot;
    private IFileSystemCallbacks myReporter;
    private ILogger myLogger;
    private Lazy`1<string> myCacheDirectory;
    public string CacheDirectory { get; }
    public FileSystem(IFileSystemRoot root, IFileSystemCallbacks reporter);
    public sealed virtual string get_CacheDirectory();
    private string CreateCacheDirectoryAndReport();
    public sealed virtual string CreateTempDirectory();
}
internal class JetBrains.ReSharper.TestRunner.Implementation.FileSystemCallbacks : object {
    private IMessageBroker myServer;
    public FileSystemCallbacks(IMessageBroker server);
    public sealed virtual void OnCacheDirectoryCreated(string pathToCacheDirectory);
}
internal class JetBrains.ReSharper.TestRunner.Implementation.FileSystemRoot : LongLivedMarshalByRefObject {
    private ILogger myLogger;
    private Lazy`1<string> myCacheDirectory;
    public string CacheDirectory { get; }
    public string CacheDirectoryIfExists { get; }
    public FileSystemRoot(ILogger logger);
    public sealed virtual string get_CacheDirectory();
    public sealed virtual string get_CacheDirectoryIfExists();
    private string CreateCacheDirectory();
}
internal interface JetBrains.ReSharper.TestRunner.Implementation.IExtendedTestExecutionSink {
    public abstract virtual void RunStarting();
    public abstract virtual void RunFinished();
}
internal interface JetBrains.ReSharper.TestRunner.Implementation.IFileSystemCallbacks {
    public abstract virtual void OnCacheDirectoryCreated(string pathToCacheDirectory);
}
public interface JetBrains.ReSharper.TestRunner.Implementation.IFileSystemRoot {
    public string CacheDirectory { get; }
    public string CacheDirectoryIfExists { get; }
    public abstract virtual string get_CacheDirectory();
    public abstract virtual string get_CacheDirectoryIfExists();
}
internal class JetBrains.ReSharper.TestRunner.Implementation.InteroperableMessageBroker : LongLivedMarshalByRefObject {
    private IMessageBroker myInner;
    public InteroperableMessageBroker(IMessageBroker inner);
    public sealed virtual void SendMessage(IMessage message, MarshaledTask task);
    public sealed virtual void SendMessage(IMessage`1<TResult> message, MarshaledTask`1<TResult> task);
}
internal interface JetBrains.ReSharper.TestRunner.Implementation.IRemoteAgentEndpoint {
    public IViewableSet`1<ILifetimeScope> OnBackendConnected { get; }
    public abstract virtual IViewableSet`1<ILifetimeScope> get_OnBackendConnected();
}
public interface JetBrains.ReSharper.TestRunner.Implementation.ITestAdapterLoadContextFactoryFactory {
    public abstract virtual void SetTestAdapterLoader(TestAdapterLoader testAdapterLoader);
    public abstract virtual void RegisterDynamicScalars(ReflectionSerializersFacade facade);
    public abstract virtual ITestAdapterLoadContext Initialize(TestRequest request);
}
public class JetBrains.ReSharper.TestRunner.Implementation.Registrations : MulticastDelegate {
    public Registrations(object object, IntPtr method);
    public virtual void Invoke(ContainerBuilder builder);
    public virtual IAsyncResult BeginInvoke(ContainerBuilder builder, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class JetBrains.ReSharper.TestRunner.Implementation.RemoteAgentEndpoint : object {
    public static string Tag { get; }
    public static string get_Tag();
}
public class JetBrains.ReSharper.TestRunner.Implementation.SingleThreadTaskScheduler : TaskScheduler {
    [ThreadStaticAttribute]
private static bool ourIsExecuting;
    private ILogger myLogger;
    private BlockingCollection`1<Task> myQueue;
    private Lazy`1<Thread> myThread;
    private CancellationToken myCt;
    public int MaximumConcurrencyLevel { get; }
    public SingleThreadTaskScheduler(CancellationToken ct);
    public virtual int get_MaximumConcurrencyLevel();
    private void RunOnCurrentThread();
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    [CompilerGeneratedAttribute]
private Thread <.ctor>b__7_0();
}
internal class JetBrains.ReSharper.TestRunner.Implementation.TestAdapterLoadContext : LoadContext {
    public TestAdapterLoadContext(string name, TestRequest request, ILifetimeScope scope, ILoadContextTracker tracker);
}
internal class JetBrains.ReSharper.TestRunner.Implementation.TestAdapterLoadContextFactoryFactory : object {
    private ILifetimeScope myScope;
    private IAssemblyResolver myAssemblyResolver;
    private ILogger myLogger;
    private TestAdapterLoader myTestAdapterLoader;
    public TestAdapterLoadContextFactoryFactory(ILifetimeScope scope, IAssemblyResolver assemblyResolver, ILogger logger);
    public sealed virtual void SetTestAdapterLoader(TestAdapterLoader testAdapterLoader);
    public sealed virtual void RegisterDynamicScalars(ReflectionSerializersFacade facade);
    public sealed virtual ITestAdapterLoadContext Initialize(TestRequest request);
}
internal class JetBrains.ReSharper.TestRunner.Implementation.TestAdapterLoadContextWrapper : TestAdapterLoadContextWrapperBase {
    public TestAdapterLoadContextWrapper(IAssemblyResolver assemblyResolver, TestAdapterInfo testAdapterInfo, TestRequest request, ILoadContext ctx);
}
internal class JetBrains.ReSharper.TestRunner.Implementation.TestAdapterLoadContextWrapperBase : object {
    protected ILoadContext myCtx;
    protected IAssemblyResolver myAssemblyResolver;
    protected TestAdapterInfo myTestAdapterInfo;
    protected ILogger myLogger;
    protected IDisposable mySubscriptions;
    public string Name { get; }
    public bool IsCollectible { get; }
    public IAssemblyResolver AssemblyResolver { get; }
    public TestAdapterLoadContextWrapperBase(IAssemblyResolver assemblyResolver, TestAdapterInfo testAdapterInfo, TestRequest request, ILoadContext ctx);
    public sealed virtual void Dispose();
    public virtual ITestDiscoverer InitializeTestDiscoverer();
    public virtual ITestExecutor InitializeTestExecutor();
    public sealed virtual string get_Name();
    public sealed virtual bool get_IsCollectible();
    public sealed virtual IAssemblyResolver get_AssemblyResolver();
    public sealed virtual object Create(Type type, T1 p1);
    public sealed virtual object Create(Type type, T1 p1, T2 p2);
    public sealed virtual object Create(Type type, T1 p1, T2 p2, T3 p3);
    public sealed virtual object Create(Type type, Object[] args);
    public sealed virtual void Unload();
}
internal class JetBrains.ReSharper.TestRunner.Implementation.TestDiscoverySink : RejectingCallContextObject {
    private IMessageBroker myServer;
    public TestDiscoverySink(IMessageBroker server);
    public sealed virtual void TestsDiscovered(RemoteTask[] tasks);
}
internal class JetBrains.ReSharper.TestRunner.Implementation.TestExecutionSink : RejectingCallContextObject {
    private IMessageBroker myServer;
    private ITestRunnerClientController myClientController;
    private ILogger myLogger;
    internal IMessageBroker MessageBroker { get; }
    public TestExecutionSink(IMessageBroker server, ITestRunnerClientController clientController);
    internal IMessageBroker get_MessageBroker();
    public sealed virtual void RunStarting();
    public sealed virtual void RunFinished();
    public virtual void TestStarting(RemoteTask task);
    public virtual void TestException(RemoteTask task, ExceptionInfo[] exceptions);
    public sealed virtual void TestFinished(RemoteTask task, TestOutcome outcome, string message, Nullable`1<TimeSpan> duration);
    public virtual void TestOutput(RemoteTask task, string text, TestOutputType outputType);
    public virtual void DynamicTestDiscovered(RemoteTask task);
    private sealed virtual override void System.IDisposable.Dispose();
}
public class JetBrains.ReSharper.TestRunner.Implementation.TestRunnerSerializersFacade : ReflectionSerializersFacade {
}
internal class JetBrains.ReSharper.TestRunner.Implementation.ThreadAffinedClientMessageBroker : LongLivedMarshalByRefObject {
    private IMessageBroker myInner;
    private TaskFactory myFactory;
    public ThreadAffinedClientMessageBroker(Lifetime lifetime, IMessageBroker inner);
    public sealed virtual Task SendMessage(IMessage message);
    public sealed virtual Task`1<TResult> SendMessage(IMessage`1<TResult> message);
    [CompilerGeneratedAttribute]
private Task <SendMessage>b__3_0(object o);
    [CompilerGeneratedAttribute]
private Task`1<TResult> <SendMessage>b__4_0(object o);
}
internal class JetBrains.ReSharper.TestRunner.Implementation.UnitTestRemoteAgent : object {
    private ILifetimeScope myScope;
    private IMessageBroker myServer;
    private IFileSystemRoot myFileSystemRoot;
    private IAssemblyResolver myAssemblyResolver;
    private ITestAdapterLoadContextFactoryFactory myLoadContextFactory;
    private ReflectionSerializersFacade mySerializersFacade;
    private CancellationTokenSource myCts;
    private ILogger myLogger;
    private TaskCompletionSource`1<int> myShutdownTcs;
    public UnitTestRemoteAgent(ILifetimeScope scope, IMessageBroker server, IFileSystemRoot fileSystemRoot, IAssemblyResolver assemblyResolver, ITestAdapterLoadContextFactoryFactory loadContextFactory, ReflectionSerializersFacade serializersFacade, ILogger logger);
    public void HandshakeAndWaitForShutdown(IApplicationOptions options);
    public sealed virtual void Execute(RemoteAgentInitializationRequest request);
    public sealed virtual void Execute(TestRunRequest request);
    private IExtendedTestExecutionSink GetExecutionSink(TestRunRequest request);
    private ITestRunnerClientController InitializeClientController(ILifetimeScope scope, ClientControllerInfo info);
    public sealed virtual void Execute(TestDiscoveryRequest request);
    public sealed virtual void Execute(RequestAbortMessage message);
    public sealed virtual void Execute(ShutdownMessage message);
}
internal class JetBrains.ReSharper.TestRunner.Isolation.ApplicationLoadContext : object {
    private ILifetimeScope myScope;
    [CompilerGeneratedAttribute]
private IAssemblyResolver <AssemblyResolver>k__BackingField;
    public string Name { get; }
    public bool IsCollectible { get; }
    public IAssemblyResolver AssemblyResolver { get; }
    public ApplicationLoadContext(ILifetimeScope scope);
    public sealed virtual string get_Name();
    public sealed virtual bool get_IsCollectible();
    [CompilerGeneratedAttribute]
public sealed virtual IAssemblyResolver get_AssemblyResolver();
    public sealed virtual void Unload();
    public sealed virtual object Create(Type type, T1 p1);
    public sealed virtual object Create(Type type, T1 p1, T2 p2);
    public sealed virtual object Create(Type type, T1 p1, T2 p2, T3 p3);
    public sealed virtual object Create(Type type, Object[] args);
}
internal interface JetBrains.ReSharper.TestRunner.Isolation.IApplicationLoadContext {
}
public interface JetBrains.ReSharper.TestRunner.Isolation.ILoadContextTracker {
    public abstract virtual void WaitForUnload();
    public abstract virtual void Track(ILoadContext ctx);
}
public class JetBrains.ReSharper.TestRunner.Isolation.LoadContext : AssemblyLoadContext {
    private ILifetimeScope myScope;
    private AssemblyLoader myPrincipalResolver;
    private AssemblyLoader myAdditionalResolver;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public bool IsCollectible { get; }
    public IAssemblyResolver AssemblyResolver { get; }
    public LoadContext(string name, bool attachResolverToDefaultCtx, ILifetimeScope scope, ILoadContextTracker tracker, bool isCollectible);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual bool get_IsCollectible();
    public sealed virtual void Unload();
    public sealed virtual IAssemblyResolver get_AssemblyResolver();
    public sealed virtual object Create(Type type, T1 p1);
    public sealed virtual object Create(Type type, T1 p1, T2 p2);
    public sealed virtual object Create(Type type, T1 p1, T2 p2, T3 p3);
    public sealed virtual object Create(Type type, Object[] args);
    protected virtual Assembly Load(AssemblyName assemblyName);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.TestRunner.Isolation.LoadContextTracker : object {
    private ILogger myLogger;
    private string myCtxName;
    private WeakReference myWeakReference;
    public LoadContextTracker(ILogger logger);
    public sealed virtual void Track(ILoadContext ctx);
    public sealed virtual void WaitForUnload();
}
public static class JetBrains.ReSharper.TestRunner.Isolation.ShadowCopyBehavior : object {
    public static IDisposable Apply(TestContainer container, IFileSystem fileSystem);
}
public static class JetBrains.ReSharper.TestRunner.Logging.Log : object {
    private static string Layout;
    private static LoggerFactory ourFactory;
    private static TestRunnerServerSink ourServerSink;
    [CompilerGeneratedAttribute]
private static bool <HasErrors>k__BackingField;
    public static bool HasErrors { get; private set; }
    private static Log();
    [CompilerGeneratedAttribute]
public static bool get_HasErrors();
    [CompilerGeneratedAttribute]
private static void set_HasErrors(bool value);
    internal static void Setup(IApplicationOptions options);
    internal static void InstallTestRunnerServerLoggingSink(Lifetime lifetime, IMessageBroker server, IApplicationOptions options);
    public static void Flush();
    [CompilerGeneratedAttribute]
internal static bool <Setup>g__SpamFromLifetimes|7_0(LogEvent evt);
    [CompilerGeneratedAttribute]
internal static bool <Setup>g__EverythingWhenServerSinkIsInstalled|7_1(LogEvent evt);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.TestRunner.Logging.LoggingExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<LogEventLevel> ToLevel(LoggingLevel loggingLevel);
    [ExtensionAttribute]
public static Nullable`1<LogEventLevel> ToLevel(LoggingLevel loggingLevel);
    [ExtensionAttribute]
public static LoggingLevel ToLoggingLevel(LogEventLevel level);
}
internal class JetBrains.ReSharper.TestRunner.Logging.LoggingModule : object {
    private static HashSet`1<Guid> ourTouchedRegistrations;
    private static LoggingModule();
    public static T Attach(T scope);
    private static void OnChildLifetimeScopeBeginning(object sender, LifetimeScopeBeginningEventArgs e);
    private static void AttachToComponentRegistrations(IComponentRegistry registry);
    private static void OnComponentPreparing(object sender, PreparingEventArgs e);
}
public static class JetBrains.ReSharper.TestRunner.ProcessInfo : object {
    private static Lazy`1<CachedData> ourData;
    public static string Name { get; }
    public static int Id { get; }
    private static ProcessInfo();
    public static string get_Name();
    public static int get_Id();
    private static CachedData GetData();
}
public enum JetBrains.ReSharper.TestRunner.RemoteAgentMode : Enum {
    public int value__;
    public static RemoteAgentMode Local;
    public static RemoteAgentMode Remote;
}
public static class JetBrains.ReSharper.TestRunner.Utils.Call : object {
    public static void Generic(Expression`1<Action> expression, Type[] typeArgs);
    public static T Generic(Expression`1<Func`1<T>> expression, Type[] typeArgs);
    private static object Generic(MethodCallExpression methodCall, Type[] typeArgs);
    private static object ExtractParameter(Expression parameter);
}
public static class JetBrains.ReSharper.TestRunner.Utils.DelegateUtils : object {
    public static T CreateCompatibleDelegate(object firstArgument, MethodInfo method);
}
internal class JetBrains.ReSharper.TestRunner.Utils.MethodInvoker : object {
    private MethodInfo myMethod;
    private Object[] myMethodArgs;
    private int myCurrentIdx;
    public MethodInvoker(Expression expr);
    public object InvokeOn(object instance);
    private void Visit(Expression expr);
    private void VisitLambda(LambdaExpression node);
    private void VisitMethodCall(MethodCallExpression node);
    private void VisitMember(MemberExpression node);
    private void VisitConstant(ConstantExpression node);
    [CompilerGeneratedAttribute]
internal static object <VisitMember>g__GetValue|8_0(Expression expr, <>c__DisplayClass8_0& );
}
internal static class JetBrains.ReSharper.TestRunner.Utils.ProcessUtil : object {
    public static int GetCurrentProcessId();
    public static Nullable`1<int> TryGetParentProcessId();
}
public static class JetBrains.Serialization.NativeMemoryPool : object {
    public static int AllocSize;
    public static int MaxAllocSize;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("1")]
private static string LogCategory;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
[ThreadStaticAttribute]
private static ThreadMemoryHolder ourThreadMemory;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadMemoryHolder[] ourBlocks;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("1")]
private static object ourLock;
    private static NativeMemoryPool();
    public static int SampleUsed();
    public static int SampleCount();
    public static Cookie Reserve();
    public static bool TryFreeMemory();
    internal static Cookie ReserveMiss();
    private static IntPtr AllocateMemory(int allocSize);
    private static void ErrorOomOldMono();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <ReserveMiss>g__SearchAndReserve|10_0(ThreadMemoryHolder& holder);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <ReserveMiss>g__AllocateNew|10_1(ThreadMemoryHolder& holder);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[PublicAPIAttribute]
public class JetBrains.Serialization.UnsafeReader : object {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
private Byte* myPtr;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
private Byte* myInitialPtr;
    private int myMaxlen;
    public static ReadDelegate`1<bool> BoolDelegate;
    public static ReadDelegate`1<bool> BooleanDelegate;
    public static ReadDelegate`1<byte> ByteDelegate;
    public static ReadDelegate`1<Guid> GuidDelegate;
    public static ReadDelegate`1<char> CharDelegate;
    public static ReadDelegate`1<decimal> DecimalDelegate;
    public static ReadDelegate`1<double> DoubleDelegate;
    public static ReadDelegate`1<float> FloatDelegate;
    public static ReadDelegate`1<short> Int16Delegate;
    public static ReadDelegate`1<short> ShortDelegate;
    public static ReadDelegate`1<int> Int32Delegate;
    public static ReadDelegate`1<int> IntDelegate;
    public static ReadDelegate`1<long> Int64Delegate;
    public static ReadDelegate`1<long> LongDelegate;
    public static ReadDelegate`1<ushort> UInt16Delegate;
    public static ReadDelegate`1<UInt32> UInt32Delegate;
    public static ReadDelegate`1<ulong> UInt64Delegate;
    public static ReadDelegate`1<DateTime> DateTimeDelegate;
    public static ReadDelegate`1<Uri> UriDelegate;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadDelegate`1<string> StringDelegate;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadDelegate`1<Byte[]> ByteArrayDelegate;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadDelegate`1<Boolean[]> BoolArrayDelegate;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadDelegate`1<Int32[]> IntArrayDelegate;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadDelegate`1<String[]> StringArrayDelegate;
    public int Position { get; }
    private static UnsafeReader();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("0")]
public static UnsafeReader CreateReader(Byte* ptr, int len);
    public static void With(Byte[] data, Action`1<UnsafeReader> action);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("0")]
public UnsafeReader Reset(Byte* ptr, int len);
    public int get_Position();
    public void Skip(int bytes);
    private void AssertLength(int size);
    private void ThrowOutOfRange(int size, int alreadyRead);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("0")]
public Byte* ReadRaw(int count);
    public bool ReadBoolean();
    public byte ReadByte();
    public sbyte ReadSByte();
    public Guid ReadGuid();
    public char ReadChar();
    public decimal ReadDecimal();
    public double ReadDouble();
    public float ReadFloat();
    public short ReadInt16();
    public int ReadInt32();
    public int Read7BitEncodedInt32();
    public int ReadOftenSmallPositiveInt32();
    public long ReadInt64();
    public ushort ReadUInt16();
    public UInt32 ReadUInt32();
    public ulong ReadUInt64();
    public DateTime ReadDateTime();
    public TimeSpan ReadTimeSpan();
    public Uri ReadUri();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public string ReadString();
    public string ReadStringInterned(IRawStringIntern intern);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public T[] ReadArray(ReadDelegate`1<T> readDelegate);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public Int32[] ReadIntArray();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public Byte[] ReadByteArray();
    public TCollection ReadCollection(ReadDelegate`1<T> readDelegate, Func`2<int, TCollection> constructor);
    public TDictionary ReadDictionary(ReadDelegate`1<TKey> readKeyDelegate, ReadDelegate`1<TValue> readValueDelegate, Func`2<int, TDictionary> constructor);
    public bool ReadNullness();
    public bool ReadBool();
    public short ReadShort();
    public int ReadInt();
    public long ReadLong();
    public byte ReadUByte();
    public ushort ReadUShort();
    public UInt32 ReadUInt();
    public ulong ReadULong();
    public static ushort ReadUInt16FromBytes(Byte[] bytes);
    public static int ReadInt32FromBytes(Byte[] bytes, int offset);
    public static long ReadInt64FromBytes(Byte[] bytes, int offset);
    public static ulong ReadUInt64FromBytes(Byte[] bytes);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[PublicAPIAttribute]
public class JetBrains.Serialization.UnsafeWriter : object {
    private int myInitialAllocSize;
    private static string LogCategory;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
[ThreadStaticAttribute]
private static UnsafeWriter ourWriter;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
private Byte* myStartPtr;
    private int myCurrentAllocSize;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
private Byte* myPtr;
    private int myCount;
    internal int ReleaseResources;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
private ThreadMemoryHolder myMemory;
    private int myRecursionLevel;
    private static bool ourOldMonoFlag;
    public static WriteDelegate`1<bool> BooleanDelegate;
    public static WriteDelegate`1<byte> ByteDelegate;
    public static WriteDelegate`1<Guid> GuidDelegate;
    public static WriteDelegate`1<char> CharDelegate;
    public static WriteDelegate`1<decimal> DecimalDelegate;
    public static WriteDelegate`1<double> DoubleDelegate;
    public static WriteDelegate`1<float> FloatDelegate;
    public static WriteDelegate`1<short> Int16Delegate;
    public static WriteDelegate`1<int> Int32Delegate;
    public static WriteDelegate`1<long> Int64Delegate;
    public static WriteDelegate`1<ushort> UInt16Delegate;
    public static WriteDelegate`1<UInt32> UInt32Delegate;
    public static WriteDelegate`1<ulong> UInt64Delegate;
    public static WriteDelegate`1<DateTime> DateTimeDelegate;
    public static WriteDelegate`1<Uri> UriDelegate;
    public static WriteDelegate`1<string> StringDelegate;
    public static WriteDelegate`1<Byte[]> ByteArrayDelegate;
    public static WriteDelegate`1<Int32[]> IntArrayDelegate;
    public static WriteDelegate`1<String[]> StringArrayDelegate;
    [ObsoleteAttribute("Don't use")]
public static bool AllowUnsafeWriterCaching { get; public set; }
    private int Count { get; }
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
private Byte* Data { get; }
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public Byte* Ptr { get; }
    private static UnsafeWriter();
    public static bool get_AllowUnsafeWriterCaching();
    public static void set_AllowUnsafeWriterCaching(bool value);
    public static Cookie NewThreadLocalWriter();
    [ObsoleteAttribute("Use NewThreadLocalWriter()")]
public static Cookie NewThreadLocalWriterNoCaching();
    [ObsoleteAttribute("Use NewThreadLocalWriter()")]
private static Cookie NewThreadLocalWriterImpl(bool allowCaching);
    private void Initialize();
    private void Deinitialize(int start);
    protected virtual override void Finalize();
    private void Reset(int start);
    private int get_Count();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("0")]
private Byte* get_Data();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("0")]
public Byte* get_Ptr();
    private void Prepare(int nbytes);
    private void Realloc(int newCount);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(bool value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(byte value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(Guid value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(char value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(decimal value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(double value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(float value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(short value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(int value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(long value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(ushort value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(UInt32 value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(ulong value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(DateTime value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(TimeSpan value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(Uri value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[CodeTemplateAttribute("$member$($arg$)")]
public void Write(string value);
    public void WriteBoolean(bool value);
    public void WriteByte(byte value);
    public void WriteSByte(sbyte value);
    public void WriteGuid(Guid value);
    public void WriteChar(char value);
    public void WriteDecimal(decimal value);
    public void WriteDouble(double value);
    public void WriteFloat(float value);
    public void WriteInt16(short value);
    public void WriteInt32(int value);
    public void Write7BitEncodedInt32(int value);
    public void WriteOftenSmallPositiveInt32(int value);
    public static void WriteInt32ToBytes(int value, Byte[] data, int offset);
    public void WriteInt64(long value);
    public void WriteUint16(ushort value);
    public void WriteUInt32(UInt32 value);
    public void WriteUint64(ulong value);
    public void WriteDateTime(DateTime value);
    public void WriteTimeSpan(TimeSpan value);
    public void WriteUri(Uri value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void WriteString(string value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void WriteStringContent(string value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void WriteStringContent(string value, int offset, int count);
    private static void WriteStringContentInternal(UnsafeWriter wrt, string value, int offset, int count);
    private static void WriteStringContentInternalAfterMono5(UnsafeWriter wrt, string value, int offset, int count);
    private static void WriteStringContentInternalBeforeMono5(UnsafeWriter wrt, string value, int offset, int count);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("0")]
public void Write(Byte* ptr, int size);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[CodeTemplateAttribute("$member$($arg$)")]
public void Write(Int32[] value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[CodeTemplateAttribute("$member$($arg$)")]
public void Write(Byte[] value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void WriteArray(Int32[] value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public void WriteByteArray(Byte[] value);
    public void WriteRaw(Byte[] value);
    public void WriteRaw(Byte[] value, int start, int length);
    [MustUseReturnValueAttribute]
public Bookmark MakeBookmark();
    public Bookmark Alloc(int length);
    [CodeTemplateAttribute("$member$($args$)")]
public void Write(WriteDelegate`1<T> writeDelegate, TCollection value);
    public void WriteCollection(WriteDelegate`1<T> writeDelegate, TCollection value);
    public void Write(WriteDelegate`1<TK> writeKeyDelegate, WriteDelegate`1<TV> writeValueDelegate, TDictionary value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("0")]
[ContractAnnotationAttribute("null=>false")]
public bool WriteNullness(Nullable`1<T> value);
    [ContractAnnotationAttribute("null=>false")]
public bool WriteNullness(T value);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Threading.Actor`1 : object {
    [PublicAPIAttribute]
public string Id;
    private Func`2<T, Task> myProcessor;
    private AsyncChannel`1<T> myChannel;
    private ILog myLog;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncLocal`1<Unit> myInsideProcessingFlow;
    private long myTotalMessagesProcessed;
    [PublicAPIAttribute]
public ISendChannel`1<T> Channel { get; }
    [PublicAPIAttribute]
public bool IsEmpty { get; }
    [PublicAPIAttribute]
public bool IsNotEmpty { get; }
    public bool IsInsideProcessing { get; }
    public Actor`1(string id, Lifetime lifetime, Action`1<T> processor, TaskScheduler scheduler, int maxQueueSize);
    public Actor`1(string id, Lifetime lifetime, Func`2<T, Task> processor, TaskScheduler scheduler, int maxQueueSize);
    public ISendChannel`1<T> get_Channel();
    public bool get_IsEmpty();
    public bool get_IsNotEmpty();
    public bool get_IsInsideProcessing();
    [AsyncStateMachineAttribute("JetBrains.Threading.Actor`1/<Process>d__16")]
[HandleProcessCorruptedStateExceptionsAttribute]
private Task Process();
    public sealed virtual void SendBlocking(T msg);
    public sealed virtual Task SendAsync(T msg);
    [AsyncStateMachineAttribute("JetBrains.Threading.Actor`1/<SendOrExecuteInline>d__19")]
public Task SendOrExecuteInline(T msg);
    public void WaitForEmpty();
    [CompilerGeneratedAttribute]
private bool <WaitForEmpty>b__20_0();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Threading.AsyncChannel`1 : object {
    private Lifetime myLifetime;
    private object myLock;
    private Queue`1<TaskCompletionSource`1<Unit>> mySenders;
    private Queue`1<T> myMessages;
    private Queue`1<TaskCompletionSource`1<T>> myReceivers;
    private int myTotalMessagesSent;
    [PublicAPIAttribute]
public int SendBufferSize;
    [PublicAPIAttribute]
public long TotalMessagesSent { get; }
    [PublicAPIAttribute]
public bool IsEmpty { get; }
    public AsyncChannel`1(Lifetime lifetime, int sendBufferSize);
    public long get_TotalMessagesSent();
    public bool get_IsEmpty();
    private void SetCanceledIsolated(TaskCompletionSource`1<TResult> tcs);
    [PublicAPIAttribute]
public sealed virtual void SendBlocking(T msg);
    [PublicAPIAttribute]
public sealed virtual T ReceiveBlocking();
    private void AssertState();
    public virtual string ToString();
    [PublicAPIAttribute]
public sealed virtual Task SendAsync(T msg);
    [PublicAPIAttribute]
public sealed virtual Task`1<T> ReceiveAsync();
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_0();
}
public class JetBrains.Threading.ByteBufferAsyncProcessor : object {
    private static string LogCategory;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    private Processor myProcessor;
    private object myLock;
    [CompilerGeneratedAttribute]
private long <AcknowledgedSeqN>k__BackingField;
    private static int DefaultChunkSize;
    private ILog myLog;
    [PublicAPIAttribute]
public int ChunkSize;
    private static int DefaultShrinkIntervalMs;
    private int myLastShrinkOrGrowTimeMs;
    [PublicAPIAttribute]
public int ShrinkIntervalMs;
    private bool myAllDataProcessed;
    private HashSet`1<string> myPauseReasons;
    [CompilerGeneratedAttribute]
private StateKind <State>k__BackingField;
    private Chunk myChunkToFill;
    private bool myProcessing;
    private Chunk modreq(System.Runtime.CompilerServices.IsVolatile) myChunkToProcess;
    private Thread myAsyncProcessingThread;
    [PublicAPIAttribute]
public string Id { get; }
    public long AcknowledgedSeqN { get; private set; }
    public bool AllDataProcessed { get; }
    public StateKind State { get; private set; }
    public int ChunkCount { get; }
    public ByteBufferAsyncProcessor(string id, Processor processor);
    public ByteBufferAsyncProcessor(string id, int chunkSize, Processor processor);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public long get_AcknowledgedSeqN();
    [CompilerGeneratedAttribute]
private void set_AcknowledgedSeqN(long value);
    public bool get_AllDataProcessed();
    [CompilerGeneratedAttribute]
public StateKind get_State();
    [CompilerGeneratedAttribute]
private void set_State(StateKind value);
    public int get_ChunkCount();
    private void CleanupInternal();
    private bool TerminateInternal(int timeoutMs, StateKind state, string action);
    private void ThreadProcCatchAbort();
    public void Acknowledge(long seqNumber);
    public void ReprocessUnacknowledged();
    private void ThreadProc();
    public void Start();
    private void Reset(int chunkSize);
    public void Clear();
    public bool Pause(string reason);
    private void WaitProcessingFinished();
    public bool Resume(string reason);
    public bool Stop(int timeoutMs);
    public bool Terminate(int timeoutMs);
    [PublicAPIAttribute]
public void Put(Byte[] data);
    [PublicAPIAttribute]
public void Put(Cookie data);
    [HandleProcessCorruptedStateExceptionsAttribute]
[PublicAPIAttribute]
public void Put(Byte* start, int count);
    private void GrowConditionally();
    private void ShrinkConditionally(Chunk upTo);
    [CompilerGeneratedAttribute]
private void <TerminateInternal>b__36_0();
}
[ExtensionAttribute]
public static class JetBrains.Threading.ExceptionEx : object {
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[ExtensionAttribute]
[PublicAPIAttribute]
public static bool IsOperationCanceled(Exception exception);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public interface JetBrains.Threading.IReceiveChannel`1 {
    public abstract virtual T ReceiveBlocking();
    public abstract virtual Task`1<T> ReceiveAsync();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
public interface JetBrains.Threading.ISendChannel`1 {
    public abstract virtual void SendBlocking(T msg);
    public abstract virtual Task SendAsync(T msg);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Threading.ProactiveLazy`1 : object {
    private Task`1<T> myTask;
    public ProactiveLazy`1(Lifetime lifetime, Func`1<T> factory, TaskScheduler taskScheduler);
    [PublicAPIAttribute]
public T GetOrWait();
    [PublicAPIAttribute]
public T GetOrWait(Lifetime lifetime);
    [PublicAPIAttribute]
public TaskAwaiter`1<T> GetAwaiter();
    [PublicAPIAttribute]
public Task`1<T> AsTask();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Threading.ScopedAsyncLocal`1 : ValueType {
    private AsyncLocal`1<T> myAsyncLocal;
    private T myOldValue;
    public ScopedAsyncLocal`1(AsyncLocal`1<T> asyncLocal, T value);
    public sealed virtual void Dispose();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public static class JetBrains.Threading.SpinWaitEx : object {
    [PublicAPIAttribute]
public static void SpinUntil(Func`1<bool> condition);
    [PublicAPIAttribute]
public static bool SpinUntil(Lifetime lifetime, Func`1<bool> condition);
    [PublicAPIAttribute]
public static bool SpinUntil(TimeSpan timeout, Func`1<bool> condition);
    [PublicAPIAttribute]
public static bool SpinUntil(Lifetime lifetime, TimeSpan timeout, Func`1<bool> condition);
    [PublicAPIAttribute]
public static bool SpinUntil(Lifetime lifetime, long timeoutMs, Func`1<bool> condition);
    [AsyncStateMachineAttribute("JetBrains.Threading.SpinWaitEx/<SpinUntilAsync>d__5")]
[PublicAPIAttribute]
public static Task`1<bool> SpinUntilAsync(Lifetime lifetime, long timeoutMs, int delayBetweenChecksMs, Func`1<bool> condition);
}
public class JetBrains.Threading.SpinWaitLock : ValueType {
    private int _ownerThreadId;
    private int _lockCount;
    private static int _processorCount;
    private static int _sleepCount;
    public static int ApprovedProcessorCount { get; }
    private static SpinWaitLock();
    public static int get_ApprovedProcessorCount();
    public bool TryEnter();
    public void Enter();
    public void Exit();
    private bool TryEnter(int currentThreadId);
    private static void CalcApprovedProcessorCount();
    private static void Sleep();
}
[ExtensionAttribute]
[UsedImplicitlyAttribute]
public static class JetBrains.Threading.SpinWaitLockExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("It is not possible to use the using() pattern with the non-allocating SpinWaitLock because its lock status is cloned on copying. Either call paired methods, or use SpinWaitLockRef and allocate a heap object.")]
[UsedImplicitlyAttribute]
public static SpinWaitLockCookie Acquire(SpinWaitLock spinWaitLock);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Threading.TaskEx : object {
    private static Action`1<Task> ourNoAwaitContinuation;
    private static TaskEx();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[ExtensionAttribute]
[PublicAPIAttribute]
public static void NoAwait(Task task);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static IReadonlyProperty`1<Result`1<T>> ToResultProperty(Task`1<T> task);
    [ExtensionAttribute]
public static T GetOrWait(Task`1<T> task, Lifetime lifetime);
    [ExtensionAttribute]
public static bool IsOperationCanceled(Task task);
    [AsyncStateMachineAttribute("JetBrains.Threading.TaskEx/<Select>d__5`2")]
[ExtensionAttribute]
[PublicAPIAttribute]
public static Task`1<TDst> Select(Task`1<TSrc> task, Func`2<TSrc, TDst> selector);
}
[ExtensionAttribute]
public static class JetBrains.Threading.ThreadEx : object {
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToThreadString(Thread thread);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public static class JetBrains.Util.BitHacks : object {
    private static UInt32 DeBruijnSequence32;
    private static ulong DeBruijnSequence64;
    private static Byte[] ourDeBruijnBitTable32;
    private static Byte[] ourDeBruijnBitTable64;
    private static BitHacks();
    public static int Log2Floor(int x);
    public static int Log2Floor(long x);
    public static int Log2Ceil(int x);
    public static int Log2Ceil(long x);
    public static int NumberOfBitSet(int x);
    private static int ReverseBitScan(UInt32 value);
    private static int ReverseBitScan(ulong value);
}
public static class JetBrains.Util.EmptyAction : object {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("1")]
public static Action Instance;
    private static EmptyAction();
}
public static class JetBrains.Util.EmptyAction`1 : object {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("1")]
public static Action`1<T> Instance;
    private static EmptyAction`1();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public static class JetBrains.Util.EmptyAction`2 : object {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("1")]
public static Action`2<T1, T2> Instance;
    private static EmptyAction`2();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public static class JetBrains.Util.EmptyAction`3 : object {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("1")]
public static Action`3<T1, T2, T3> Instance;
    private static EmptyAction`3();
}
public static class JetBrains.Util.EmptyArray : object {
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[PureAttribute]
public static T[] GetInstance();
}
[DebuggerDisplayAttribute("Length = 0")]
public static class JetBrains.Util.EmptyArray`1 : object {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("1")]
public static T[] Instance;
    private static EmptyArray`1();
}
public static class JetBrains.Util.GenericUtil`1 : object {
    public static bool IsValueWriteAtomic;
    private static GenericUtil`1();
    private static bool IsValueWriteAtomicCalculate();
}
public class JetBrains.Util.Internal.Memory : object {
    public static void CopyMemory(Byte* src, Byte* dest, int len);
    public static void Barrier();
    public static T VolatileRead(T& location);
    public static void VolatileWrite(T& location, T value);
    public static int VolatileRead(Int32& location);
    public static void VolatileWrite(Int32& location, int value);
    public static bool VolatileRead(Boolean& location);
    public static void VolatileWrite(Boolean& location, bool value);
}
[<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
public class JetBrains.Util.LocalStopwatch : ValueType {
    private static long TicksPerMillisecond;
    private static long TicksPerSecond;
    private static long ourFrequency;
    private static double ourTickFrequency;
    private long myStartTimeStamp;
    public TimeSpan Elapsed { get; }
    public long ElapsedMilliseconds { get; }
    public long ElapsedTicks { get; }
    private static LocalStopwatch();
    private LocalStopwatch(long startTimeStamp);
    public static LocalStopwatch StartNew();
    public TimeSpan get_Elapsed();
    public long get_ElapsedMilliseconds();
    public long get_ElapsedTicks();
    private long GetElapsedDateTimeTicks();
    private void AssertTimeStamp();
}
public static class JetBrains.Util.MethodImplAdvancedOptions : object {
    public static MethodImplOptions AggressiveInlining;
}
[ExtensionAttribute]
public static class JetBrains.Util.NullableEx : object {
    [ExtensionAttribute]
public static Nullable`1<T> ToNullable(T t);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Util.ReflectionUtil : object {
    public static SetValueDelegate GetSetter(MemberInfo mi);
    public static SetValueDelegate TryGetSetter(MemberInfo mi);
    public static Func`2<object, object> GetGetter(MemberInfo mi);
    public static Type GetReturnType(MemberInfo mi);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public static T Call(MethodInfo method, object thisArg, Object[] parameters);
    public static object InvokeGenericThis(object self, string methodName, Type argument, Object[] parameters);
    public static object InvokeStaticGeneric(Type type, string methodName, Type argument, Object[] parameters);
    public static object InvokeStaticGeneric2(Type type, string methodName, Type argument1, Type argument2, Object[] parameters);
    public static object TryGetNonStaticField(object ownerObject, string memberName);
    public static object TryGetNonStaticProperty(object ownerObject, string memberName);
    [IteratorStateMachineAttribute("JetBrains.Util.ReflectionUtil/<EnumerateEnumValues>d__11`1")]
public static IEnumerable`1<T> EnumerateEnumValues();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[ExtensionAttribute]
public static T GetPropertyValueSafe(object o, string propertyName, T defaultValue);
    public static T SetStaticInstanceProperty(Lifetime lifetime, Type type);
    [CompilerGeneratedAttribute]
internal static SetValueDelegate <TryGetSetter>g__GetFieldSetter|2_0(FieldInfo backingField);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[<38a4eff7-7a49-47b5-aea6-62ba43680c54>IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute]
public class JetBrains.Util.RentedValueCookie`1 : ValueType {
    private SingleThreadObjectPool`1<T> myPool;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; }
    public RentedValueCookie`1(SingleThreadObjectPool`1<T> pool, T value);
    [CompilerGeneratedAttribute]
public T get_Value();
    public void Dispose();
}
public static class JetBrains.Util.RuntimeInfo : object {
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
public static Version CurrentMonoVersion;
    public static bool IsRunningOnMono;
    public static bool IsRunningUnderWindows;
    public static bool IsRunningOnCore;
    public static bool IsUnalignedAccessAllowed;
    private static RuntimeInfo();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Util.SingleThreadListPool`1 : SingleThreadObjectPool`1<List`1<T>> {
    public SingleThreadListPool`1(int maxCapacity);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Util.SingleThreadObjectPool`1 : object {
    private int myMaxCapacity;
    private Func`1<T> myFactory;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<T> myClear;
    private Stack`1<T> myPool;
    private Thread myThread;
    public SingleThreadObjectPool`1(Func`1<T> factory, Action`1<T> clear);
    public SingleThreadObjectPool`1(int maxCapacity, Func`1<T> factory, Action`1<T> clear);
    public T Rent();
    public RentedValueCookie`1<T> RentCookie();
    public void Return(T value);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Util.Util.BitSlice : object {
    [PublicAPIAttribute]
public int LoBit;
    [PublicAPIAttribute]
public int BitCount;
    [PublicAPIAttribute]
public int Mask;
    [PublicAPIAttribute]
public int HiBit { get; }
    public BitSlice(int loBit, int bitCount);
    public int get_HiBit();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[AssertionMethodAttribute]
protected void AssertSliceFitsHostType();
    [AssertionMethodAttribute]
private void AssertValueFitsSlice(int value);
    protected int GetRaw(int host);
    protected int UpdatedRaw(int host, int value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
private static int NextSliceLoBit(BitSlice slice);
    public static IntBitSlice Int(int bitCount, BitSlice previousSlice);
    public static BoolBitSlice Bool(BitSlice previousSlice);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("0")]
public static Enum32BitSlice`1<T> Enum(BitSlice previousSlice);
    public virtual string ToString();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class JetBrains.Util.Util.BitSlice`1 : BitSlice {
    public T Item { get; }
    protected BitSlice`1(int loBit, int bitCount);
    public abstract virtual T get_Item(int host);
    public abstract virtual int Updated(int host, T value);
    public void InterlockedUpdate(Int32& host, T value);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Util.BoolBitSlice : BitSlice`1<bool> {
    public bool Item { get; }
    public BoolBitSlice(int loBit, int bitCount);
    public virtual bool get_Item(int host);
    public virtual int Updated(int host, bool value);
}
public static class JetBrains.Util.Util.Cast32BitEnum`1 : object {
    private static Cast32BitEnum`1();
    [PublicAPIAttribute]
public static T FromInt(int source);
    [PublicAPIAttribute]
public static int ToInt(T source);
    [PublicAPIAttribute]
public static T FromUInt(UInt32 source);
    [PublicAPIAttribute]
public static UInt32 ToUInt(T source);
}
public static class JetBrains.Util.Util.Cast64BitEnum`1 : object {
    private static Cast64BitEnum`1();
    [PublicAPIAttribute]
public static T FromLong(long source);
    [PublicAPIAttribute]
public static long ToLong(T source);
    [PublicAPIAttribute]
public static T FromULong(ulong source);
    [PublicAPIAttribute]
public static ulong ToULong(T source);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public static class JetBrains.Util.Util.CastTo`1 : object {
    [PublicAPIAttribute]
public static TTo From(TFrom s);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Util.Enum32BitSlice`1 : BitSlice`1<T> {
    public T Item { get; }
    public Enum32BitSlice`1(int loBit);
    private static int CalculateBitCount();
    public virtual T get_Item(int host);
    public virtual int Updated(int host, T value);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Util.IntBitSlice : BitSlice`1<int> {
    public int Item { get; }
    public IntBitSlice(int loBit, int bitCount);
    public virtual int get_Item(int host);
    public virtual int Updated(int host, int value);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public static class JetBrains.Util.Util.Statics : object {
    private static Dictionary`2<Type, object> ourPerTypeStatics;
    private static Statics();
    public static StaticsForType`1<T> For();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
public class JetBrains.Util.Util.StaticsForType`1 : object {
    private List`1<T> myList;
    [<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Action Changed;
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void add_Changed(Action value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void remove_Changed(Action value);
    private void FireChanged();
    public void ForEachValue(Action action);
    public void AddLast(T value);
    public void AddFirst(T value);
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public T PeekFirst();
    [<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("2")]
public T PeekLast();
    public void ReplaceFirst(T value);
    public bool RemoveLastReferenceEqual(T value, bool failIfNotLast);
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Util.Util.Types : object {
    private static Dictionary`2<Type, string> ourPrimitives;
    private static Types();
    [ExtensionAttribute]
[ContractAnnotationAttribute("thisType:null=>null;=>notnull")]
public static string ToString(Type thisType, bool withNamespaces, bool withGenericArguments);
    [ExtensionAttribute]
public static TypeInfo OptionalTypeInfo(Type thisType);
}
[CompilerGeneratedAttribute]
[<0abd5fd1-b98f-46d0-a587-6ff50f776e07>EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.<0abd5fd1-b98f-46d0-a587-6ff50f776e07>EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[<0c8f9499-07fc-4e51-9581-dbc8ddaed996>EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.<0c8f9499-07fc-4e51-9581-dbc8ddaed996>EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[<2fc6a22d-6ff4-4a8d-92ab-b13864770451>EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.<2fc6a22d-6ff4-4a8d-92ab-b13864770451>EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[<464b1da7-2850-4f6e-b645-1ecc5491e1de>EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.<464b1da7-2850-4f6e-b645-1ecc5491e1de>EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[<65dae668-034e-42f6-9c81-6d0733d90d8f>EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.<65dae668-034e-42f6-9c81-6d0733d90d8f>EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[<7d269b2f-849d-40f4-86fc-5805e8f0b1b5>EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.<7d269b2f-849d-40f4-86fc-5805e8f0b1b5>EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class RailwaySharp.ErrorHandling.Bad`2 : Result`2<TSuccess, TMessage> {
    private IEnumerable`1<TMessage> _messages;
    public IEnumerable`1<TMessage> Messages { get; }
    public Bad`2(IEnumerable`1<TMessage> messages);
    public IEnumerable`1<TMessage> get_Messages();
}
internal class RailwaySharp.ErrorHandling.Ok`2 : Result`2<TSuccess, TMessage> {
    private Tuple`2<TSuccess, IEnumerable`1<TMessage>> _value;
    public TSuccess Success { get; }
    public IEnumerable`1<TMessage> Messages { get; }
    public Ok`2(TSuccess success, IEnumerable`1<TMessage> messages);
    public TSuccess get_Success();
    public IEnumerable`1<TMessage> get_Messages();
}
internal static class RailwaySharp.ErrorHandling.Result : object {
    public static Result`2<TSuccess, TMessage> FailWith(IEnumerable`1<TMessage> messages);
    public static Result`2<TSuccess, TMessage> FailWith(TMessage message);
    public static Result`2<TSuccess, TMessage> Succeed(TSuccess value);
    public static Result`2<TSuccess, TMessage> Succeed(TSuccess value, TMessage message);
    public static Result`2<TSuccess, TMessage> Succeed(TSuccess value, IEnumerable`1<TMessage> messages);
    public static Result`2<TSuccess, Exception> Try(Func`1<TSuccess> func);
}
internal abstract class RailwaySharp.ErrorHandling.Result`2 : object {
    private ResultType _tag;
    public ResultType Tag { get; }
    protected Result`2(ResultType tag);
    public ResultType get_Tag();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class RailwaySharp.ErrorHandling.ResultExtensions : object {
    [ExtensionAttribute]
public static void Match(Result`2<TSuccess, TMessage> result, Action`2<TSuccess, IEnumerable`1<TMessage>> ifSuccess, Action`1<IEnumerable`1<TMessage>> ifFailure);
    [ExtensionAttribute]
public static TResult Either(Result`2<TSuccess, TMessage> result, Func`3<TSuccess, IEnumerable`1<TMessage>, TResult> ifSuccess, Func`2<IEnumerable`1<TMessage>, TResult> ifFailure);
    [ExtensionAttribute]
public static Result`2<TResult, TMessage> Map(Result`2<TSuccess, TMessage> result, Func`2<TSuccess, TResult> func);
    [ExtensionAttribute]
public static Result`2<IEnumerable`1<TSuccess>, TMessage> Collect(IEnumerable`1<Result`2<TSuccess, TMessage>> values);
    [ExtensionAttribute]
public static Result`2<IEnumerable`1<TSuccess>, TMessage> Flatten(Result`2<IEnumerable`1<Result`2<TSuccess, TMessage>>, TMessage> result);
    [ExtensionAttribute]
public static Result`2<TResult, TMessage> SelectMany(Result`2<TSuccess, TMessage> result, Func`2<TSuccess, Result`2<TResult, TMessage>> func);
    [ExtensionAttribute]
public static Result`2<TResult, TMessage> SelectMany(Result`2<TSuccess, TMessage> result, Func`2<TSuccess, Result`2<TValue, TMessage>> func, Func`3<TSuccess, TValue, TResult> mapperFunc);
    [ExtensionAttribute]
public static Result`2<TResult, TMessage> Select(Result`2<TSuccess, TMessage> result, Func`2<TSuccess, TResult> func);
    [ExtensionAttribute]
public static IEnumerable`1<TMessage> FailedWith(Result`2<TSuccess, TMessage> result);
    [ExtensionAttribute]
public static TSuccess SucceededWith(Result`2<TSuccess, TMessage> result);
    [ExtensionAttribute]
public static IEnumerable`1<TMessage> SuccessMessages(Result`2<TSuccess, TMessage> result);
    [ExtensionAttribute]
public static Maybe`1<TSuccess> ToMaybe(Result`2<TSuccess, TMessage> result);
}
internal enum RailwaySharp.ErrorHandling.ResultType : Enum {
    public int value__;
    public static ResultType Ok;
    public static ResultType Bad;
}
internal static class RailwaySharp.ErrorHandling.Trial : object {
    public static Result`2<TSuccess, TMessage> Ok(TSuccess value);
    public static Result`2<TSuccess, TMessage> Pass(TSuccess value);
    public static Result`2<TSuccess, TMessage> Warn(TMessage message, TSuccess value);
    public static Result`2<TSuccess, TMessage> Fail(TMessage message);
    public static bool Failed(Result`2<TSuccess, TMessage> result);
    public static TResult Either(Func`3<TSuccess, IEnumerable`1<TMessage>, TResult> successFunc, Func`2<IEnumerable`1<TMessage>, TResult> failureFunc, Result`2<TSuccess, TMessage> trialResult);
    public static TSuccess ReturnOrFail(Result`2<TSuccess, TMessage> result);
    public static Result`2<TSuccess, TMessage> MergeMessages(IEnumerable`1<TMessage> messages, Result`2<TSuccess, TMessage> result);
    public static Result`2<TSuccess, TMessage> Bind(Func`2<TValue, Result`2<TSuccess, TMessage>> func, Result`2<TValue, TMessage> result);
    public static Result`2<TSuccess, TMessage> Flatten(Result`2<Result`2<TSuccess, TMessage>, TMessage> result);
    public static Result`2<TSuccess, TMessage> Apply(Result`2<Func`2<TValue, TSuccess>, TMessage> wrappedFunction, Result`2<TValue, TMessage> result);
    public static Result`2<TSuccess, TMessage> Lift(Func`2<TValue, TSuccess> func, Result`2<TValue, TMessage> result);
    public static Result`2<TSuccess1, TMessage1> Lift2(Func`2<TSuccess, Func`2<TMessage, TSuccess1>> func, Result`2<TSuccess, TMessage1> first, Result`2<TMessage, TMessage1> second);
    public static Result`2<IEnumerable`1<TSuccess>, TMessage> Collect(IEnumerable`1<Result`2<TSuccess, TMessage>> xs);
}
[ExtensionAttribute]
internal static class Serilog.Capturing.GetablePropertyFinder : object {
    [IteratorStateMachineAttribute("Serilog.Capturing.GetablePropertyFinder/<GetPropertiesRecursive>d__0")]
[ExtensionAttribute]
internal static IEnumerable`1<PropertyInfo> GetPropertiesRecursive(Type type);
}
internal class Serilog.Capturing.MessageTemplateProcessor : object {
    private MessageTemplateCache _parser;
    private PropertyBinder _propertyBinder;
    private PropertyValueConverter _propertyValueConverter;
    public MessageTemplateProcessor(PropertyValueConverter propertyValueConverter);
    public void Process(string messageTemplate, Object[] messageTemplateParameters, MessageTemplate& parsedTemplate, EventProperty[]& properties);
    public sealed virtual LogEventProperty CreateProperty(string name, object value, bool destructureObjects);
    public LogEventPropertyValue CreatePropertyValue(object value, bool destructureObjects);
}
internal class Serilog.Capturing.PropertyBinder : object {
    private PropertyValueConverter _valueConverter;
    private static EventProperty[] NoProperties;
    public PropertyBinder(PropertyValueConverter valueConverter);
    private static PropertyBinder();
    public EventProperty[] ConstructProperties(MessageTemplate messageTemplate, Object[] messageTemplateParameters);
    private EventProperty[] ConstructPositionalProperties(MessageTemplate template, Object[] messageTemplateParameters);
    private EventProperty[] ConstructNamedProperties(MessageTemplate template, Object[] messageTemplateParameters);
    private EventProperty ConstructProperty(PropertyToken propertyToken, object value);
}
internal class Serilog.Capturing.PropertyValueConverter : object {
    private static HashSet`1<Type> BuiltInScalarTypes;
    private IDestructuringPolicy[] _destructuringPolicies;
    private IScalarConversionPolicy[] _scalarConversionPolicies;
    private DepthLimiter _depthLimiter;
    private int _maximumStringLength;
    private int _maximumCollectionCount;
    private bool _propagateExceptions;
    public PropertyValueConverter(int maximumDestructuringDepth, int maximumStringLength, int maximumCollectionCount, IEnumerable`1<Type> additionalScalarTypes, IEnumerable`1<IDestructuringPolicy> additionalDestructuringPolicies, bool propagateExceptions);
    private static PropertyValueConverter();
    public sealed virtual LogEventProperty CreateProperty(string name, object value, bool destructureObjects);
    public sealed virtual LogEventPropertyValue CreatePropertyValue(object value, bool destructureObjects);
    public LogEventPropertyValue CreatePropertyValue(object value, Destructuring destructuring);
    private LogEventPropertyValue CreatePropertyValue(object value, bool destructureObjects, int depth);
    private LogEventPropertyValue CreatePropertyValue(object value, Destructuring destructuring, int depth);
    private bool TryConvertEnumerable(object value, Destructuring destructuring, Type valueType, LogEventPropertyValue& result);
    private bool TryConvertValueTuple(object value, Destructuring destructuring, Type valueType, LogEventPropertyValue& result);
    private bool TryConvertCompilerGeneratedType(object value, Destructuring destructuring, Type valueType, LogEventPropertyValue& result);
    private LogEventPropertyValue Stringify(object value);
    private string TruncateIfNecessary(string text);
    private static bool TryGetDictionary(object value, Type valueType, IDictionary& dictionary);
    private static bool IsValidDictionaryKeyType(Type valueType);
    [IteratorStateMachineAttribute("Serilog.Capturing.PropertyValueConverter/<GetProperties>d__21")]
private IEnumerable`1<LogEventProperty> GetProperties(object value);
    internal static bool IsCompilerGeneratedType(Type type);
    [IteratorStateMachineAttribute("Serilog.Capturing.PropertyValueConverter/<<TryConvertEnumerable>g__MapToDictionaryElements|14_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<KeyValuePair`2<ScalarValue, LogEventPropertyValue>> <TryConvertEnumerable>g__MapToDictionaryElements|14_0(IDictionary dictionaryEntries, Destructuring destructure);
    [IteratorStateMachineAttribute("Serilog.Capturing.PropertyValueConverter/<<TryConvertEnumerable>g__MapToSequenceElements|14_1>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<LogEventPropertyValue> <TryConvertEnumerable>g__MapToSequenceElements|14_1(IEnumerable sequence, Destructuring destructure);
}
public interface Serilog.Configuration.ILoggerSettings {
    public abstract virtual void Configure(LoggerConfiguration loggerConfiguration);
}
public class Serilog.Configuration.LoggerAuditSinkConfiguration : object {
    private LoggerSinkConfiguration _sinkConfiguration;
    internal LoggerAuditSinkConfiguration(LoggerConfiguration loggerConfiguration, Action`1<ILogEventSink> addSink);
    public LoggerConfiguration Sink(ILogEventSink logEventSink, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    public LoggerConfiguration Sink(LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    public LoggerConfiguration Logger(Action`1<LoggerConfiguration> configureLogger, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    public LoggerConfiguration Logger(ILogger logger, LogEventLevel restrictedToMinimumLevel);
}
public class Serilog.Configuration.LoggerDestructuringConfiguration : object {
    private LoggerConfiguration _loggerConfiguration;
    private Action`1<Type> _addScalar;
    private Action`1<IDestructuringPolicy> _addPolicy;
    private Action`1<int> _setMaximumDepth;
    private Action`1<int> _setMaximumStringLength;
    private Action`1<int> _setMaximumCollectionCount;
    internal LoggerDestructuringConfiguration(LoggerConfiguration loggerConfiguration, Action`1<Type> addScalar, Action`1<IDestructuringPolicy> addPolicy, Action`1<int> setMaximumDepth, Action`1<int> setMaximumStringLength, Action`1<int> setMaximumCollectionCount);
    public LoggerConfiguration AsScalar(Type scalarType);
    public LoggerConfiguration AsScalar();
    public LoggerConfiguration With(IDestructuringPolicy[] destructuringPolicies);
    public LoggerConfiguration With();
    public LoggerConfiguration ByTransforming(Func`2<TValue, object> transformation);
    public LoggerConfiguration ByTransformingWhere(Func`2<Type, bool> predicate, Func`2<TValue, object> transformation);
    public LoggerConfiguration ToMaximumDepth(int maximumDestructuringDepth);
    public LoggerConfiguration ToMaximumStringLength(int maximumStringLength);
    public LoggerConfiguration ToMaximumCollectionCount(int maximumCollectionCount);
}
public class Serilog.Configuration.LoggerEnrichmentConfiguration : object {
    private LoggerConfiguration _loggerConfiguration;
    private Action`1<ILogEventEnricher> _addEnricher;
    internal LoggerEnrichmentConfiguration(LoggerConfiguration loggerConfiguration, Action`1<ILogEventEnricher> addEnricher);
    public LoggerConfiguration With(ILogEventEnricher[] enrichers);
    public LoggerConfiguration With();
    public LoggerConfiguration WithProperty(string name, object value, bool destructureObjects);
    public LoggerConfiguration FromLogContext();
    public LoggerConfiguration When(Func`2<LogEvent, bool> condition, Action`1<LoggerEnrichmentConfiguration> configureEnricher);
    public LoggerConfiguration AtLevel(LogEventLevel enrichFromLevel, Action`1<LoggerEnrichmentConfiguration> configureEnricher);
    public LoggerConfiguration AtLevel(LoggingLevelSwitch levelSwitch, Action`1<LoggerEnrichmentConfiguration> configureEnricher);
    public static LoggerConfiguration Wrap(LoggerEnrichmentConfiguration loggerEnrichmentConfiguration, Func`2<ILogEventEnricher, ILogEventEnricher> wrapEnricher, Action`1<LoggerEnrichmentConfiguration> configureWrappedEnricher);
}
public class Serilog.Configuration.LoggerFilterConfiguration : object {
    private LoggerConfiguration _loggerConfiguration;
    private Action`1<ILogEventFilter> _addFilter;
    internal LoggerFilterConfiguration(LoggerConfiguration loggerConfiguration, Action`1<ILogEventFilter> addFilter);
    public LoggerConfiguration With(ILogEventFilter[] filters);
    public LoggerConfiguration With();
    public LoggerConfiguration ByExcluding(Func`2<LogEvent, bool> exclusionPredicate);
    public LoggerConfiguration ByIncludingOnly(Func`2<LogEvent, bool> inclusionPredicate);
}
public class Serilog.Configuration.LoggerMinimumLevelConfiguration : object {
    private LoggerConfiguration _loggerConfiguration;
    private Action`1<LogEventLevel> _setMinimum;
    private Action`1<LoggingLevelSwitch> _setLevelSwitch;
    private Action`2<string, LoggingLevelSwitch> _addOverride;
    internal LoggerMinimumLevelConfiguration(LoggerConfiguration loggerConfiguration, Action`1<LogEventLevel> setMinimum, Action`1<LoggingLevelSwitch> setLevelSwitch, Action`2<string, LoggingLevelSwitch> addOverride);
    public LoggerConfiguration Is(LogEventLevel minimumLevel);
    public LoggerConfiguration ControlledBy(LoggingLevelSwitch levelSwitch);
    public LoggerConfiguration Verbose();
    public LoggerConfiguration Debug();
    public LoggerConfiguration Information();
    public LoggerConfiguration Warning();
    public LoggerConfiguration Error();
    public LoggerConfiguration Fatal();
    public LoggerConfiguration Override(string source, LoggingLevelSwitch levelSwitch);
    public LoggerConfiguration Override(string source, LogEventLevel minimumLevel);
}
public class Serilog.Configuration.LoggerSettingsConfiguration : object {
    private LoggerConfiguration _loggerConfiguration;
    internal LoggerSettingsConfiguration(LoggerConfiguration loggerConfiguration);
    public LoggerConfiguration Settings(ILoggerSettings settings);
    public LoggerConfiguration KeyValuePairs(IEnumerable`1<KeyValuePair`2<string, string>> settings);
    private LoggerConfiguration KeyValuePairs(IReadOnlyDictionary`2<string, string> settings);
}
public class Serilog.Configuration.LoggerSinkConfiguration : object {
    private LoggerConfiguration _loggerConfiguration;
    private Action`1<ILogEventSink> _addSink;
    internal LoggerSinkConfiguration(LoggerConfiguration loggerConfiguration, Action`1<ILogEventSink> addSink);
    [EditorBrowsableAttribute("1")]
public LoggerConfiguration Sink(ILogEventSink logEventSink, LogEventLevel restrictedToMinimumLevel);
    public LoggerConfiguration Sink(ILogEventSink logEventSink, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    public LoggerConfiguration Sink(LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    public LoggerConfiguration Logger(Action`1<LoggerConfiguration> configureLogger, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    public LoggerConfiguration Logger(ILogger logger, LogEventLevel restrictedToMinimumLevel);
    public LoggerConfiguration Conditional(Func`2<LogEvent, bool> condition, Action`1<LoggerSinkConfiguration> configureSink);
    [ObsoleteAttribute("Please use `LoggerConfiguration.Wrap(loggerSinkConfiguration, wrapSink, configureWrappedSink, restrictedToMinimumLevel, levelSwitch)` instead.")]
public static LoggerConfiguration Wrap(LoggerSinkConfiguration loggerSinkConfiguration, Func`2<ILogEventSink, ILogEventSink> wrapSink, Action`1<LoggerSinkConfiguration> configureWrappedSink);
    public static LoggerConfiguration Wrap(LoggerSinkConfiguration loggerSinkConfiguration, Func`2<ILogEventSink, ILogEventSink> wrapSink, Action`1<LoggerSinkConfiguration> configureWrappedSink, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
[ExtensionAttribute]
public static class Serilog.ConsoleLoggerConfigurationExtensions : object {
    private static object DefaultSyncRoot;
    private static string DefaultConsoleOutputTemplate;
    private static ConsoleLoggerConfigurationExtensions();
    [<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("2")]
[ExtensionAttribute]
public static LoggerConfiguration Console(LoggerSinkConfiguration sinkConfiguration, LogEventLevel restrictedToMinimumLevel, string outputTemplate, IFormatProvider formatProvider, LoggingLevelSwitch levelSwitch, Nullable`1<LogEventLevel> standardErrorFromLevel, ConsoleTheme theme, bool applyThemeToRedirectedOutput, object syncRoot);
    [ExtensionAttribute]
public static LoggerConfiguration Console(LoggerSinkConfiguration sinkConfiguration, ITextFormatter formatter, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch, Nullable`1<LogEventLevel> standardErrorFromLevel, object syncRoot);
}
internal class Serilog.Context.ImmutableStack`1 : object {
    private ImmutableStack`1<T> _under;
    private T _top;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableStack`1<T> <Empty>k__BackingField;
    public int Count { get; }
    public static ImmutableStack`1<T> Empty { get; }
    public bool IsEmpty { get; }
    public T Top { get; }
    private ImmutableStack`1(ImmutableStack`1<T> under, T top);
    private static ImmutableStack`1();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public static ImmutableStack`1<T> get_Empty();
    public bool get_IsEmpty();
    public ImmutableStack`1<T> Push(T t);
    public T get_Top();
}
public static class Serilog.Context.LogContext : object {
    private static AsyncLocal`1<ImmutableStack`1<ILogEventEnricher>> Data;
    private static ImmutableStack`1<ILogEventEnricher> Enrichers { get; private set; }
    private static LogContext();
    public static IDisposable PushProperty(string name, object value, bool destructureObjects);
    public static IDisposable Push(ILogEventEnricher enricher);
    public static IDisposable Push(ILogEventEnricher[] enrichers);
    [ObsoleteAttribute("Please use `LogContext.Push(properties)` instead.")]
[EditorBrowsableAttribute("1")]
public static IDisposable PushProperties(ILogEventEnricher[] properties);
    public static ILogEventEnricher Clone();
    public static IDisposable Suspend();
    public static void Reset();
    private static ImmutableStack`1<ILogEventEnricher> GetOrCreateEnricherStack();
    internal static void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
    private static ImmutableStack`1<ILogEventEnricher> get_Enrichers();
    private static void set_Enrichers(ImmutableStack`1<ILogEventEnricher> value);
}
internal class Serilog.Context.LogContextEnricher : object {
    public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
public static class Serilog.Core.Constants : object {
    public static string SourceContextPropertyName;
}
internal class Serilog.Core.Enrichers.ConditionalEnricher : object {
    private ILogEventEnricher _wrapped;
    private Func`2<LogEvent, bool> _condition;
    public ConditionalEnricher(ILogEventEnricher wrapped, Func`2<LogEvent, bool> condition);
    public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
    public sealed virtual void Dispose();
}
internal class Serilog.Core.Enrichers.EmptyEnricher : object {
    public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
internal class Serilog.Core.Enrichers.FixedPropertyEnricher : object {
    private EventProperty _eventProperty;
    public FixedPropertyEnricher(EventProperty& eventProperty);
    public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
public class Serilog.Core.Enrichers.PropertyEnricher : object {
    private string _name;
    private object _value;
    private bool _destructureObjects;
    public PropertyEnricher(string name, object value, bool destructureObjects);
    public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
internal class Serilog.Core.Enrichers.SafeAggregateEnricher : object {
    private ILogEventEnricher[] _enrichers;
    public SafeAggregateEnricher(IEnumerable`1<ILogEventEnricher> enrichers);
    public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
internal class Serilog.Core.Filters.DelegateFilter : object {
    private Func`2<LogEvent, bool> _isEnabled;
    public DelegateFilter(Func`2<LogEvent, bool> isEnabled);
    public sealed virtual bool IsEnabled(LogEvent logEvent);
}
public interface Serilog.Core.IDestructuringPolicy {
    public abstract virtual bool TryDestructure(object value, ILogEventPropertyValueFactory propertyValueFactory, LogEventPropertyValue& result);
}
public interface Serilog.Core.ILogEventEnricher {
    public abstract virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
public interface Serilog.Core.ILogEventFilter {
    public abstract virtual bool IsEnabled(LogEvent logEvent);
}
public interface Serilog.Core.ILogEventPropertyFactory {
    public abstract virtual LogEventProperty CreateProperty(string name, object value, bool destructureObjects);
}
public interface Serilog.Core.ILogEventPropertyValueFactory {
    public abstract virtual LogEventPropertyValue CreatePropertyValue(object value, bool destructureObjects);
}
public interface Serilog.Core.ILogEventSink {
    public abstract virtual void Emit(LogEvent logEvent);
}
internal interface Serilog.Core.IMessageTemplateParser {
    public abstract virtual MessageTemplate Parse(string messageTemplate);
}
internal interface Serilog.Core.IScalarConversionPolicy {
    public abstract virtual bool TryConvertToScalar(object value, ScalarValue& result);
}
internal class Serilog.Core.LevelOverrideMap : object {
    private LogEventLevel _defaultMinimumLevel;
    private LoggingLevelSwitch _defaultLevelSwitch;
    private LevelOverride[] _overrides;
    public LevelOverrideMap(IDictionary`2<string, LoggingLevelSwitch> overrides, LogEventLevel defaultMinimumLevel, LoggingLevelSwitch defaultLevelSwitch);
    public void GetEffectiveLevel(string context, LogEventLevel& minimumLevel, LoggingLevelSwitch& levelSwitch);
}
public class Serilog.Core.Logger : object {
    private static Object[] NoPropertyValues;
    private static LogEventProperty[] NoProperties;
    private MessageTemplateProcessor _messageTemplateProcessor;
    private ILogEventSink _sink;
    private Action _dispose;
    private ILogEventEnricher _enricher;
    private LogEventLevel _minimumLevel;
    private LoggingLevelSwitch _levelSwitch;
    private LevelOverrideMap _overrideMap;
    [CompilerGeneratedAttribute]
private static ILogger <None>k__BackingField;
    internal bool HasOverrideMap { get; }
    public static ILogger None { get; }
    internal Logger(MessageTemplateProcessor messageTemplateProcessor, LogEventLevel minimumLevel, ILogEventSink sink, ILogEventEnricher enricher, Action dispose, LevelOverrideMap overrideMap);
    internal Logger(MessageTemplateProcessor messageTemplateProcessor, LoggingLevelSwitch levelSwitch, ILogEventSink sink, ILogEventEnricher enricher, Action dispose, LevelOverrideMap overrideMap);
    private Logger(MessageTemplateProcessor messageTemplateProcessor, LogEventLevel minimumLevel, ILogEventSink sink, ILogEventEnricher enricher, Action dispose, LoggingLevelSwitch levelSwitch, LevelOverrideMap overrideMap);
    private static Logger();
    internal bool get_HasOverrideMap();
    public sealed virtual ILogger ForContext(ILogEventEnricher enricher);
    public sealed virtual ILogger ForContext(IEnumerable`1<ILogEventEnricher> enrichers);
    public sealed virtual ILogger ForContext(string propertyName, object value, bool destructureObjects);
    public sealed virtual ILogger ForContext(Type source);
    public sealed virtual ILogger ForContext();
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, string messageTemplate, Object[] propertyValues);
    public sealed virtual bool IsEnabled(LogEventLevel level);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, Object[] propertyValues);
    public sealed virtual void Write(LogEvent logEvent);
    private sealed virtual override void Serilog.Core.ILogEventSink.Emit(LogEvent logEvent);
    private void Dispatch(LogEvent logEvent);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Verbose(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Debug(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Information(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Warning(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Error(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual void Fatal(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual bool BindMessageTemplate(string messageTemplate, Object[] propertyValues, MessageTemplate& parsedTemplate, IEnumerable`1& boundProperties);
    public sealed virtual bool BindProperty(string propertyName, object value, bool destructureObjects, LogEventProperty& property);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public static ILogger get_None();
}
public class Serilog.Core.LoggingLevelSwitch : object {
    private LogEventLevel modreq(System.Runtime.CompilerServices.IsVolatile) _minimumLevel;
    public LogEventLevel MinimumLevel { get; public set; }
    public LoggingLevelSwitch(LogEventLevel initialMinimumLevel);
    public LogEventLevel get_MinimumLevel();
    public void set_MinimumLevel(LogEventLevel value);
}
[AttributeUsageAttribute("96")]
public class Serilog.Core.MessageTemplateFormatMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MessageTemplateParameterName>k__BackingField;
    public string MessageTemplateParameterName { get; private set; }
    public MessageTemplateFormatMethodAttribute(string messageTemplateParameterName);
    [CompilerGeneratedAttribute]
public string get_MessageTemplateParameterName();
    [CompilerGeneratedAttribute]
private void set_MessageTemplateParameterName(string value);
}
internal class Serilog.Core.Pipeline.MessageTemplateCache : object {
    private IMessageTemplateParser _innerParser;
    private object _templatesLock;
    private Hashtable _templates;
    private static int MaxCacheItems;
    private static int MaxCachedTemplateLength;
    public MessageTemplateCache(IMessageTemplateParser innerParser);
    public sealed virtual MessageTemplate Parse(string messageTemplate);
}
internal class Serilog.Core.Pipeline.SilentLogger : object {
    public static ILogger Instance;
    private static SilentLogger();
    public sealed virtual ILogger ForContext(ILogEventEnricher enricher);
    public sealed virtual ILogger ForContext(IEnumerable`1<ILogEventEnricher> enrichers);
    public sealed virtual ILogger ForContext(string propertyName, object value, bool destructureObjects);
    public sealed virtual ILogger ForContext();
    public sealed virtual ILogger ForContext(Type source);
    public sealed virtual void Write(LogEvent logEvent);
    public sealed virtual void Write(LogEventLevel level, string messageTemplate);
    public sealed virtual void Write(LogEventLevel level, string messageTemplate, T propertyValue);
    public sealed virtual void Write(LogEventLevel level, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Write(LogEventLevel level, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Write(LogEventLevel level, string messageTemplate, Object[] propertyValues);
    public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate);
    public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, T propertyValue);
    public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, Object[] propertyValues);
    public sealed virtual bool IsEnabled(LogEventLevel level);
    public sealed virtual void Verbose(string messageTemplate);
    public sealed virtual void Verbose(string messageTemplate, T propertyValue);
    public sealed virtual void Verbose(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Verbose(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Verbose(string messageTemplate, Object[] propertyValues);
    public sealed virtual void Verbose(Exception exception, string messageTemplate);
    public sealed virtual void Verbose(Exception exception, string messageTemplate, T propertyValue);
    public sealed virtual void Verbose(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Verbose(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Verbose(Exception exception, string messageTemplate, Object[] propertyValues);
    public sealed virtual void Debug(string messageTemplate);
    public sealed virtual void Debug(string messageTemplate, T propertyValue);
    public sealed virtual void Debug(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Debug(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Debug(string messageTemplate, Object[] propertyValues);
    public sealed virtual void Debug(Exception exception, string messageTemplate);
    public sealed virtual void Debug(Exception exception, string messageTemplate, T propertyValue);
    public sealed virtual void Debug(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Debug(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Debug(Exception exception, string messageTemplate, Object[] propertyValues);
    public sealed virtual void Information(string messageTemplate);
    public sealed virtual void Information(string messageTemplate, T propertyValue);
    public sealed virtual void Information(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Information(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Information(string messageTemplate, Object[] propertyValues);
    public sealed virtual void Information(Exception exception, string messageTemplate);
    public sealed virtual void Information(Exception exception, string messageTemplate, T propertyValue);
    public sealed virtual void Information(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Information(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Information(Exception exception, string messageTemplate, Object[] propertyValues);
    public sealed virtual void Warning(string messageTemplate);
    public sealed virtual void Warning(string messageTemplate, T propertyValue);
    public sealed virtual void Warning(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Warning(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Warning(string messageTemplate, Object[] propertyValues);
    public sealed virtual void Warning(Exception exception, string messageTemplate);
    public sealed virtual void Warning(Exception exception, string messageTemplate, T propertyValue);
    public sealed virtual void Warning(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Warning(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Warning(Exception exception, string messageTemplate, Object[] propertyValues);
    public sealed virtual void Error(string messageTemplate);
    public sealed virtual void Error(string messageTemplate, T propertyValue);
    public sealed virtual void Error(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Error(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Error(string messageTemplate, Object[] propertyValues);
    public sealed virtual void Error(Exception exception, string messageTemplate);
    public sealed virtual void Error(Exception exception, string messageTemplate, T propertyValue);
    public sealed virtual void Error(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Error(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Error(Exception exception, string messageTemplate, Object[] propertyValues);
    public sealed virtual void Fatal(string messageTemplate);
    public sealed virtual void Fatal(string messageTemplate, T propertyValue);
    public sealed virtual void Fatal(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Fatal(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Fatal(string messageTemplate, Object[] propertyValues);
    public sealed virtual void Fatal(Exception exception, string messageTemplate);
    public sealed virtual void Fatal(Exception exception, string messageTemplate, T propertyValue);
    public sealed virtual void Fatal(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public sealed virtual void Fatal(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public sealed virtual void Fatal(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public sealed virtual bool BindMessageTemplate(string messageTemplate, Object[] propertyValues, MessageTemplate& parsedTemplate, IEnumerable`1& boundProperties);
    public sealed virtual bool BindProperty(string propertyName, object value, bool destructureObjects, LogEventProperty& property);
}
internal class Serilog.Core.Sinks.AggregateSink : object {
    private ILogEventSink[] _sinks;
    public AggregateSink(IEnumerable`1<ILogEventSink> sinks);
    public sealed virtual void Emit(LogEvent logEvent);
}
internal class Serilog.Core.Sinks.ConditionalSink : object {
    private ILogEventSink _wrapped;
    private Func`2<LogEvent, bool> _condition;
    public ConditionalSink(ILogEventSink wrapped, Func`2<LogEvent, bool> condition);
    public sealed virtual void Emit(LogEvent logEvent);
    public sealed virtual void Dispose();
}
internal class Serilog.Core.Sinks.DisposeDelegatingSink : object {
    private ILogEventSink _sink;
    private IDisposable _disposable;
    public DisposeDelegatingSink(ILogEventSink sink, IDisposable disposable);
    public sealed virtual void Dispose();
    public sealed virtual void Emit(LogEvent logEvent);
}
internal class Serilog.Core.Sinks.DisposingAggregateSink : object {
    private ILogEventSink[] _sinks;
    public DisposingAggregateSink(IEnumerable`1<ILogEventSink> sinks);
    public sealed virtual void Emit(LogEvent logEvent);
    public sealed virtual void Dispose();
}
internal class Serilog.Core.Sinks.FilteringSink : object {
    private ILogEventSink _sink;
    private bool _propagateExceptions;
    private ILogEventFilter[] _filters;
    public FilteringSink(ILogEventSink sink, IEnumerable`1<ILogEventFilter> filters, bool propagateExceptions);
    public sealed virtual void Emit(LogEvent logEvent);
}
internal class Serilog.Core.Sinks.RestrictedSink : object {
    private ILogEventSink _sink;
    private LoggingLevelSwitch _levelSwitch;
    public RestrictedSink(ILogEventSink sink, LoggingLevelSwitch levelSwitch);
    public sealed virtual void Emit(LogEvent logEvent);
    public sealed virtual void Dispose();
}
internal class Serilog.Core.Sinks.SafeAggregateSink : object {
    private ILogEventSink[] _sinks;
    public SafeAggregateSink(IEnumerable`1<ILogEventSink> sinks);
    public sealed virtual void Emit(LogEvent logEvent);
}
internal class Serilog.Core.Sinks.SecondaryLoggerSink : object {
    private ILogger _logger;
    private bool _attemptDispose;
    public SecondaryLoggerSink(ILogger logger, bool attemptDispose);
    public sealed virtual void Emit(LogEvent logEvent);
    public sealed virtual void Dispose();
}
public abstract class Serilog.Data.LogEventPropertyValueRewriter`1 : LogEventPropertyValueVisitor`2<TState, LogEventPropertyValue> {
    protected virtual LogEventPropertyValue VisitScalarValue(TState state, ScalarValue scalar);
    protected virtual LogEventPropertyValue VisitSequenceValue(TState state, SequenceValue sequence);
    protected virtual LogEventPropertyValue VisitStructureValue(TState state, StructureValue structure);
    protected virtual LogEventPropertyValue VisitDictionaryValue(TState state, DictionaryValue dictionary);
    protected virtual LogEventPropertyValue VisitUnsupportedValue(TState state, LogEventPropertyValue value);
}
public abstract class Serilog.Data.LogEventPropertyValueVisitor`2 : object {
    protected virtual TResult Visit(TState state, LogEventPropertyValue value);
    protected abstract virtual TResult VisitScalarValue(TState state, ScalarValue scalar);
    protected abstract virtual TResult VisitSequenceValue(TState state, SequenceValue sequence);
    protected abstract virtual TResult VisitStructureValue(TState state, StructureValue structure);
    protected abstract virtual TResult VisitDictionaryValue(TState state, DictionaryValue dictionary);
    protected virtual TResult VisitUnsupportedValue(TState state, LogEventPropertyValue value);
}
public class Serilog.Debugging.LoggingFailedException : Exception {
    public LoggingFailedException(string message);
}
public static class Serilog.Debugging.SelfLog : object {
    private static Action`1<string> _output;
    [ObsoleteAttribute("Use SelfLog.Enable(value) and SelfLog.Disable() instead")]
unknown static TextWriter Out {public set; }
    public static void set_Out(TextWriter value);
    public static void Enable(TextWriter output);
    public static void Enable(Action`1<string> output);
    public static void Disable();
    public static void WriteLine(string format, object arg0, object arg1, object arg2);
}
public class Serilog.Enrichers.ThreadIdEnricher : object {
    public static string ThreadIdPropertyName;
    public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
public class Serilog.Enrichers.ThreadNameEnricher : object {
    public static string ThreadNamePropertyName;
    public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
public class Serilog.Events.DictionaryValue : LogEventPropertyValue {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<ScalarValue, LogEventPropertyValue> <Elements>k__BackingField;
    public IReadOnlyDictionary`2<ScalarValue, LogEventPropertyValue> Elements { get; }
    public DictionaryValue(IEnumerable`1<KeyValuePair`2<ScalarValue, LogEventPropertyValue>> elements);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<ScalarValue, LogEventPropertyValue> get_Elements();
    public virtual void Render(TextWriter output, string format, IFormatProvider formatProvider);
}
[IsReadOnlyAttribute]
internal class Serilog.Events.EventProperty : ValueType {
    public static EventProperty None;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private LogEventPropertyValue <Value>k__BackingField;
    public string Name { get; }
    public LogEventPropertyValue Value { get; }
    public EventProperty(string name, LogEventPropertyValue value);
    private static EventProperty();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public LogEventPropertyValue get_Value();
    public void Deconstruct(String& name, LogEventPropertyValue& value);
    public virtual bool Equals(object obj);
    public bool Equals(EventProperty other);
    public virtual int GetHashCode();
}
public static class Serilog.Events.LevelAlias : object {
    public static LogEventLevel Minimum;
    public static LogEventLevel Maximum;
}
public class Serilog.Events.LogEvent : object {
    private Dictionary`2<string, LogEventPropertyValue> _properties;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private LogEventLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageTemplate <MessageTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public DateTimeOffset Timestamp { get; }
    public LogEventLevel Level { get; }
    public MessageTemplate MessageTemplate { get; }
    public IReadOnlyDictionary`2<string, LogEventPropertyValue> Properties { get; }
    public Exception Exception { get; }
    private LogEvent(DateTimeOffset timestamp, LogEventLevel level, Exception exception, MessageTemplate messageTemplate, Dictionary`2<string, LogEventPropertyValue> properties);
    public LogEvent(DateTimeOffset timestamp, LogEventLevel level, Exception exception, MessageTemplate messageTemplate, IEnumerable`1<LogEventProperty> properties);
    internal LogEvent(DateTimeOffset timestamp, LogEventLevel level, Exception exception, MessageTemplate messageTemplate, EventProperty[] properties);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public LogEventLevel get_Level();
    [CompilerGeneratedAttribute]
public MessageTemplate get_MessageTemplate();
    public void RenderMessage(TextWriter output, IFormatProvider formatProvider);
    public string RenderMessage(IFormatProvider formatProvider);
    public IReadOnlyDictionary`2<string, LogEventPropertyValue> get_Properties();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    public void AddOrUpdateProperty(LogEventProperty property);
    internal void AddOrUpdateProperty(EventProperty& property);
    public void AddPropertyIfAbsent(LogEventProperty property);
    internal void AddPropertyIfAbsent(EventProperty& property);
    public void RemovePropertyIfPresent(string propertyName);
    internal LogEvent Copy();
}
public enum Serilog.Events.LogEventLevel : Enum {
    public int value__;
    public static LogEventLevel Verbose;
    public static LogEventLevel Debug;
    public static LogEventLevel Information;
    public static LogEventLevel Warning;
    public static LogEventLevel Error;
    public static LogEventLevel Fatal;
}
public class Serilog.Events.LogEventProperty : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private LogEventPropertyValue <Value>k__BackingField;
    public string Name { get; }
    public LogEventPropertyValue Value { get; }
    public LogEventProperty(string name, LogEventPropertyValue value);
    internal LogEventProperty(EventProperty property);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public LogEventPropertyValue get_Value();
    public static bool IsValidName(string name);
    internal static void EnsureValidName(string name);
}
public abstract class Serilog.Events.LogEventPropertyValue : object {
    public abstract virtual void Render(TextWriter output, string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
public class Serilog.Events.MessageTemplate : object {
    [CompilerGeneratedAttribute]
private static MessageTemplate <Empty>k__BackingField;
    private MessageTemplateToken[] _tokens;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyToken[] <NamedProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyToken[] <PositionalProperties>k__BackingField;
    public static MessageTemplate Empty { get; }
    public string Text { get; }
    public IEnumerable`1<MessageTemplateToken> Tokens { get; }
    internal MessageTemplateToken[] TokenArray { get; }
    internal PropertyToken[] NamedProperties { get; }
    internal PropertyToken[] PositionalProperties { get; }
    public MessageTemplate(IEnumerable`1<MessageTemplateToken> tokens);
    public MessageTemplate(string text, IEnumerable`1<MessageTemplateToken> tokens);
    private static MessageTemplate();
    [CompilerGeneratedAttribute]
public static MessageTemplate get_Empty();
    private static TResult[] GetElementsOfTypeToArray(MessageTemplateToken[] tokens);
    [CompilerGeneratedAttribute]
public string get_Text();
    public virtual string ToString();
    public IEnumerable`1<MessageTemplateToken> get_Tokens();
    internal MessageTemplateToken[] get_TokenArray();
    [CompilerGeneratedAttribute]
internal PropertyToken[] get_NamedProperties();
    [CompilerGeneratedAttribute]
internal PropertyToken[] get_PositionalProperties();
    public string Render(IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, IFormatProvider formatProvider);
    public void Render(IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output, IFormatProvider formatProvider);
}
public class Serilog.Events.ScalarValue : LogEventPropertyValue {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public ScalarValue(object value);
    [CompilerGeneratedAttribute]
public object get_Value();
    public virtual void Render(TextWriter output, string format, IFormatProvider formatProvider);
    internal static void Render(object value, TextWriter output, string format, IFormatProvider formatProvider);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Serilog.Events.SequenceValue : LogEventPropertyValue {
    private LogEventPropertyValue[] _elements;
    public IReadOnlyList`1<LogEventPropertyValue> Elements { get; }
    public SequenceValue(IEnumerable`1<LogEventPropertyValue> elements);
    public IReadOnlyList`1<LogEventPropertyValue> get_Elements();
    public virtual void Render(TextWriter output, string format, IFormatProvider formatProvider);
}
public class Serilog.Events.StructureValue : LogEventPropertyValue {
    private LogEventProperty[] _properties;
    [CompilerGeneratedAttribute]
private string <TypeTag>k__BackingField;
    public string TypeTag { get; }
    public IReadOnlyList`1<LogEventProperty> Properties { get; }
    public StructureValue(IEnumerable`1<LogEventProperty> properties, string typeTag);
    [CompilerGeneratedAttribute]
public string get_TypeTag();
    public IReadOnlyList`1<LogEventProperty> get_Properties();
    public virtual void Render(TextWriter output, string format, IFormatProvider formatProvider);
    private static void Render(TextWriter output, LogEventProperty property, IFormatProvider formatProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Serilog.FileLoggerConfigurationExtensions : object {
    private static int DefaultRetainedFileCountLimit;
    private static long DefaultFileSizeLimitBytes;
    private static string DefaultOutputTemplate;
    [ExtensionAttribute]
[ObsoleteAttribute("New code should not be compiled against this obsolete overload")]
[EditorBrowsableAttribute("1")]
public static LoggerConfiguration File(LoggerSinkConfiguration sinkConfiguration, string path, LogEventLevel restrictedToMinimumLevel, string outputTemplate, IFormatProvider formatProvider, Nullable`1<long> fileSizeLimitBytes, LoggingLevelSwitch levelSwitch, bool buffered, bool shared, Nullable`1<TimeSpan> flushToDiskInterval);
    [ExtensionAttribute]
[ObsoleteAttribute("New code should not be compiled against this obsolete overload")]
[EditorBrowsableAttribute("1")]
public static LoggerConfiguration File(LoggerSinkConfiguration sinkConfiguration, ITextFormatter formatter, string path, LogEventLevel restrictedToMinimumLevel, Nullable`1<long> fileSizeLimitBytes, LoggingLevelSwitch levelSwitch, bool buffered, bool shared, Nullable`1<TimeSpan> flushToDiskInterval);
    [ExtensionAttribute]
[ObsoleteAttribute("New code should not be compiled against this obsolete overload")]
[EditorBrowsableAttribute("1")]
public static LoggerConfiguration File(LoggerSinkConfiguration sinkConfiguration, string path, LogEventLevel restrictedToMinimumLevel, string outputTemplate, IFormatProvider formatProvider, Nullable`1<long> fileSizeLimitBytes, LoggingLevelSwitch levelSwitch, bool buffered, bool shared, Nullable`1<TimeSpan> flushToDiskInterval, RollingInterval rollingInterval, bool rollOnFileSizeLimit, Nullable`1<int> retainedFileCountLimit, Encoding encoding);
    [ExtensionAttribute]
[ObsoleteAttribute("New code should not be compiled against this obsolete overload")]
[EditorBrowsableAttribute("1")]
public static LoggerConfiguration File(LoggerSinkConfiguration sinkConfiguration, ITextFormatter formatter, string path, LogEventLevel restrictedToMinimumLevel, Nullable`1<long> fileSizeLimitBytes, LoggingLevelSwitch levelSwitch, bool buffered, bool shared, Nullable`1<TimeSpan> flushToDiskInterval, RollingInterval rollingInterval, bool rollOnFileSizeLimit, Nullable`1<int> retainedFileCountLimit, Encoding encoding);
    [ExtensionAttribute]
public static LoggerConfiguration File(LoggerSinkConfiguration sinkConfiguration, string path, LogEventLevel restrictedToMinimumLevel, string outputTemplate, IFormatProvider formatProvider, Nullable`1<long> fileSizeLimitBytes, LoggingLevelSwitch levelSwitch, bool buffered, bool shared, Nullable`1<TimeSpan> flushToDiskInterval, RollingInterval rollingInterval, bool rollOnFileSizeLimit, Nullable`1<int> retainedFileCountLimit, Encoding encoding, FileLifecycleHooks hooks, Nullable`1<TimeSpan> retainedFileTimeLimit);
    [ExtensionAttribute]
public static LoggerConfiguration File(LoggerSinkConfiguration sinkConfiguration, ITextFormatter formatter, string path, LogEventLevel restrictedToMinimumLevel, Nullable`1<long> fileSizeLimitBytes, LoggingLevelSwitch levelSwitch, bool buffered, bool shared, Nullable`1<TimeSpan> flushToDiskInterval, RollingInterval rollingInterval, bool rollOnFileSizeLimit, Nullable`1<int> retainedFileCountLimit, Encoding encoding, FileLifecycleHooks hooks, Nullable`1<TimeSpan> retainedFileTimeLimit);
    [ExtensionAttribute]
[ObsoleteAttribute("New code should not be compiled against this obsolete overload")]
[EditorBrowsableAttribute("1")]
public static LoggerConfiguration File(LoggerAuditSinkConfiguration sinkConfiguration, string path, LogEventLevel restrictedToMinimumLevel, string outputTemplate, IFormatProvider formatProvider, LoggingLevelSwitch levelSwitch);
    [ExtensionAttribute]
[ObsoleteAttribute("New code should not be compiled against this obsolete overload")]
[EditorBrowsableAttribute("1")]
public static LoggerConfiguration File(LoggerAuditSinkConfiguration sinkConfiguration, ITextFormatter formatter, string path, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    [ExtensionAttribute]
public static LoggerConfiguration File(LoggerAuditSinkConfiguration sinkConfiguration, string path, LogEventLevel restrictedToMinimumLevel, string outputTemplate, IFormatProvider formatProvider, LoggingLevelSwitch levelSwitch, Encoding encoding, FileLifecycleHooks hooks);
    [ExtensionAttribute]
public static LoggerConfiguration File(LoggerAuditSinkConfiguration sinkConfiguration, ITextFormatter formatter, string path, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch, Encoding encoding, FileLifecycleHooks hooks);
    [ExtensionAttribute]
private static LoggerConfiguration ConfigureFile(Func`4<ILogEventSink, LogEventLevel, LoggingLevelSwitch, LoggerConfiguration> addSink, ITextFormatter formatter, string path, LogEventLevel restrictedToMinimumLevel, Nullable`1<long> fileSizeLimitBytes, LoggingLevelSwitch levelSwitch, bool buffered, bool propagateExceptions, bool shared, Nullable`1<TimeSpan> flushToDiskInterval, Encoding encoding, RollingInterval rollingInterval, bool rollOnFileSizeLimit, Nullable`1<int> retainedFileCountLimit, FileLifecycleHooks hooks, Nullable`1<TimeSpan> retainedFileTimeLimit);
}
public static class Serilog.Filters.Matching : object {
    public static Func`2<LogEvent, bool> FromSource();
    public static Func`2<LogEvent, bool> FromSource(string source);
    public static Func`2<LogEvent, bool> WithProperty(string propertyName);
    public static Func`2<LogEvent, bool> WithProperty(string propertyName, object scalarValue);
    public static Func`2<LogEvent, bool> WithProperty(string propertyName, Func`2<TScalar, bool> predicate);
}
internal static class Serilog.Formatting.Display.LevelOutputFormat : object {
    private static String[][] _titleCaseLevelMap;
    private static String[][] _lowerCaseLevelMap;
    private static String[][] _upperCaseLevelMap;
    private static LevelOutputFormat();
    public static string GetLevelMoniker(LogEventLevel value, string format);
    private static string GetLevelMoniker(String[][] caseLevelMap, int index, int width);
    private static string GetLevelMoniker(String[][] caseLevelMap, int index);
}
public class Serilog.Formatting.Display.MessageTemplateTextFormatter : object {
    private IFormatProvider _formatProvider;
    private MessageTemplate _outputTemplate;
    public MessageTemplateTextFormatter(string outputTemplate, IFormatProvider formatProvider);
    public sealed virtual void Format(LogEvent logEvent, TextWriter output);
}
[ObsoleteAttribute("Not used by the current output formatting implementation.")]
internal class Serilog.Formatting.Display.Obsolete.LiteralStringValue : LogEventPropertyValue {
    private string _value;
    public LiteralStringValue(string value);
    public virtual void Render(TextWriter output, string format, IFormatProvider formatProvider);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ObsoleteAttribute("Not used by the current output formatting implementation.")]
internal class Serilog.Formatting.Display.Obsolete.LogEventLevelValue : LogEventPropertyValue {
    private LogEventLevel _value;
    public LogEventLevelValue(LogEventLevel value);
    public virtual void Render(TextWriter output, string format, IFormatProvider formatProvider);
}
[ObsoleteAttribute("Not used by the current output formatting implementation.")]
internal class Serilog.Formatting.Display.Obsolete.LogEventPropertiesValue : LogEventPropertyValue {
    private MessageTemplate _template;
    private IReadOnlyDictionary`2<string, LogEventPropertyValue> _properties;
    private MessageTemplate _outputTemplate;
    public LogEventPropertiesValue(MessageTemplate template, IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, MessageTemplate outputTemplate);
    public virtual void Render(TextWriter output, string format, IFormatProvider formatProvider);
}
[ObsoleteAttribute("Not used by the current output formatting implementation.")]
internal class Serilog.Formatting.Display.Obsolete.LogEventPropertyMessageValue : LogEventPropertyValue {
    private MessageTemplate _template;
    private IReadOnlyDictionary`2<string, LogEventPropertyValue> _properties;
    public LogEventPropertyMessageValue(MessageTemplate template, IReadOnlyDictionary`2<string, LogEventPropertyValue> properties);
    public virtual void Render(TextWriter output, string format, IFormatProvider formatProvider);
}
public static class Serilog.Formatting.Display.OutputProperties : object {
    private static LiteralStringValue LiteralNewLine;
    public static string MessagePropertyName;
    public static string TimestampPropertyName;
    public static string LevelPropertyName;
    public static string NewLinePropertyName;
    public static string ExceptionPropertyName;
    public static string PropertiesPropertyName;
    private static OutputProperties();
    [ObsoleteAttribute("These implementation details of output formatting will not be exposed in a future version.")]
public static IReadOnlyDictionary`2<string, LogEventPropertyValue> GetOutputProperties(LogEvent logEvent);
    internal static IReadOnlyDictionary`2<string, LogEventPropertyValue> GetOutputProperties(LogEvent logEvent, MessageTemplate outputTemplate);
}
internal static class Serilog.Formatting.Display.PropertiesOutputFormat : object {
    private static JsonValueFormatter JsonValueFormatter;
    private static PropertiesOutputFormat();
    public static void Render(MessageTemplate template, IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, MessageTemplate outputTemplate, TextWriter output, string format, IFormatProvider formatProvider);
    private static bool TemplateContainsPropertyName(MessageTemplate template, string propertyName);
}
public interface Serilog.Formatting.ITextFormatter {
    public abstract virtual void Format(LogEvent logEvent, TextWriter output);
}
public class Serilog.Formatting.Json.JsonFormatter : object {
    private static string ExtensionPointObsoletionMessage;
    private bool _omitEnclosingObject;
    private string _closingDelimiter;
    private bool _renderMessage;
    private IFormatProvider _formatProvider;
    private IDictionary`2<Type, Action`3<object, bool, TextWriter>> _literalWriters;
    public JsonFormatter(string closingDelimiter, bool renderMessage, IFormatProvider formatProvider);
    [ObsoleteAttribute("The omitEnclosingObject parameter is obsolete and will be removed in a future Serilog version.")]
public JsonFormatter(bool omitEnclosingObject, string closingDelimiter, bool renderMessage, IFormatProvider formatProvider);
    public sealed virtual void Format(LogEvent logEvent, TextWriter output);
    [ObsoleteAttribute("Extension of JsonFormatter by subclassing is obsolete and will be removed in a future Serilog version. Write a custom formatter based on JsonValueFormatter instead. See https://github.com/serilog/serilog/pull/819.")]
protected void AddLiteralWriter(Type type, Action`2<object, TextWriter> writer);
    [ObsoleteAttribute("Extension of JsonFormatter by subclassing is obsolete and will be removed in a future Serilog version. Write a custom formatter based on JsonValueFormatter instead. See https://github.com/serilog/serilog/pull/819.")]
protected virtual void WriteRenderings(IGrouping`2[] tokensWithFormat, IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output);
    [ObsoleteAttribute("Extension of JsonFormatter by subclassing is obsolete and will be removed in a future Serilog version. Write a custom formatter based on JsonValueFormatter instead. See https://github.com/serilog/serilog/pull/819.")]
protected virtual void WriteRenderingsValues(IGrouping`2[] tokensWithFormat, IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output);
    [ObsoleteAttribute("Extension of JsonFormatter by subclassing is obsolete and will be removed in a future Serilog version. Write a custom formatter based on JsonValueFormatter instead. See https://github.com/serilog/serilog/pull/819.")]
protected virtual void WriteProperties(IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output);
    [ObsoleteAttribute("Extension of JsonFormatter by subclassing is obsolete and will be removed in a future Serilog version. Write a custom formatter based on JsonValueFormatter instead. See https://github.com/serilog/serilog/pull/819.")]
protected virtual void WritePropertiesValues(IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output);
    [ObsoleteAttribute("Extension of JsonFormatter by subclassing is obsolete and will be removed in a future Serilog version. Write a custom formatter based on JsonValueFormatter instead. See https://github.com/serilog/serilog/pull/819.")]
protected virtual void WriteException(Exception exception, String& delim, TextWriter output);
    [ObsoleteAttribute("Extension of JsonFormatter by subclassing is obsolete and will be removed in a future Serilog version. Write a custom formatter based on JsonValueFormatter instead. See https://github.com/serilog/serilog/pull/819.")]
protected virtual void WriteRenderedMessage(string message, String& delim, TextWriter output);
    [ObsoleteAttribute("Extension of JsonFormatter by subclassing is obsolete and will be removed in a future Serilog version. Write a custom formatter based on JsonValueFormatter instead. See https://github.com/serilog/serilog/pull/819.")]
protected virtual void WriteMessageTemplate(string template, String& delim, TextWriter output);
    [ObsoleteAttribute("Extension of JsonFormatter by subclassing is obsolete and will be removed in a future Serilog version. Write a custom formatter based on JsonValueFormatter instead. See https://github.com/serilog/serilog/pull/819.")]
protected virtual void WriteLevel(LogEventLevel level, String& delim, TextWriter output);
    [ObsoleteAttribute("Extension of JsonFormatter by subclassing is obsolete and will be removed in a future Serilog version. Write a custom formatter based on JsonValueFormatter instead. See https://github.com/serilog/serilog/pull/819.")]
protected virtual void WriteTimestamp(DateTimeOffset timestamp, String& delim, TextWriter output);
    [ObsoleteAttribute("Extension of JsonFormatter by subclassing is obsolete and will be removed in a future Serilog version. Write a custom formatter based on JsonValueFormatter instead. See https://github.com/serilog/serilog/pull/819.")]
protected virtual void WriteStructure(string typeTag, IEnumerable`1<LogEventProperty> properties, TextWriter output);
    [ObsoleteAttribute("Extension of JsonFormatter by subclassing is obsolete and will be removed in a future Serilog version. Write a custom formatter based on JsonValueFormatter instead. See https://github.com/serilog/serilog/pull/819.")]
protected virtual void WriteSequence(IEnumerable elements, TextWriter output);
    [ObsoleteAttribute("Extension of JsonFormatter by subclassing is obsolete and will be removed in a future Serilog version. Write a custom formatter based on JsonValueFormatter instead. See https://github.com/serilog/serilog/pull/819.")]
protected virtual void WriteDictionary(IReadOnlyDictionary`2<ScalarValue, LogEventPropertyValue> elements, TextWriter output);
    [ObsoleteAttribute("Extension of JsonFormatter by subclassing is obsolete and will be removed in a future Serilog version. Write a custom formatter based on JsonValueFormatter instead. See https://github.com/serilog/serilog/pull/819.")]
protected virtual void WriteJsonProperty(string name, object value, String& precedingDelimiter, TextWriter output);
    [ObsoleteAttribute("Extension of JsonFormatter by subclassing is obsolete and will be removed in a future Serilog version. Write a custom formatter based on JsonValueFormatter instead. See https://github.com/serilog/serilog/pull/819.")]
protected virtual void WriteLiteralValue(object value, TextWriter output);
    private void WriteLiteral(object value, TextWriter output, bool forceQuotation);
    private static void WriteToString(object number, bool quote, TextWriter output);
    private static void WriteBoolean(bool value, TextWriter output);
    private static void WriteSingle(float value, TextWriter output);
    private static void WriteDouble(double value, TextWriter output);
    private static void WriteOffset(DateTimeOffset value, TextWriter output);
    private static void WriteDateTime(DateTime value, TextWriter output);
    private static void WriteString(string value, TextWriter output);
    [ObsoleteAttribute("Use JsonValueFormatter.WriteQuotedJsonString() instead.")]
[EditorBrowsableAttribute("1")]
public static string Escape(string s);
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_7(object v, bool q, TextWriter w);
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_8(object v, bool q, TextWriter w);
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_9(object v, bool q, TextWriter w);
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_10(object v, bool q, TextWriter w);
}
public class Serilog.Formatting.Json.JsonValueFormatter : LogEventPropertyValueVisitor`2<TextWriter, bool> {
    private string _typeTagName;
    private static string DefaultTypeTagName;
    public JsonValueFormatter(string typeTagName);
    public void Format(LogEventPropertyValue value, TextWriter output);
    protected virtual bool VisitScalarValue(TextWriter state, ScalarValue scalar);
    protected virtual bool VisitSequenceValue(TextWriter state, SequenceValue sequence);
    protected virtual bool VisitStructureValue(TextWriter state, StructureValue structure);
    protected virtual bool VisitDictionaryValue(TextWriter state, DictionaryValue dictionary);
    protected virtual void FormatLiteralValue(object value, TextWriter output);
    private static void FormatBooleanValue(bool value, TextWriter output);
    private static void FormatFloatValue(float value, TextWriter output);
    private static void FormatDoubleValue(double value, TextWriter output);
    private static void FormatExactNumericValue(IFormattable value, TextWriter output);
    private static void FormatDateTimeValue(IFormattable value, TextWriter output);
    private static void FormatTimeSpanValue(TimeSpan value, TextWriter output);
    private static void FormatLiteralObjectValue(object value, TextWriter output);
    private static void FormatStringValue(string str, TextWriter output);
    private static void FormatNullValue(TextWriter output);
    public static void WriteQuotedJsonString(string str, TextWriter output);
}
[ObsoleteAttribute("A JSON-based formatter such as `Serilog.Formatting.Compact.CompactJsonFormatter` is recommended for this task.")]
public class Serilog.Formatting.Raw.RawFormatter : object {
    public sealed virtual void Format(LogEvent logEvent, TextWriter output);
}
public interface Serilog.ILogger {
    public abstract virtual ILogger ForContext(ILogEventEnricher enricher);
    public abstract virtual ILogger ForContext(IEnumerable`1<ILogEventEnricher> enrichers);
    public abstract virtual ILogger ForContext(string propertyName, object value, bool destructureObjects);
    public abstract virtual ILogger ForContext();
    public abstract virtual ILogger ForContext(Type source);
    public abstract virtual void Write(LogEvent logEvent);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Write(LogEventLevel level, Exception exception, string messageTemplate, Object[] propertyValues);
    public abstract virtual bool IsEnabled(LogEventLevel level);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Verbose(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Debug(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Information(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Warning(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Error(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual void Fatal(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public abstract virtual bool BindMessageTemplate(string messageTemplate, Object[] propertyValues, MessageTemplate& parsedTemplate, IEnumerable`1& boundProperties);
    public abstract virtual bool BindProperty(string propertyName, object value, bool destructureObjects, LogEventProperty& property);
}
public static class Serilog.Log : object {
    private static ILogger _logger;
    public static ILogger Logger { get; public set; }
    private static Log();
    public static ILogger get_Logger();
    public static void set_Logger(ILogger value);
    public static void CloseAndFlush();
    public static ILogger ForContext(ILogEventEnricher enricher);
    public static ILogger ForContext(ILogEventEnricher[] enrichers);
    public static ILogger ForContext(string propertyName, object value, bool destructureObjects);
    public static ILogger ForContext();
    public static ILogger ForContext(Type source);
    public static void Write(LogEvent logEvent);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Write(LogEventLevel level, Exception exception, string messageTemplate, Object[] propertyValues);
    public static bool IsEnabled(LogEventLevel level);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Verbose(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Debug(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Information(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Warning(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Error(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(Exception exception, string messageTemplate);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(Exception exception, string messageTemplate, T propertyValue);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(Exception exception, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static void Fatal(Exception exception, string messageTemplate, Object[] propertyValues);
    [MessageTemplateFormatMethodAttribute("messageTemplate")]
public static bool BindMessageTemplate(string messageTemplate, Object[] propertyValues, MessageTemplate& parsedTemplate, IEnumerable`1& boundProperties);
    public static bool BindProperty(string propertyName, object value, bool destructureObjects, LogEventProperty& property);
}
public class Serilog.LoggerConfiguration : object {
    private List`1<ILogEventSink> _logEventSinks;
    private List`1<ILogEventSink> _auditSinks;
    private List`1<ILogEventEnricher> _enrichers;
    private List`1<ILogEventFilter> _filters;
    private List`1<Type> _additionalScalarTypes;
    private List`1<IDestructuringPolicy> _additionalDestructuringPolicies;
    private Dictionary`2<string, LoggingLevelSwitch> _overrides;
    private LogEventLevel _minimumLevel;
    private LoggingLevelSwitch _levelSwitch;
    private int _maximumDestructuringDepth;
    private int _maximumStringLength;
    private int _maximumCollectionCount;
    private bool _loggerCreated;
    [CompilerGeneratedAttribute]
private LoggerSinkConfiguration <WriteTo>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggerEnrichmentConfiguration <Enrich>k__BackingField;
    public LoggerSinkConfiguration WriteTo { get; internal set; }
    public LoggerAuditSinkConfiguration AuditTo { get; }
    public LoggerMinimumLevelConfiguration MinimumLevel { get; }
    public LoggerEnrichmentConfiguration Enrich { get; internal set; }
    public LoggerFilterConfiguration Filter { get; }
    public LoggerDestructuringConfiguration Destructure { get; }
    public LoggerSettingsConfiguration ReadFrom { get; }
    [CompilerGeneratedAttribute]
public LoggerSinkConfiguration get_WriteTo();
    [CompilerGeneratedAttribute]
internal void set_WriteTo(LoggerSinkConfiguration value);
    public LoggerAuditSinkConfiguration get_AuditTo();
    public LoggerMinimumLevelConfiguration get_MinimumLevel();
    [CompilerGeneratedAttribute]
public LoggerEnrichmentConfiguration get_Enrich();
    [CompilerGeneratedAttribute]
internal void set_Enrich(LoggerEnrichmentConfiguration value);
    public LoggerFilterConfiguration get_Filter();
    public LoggerDestructuringConfiguration get_Destructure();
    public LoggerSettingsConfiguration get_ReadFrom();
    public Logger CreateLogger();
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_0(ILogEventSink s);
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_1(ILogEventEnricher e);
    [CompilerGeneratedAttribute]
private void <get_AuditTo>b__19_0(ILogEventSink s);
    [CompilerGeneratedAttribute]
private void <get_MinimumLevel>b__21_0(LogEventLevel l);
    [CompilerGeneratedAttribute]
private void <get_MinimumLevel>b__21_1(LoggingLevelSwitch sw);
    [CompilerGeneratedAttribute]
private void <get_MinimumLevel>b__21_2(string s, LoggingLevelSwitch lls);
    [CompilerGeneratedAttribute]
private void <get_Filter>b__27_0(ILogEventFilter f);
    [CompilerGeneratedAttribute]
private void <get_Destructure>b__29_0(int depth);
    [CompilerGeneratedAttribute]
private void <get_Destructure>b__29_1(int length);
    [CompilerGeneratedAttribute]
private void <get_Destructure>b__29_2(int count);
}
[ExtensionAttribute]
public static class Serilog.LoggerExtensions : object {
    [ExtensionAttribute]
public static ILogger ForContext(ILogger logger, LogEventLevel level, string propertyName, TValue value, bool destructureObjects);
}
public class Serilog.Parsing.Alignment : ValueType {
    [CompilerGeneratedAttribute]
private AlignmentDirection <Direction>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    public AlignmentDirection Direction { get; }
    public int Width { get; }
    public Alignment(AlignmentDirection direction, int width);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public AlignmentDirection get_Direction();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Width();
}
public enum Serilog.Parsing.AlignmentDirection : Enum {
    public int value__;
    public static AlignmentDirection Left;
    public static AlignmentDirection Right;
}
public enum Serilog.Parsing.Destructuring : Enum {
    public int value__;
    public static Destructuring Default;
    public static Destructuring Stringify;
    public static Destructuring Destructure;
}
public class Serilog.Parsing.MessageTemplateParser : object {
    public sealed virtual MessageTemplate Parse(string messageTemplate);
    [IteratorStateMachineAttribute("Serilog.Parsing.MessageTemplateParser/<Tokenize>d__1")]
private static IEnumerable`1<MessageTemplateToken> Tokenize(string messageTemplate);
    private static MessageTemplateToken ParsePropertyToken(int startAt, string messageTemplate, Int32& next);
    private static bool TrySplitTagContent(string tagContent, String& propertyNameAndDestructuring, String& format, String& alignment);
    private static bool IsValidInPropertyTag(char c);
    private static bool IsValidInPropertyName(char c);
    private static bool TryGetDestructuringHint(char c, Destructuring& destructuring);
    private static bool IsValidInDestructuringHint(char c);
    private static bool IsValidInAlignment(char c);
    private static bool IsValidInFormat(char c);
    private static TextToken ParseTextToken(int startAt, string messageTemplate, Int32& next);
}
public abstract class Serilog.Parsing.MessageTemplateToken : object {
    [CompilerGeneratedAttribute]
private int <StartIndex>k__BackingField;
    public int StartIndex { get; }
    public int Length { get; }
    protected MessageTemplateToken(int startIndex);
    [CompilerGeneratedAttribute]
public int get_StartIndex();
    public abstract virtual int get_Length();
    public abstract virtual void Render(IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output, IFormatProvider formatProvider);
}
public class Serilog.Parsing.PropertyToken : MessageTemplateToken {
    private string _rawText;
    private Nullable`1<int> _position;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Destructuring <Destructuring>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Alignment> <Alignment>k__BackingField;
    public int Length { get; }
    public string PropertyName { get; }
    public Destructuring Destructuring { get; }
    public string Format { get; }
    public Nullable`1<Alignment> Alignment { get; }
    public bool IsPositional { get; }
    internal string RawText { get; }
    [ObsoleteAttribute("Use named arguments with this method to guarantee forwards-compatibility.")]
[EditorBrowsableAttribute("1")]
public PropertyToken(string propertyName, string rawText, string formatObsolete, Destructuring destructuringObsolete);
    public PropertyToken(string propertyName, string rawText, string format, Nullable`1<Alignment> alignment, Destructuring destructuring, int startIndex);
    public virtual int get_Length();
    public virtual void Render(IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output, IFormatProvider formatProvider);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public Destructuring get_Destructuring();
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public Nullable`1<Alignment> get_Alignment();
    public bool get_IsPositional();
    internal string get_RawText();
    public bool TryGetPositionalValue(Int32& position);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Serilog.Parsing.TextToken : MessageTemplateToken {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public int Length { get; }
    public string Text { get; }
    public TextToken(string text, int startIndex);
    public virtual int get_Length();
    public virtual void Render(IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output, IFormatProvider formatProvider);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public string get_Text();
}
internal class Serilog.Policies.ByteArrayScalarConversionPolicy : object {
    private static int MaximumByteArrayLength;
    public sealed virtual bool TryConvertToScalar(object value, ScalarValue& result);
}
internal class Serilog.Policies.DelegateDestructuringPolicy : object {
    public sealed virtual bool TryDestructure(object value, ILogEventPropertyValueFactory propertyValueFactory, LogEventPropertyValue& result);
}
internal class Serilog.Policies.EnumScalarConversionPolicy : object {
    public sealed virtual bool TryConvertToScalar(object value, ScalarValue& result);
}
internal class Serilog.Policies.ProjectedDestructuringPolicy : object {
    private Func`2<Type, bool> _canApply;
    private Func`2<object, object> _projection;
    public ProjectedDestructuringPolicy(Func`2<Type, bool> canApply, Func`2<object, object> projection);
    public sealed virtual bool TryDestructure(object value, ILogEventPropertyValueFactory propertyValueFactory, LogEventPropertyValue& result);
}
internal class Serilog.Policies.ReflectionTypesScalarDestructuringPolicy : object {
    public sealed virtual bool TryDestructure(object value, ILogEventPropertyValueFactory propertyValueFactory, LogEventPropertyValue& result);
}
internal class Serilog.Policies.SimpleScalarConversionPolicy : object {
    private HashSet`1<Type> _scalarTypes;
    public SimpleScalarConversionPolicy(IEnumerable`1<Type> scalarTypes);
    public sealed virtual bool TryConvertToScalar(object value, ScalarValue& result);
}
internal static class Serilog.Rendering.Casing : object {
    public static string Format(string value, string format);
}
internal static class Serilog.Rendering.MessageTemplateRenderer : object {
    private static JsonValueFormatter JsonValueFormatter;
    private static MessageTemplateRenderer();
    public static void Render(MessageTemplate messageTemplate, IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output, string format, IFormatProvider formatProvider);
    public static void RenderTextToken(TextToken tt, TextWriter output);
    public static void RenderPropertyToken(PropertyToken pt, IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output, IFormatProvider formatProvider, bool isLiteral, bool isJson);
    private static void RenderValue(LogEventPropertyValue propertyValue, bool literal, bool json, TextWriter output, string format, IFormatProvider formatProvider);
}
internal static class Serilog.Rendering.Padding : object {
    private static Char[] PaddingChars;
    private static Padding();
    public static void Apply(TextWriter output, string value, Nullable`1<Alignment> alignment);
}
public enum Serilog.RollingInterval : Enum {
    public int value__;
    public static RollingInterval Infinite;
    public static RollingInterval Year;
    public static RollingInterval Month;
    public static RollingInterval Day;
    public static RollingInterval Hour;
    public static RollingInterval Minute;
}
internal static class Serilog.Settings.KeyValuePairs.CallableConfigurationMethodFinder : object {
    internal static IList`1<MethodInfo> FindConfigurationMethods(IEnumerable`1<Assembly> configurationAssemblies, Type configType);
}
internal class Serilog.Settings.KeyValuePairs.KeyValuePairSettings : object {
    private static string UsingDirective;
    private static string LevelSwitchDirective;
    private static string AuditToDirective;
    private static string WriteToDirective;
    private static string MinimumLevelDirective;
    private static string MinimumLevelControlledByDirective;
    private static string EnrichWithDirective;
    private static string EnrichWithPropertyDirective;
    private static string FilterDirective;
    private static string DestructureDirective;
    private static string UsingDirectiveFullFormPrefix;
    private static string EnrichWithPropertyDirectivePrefix;
    private static string MinimumLevelOverrideDirectivePrefix;
    private static string CallableDirectiveRegex;
    private static string LevelSwitchDeclarationDirectiveRegex;
    private static string LevelSwitchNameRegex;
    private static String[] _supportedDirectives;
    private static Dictionary`2<string, Type> CallableDirectiveReceiverTypes;
    private static Dictionary`2<Type, Func`2<LoggerConfiguration, object>> CallableDirectiveReceivers;
    private IReadOnlyDictionary`2<string, string> _settings;
    public KeyValuePairSettings(IReadOnlyDictionary`2<string, string> settings);
    private static KeyValuePairSettings();
    public sealed virtual void Configure(LoggerConfiguration loggerConfiguration);
    internal static bool IsValidSwitchName(string input);
    private static IReadOnlyDictionary`2<string, LoggingLevelSwitch> ParseNamedLevelSwitchDeclarationDirectives(IReadOnlyDictionary`2<string, string> directives);
    private static LoggingLevelSwitch LookUpSwitchByName(string switchName, IReadOnlyDictionary`2<string, LoggingLevelSwitch> declaredLevelSwitches);
    private static object ConvertOrLookupByName(string valueOrSwitchName, Type type, IReadOnlyDictionary`2<string, LoggingLevelSwitch> declaredSwitches);
    private static void ApplyDirectives(List`1<IGrouping`2<string, ConfigurationMethodCall>> directives, IList`1<MethodInfo> configurationMethods, object loggerConfigMethod, IReadOnlyDictionary`2<string, LoggingLevelSwitch> declaredSwitches);
    internal static MethodInfo SelectConfigurationMethod(IEnumerable`1<MethodInfo> candidateMethods, string name, IEnumerable`1<ConfigurationMethodCall> suppliedArgumentValues);
    internal static IEnumerable`1<Assembly> LoadConfigurationAssemblies(IReadOnlyDictionary`2<string, string> directives);
}
internal class Serilog.Settings.KeyValuePairs.SettingValueConversions : object {
    private static Regex StaticMemberAccessorRegex;
    private static Dictionary`2<Type, Func`2<string, object>> ExtendedTypeConversions;
    private static SettingValueConversions();
    public static object ConvertToType(string value, Type toType);
    internal static bool TryParseStaticMemberAccessor(string input, String& accessorTypeName, String& memberName);
}
internal static class Serilog.Settings.KeyValuePairs.SurrogateConfigurationMethods : object {
    private static Dictionary`2<Type, MethodInfo[]> SurrogateMethodCandidates;
    internal static MethodInfo[] WriteTo;
    internal static MethodInfo[] AuditTo;
    internal static MethodInfo[] Enrich;
    internal static MethodInfo[] Destructure;
    internal static MethodInfo[] Filter;
    private static SurrogateConfigurationMethods();
    internal static LoggerConfiguration Sink(LoggerSinkConfiguration loggerSinkConfiguration, ILogEventSink sink, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    internal static LoggerConfiguration Sink(LoggerAuditSinkConfiguration auditSinkConfiguration, ILogEventSink sink, LogEventLevel restrictedToMinimumLevel, LoggingLevelSwitch levelSwitch);
    internal static LoggerConfiguration With(LoggerEnrichmentConfiguration loggerEnrichmentConfiguration, ILogEventEnricher enricher);
    internal static LoggerConfiguration FromLogContext(LoggerEnrichmentConfiguration loggerEnrichmentConfiguration);
    internal static LoggerConfiguration With(LoggerDestructuringConfiguration loggerDestructuringConfiguration, IDestructuringPolicy policy);
    internal static LoggerConfiguration AsScalar(LoggerDestructuringConfiguration loggerDestructuringConfiguration, Type scalarType);
    internal static LoggerConfiguration ToMaximumCollectionCount(LoggerDestructuringConfiguration loggerDestructuringConfiguration, int maximumCollectionCount);
    internal static LoggerConfiguration ToMaximumDepth(LoggerDestructuringConfiguration loggerDestructuringConfiguration, int maximumDestructuringDepth);
    internal static LoggerConfiguration ToMaximumStringLength(LoggerDestructuringConfiguration loggerDestructuringConfiguration, int maximumStringLength);
    internal static LoggerConfiguration With(LoggerFilterConfiguration loggerFilterConfiguration, ILogEventFilter filter);
}
internal static class Serilog.Sinks.File.Clock : object {
    [NullableAttribute("1")]
private static Func`1<DateTime> _dateTimeNow;
    [ThreadStaticAttribute]
private static DateTime _testDateTimeNow;
    public static DateTime DateTimeNow { get; }
    private static Clock();
    public static DateTime get_DateTimeNow();
    public static void SetTestDateTimeNow(DateTime now);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.File.FileLifeCycleHookChain : FileLifecycleHooks {
    private FileLifecycleHooks _first;
    private FileLifecycleHooks _second;
    public FileLifeCycleHookChain(FileLifecycleHooks first, FileLifecycleHooks second);
    public virtual Stream OnFileOpened(string path, Stream underlyingStream, Encoding encoding);
    public virtual void OnFileDeleting(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Serilog.Sinks.File.FileLifecycleHooks : object {
    public virtual Stream OnFileOpened(string path, Stream underlyingStream, Encoding encoding);
    public virtual Stream OnFileOpened(Stream underlyingStream, Encoding encoding);
    public virtual void OnFileDeleting(string path);
    public FileLifecycleHooks Then(FileLifecycleHooks next);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Serilog.Sinks.File.FileSink : object {
    private TextWriter _output;
    private FileStream _underlyingStream;
    private ITextFormatter _textFormatter;
    private Nullable`1<long> _fileSizeLimitBytes;
    private bool _buffered;
    private object _syncRoot;
    [NullableAttribute("2")]
private WriteCountingStream _countingStreamWrapper;
    [ObsoleteAttribute("This type and constructor will be removed from the public API in a future version; use `WriteTo.File()` instead.")]
public FileSink(string path, ITextFormatter textFormatter, Nullable`1<long> fileSizeLimitBytes, Encoding encoding, bool buffered);
    internal FileSink(string path, ITextFormatter textFormatter, Nullable`1<long> fileSizeLimitBytes, Encoding encoding, bool buffered, FileLifecycleHooks hooks);
    private sealed virtual override bool Serilog.Sinks.File.IFileSink.EmitOrOverflow(LogEvent logEvent);
    public sealed virtual void Emit(LogEvent logEvent);
    public sealed virtual void Dispose();
    public sealed virtual void FlushToDisk();
}
internal interface Serilog.Sinks.File.IFileSink {
    [NullableContextAttribute("1")]
public abstract virtual bool EmitOrOverflow(LogEvent logEvent);
}
public interface Serilog.Sinks.File.IFlushableFileSink {
    public abstract virtual void FlushToDisk();
}
internal static class Serilog.Sinks.File.IOErrors : object {
    [NullableContextAttribute("1")]
public static bool IsLockedFile(IOException ex);
}
internal class Serilog.Sinks.File.NullSink : object {
    [NullableContextAttribute("1")]
public sealed virtual void Emit(LogEvent logEvent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.File.PathRoller : object {
    private static string PeriodMatchGroup;
    private static string SequenceNumberMatchGroup;
    private string _directory;
    private string _filenamePrefix;
    private string _filenameSuffix;
    private Regex _filenameMatcher;
    private RollingInterval _interval;
    private string _periodFormat;
    [CompilerGeneratedAttribute]
private string <DirectorySearchPattern>k__BackingField;
    public string LogFileDirectory { get; }
    public string DirectorySearchPattern { get; }
    public PathRoller(string path, RollingInterval interval);
    public string get_LogFileDirectory();
    [CompilerGeneratedAttribute]
public string get_DirectorySearchPattern();
    public void GetLogFilePath(DateTime date, Nullable`1<int> sequenceNumber, String& path);
    [IteratorStateMachineAttribute("Serilog.Sinks.File.PathRoller/<SelectMatches>d__15")]
public IEnumerable`1<RollingLogFile> SelectMatches(IEnumerable`1<string> filenames);
    public Nullable`1<DateTime> GetCurrentCheckpoint(DateTime instant);
    public Nullable`1<DateTime> GetNextCheckpoint(DateTime instant);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("This type will be removed from the public API in a future version; use `WriteTo.File(flushToDiskInterval:)` instead.")]
public class Serilog.Sinks.File.PeriodicFlushToDiskSink : object {
    private ILogEventSink _sink;
    private Timer _timer;
    private int _flushRequired;
    public PeriodicFlushToDiskSink(ILogEventSink sink, TimeSpan flushInterval);
    public sealed virtual void Emit(LogEvent logEvent);
    public sealed virtual void Dispose();
    private void FlushToDisk(IFlushableFileSink flushable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.File.RollingFileSink : object {
    private PathRoller _roller;
    private ITextFormatter _textFormatter;
    private Nullable`1<long> _fileSizeLimitBytes;
    private Nullable`1<int> _retainedFileCountLimit;
    private Nullable`1<TimeSpan> _retainedFileTimeLimit;
    [NullableAttribute("2")]
private Encoding _encoding;
    private bool _buffered;
    private bool _shared;
    private bool _rollOnFileSizeLimit;
    [NullableAttribute("2")]
private FileLifecycleHooks _hooks;
    private object _syncRoot;
    private bool _isDisposed;
    private Nullable`1<DateTime> _nextCheckpoint;
    [NullableAttribute("2")]
private IFileSink _currentFile;
    private Nullable`1<int> _currentFileSequence;
    public RollingFileSink(string path, ITextFormatter textFormatter, Nullable`1<long> fileSizeLimitBytes, Nullable`1<int> retainedFileCountLimit, Encoding encoding, bool buffered, bool shared, RollingInterval rollingInterval, bool rollOnFileSizeLimit, FileLifecycleHooks hooks, Nullable`1<TimeSpan> retainedFileTimeLimit);
    public sealed virtual void Emit(LogEvent logEvent);
    private void AlignCurrentFileTo(DateTime now, bool nextSequence);
    private void OpenFile(DateTime now, Nullable`1<int> minSequence);
    private void ApplyRetentionPolicy(string currentFilePath, DateTime now);
    private bool ShouldRetainFile(RollingLogFile file, int index, DateTime now);
    public sealed virtual void Dispose();
    private void CloseFile();
    public sealed virtual void FlushToDisk();
}
[ExtensionAttribute]
internal static class Serilog.Sinks.File.RollingIntervalExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetFormat(RollingInterval interval);
    [ExtensionAttribute]
public static Nullable`1<DateTime> GetCurrentCheckpoint(RollingInterval interval, DateTime instant);
    [ExtensionAttribute]
public static Nullable`1<DateTime> GetNextCheckpoint(RollingInterval interval, DateTime instant);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.File.RollingLogFile : object {
    [CompilerGeneratedAttribute]
private string <Filename>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <DateTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <SequenceNumber>k__BackingField;
    public string Filename { get; }
    public Nullable`1<DateTime> DateTime { get; }
    public Nullable`1<int> SequenceNumber { get; }
    public RollingLogFile(string filename, Nullable`1<DateTime> dateTime, Nullable`1<int> sequenceNumber);
    [CompilerGeneratedAttribute]
public string get_Filename();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_DateTime();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_SequenceNumber();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("This type will be removed from the public API in a future version; use `WriteTo.File(shared: true)` instead.")]
public class Serilog.Sinks.File.SharedFileSink : object {
    private TextWriter _output;
    private FileStream _underlyingStream;
    private ITextFormatter _textFormatter;
    private Nullable`1<long> _fileSizeLimitBytes;
    private object _syncRoot;
    private static string MutexNameSuffix;
    private static int MutexWaitTimeout;
    private Mutex _mutex;
    public SharedFileSink(string path, ITextFormatter textFormatter, Nullable`1<long> fileSizeLimitBytes, Encoding encoding);
    private sealed virtual override bool Serilog.Sinks.File.IFileSink.EmitOrOverflow(LogEvent logEvent);
    public sealed virtual void Emit(LogEvent logEvent);
    public sealed virtual void Dispose();
    public sealed virtual void FlushToDisk();
    private bool TryAcquireMutex();
    private void ReleaseMutex();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Sinks.File.WriteCountingStream : Stream {
    private Stream _stream;
    [CompilerGeneratedAttribute]
private long <CountedLength>k__BackingField;
    public long CountedLength { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public WriteCountingStream(Stream stream);
    [CompilerGeneratedAttribute]
public long get_CountedLength();
    [CompilerGeneratedAttribute]
private void set_CountedLength(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.ConsoleSink : object {
    private Nullable`1<LogEventLevel> _standardErrorFromLevel;
    private ConsoleTheme _theme;
    private ITextFormatter _formatter;
    private object _syncRoot;
    private static int DefaultWriteBufferCapacity;
    private static ConsoleSink();
    public ConsoleSink(ConsoleTheme theme, ITextFormatter formatter, Nullable`1<LogEventLevel> standardErrorFromLevel, object syncRoot);
    public sealed virtual void Emit(LogEvent logEvent);
    private TextWriter SelectOutputStream(LogEventLevel logEventLevel);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Formatting.ThemedDisplayValueFormatter : ThemedValueFormatter {
    [<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("2")]
private IFormatProvider _formatProvider;
    public ThemedDisplayValueFormatter(ConsoleTheme theme, IFormatProvider formatProvider);
    public virtual ThemedValueFormatter SwitchTheme(ConsoleTheme theme);
    protected virtual int VisitScalarValue(ThemedValueFormatterState state, ScalarValue scalar);
    protected virtual int VisitSequenceValue(ThemedValueFormatterState state, SequenceValue sequence);
    protected virtual int VisitStructureValue(ThemedValueFormatterState state, StructureValue structure);
    protected virtual int VisitDictionaryValue(ThemedValueFormatterState state, DictionaryValue dictionary);
    public int FormatLiteralValue(ScalarValue scalar, TextWriter output, string format);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Formatting.ThemedJsonValueFormatter : ThemedValueFormatter {
    private ThemedDisplayValueFormatter _displayFormatter;
    [<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("2")]
private IFormatProvider _formatProvider;
    public ThemedJsonValueFormatter(ConsoleTheme theme, IFormatProvider formatProvider);
    public virtual ThemedValueFormatter SwitchTheme(ConsoleTheme theme);
    protected virtual int VisitScalarValue(ThemedValueFormatterState state, ScalarValue scalar);
    protected virtual int VisitSequenceValue(ThemedValueFormatterState state, SequenceValue sequence);
    protected virtual int VisitStructureValue(ThemedValueFormatterState state, StructureValue structure);
    protected virtual int VisitDictionaryValue(ThemedValueFormatterState state, DictionaryValue dictionary);
    private int FormatLiteralValue(ScalarValue scalar, TextWriter output);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal abstract class Serilog.Sinks.SystemConsole.Formatting.ThemedValueFormatter : LogEventPropertyValueVisitor`2<ThemedValueFormatterState, int> {
    private ConsoleTheme _theme;
    protected ThemedValueFormatter(ConsoleTheme theme);
    protected StyleReset ApplyStyle(TextWriter output, ConsoleThemeStyle style, Int32& invisibleCharacterCount);
    public int Format(LogEventPropertyValue value, TextWriter output, string format, bool literalTopLevel);
    public abstract virtual ThemedValueFormatter SwitchTheme(ConsoleTheme theme);
}
internal class Serilog.Sinks.SystemConsole.Formatting.ThemedValueFormatterState : ValueType {
    [<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("1")]
public TextWriter Output;
    [<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("2")]
public string Format;
    public bool IsTopLevel;
    public ThemedValueFormatterState Nest();
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Output.EventPropertyTokenRenderer : OutputTemplateTokenRenderer {
    private ConsoleTheme _theme;
    private PropertyToken _token;
    [<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("2")]
private IFormatProvider _formatProvider;
    public EventPropertyTokenRenderer(ConsoleTheme theme, PropertyToken token, IFormatProvider formatProvider);
    public virtual void Render(LogEvent logEvent, TextWriter output);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Output.ExceptionTokenRenderer : OutputTemplateTokenRenderer {
    private static string StackFrameLinePrefix;
    private ConsoleTheme _theme;
    public ExceptionTokenRenderer(ConsoleTheme theme, PropertyToken pt);
    public virtual void Render(LogEvent logEvent, TextWriter output);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal static class Serilog.Sinks.SystemConsole.Output.LevelOutputFormat : object {
    private static String[][] TitleCaseLevelMap;
    private static String[][] LowercaseLevelMap;
    private static String[][] UppercaseLevelMap;
    private static LevelOutputFormat();
    public static string GetLevelMoniker(LogEventLevel value, string format);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Output.LevelTokenRenderer : OutputTemplateTokenRenderer {
    private ConsoleTheme _theme;
    private PropertyToken _levelToken;
    private static Dictionary`2<LogEventLevel, ConsoleThemeStyle> Levels;
    public LevelTokenRenderer(ConsoleTheme theme, PropertyToken levelToken);
    private static LevelTokenRenderer();
    public virtual void Render(LogEvent logEvent, TextWriter output);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Output.MessageTemplateOutputTokenRenderer : OutputTemplateTokenRenderer {
    private ConsoleTheme _theme;
    private PropertyToken _token;
    private ThemedMessageTemplateRenderer _renderer;
    public MessageTemplateOutputTokenRenderer(ConsoleTheme theme, PropertyToken token, IFormatProvider formatProvider);
    public virtual void Render(LogEvent logEvent, TextWriter output);
}
internal class Serilog.Sinks.SystemConsole.Output.NewLineTokenRenderer : OutputTemplateTokenRenderer {
    private Nullable`1<Alignment> _alignment;
    public NewLineTokenRenderer(Nullable`1<Alignment> alignment);
    [<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
public virtual void Render(LogEvent logEvent, TextWriter output);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Output.OutputTemplateRenderer : object {
    private OutputTemplateTokenRenderer[] _renderers;
    public OutputTemplateRenderer(ConsoleTheme theme, string outputTemplate, IFormatProvider formatProvider);
    public sealed virtual void Format(LogEvent logEvent, TextWriter output);
}
internal abstract class Serilog.Sinks.SystemConsole.Output.OutputTemplateTokenRenderer : object {
    [<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
public abstract virtual void Render(LogEvent logEvent, TextWriter output);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Output.PropertiesTokenRenderer : OutputTemplateTokenRenderer {
    private MessageTemplate _outputTemplate;
    private ConsoleTheme _theme;
    private PropertyToken _token;
    private ThemedValueFormatter _valueFormatter;
    public PropertiesTokenRenderer(ConsoleTheme theme, PropertyToken token, MessageTemplate outputTemplate, IFormatProvider formatProvider);
    public virtual void Render(LogEvent logEvent, TextWriter output);
    private static bool TemplateContainsPropertyName(MessageTemplate template, string propertyName);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Output.TextTokenRenderer : OutputTemplateTokenRenderer {
    private ConsoleTheme _theme;
    private string _text;
    public TextTokenRenderer(ConsoleTheme theme, string text);
    public virtual void Render(LogEvent logEvent, TextWriter output);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Output.TimestampTokenRenderer : OutputTemplateTokenRenderer {
    private ConsoleTheme _theme;
    private PropertyToken _token;
    [<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("2")]
private IFormatProvider _formatProvider;
    public TimestampTokenRenderer(ConsoleTheme theme, PropertyToken token, IFormatProvider formatProvider);
    public virtual void Render(LogEvent logEvent, TextWriter output);
}
internal static class Serilog.Sinks.SystemConsole.Platform.WindowsConsole : object {
    private static int StandardOutputHandleId;
    private static UInt32 EnableVirtualTerminalProcessingMode;
    private static long InvalidHandleValue;
    public static void EnableVirtualTerminalProcessing();
    private static IntPtr GetStdHandle(int handleId);
    private static bool GetConsoleMode(IntPtr handle, UInt32& mode);
    private static bool SetConsoleMode(IntPtr handle, UInt32 mode);
}
[ExtensionAttribute]
internal static class Serilog.Sinks.SystemConsole.Rendering.AlignmentExtensions : object {
    [ExtensionAttribute]
public static Alignment Widen(Alignment alignment, int amount);
}
internal static class Serilog.Sinks.SystemConsole.Rendering.Casing : object {
    [<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
public static string Format(string value, string format);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal static class Serilog.Sinks.SystemConsole.Rendering.Padding : object {
    private static Char[] PaddingChars;
    private static Padding();
    public static void Apply(TextWriter output, string value, Nullable`1<Alignment> alignment);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Rendering.ThemedMessageTemplateRenderer : object {
    private ConsoleTheme _theme;
    private ThemedValueFormatter _valueFormatter;
    private bool _isLiteral;
    private static ConsoleTheme NoTheme;
    private ThemedValueFormatter _unthemedValueFormatter;
    public ThemedMessageTemplateRenderer(ConsoleTheme theme, ThemedValueFormatter valueFormatter, bool isLiteral);
    private static ThemedMessageTemplateRenderer();
    public int Render(MessageTemplate template, IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output);
    private int RenderTextToken(TextToken tt, TextWriter output);
    private int RenderPropertyToken(PropertyToken pt, IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, TextWriter output);
    private int RenderAlignedPropertyTokenUnbuffered(PropertyToken pt, TextWriter output, LogEventPropertyValue propertyValue);
    private int RenderValue(ConsoleTheme theme, ThemedValueFormatter valueFormatter, LogEventPropertyValue propertyValue, TextWriter output, string format);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
public class Serilog.Sinks.SystemConsole.Themes.AnsiConsoleTheme : ConsoleTheme {
    [CompilerGeneratedAttribute]
private static AnsiConsoleTheme <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private static AnsiConsoleTheme <Grayscale>k__BackingField;
    [CompilerGeneratedAttribute]
private static AnsiConsoleTheme <Literate>k__BackingField;
    private IReadOnlyDictionary`2<ConsoleThemeStyle, string> _styles;
    private static string AnsiStyleReset;
    [CompilerGeneratedAttribute]
private int <ResetCharCount>k__BackingField;
    public static AnsiConsoleTheme Code { get; }
    public static AnsiConsoleTheme Grayscale { get; }
    public static AnsiConsoleTheme Literate { get; }
    public bool CanBuffer { get; }
    protected int ResetCharCount { get; }
    public AnsiConsoleTheme(IReadOnlyDictionary`2<ConsoleThemeStyle, string> styles);
    private static AnsiConsoleTheme();
    [CompilerGeneratedAttribute]
public static AnsiConsoleTheme get_Code();
    [CompilerGeneratedAttribute]
public static AnsiConsoleTheme get_Grayscale();
    [CompilerGeneratedAttribute]
public static AnsiConsoleTheme get_Literate();
    public virtual bool get_CanBuffer();
    [CompilerGeneratedAttribute]
protected virtual int get_ResetCharCount();
    public virtual int Set(TextWriter output, ConsoleThemeStyle style);
    public virtual void Reset(TextWriter output);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal static class Serilog.Sinks.SystemConsole.Themes.AnsiConsoleThemes : object {
    [CompilerGeneratedAttribute]
private static AnsiConsoleTheme <Literate>k__BackingField;
    [CompilerGeneratedAttribute]
private static AnsiConsoleTheme <Grayscale>k__BackingField;
    [CompilerGeneratedAttribute]
private static AnsiConsoleTheme <Code>k__BackingField;
    public static AnsiConsoleTheme Literate { get; }
    public static AnsiConsoleTheme Grayscale { get; }
    public static AnsiConsoleTheme Code { get; }
    private static AnsiConsoleThemes();
    [CompilerGeneratedAttribute]
public static AnsiConsoleTheme get_Literate();
    [CompilerGeneratedAttribute]
public static AnsiConsoleTheme get_Grayscale();
    [CompilerGeneratedAttribute]
public static AnsiConsoleTheme get_Code();
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
public abstract class Serilog.Sinks.SystemConsole.Themes.ConsoleTheme : object {
    [CompilerGeneratedAttribute]
private static ConsoleTheme <None>k__BackingField;
    public static ConsoleTheme None { get; }
    public bool CanBuffer { get; }
    protected int ResetCharCount { get; }
    private static ConsoleTheme();
    [CompilerGeneratedAttribute]
public static ConsoleTheme get_None();
    public abstract virtual bool get_CanBuffer();
    public abstract virtual int Set(TextWriter output, ConsoleThemeStyle style);
    public abstract virtual void Reset(TextWriter output);
    protected abstract virtual int get_ResetCharCount();
    internal StyleReset Apply(TextWriter output, ConsoleThemeStyle style, Int32& invisibleCharacterCount);
}
public enum Serilog.Sinks.SystemConsole.Themes.ConsoleThemeStyle : Enum {
    public int value__;
    public static ConsoleThemeStyle Text;
    public static ConsoleThemeStyle SecondaryText;
    public static ConsoleThemeStyle TertiaryText;
    public static ConsoleThemeStyle Invalid;
    public static ConsoleThemeStyle Null;
    public static ConsoleThemeStyle Name;
    public static ConsoleThemeStyle String;
    public static ConsoleThemeStyle Number;
    public static ConsoleThemeStyle Boolean;
    public static ConsoleThemeStyle Scalar;
    [ObsoleteAttribute("Use ConsoleThemeStyle.Scalar instead")]
[EditorBrowsableAttribute("1")]
public static ConsoleThemeStyle Object;
    public static ConsoleThemeStyle LevelVerbose;
    public static ConsoleThemeStyle LevelDebug;
    public static ConsoleThemeStyle LevelInformation;
    public static ConsoleThemeStyle LevelWarning;
    public static ConsoleThemeStyle LevelError;
    public static ConsoleThemeStyle LevelFatal;
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Themes.EmptyConsoleTheme : ConsoleTheme {
    [CompilerGeneratedAttribute]
private int <ResetCharCount>k__BackingField;
    public bool CanBuffer { get; }
    protected int ResetCharCount { get; }
    public virtual bool get_CanBuffer();
    [CompilerGeneratedAttribute]
protected virtual int get_ResetCharCount();
    public virtual int Set(TextWriter output, ConsoleThemeStyle style);
    public virtual void Reset(TextWriter output);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal class Serilog.Sinks.SystemConsole.Themes.StyleReset : ValueType {
    private ConsoleTheme _theme;
    private TextWriter _output;
    public StyleReset(ConsoleTheme theme, TextWriter output);
    public sealed virtual void Dispose();
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
public class Serilog.Sinks.SystemConsole.Themes.SystemConsoleTheme : ConsoleTheme {
    [CompilerGeneratedAttribute]
private static SystemConsoleTheme <Grayscale>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemConsoleTheme <Literate>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemConsoleTheme <Colored>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<ConsoleThemeStyle, SystemConsoleThemeStyle> <Styles>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ResetCharCount>k__BackingField;
    public static SystemConsoleTheme Grayscale { get; }
    public static SystemConsoleTheme Literate { get; }
    public static SystemConsoleTheme Colored { get; }
    public IReadOnlyDictionary`2<ConsoleThemeStyle, SystemConsoleThemeStyle> Styles { get; }
    public bool CanBuffer { get; }
    protected int ResetCharCount { get; }
    public SystemConsoleTheme(IReadOnlyDictionary`2<ConsoleThemeStyle, SystemConsoleThemeStyle> styles);
    private static SystemConsoleTheme();
    [CompilerGeneratedAttribute]
public static SystemConsoleTheme get_Grayscale();
    [CompilerGeneratedAttribute]
public static SystemConsoleTheme get_Literate();
    [CompilerGeneratedAttribute]
public static SystemConsoleTheme get_Colored();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<ConsoleThemeStyle, SystemConsoleThemeStyle> get_Styles();
    public virtual bool get_CanBuffer();
    [CompilerGeneratedAttribute]
protected virtual int get_ResetCharCount();
    public virtual int Set(TextWriter output, ConsoleThemeStyle style);
    public virtual void Reset(TextWriter output);
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
internal static class Serilog.Sinks.SystemConsole.Themes.SystemConsoleThemes : object {
    [CompilerGeneratedAttribute]
private static SystemConsoleTheme <Literate>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemConsoleTheme <Grayscale>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemConsoleTheme <Colored>k__BackingField;
    public static SystemConsoleTheme Literate { get; }
    public static SystemConsoleTheme Grayscale { get; }
    public static SystemConsoleTheme Colored { get; }
    private static SystemConsoleThemes();
    [CompilerGeneratedAttribute]
public static SystemConsoleTheme get_Literate();
    [CompilerGeneratedAttribute]
public static SystemConsoleTheme get_Grayscale();
    [CompilerGeneratedAttribute]
public static SystemConsoleTheme get_Colored();
}
public class Serilog.Sinks.SystemConsole.Themes.SystemConsoleThemeStyle : ValueType {
    public Nullable`1<ConsoleColor> Foreground;
    public Nullable`1<ConsoleColor> Background;
}
[ExtensionAttribute]
public static class Serilog.ThreadLoggerConfigurationExtensions : object {
    [ExtensionAttribute]
public static LoggerConfiguration WithThreadId(LoggerEnrichmentConfiguration enrichmentConfiguration);
    [ExtensionAttribute]
public static LoggerConfiguration WithThreadName(LoggerEnrichmentConfiguration enrichmentConfiguration);
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<132b592e-de03-465b-8848-995166f9a3bf>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<336a2475-2dec-4533-8192-879acbcfad01>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<46454838-2a2c-49c0-b611-bc6eab34bce5>MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <46454838-2a2c-49c0-b611-bc6eab34bce5>MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<47dec5e8-3d30-4753-9682-ac8b8d032937>NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<717bca22-d9f1-4d12-9f0a-506874e76d75>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<73c42a32-4ad9-42d8-96a0-06fef7f5d083>DisallowNullAttribute : Attribute {
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<7494167f-b0e3-4485-a731-bb4db4195569>MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public <7494167f-b0e3-4485-a731-bb4db4195569>MemberNotNullWhenAttribute(bool returnValue, string member);
    public <7494167f-b0e3-4485-a731-bb4db4195569>MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<788f9afa-ce5c-4c81-9809-81497164a9da>MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public <788f9afa-ce5c-4c81-9809-81497164a9da>MemberNotNullAttribute(string member);
    public <788f9afa-ce5c-4c81-9809-81497164a9da>MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.<840d761f-1ec4-423b-9c77-f11b106d5e22>NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public <840d761f-1ec4-423b-9c77-f11b106d5e22>NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<87123e78-d0ac-427c-a355-146a10750ca6>NotNullAttribute : Attribute {
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[AttributeUsageAttribute("448")]
internal class System.Diagnostics.CodeAnalysis.<8c2af8bd-0e45-408b-bda9-968e24137dbc>MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public <8c2af8bd-0e45-408b-bda9-968e24137dbc>MemberNotNullWhenAttribute(bool returnValue, string member);
    public <8c2af8bd-0e45-408b-bda9-968e24137dbc>MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<9bf7da57-6527-44c3-9f62-9752334294e2>DoesNotReturnAttribute : Attribute {
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<a2669634-7616-4117-9cd6-f89fab53edce>MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public <a2669634-7616-4117-9cd6-f89fab53edce>MemberNotNullAttribute(string member);
    public <a2669634-7616-4117-9cd6-f89fab53edce>MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<a799475e-2225-4c75-bfb9-8c086b70d14a>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public <a799475e-2225-4c75-bfb9-8c086b70d14a>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<b53a57b1-31b4-458a-91b1-88dc1451108f>MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <b53a57b1-31b4-458a-91b1-88dc1451108f>MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<c9c09d48-0b24-4d65-884a-0126c27c6649>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <c9c09d48-0b24-4d65-884a-0126c27c6649>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<dc5e4b22-5fb6-421e-ac20-a32beb9eb8e2>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<e51d4fe6-9eee-44cd-bb7c-01a41cd9fc54>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public <e51d4fe6-9eee-44cd-bb7c-01a41cd9fc54>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute("1")]
[<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<ea18bfec-a25d-478e-9646-dd10bbc41350>NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public <ea18bfec-a25d-478e-9646-dd10bbc41350>NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<f3307c8c-9ed2-4428-a1eb-d9787f7c7bae>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <f3307c8c-9ed2-4428-a1eb-d9787f7c7bae>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.<f65dc85a-eee6-406b-bb85-472d872eae7c>DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<f7396906-b424-45c3-a400-3ca6eb0a2a2c>DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[<464b1da7-2850-4f6e-b645-1ecc5491e1de>EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.<0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public <0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute(byte );
    public <0a8a35ef-3259-4371-91a4-0a36bd2d8f65>NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[<464b1da7-2850-4f6e-b645-1ecc5491e1de>EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.<13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute : Attribute {
    public byte Flag;
    public <13b20f7e-2a9a-470e-9ae7-4a4f3e42ed7b>NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[<7d269b2f-849d-40f4-86fc-5805e8f0b1b5>EmbeddedAttribute]
internal class System.Runtime.CompilerServices.<244bebf6-3496-425e-992b-874f8cb87e3a>IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[<65dae668-034e-42f6-9c81-6d0733d90d8f>EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.<27db1fa8-cc45-4ef1-bee9-b6d600dd729c>NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public <27db1fa8-cc45-4ef1-bee9-b6d600dd729c>NullableAttribute(byte );
    public <27db1fa8-cc45-4ef1-bee9-b6d600dd729c>NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[<7d269b2f-849d-40f4-86fc-5805e8f0b1b5>EmbeddedAttribute]
internal class System.Runtime.CompilerServices.<38a4eff7-7a49-47b5-aea6-62ba43680c54>IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[<0abd5fd1-b98f-46d0-a587-6ff50f776e07>EmbeddedAttribute]
internal class System.Runtime.CompilerServices.<5addcc8f-3e2e-417c-9888-d86515e9ac25>IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[<0abd5fd1-b98f-46d0-a587-6ff50f776e07>EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.<62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public <62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute(byte );
    public <62ed02a6-eb79-49be-a965-d274551050cb>NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[<7d269b2f-849d-40f4-86fc-5805e8f0b1b5>EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public <65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute(byte );
    public <65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[<0c8f9499-07fc-4e51-9581-dbc8ddaed996>EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.<6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public <6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute(byte );
    public <6751b585-9d0a-42c7-9992-3dbec0e4aaf3>NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[<7d269b2f-849d-40f4-86fc-5805e8f0b1b5>EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute : Attribute {
    public byte Flag;
    public <b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[<7d269b2f-849d-40f4-86fc-5805e8f0b1b5>EmbeddedAttribute]
internal class System.Runtime.CompilerServices.<d057cbaf-65b7-49bd-be85-bd9a95e81eaa>IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[<0c8f9499-07fc-4e51-9581-dbc8ddaed996>EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.<eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute : Attribute {
    public byte Flag;
    public <eab68175-ce68-421c-aa83-faa1f801b0ac>NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[<464b1da7-2850-4f6e-b645-1ecc5491e1de>EmbeddedAttribute]
internal class System.Runtime.CompilerServices.<eec4cdc7-e584-46f4-83db-bf8b7fff2ead>IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[<464b1da7-2850-4f6e-b645-1ecc5491e1de>EmbeddedAttribute]
internal class System.Runtime.CompilerServices.<eef56720-e327-4776-9dd8-204dd3e85bc0>IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[<0abd5fd1-b98f-46d0-a587-6ff50f776e07>EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.<efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute : Attribute {
    public byte Flag;
    public <efb54ddb-9c24-42e8-8f82-29b6ace77aaf>NullableContextAttribute(byte );
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public CallerArgumentExpressionAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[<b3341196-a78a-4fdc-9882-fe457efba707>NullableContextAttribute("1")]
[<65e71363-487c-4ad8-a02f-ec5fdaba318f>NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    public String[] Arguments { get; }
    public InterpolatedStringHandlerArgumentAttribute(string argument);
    public InterpolatedStringHandlerArgumentAttribute(String[] arguments);
    [CompilerGeneratedAttribute]
public String[] get_Arguments();
}
[AttributeUsageAttribute("12")]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[<464b1da7-2850-4f6e-b645-1ecc5491e1de>EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[<2fc6a22d-6ff4-4a8d-92ab-b13864770451>EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[<0abd5fd1-b98f-46d0-a587-6ff50f776e07>EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
