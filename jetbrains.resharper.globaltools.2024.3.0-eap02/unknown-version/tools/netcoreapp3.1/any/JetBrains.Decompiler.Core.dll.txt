public static class JetBrains.Decompiler.Ast.AstFactory : object {
    public static ILocalVariableDeclarationScope CreateLocalVariableDeclarationScope();
    public static IFunctionSignature CreateFunctionSignature();
    public static ILiteralExpression CreateLiteral(Constant value, IInstructionReference instructionReference);
    public static IUnaryOperationExpression CreateUnaryOperation(OperationType operationType, IExpression argument, IInstructionReference instructionReference, OverflowCheckType overflowCheck);
    public static IUserDefinedUnaryOperationExpression CreateUserDefinedUnaryOperation(OperationType operationType, MethodSpecification methodSpecification, IMetadataType resultType, IExpression argument, IMetadataType constrainedType, OverflowCheckType overflowCheck, IInstructionReference instructionReference);
    public static IBinaryOperationExpression CreateBinaryOperation(OperationType operationType, IExpression leftArgument, IExpression rightArgument, IInstructionReference instructionReference, OverflowCheckType overflowCheck);
    public static IUserDefinedBinaryOperationExpression CreateUserDefinedBinaryOperation(OperationType operationType, MethodSpecification methodSpecification, IMetadataType resultType, IExpression leftArgument, IExpression rightArgument, IMetadataType constrainedType, OverflowCheckType overflowCheck, IInstructionReference instructionReference);
    public static IThrowExpression CreateThrowExpression(IExpression argument, IInstructionReference instructionReference);
    public static IThisReferenceExpression CreateThisReference(IInstructionReference instructionReference);
    public static IBaseReferenceExpression CreateBaseReference(IInstructionReference instructionReference);
    public static ILocalFunctionCallExpression CreateLocalFunctionCall(MethodInstantiation methodInstantiation, IExpression[] arguments, IMetadataMethod ownerMethod, IInstructionReference instructionReference);
    public static IMethodCallExpression CreateMethodCall(IExpression target, MethodInstantiation methodInstantiation, bool isVirtual, IExpression[] arguments, IMetadataType constrainedType, IInstructionReference instructionReference, MemberAccessKind accessKind, bool isConditionalAccess);
    public static IIndexerCallExpression CreateIndexerCall(IExpression target, PropertySpecification propertySpecification, bool isVirtual, IExpression[] arguments, IInstructionReference instructionReference, bool isConditionalAccess);
    public static INamedArgumentExpression CreateNamedArgument(IExpression argument, string parameterName, int metadataParameterIndex, IInstructionReference instructionReference);
    public static IConstructorInitializer CreateConstructorInitializer(IExpression target, MethodSpecification constructorSpecification, IExpression[] arguments, IInstructionReference instructionReference);
    public static IPropertyAccessExpression CreatePropertyAccess(IExpression target, PropertySpecification propertySpecification, bool isVirtual, IMetadataType constrainedType, IInstructionReference instructionReference, MemberAccessKind accessKind, bool isConditionalAccess);
    public static IEventAccessExpression CreateEventAccess(IExpression target, EventSpecification eventSpecification, bool isVirtual, IMetadataType constrainedType, IInstructionReference instructionReference, bool isConditionalAccess);
    public static ITypeCastExpression CreateTypeCast(IExpression argument, IMetadataType targetType, OverflowCheckType overflowCheck, IInstructionReference instructionReference);
    public static IConditionalExpression CreateConditional(IExpression condition, IExpression thenExpression, IExpression elseExpression, IInstructionReference instructionReference);
    public static IDiscardExpression CreateDiscard(IMetadataType type, bool explicitType, IInstructionReference instructionReference);
    public static ITupleExpression CreateTuple(IExpression[] components, IMetadataTupleType tupleElementNames, MethodSpecification deconstructMethodSpecification, IInstructionReference instructionReference);
    public static ITupleComponentAccessExpression CreateTupleComponentAccess(IExpression target, IMetadataType type, int index, string name, IInstructionReference instructionReference);
    public static IObjectCreationExpression CreateObjectCreation(IMetadataType constructedType, MethodSpecification constructorSpecification, IExpression[] arguments, IInstructionReference instructionReference);
    public static ITupleCreationExpression CreateTupleCreation(IMetadataType constructedType, IExpression[] arguments, String[] componentNames, IInstructionReference instructionReference);
    public static IArrayCreationExpression CreateArrayCreation(IMetadataArrayType arrayType, IExpression[] dimensions, IExpressionList initializer, IInstructionReference instructionReference);
    public static IAnonymousObjectCreationExpression CreateAnonymousObjectCreation(IMetadataType constructedType, IMemberInitializerList initializer, IInstructionReference instructionReference);
    public static IWithExpression CreateWith(IExpression argument, IMemberInitializerList initializer, IMetadataType constructedType, IInstructionReference instructionReference);
    public static IIndexerMemberInitializer CreateIndexerMemberInitializer(IMetadataProperty property, IExpression[] arguments, IExpression value, IInstructionReference instructionReference);
    public static IPropertyMemberInitializer CreatePropertyMemberInitializer(IMetadataProperty property, IExpression value, IInstructionReference instructionReference);
    public static IFieldMemberInitializer CreateFieldMemberInitializer(IMetadataField field, IExpression value, IInstructionReference instructionReference);
    public static INestedInitializer CreateNestedInitializer(IInstructionReference instructionReference);
    public static IParameterModifierExpression CreateParameterModifier(IExpression argument, ParameterModifierKind modifierKind, IInstructionReference instructionReference);
    public static IRefModifierExpression CreateRefModifier(IExpression argument, IInstructionReference instructionReference);
    public static ISizeOfExpression CreateSizeOf(IMetadataType type, IInstructionReference instructionReference);
    public static IConstantPatternExpression CreateConstantPattern(IExpression argument, IExpression constant, IInstructionReference instructionReference);
    public static ITypePatternExpression CreateTypePattern(IExpression argument, IMetadataType type, ILocalVariableReferenceExpression variableReference, IInstructionReference instructionReference);
    public static ICaseTypePatternExpression CreateCaseTypePattern(IMetadataType type, ILocalVariableReferenceExpression variableReference, IExpression predicate, IInstructionReference instructionReference);
    public static ICaseConstantPatternExpression CreateCaseConstantPattern(IExpression value, IExpression predicate, IInstructionReference instructionReference);
    public static ICheckCastExpression CreateCheckCast(IExpression argument, IMetadataType type, IInstructionReference instructionReference);
    public static ITryCastExpression CreateTryCast(IExpression argument, IMetadataType type, IInstructionReference instructionReference);
    public static ITypeOfExpression CreateTypeOf(IMetadataType type, IInstructionReference instructionReference);
    public static INameOfExpression CreateNameOf(string argument, IInstructionReference instructionReference);
    public static IBoxExpression CreateBox(IExpression argument, IMetadataType sourceType, IInstructionReference instructionReference);
    public static IUnboxExpression CreateUnbox(IExpression argument, IMetadataType targetType, IInstructionReference instructionReference);
    public static IArgListReferenceExpression CreateArgListReference(IInstructionReference instructionReference);
    public static IArgListCreationExpression CreateArgListCreation(IExpression[] arguments, IInstructionReference instructionReference);
    public static IRefValueExpression CreateRefValue(IExpression argument, IMetadataType type, IInstructionReference instructionReference);
    public static IRefTypeExpression CreateRefType(IExpression argument, IInstructionReference instructionReference);
    public static IRefTypeTokenExpression CreateRefTypeToken(IExpression argument, IInstructionReference instructionReference);
    public static IMakeRefExpression CreateMakeRef(IExpression argument, IInstructionReference instructionReference);
    public static IArrayElementAccessExpression CreateArrayElementAccess(IExpression array, IExpression[] indexes, IInstructionReference instructionReference, bool isConditionalAccess);
    public static IPointerElementAccessExpression CreatePointerElementAccess(IExpression pointer, IExpression index, IInstructionReference instructionReference);
    public static IDefaultValueExpression CreateDefaultValue(IMetadataType type, IInstructionReference instructionReference);
    public static IMethodPointerExpression CreateMethodPointer(MethodInstantiation methodInstantiation, IInstructionReference instructionReference);
    public static IVirtualMethodPointerExpression CreateVirtualMethodPointer(MethodInstantiation methodInstantiation, IExpression target, IInstructionReference instructionReference);
    public static IDelegateCreationExpression CreateDelegateCreation(IMetadataType constructedType, MethodInstantiation methodInstantiation, IExpression target, IInstructionReference instructionReference);
    public static ILocalFunctionDelegateCreationExpression CreateLocalFunctionDelegateCreation(IMetadataType constructedType, MethodInstantiation methodInstantiation, IMetadataMethod ownerMethod, IInstructionReference instructionReference);
    public static IAnonymousMethodExpression CreateAnonymousMethodExpression(IMetadataMethod metadataMethod, IFunctionSignature signature, IBlockStatement body, IInstructionReference instructionReference);
    public static ILambdaExpression CreateLambdaExpression(IMetadataMethod metadataMethod, IFunctionSignature signature, IExpression body, IInstructionReference instructionReference);
    public static ILambdaBlockExpression CreateLambdaBlockExpression(IMetadataMethod metadataMethod, IFunctionSignature signature, IBlockStatement body, IInstructionReference instructionReference);
    public static ICheckFiniteExpression CreateCheckFinite(IExpression expression, IInstructionReference instructionReference);
    public static IDelegateCallExpression CreateDelegateCall(IExpression delegate, MethodSpecification invokeSpecification, IExpression[] arguments, IInstructionReference instructionReference);
    public static IUserDefinedTypeCastExpression CreateUserDefinedTypeCast(MethodSpecification methodSpecification, IExpression argument, IMetadataType targetType, IMetadataType constrainedType, OverflowCheckType overflowCheck, IInstructionReference instructionReference);
    public static IUntypedStackAllocExpression CreateUntypedStackAlloc(IExpression length, IInstructionReference instructionReference);
    public static IStackAllocExpression CreateStackAlloc(IMetadataType elementType, IExpression length, IExpressionList initializer, IMetadataClassType spanType, IInstructionReference instructionReference);
    public static IExpressionList CreateExpressionList(IInstructionReference instructionReference);
    public static IExpressionList CreateExpressionList(IEnumerable`1<IExpression> expressions, IInstructionReference instructionReference);
    public static IMemberInitializerList CreateMemberInitializerList(IInstructionReference instructionReference);
    public static IMemberInitializerList CreateMemberInitializerList(IEnumerable`1<IMemberInitializer> initializers, IInstructionReference instructionReference);
    public static IJumpStatement CreateJump(MethodInstantiation methodInstantiation, IInstructionReference instructionReference);
    public static IParameterReferenceExpression CreateParameterReference(IMethodParameter parameter, IInstructionReference instructionReference);
    public static ILocalVariableReferenceExpression CreateLocalVariableReference(ILocalVariable variable, IInstructionReference instructionReference);
    public static IFieldReferenceExpression CreateFieldReference(FieldSpecification specification, IInstructionReference instructionReference);
    public static IMethodReferenceExpression CreateMethodReference(MethodInstantiation methodInstantiation, IInstructionReference instructionReference);
    public static ITypeReferenceExpression CreateTypeReference(IMetadataType type, IInstructionReference instructionReference);
    public static IFieldAccessExpression CreateFieldAccess(IExpression target, FieldSpecification fieldSpecification, IInstructionReference instructionReference, MemberAccessKind accessKind, bool isConditionalAccess);
    public static IAddressOfExpression CreateAddressOf(IExpression argument, IInstructionReference instructionReference);
    public static IRefExpression CreateRef(IExpression argument, IInstructionReference instructionReference, bool implicit);
    public static IPointerIndirectionExpression CreatePointerIndirection(IExpression argument, IInstructionReference instructionReference);
    public static IDerefExpression CreateDeref(IExpression argument, IInstructionReference instructionReference, bool implicit);
    public static IAwaitExpression CreateAwait(IExpression argument, IMetadataType resultType, IInstructionReference instructionReference);
    public static IFunctionPointerCallExpression CreateFunctionPointerCall(IExpression functionPointer, IExpression[] arguments, IInstructionReference instructionReference);
    public static ICommentStatement CreateComment(string text);
    public static IBlockStatement CreateBlockStatement();
    public static IBlockStatement CreateBlockStatement(IEnumerable`1<IStatement> statements);
    public static ILocalVariableDeclarationStatement CreateLocalVariableDeclaration(ILocalVariableReferenceExpression variableReference, IInstructionReference instructionReference, IExpression initializer, LocalVariableDeclarationModifierKind modifierKind);
    public static IExpressionStatement CreateExpressionStatement(IExpression expression, IInstructionReference instructionReference);
    public static IReturnStatement CreateReturn(IExpression result, IInstructionReference instructionReference);
    public static IEndFinallyStatement CreateEndFinally(IInstructionReference instructionReference);
    public static IIfStatement CreateIf(IExpression condition, IStatement then, IStatement else, IInstructionReference instructionReference);
    public static ILoopStatement CreateLoop(LoopType loopType, IExpression condition, IStatement body, IInstructionReference instructionReference);
    public static IForStatement CreateFor(IStatement initializer, IExpression condition, IStatement iterator, IStatement body, IInstructionReference instructionReference);
    public static IForEachStatement CreateForEach(IDeclarationExpression elementDeclaration, IExpression expression, IStatement body, bool isAwait, IInstructionReference instructionReference);
    public static IEmptyStatement CreateEmptyStatement(IInstructionReference instructionReference);
    public static ILabelDeclarationStatement CreateLabelDeclaration(ILabel label, IInstructionReference instructionReference);
    public static IGotoStatement CreateGoto(ILabel label, IInstructionReference instructionReference);
    public static IBreakStatement CreateBreak(IInstructionReference instructionReference);
    public static IContinueStatement CreateContinue(IInstructionReference instructionReference);
    public static IGotoCaseStatement CreateGotoCase(IExpression caseValue, bool isConstantPatternCase, IInstructionReference instructionReference);
    public static IGotoDefaultStatement CreateGotoDefault(IInstructionReference instructionReference);
    public static IThrowStatement CreateThrow(IExpression argument, IInstructionReference instructionReference);
    public static IRethrowStatement CreateRethrow(IInstructionReference instructionReference);
    public static ITryStatement CreateTry(IBlockStatement body, ICatchClause[] catchClauses, IBlockStatement finallyBlock, IBlockStatement faultBlock, IInstructionReference instructionReference);
    public static ICatchClause CreateCatchClause(ILocalVariableReferenceExpression variableReference, IBlockStatement body, IInstructionReference instructionReference);
    public static ICatchClause CreateCatchFilterClause(ILocalVariableReferenceExpression variableReference, IBlockStatement filter, IBlockStatement body, IInstructionReference instructionReference);
    public static ISuccessfulFilteringStatement CreateSuccessfulFiltering(IInstructionReference instructionReference);
    public static IUsingStatement CreateUsing(ILocalVariableReferenceExpression variableReference, IExpression expression, IStatement body, bool isAwait, IInstructionReference instructionReference);
    public static IPinStatement CreatePin(ILocalVariableReferenceExpression variableReference, IExpression initializer, IInstructionReference instructionReference);
    public static IUnpinStatement CreateUnpin(ILocalVariableReferenceExpression variableReference, IInstructionReference instructionReference);
    public static IFixedStatement CreateFixed(ILocalVariableReferenceExpression variableReference, IExpression initializer, IStatement body, IInstructionReference instructionReference);
    public static ILockStatement CreateLock(IExpression expression, IStatement body, IInstructionReference instructionReference);
    public static ISwitchCase CreateSwitchCase(IExpression[] values, IBlockStatement body, IInstructionReference instructionReference);
    public static ISwitchStatement CreateSwitch(IExpression expression, ISwitchCase[] cases, IBlockStatement defaultBlock, IInstructionReference instructionReference);
    public static IMemoryCopyStatement CreateMemoryCopy(IExpression source, IExpression destination, IExpression length, IInstructionReference instructionReference);
    public static IMemoryInitializeStatement CreateMemoryInitialize(IExpression destination, IExpression value, IExpression length, IInstructionReference instructionReference);
    public static IYieldReturnStatement CreateYieldReturn(IExpression result, IInstructionReference instructionReference);
    public static IYieldBreakStatement CreateYieldBreak(IInstructionReference instructionReference);
}
public class JetBrains.Decompiler.Ast.Constant : object {
    [CompilerGeneratedAttribute]
private IMetadataType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ElementType <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public static Constant Null;
    [NotNullAttribute]
public IMetadataType Type { get; }
    public ElementType ElementType { get; }
    [CanBeNullAttribute]
public object Value { get; }
    public bool IsNull { get; }
    private Constant(IMetadataType type, ElementType elementType, object value);
    private static Constant();
    public static Constant FromValueAndType(object value, IMetadataType type);
    internal static Constant FromValue(object value, MetadataTypeCache typeCache);
    [CompilerGeneratedAttribute]
public IMetadataType get_Type();
    [CompilerGeneratedAttribute]
public ElementType get_ElementType();
    [CompilerGeneratedAttribute]
public object get_Value();
    public bool Is();
    public bool get_IsNull();
    public T As();
    public sealed virtual bool Equals(Constant other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.Ast.ExpressionEx : object {
    [ExtensionAttribute]
public static ITypeCastExpression WrapTypeCast(IExpression argument, IMetadataType type, IInstructionReference instructionReference, OverflowCheckType overflowCheck);
    [ExtensionAttribute]
public static IExpression MaybeWrapTypeCast(IExpression argument, IMetadataType type, IInstructionReference instructionReference, OverflowCheckType overflowCheck);
    [ExtensionAttribute]
public static IExpression MaybeWrapTypeCast(IExpression argument, IMetadataType type, IInstructionReference instructionReference, bool wrap, OverflowCheckType overflowCheck);
    [ExtensionAttribute]
public static IUnaryOperationExpression WrapUnary(IExpression argument, OperationType operationType, IInstructionReference instructionReference, OverflowCheckType overflowCheck);
    [ExtensionAttribute]
public static IExpression MaybeNegate(IExpression argument, bool negate, IInstructionReference instructionReference);
    [ExtensionAttribute]
public static IUserDefinedUnaryOperationExpression WrapUserDefinedUnary(IExpression argument, OperationType operationType, IMethodCallExpression baseOperation);
    public static IUserDefinedBinaryOperationExpression CreateUserDefinedBinaryOperation(OperationType operationType, IUserDefinedBinaryOperationExpression baseBinaryOperation, IExpression leftArgument, IExpression rightArgument);
    [ExtensionAttribute]
public static IRefExpression WrapRef(IExpression argument, IInstructionReference instructionReference, bool implicit);
    [ExtensionAttribute]
public static IRefModifierExpression WrapRefModifier(IExpression argument, IInstructionReference instructionReference);
    [ExtensionAttribute]
public static IAddressOfExpression WrapAddressOf(IExpression argument, IInstructionReference instructionReference);
    [ExtensionAttribute]
public static IDerefExpression WrapDeref(IExpression argument, IInstructionReference instructionReference, bool implicit);
    [ExtensionAttribute]
public static IPointerIndirectionExpression WrapPointerIndirection(IExpression argument, IInstructionReference instructionReference);
    [ExtensionAttribute]
public static ILocalVariableReferenceExpression ToReference(ILocalVariable variable, IInstructionReference instructionReference);
    [ExtensionAttribute]
public static IParameterReferenceExpression ToReference(IMethodParameter parameter, IInstructionReference instructionReference);
    [ExtensionAttribute]
public static IExpressionStatement ToStatement(IExpression expression, IInstructionReference instructionReference);
    [ExtensionAttribute]
public static IExpression UnwrapTypeCasts(IExpression expression);
    [ExtensionAttribute]
public static IExpression GetTarget(IAccessExpression entityAccess);
    [ExtensionAttribute]
internal static string GetPresentation(IMemberCallExpression memberCall, IMetadataClassType ownerType, string memberPresentation);
    [ExtensionAttribute]
internal static string GetConstrainedTypePresentation(ITypeConstrainedCallExpression typeConstrainedCallExpression);
    [ExtensionAttribute]
internal static string GetOverflowCheckPresentation(IOverflowCheckExpression overflowCheck);
    [ExtensionAttribute]
public static bool ContainsReference(IExpression expression, ILocalVariable variable);
}
public enum JetBrains.Decompiler.Ast.FunctionSignatureStyle : Enum {
    public int value__;
    public static FunctionSignatureStyle Full;
    public static FunctionSignatureStyle Compact;
    public static FunctionSignatureStyle CompactSingle;
}
public interface JetBrains.Decompiler.Ast.IAbstractBinaryOperationExpression {
    public OperationType OperationType { get; public set; }
    public IExpression LeftArgument { get; public set; }
    public IExpression RightArgument { get; public set; }
    public abstract virtual OperationType get_OperationType();
    public abstract virtual void set_OperationType(OperationType value);
    public abstract virtual IExpression get_LeftArgument();
    public abstract virtual void set_LeftArgument(IExpression value);
    public abstract virtual IExpression get_RightArgument();
    public abstract virtual void set_RightArgument(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IAbstractGotoStatement {
}
public interface JetBrains.Decompiler.Ast.IAbstractLoopStatement {
    public IStatement Body { get; public set; }
    public abstract virtual IStatement get_Body();
    public abstract virtual void set_Body(IStatement value);
}
public interface JetBrains.Decompiler.Ast.IAbstractTypeCastExpression {
    public IMetadataType TargetType { get; public set; }
    public IExpression Argument { get; public set; }
    public abstract virtual IMetadataType get_TargetType();
    public abstract virtual void set_TargetType(IMetadataType value);
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IAbstractUnaryOperationExpression {
    public OperationType OperationType { get; public set; }
    public IExpression Argument { get; public set; }
    public abstract virtual OperationType get_OperationType();
    public abstract virtual void set_OperationType(OperationType value);
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IAccessExpression {
    public bool IsConditionalAccess { get; public set; }
    public abstract virtual bool get_IsConditionalAccess();
    public abstract virtual void set_IsConditionalAccess(bool value);
}
public interface JetBrains.Decompiler.Ast.IAddressOfExpression {
    public IExpression Argument { get; public set; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IAnonymousMethodExpression {
    public IBlockStatement Body { get; public set; }
    public abstract virtual IBlockStatement get_Body();
    public abstract virtual void set_Body(IBlockStatement value);
}
public interface JetBrains.Decompiler.Ast.IAnonymousMethodExpressionBase {
    [CanBeNullAttribute]
public IFunctionSignature Signature { get; public set; }
    [CanBeNullAttribute]
public IMetadataMethod MetadataMethod { get; }
    public abstract virtual IFunctionSignature get_Signature();
    public abstract virtual void set_Signature(IFunctionSignature value);
    public abstract virtual IMetadataMethod get_MetadataMethod();
}
public interface JetBrains.Decompiler.Ast.IAnonymousObjectCreationExpression {
    public IMemberInitializerList Initializer { get; public set; }
    public ILocalVariableDeclarationScope DeclarationScope { get; }
    public abstract virtual IMemberInitializerList get_Initializer();
    public abstract virtual void set_Initializer(IMemberInitializerList value);
    public abstract virtual ILocalVariableDeclarationScope get_DeclarationScope();
}
public interface JetBrains.Decompiler.Ast.IArgListCreationExpression {
}
public interface JetBrains.Decompiler.Ast.IArgListReferenceExpression {
}
public interface JetBrains.Decompiler.Ast.IArgumentable {
    public IExpression[] Arguments { get; public set; }
    public abstract virtual IExpression[] get_Arguments();
    public abstract virtual void set_Arguments(IExpression[] value);
}
public interface JetBrains.Decompiler.Ast.IArrayCreationExpression {
    public IExpression[] Dimensions { get; public set; }
    public IExpressionList Initializer { get; public set; }
    public IMetadataArrayType ArrayType { get; }
    public abstract virtual IExpression[] get_Dimensions();
    public abstract virtual void set_Dimensions(IExpression[] value);
    public abstract virtual IExpressionList get_Initializer();
    public abstract virtual void set_Initializer(IExpressionList value);
    public abstract virtual IMetadataArrayType get_ArrayType();
}
public interface JetBrains.Decompiler.Ast.IArrayElementAccessExpression {
    public IExpression Array { get; public set; }
    public IExpression[] Indexes { get; public set; }
    public abstract virtual IExpression get_Array();
    public abstract virtual void set_Array(IExpression value);
    public abstract virtual IExpression[] get_Indexes();
    public abstract virtual void set_Indexes(IExpression[] value);
}
public interface JetBrains.Decompiler.Ast.IAwaitExpression {
    public IExpression Argument { get; public set; }
    public IMetadataType ResultType { get; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
    public abstract virtual IMetadataType get_ResultType();
}
public interface JetBrains.Decompiler.Ast.IBaseReferenceExpression {
}
public interface JetBrains.Decompiler.Ast.IBinaryOperationExpression {
}
public interface JetBrains.Decompiler.Ast.IBlockStatement {
    public INodeList`1<IStatement> Statements { get; }
    public abstract virtual INodeList`1<IStatement> get_Statements();
}
public interface JetBrains.Decompiler.Ast.IBoxExpression {
    public IExpression Argument { get; public set; }
    public IMetadataType SourceType { get; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
    public abstract virtual IMetadataType get_SourceType();
}
public interface JetBrains.Decompiler.Ast.IBreakStatement {
}
public interface JetBrains.Decompiler.Ast.ICaseConstantPatternExpression {
    public IExpression Value { get; public set; }
    public abstract virtual IExpression get_Value();
    public abstract virtual void set_Value(IExpression value);
}
public interface JetBrains.Decompiler.Ast.ICasePatternExpression {
    public IExpression Predicate { get; public set; }
    public abstract virtual IExpression get_Predicate();
    public abstract virtual void set_Predicate(IExpression value);
}
public interface JetBrains.Decompiler.Ast.ICaseTypePatternExpression {
}
public interface JetBrains.Decompiler.Ast.ICatchClause {
    public ILocalVariableReferenceExpression VariableReference { get; public set; }
    public IBlockStatement Filter { get; public set; }
    public IBlockStatement Body { get; public set; }
    public abstract virtual ILocalVariableReferenceExpression get_VariableReference();
    public abstract virtual void set_VariableReference(ILocalVariableReferenceExpression value);
    public abstract virtual IBlockStatement get_Filter();
    public abstract virtual void set_Filter(IBlockStatement value);
    public abstract virtual IBlockStatement get_Body();
    public abstract virtual void set_Body(IBlockStatement value);
}
public interface JetBrains.Decompiler.Ast.ICheckCastExpression {
    public IExpression Argument { get; public set; }
    public IMetadataType Type { get; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
    public abstract virtual IMetadataType get_Type();
}
public interface JetBrains.Decompiler.Ast.ICheckFiniteExpression {
    public IExpression Expression { get; public set; }
    public abstract virtual IExpression get_Expression();
    public abstract virtual void set_Expression(IExpression value);
}
public interface JetBrains.Decompiler.Ast.ICommentStatement {
    public string Text { get; }
    public abstract virtual string get_Text();
}
public interface JetBrains.Decompiler.Ast.IConditionalExpression {
    public IExpression Condition { get; public set; }
    public IExpression Then { get; public set; }
    public IExpression Else { get; public set; }
    public abstract virtual IExpression get_Condition();
    public abstract virtual void set_Condition(IExpression value);
    public abstract virtual IExpression get_Then();
    public abstract virtual void set_Then(IExpression value);
    public abstract virtual IExpression get_Else();
    public abstract virtual void set_Else(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IConstantPatternExpression {
    public IExpression Argument { get; public set; }
    public IExpression Constant { get; public set; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
    public abstract virtual IExpression get_Constant();
    public abstract virtual void set_Constant(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IConstructorInitializer {
    [CanBeNullAttribute]
public MethodSpecification ConstructorSpecification { get; public set; }
    public abstract virtual MethodSpecification get_ConstructorSpecification();
    public abstract virtual void set_ConstructorSpecification(MethodSpecification value);
}
public interface JetBrains.Decompiler.Ast.IContinueStatement {
}
public interface JetBrains.Decompiler.Ast.ICreationExpression {
    public IMetadataType ConstructedType { get; }
    public abstract virtual IMetadataType get_ConstructedType();
}
public interface JetBrains.Decompiler.Ast.IDeclarationExpression {
}
public interface JetBrains.Decompiler.Ast.IDecompiledClass {
    [NotNullAttribute]
public DataHolder Data { get; }
    [NotNullAttribute]
public IMetadataTypeInfo TypeInfo { get; }
    [NotNullAttribute]
public IList`1<IDecompiledMethod> Methods { get; }
    [NotNullAttribute]
public IList`1<IDecompiledField> Fields { get; }
    [NotNullAttribute]
public IList`1<IDecompiledProperty> Properties { get; }
    [NotNullAttribute]
public IList`1<IDecompiledEvent> Events { get; }
    [NotNullAttribute]
public IList`1<IMetadataTypeInfo> NestedTypes { get; }
    [CanBeNullAttribute]
public IDecompiledMethod TopLevelEntryPoint { get; }
    public bool IsRecord { get; }
    [CanBeNullAttribute]
public IDecompiledMethod RecordPrimaryConstructor { get; }
    public abstract virtual DataHolder get_Data();
    public abstract virtual IMetadataTypeInfo get_TypeInfo();
    public abstract virtual IList`1<IDecompiledMethod> get_Methods();
    public abstract virtual IList`1<IDecompiledField> get_Fields();
    public abstract virtual IList`1<IDecompiledProperty> get_Properties();
    public abstract virtual IList`1<IDecompiledEvent> get_Events();
    public abstract virtual IList`1<IMetadataTypeInfo> get_NestedTypes();
    public abstract virtual IDecompiledMethod get_TopLevelEntryPoint();
    public abstract virtual bool get_IsRecord();
    public abstract virtual IDecompiledMethod get_RecordPrimaryConstructor();
}
public interface JetBrains.Decompiler.Ast.IDecompiledClassMember {
    [CanBeNullAttribute]
public IDecompiledClass OwnerClass { get; }
    public abstract virtual IDecompiledClass get_OwnerClass();
}
public interface JetBrains.Decompiler.Ast.IDecompiledEvent {
    [NotNullAttribute]
public IMetadataEvent MetadataEvent { get; }
    [CanBeNullAttribute]
public IDecompiledMethod Adder { get; }
    [CanBeNullAttribute]
public IDecompiledMethod Remover { get; }
    public bool IsFieldLike { get; public set; }
    [CanBeNullAttribute]
public IExpression Initializer { get; public set; }
    [CanBeNullAttribute]
public IMetadataField BackingField { get; public set; }
    public abstract virtual IMetadataEvent get_MetadataEvent();
    public abstract virtual IDecompiledMethod get_Adder();
    public abstract virtual IDecompiledMethod get_Remover();
    public abstract virtual bool get_IsFieldLike();
    public abstract virtual void set_IsFieldLike(bool value);
    public abstract virtual IExpression get_Initializer();
    public abstract virtual void set_Initializer(IExpression value);
    public abstract virtual IMetadataField get_BackingField();
    public abstract virtual void set_BackingField(IMetadataField value);
}
public interface JetBrains.Decompiler.Ast.IDecompiledField {
    [NotNullAttribute]
public IMetadataField MetadataField { get; }
    public bool IsUnsafe { get; public set; }
    [CanBeNullAttribute]
public IExpression Initializer { get; public set; }
    public abstract virtual IMetadataField get_MetadataField();
    public abstract virtual bool get_IsUnsafe();
    public abstract virtual void set_IsUnsafe(bool value);
    public abstract virtual IExpression get_Initializer();
    public abstract virtual void set_Initializer(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IDecompiledMethod {
    public IConstructorInitializer ConstructorInitializer { get; public set; }
    public abstract virtual IConstructorInitializer get_ConstructorInitializer();
    public abstract virtual void set_ConstructorInitializer(IConstructorInitializer value);
}
public interface JetBrains.Decompiler.Ast.IDecompiledMethodBase {
    [CanBeNullAttribute]
public IBlockStatement Body { get; public set; }
    [CanBeNullAttribute]
public IExpression BodyExpression { get; public set; }
    public IFunctionSignature Signature { get; public set; }
    [NotNullAttribute]
public IMetadataMethod MetadataMethod { get; }
    public bool IsUnsafe { get; public set; }
    public bool IsIterator { get; public set; }
    [NotNullAttribute]
public ICollection`1<ILocalVariable> LocalVariables { get; }
    [NotNullAttribute]
public ICollection`1<ILabel> Labels { get; }
    [NotNullAttribute]
public IDictionary`2<MetadataToken, ILocalFunction> LocalFunctions { get; }
    public string Name { get; }
    public abstract virtual IBlockStatement get_Body();
    public abstract virtual void set_Body(IBlockStatement value);
    public abstract virtual IExpression get_BodyExpression();
    public abstract virtual void set_BodyExpression(IExpression value);
    public abstract virtual IFunctionSignature get_Signature();
    public abstract virtual void set_Signature(IFunctionSignature value);
    public abstract virtual IMetadataMethod get_MetadataMethod();
    public abstract virtual bool get_IsUnsafe();
    public abstract virtual void set_IsUnsafe(bool value);
    public abstract virtual bool get_IsIterator();
    public abstract virtual void set_IsIterator(bool value);
    public abstract virtual ICollection`1<ILocalVariable> get_LocalVariables();
    public abstract virtual ICollection`1<ILabel> get_Labels();
    public abstract virtual IDictionary`2<MetadataToken, ILocalFunction> get_LocalFunctions();
    public abstract virtual string get_Name();
}
public interface JetBrains.Decompiler.Ast.IDecompiledProperty {
    [NotNullAttribute]
public IMetadataProperty MetadataProperty { get; }
    [CanBeNullAttribute]
public IDecompiledMethod Getter { get; public set; }
    [CanBeNullAttribute]
public IDecompiledMethod Setter { get; public set; }
    public bool IsAuto { get; public set; }
    [CanBeNullAttribute]
public IExpression Initializer { get; public set; }
    [CanBeNullAttribute]
public IMetadataField BackingField { get; public set; }
    public abstract virtual IMetadataProperty get_MetadataProperty();
    public abstract virtual IDecompiledMethod get_Getter();
    public abstract virtual void set_Getter(IDecompiledMethod value);
    public abstract virtual IDecompiledMethod get_Setter();
    public abstract virtual void set_Setter(IDecompiledMethod value);
    public abstract virtual bool get_IsAuto();
    public abstract virtual void set_IsAuto(bool value);
    public abstract virtual IExpression get_Initializer();
    public abstract virtual void set_Initializer(IExpression value);
    public abstract virtual IMetadataField get_BackingField();
    public abstract virtual void set_BackingField(IMetadataField value);
}
public interface JetBrains.Decompiler.Ast.IDefaultValueExpression {
    public IMetadataType Type { get; }
    public abstract virtual IMetadataType get_Type();
}
public interface JetBrains.Decompiler.Ast.IDelegateCallExpression {
    public IExpression Delegate { get; public set; }
    public MethodSpecification InvokeSpecification { get; }
    public abstract virtual IExpression get_Delegate();
    public abstract virtual void set_Delegate(IExpression value);
    public abstract virtual MethodSpecification get_InvokeSpecification();
}
public interface JetBrains.Decompiler.Ast.IDelegateCreationBaseExpression {
    public MethodInstantiation MethodInstantiation { get; }
    public abstract virtual MethodInstantiation get_MethodInstantiation();
}
public interface JetBrains.Decompiler.Ast.IDelegateCreationExpression {
    public bool IsStatic { get; }
    public abstract virtual bool get_IsStatic();
}
public interface JetBrains.Decompiler.Ast.IDerefExpression {
    public IExpression Argument { get; public set; }
    public bool Implicit { get; public set; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
    public abstract virtual bool get_Implicit();
    public abstract virtual void set_Implicit(bool value);
}
public interface JetBrains.Decompiler.Ast.IDiscardExpression {
    public IMetadataType Type { get; }
    public bool ExplicitType { get; public set; }
    public abstract virtual IMetadataType get_Type();
    public abstract virtual bool get_ExplicitType();
    public abstract virtual void set_ExplicitType(bool value);
}
public interface JetBrains.Decompiler.Ast.IEmptyStatement {
}
public interface JetBrains.Decompiler.Ast.IEndFinallyStatement {
}
public interface JetBrains.Decompiler.Ast.IEventAccessExpression {
    public EventSpecification EventSpecification { get; }
    public abstract virtual EventSpecification get_EventSpecification();
}
public interface JetBrains.Decompiler.Ast.IExpression {
}
public interface JetBrains.Decompiler.Ast.IExpressionList {
    public INodeList`1<IExpression> Expressions { get; }
    public abstract virtual INodeList`1<IExpression> get_Expressions();
}
public interface JetBrains.Decompiler.Ast.IExpressionStatement {
    public IExpression Expression { get; public set; }
    public abstract virtual IExpression get_Expression();
    public abstract virtual void set_Expression(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IFieldAccessExpression {
    public FieldSpecification FieldSpecification { get; }
    public abstract virtual FieldSpecification get_FieldSpecification();
}
public interface JetBrains.Decompiler.Ast.IFieldMemberInitializer {
    public IMetadataField Field { get; }
    public abstract virtual IMetadataField get_Field();
}
public interface JetBrains.Decompiler.Ast.IFieldReferenceExpression {
    public FieldSpecification FieldSpecification { get; }
    public abstract virtual FieldSpecification get_FieldSpecification();
}
public interface JetBrains.Decompiler.Ast.IFixedStatement {
    public ILocalVariableReferenceExpression VariableReference { get; public set; }
    public IExpression Initializer { get; public set; }
    public IStatement Body { get; public set; }
    public abstract virtual ILocalVariableReferenceExpression get_VariableReference();
    public abstract virtual void set_VariableReference(ILocalVariableReferenceExpression value);
    public abstract virtual IExpression get_Initializer();
    public abstract virtual void set_Initializer(IExpression value);
    public abstract virtual IStatement get_Body();
    public abstract virtual void set_Body(IStatement value);
}
public interface JetBrains.Decompiler.Ast.IForEachStatement {
    public IDeclarationExpression ElementDeclaration { get; public set; }
    public IExpression Expression { get; public set; }
    public bool IsAwait { get; }
    public abstract virtual IDeclarationExpression get_ElementDeclaration();
    public abstract virtual void set_ElementDeclaration(IDeclarationExpression value);
    public abstract virtual IExpression get_Expression();
    public abstract virtual void set_Expression(IExpression value);
    public abstract virtual bool get_IsAwait();
}
public interface JetBrains.Decompiler.Ast.IForStatement {
    public IStatement Initializer { get; public set; }
    public IExpression Condition { get; public set; }
    public IStatement Iterator { get; public set; }
    public abstract virtual IStatement get_Initializer();
    public abstract virtual void set_Initializer(IStatement value);
    public abstract virtual IExpression get_Condition();
    public abstract virtual void set_Condition(IExpression value);
    public abstract virtual IStatement get_Iterator();
    public abstract virtual void set_Iterator(IStatement value);
}
public interface JetBrains.Decompiler.Ast.IFunctionPointerCallExpression {
    public IExpression FunctionPointer { get; public set; }
    public abstract virtual IExpression get_FunctionPointer();
    public abstract virtual void set_FunctionPointer(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IFunctionSignature {
    public IList`1<IMethodParameter> Parameters { get; }
    [CanBeNullAttribute]
public Nullable`1<int> OwnParametersCount { get; public set; }
    public FunctionSignatureStyle Style { get; public set; }
    public bool IsAsync { get; public set; }
    public bool HasArgList { get; public set; }
    public abstract virtual IList`1<IMethodParameter> get_Parameters();
    public abstract virtual Nullable`1<int> get_OwnParametersCount();
    public abstract virtual void set_OwnParametersCount(Nullable`1<int> value);
    public abstract virtual FunctionSignatureStyle get_Style();
    public abstract virtual void set_Style(FunctionSignatureStyle value);
    public abstract virtual bool get_IsAsync();
    public abstract virtual void set_IsAsync(bool value);
    public abstract virtual bool get_HasArgList();
    public abstract virtual void set_HasArgList(bool value);
}
public interface JetBrains.Decompiler.Ast.IGotoCaseStatement {
    public IExpression CaseValue { get; public set; }
    public bool IsConstantPatternCase { get; }
    public abstract virtual IExpression get_CaseValue();
    public abstract virtual void set_CaseValue(IExpression value);
    public abstract virtual bool get_IsConstantPatternCase();
}
public interface JetBrains.Decompiler.Ast.IGotoDefaultStatement {
}
public interface JetBrains.Decompiler.Ast.IGotoStatement {
    public ILabel Label { get; }
    public abstract virtual ILabel get_Label();
}
public interface JetBrains.Decompiler.Ast.IIfStatement {
    public IExpression Condition { get; public set; }
    public IStatement Then { get; public set; }
    public IStatement Else { get; public set; }
    public abstract virtual IExpression get_Condition();
    public abstract virtual void set_Condition(IExpression value);
    public abstract virtual IStatement get_Then();
    public abstract virtual void set_Then(IStatement value);
    public abstract virtual IStatement get_Else();
    public abstract virtual void set_Else(IStatement value);
}
public interface JetBrains.Decompiler.Ast.IIndexerCallExpression {
    public PropertySpecification PropertySpecification { get; }
    public abstract virtual PropertySpecification get_PropertySpecification();
}
public interface JetBrains.Decompiler.Ast.IIndexerMemberInitializer {
    public IMetadataProperty Property { get; }
    public abstract virtual IMetadataProperty get_Property();
}
public interface JetBrains.Decompiler.Ast.IInstructionsRange {
    public Instruction First { get; }
    public Instruction Last { get; }
    public abstract virtual Instruction get_First();
    public abstract virtual Instruction get_Last();
    public abstract virtual void AddInstruction(Instruction instruction);
}
public interface JetBrains.Decompiler.Ast.IJumpStatement {
    public MethodInstantiation MethodInstantiation { get; }
    public abstract virtual MethodInstantiation get_MethodInstantiation();
}
public interface JetBrains.Decompiler.Ast.ILabel {
    public IDecompiledMethodBase Method { get; }
    public string Name { get; }
    public abstract virtual IDecompiledMethodBase get_Method();
    public abstract virtual string get_Name();
}
public interface JetBrains.Decompiler.Ast.ILabelDeclarationStatement {
    public ILabel Label { get; }
    public abstract virtual ILabel get_Label();
}
public interface JetBrains.Decompiler.Ast.ILambdaBlockExpression {
    public IBlockStatement Body { get; public set; }
    public abstract virtual IBlockStatement get_Body();
    public abstract virtual void set_Body(IBlockStatement value);
}
public interface JetBrains.Decompiler.Ast.ILambdaExpression {
    public IExpression Body { get; public set; }
    public abstract virtual IExpression get_Body();
    public abstract virtual void set_Body(IExpression value);
}
public interface JetBrains.Decompiler.Ast.ILiteralExpression {
    public Constant Value { get; }
    public abstract virtual Constant get_Value();
}
public interface JetBrains.Decompiler.Ast.ILocalFunction {
    [NotNullAttribute]
public IDecompiledMethodBase OwnerMethod { get; }
    public bool IsStatic { get; }
    public abstract virtual IDecompiledMethodBase get_OwnerMethod();
    public abstract virtual ILocalFunction Detach();
    public abstract virtual bool get_IsStatic();
}
public interface JetBrains.Decompiler.Ast.ILocalFunctionCallExpression {
    public IMetadataMethod OwnerMethod { get; }
    public abstract virtual IMetadataMethod get_OwnerMethod();
}
public interface JetBrains.Decompiler.Ast.ILocalFunctionDelegateCreationExpression {
    public IMetadataMethod OwnerMethod { get; }
    public abstract virtual IMetadataMethod get_OwnerMethod();
}
public interface JetBrains.Decompiler.Ast.ILocalVariable {
    [NotNullAttribute]
public IDecompiledMethodBase Method { get; }
    [NotNullAttribute]
public ILocalVariableDeclarationScope DeclarationScope { get; }
    public LocalVariableKind Kind { get; public set; }
    public bool Duplicated { get; public set; }
    [NotNullAttribute]
public string Name { get; public set; }
    public IMetadataType Type { get; public set; }
    [CanBeNullAttribute]
public IMethodBodyLocalVariable MetadataVariable { get; }
    [CanBeNullAttribute]
public IMetadataField MetadataField { get; }
    [CanBeNullAttribute]
public IInstructionsRange InstructionsRange { get; }
    public abstract virtual IDecompiledMethodBase get_Method();
    public abstract virtual ILocalVariableDeclarationScope get_DeclarationScope();
    public abstract virtual LocalVariableKind get_Kind();
    public abstract virtual void set_Kind(LocalVariableKind value);
    public abstract virtual bool get_Duplicated();
    public abstract virtual void set_Duplicated(bool value);
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual IMetadataType get_Type();
    public abstract virtual void set_Type(IMetadataType value);
    public abstract virtual IMethodBodyLocalVariable get_MetadataVariable();
    public abstract virtual IMetadataField get_MetadataField();
    public abstract virtual IInstructionsRange get_InstructionsRange();
    public abstract virtual void SetMetadataVariableAndInstructionRange(ILocalVariable other);
}
public interface JetBrains.Decompiler.Ast.ILocalVariableDeclarationScope {
}
public interface JetBrains.Decompiler.Ast.ILocalVariableDeclarationScopeOwner {
    public ILocalVariableDeclarationScope DeclarationScope { get; }
    public abstract virtual ILocalVariableDeclarationScope get_DeclarationScope();
}
public interface JetBrains.Decompiler.Ast.ILocalVariableDeclarationStatement {
    public ILocalVariableReferenceExpression VariableReference { get; public set; }
    public IExpression Initializer { get; public set; }
    public LocalVariableDeclarationModifierKind ModifierKind { get; }
    public abstract virtual ILocalVariableReferenceExpression get_VariableReference();
    public abstract virtual void set_VariableReference(ILocalVariableReferenceExpression value);
    public abstract virtual IExpression get_Initializer();
    public abstract virtual void set_Initializer(IExpression value);
    public abstract virtual LocalVariableDeclarationModifierKind get_ModifierKind();
}
public interface JetBrains.Decompiler.Ast.ILocalVariableReferenceExpression {
    public ILocalVariable Variable { get; }
    public abstract virtual ILocalVariable get_Variable();
}
public interface JetBrains.Decompiler.Ast.ILockStatement {
    public IExpression Expression { get; public set; }
    public IStatement Body { get; public set; }
    public abstract virtual IExpression get_Expression();
    public abstract virtual void set_Expression(IExpression value);
    public abstract virtual IStatement get_Body();
    public abstract virtual void set_Body(IStatement value);
}
public interface JetBrains.Decompiler.Ast.ILoopStatement {
    public IExpression Condition { get; public set; }
    public LoopType LoopType { get; }
    public abstract virtual IExpression get_Condition();
    public abstract virtual void set_Condition(IExpression value);
    public abstract virtual LoopType get_LoopType();
}
public interface JetBrains.Decompiler.Ast.IMakeRefExpression {
    public IExpression Argument { get; public set; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IMemberAccessExpression {
    public MemberAccessKind AccessKind { get; }
    public bool IsStatic { get; }
    public abstract virtual MemberAccessKind get_AccessKind();
    public abstract virtual bool get_IsStatic();
}
public interface JetBrains.Decompiler.Ast.IMemberCallExpression {
    public bool IsVirtual { get; }
    public abstract virtual bool get_IsVirtual();
}
public interface JetBrains.Decompiler.Ast.IMemberInitializer {
    public IExpression Value { get; public set; }
    public abstract virtual IExpression get_Value();
    public abstract virtual void set_Value(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IMemberInitializerList {
    public INodeList`1<IMemberInitializer> Initializers { get; }
    public abstract virtual INodeList`1<IMemberInitializer> get_Initializers();
}
public interface JetBrains.Decompiler.Ast.IMemoryCopyStatement {
    public IExpression Destination { get; public set; }
    public IExpression Source { get; public set; }
    public IExpression Length { get; public set; }
    public abstract virtual IExpression get_Destination();
    public abstract virtual void set_Destination(IExpression value);
    public abstract virtual IExpression get_Source();
    public abstract virtual void set_Source(IExpression value);
    public abstract virtual IExpression get_Length();
    public abstract virtual void set_Length(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IMemoryInitializeStatement {
    public IExpression Destination { get; public set; }
    public IExpression Value { get; public set; }
    public IExpression Length { get; public set; }
    public abstract virtual IExpression get_Destination();
    public abstract virtual void set_Destination(IExpression value);
    public abstract virtual IExpression get_Value();
    public abstract virtual void set_Value(IExpression value);
    public abstract virtual IExpression get_Length();
    public abstract virtual void set_Length(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IMethodCallBaseExpression {
    public MethodInstantiation MethodInstantiation { get; }
    public string Name { get; }
    public abstract virtual MethodInstantiation get_MethodInstantiation();
    public abstract virtual string get_Name();
}
public interface JetBrains.Decompiler.Ast.IMethodCallExpression {
}
public interface JetBrains.Decompiler.Ast.IMethodParameter {
    [CanBeNullAttribute]
public IDecompiledMethodBase Method { get; }
    public MethodParameterKind Kind { get; public set; }
    [NotNullAttribute]
public IMetadataType Type { get; }
    [CanBeNullAttribute]
public string Name { get; public set; }
    public int Index { get; public set; }
    [CanBeNullAttribute]
public IMetadataParameter MetadataParameter { get; }
    public abstract virtual IDecompiledMethodBase get_Method();
    public abstract virtual MethodParameterKind get_Kind();
    public abstract virtual void set_Kind(MethodParameterKind value);
    public abstract virtual IMetadataType get_Type();
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual int get_Index();
    public abstract virtual void set_Index(int value);
    public abstract virtual IMetadataParameter get_MetadataParameter();
}
public interface JetBrains.Decompiler.Ast.IMethodPointerExpression {
    public MethodInstantiation MethodInstantiation { get; }
    public abstract virtual MethodInstantiation get_MethodInstantiation();
}
public interface JetBrains.Decompiler.Ast.IMethodReferenceExpression {
    public MethodInstantiation MethodInstantiation { get; }
    public abstract virtual MethodInstantiation get_MethodInstantiation();
}
internal class JetBrains.Decompiler.Ast.Impl.AddressOfExpression : Expression {
    private IExpression myArgument;
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.AddressOfExpression/<get_Children>d__5")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.AnonymousMethodExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataMethod <MetadataMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ILocalVariableDeclarationScope <DeclarationScope>k__BackingField;
    private IFunctionSignature mySignature;
    private IBlockStatement myBody;
    public IMetadataType ConstructedType { get; }
    public IMetadataMethod MetadataMethod { get; public set; }
    public ILocalVariableDeclarationScope DeclarationScope { get; public set; }
    public IFunctionSignature Signature { get; public set; }
    public IBlockStatement Body { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public sealed virtual IMetadataType get_ConstructedType();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataMethod get_MetadataMethod();
    [CompilerGeneratedAttribute]
public void set_MetadataMethod(IMetadataMethod value);
    [CompilerGeneratedAttribute]
public sealed virtual ILocalVariableDeclarationScope get_DeclarationScope();
    [CompilerGeneratedAttribute]
public void set_DeclarationScope(ILocalVariableDeclarationScope value);
    [DebuggerStepThroughAttribute]
public sealed virtual IFunctionSignature get_Signature();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Signature(IFunctionSignature value);
    [DebuggerStepThroughAttribute]
public sealed virtual IBlockStatement get_Body();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Body(IBlockStatement value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.AnonymousMethodExpression/<get_Children>d__19")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.AnonymousObjectCreationExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <ConstructedType>k__BackingField;
    [CompilerGeneratedAttribute]
private ILocalVariableDeclarationScope <DeclarationScope>k__BackingField;
    private IMemberInitializerList myInitializer;
    public IMetadataType ConstructedType { get; public set; }
    public ILocalVariableDeclarationScope DeclarationScope { get; public set; }
    public IMemberInitializerList Initializer { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_ConstructedType();
    [CompilerGeneratedAttribute]
public void set_ConstructedType(IMetadataType value);
    [CompilerGeneratedAttribute]
public sealed virtual ILocalVariableDeclarationScope get_DeclarationScope();
    [CompilerGeneratedAttribute]
public void set_DeclarationScope(ILocalVariableDeclarationScope value);
    [DebuggerStepThroughAttribute]
public sealed virtual IMemberInitializerList get_Initializer();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Initializer(IMemberInitializerList value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.AnonymousObjectCreationExpression/<get_Children>d__13")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.ArgListCreationExpression : Expression {
    private IExpression[] myArguments;
    public IExpression[] Arguments { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression[] get_Arguments();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Arguments(IExpression[] value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.ArgListCreationExpression/<get_Children>d__5")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.ArgListReferenceExpression : Expression {
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.ArrayCreationExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataArrayType <ArrayType>k__BackingField;
    private IExpression[] myDimensions;
    private IExpressionList myInitializer;
    public IMetadataType ConstructedType { get; }
    public IMetadataArrayType ArrayType { get; public set; }
    public IExpression[] Dimensions { get; public set; }
    public IExpressionList Initializer { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public sealed virtual IMetadataType get_ConstructedType();
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataArrayType get_ArrayType();
    [CompilerGeneratedAttribute]
public void set_ArrayType(IMetadataArrayType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression[] get_Dimensions();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Dimensions(IExpression[] value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpressionList get_Initializer();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Initializer(IExpressionList value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.ArrayCreationExpression/<get_Children>d__17")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.ArrayElementAccessExpression : Expression {
    [CompilerGeneratedAttribute]
private bool <IsConditionalAccess>k__BackingField;
    private IExpression myArray;
    private IExpression[] myIndexes;
    public bool IsConditionalAccess { get; public set; }
    public IExpression Array { get; public set; }
    public IExpression[] Indexes { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsConditionalAccess();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsConditionalAccess(bool value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Array();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Array(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression[] get_Indexes();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Indexes(IExpression[] value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.ArrayElementAccessExpression/<get_Children>d__15")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.AwaitExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <ResultType>k__BackingField;
    private IExpression myArgument;
    public IMetadataType ResultType { get; public set; }
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_ResultType();
    [CompilerGeneratedAttribute]
public void set_ResultType(IMetadataType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.AwaitExpression/<get_Children>d__11")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.BaseReferenceExpression : ExpressionStatement {
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.BinaryOperationExpression : Expression {
    [CompilerGeneratedAttribute]
private OperationType <OperationType>k__BackingField;
    [CompilerGeneratedAttribute]
private OverflowCheckType <OverflowCheck>k__BackingField;
    private IExpression myLeftArgument;
    private IExpression myRightArgument;
    public OperationType OperationType { get; public set; }
    public OverflowCheckType OverflowCheck { get; public set; }
    public IExpression LeftArgument { get; public set; }
    public IExpression RightArgument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual OperationType get_OperationType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OperationType(OperationType value);
    [CompilerGeneratedAttribute]
public sealed virtual OverflowCheckType get_OverflowCheck();
    [CompilerGeneratedAttribute]
public void set_OverflowCheck(OverflowCheckType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_LeftArgument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_LeftArgument(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_RightArgument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_RightArgument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.BinaryOperationExpression/<get_Children>d__19")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.BlockStatement : Statement {
    private LinkedNodeList`1<IStatement> myStatements;
    public INodeList`1<IStatement> Statements { get; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public sealed virtual INodeList`1<IStatement> get_Statements();
    public virtual IEnumerable`1<INode> get_Children();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
    public virtual INode GetRightSibling(INode child);
    public virtual INode GetLeftSibling(INode child);
    public virtual object Clone();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
}
internal class JetBrains.Decompiler.Ast.Impl.BoxExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <SourceType>k__BackingField;
    private IExpression myArgument;
    public IMetadataType SourceType { get; public set; }
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_SourceType();
    [CompilerGeneratedAttribute]
public void set_SourceType(IMetadataType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.BoxExpression/<get_Children>d__11")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.BreakStatement : Statement {
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.CaseConstantPatternExpression : Expression {
    private IExpression myValue;
    private IExpression myPredicate;
    public IExpression Value { get; public set; }
    public IExpression Predicate { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Value();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Value(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Predicate();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Predicate(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.CaseConstantPatternExpression/<get_Children>d__11")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.CaseTypePatternExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <Type>k__BackingField;
    private ILocalVariableReferenceExpression myVariableReference;
    private IExpression myPredicate;
    public IMetadataType Type { get; public set; }
    public ILocalVariableReferenceExpression VariableReference { get; public set; }
    public IExpression Predicate { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IMetadataType value);
    [DebuggerStepThroughAttribute]
public sealed virtual ILocalVariableReferenceExpression get_VariableReference();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_VariableReference(ILocalVariableReferenceExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Predicate();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Predicate(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.CaseTypePatternExpression/<get_Children>d__15")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.CatchClause : Node {
    private ILocalVariableReferenceExpression myVariableReference;
    private IBlockStatement myFilter;
    private IBlockStatement myBody;
    public ILocalVariableReferenceExpression VariableReference { get; public set; }
    public IBlockStatement Filter { get; public set; }
    public IBlockStatement Body { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual ILocalVariableReferenceExpression get_VariableReference();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_VariableReference(ILocalVariableReferenceExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IBlockStatement get_Filter();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Filter(IBlockStatement value);
    [DebuggerStepThroughAttribute]
public sealed virtual IBlockStatement get_Body();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Body(IBlockStatement value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.CatchClause/<get_Children>d__13")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.CheckCastExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <Type>k__BackingField;
    private IExpression myArgument;
    public IMetadataType Type { get; public set; }
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IMetadataType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.CheckCastExpression/<get_Children>d__11")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.CheckFiniteExpression : Expression {
    private IExpression myExpression;
    public IExpression Expression { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Expression();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Expression(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.CheckFiniteExpression/<get_Children>d__5")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.CommentStatement : Statement {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; public set; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.ConditionalExpression : Expression {
    private IExpression myCondition;
    private IExpression myThen;
    private IExpression myElse;
    public IExpression Condition { get; public set; }
    public IExpression Then { get; public set; }
    public IExpression Else { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Condition();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Condition(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Then();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Then(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Else();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Else(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.ConditionalExpression/<get_Children>d__14")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.ConstantPatternExpression : Expression {
    private IExpression myArgument;
    private IExpression myConstant;
    public IExpression Argument { get; public set; }
    public IExpression Constant { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Constant();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Constant(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.ConstantPatternExpression/<get_Children>d__9")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.ConstructorInitializer : Node {
    [CompilerGeneratedAttribute]
private MethodSpecification <ConstructorSpecification>k__BackingField;
    private IExpression myTarget;
    private IExpression[] myArguments;
    public MethodSpecification ConstructorSpecification { get; public set; }
    public IExpression Target { get; public set; }
    public IExpression[] Arguments { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual MethodSpecification get_ConstructorSpecification();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConstructorSpecification(MethodSpecification value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Target();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Target(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression[] get_Arguments();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Arguments(IExpression[] value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.ConstructorInitializer/<get_Children>d__15")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.ContinueStatement : Statement {
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.ControlFlowBlockNode : Node {
    private INodeContainer myContainer;
    private IBlockStatement myBlockStatement;
    private IExpression myBranchExpression;
    public INodeContainer Container { get; }
    public IBlockStatement BlockStatement { get; public set; }
    public IExpression BranchExpression { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public virtual INodeContainer get_Container();
    public void SetContainer(INodeContainer container);
    public void ResetContainer();
    [DebuggerStepThroughAttribute]
public IBlockStatement get_BlockStatement();
    [DebuggerStepThroughAttribute]
public void set_BlockStatement(IBlockStatement value);
    [DebuggerStepThroughAttribute]
public IExpression get_BranchExpression();
    [DebuggerStepThroughAttribute]
public void set_BranchExpression(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.ControlFlowBlockNode/<get_Children>d__15")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
}
internal class JetBrains.Decompiler.Ast.Impl.DecompiledClass : object {
    [CompilerGeneratedAttribute]
private DataHolder <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataTypeInfo <TypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IDecompiledMethod> <Methods>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IDecompiledField> <Fields>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IDecompiledProperty> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IDecompiledEvent> <Events>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IMetadataTypeInfo> <NestedTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDecompiledMethod <TopLevelEntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private IDecompiledMethod <RecordPrimaryConstructor>k__BackingField;
    public DataHolder Data { get; }
    public IMetadataTypeInfo TypeInfo { get; }
    public IList`1<IDecompiledMethod> Methods { get; }
    public IList`1<IDecompiledField> Fields { get; }
    public IList`1<IDecompiledProperty> Properties { get; }
    public IList`1<IDecompiledEvent> Events { get; }
    public IList`1<IMetadataTypeInfo> NestedTypes { get; }
    public IDecompiledMethod TopLevelEntryPoint { get; public set; }
    public bool IsRecord { get; public set; }
    public IDecompiledMethod RecordPrimaryConstructor { get; public set; }
    public DecompiledClass(IMetadataTypeInfo typeInfo);
    [CompilerGeneratedAttribute]
public sealed virtual DataHolder get_Data();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataTypeInfo get_TypeInfo();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IDecompiledMethod> get_Methods();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IDecompiledField> get_Fields();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IDecompiledProperty> get_Properties();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IDecompiledEvent> get_Events();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IMetadataTypeInfo> get_NestedTypes();
    [CompilerGeneratedAttribute]
public sealed virtual IDecompiledMethod get_TopLevelEntryPoint();
    [CompilerGeneratedAttribute]
public void set_TopLevelEntryPoint(IDecompiledMethod value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRecord();
    [CompilerGeneratedAttribute]
public void set_IsRecord(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IDecompiledMethod get_RecordPrimaryConstructor();
    [CompilerGeneratedAttribute]
public void set_RecordPrimaryConstructor(IDecompiledMethod value);
}
internal class JetBrains.Decompiler.Ast.Impl.DecompiledEvent : object {
    [CompilerGeneratedAttribute]
private IDecompiledClass <OwnerClass>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataEvent <MetadataEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private IDecompiledMethod <Adder>k__BackingField;
    [CompilerGeneratedAttribute]
private IDecompiledMethod <Remover>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFieldLike>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <Initializer>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <BackingField>k__BackingField;
    public IDecompiledClass OwnerClass { get; }
    public IMetadataEvent MetadataEvent { get; }
    public IDecompiledMethod Adder { get; public set; }
    public IDecompiledMethod Remover { get; public set; }
    public bool IsFieldLike { get; public set; }
    public IExpression Initializer { get; public set; }
    public IMetadataField BackingField { get; public set; }
    public DecompiledEvent(IMetadataEvent metadataEvent, IDecompiledClass decompiledClass);
    [CompilerGeneratedAttribute]
public sealed virtual IDecompiledClass get_OwnerClass();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataEvent get_MetadataEvent();
    [CompilerGeneratedAttribute]
public sealed virtual IDecompiledMethod get_Adder();
    [CompilerGeneratedAttribute]
public void set_Adder(IDecompiledMethod value);
    [CompilerGeneratedAttribute]
public sealed virtual IDecompiledMethod get_Remover();
    [CompilerGeneratedAttribute]
public void set_Remover(IDecompiledMethod value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsFieldLike();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsFieldLike(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IExpression get_Initializer();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Initializer(IExpression value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataField get_BackingField();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BackingField(IMetadataField value);
}
internal class JetBrains.Decompiler.Ast.Impl.DecompiledField : object {
    [CompilerGeneratedAttribute]
private IDecompiledClass <OwnerClass>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <MetadataField>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUnsafe>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <Initializer>k__BackingField;
    public IDecompiledClass OwnerClass { get; }
    public IMetadataField MetadataField { get; }
    public bool IsUnsafe { get; public set; }
    public IExpression Initializer { get; public set; }
    public DecompiledField(IMetadataField metadataField, IDecompiledClass decompiledClass);
    [CompilerGeneratedAttribute]
public sealed virtual IDecompiledClass get_OwnerClass();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataField get_MetadataField();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsUnsafe();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsUnsafe(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IExpression get_Initializer();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Initializer(IExpression value);
}
internal class JetBrains.Decompiler.Ast.Impl.DecompiledMethod : DecompiledMethodBase {
    private NodeContainer myContainer;
    [CompilerGeneratedAttribute]
private IDecompiledClass <OwnerClass>k__BackingField;
    private IBlockStatement myBody;
    private IConstructorInitializer myConstructorInitializer;
    private IFunctionSignature mySignature;
    public INodeContainer Container { get; }
    public IDecompiledClass OwnerClass { get; }
    public string Name { get; }
    public IBlockStatement Body { get; public set; }
    public IConstructorInitializer ConstructorInitializer { get; public set; }
    public IFunctionSignature Signature { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public DecompiledMethod(IMetadataMethod metadataMethod, IDecompiledClass ownerClass, LocalVariableManager localVariableManager, LabelManager labelManager);
    public virtual INodeContainer get_Container();
    [CompilerGeneratedAttribute]
public sealed virtual IDecompiledClass get_OwnerClass();
    public virtual string ToString();
    public sealed virtual string get_Name();
    [DebuggerStepThroughAttribute]
public sealed virtual IBlockStatement get_Body();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Body(IBlockStatement value);
    [DebuggerStepThroughAttribute]
public sealed virtual IConstructorInitializer get_ConstructorInitializer();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_ConstructorInitializer(IConstructorInitializer value);
    [DebuggerStepThroughAttribute]
public sealed virtual IFunctionSignature get_Signature();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Signature(IFunctionSignature value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.DecompiledMethod/<get_Children>d__23")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
}
internal class JetBrains.Decompiler.Ast.Impl.DecompiledMethodBase : Node {
    protected LocalVariableManager LocalVariableManager;
    protected LabelManager LabelManager;
    [CanBeNullAttribute]
private IDictionary`2<MetadataToken, ILocalFunction> myLocalFunctions;
    [CompilerGeneratedAttribute]
private IMetadataMethod <MetadataMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <BodyExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUnsafe>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIterator>k__BackingField;
    [CompilerGeneratedAttribute]
private ILocalVariableDeclarationScope <DeclarationScope>k__BackingField;
    public ICollection`1<ILocalVariable> LocalVariables { get; }
    public ICollection`1<ILabel> Labels { get; }
    [NotNullAttribute]
public IDictionary`2<MetadataToken, ILocalFunction> LocalFunctions { get; }
    public IMetadataMethod MetadataMethod { get; }
    [CanBeNullAttribute]
public IExpression BodyExpression { get; public set; }
    public bool IsUnsafe { get; public set; }
    public bool IsIterator { get; public set; }
    public ILocalVariableDeclarationScope DeclarationScope { get; }
    protected DecompiledMethodBase(IMetadataMethod metadataMethod, LocalVariableManager localVariableManager, LabelManager labelManager, IDictionary`2<MetadataToken, ILocalFunction> localFunctions);
    public sealed virtual ICollection`1<ILocalVariable> get_LocalVariables();
    public sealed virtual ICollection`1<ILabel> get_Labels();
    public sealed virtual IDictionary`2<MetadataToken, ILocalFunction> get_LocalFunctions();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataMethod get_MetadataMethod();
    [CompilerGeneratedAttribute]
public sealed virtual IExpression get_BodyExpression();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BodyExpression(IExpression value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsUnsafe();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsUnsafe(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsIterator();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsIterator(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual ILocalVariableDeclarationScope get_DeclarationScope();
}
internal class JetBrains.Decompiler.Ast.Impl.DecompiledProperty : object {
    [CompilerGeneratedAttribute]
private IDecompiledClass <OwnerClass>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataProperty <MetadataProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private IDecompiledMethod <Getter>k__BackingField;
    [CompilerGeneratedAttribute]
private IDecompiledMethod <Setter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAuto>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <Initializer>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <BackingField>k__BackingField;
    public IDecompiledClass OwnerClass { get; }
    public IMetadataProperty MetadataProperty { get; }
    public IDecompiledMethod Getter { get; public set; }
    public IDecompiledMethod Setter { get; public set; }
    public bool IsAuto { get; public set; }
    public IExpression Initializer { get; public set; }
    public IMetadataField BackingField { get; public set; }
    public DecompiledProperty(IMetadataProperty metadataProperty, IDecompiledClass decompiledClass);
    [CompilerGeneratedAttribute]
public sealed virtual IDecompiledClass get_OwnerClass();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataProperty get_MetadataProperty();
    [CompilerGeneratedAttribute]
public sealed virtual IDecompiledMethod get_Getter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Getter(IDecompiledMethod value);
    [CompilerGeneratedAttribute]
public sealed virtual IDecompiledMethod get_Setter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Setter(IDecompiledMethod value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAuto();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsAuto(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IExpression get_Initializer();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Initializer(IExpression value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataField get_BackingField();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BackingField(IMetadataField value);
}
internal class JetBrains.Decompiler.Ast.Impl.DefaultValueExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <Type>k__BackingField;
    public IMetadataType Type { get; public set; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IMetadataType value);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.DelegateCallExpression : Expression {
    [CompilerGeneratedAttribute]
private MethodSpecification <InvokeSpecification>k__BackingField;
    private IExpression myDelegate;
    private IExpression[] myArguments;
    public bool IsVirtual { get; }
    public MethodSpecification InvokeSpecification { get; public set; }
    public IExpression Delegate { get; public set; }
    public IExpression[] Arguments { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public bool get_IsVirtual();
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual MethodSpecification get_InvokeSpecification();
    [CompilerGeneratedAttribute]
public void set_InvokeSpecification(MethodSpecification value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Delegate();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Delegate(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression[] get_Arguments();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Arguments(IExpression[] value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.DelegateCallExpression/<get_Children>d__17")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.DelegateCreationExpression : Expression {
    [CompilerGeneratedAttribute]
private MethodInstantiation <MethodInstantiation>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <ConstructedType>k__BackingField;
    private IExpression myTarget;
    public bool IsStatic { get; }
    public MethodInstantiation MethodInstantiation { get; public set; }
    public IMetadataType ConstructedType { get; public set; }
    public IExpression Target { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public sealed virtual bool get_IsStatic();
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual MethodInstantiation get_MethodInstantiation();
    [CompilerGeneratedAttribute]
public void set_MethodInstantiation(MethodInstantiation value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_ConstructedType();
    [CompilerGeneratedAttribute]
public void set_ConstructedType(IMetadataType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Target();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Target(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.DelegateCreationExpression/<get_Children>d__17")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.DerefExpression : Expression {
    [CompilerGeneratedAttribute]
private bool <Implicit>k__BackingField;
    private IExpression myArgument;
    public bool Implicit { get; public set; }
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Implicit();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Implicit(bool value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.DerefExpression/<get_Children>d__11")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.DiscardExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExplicitType>k__BackingField;
    public IMetadataType Type { get; public set; }
    public bool ExplicitType { get; public set; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IMetadataType value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ExplicitType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExplicitType(bool value);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.EmptyStatement : Statement {
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.EndFinallyStatement : Statement {
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.EventAccessExpression : Expression {
    [CompilerGeneratedAttribute]
private EventSpecification <EventSpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVirtual>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConditionalAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <ConstrainedType>k__BackingField;
    private IExpression myTarget;
    public MemberAccessKind AccessKind { get; }
    public bool IsStatic { get; }
    public EventSpecification EventSpecification { get; public set; }
    public bool IsVirtual { get; public set; }
    public bool IsConditionalAccess { get; public set; }
    public IMetadataType ConstrainedType { get; public set; }
    public IExpression Target { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public sealed virtual MemberAccessKind get_AccessKind();
    public sealed virtual bool get_IsStatic();
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual EventSpecification get_EventSpecification();
    [CompilerGeneratedAttribute]
public void set_EventSpecification(EventSpecification value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsVirtual();
    [CompilerGeneratedAttribute]
public void set_IsVirtual(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsConditionalAccess();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsConditionalAccess(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_ConstrainedType();
    [CompilerGeneratedAttribute]
public void set_ConstrainedType(IMetadataType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Target();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Target(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.EventAccessExpression/<get_Children>d__27")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal abstract class JetBrains.Decompiler.Ast.Impl.Expression : Node {
}
internal class JetBrains.Decompiler.Ast.Impl.ExpressionList : Expression {
    private LinkedNodeList`1<IExpression> myExpressions;
    public INodeList`1<IExpression> Expressions { get; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public sealed virtual INodeList`1<IExpression> get_Expressions();
    public virtual IEnumerable`1<INode> get_Children();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
    public virtual INode GetRightSibling(INode child);
    public virtual INode GetLeftSibling(INode child);
    public virtual object Clone();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
}
internal class JetBrains.Decompiler.Ast.Impl.ExpressionStatement : Statement {
    private IExpression myExpression;
    public IExpression Expression { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Expression();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Expression(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.ExpressionStatement/<get_Children>d__7")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.FieldAccessExpression : Expression {
    [CompilerGeneratedAttribute]
private MemberAccessKind <AccessKind>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldSpecification <FieldSpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConditionalAccess>k__BackingField;
    private IExpression myTarget;
    public bool IsStatic { get; }
    public MemberAccessKind AccessKind { get; public set; }
    public FieldSpecification FieldSpecification { get; public set; }
    public bool IsConditionalAccess { get; public set; }
    public IExpression Target { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public sealed virtual bool get_IsStatic();
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual MemberAccessKind get_AccessKind();
    [CompilerGeneratedAttribute]
public void set_AccessKind(MemberAccessKind value);
    [CompilerGeneratedAttribute]
public sealed virtual FieldSpecification get_FieldSpecification();
    [CompilerGeneratedAttribute]
public void set_FieldSpecification(FieldSpecification value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsConditionalAccess();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsConditionalAccess(bool value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Target();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Target(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.FieldAccessExpression/<get_Children>d__21")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.FieldMemberInitializer : Node {
    [CompilerGeneratedAttribute]
private IMetadataField <Field>k__BackingField;
    private IExpression myValue;
    public IMetadataField Field { get; public set; }
    public IExpression Value { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataField get_Field();
    [CompilerGeneratedAttribute]
public void set_Field(IMetadataField value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Value();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Value(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.FieldMemberInitializer/<get_Children>d__11")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.FieldReferenceExpression : Expression {
    [CompilerGeneratedAttribute]
private FieldSpecification <FieldSpecification>k__BackingField;
    public FieldSpecification FieldSpecification { get; public set; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    [CompilerGeneratedAttribute]
public sealed virtual FieldSpecification get_FieldSpecification();
    [CompilerGeneratedAttribute]
public void set_FieldSpecification(FieldSpecification value);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.FixedStatement : Statement {
    private ILocalVariableReferenceExpression myVariableReference;
    private IExpression myInitializer;
    private IStatement myBody;
    public ILocalVariableReferenceExpression VariableReference { get; public set; }
    public IExpression Initializer { get; public set; }
    public IStatement Body { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual ILocalVariableReferenceExpression get_VariableReference();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_VariableReference(ILocalVariableReferenceExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Initializer();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Initializer(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IStatement get_Body();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Body(IStatement value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.FixedStatement/<get_Children>d__13")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.ForEachStatement : Statement {
    [CompilerGeneratedAttribute]
private bool <IsAwait>k__BackingField;
    private IDeclarationExpression myElementDeclaration;
    private IExpression myExpression;
    private IStatement myBody;
    public bool IsAwait { get; public set; }
    public IDeclarationExpression ElementDeclaration { get; public set; }
    public IExpression Expression { get; public set; }
    public IStatement Body { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAwait();
    [CompilerGeneratedAttribute]
public void set_IsAwait(bool value);
    [DebuggerStepThroughAttribute]
public sealed virtual IDeclarationExpression get_ElementDeclaration();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_ElementDeclaration(IDeclarationExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Expression();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Expression(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IStatement get_Body();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Body(IStatement value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.ForEachStatement/<get_Children>d__19")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.ForStatement : Statement {
    private IStatement myInitializer;
    private IExpression myCondition;
    private IStatement myIterator;
    private IStatement myBody;
    public IStatement Initializer { get; public set; }
    public IExpression Condition { get; public set; }
    public IStatement Iterator { get; public set; }
    public IStatement Body { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [DebuggerStepThroughAttribute]
public sealed virtual IStatement get_Initializer();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Initializer(IStatement value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Condition();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Condition(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IStatement get_Iterator();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Iterator(IStatement value);
    [DebuggerStepThroughAttribute]
public sealed virtual IStatement get_Body();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Body(IStatement value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.ForStatement/<get_Children>d__19")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.FunctionPointerCallExpression : Expression {
    private IExpression myFunctionPointer;
    private IExpression[] myArguments;
    public IExpression FunctionPointer { get; public set; }
    public IExpression[] Arguments { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_FunctionPointer();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_FunctionPointer(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression[] get_Arguments();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Arguments(IExpression[] value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.FunctionPointerCallExpression/<get_Children>d__9")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.FunctionSignature : Node {
    [CompilerGeneratedAttribute]
private IList`1<IMethodParameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <OwnParametersCount>k__BackingField;
    [CompilerGeneratedAttribute]
private FunctionSignatureStyle <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasArgList>k__BackingField;
    public IList`1<IMethodParameter> Parameters { get; private set; }
    public Nullable`1<int> OwnParametersCount { get; public set; }
    public FunctionSignatureStyle Style { get; public set; }
    public bool IsAsync { get; public set; }
    public bool HasArgList { get; public set; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IMethodParameter> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(IList`1<IMethodParameter> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_OwnParametersCount();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OwnParametersCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public sealed virtual FunctionSignatureStyle get_Style();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Style(FunctionSignatureStyle value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAsync();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsAsync(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasArgList();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HasArgList(bool value);
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
    public virtual object Clone();
}
internal class JetBrains.Decompiler.Ast.Impl.GotoCaseStatement : Statement {
    [CompilerGeneratedAttribute]
private bool <IsConstantPatternCase>k__BackingField;
    private IExpression myCaseValue;
    public bool IsConstantPatternCase { get; public set; }
    public IExpression CaseValue { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsConstantPatternCase();
    [CompilerGeneratedAttribute]
public void set_IsConstantPatternCase(bool value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_CaseValue();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_CaseValue(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.GotoCaseStatement/<get_Children>d__11")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.GotoDefaultStatement : Statement {
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.GotoStatement : Statement {
    [CompilerGeneratedAttribute]
private ILabel <Label>k__BackingField;
    public ILabel Label { get; public set; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual ILabel get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(ILabel value);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.IfStatement : Statement {
    private IExpression myCondition;
    private IStatement myThen;
    private IStatement myElse;
    public IExpression Condition { get; public set; }
    public IStatement Then { get; public set; }
    public IStatement Else { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Condition();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Condition(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IStatement get_Then();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Then(IStatement value);
    [DebuggerStepThroughAttribute]
public sealed virtual IStatement get_Else();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Else(IStatement value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.IfStatement/<get_Children>d__15")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.IndexerCallExpression : Expression {
    [CompilerGeneratedAttribute]
private bool <IsVirtual>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertySpecification <PropertySpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConditionalAccess>k__BackingField;
    private IExpression myTarget;
    private IExpression[] myArguments;
    public MemberAccessKind AccessKind { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; public set; }
    public PropertySpecification PropertySpecification { get; public set; }
    public bool IsConditionalAccess { get; public set; }
    public IExpression Target { get; public set; }
    public IExpression[] Arguments { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public sealed virtual MemberAccessKind get_AccessKind();
    public sealed virtual bool get_IsStatic();
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsVirtual();
    [CompilerGeneratedAttribute]
public void set_IsVirtual(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual PropertySpecification get_PropertySpecification();
    [CompilerGeneratedAttribute]
public void set_PropertySpecification(PropertySpecification value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsConditionalAccess();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsConditionalAccess(bool value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Target();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Target(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression[] get_Arguments();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Arguments(IExpression[] value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.IndexerCallExpression/<get_Children>d__27")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.IndexerMemberInitializer : Node {
    [CompilerGeneratedAttribute]
private IMetadataProperty <Property>k__BackingField;
    private IExpression myValue;
    private IExpression[] myArguments;
    public IMetadataProperty Property { get; public set; }
    public IExpression Value { get; public set; }
    public IExpression[] Arguments { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataProperty get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(IMetadataProperty value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Value();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Value(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression[] get_Arguments();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Arguments(IExpression[] value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.IndexerMemberInitializer/<get_Children>d__13")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.JumpStatement : Statement {
    [CompilerGeneratedAttribute]
private MethodInstantiation <MethodInstantiation>k__BackingField;
    public MethodInstantiation MethodInstantiation { get; public set; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [CompilerGeneratedAttribute]
public sealed virtual MethodInstantiation get_MethodInstantiation();
    [CompilerGeneratedAttribute]
public void set_MethodInstantiation(MethodInstantiation value);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.Label : object {
    [CompilerGeneratedAttribute]
private IDecompiledMethodBase <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public IDecompiledMethodBase Method { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IDecompiledMethodBase get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(IDecompiledMethodBase value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
internal class JetBrains.Decompiler.Ast.Impl.LabelDeclarationStatement : Statement {
    [CompilerGeneratedAttribute]
private ILabel <Label>k__BackingField;
    public ILabel Label { get; public set; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual ILabel get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(ILabel value);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.LambdaBlockExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataMethod <MetadataMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ILocalVariableDeclarationScope <DeclarationScope>k__BackingField;
    private IFunctionSignature mySignature;
    private IBlockStatement myBody;
    public IMetadataType ConstructedType { get; }
    public IMetadataMethod MetadataMethod { get; public set; }
    public ILocalVariableDeclarationScope DeclarationScope { get; public set; }
    public IFunctionSignature Signature { get; public set; }
    public IBlockStatement Body { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public sealed virtual IMetadataType get_ConstructedType();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataMethod get_MetadataMethod();
    [CompilerGeneratedAttribute]
public void set_MetadataMethod(IMetadataMethod value);
    [CompilerGeneratedAttribute]
public sealed virtual ILocalVariableDeclarationScope get_DeclarationScope();
    [CompilerGeneratedAttribute]
public void set_DeclarationScope(ILocalVariableDeclarationScope value);
    [DebuggerStepThroughAttribute]
public sealed virtual IFunctionSignature get_Signature();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Signature(IFunctionSignature value);
    [DebuggerStepThroughAttribute]
public sealed virtual IBlockStatement get_Body();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Body(IBlockStatement value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.LambdaBlockExpression/<get_Children>d__20")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.LambdaExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataMethod <MetadataMethod>k__BackingField;
    private IFunctionSignature mySignature;
    private IExpression myBody;
    public IMetadataType ConstructedType { get; }
    public IMetadataMethod MetadataMethod { get; public set; }
    public IFunctionSignature Signature { get; public set; }
    public IExpression Body { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public sealed virtual IMetadataType get_ConstructedType();
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataMethod get_MetadataMethod();
    [CompilerGeneratedAttribute]
public void set_MetadataMethod(IMetadataMethod value);
    [DebuggerStepThroughAttribute]
public sealed virtual IFunctionSignature get_Signature();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Signature(IFunctionSignature value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Body();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Body(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.LambdaExpression/<get_Children>d__17")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.LinkedNodeList`1 : object {
    private Node myParent;
    private LinkedList`1<T> myList;
    private Dictionary`2<T, LinkedListNode`1<T>> myNodeMap;
    public T First { get; }
    public T Last { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public LinkedNodeList`1(Node parent);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.LinkedNodeList`1/<GetEnumerator>d__4")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T node);
    public sealed virtual void AddFront(T node);
    public sealed virtual void AddBack(T node);
    public sealed virtual void AddBefore(T anchor, T node);
    public sealed virtual void AddAfter(T anchor, T node);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T node);
    public sealed virtual void Replace(T oldNode, T newNode);
    public sealed virtual bool Contains(T item);
    public sealed virtual T GetNext(T node);
    public sealed virtual T GetPrevious(T node);
    public sealed virtual T get_First();
    public sealed virtual T get_Last();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
internal class JetBrains.Decompiler.Ast.Impl.LiteralExpression : Expression {
    [CompilerGeneratedAttribute]
private Constant <Value>k__BackingField;
    public Constant Value { get; public set; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual Constant get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Constant value);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.LocalFunction : DecompiledMethodBase {
    [CanBeNullAttribute]
private INodeContainer myContainer;
    [CompilerGeneratedAttribute]
private IDecompiledMethodBase <OwnerMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    private IBlockStatement myBody;
    private IFunctionSignature mySignature;
    public INodeContainer Container { get; }
    public IDecompiledMethodBase OwnerMethod { get; }
    public string Name { get; }
    public bool IsStatic { get; public set; }
    public IBlockStatement Body { get; public set; }
    public IFunctionSignature Signature { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public LocalFunction(IMetadataMethod metadataMethod, IDecompiledMethodBase ownerMethod, LocalVariableManager localVariableManager, LabelManager labelManager);
    private LocalFunction(IMetadataMethod metadataMethod, IDecompiledMethodBase ownerMethod, INodeContainer container, LocalVariableManager localVariableManager, LabelManager labelManager, IDictionary`2<MetadataToken, ILocalFunction> localFunctions);
    public virtual INodeContainer get_Container();
    [CompilerGeneratedAttribute]
public sealed virtual IDecompiledMethodBase get_OwnerMethod();
    public sealed virtual ILocalFunction Detach();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public virtual object Clone();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsStatic();
    [CompilerGeneratedAttribute]
public void set_IsStatic(bool value);
    [DebuggerStepThroughAttribute]
public sealed virtual IBlockStatement get_Body();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Body(IBlockStatement value);
    [DebuggerStepThroughAttribute]
public sealed virtual IFunctionSignature get_Signature();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Signature(IFunctionSignature value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.LocalFunction/<get_Children>d__27")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
}
internal class JetBrains.Decompiler.Ast.Impl.LocalFunctionCallExpression : Expression {
    private string myName;
    [CompilerGeneratedAttribute]
private MethodInstantiation <MethodInstantiation>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <OwnerMethod>k__BackingField;
    private IExpression[] myArguments;
    public string Name { get; }
    public MethodInstantiation MethodInstantiation { get; public set; }
    public IMetadataMethod OwnerMethod { get; public set; }
    public IExpression[] Arguments { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public sealed virtual string get_Name();
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual MethodInstantiation get_MethodInstantiation();
    [CompilerGeneratedAttribute]
public void set_MethodInstantiation(MethodInstantiation value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataMethod get_OwnerMethod();
    [CompilerGeneratedAttribute]
public void set_OwnerMethod(IMetadataMethod value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression[] get_Arguments();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Arguments(IExpression[] value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.LocalFunctionCallExpression/<get_Children>d__18")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.LocalFunctionDelegateCreationExpression : Expression {
    [CompilerGeneratedAttribute]
private MethodInstantiation <MethodInstantiation>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <OwnerMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <ConstructedType>k__BackingField;
    public MethodInstantiation MethodInstantiation { get; public set; }
    public IMetadataMethod OwnerMethod { get; public set; }
    public IMetadataType ConstructedType { get; public set; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual MethodInstantiation get_MethodInstantiation();
    [CompilerGeneratedAttribute]
public void set_MethodInstantiation(MethodInstantiation value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataMethod get_OwnerMethod();
    [CompilerGeneratedAttribute]
public void set_OwnerMethod(IMetadataMethod value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_ConstructedType();
    [CompilerGeneratedAttribute]
public void set_ConstructedType(IMetadataType value);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.LocalVariable : object {
    [CompilerGeneratedAttribute]
private IDecompiledMethodBase <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private ILocalVariableDeclarationScope <DeclarationScope>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalVariableKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Duplicated>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodBodyLocalVariable <MetadataVariable>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <MetadataField>k__BackingField;
    [CompilerGeneratedAttribute]
private IInstructionsRange <InstructionsRange>k__BackingField;
    public IDecompiledMethodBase Method { get; public set; }
    public ILocalVariableDeclarationScope DeclarationScope { get; public set; }
    public LocalVariableKind Kind { get; public set; }
    public bool Duplicated { get; public set; }
    public IMetadataType Type { get; public set; }
    public string Name { get; public set; }
    public IMethodBodyLocalVariable MetadataVariable { get; public set; }
    public IMetadataField MetadataField { get; public set; }
    public IInstructionsRange InstructionsRange { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IDecompiledMethodBase get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(IDecompiledMethodBase value);
    [CompilerGeneratedAttribute]
public sealed virtual ILocalVariableDeclarationScope get_DeclarationScope();
    [CompilerGeneratedAttribute]
public void set_DeclarationScope(ILocalVariableDeclarationScope value);
    [CompilerGeneratedAttribute]
public sealed virtual LocalVariableKind get_Kind();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Kind(LocalVariableKind value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Duplicated();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Duplicated(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Type(IMetadataType value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IMethodBodyLocalVariable get_MetadataVariable();
    [CompilerGeneratedAttribute]
public void set_MetadataVariable(IMethodBodyLocalVariable value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataField get_MetadataField();
    [CompilerGeneratedAttribute]
public void set_MetadataField(IMetadataField value);
    [CompilerGeneratedAttribute]
public sealed virtual IInstructionsRange get_InstructionsRange();
    [CompilerGeneratedAttribute]
public void set_InstructionsRange(IInstructionsRange value);
    public sealed virtual void SetMetadataVariableAndInstructionRange(ILocalVariable other);
    public virtual string ToString();
}
internal class JetBrains.Decompiler.Ast.Impl.LocalVariableDeclarationScope : object {
}
internal class JetBrains.Decompiler.Ast.Impl.LocalVariableDeclarationStatement : Statement {
    [CompilerGeneratedAttribute]
private LocalVariableDeclarationModifierKind <ModifierKind>k__BackingField;
    private ILocalVariableReferenceExpression myVariableReference;
    private IExpression myInitializer;
    public LocalVariableDeclarationModifierKind ModifierKind { get; public set; }
    public ILocalVariableReferenceExpression VariableReference { get; public set; }
    public IExpression Initializer { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual LocalVariableDeclarationModifierKind get_ModifierKind();
    [CompilerGeneratedAttribute]
public void set_ModifierKind(LocalVariableDeclarationModifierKind value);
    [DebuggerStepThroughAttribute]
public sealed virtual ILocalVariableReferenceExpression get_VariableReference();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_VariableReference(ILocalVariableReferenceExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Initializer();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Initializer(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.LocalVariableDeclarationStatement/<get_Children>d__15")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.LocalVariableReferenceExpression : Expression {
    [CompilerGeneratedAttribute]
private ILocalVariable <Variable>k__BackingField;
    public ILocalVariable Variable { get; public set; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual ILocalVariable get_Variable();
    [CompilerGeneratedAttribute]
public void set_Variable(ILocalVariable value);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.LockStatement : Statement {
    private IExpression myExpression;
    private IStatement myBody;
    public IExpression Expression { get; public set; }
    public IStatement Body { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Expression();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Expression(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IStatement get_Body();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Body(IStatement value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.LockStatement/<get_Children>d__9")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.LoopStatement : Statement {
    [CompilerGeneratedAttribute]
private LoopType <LoopType>k__BackingField;
    private IExpression myCondition;
    private IStatement myBody;
    public LoopType LoopType { get; public set; }
    public IExpression Condition { get; public set; }
    public IStatement Body { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual LoopType get_LoopType();
    [CompilerGeneratedAttribute]
public void set_LoopType(LoopType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Condition();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Condition(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IStatement get_Body();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Body(IStatement value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.LoopStatement/<get_Children>d__15")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.MakeRefExpression : Expression {
    private IExpression myArgument;
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.MakeRefExpression/<get_Children>d__5")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.MemberInitializerList : Expression {
    private LinkedNodeList`1<IMemberInitializer> myInitializers;
    public INodeList`1<IMemberInitializer> Initializers { get; }
    public IEnumerable`1<INode> Children { get; }
    public sealed virtual INodeList`1<IMemberInitializer> get_Initializers();
    public virtual IEnumerable`1<INode> get_Children();
    public virtual INode GetRightSibling(INode child);
    public virtual INode GetLeftSibling(INode child);
    public virtual object Clone();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
}
internal class JetBrains.Decompiler.Ast.Impl.MemoryCopyStatement : Statement {
    private IExpression myDestination;
    private IExpression mySource;
    private IExpression myLength;
    public IExpression Destination { get; public set; }
    public IExpression Source { get; public set; }
    public IExpression Length { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Destination();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Destination(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Source();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Source(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Length();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Length(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.MemoryCopyStatement/<get_Children>d__13")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.MemoryInitializeStatement : Statement {
    private IExpression myDestination;
    private IExpression myValue;
    private IExpression myLength;
    public IExpression Destination { get; public set; }
    public IExpression Value { get; public set; }
    public IExpression Length { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Destination();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Destination(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Value();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Value(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Length();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Length(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.MemoryInitializeStatement/<get_Children>d__13")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.MethodCallExpression : Expression {
    [CompilerGeneratedAttribute]
private MethodInstantiation <MethodInstantiation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVirtual>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberAccessKind <AccessKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConditionalAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <ConstrainedType>k__BackingField;
    private IExpression myTarget;
    private IExpression[] myArguments;
    public bool IsStatic { get; }
    public string Name { get; }
    public MethodInstantiation MethodInstantiation { get; public set; }
    public bool IsVirtual { get; public set; }
    public MemberAccessKind AccessKind { get; public set; }
    public bool IsConditionalAccess { get; public set; }
    public IMetadataType ConstrainedType { get; public set; }
    public IExpression Target { get; public set; }
    public IExpression[] Arguments { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public sealed virtual bool get_IsStatic();
    public sealed virtual string get_Name();
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual MethodInstantiation get_MethodInstantiation();
    [CompilerGeneratedAttribute]
public void set_MethodInstantiation(MethodInstantiation value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsVirtual();
    [CompilerGeneratedAttribute]
public void set_IsVirtual(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual MemberAccessKind get_AccessKind();
    [CompilerGeneratedAttribute]
public void set_AccessKind(MemberAccessKind value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsConditionalAccess();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsConditionalAccess(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_ConstrainedType();
    [CompilerGeneratedAttribute]
public void set_ConstrainedType(IMetadataType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Target();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Target(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression[] get_Arguments();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Arguments(IExpression[] value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.MethodCallExpression/<get_Children>d__35")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.MethodParameter : object {
    [CanBeNullAttribute]
private IMetadataType myType;
    [CompilerGeneratedAttribute]
private MethodParameterKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataParameter <MetadataParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private IDecompiledMethodBase <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public MethodParameterKind Kind { get; public set; }
    public IMetadataParameter MetadataParameter { get; public set; }
    public IDecompiledMethodBase Method { get; public set; }
    public string Name { get; public set; }
    public int Index { get; public set; }
    public IMetadataType Type { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual MethodParameterKind get_Kind();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Kind(MethodParameterKind value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataParameter get_MetadataParameter();
    [CompilerGeneratedAttribute]
public void set_MetadataParameter(IMetadataParameter value);
    [CompilerGeneratedAttribute]
public sealed virtual IDecompiledMethodBase get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(IDecompiledMethodBase value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Index();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Index(int value);
    public sealed virtual IMetadataType get_Type();
    public void set_Type(IMetadataType value);
    public virtual string ToString();
}
internal class JetBrains.Decompiler.Ast.Impl.MethodPointerExpression : Expression {
    [CompilerGeneratedAttribute]
private MethodInstantiation <MethodInstantiation>k__BackingField;
    public MethodInstantiation MethodInstantiation { get; public set; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [CompilerGeneratedAttribute]
public sealed virtual MethodInstantiation get_MethodInstantiation();
    [CompilerGeneratedAttribute]
public void set_MethodInstantiation(MethodInstantiation value);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.MethodReferenceExpression : Expression {
    [CompilerGeneratedAttribute]
private MethodInstantiation <MethodInstantiation>k__BackingField;
    public MethodInstantiation MethodInstantiation { get; public set; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [CompilerGeneratedAttribute]
public sealed virtual MethodInstantiation get_MethodInstantiation();
    [CompilerGeneratedAttribute]
public void set_MethodInstantiation(MethodInstantiation value);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.NamedArgumentExpression : Expression {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MetadataParameterIndex>k__BackingField;
    private IExpression myArgument;
    public string ParameterName { get; public set; }
    public int MetadataParameterIndex { get; public set; }
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ParameterName();
    [CompilerGeneratedAttribute]
public void set_ParameterName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MetadataParameterIndex();
    [CompilerGeneratedAttribute]
public void set_MetadataParameterIndex(int value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.NamedArgumentExpression/<get_Children>d__15")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.NameOfExpression : Expression {
    [CompilerGeneratedAttribute]
private string <Argument>k__BackingField;
    public string Argument { get; public set; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Argument();
    [CompilerGeneratedAttribute]
public void set_Argument(string value);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.NestedInitializer : Expression {
    private IMemberInitializerList myObjectInitializer;
    private IExpressionList myCollectionInitializer;
    public IMemberInitializerList ObjectInitializer { get; public set; }
    public IExpressionList CollectionInitializer { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual IMemberInitializerList get_ObjectInitializer();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_ObjectInitializer(IMemberInitializerList value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpressionList get_CollectionInitializer();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_CollectionInitializer(IExpressionList value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.NestedInitializer/<get_Children>d__9")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal abstract class JetBrains.Decompiler.Ast.Impl.Node : object {
    private DataHolder myData;
    [CompilerGeneratedAttribute]
private IInstructionReference <InstructionReference>k__BackingField;
    [CompilerGeneratedAttribute]
private INode <Parent>k__BackingField;
    public INodeContainer Container { get; }
    public bool IsAttached { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public DataHolder Data { get; }
    public IInstructionReference InstructionReference { get; public set; }
    public INode Parent { get; private set; }
    public IEnumerable`1<INode> Children { get; }
    public virtual INodeContainer get_Container();
    public sealed virtual bool get_IsAttached();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
    public sealed virtual DataHolder get_Data();
    [CompilerGeneratedAttribute]
public sealed virtual IInstructionReference get_InstructionReference();
    [CompilerGeneratedAttribute]
public sealed virtual void set_InstructionReference(IInstructionReference value);
    [CompilerGeneratedAttribute]
public sealed virtual INode get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(INode value);
    public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual INode GetRightSibling(INode child);
    public virtual INode GetLeftSibling(INode child);
    public virtual object Clone();
    internal void InternalAttach(INode child);
    internal void InternalDetach(INode child);
    internal void InternalReplace(INode oldChild, INode newChild);
    protected void InternalSet(T& child, T newChild);
    protected void InternalSet(T[]& children, T[] newChildren);
    protected bool InternalReplace(T& child, INode oldChild, INode newChild);
    protected bool InternalReplace(T[] children, INode oldChild, INode newChild);
    protected void InitializeCopy(INode origin);
    private string GetInstructionString();
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    public virtual string ToString();
}
internal class JetBrains.Decompiler.Ast.Impl.NodeContainer : object {
    private JetHashSet`1<INode> myNodes;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<INode>> NodeAttached;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<INode>> NodeDetached;
    public ICollection`1<INode> Nodes { get; }
    public sealed virtual void AttachTree(INode root);
    public sealed virtual void DetachTree(INode root);
    public sealed virtual ICollection`1<INode> get_Nodes();
    [CompilerGeneratedAttribute]
public sealed virtual void add_NodeAttached(EventHandler`1<EventArgs`1<INode>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_NodeAttached(EventHandler`1<EventArgs`1<INode>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_NodeDetached(EventHandler`1<EventArgs`1<INode>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_NodeDetached(EventHandler`1<EventArgs`1<INode>> value);
    private void InvokeNodeAttached(INode node);
    private void InvokeNodeDetached(INode node);
    [CompilerGeneratedAttribute]
private void <AttachTree>b__1_0(INode currentNode);
    [CompilerGeneratedAttribute]
private void <DetachTree>b__2_0(INode currentNode);
}
internal static class JetBrains.Decompiler.Ast.Impl.NodeListUtil : object {
    public static bool AreDeepEqual(INodeList`1<T> list1, INodeList`1<T> list2);
}
internal class JetBrains.Decompiler.Ast.Impl.ObjectCreationExpression : Expression {
    [CompilerGeneratedAttribute]
private MethodSpecification <ConstructorSpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <ConstructedType>k__BackingField;
    private IExpression[] myArguments;
    private IMemberInitializerList myObjectInitializer;
    private IExpressionList myCollectionInitializer;
    public MethodSpecification ConstructorSpecification { get; public set; }
    public IMetadataType ConstructedType { get; public set; }
    public IExpression[] Arguments { get; public set; }
    public IMemberInitializerList ObjectInitializer { get; public set; }
    public IExpressionList CollectionInitializer { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual MethodSpecification get_ConstructorSpecification();
    [CompilerGeneratedAttribute]
public void set_ConstructorSpecification(MethodSpecification value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_ConstructedType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConstructedType(IMetadataType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression[] get_Arguments();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Arguments(IExpression[] value);
    [DebuggerStepThroughAttribute]
public sealed virtual IMemberInitializerList get_ObjectInitializer();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_ObjectInitializer(IMemberInitializerList value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpressionList get_CollectionInitializer();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_CollectionInitializer(IExpressionList value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.ObjectCreationExpression/<get_Children>d__23")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.ParameterModifierExpression : Expression {
    [CompilerGeneratedAttribute]
private ParameterModifierKind <ModifierKind>k__BackingField;
    private IExpression myArgument;
    public ParameterModifierKind ModifierKind { get; public set; }
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual ParameterModifierKind get_ModifierKind();
    [CompilerGeneratedAttribute]
public void set_ModifierKind(ParameterModifierKind value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.ParameterModifierExpression/<get_Children>d__11")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.ParameterReferenceExpression : Expression {
    [CompilerGeneratedAttribute]
private IMethodParameter <Parameter>k__BackingField;
    public IMethodParameter Parameter { get; public set; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodParameter get_Parameter();
    [CompilerGeneratedAttribute]
public void set_Parameter(IMethodParameter value);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.PinStatement : Statement {
    private ILocalVariableReferenceExpression myVariableReference;
    private IExpression myInitializer;
    public ILocalVariableReferenceExpression VariableReference { get; public set; }
    public IExpression Initializer { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual ILocalVariableReferenceExpression get_VariableReference();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_VariableReference(ILocalVariableReferenceExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Initializer();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Initializer(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.PinStatement/<get_Children>d__9")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.PointerElementAccessExpression : Expression {
    private IExpression myPointer;
    private IExpression myIndex;
    public IExpression Pointer { get; public set; }
    public IExpression Index { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Pointer();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Pointer(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Index();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Index(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.PointerElementAccessExpression/<get_Children>d__9")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.PointerIndirectionExpression : Expression {
    private IExpression myArgument;
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.PointerIndirectionExpression/<get_Children>d__5")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.PropertyAccessExpression : Expression {
    [CompilerGeneratedAttribute]
private MemberAccessKind <AccessKind>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertySpecification <PropertySpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVirtual>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConditionalAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <ConstrainedType>k__BackingField;
    private IExpression myTarget;
    public bool IsStatic { get; }
    public MemberAccessKind AccessKind { get; public set; }
    public PropertySpecification PropertySpecification { get; public set; }
    public bool IsVirtual { get; public set; }
    public bool IsConditionalAccess { get; public set; }
    public IMetadataType ConstrainedType { get; public set; }
    public IExpression Target { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public sealed virtual bool get_IsStatic();
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual MemberAccessKind get_AccessKind();
    [CompilerGeneratedAttribute]
public void set_AccessKind(MemberAccessKind value);
    [CompilerGeneratedAttribute]
public sealed virtual PropertySpecification get_PropertySpecification();
    [CompilerGeneratedAttribute]
public void set_PropertySpecification(PropertySpecification value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsVirtual();
    [CompilerGeneratedAttribute]
public void set_IsVirtual(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsConditionalAccess();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsConditionalAccess(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_ConstrainedType();
    [CompilerGeneratedAttribute]
public void set_ConstrainedType(IMetadataType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Target();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Target(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.PropertyAccessExpression/<get_Children>d__29")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.PropertyMemberInitializer : Node {
    [CompilerGeneratedAttribute]
private IMetadataProperty <Property>k__BackingField;
    private IExpression myValue;
    public IMetadataProperty Property { get; public set; }
    public IExpression Value { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataProperty get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(IMetadataProperty value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Value();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Value(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.PropertyMemberInitializer/<get_Children>d__11")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.RefExpression : Expression {
    [CompilerGeneratedAttribute]
private bool <Implicit>k__BackingField;
    private IExpression myArgument;
    public bool Implicit { get; public set; }
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Implicit();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Implicit(bool value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.RefExpression/<get_Children>d__11")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.RefModifierExpression : Expression {
    private IExpression myArgument;
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.RefModifierExpression/<get_Children>d__7")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.RefTypeExpression : Expression {
    private IExpression myArgument;
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.RefTypeExpression/<get_Children>d__5")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.RefTypeTokenExpression : Expression {
    private IExpression myArgument;
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.RefTypeTokenExpression/<get_Children>d__5")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.RefValueExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <Type>k__BackingField;
    private IExpression myArgument;
    public IMetadataType Type { get; public set; }
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IMetadataType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.RefValueExpression/<get_Children>d__9")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.RethrowStatement : Statement {
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.ReturnStatement : Statement {
    private IExpression myResult;
    public IExpression Result { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Result();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Result(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.ReturnStatement/<get_Children>d__7")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.SizeOfExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <Type>k__BackingField;
    public IMetadataType Type { get; public set; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IMetadataType value);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.StackAllocExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <SpanType>k__BackingField;
    private IExpression myLength;
    private IExpressionList myInitializer;
    public IMetadataType ElementType { get; public set; }
    public IMetadataClassType SpanType { get; public set; }
    public IExpression Length { get; public set; }
    public IExpressionList Initializer { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public sealed virtual void SetElementType(IMetadataType elementType);
    public sealed virtual void SetSpanType(IMetadataClassType spanType);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_ElementType();
    [CompilerGeneratedAttribute]
public void set_ElementType(IMetadataType value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataClassType get_SpanType();
    [CompilerGeneratedAttribute]
public void set_SpanType(IMetadataClassType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Length();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Length(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpressionList get_Initializer();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Initializer(IExpressionList value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.StackAllocExpression/<get_Children>d__19")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal abstract class JetBrains.Decompiler.Ast.Impl.Statement : Node {
}
internal class JetBrains.Decompiler.Ast.Impl.SuccessfulFilteringStatement : Statement {
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.SwitchCase : Node {
    private IExpression[] myValues;
    private IBlockStatement myBody;
    public IExpression[] Values { get; public set; }
    public IBlockStatement Body { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression[] get_Values();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Values(IExpression[] value);
    [DebuggerStepThroughAttribute]
public sealed virtual IBlockStatement get_Body();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Body(IBlockStatement value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.SwitchCase/<get_Children>d__11")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.SwitchStatement : Statement {
    private IExpression myExpression;
    private ISwitchCase[] myCases;
    private IBlockStatement myDefault;
    public IExpression Expression { get; public set; }
    public ISwitchCase[] Cases { get; public set; }
    public IBlockStatement Default { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Expression();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Expression(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual ISwitchCase[] get_Cases();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Cases(ISwitchCase[] value);
    [DebuggerStepThroughAttribute]
public sealed virtual IBlockStatement get_Default();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Default(IBlockStatement value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.SwitchStatement/<get_Children>d__15")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.ThisReferenceExpression : Expression {
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.ThrowExpression : Expression {
    private IExpression myArgument;
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.ThrowExpression/<get_Children>d__7")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.ThrowStatement : Statement {
    private IExpression myArgument;
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.ThrowStatement/<get_Children>d__7")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.TryCastExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <Type>k__BackingField;
    private IExpression myArgument;
    public IMetadataType Type { get; public set; }
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IMetadataType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.TryCastExpression/<get_Children>d__11")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.TryStatement : Statement {
    private IBlockStatement myBody;
    private IBlockStatement myFinally;
    private IBlockStatement myFault;
    private ICatchClause[] myCatchClauses;
    public IBlockStatement Body { get; public set; }
    public IBlockStatement Finally { get; public set; }
    public IBlockStatement Fault { get; public set; }
    public ICatchClause[] CatchClauses { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual IBlockStatement get_Body();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Body(IBlockStatement value);
    [DebuggerStepThroughAttribute]
public sealed virtual IBlockStatement get_Finally();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Finally(IBlockStatement value);
    [DebuggerStepThroughAttribute]
public sealed virtual IBlockStatement get_Fault();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Fault(IBlockStatement value);
    [DebuggerStepThroughAttribute]
public sealed virtual ICatchClause[] get_CatchClauses();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_CatchClauses(ICatchClause[] value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.TryStatement/<get_Children>d__17")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.TupleComponentAccessExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private IExpression myTarget;
    public IMetadataType Type { get; public set; }
    public int Index { get; public set; }
    public string Name { get; public set; }
    public IExpression Target { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IMetadataType value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Target();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Target(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.TupleComponentAccessExpression/<get_Children>d__19")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.TupleCreationExpression : Expression {
    [CompilerGeneratedAttribute]
private String[] <ComponentNames>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <ConstructedType>k__BackingField;
    private IExpression[] myArguments;
    public String[] ComponentNames { get; public set; }
    public IMetadataType ConstructedType { get; public set; }
    public IExpression[] Arguments { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ComponentNames();
    [CompilerGeneratedAttribute]
public void set_ComponentNames(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_ConstructedType();
    [CompilerGeneratedAttribute]
public void set_ConstructedType(IMetadataType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression[] get_Arguments();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Arguments(IExpression[] value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.TupleCreationExpression/<get_Children>d__15")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.TupleExpression : Expression {
    [CompilerGeneratedAttribute]
private MethodSpecification <DeconstructMethodSpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataTupleType <TupleElementNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeclaration>k__BackingField;
    private IExpression[] myComponents;
    public MethodSpecification DeconstructMethodSpecification { get; public set; }
    public IMetadataTupleType TupleElementNames { get; public set; }
    public bool IsDeclaration { get; public set; }
    public IExpression[] Components { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual MethodSpecification get_DeconstructMethodSpecification();
    [CompilerGeneratedAttribute]
public void set_DeconstructMethodSpecification(MethodSpecification value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataTupleType get_TupleElementNames();
    [CompilerGeneratedAttribute]
public void set_TupleElementNames(IMetadataTupleType value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDeclaration();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsDeclaration(bool value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression[] get_Components();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Components(IExpression[] value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.TupleExpression/<get_Children>d__19")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.TypeCastExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private OverflowCheckType <OverflowCheck>k__BackingField;
    private IExpression myArgument;
    public IMetadataType TargetType { get; public set; }
    public OverflowCheckType OverflowCheck { get; public set; }
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_TargetType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TargetType(IMetadataType value);
    [CompilerGeneratedAttribute]
public sealed virtual OverflowCheckType get_OverflowCheck();
    [CompilerGeneratedAttribute]
public void set_OverflowCheck(OverflowCheckType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.TypeCastExpression/<get_Children>d__15")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.TypeOfExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <Type>k__BackingField;
    public IMetadataType Type { get; public set; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IMetadataType value);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.TypePatternExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <Type>k__BackingField;
    private IExpression myArgument;
    private ILocalVariableReferenceExpression myVariableReference;
    public IMetadataType Type { get; public set; }
    public IExpression Argument { get; public set; }
    public ILocalVariableReferenceExpression VariableReference { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IMetadataType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual ILocalVariableReferenceExpression get_VariableReference();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_VariableReference(ILocalVariableReferenceExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.TypePatternExpression/<get_Children>d__15")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.TypeReferenceExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <Type>k__BackingField;
    public IMetadataType Type { get; public set; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IMetadataType value);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.UnaryOperationExpression : Expression {
    [CompilerGeneratedAttribute]
private OperationType <OperationType>k__BackingField;
    [CompilerGeneratedAttribute]
private OverflowCheckType <OverflowCheck>k__BackingField;
    private IExpression myArgument;
    public OperationType OperationType { get; public set; }
    public OverflowCheckType OverflowCheck { get; public set; }
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual OperationType get_OperationType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OperationType(OperationType value);
    [CompilerGeneratedAttribute]
public sealed virtual OverflowCheckType get_OverflowCheck();
    [CompilerGeneratedAttribute]
public void set_OverflowCheck(OverflowCheckType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.UnaryOperationExpression/<get_Children>d__15")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.UnboxExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <TargetType>k__BackingField;
    private IExpression myArgument;
    public IMetadataType TargetType { get; public set; }
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_TargetType();
    [CompilerGeneratedAttribute]
public void set_TargetType(IMetadataType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.UnboxExpression/<get_Children>d__11")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.UnpinStatement : Statement {
    private ILocalVariableReferenceExpression myVariableReference;
    public ILocalVariableReferenceExpression VariableReference { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual ILocalVariableReferenceExpression get_VariableReference();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_VariableReference(ILocalVariableReferenceExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.UnpinStatement/<get_Children>d__5")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.UntypedStackAllocExpression : Expression {
    private IExpression myLength;
    public IExpression Length { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Length();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Length(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.UntypedStackAllocExpression/<get_Children>d__5")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.UserDefinedBinaryOperationExpression : Expression {
    [CompilerGeneratedAttribute]
private OperationType <OperationType>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSpecification <MethodSpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <ResultType>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <ConstrainedType>k__BackingField;
    [CompilerGeneratedAttribute]
private OverflowCheckType <OverflowCheck>k__BackingField;
    private IExpression myLeftArgument;
    private IExpression myRightArgument;
    public OperationType OperationType { get; public set; }
    public MethodSpecification MethodSpecification { get; public set; }
    public IMetadataType ResultType { get; public set; }
    public IMetadataType ConstrainedType { get; public set; }
    public OverflowCheckType OverflowCheck { get; public set; }
    public IExpression LeftArgument { get; public set; }
    public IExpression RightArgument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual OperationType get_OperationType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OperationType(OperationType value);
    [CompilerGeneratedAttribute]
public sealed virtual MethodSpecification get_MethodSpecification();
    [CompilerGeneratedAttribute]
public void set_MethodSpecification(MethodSpecification value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_ResultType();
    [CompilerGeneratedAttribute]
public void set_ResultType(IMetadataType value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_ConstrainedType();
    [CompilerGeneratedAttribute]
public void set_ConstrainedType(IMetadataType value);
    [CompilerGeneratedAttribute]
public sealed virtual OverflowCheckType get_OverflowCheck();
    [CompilerGeneratedAttribute]
public void set_OverflowCheck(OverflowCheckType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_LeftArgument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_LeftArgument(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_RightArgument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_RightArgument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.UserDefinedBinaryOperationExpression/<get_Children>d__31")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.UserDefinedTypeCastExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSpecification <MethodSpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <ConstrainedType>k__BackingField;
    [CompilerGeneratedAttribute]
private OverflowCheckType <OverflowCheck>k__BackingField;
    private IExpression myArgument;
    public IMetadataType TargetType { get; public set; }
    public MethodSpecification MethodSpecification { get; public set; }
    public IMetadataType ConstrainedType { get; public set; }
    public OverflowCheckType OverflowCheck { get; public set; }
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_TargetType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TargetType(IMetadataType value);
    [CompilerGeneratedAttribute]
public sealed virtual MethodSpecification get_MethodSpecification();
    [CompilerGeneratedAttribute]
public void set_MethodSpecification(MethodSpecification value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_ConstrainedType();
    [CompilerGeneratedAttribute]
public void set_ConstrainedType(IMetadataType value);
    [CompilerGeneratedAttribute]
public sealed virtual OverflowCheckType get_OverflowCheck();
    [CompilerGeneratedAttribute]
public void set_OverflowCheck(OverflowCheckType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.UserDefinedTypeCastExpression/<get_Children>d__23")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.UserDefinedUnaryOperationExpression : Expression {
    [CompilerGeneratedAttribute]
private OperationType <OperationType>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSpecification <MethodSpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <ResultType>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <ConstrainedType>k__BackingField;
    [CompilerGeneratedAttribute]
private OverflowCheckType <OverflowCheck>k__BackingField;
    private IExpression myArgument;
    public OperationType OperationType { get; public set; }
    public MethodSpecification MethodSpecification { get; public set; }
    public IMetadataType ResultType { get; public set; }
    public IMetadataType ConstrainedType { get; public set; }
    public OverflowCheckType OverflowCheck { get; public set; }
    public IExpression Argument { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual OperationType get_OperationType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OperationType(OperationType value);
    [CompilerGeneratedAttribute]
public sealed virtual MethodSpecification get_MethodSpecification();
    [CompilerGeneratedAttribute]
public void set_MethodSpecification(MethodSpecification value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_ResultType();
    [CompilerGeneratedAttribute]
public void set_ResultType(IMetadataType value);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_ConstrainedType();
    [CompilerGeneratedAttribute]
public void set_ConstrainedType(IMetadataType value);
    [CompilerGeneratedAttribute]
public sealed virtual OverflowCheckType get_OverflowCheck();
    [CompilerGeneratedAttribute]
public void set_OverflowCheck(OverflowCheckType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.UserDefinedUnaryOperationExpression/<get_Children>d__27")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.UsingStatement : Statement {
    [CompilerGeneratedAttribute]
private bool <IsAwait>k__BackingField;
    private ILocalVariableReferenceExpression myVariableReference;
    private IExpression myExpression;
    private IStatement myBody;
    public bool IsAwait { get; public set; }
    public ILocalVariableReferenceExpression VariableReference { get; public set; }
    public IExpression Expression { get; public set; }
    public IStatement Body { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAwait();
    [CompilerGeneratedAttribute]
public void set_IsAwait(bool value);
    [DebuggerStepThroughAttribute]
public sealed virtual ILocalVariableReferenceExpression get_VariableReference();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_VariableReference(ILocalVariableReferenceExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Expression();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Expression(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IStatement get_Body();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Body(IStatement value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.UsingStatement/<get_Children>d__19")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.VirtualMethodPointerExpression : Expression {
    [CompilerGeneratedAttribute]
private MethodInstantiation <MethodInstantiation>k__BackingField;
    private IExpression myTarget;
    public MethodInstantiation MethodInstantiation { get; public set; }
    public IExpression Target { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    [CompilerGeneratedAttribute]
public sealed virtual MethodInstantiation get_MethodInstantiation();
    [CompilerGeneratedAttribute]
public void set_MethodInstantiation(MethodInstantiation value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Target();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Target(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.VirtualMethodPointerExpression/<get_Children>d__9")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.WithExpression : Expression {
    [CompilerGeneratedAttribute]
private IMetadataType <ConstructedType>k__BackingField;
    private IExpression myArgument;
    private IMemberInitializerList myInitializer;
    public IMetadataType ConstructedType { get; public set; }
    public IExpression Argument { get; public set; }
    public IMemberInitializerList Initializer { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_ConstructedType();
    [CompilerGeneratedAttribute]
public void set_ConstructedType(IMetadataType value);
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Argument();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Argument(IExpression value);
    [DebuggerStepThroughAttribute]
public sealed virtual IMemberInitializerList get_Initializer();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Initializer(IMemberInitializerList value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.WithExpression/<get_Children>d__15")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.YieldBreakStatement : Statement {
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
internal class JetBrains.Decompiler.Ast.Impl.YieldReturnStatement : Statement {
    private IExpression myResult;
    public IExpression Result { get; public set; }
    public IEnumerable`1<INode> Children { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    protected virtual string GetInfoString();
    protected virtual string GetNodeTypeString();
    [DebuggerStepThroughAttribute]
public sealed virtual IExpression get_Result();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Result(IExpression value);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Ast.Impl.YieldReturnStatement/<get_Children>d__7")]
[DebuggerStepThroughAttribute]
public virtual IEnumerable`1<INode> get_Children();
    public virtual void ReplaceChild(INode oldChild, INode newChild);
    public virtual object Clone();
    public virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
}
public interface JetBrains.Decompiler.Ast.INamedArgumentExpression {
    public IExpression Argument { get; public set; }
    public string ParameterName { get; }
    public int MetadataParameterIndex { get; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
    public abstract virtual string get_ParameterName();
    public abstract virtual int get_MetadataParameterIndex();
}
public interface JetBrains.Decompiler.Ast.INameOfExpression {
    public string Argument { get; }
    public abstract virtual string get_Argument();
}
public interface JetBrains.Decompiler.Ast.INestedInitializer {
    public IMemberInitializerList ObjectInitializer { get; public set; }
    public IExpressionList CollectionInitializer { get; public set; }
    public abstract virtual IMemberInitializerList get_ObjectInitializer();
    public abstract virtual void set_ObjectInitializer(IMemberInitializerList value);
    public abstract virtual IExpressionList get_CollectionInitializer();
    public abstract virtual void set_CollectionInitializer(IExpressionList value);
}
public interface JetBrains.Decompiler.Ast.INode {
    public bool IsAttached { get; }
    public INodeContainer Container { get; }
    public IEqualityComparer`1<INode> DeepEqualityComparer { get; }
    public DataHolder Data { get; }
    [CanBeNullAttribute]
public IInstructionReference InstructionReference { get; public set; }
    public INode Parent { get; }
    public IEnumerable`1<INode> Children { get; }
    public abstract virtual bool get_IsAttached();
    public abstract virtual INodeContainer get_Container();
    public abstract virtual IEqualityComparer`1<INode> get_DeepEqualityComparer();
    public abstract virtual DataHolder get_Data();
    public abstract virtual IInstructionReference get_InstructionReference();
    public abstract virtual void set_InstructionReference(IInstructionReference value);
    public abstract virtual INode get_Parent();
    public abstract virtual IEnumerable`1<INode> get_Children();
    public abstract virtual void ReplaceChild(INode oldChild, INode newChild);
    public abstract virtual INode GetRightSibling(INode child);
    public abstract virtual INode GetLeftSibling(INode child);
}
public interface JetBrains.Decompiler.Ast.INodeContainer {
    public ICollection`1<INode> Nodes { get; }
    public abstract virtual ICollection`1<INode> get_Nodes();
    public abstract virtual void AttachTree(INode root);
    public abstract virtual void DetachTree(INode root);
    [CompilerGeneratedAttribute]
public abstract virtual void add_NodeAttached(EventHandler`1<EventArgs`1<INode>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NodeAttached(EventHandler`1<EventArgs`1<INode>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_NodeDetached(EventHandler`1<EventArgs`1<INode>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NodeDetached(EventHandler`1<EventArgs`1<INode>> value);
}
public interface JetBrains.Decompiler.Ast.INodeList`1 {
    public int Count { get; }
    public T First { get; }
    public T Last { get; }
    public abstract virtual int get_Count();
    public abstract virtual void AddFront(T node);
    public abstract virtual void AddBack(T node);
    public abstract virtual void AddBefore(T anchor, T node);
    public abstract virtual void AddAfter(T anchor, T node);
    public abstract virtual void Replace(T oldNode, T newNode);
    public abstract virtual T GetNext(T node);
    public abstract virtual T GetPrevious(T node);
    public abstract virtual T get_First();
    public abstract virtual T get_Last();
}
internal class JetBrains.Decompiler.Ast.InstructionsRange : object {
    [CompilerGeneratedAttribute]
private Instruction <First>k__BackingField;
    [CompilerGeneratedAttribute]
private Instruction <Last>k__BackingField;
    private bool myInitialized;
    public Instruction First { get; private set; }
    public Instruction Last { get; private set; }
    public InstructionsRange(Instruction instruction);
    public InstructionsRange(ControlFlowBlock block);
    public InstructionsRange(ControlFlowRegion region);
    public InstructionsRange(FilterRegion filterRegion, CatchRegion catchRegion);
    [CompilerGeneratedAttribute]
public sealed virtual Instruction get_First();
    [CompilerGeneratedAttribute]
private void set_First(Instruction value);
    [CompilerGeneratedAttribute]
public sealed virtual Instruction get_Last();
    [CompilerGeneratedAttribute]
private void set_Last(Instruction value);
    public sealed virtual void AddInstruction(Instruction instruction);
    private void AddBlock(ControlFlowBlock block);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Decompiler.Ast.InstructionsRangeExtensions : object {
    [ExtensionAttribute]
public static bool Intersects(IInstructionsRange range, IInstructionsRange otherRange);
    [ExtensionAttribute]
public static bool Includes(IInstructionsRange range, int offset);
    [ExtensionAttribute]
public static string ToOffsetRangeString(IInstructionsRange range);
}
public interface JetBrains.Decompiler.Ast.IObjectCreationExpression {
    public IMetadataType ConstructedType { get; public set; }
    public IMemberInitializerList ObjectInitializer { get; public set; }
    public IExpressionList CollectionInitializer { get; public set; }
    public MethodSpecification ConstructorSpecification { get; }
    public abstract virtual IMetadataType get_ConstructedType();
    public abstract virtual void set_ConstructedType(IMetadataType value);
    public abstract virtual IMemberInitializerList get_ObjectInitializer();
    public abstract virtual void set_ObjectInitializer(IMemberInitializerList value);
    public abstract virtual IExpressionList get_CollectionInitializer();
    public abstract virtual void set_CollectionInitializer(IExpressionList value);
    public abstract virtual MethodSpecification get_ConstructorSpecification();
}
public interface JetBrains.Decompiler.Ast.IOverflowCheckExpression {
    public OverflowCheckType OverflowCheck { get; }
    public abstract virtual OverflowCheckType get_OverflowCheck();
}
public interface JetBrains.Decompiler.Ast.IParameterModifierExpression {
    public IExpression Argument { get; public set; }
    public ParameterModifierKind ModifierKind { get; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
    public abstract virtual ParameterModifierKind get_ModifierKind();
}
public interface JetBrains.Decompiler.Ast.IParameterReferenceExpression {
    public IMethodParameter Parameter { get; }
    public abstract virtual IMethodParameter get_Parameter();
}
public interface JetBrains.Decompiler.Ast.IPinStatement {
    public ILocalVariableReferenceExpression VariableReference { get; public set; }
    public IExpression Initializer { get; public set; }
    public abstract virtual ILocalVariableReferenceExpression get_VariableReference();
    public abstract virtual void set_VariableReference(ILocalVariableReferenceExpression value);
    public abstract virtual IExpression get_Initializer();
    public abstract virtual void set_Initializer(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IPointerElementAccessExpression {
    public IExpression Pointer { get; public set; }
    public IExpression Index { get; public set; }
    public abstract virtual IExpression get_Pointer();
    public abstract virtual void set_Pointer(IExpression value);
    public abstract virtual IExpression get_Index();
    public abstract virtual void set_Index(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IPointerIndirectionExpression {
    public IExpression Argument { get; public set; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IPropertyAccessExpression {
    public PropertySpecification PropertySpecification { get; }
    public abstract virtual PropertySpecification get_PropertySpecification();
}
public interface JetBrains.Decompiler.Ast.IPropertyMemberInitializer {
    public IMetadataProperty Property { get; }
    public abstract virtual IMetadataProperty get_Property();
}
public interface JetBrains.Decompiler.Ast.IRefExpression {
    public IExpression Argument { get; public set; }
    public bool Implicit { get; public set; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
    public abstract virtual bool get_Implicit();
    public abstract virtual void set_Implicit(bool value);
}
public interface JetBrains.Decompiler.Ast.IRefModifierExpression {
    public IExpression Argument { get; public set; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IRefTypeExpression {
    public IExpression Argument { get; public set; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IRefTypeTokenExpression {
    public IExpression Argument { get; public set; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IRefValueExpression {
    public IExpression Argument { get; public set; }
    public IMetadataType Type { get; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
    public abstract virtual IMetadataType get_Type();
}
public interface JetBrains.Decompiler.Ast.IRethrowStatement {
}
public interface JetBrains.Decompiler.Ast.IReturnStatement {
    public IExpression Result { get; public set; }
    public abstract virtual IExpression get_Result();
    public abstract virtual void set_Result(IExpression value);
}
public interface JetBrains.Decompiler.Ast.ISizeOfExpression {
    public IMetadataType Type { get; }
    public abstract virtual IMetadataType get_Type();
}
public interface JetBrains.Decompiler.Ast.IStackAllocExpression {
    public IExpression Length { get; public set; }
    public IExpressionList Initializer { get; public set; }
    public IMetadataType ElementType { get; }
    public IMetadataClassType SpanType { get; }
    public abstract virtual void SetElementType(IMetadataType elementType);
    public abstract virtual void SetSpanType(IMetadataClassType spanType);
    public abstract virtual IExpression get_Length();
    public abstract virtual void set_Length(IExpression value);
    public abstract virtual IExpressionList get_Initializer();
    public abstract virtual void set_Initializer(IExpressionList value);
    public abstract virtual IMetadataType get_ElementType();
    public abstract virtual IMetadataClassType get_SpanType();
}
public interface JetBrains.Decompiler.Ast.IStatement {
}
public interface JetBrains.Decompiler.Ast.ISuccessfulFilteringStatement {
}
public interface JetBrains.Decompiler.Ast.ISwitchCase {
    public IExpression[] Values { get; public set; }
    public IBlockStatement Body { get; public set; }
    public abstract virtual IExpression[] get_Values();
    public abstract virtual void set_Values(IExpression[] value);
    public abstract virtual IBlockStatement get_Body();
    public abstract virtual void set_Body(IBlockStatement value);
}
public interface JetBrains.Decompiler.Ast.ISwitchCaseValue {
}
public interface JetBrains.Decompiler.Ast.ISwitchStatement {
    public IExpression Expression { get; public set; }
    public ISwitchCase[] Cases { get; public set; }
    public IBlockStatement Default { get; public set; }
    public abstract virtual IExpression get_Expression();
    public abstract virtual void set_Expression(IExpression value);
    public abstract virtual ISwitchCase[] get_Cases();
    public abstract virtual void set_Cases(ISwitchCase[] value);
    public abstract virtual IBlockStatement get_Default();
    public abstract virtual void set_Default(IBlockStatement value);
}
public interface JetBrains.Decompiler.Ast.ITargetable {
    public IExpression Target { get; public set; }
    public abstract virtual IExpression get_Target();
    public abstract virtual void set_Target(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IThisReferenceExpression {
}
public interface JetBrains.Decompiler.Ast.IThrowExpression {
    public IExpression Argument { get; public set; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IThrowStatement {
    public IExpression Argument { get; public set; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
}
public interface JetBrains.Decompiler.Ast.ITryCastExpression {
    public IExpression Argument { get; public set; }
    public IMetadataType Type { get; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
    public abstract virtual IMetadataType get_Type();
}
public interface JetBrains.Decompiler.Ast.ITryStatement {
    public IBlockStatement Body { get; public set; }
    public IBlockStatement Finally { get; public set; }
    public IBlockStatement Fault { get; public set; }
    public ICatchClause[] CatchClauses { get; public set; }
    public abstract virtual IBlockStatement get_Body();
    public abstract virtual void set_Body(IBlockStatement value);
    public abstract virtual IBlockStatement get_Finally();
    public abstract virtual void set_Finally(IBlockStatement value);
    public abstract virtual IBlockStatement get_Fault();
    public abstract virtual void set_Fault(IBlockStatement value);
    public abstract virtual ICatchClause[] get_CatchClauses();
    public abstract virtual void set_CatchClauses(ICatchClause[] value);
}
public interface JetBrains.Decompiler.Ast.ITupleComponentAccessExpression {
    public IMetadataType Type { get; }
    public int Index { get; }
    public string Name { get; }
    public abstract virtual IMetadataType get_Type();
    public abstract virtual int get_Index();
    public abstract virtual string get_Name();
}
public interface JetBrains.Decompiler.Ast.ITupleCreationExpression {
    public String[] ComponentNames { get; }
    public abstract virtual String[] get_ComponentNames();
}
public interface JetBrains.Decompiler.Ast.ITupleExpression {
    [CanBeNullAttribute]
public MethodSpecification DeconstructMethodSpecification { get; }
    [CanBeNullAttribute]
public IMetadataTupleType TupleElementNames { get; }
    public IExpression[] Components { get; public set; }
    public bool IsDeclaration { get; public set; }
    public abstract virtual MethodSpecification get_DeconstructMethodSpecification();
    public abstract virtual IMetadataTupleType get_TupleElementNames();
    public abstract virtual IExpression[] get_Components();
    public abstract virtual void set_Components(IExpression[] value);
    public abstract virtual bool get_IsDeclaration();
    public abstract virtual void set_IsDeclaration(bool value);
}
public interface JetBrains.Decompiler.Ast.ITypeCastExpression {
}
public interface JetBrains.Decompiler.Ast.ITypeConstrainedCallExpression {
    [CanBeNullAttribute]
public IMetadataType ConstrainedType { get; }
    public abstract virtual IMetadataType get_ConstrainedType();
}
public interface JetBrains.Decompiler.Ast.ITypeOfExpression {
    public IMetadataType Type { get; }
    public abstract virtual IMetadataType get_Type();
}
public interface JetBrains.Decompiler.Ast.ITypePatternExpression {
    public IExpression Argument { get; public set; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
}
public interface JetBrains.Decompiler.Ast.ITypePatternExpressionBase {
    [CanBeNullAttribute]
public ILocalVariableReferenceExpression VariableReference { get; public set; }
    public IMetadataType Type { get; }
    public abstract virtual ILocalVariableReferenceExpression get_VariableReference();
    public abstract virtual void set_VariableReference(ILocalVariableReferenceExpression value);
    public abstract virtual IMetadataType get_Type();
}
public interface JetBrains.Decompiler.Ast.ITypeReferenceExpression {
    public IMetadataType Type { get; }
    public abstract virtual IMetadataType get_Type();
}
public interface JetBrains.Decompiler.Ast.IUnaryOperationExpression {
}
public interface JetBrains.Decompiler.Ast.IUnboxExpression {
    public IExpression Argument { get; public set; }
    public IMetadataType TargetType { get; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
    public abstract virtual IMetadataType get_TargetType();
}
public interface JetBrains.Decompiler.Ast.IUnpinStatement {
    public ILocalVariableReferenceExpression VariableReference { get; public set; }
    public abstract virtual ILocalVariableReferenceExpression get_VariableReference();
    public abstract virtual void set_VariableReference(ILocalVariableReferenceExpression value);
}
public interface JetBrains.Decompiler.Ast.IUntypedStackAllocExpression {
    public IExpression Length { get; public set; }
    public abstract virtual IExpression get_Length();
    public abstract virtual void set_Length(IExpression value);
}
public interface JetBrains.Decompiler.Ast.IUserDefinedBinaryOperationExpression {
    public MethodSpecification MethodSpecification { get; }
    public IMetadataType ResultType { get; }
    public abstract virtual MethodSpecification get_MethodSpecification();
    public abstract virtual IMetadataType get_ResultType();
}
public interface JetBrains.Decompiler.Ast.IUserDefinedTypeCastExpression {
    public MethodSpecification MethodSpecification { get; }
    public abstract virtual MethodSpecification get_MethodSpecification();
}
public interface JetBrains.Decompiler.Ast.IUserDefinedUnaryOperationExpression {
    public MethodSpecification MethodSpecification { get; }
    public IMetadataType ResultType { get; }
    public abstract virtual MethodSpecification get_MethodSpecification();
    public abstract virtual IMetadataType get_ResultType();
}
public interface JetBrains.Decompiler.Ast.IUsingStatement {
    public ILocalVariableReferenceExpression VariableReference { get; public set; }
    public IExpression Expression { get; public set; }
    public IStatement Body { get; public set; }
    public bool IsAwait { get; }
    public abstract virtual ILocalVariableReferenceExpression get_VariableReference();
    public abstract virtual void set_VariableReference(ILocalVariableReferenceExpression value);
    public abstract virtual IExpression get_Expression();
    public abstract virtual void set_Expression(IExpression value);
    public abstract virtual IStatement get_Body();
    public abstract virtual void set_Body(IStatement value);
    public abstract virtual bool get_IsAwait();
}
public interface JetBrains.Decompiler.Ast.IVirtualMethodPointerExpression {
    public MethodInstantiation MethodInstantiation { get; }
    public abstract virtual MethodInstantiation get_MethodInstantiation();
}
public interface JetBrains.Decompiler.Ast.IWithExpression {
    public IExpression Argument { get; public set; }
    public IMemberInitializerList Initializer { get; public set; }
    public abstract virtual IExpression get_Argument();
    public abstract virtual void set_Argument(IExpression value);
    public abstract virtual IMemberInitializerList get_Initializer();
    public abstract virtual void set_Initializer(IMemberInitializerList value);
}
public interface JetBrains.Decompiler.Ast.IYieldBreakStatement {
}
public interface JetBrains.Decompiler.Ast.IYieldReturnStatement {
    public IExpression Result { get; public set; }
    public abstract virtual IExpression get_Result();
    public abstract virtual void set_Result(IExpression value);
}
public enum JetBrains.Decompiler.Ast.LocalVariableDeclarationModifierKind : Enum {
    public int value__;
    public static LocalVariableDeclarationModifierKind None;
    public static LocalVariableDeclarationModifierKind Ref;
    public static LocalVariableDeclarationModifierKind RefReadonly;
}
public enum JetBrains.Decompiler.Ast.LocalVariableKind : Enum {
    public int value__;
    public static LocalVariableKind Regular;
    public static LocalVariableKind Temporary;
    public static LocalVariableKind Exception;
    public static LocalVariableKind ForEach;
    public static LocalVariableKind Using;
    public static LocalVariableKind Fixed;
    public static LocalVariableKind Pattern;
    public static LocalVariableKind Tuple;
    public static LocalVariableKind Closure;
    public static LocalVariableKind Iterator;
}
public enum JetBrains.Decompiler.Ast.LoopType : Enum {
    public int value__;
    public static LoopType Preconditional;
    public static LoopType Postconditional;
    public static LoopType Unconditional;
}
public enum JetBrains.Decompiler.Ast.MemberAccessKind : Enum {
    public int value__;
    public static MemberAccessKind Regular;
    public static MemberAccessKind Pointer;
}
[ExtensionAttribute]
public static class JetBrains.Decompiler.Ast.MethodParameterEx : object {
    [ExtensionAttribute]
public static bool IsExternalParamArray(IMethodParameter parameter);
}
[FlagsAttribute]
public enum JetBrains.Decompiler.Ast.MethodParameterKind : Enum {
    public int value__;
    public static MethodParameterKind Regular;
    public static MethodParameterKind AnonymousDelegate;
    public static MethodParameterKind ExternalParamArray;
}
[ExtensionAttribute]
public static class JetBrains.Decompiler.Ast.NodeEx : object {
    [ExtensionAttribute]
private static void Visit(INode node, Action`1<T> preorderAction, Action`1<T> postorderAction);
    [ExtensionAttribute]
public static void VisitPreorder(INode node, Action`1<T> action);
    [ExtensionAttribute]
public static void VisitPostorder(INode node, Action`1<T> action);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static T FindFirstPostorder(INode node, Predicate`1<T> predicate);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static T FindNearestAncestor(INode searchFrom, INode searchUntil, Predicate`1<T> predicate);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static INode GetRightSibling(INode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IStatement GetRightSibling(IStatement statement);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static INode GetLeftSibling(INode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IStatement GetLeftSibling(IStatement statement);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static INode GetParent(INode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static INode GetFirstPostorder(INode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static INode GetNextPostorder(INode node);
    [ExtensionAttribute]
public static void ReplaceWith(INode oldNode, INode newNode);
    [ExtensionAttribute]
public static T Detach(T node);
    [ExtensionAttribute]
public static IEnumerable`1<T> Detach(IEnumerable`1<T> list);
    [ExtensionAttribute]
internal static bool IsInside(INode child, INode parent);
    [ExtensionAttribute]
public static bool DeepEquals(INode thisNode, INode otherNode);
    [ExtensionAttribute]
public static bool DeepEquals(INode[] theseNodes, INode[] otherNodes);
    [ExtensionAttribute]
[ConditionalAttribute("VALIDATE_TRANSFORMATIONS")]
public static void ValidateTree(INode node);
    private static void ValidateTree(INode node, INode parent);
    [ExtensionAttribute]
public static T TypedClone(T node);
    [ExtensionAttribute]
public static T[] TypedClone(T[] nodes);
    [ExtensionAttribute]
public static string ToStringDebug(INode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IInstructionReference ChooseFirstSequencePointInstruction(INode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IInstructionReference GetParentOrCurrentInstructionReference(INode node);
    [ExtensionAttribute]
public static void RemoveInstructionFromSubtree(INode root, IInstructionReference instructionToRemove);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMethodBody TryGetMethodBody(INode node, MetadataToken methodToken);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IDecompiledMethodBase TryGetContainingMethod(INode node);
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.Ast.NodeListEx : object {
    [ExtensionAttribute]
public static void AddRangeBefore(INodeList`1<T> nodeList, T anchor, IEnumerable`1<T> range);
    [ExtensionAttribute]
public static void AddRangeAfter(INodeList`1<T> nodeList, T anchor, IEnumerable`1<T> range);
    [ExtensionAttribute]
public static void AddRangeFront(INodeList`1<T> nodeList, IEnumerable`1<T> range);
    [ExtensionAttribute]
public static void AddRangeBack(INodeList`1<T> nodeList, IEnumerable`1<T> range);
}
public enum JetBrains.Decompiler.Ast.OperationType : Enum {
    public int value__;
    public static OperationType Not;
    public static OperationType UnaryPlus;
    public static OperationType UnaryMinus;
    public static OperationType LogicalNeg;
    public static OperationType PrefixIncrement;
    public static OperationType PrefixDecrement;
    public static OperationType PostfixIncrement;
    public static OperationType PostfixDecrement;
    public static OperationType Assignment;
    public static OperationType AssignmentAdd;
    public static OperationType AssignmentSubtract;
    public static OperationType AssignmentMultiply;
    public static OperationType AssignmentDivide;
    public static OperationType AssignmentRemainder;
    public static OperationType AssignmentLogicalAnd;
    public static OperationType AssignmentLogicalOr;
    public static OperationType AssignmentLogicalXor;
    public static OperationType AssignmentShiftLeft;
    public static OperationType AssignmentShiftRight;
    public static OperationType AssignmentUnsignedShiftRight;
    public static OperationType LogicalAnd;
    public static OperationType LogicalOr;
    public static OperationType LogicalXor;
    public static OperationType Equal;
    public static OperationType NotEqual;
    public static OperationType Greater;
    public static OperationType Less;
    public static OperationType GreaterOrEqual;
    public static OperationType LessOrEqual;
    public static OperationType Add;
    public static OperationType Subtract;
    public static OperationType Divide;
    public static OperationType Multiply;
    public static OperationType Remainder;
    public static OperationType ShiftLeft;
    public static OperationType ShiftRight;
    public static OperationType UnsignedShiftRight;
    public static OperationType ConditionalAnd;
    public static OperationType ConditionalOr;
    public static OperationType NullCoalescing;
}
public enum JetBrains.Decompiler.Ast.OverflowCheckType : Enum {
    public int value__;
    public static OverflowCheckType Enabled;
    public static OverflowCheckType Disabled;
    public static OverflowCheckType DontCare;
}
public enum JetBrains.Decompiler.Ast.ParameterModifierKind : Enum {
    public int value__;
    public static ParameterModifierKind Ref;
    public static ParameterModifierKind Out;
    public static ParameterModifierKind In;
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.Ast.ParameterModifierKindEx : object {
    [ExtensionAttribute]
public static ParameterModifierKind ToParameterModifierKind(IMetadataParameter parameter);
    [ExtensionAttribute]
public static NameSuggestionKind ToNameSuggestionKind(ParameterModifierKind parameterModifierKind);
}
internal class JetBrains.Decompiler.Ast.ReferencesFinder : object {
    private OneToSetMap`2<ILocalVariable, ILocalVariableReferenceExpression> myVariableToReferences;
    private OneToSetMap`2<IMethodParameter, IParameterReferenceExpression> myParameterToReferences;
    public ReferencesFinder(INodeContainer container);
    public ICollection`1<ILocalVariableReferenceExpression> GetReferences(ILocalVariable variable);
    public ICollection`1<IParameterReferenceExpression> GetReferences(IMethodParameter parameter);
    private void AttachNode(INode node);
    private void DetachNode(INode node);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(object sender, EventArgs`1<INode> args);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_1(object sender, EventArgs`1<INode> args);
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.Ast.StatementEx : object {
    [ExtensionAttribute]
public static IBlockStatement ToBlockStatement(IStatement statement);
    [ExtensionAttribute]
public static void VisitEndpointStatements(IStatement root, Action`1<T> action);
    private static void InternalVisitEndpointStatements(IStatement rootStatement, IStatement currentStatement, Action`1<T> action);
    [ExtensionAttribute]
internal static bool IsEndpoint(INode node);
    [ExtensionAttribute]
public static bool IsEmpty(IStatement statement);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(IStatement statement);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("statement: null => null")]
public static IStatement GetFirstStatement(IStatement statement);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("statement: null => null")]
public static IStatement GetLastStatement(IStatement statement);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("statement: null => null")]
public static IStatement GetOnlyStatement(IStatement statement);
    [ExtensionAttribute]
public static bool IsRemovable(IStatement statement);
    [ExtensionAttribute]
public static bool IsBlockRequired(IStatement statement);
    [ExtensionAttribute]
public static void Remove(IStatement statement);
    [ExtensionAttribute]
public static bool IsEmbeddable(IStatement statement);
    [ExtensionAttribute]
public static bool IsEmbedded(IExpressionStatement statement);
    [ExtensionAttribute]
private static IEnumerable`1<IStatement> UnwrapStatement(IStatement statement);
    [ExtensionAttribute]
public static void UnwrapAndAddFront(INodeList`1<IStatement> statementList, IStatement statement);
    [ExtensionAttribute]
public static void UnwrapAndAddBack(INodeList`1<IStatement> statementList, IStatement statement);
    [ExtensionAttribute]
public static void UnwrapAndAddBefore(INodeList`1<IStatement> statementList, IStatement anchor, IStatement statement);
    [ExtensionAttribute]
public static void UnwrapAndAddAfter(INodeList`1<IStatement> statementList, IStatement anchor, IStatement statement);
    private static IBlockStatement EnsureBlockParent(IStatement anchor, IStatement& newAnchor);
    [ExtensionAttribute]
public static void UnwrapAndAddBefore(IStatement anchor, IStatement statement);
    [ExtensionAttribute]
public static void UnwrapAndAddAfter(IStatement anchor, IStatement statement);
    [ExtensionAttribute]
public static void UnwrapAndAddBack(IStatement anchor, IStatement statement);
}
public static class JetBrains.Decompiler.Baml.BamlDecompiler : object {
    [CanBeNullAttribute]
public static string Decompile(Stream stream, ITypeSystemHelper typeSystemHelper, BamlPredefinedProvider predefinedProvider, INamespaceMappingProvider mappingProvider);
    [CanBeNullAttribute]
public static string Decompile(string bamlName, FileSystemPath location, IAssemblyResolver resolver);
    [NotNullAttribute]
public static string ChangeExtension(string name);
}
public class JetBrains.Decompiler.Baml.CacheBuilder.CacheBuilder : TreeBuilderBase {
    [NotNullAttribute]
private List`1<IResourceDictionaryRecord> myResources;
    private BamlTypeInfo myRootType;
    private static string MergedDictionariesProperty;
    private static string SourceProperty;
    [CompilerGeneratedAttribute]
private bool <IsProcessingFinished>k__BackingField;
    public bool IsProcessingFinished { get; private set; }
    public CacheBuilder(BamlPredefinedProvider predefinedProvider);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsProcessingFinished();
    [CompilerGeneratedAttribute]
private void set_IsProcessingFinished(bool value);
    public sealed virtual void BeginElement(BamlTypeInfo type, long streamPosition);
    public sealed virtual void EndElement();
    public sealed virtual void NamespaceMapping(string xmlNamespace, string clrNamespace, string assembly);
    public sealed virtual void XmlnsDeclaration(string prefix, string value);
    public sealed virtual void PropertyContent(BamlPropertyInfo property);
    public sealed virtual void BeginDictionaryProperty(BamlPropertyInfo property);
    public sealed virtual void BeginComplexProperty(BamlPropertyInfo property);
    public sealed virtual void BeginListProperty(BamlPropertyInfo property);
    public sealed virtual void EndDictionaryProperty();
    public sealed virtual void EndComplexProperty();
    public sealed virtual void EndListProperty();
    public sealed virtual void PropertyDeclaration(BamlPropertyInfo property, string value);
    public sealed virtual void PropertyWithConverter(BamlPropertyInfo property, BamlTypeInfo converterType, string value);
    public sealed virtual void Connection(int connectionId);
    public sealed virtual void Property(BamlPropertyInfo property, string value);
    public sealed virtual void PropertyResource(BamlPropertyInfo property, bool isDynamic, string resourceKey);
    public sealed virtual void PropertyResource(BamlPropertyInfo property, bool isDynamic, BamlPropertyInfo member);
    public sealed virtual void PropertyResource(BamlPropertyInfo property, bool isDynamic, BamlTypeInfo keyType);
    public sealed virtual void PropertyXStatic(BamlPropertyInfo property, BamlPropertyInfo member);
    public sealed virtual void PropertyXType(BamlPropertyInfo property, BamlTypeInfo type);
    public sealed virtual void PropertyTemplateBinding(BamlPropertyInfo property, BamlPropertyInfo templateProperty);
    public sealed virtual void PropertyCustom(BamlPropertyInfo property, BamlPropertyInfo propertyValue);
    public sealed virtual void PropertyCustom(BamlPropertyInfo property, string propertyValue);
    public sealed virtual void PropertyStaticResourceId(BamlPropertyInfo property, short staticResourceId);
    public sealed virtual void BeginArrayProperty(BamlPropertyInfo property);
    public sealed virtual void EndArrayProperty();
    public sealed virtual void BeginConstructorArguments();
    public sealed virtual void EndConstructorArguments();
    public sealed virtual void ConstructorParameterType(BamlTypeInfo type);
    public sealed virtual void OptimizedStaticResource(BamlTypeInfo type);
    public sealed virtual void OptimizedStaticResource(BamlPropertyInfo property);
    public sealed virtual void OptimizedStaticResource(string resourceKey);
    public sealed virtual void StaticResourceId(short staticResourceId);
    public sealed virtual void BeginStaticResource(BamlTypeInfo type);
    public sealed virtual void EndStaticResource();
    public sealed virtual void Text(string value);
    public sealed virtual void TextWithConverter(string value, BamlTypeInfo converterType);
    public sealed virtual void LiteralContent(string text);
    private void AddToTree(BamlElement element);
    protected virtual void AddToDictionary(BamlElement keyElement, BamlKeyInfo keyInfo);
    private static bool IsResourceDictionaryType(BamlTypeInfo typeInfo);
    [NotNullAttribute]
public IList`1<IResourceDictionaryRecord> GetDefinedResources(BamlTypeInfo& rootTagType);
}
public interface JetBrains.Decompiler.Baml.CacheBuilder.IResourceDictionaryRecord {
}
public class JetBrains.Decompiler.Baml.CacheBuilder.MergedDictionaryRecord : object {
    [NotNullAttribute]
private string myDictionaryUri;
    [NotNullAttribute]
public string DictionaryUri { get; }
    public MergedDictionaryRecord(string dictionaryUri);
    public string get_DictionaryUri();
    public virtual string ToString();
}
public abstract class JetBrains.Decompiler.Baml.CacheBuilder.ResourceRecord : object {
    [DebuggerBrowsableAttribute("0")]
private BamlTypeInfo myResourceType;
    public BamlTypeInfo ResourceType { get; }
    protected ResourceRecord(BamlTypeInfo resourceType);
    public BamlTypeInfo get_ResourceType();
    public virtual string ToString();
}
public class JetBrains.Decompiler.Baml.CacheBuilder.StaticMemberKeyResourceRecord : ResourceRecord {
    [DebuggerBrowsableAttribute("0")]
private BamlPropertyInfo myResourceKey;
    public BamlPropertyInfo ResourceKey { get; }
    public StaticMemberKeyResourceRecord(BamlPropertyInfo resourceKey, BamlTypeInfo resourceType);
    public BamlPropertyInfo get_ResourceKey();
    public virtual string ToString();
}
public class JetBrains.Decompiler.Baml.CacheBuilder.StringKeyResourceRecord : ResourceRecord {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private string myResourceKey;
    [NotNullAttribute]
public string ResourceKey { get; }
    public StringKeyResourceRecord(string resourceKey, BamlTypeInfo resourceType);
    public string get_ResourceKey();
    public virtual string ToString();
}
public class JetBrains.Decompiler.Baml.CacheBuilder.TypeKeyResourceRecord : ResourceRecord {
    [DebuggerBrowsableAttribute("0")]
private BamlTypeInfo myResourceKey;
    public BamlTypeInfo ResourceKey { get; }
    public TypeKeyResourceRecord(BamlTypeInfo resourceKey, BamlTypeInfo resourceType);
    public BamlTypeInfo get_ResourceKey();
    public virtual string ToString();
}
public class JetBrains.Decompiler.Baml.Renderer.XamlRenderer : object {
    [NotNullAttribute]
private StringBuilder myBuilder;
    [NotNullAttribute]
private NamespaceManager myNamespaceManager;
    [NotNullAttribute]
private ITypeSystemHelper myHelper;
    private BamlTypeInfo myRootType;
    private BamlTypeInfo mySubclassType;
    private int myIndentLevel;
    private int myIndentSize;
    private int myLineWidth;
    private bool myIsSpacePreserved;
    [CanBeNullAttribute]
private BamlProperty myLastAttribute;
    private int myAttributeIndent;
    private int myAttributeLevel;
    private static BamlPropertyInfo ourClassAttribute;
    private static BamlPropertyInfo ourClassModifierAttribute;
    private static BamlPropertyInfo ourFieldModifierAttribute;
    private static BamlPropertyInfo ourTypeArgumentsAttribute;
    private static BamlPropertyInfo ourSubclassAttribute;
    private static string ExtensionSuffix;
    private static string XamlXNamespace;
    private static string XamlPresentationOptionsNamespace;
    [CompilerGeneratedAttribute]
private bool <SortProperties>k__BackingField;
    public int IndentSize { get; public set; }
    public int LineWidth { get; public set; }
    public bool SortProperties { get; public set; }
    public XamlRenderer(INamespaceMappingProvider mappingProvider, ITypeSystemHelper helper);
    private static XamlRenderer();
    public int get_IndentSize();
    public void set_IndentSize(int value);
    public int get_LineWidth();
    public void set_LineWidth(int value);
    [CompilerGeneratedAttribute]
public bool get_SortProperties();
    [CompilerGeneratedAttribute]
public void set_SortProperties(bool value);
    public void EnsureCapacity(long streamLength);
    public string Render(BamlObjectElement rootElement);
    private void PrintElement(BamlObjectElement objectElement, bool isRoot);
    private void PrintElementPropertyElements(BamlObjectElement element, List`1<BamlProperty> complexProperties);
    private void PrintPropertyElementContent(BamlProperty property);
    private bool PrintContentProperty(BamlContentProperty contentProperty);
    private static bool IsInvisibleWhitespace(BamlElement content);
    private void PrintClassDeclarationAttributes(bool isPublic, BamlTypeInfo[] typeArguments);
    private bool PrintAttribute(BamlObjectElement ownerElement, BamlProperty property);
    private void PrintAttributeValue(BamlTypeInfo ownerType, BamlValueProperty property);
    private bool PrintAttributeConnection(BamlConnectionProperty connection);
    private void PrintAttributeDeclaration(BamlTypeInfo ownerType, BamlDeclarationProperty property);
    private bool PrintAttributeComplex(BamlObjectElement ownerElement, BamlComplexProperty property);
    private static bool IsImplicitKey(BamlProperty property, BamlObjectElement ownerElement, BamlObjectElement keyElement);
    private bool PrintPrimitive(BamlElement argument, bool insideAttribute, bool insideMarkup);
    private void PrintPropertySetter(BamlPropertyInfo property);
    private void PrintPropertySetter(BamlTypeInfo ownerType, BamlProperty property);
    private void PrintConstructorArgumentsDump(BamlObjectElement element);
    private bool PrintMarkupExtension(BamlObjectElement markupExtension, bool force);
    private bool PrintConstructorArgument(BamlElement argument, bool force);
    private void AppendLine();
    private void PrintContentBreakLine();
    private MyAttributeBreakCookie PrintAttributeBreakLineIfNeeded();
    private void PrintAttributeBreakLine();
    private void PrintIndent();
    private void PrintContentIndent();
    private MyIndentCookie WithIndent(Nullable`1<int> customSize);
}
[DebuggerDisplayAttribute("{PropertyInfo.Name,nq}=(...)")]
public class JetBrains.Decompiler.Baml.TreeBuilder.BamlComplexProperty : BamlProperty {
    [DebuggerBrowsableAttribute("0")]
private BamlElement myValue;
    [CanBeNullAttribute]
public BamlElement Value { get; }
    public BamlComplexProperty(BamlPropertyInfo property);
    public BamlComplexProperty(BamlPropertyInfo property, BamlElement value);
    public BamlElement get_Value();
    public virtual void AddChildElement(BamlElement element);
}
[DebuggerDisplayAttribute("ConnectionId="{ConnectionId,nq}"")]
public class JetBrains.Decompiler.Baml.TreeBuilder.BamlConnectionProperty : BamlProperty {
    [DebuggerBrowsableAttribute("0")]
private int myConnectionId;
    public int ConnectionId { get; }
    public BamlConnectionProperty(int connectionId);
    public int get_ConnectionId();
    public virtual void AddChildElement(BamlElement element);
}
[DebuggerDisplayAttribute("{PropertyInfo.Name,nq} (content property)")]
public class JetBrains.Decompiler.Baml.TreeBuilder.BamlContentProperty : BamlProperty {
    [DebuggerBrowsableAttribute("0")]
private object myValue;
    [DebuggerBrowsableAttribute("0")]
public bool HasContent { get; }
    [DebuggerBrowsableAttribute("3")]
[UsedImplicitlyAttribute]
private IList`1<BamlElement> DebugContents { get; }
    public BamlContentProperty(BamlPropertyInfo property);
    public bool get_HasContent();
    private IList`1<BamlElement> get_DebugContents();
    public IList`1<BamlElement> GetContents();
    public void AddContent(BamlElement content);
    public virtual void AddChildElement(BamlElement element);
}
[DebuggerDisplayAttribute("{PropertyInfo.Name,nq}="{Name,nq}"")]
public class JetBrains.Decompiler.Baml.TreeBuilder.BamlDeclarationProperty : BamlProperty {
    [DebuggerBrowsableAttribute("0")]
private string myName;
    [NotNullAttribute]
public string Name { get; }
    public BamlDeclarationProperty(BamlPropertyInfo property, string name);
    public string get_Name();
    public virtual void AddChildElement(BamlElement element);
}
[DebuggerDisplayAttribute("{PropertyInfo.Name,nq}=(dictionary)")]
public class JetBrains.Decompiler.Baml.TreeBuilder.BamlDictionaryProperty : BamlProperty {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private List`1<BamlObjectElement> myElements;
    [DebuggerBrowsableAttribute("0")]
[CanBeNullAttribute]
private BamlObjectElement myObject;
    [DebuggerBrowsableAttribute("3")]
[NotNullAttribute]
public IList`1<BamlObjectElement> Elements { get; }
    public BamlDictionaryProperty(BamlPropertyInfo property);
    public IList`1<BamlObjectElement> get_Elements();
    public virtual void AddChildElement(BamlElement element);
    public void FinishDictionary();
}
public abstract class JetBrains.Decompiler.Baml.TreeBuilder.BamlElement : BamlObject {
    public bool IsPrimitive { get; }
    public abstract virtual bool get_IsPrimitive();
}
[DebuggerDisplayAttribute("{PropertyInfo.Name,nq}=(list)")]
public class JetBrains.Decompiler.Baml.TreeBuilder.BamlListProperty : BamlProperty {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private List`1<BamlElement> myElements;
    [DebuggerBrowsableAttribute("3")]
[NotNullAttribute]
public IList`1<BamlElement> Elements { get; }
    public BamlListProperty(BamlPropertyInfo property);
    public IList`1<BamlElement> get_Elements();
    public virtual void AddChildElement(BamlElement element);
}
[DebuggerDisplayAttribute("xmlns:{Prefix,nq}="{Namespace,nq}"")]
public class JetBrains.Decompiler.Baml.TreeBuilder.BamlNamespaceProperty : BamlProperty {
    [DebuggerBrowsableAttribute("0")]
private string myPrefix;
    [DebuggerBrowsableAttribute("0")]
private string myNamespace;
    [NotNullAttribute]
public string Prefix { get; }
    [NotNullAttribute]
public string Namespace { get; }
    public BamlNamespaceProperty(string prefix, string ns);
    public string get_Prefix();
    public string get_Namespace();
    public virtual void AddChildElement(BamlElement element);
}
public abstract class JetBrains.Decompiler.Baml.TreeBuilder.BamlObject : object {
}
[DebuggerDisplayAttribute("<{TypeInfo.ShortName,nq}>")]
public class JetBrains.Decompiler.Baml.TreeBuilder.BamlObjectElement : BamlElement {
    [DebuggerBrowsableAttribute("0")]
private BamlTypeInfo myType;
    [DebuggerBrowsableAttribute("0")]
[CanBeNullAttribute]
private List`1<BamlProperty> myProperties;
    [DebuggerBrowsableAttribute("0")]
[CanBeNullAttribute]
private List`1<BamlElement> myArguments;
    public BamlTypeInfo TypeInfo { get; }
    public bool IsPrimitive { get; }
    [DebuggerBrowsableAttribute("3")]
[NotNullAttribute]
public IList`1<BamlProperty> Properties { get; }
    [NotNullAttribute]
public IList`1<BamlElement> ConstructorArguments { get; }
    public BamlObjectElement(BamlTypeInfo type);
    public BamlObjectElement(BamlTypeInfo type, BamlElement constructorArgument);
    public BamlTypeInfo get_TypeInfo();
    public virtual bool get_IsPrimitive();
    public IList`1<BamlProperty> get_Properties();
    public IList`1<BamlElement> get_ConstructorArguments();
    [CanBeNullAttribute]
public BamlContentProperty GetContentProperty();
    [NotNullAttribute]
public BamlContentProperty GetOrCreateContentProperty();
    public void AddConstructorArgument(BamlElement argument);
    public void AddProperty(BamlProperty property);
}
public abstract class JetBrains.Decompiler.Baml.TreeBuilder.BamlProperty : BamlObject {
    [DebuggerBrowsableAttribute("0")]
private BamlPropertyInfo myProperty;
    public BamlPropertyInfo PropertyInfo { get; }
    protected BamlProperty(BamlPropertyInfo property);
    public BamlPropertyInfo get_PropertyInfo();
    public abstract virtual void AddChildElement(BamlElement element);
}
[DebuggerDisplayAttribute("{Property.Name,nq}")]
public class JetBrains.Decompiler.Baml.TreeBuilder.BamlPropertyReference : BamlElement {
    [DebuggerBrowsableAttribute("0")]
private BamlPropertyInfo myProperty;
    public BamlPropertyInfo Property { get; }
    public bool IsPrimitive { get; }
    public BamlPropertyReference(BamlPropertyInfo property);
    public BamlPropertyInfo get_Property();
    public virtual bool get_IsPrimitive();
}
[DebuggerDisplayAttribute("{Value}")]
public class JetBrains.Decompiler.Baml.TreeBuilder.BamlTextElement : BamlElement {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private string myValue;
    [DebuggerBrowsableAttribute("0")]
private bool myDisableEscaping;
    [NotNullAttribute]
public string Value { get; }
    public bool DisableEscaping { get; }
    public bool IsPrimitive { get; }
    public BamlTextElement(string value);
    public BamlTextElement(string value, bool disableEscaping);
    public string get_Value();
    public bool get_DisableEscaping();
    public virtual bool get_IsPrimitive();
}
public class JetBrains.Decompiler.Baml.TreeBuilder.BamlTreeBuilder : TreeBuilderBase {
    [NotNullAttribute]
private OneToSetMap`2<ReferencedNamespace, string> myMapping;
    private static string MsCorLib2;
    private static string MsCorLib4;
    public bool IsProcessingFinished { get; }
    public BamlTreeBuilder(BamlPredefinedProvider predefinedProvider);
    public sealed virtual bool get_IsProcessingFinished();
    private sealed virtual override IEnumerable`1<string> JetBrains.Decompiler.Baml.TypeSystem.INamespaceMappingProvider.GetXmlNamespace(ReferencedNamespace referencedNamespace);
    public sealed virtual void BeginElement(BamlTypeInfo type, long streamPosition);
    public sealed virtual void EndElement();
    public sealed virtual void NamespaceMapping(string xmlNamespace, string clrNamespace, string assembly);
    public sealed virtual void XmlnsDeclaration(string prefix, string value);
    public sealed virtual void Connection(int connectionId);
    public sealed virtual void Property(BamlPropertyInfo property, string value);
    public sealed virtual void PropertyDeclaration(BamlPropertyInfo property, string value);
    public sealed virtual void PropertyContent(BamlPropertyInfo property);
    public sealed virtual void PropertyWithConverter(BamlPropertyInfo property, BamlTypeInfo converterType, string value);
    public sealed virtual void PropertyResource(BamlPropertyInfo property, bool isDynamic, string resourceKey);
    public sealed virtual void PropertyResource(BamlPropertyInfo property, bool isDynamic, BamlPropertyInfo member);
    public sealed virtual void PropertyResource(BamlPropertyInfo property, bool isDynamic, BamlTypeInfo keyType);
    public sealed virtual void PropertyXStatic(BamlPropertyInfo property, BamlPropertyInfo member);
    public sealed virtual void PropertyXType(BamlPropertyInfo property, BamlTypeInfo type);
    public sealed virtual void PropertyTemplateBinding(BamlPropertyInfo property, BamlPropertyInfo templateProperty);
    public sealed virtual void PropertyCustom(BamlPropertyInfo property, string propertyValue);
    public sealed virtual void PropertyCustom(BamlPropertyInfo property, BamlPropertyInfo propertyValue);
    public sealed virtual void PropertyStaticResourceId(BamlPropertyInfo property, short staticResourceId);
    public sealed virtual void BeginDictionaryProperty(BamlPropertyInfo property);
    public sealed virtual void BeginComplexProperty(BamlPropertyInfo property);
    public sealed virtual void EndDictionaryProperty();
    public sealed virtual void EndComplexProperty();
    public sealed virtual void BeginListProperty(BamlPropertyInfo property);
    public sealed virtual void BeginArrayProperty(BamlPropertyInfo property);
    public sealed virtual void EndListProperty();
    public sealed virtual void EndArrayProperty();
    public sealed virtual void BeginConstructorArguments();
    public sealed virtual void EndConstructorArguments();
    public sealed virtual void ConstructorParameterType(BamlTypeInfo type);
    public sealed virtual void OptimizedStaticResource(BamlTypeInfo type);
    public sealed virtual void OptimizedStaticResource(BamlPropertyInfo property);
    public sealed virtual void OptimizedStaticResource(string resourceKey);
    public sealed virtual void StaticResourceId(short staticResourceId);
    public sealed virtual void BeginStaticResource(BamlTypeInfo type);
    public sealed virtual void EndStaticResource();
    public sealed virtual void Text(string value);
    public sealed virtual void TextWithConverter(string value, BamlTypeInfo converterType);
    public sealed virtual void LiteralContent(string text);
    [NotNullAttribute]
private BamlObjectElement GetCurrentObjectElement();
    private void AddToTree(BamlElement element);
    private void AddObjectProperty(BamlProperty property);
    protected virtual void AddToDictionary(BamlElement keyElement, BamlKeyInfo keyInfo);
    private void AddComplexProperty(BamlPropertyInfo property, BamlElement valueElement);
    private void AddResource(object resource);
    private void AddResourceReference(BamlPropertyInfo property, bool isDynamic, BamlElement keyElement);
    private object ResolveResource(int staticResourceId);
    [NotNullAttribute]
public BamlObjectElement GetResult();
    [NotNullAttribute]
public INamespaceMappingProvider GetNamespaceMappingProvider();
}
[DebuggerDisplayAttribute("{Type.FullName,nq}")]
public class JetBrains.Decompiler.Baml.TreeBuilder.BamlTypeReference : BamlElement {
    [DebuggerBrowsableAttribute("0")]
private BamlTypeInfo myType;
    public BamlTypeInfo Type { get; }
    public bool IsPrimitive { get; }
    public BamlTypeReference(BamlTypeInfo type);
    public BamlTypeInfo get_Type();
    public virtual bool get_IsPrimitive();
}
[DebuggerDisplayAttribute("{PropertyInfo.Name,nq}="{Value,nq}"")]
public class JetBrains.Decompiler.Baml.TreeBuilder.BamlValueProperty : BamlProperty {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private string myValue;
    [NotNullAttribute]
public string Value { get; }
    public BamlValueProperty(BamlPropertyInfo property, string value);
    public string get_Value();
    public virtual void AddChildElement(BamlElement element);
}
public abstract class JetBrains.Decompiler.Baml.TreeBuilder.TreeBuilderBase : object {
    [CanBeNullAttribute]
protected BamlObjectElement RootElement;
    [NotNullAttribute]
protected Stack`1<BamlObject> Stack;
    [NotNullAttribute]
protected Dictionary`2<BamlObjectElement, DictionaryInfo> Dictionaries;
    [NotNullAttribute]
protected BamlPredefinedProvider Predefined;
    [NotNullAttribute]
protected Stack`1<BamlElement> ConstructorArgs;
    protected TreeBuilderBase(BamlPredefinedProvider predefinedProvider);
    [CanBeNullAttribute]
protected BamlObject GetCurrentElement();
    protected abstract virtual void AddToDictionary(BamlElement keyElement, BamlKeyInfo keyInfo);
    public sealed virtual void KeyAttributeString(string keyString, BamlKeyInfo key);
    public sealed virtual void KeyAttributeType(BamlTypeInfo type, BamlKeyInfo key);
    public sealed virtual void BeginKeyElement(BamlTypeInfo type, BamlKeyInfo key);
    public sealed virtual void EndKeyElement();
    public sealed virtual void LineAndPosition(int line, int position);
    public sealed virtual void Position(int position);
    protected void AssertStacksAreEmpty();
}
public class JetBrains.Decompiler.Baml.TypeSystem.ComposedMappingProvider : object {
    [NotNullAttribute]
private INamespaceMappingProvider myFirst;
    [NotNullAttribute]
private INamespaceMappingProvider mySecond;
    public ComposedMappingProvider(INamespaceMappingProvider first, INamespaceMappingProvider second);
    public sealed virtual IEnumerable`1<string> GetXmlNamespace(ReferencedNamespace referencedNamespace);
}
[ExtensionAttribute]
public static class JetBrains.Decompiler.Baml.TypeSystem.ComposedMappingProviderExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static INamespaceMappingProvider Compose(INamespaceMappingProvider first, INamespaceMappingProvider second);
}
public class JetBrains.Decompiler.Baml.TypeSystem.DefaultTypeSystemHelper : object {
    public static ITypeSystemHelper Instance;
    private static DefaultTypeSystemHelper();
    public sealed virtual bool IsResolved(BamlTypeInfo type);
    public sealed virtual bool IsBaseOf(BamlTypeInfo baseType, BamlTypeInfo derivedType);
    public sealed virtual bool IsMarkupExtension(BamlTypeInfo type);
    public sealed virtual bool IsXamlDeclaredType(BamlTypeInfo type, Boolean& isPublic);
    public sealed virtual BamlTypeInfo GetBaseType(BamlTypeInfo type, BamlTypeInfo[]& typeArguments);
    public sealed virtual FieldAccessRights GetFieldAccessRights(BamlTypeInfo type, string fieldName);
    public sealed virtual IList`1<EventConnectRecord> GetEventRecords(int connectionId, BamlTypeInfo type);
}
public class JetBrains.Decompiler.Baml.TypeSystem.EventConnectRecord : object {
    private BamlTypeInfo myEventOwner;
    [NotNullAttribute]
private string myEventName;
    [NotNullAttribute]
private string myHandlerName;
    public BamlTypeInfo EventOwner { get; }
    [NotNullAttribute]
public string EventName { get; }
    [NotNullAttribute]
public string HandlerName { get; }
    public EventConnectRecord(BamlTypeInfo eventOwner, string eventName, string handlerName);
    public BamlTypeInfo get_EventOwner();
    public string get_EventName();
    public string get_HandlerName();
}
public enum JetBrains.Decompiler.Baml.TypeSystem.FieldAccessRights : Enum {
    public int value__;
    public static FieldAccessRights None;
    public static FieldAccessRights Private;
    public static FieldAccessRights Protected;
    public static FieldAccessRights Internal;
    public static FieldAccessRights Public;
}
public interface JetBrains.Decompiler.Baml.TypeSystem.INamespaceMappingProvider {
    [NotNullAttribute]
public abstract virtual IEnumerable`1<string> GetXmlNamespace(ReferencedNamespace referencedNamespace);
}
public interface JetBrains.Decompiler.Baml.TypeSystem.ITypeSystemHelper {
    [PureAttribute]
public abstract virtual bool IsResolved(BamlTypeInfo type);
    [PureAttribute]
public abstract virtual bool IsBaseOf(BamlTypeInfo baseType, BamlTypeInfo derivedType);
    [PureAttribute]
public abstract virtual bool IsMarkupExtension(BamlTypeInfo type);
    [PureAttribute]
public abstract virtual bool IsXamlDeclaredType(BamlTypeInfo type, Boolean& isPublic);
    [PureAttribute]
public abstract virtual BamlTypeInfo GetBaseType(BamlTypeInfo type, BamlTypeInfo[]& typeArguments);
    [PureAttribute]
public abstract virtual FieldAccessRights GetFieldAccessRights(BamlTypeInfo type, string fieldName);
    [NotNullAttribute]
public abstract virtual IList`1<EventConnectRecord> GetEventRecords(int connectionId, BamlTypeInfo type);
}
public class JetBrains.Decompiler.Baml.TypeSystem.MetadataTypeSystemHelper : object {
    [NotNullAttribute]
private IMetadataAssembly myMetadataAssembly;
    [NotNullAttribute]
private Dictionary`2<BamlTypeInfo, IMetadataType> myTypes;
    [NotNullAttribute]
private Dictionary`2<Pair`2<IMetadataTypeInfo, IMetadataTypeInfo>, bool> mySubtypes;
    [NotNullAttribute]
private Dictionary`2<BamlTypeInfo, OneToListMap`2<int, EventConnectRecord>> myConnections;
    [CanBeNullAttribute]
private OneToSetMap`2<ReferencedNamespace, string> myAssemblyMapping;
    [CanBeNullAttribute]
private IMetadataTypeInfo myMarkupExtensionType;
    private static string MarkupExtension;
    private static string InitializeComponent;
    private static string ContentLoaded;
    private static string ConnectMethod;
    private static string EventSuffix;
    private static string AddHandlerMethod;
    private static string XmlnsDefinition;
    public MetadataTypeSystemHelper(IMetadataAssembly metadataAssembly);
    [NotNullAttribute]
private IMetadataType GetType(BamlTypeInfo type);
    private static BamlTypeInfo ToBamlType(IMetadataTypeInfo typeInfo);
    private static BamlTypeInfo ToBamlType(IMetadataType typeInfo);
    public sealed virtual bool IsResolved(BamlTypeInfo type);
    public sealed virtual bool IsBaseOf(BamlTypeInfo baseType, BamlTypeInfo derivedType);
    [PureAttribute]
private bool IsBaseOfImpl(IMetadataTypeInfo baseInfo, IMetadataTypeInfo derivedInfo);
    public sealed virtual bool IsMarkupExtension(BamlTypeInfo type);
    public sealed virtual bool IsXamlDeclaredType(BamlTypeInfo type, Boolean& isPublic);
    public sealed virtual BamlTypeInfo GetBaseType(BamlTypeInfo type, BamlTypeInfo[]& typeArguments);
    public sealed virtual FieldAccessRights GetFieldAccessRights(BamlTypeInfo type, string fieldName);
    public sealed virtual IList`1<EventConnectRecord> GetEventRecords(int connectionId, BamlTypeInfo type);
    [CanBeNullAttribute]
private OneToListMap`2<int, EventConnectRecord> DecompileConnectMethod(BamlTypeInfo type);
    [CanBeNullAttribute]
private static OneToListMap`2<int, EventConnectRecord> ParseDecompiledConnect(IDecompiledMethod method);
    [CanBeNullAttribute]
private static OneToListMap`2<int, EventConnectRecord> ParseConnectionSwitch(ISwitchStatement switchStatement);
    [CanBeNullAttribute]
private static OneToListMap`2<int, EventConnectRecord> ParseConnectionIfStatement(IIfStatement ifStatement);
    private static LocalList`1<EventConnectRecord> ParseConnectionStatements(IEnumerable`1<IStatement> caseStatements);
    [CanBeNullAttribute]
private static EventConnectRecord ParseConnectionCase(IExpressionStatement expressionStatement);
    [CanBeNullAttribute]
private static string ParseEventHandler(IDelegateCreationExpression delegateCreation);
    public sealed virtual IEnumerable`1<string> GetXmlNamespace(ReferencedNamespace referencedNamespace);
    [NotNullAttribute]
private OneToSetMap`2<ReferencedNamespace, string> LoadXmlnsDefinitions();
}
public class JetBrains.Decompiler.ClassDecompiler : object {
    private IMetadataAssembly myAssembly;
    private ClassDecompilerOptions myOptions;
    private IDebugDataCollector myDebugDataCollector;
    private IImageBodyReader myImageBodyReader;
    private Dictionary`2<IMetadataMethod, IDecompiledMethod> myDecompiledMethods;
    internal IImageBodyReader ImageBodyReader { get; }
    public ClassDecompiler(Lifetime lifetime, IMetadataAssembly assembly, ClassDecompilerOptions options, IDebugDataCollector debugDataCollector);
    internal IImageBodyReader get_ImageBodyReader();
    private MethodDecompilerOptions GetMethodDecompilerOptions();
    [NotNullAttribute]
public IDecompiledClass Decompile(IMetadataTypeInfo typeInfo, IProgressIndicator indicator);
    private void DecompileTopLevelEntryPoint(MethodDecompiler methodDecompiler, DecompiledClass decompiledClass, IProgressIndicator indicator);
    public IDecompiledMethod Decompile(IMetadataTypeInfo typeInfo, IMetadataMethod methodInfo);
    [NotNullAttribute]
public static IDecompiledClass CreateEmptyDecompiledClass(IMetadataTypeInfo typeInfo);
    private void DecompileFields(IDecompiledClass decompiledClass);
    private void DecompileProperties(MethodDecompiler methodDecompiler, IDecompiledClass decompiledClass);
    private void DecompileEvents(MethodDecompiler methodDecompiler, IDecompiledClass decompiledClass);
    private IDecompiledMethod DecompileMethod(MethodDecompiler methodDecompiler, IMetadataMethod metadataMethod);
    private bool IsRegularMethod(IMetadataMethod metadataMethod);
    private void DecompileMethods(MethodDecompiler methodDecompiler, IDecompiledClass decompiledClass, IProgressIndicator indicator);
    private void DecompileNestedTypes(IDecompiledClass decompiledClass);
    private void ExtractAutoProperties(IDecompiledClass decompiledClass);
    private void RunTransformations(IDecompiledClass decompiledClass);
    private void InspectMethods(IDecompiledClass decompiledClass);
    private static bool HasOnlyDefaultConstructor(IDecompiledClass decompiledClass);
    private static bool HasEmptyClassConstructor(IDecompiledClass decompiledClass);
    private static bool HasAsyncMain(IMetadataTypeInfo type);
}
public class JetBrains.Decompiler.ClassDecompilerOptions : object {
    [CompilerGeneratedAttribute]
private bool <DecompileBodies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowCompilerGeneratedCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowMetadataTokenValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowIlCodeInComments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InspectMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private IXmlDocProvider <XmlDocProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataLocalVariablesNameProvider <MetadataLocalVariablesNameProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContainsUnsafeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private DecompilerOptions <DecompilerOptions>k__BackingField;
    public bool DecompileBodies { get; }
    public bool ShowCompilerGeneratedCode { get; }
    public bool ShowMetadataTokenValues { get; }
    public bool ShowIlCodeInComments { get; }
    public bool InspectMethods { get; }
    [CanBeNullAttribute]
public IXmlDocProvider XmlDocProvider { get; }
    [CanBeNullAttribute]
public IMetadataLocalVariablesNameProvider MetadataLocalVariablesNameProvider { get; }
    public bool ContainsUnsafeCode { get; public set; }
    public DecompilerOptions DecompilerOptions { get; }
    public ClassDecompilerOptions(bool decompileBodies, bool showCompilerGeneratedCode, bool showMetadataTokenValues, bool showIlCodeInComments, bool inspectMethods, IXmlDocProvider xmlDocProvider, IMetadataLocalVariablesNameProvider metadataLocalVariablesNameProvider, DecompilerOptions decompilerOptions);
    public ClassDecompilerOptions(bool decompileBodies);
    [CompilerGeneratedAttribute]
public bool get_DecompileBodies();
    [CompilerGeneratedAttribute]
public bool get_ShowCompilerGeneratedCode();
    [CompilerGeneratedAttribute]
public bool get_ShowMetadataTokenValues();
    [CompilerGeneratedAttribute]
public bool get_ShowIlCodeInComments();
    [CompilerGeneratedAttribute]
public bool get_InspectMethods();
    [CompilerGeneratedAttribute]
public IXmlDocProvider get_XmlDocProvider();
    [CompilerGeneratedAttribute]
public IMetadataLocalVariablesNameProvider get_MetadataLocalVariablesNameProvider();
    [CompilerGeneratedAttribute]
public bool get_ContainsUnsafeCode();
    [CompilerGeneratedAttribute]
public void set_ContainsUnsafeCode(bool value);
    [CompilerGeneratedAttribute]
public DecompilerOptions get_DecompilerOptions();
}
[DebuggerDisplayAttribute("{DebugName,nq}")]
internal class JetBrains.Decompiler.ClosureContext : object {
    [CompilerGeneratedAttribute]
private string <DebugName>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IMetadataField, IExpression> <FieldToExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IMetadataField, ClosureContext> <FieldToContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ILocalVariable <ContextLocalVariable>k__BackingField;
    [CompilerGeneratedAttribute]
private ClosureContext <ParentScopeClosureContext>k__BackingField;
    public string DebugName { get; public set; }
    public Dictionary`2<IMetadataField, IExpression> FieldToExpression { get; }
    public Dictionary`2<IMetadataField, ClosureContext> FieldToContext { get; }
    [CanBeNullAttribute]
public ILocalVariable ContextLocalVariable { get; }
    [CanBeNullAttribute]
public ClosureContext ParentScopeClosureContext { get; public set; }
    public ClosureContext(string debugName, ILocalVariable contextLocalVariable);
    [CompilerGeneratedAttribute]
public string get_DebugName();
    [CompilerGeneratedAttribute]
public void set_DebugName(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<IMetadataField, IExpression> get_FieldToExpression();
    [CompilerGeneratedAttribute]
public Dictionary`2<IMetadataField, ClosureContext> get_FieldToContext();
    [CompilerGeneratedAttribute]
public ILocalVariable get_ContextLocalVariable();
    [CompilerGeneratedAttribute]
public ClosureContext get_ParentScopeClosureContext();
    [CompilerGeneratedAttribute]
public void set_ParentScopeClosureContext(ClosureContext value);
    public bool HasFieldInDomain(IMetadataField field);
    public Action CreateResolutionMutation(IFieldAccessExpression fieldAccess, ReferencesFinder referencesFinder);
    private static void ReplaceTempClosureVariableReferences(ILocalVariableReferenceExpression tempClosureVariableReference, ClosureContext currentContext, ReferencesFinder referencesFinder);
    public static bool IsRealThisExpression(MethodDecompilerContext context, IThisReferenceExpression thisExpression);
}
internal abstract class JetBrains.Decompiler.ControlFlow.AbstractLoopRegion : ControlFlowRegion {
    [CompilerGeneratedAttribute]
private ControlFlowBlock <ExitBlock>k__BackingField;
    public ControlFlowBlock ExitBlock { get; }
    protected AbstractLoopRegion(INodeContainer nodeContainer, ControlFlowGraph graph, ControlFlowRegion parentRegion, ControlFlowBlock entryBlock, ControlFlowBlock exitBlock, IEnumerable`1<ControlFlowBlock> blocks);
    [CompilerGeneratedAttribute]
public ControlFlowBlock get_ExitBlock();
    public virtual void Remove();
}
internal class JetBrains.Decompiler.ControlFlow.CatchRegion : HandlerRegion {
    [CompilerGeneratedAttribute]
private IMetadataType <ExceptionType>k__BackingField;
    [CompilerGeneratedAttribute]
private FilterRegion <FilterRegion>k__BackingField;
    public IMetadataType ExceptionType { get; }
    public FilterRegion FilterRegion { get; public set; }
    public CatchRegion(INodeContainer nodeContainer, ControlFlowGraph graph, ProtectedRegion protectedRegion, ControlFlowBlock entryBlock, IEnumerable`1<ControlFlowBlock> blocks, IMetadataType exceptionType, FilterRegion filterRegion);
    [CompilerGeneratedAttribute]
public IMetadataType get_ExceptionType();
    [CompilerGeneratedAttribute]
public FilterRegion get_FilterRegion();
    [CompilerGeneratedAttribute]
public void set_FilterRegion(FilterRegion value);
}
internal enum JetBrains.Decompiler.ControlFlow.ControlFlowBehavior : Enum {
    public int value__;
    public static ControlFlowBehavior Undefined;
    public static ControlFlowBehavior Terminate;
    public static ControlFlowBehavior Jump;
    public static ControlFlowBehavior Branch;
    public static ControlFlowBehavior Switch;
}
internal class JetBrains.Decompiler.ControlFlow.ControlFlowBlock : object {
    public static int BreakPriority;
    public static int ContinuePriority;
    public static int EndFinallyPriority;
    [CompilerGeneratedAttribute]
private ControlFlowGraph <Graph>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<IntRange> <InstructionRange>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<IntRange> <MsilRange>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Instruction> <Instructions>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LayoutPriority>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowRegion <Region>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowBehavior <ControlFlowBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ControlFlowBlock> <Successors>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ControlFlowBlock> <Predecessors>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ISwitchCaseValue> <SwitchCaseValues>k__BackingField;
    public static Constant DefaultSwitchValue;
    [CompilerGeneratedAttribute]
private ControlFlowBlockNode <Node>k__BackingField;
    public ControlFlowGraph Graph { get; }
    public Nullable`1<IntRange> InstructionRange { get; }
    public Nullable`1<IntRange> MsilRange { get; }
    public IList`1<Instruction> Instructions { get; }
    public int LayoutPriority { get; }
    [NotNullAttribute]
public ControlFlowRegion Region { get; private set; }
    public ControlFlowBehavior ControlFlowBehavior { get; private set; }
    public List`1<ControlFlowBlock> Successors { get; }
    public List`1<ControlFlowBlock> Predecessors { get; }
    public List`1<ISwitchCaseValue> SwitchCaseValues { get; private set; }
    public IEnumerable`1<Pair`2<ControlFlowBlock, ISwitchCaseValue>> SwitchCases { get; }
    public ControlFlowBlock ThenSuccessor { get; }
    public ControlFlowBlock ElseSuccessor { get; }
    public ControlFlowBlock JumpSuccessor { get; }
    [NotNullAttribute]
public ControlFlowBlockNode Node { get; }
    public bool IsAux { get; }
    public bool IsEmpty { get; }
    public bool IsEmptyJump { get; }
    public bool IsEmptyBranch { get; }
    public bool IsEmptySwitch { get; }
    public bool IsAlive { get; }
    public bool IsEntry { get; }
    public ControlFlowBlock(ControlFlowRegion region, Nullable`1<IntRange> instructionRange, Nullable`1<IntRange> msilRange, IList`1<Instruction> instructions, int layoutPriority);
    [CompilerGeneratedAttribute]
public ControlFlowGraph get_Graph();
    [CompilerGeneratedAttribute]
public Nullable`1<IntRange> get_InstructionRange();
    [CompilerGeneratedAttribute]
public Nullable`1<IntRange> get_MsilRange();
    [CompilerGeneratedAttribute]
public IList`1<Instruction> get_Instructions();
    [CompilerGeneratedAttribute]
public int get_LayoutPriority();
    [CompilerGeneratedAttribute]
public ControlFlowRegion get_Region();
    [CompilerGeneratedAttribute]
private void set_Region(ControlFlowRegion value);
    internal void SetRegion(ControlFlowRegion region);
    [CompilerGeneratedAttribute]
public ControlFlowBehavior get_ControlFlowBehavior();
    [CompilerGeneratedAttribute]
private void set_ControlFlowBehavior(ControlFlowBehavior value);
    [CompilerGeneratedAttribute]
public List`1<ControlFlowBlock> get_Successors();
    [CompilerGeneratedAttribute]
public List`1<ControlFlowBlock> get_Predecessors();
    [CompilerGeneratedAttribute]
public List`1<ISwitchCaseValue> get_SwitchCaseValues();
    [CompilerGeneratedAttribute]
private void set_SwitchCaseValues(List`1<ISwitchCaseValue> value);
    public void SetTerminal();
    public void SetJump(ControlFlowBlock successor);
    public void SetBranch(ControlFlowBlock thenSuccessor, ControlFlowBlock elseSuccessor);
    public void SetSwitch(IEnumerable`1<Pair`2<ControlFlowBlock, ISwitchCaseValue>> switchCases);
    public void ReplaceSuccessor(ControlFlowBlock oldSuccessor, ControlFlowBlock newSuccessor);
    public void CopyControlFlowTo(ControlFlowBlock targetBlock);
    public void Remove(bool suppressChecks);
    private void AddSuccessor(ControlFlowBlock successor);
    private void RemoveSuccessors();
    [IteratorStateMachineAttribute("JetBrains.Decompiler.ControlFlow.ControlFlowBlock/<get_SwitchCases>d__49")]
public IEnumerable`1<Pair`2<ControlFlowBlock, ISwitchCaseValue>> get_SwitchCases();
    public ControlFlowBlock get_ThenSuccessor();
    public ControlFlowBlock get_ElseSuccessor();
    public ControlFlowBlock get_JumpSuccessor();
    public ControlFlowBlock GetDefaultCaseSuccessor();
    [CompilerGeneratedAttribute]
public ControlFlowBlockNode get_Node();
    public bool get_IsAux();
    public bool get_IsEmpty();
    public bool get_IsEmptyJump();
    public bool get_IsEmptyBranch();
    public bool get_IsEmptySwitch();
    public bool get_IsAlive();
    public bool get_IsEntry();
    public virtual string ToString();
    public void DumpControlFlowBehavior(StringBuilder stringBuilder);
    public string ToStringDebug();
}
internal class JetBrains.Decompiler.ControlFlow.ControlFlowCombiner : object {
    private InterruptionChecker myInterruptionChecker;
    private LocalVariableManager myLocalVariableManager;
    private ControlFlowGraph myGraph;
    private DominatorTree myTree;
    private GotoManager myGotoManager;
    private ControlFlowCombiner(InterruptionChecker interruptionChecker, LocalVariableManager localVariableManager, ControlFlowGraph graph, DominatorTree tree, GotoManager gotoManager);
    public static IBlockStatement Run(InterruptionChecker interruptionChecker, LocalVariableManager localVariableManager, ControlFlowGraph graph, DominatorTree tree, GotoManager gotoManager);
    private IBlockStatement Run();
}
internal class JetBrains.Decompiler.ControlFlow.ControlFlowGraph : ControlFlowRegion {
    [CompilerGeneratedAttribute]
private IdGenerator`1<ControlFlowBlock> <BlockIdGenerator>k__BackingField;
    internal IdGenerator`1<ControlFlowBlock> BlockIdGenerator { get; }
    public ControlFlowGraph(INodeContainer nodeContainer);
    public virtual void Remove();
    [CompilerGeneratedAttribute]
internal IdGenerator`1<ControlFlowBlock> get_BlockIdGenerator();
    public string ToStringDebug();
    [ConditionalAttribute("VALIDATE_TRANSFORMATIONS")]
public void Validate();
}
internal class JetBrains.Decompiler.ControlFlow.ControlFlowGraphBuilder : object {
    private IMethodBody myMethodBody;
    private MetadataTypeCache myTypeCache;
    private IInstructionRedirector mySequencePointInstructionRedirector;
    private ControlFlowGraph myGraph;
    private Instruction[] myInstructions;
    private IMethodBodyExceptionHandler[] myExceptionHandlers;
    private Dictionary`2<int, int> myOffsetToInstructionIndex;
    private JetHashSet`1<int> myVisitedInstructionIndexes;
    private JetHashSet`1<int> myEndInstructionIndexes;
    private JetHashSet`1<int> myStartInstructionIndexes;
    private Dictionary`2<int, ControlFlowBlock> myFirstInstructionIndexToBlock;
    private List`1<FilterRegion> myFilterRegions;
    private ControlFlowGraphBuilder(IMethodBody methodBody, INodeContainer nodeContainer, MetadataTypeCache typeCache, IInstructionRedirector sequencePointInstructionRedirector);
    private static Instruction[] GetInstructions(IMethodBody methodBody);
    public static ControlFlowGraph Build(IMethodBody methodBody, INodeContainer container, MetadataTypeCache typeCache, IInstructionRedirector sequencePointInstructionRedirector);
    private ControlFlowGraph Build();
    private void BuildProtectedRegions();
    private static IntRange GetHandlerMsilRange(IMethodBodyExceptionHandler exceptionHandler);
    private static IntRange GetTryMsilRange(IMethodBodyExceptionHandler exceptionHandler);
    private static IntRange GetProtectedMsilRange(IMethodBodyExceptionHandler exceptionHandler);
    private static IntRange GetFilterMsilRange(IMethodBodyExceptionHandler exceptionHandler);
    private void MarkExceptionHandlers();
    private void BuildOffsetToInstructionsMap();
    private void MarkBranchTargets(int instructionIndex);
    private void BuildBlocks();
    private void BuildSuccessors();
    private void ProcessCatchWithFilter();
    private IntRange GetInstructionRangeFromOffsets(IntRange msilRange);
    private int GetInstructionIndexFromOffset(int offset);
    private ControlFlowBlock GetBlockFromFirstInstructionIndex(int index);
    private IEnumerable`1<ControlFlowBlock> GetBlocksFromInstructionRange(IntRange instructionRange);
    private ControlFlowBlock GetBlockFromOffset(int offset);
}
internal abstract class JetBrains.Decompiler.ControlFlow.ControlFlowRegion : object {
    protected INodeContainer myNodeContainer;
    [CompilerGeneratedAttribute]
private ControlFlowGraph <Graph>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowRegion <ParentRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowBlock <EntryBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<ControlFlowBlock> <Blocks>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<ProtectedRegion> <ProtectedRegions>k__BackingField;
    public ControlFlowGraph Graph { get; protected set; }
    public ControlFlowRegion ParentRegion { get; private set; }
    public ControlFlowBlock EntryBlock { get; protected set; }
    public JetHashSet`1<ControlFlowBlock> Blocks { get; }
    public JetHashSet`1<ProtectedRegion> ProtectedRegions { get; }
    protected ControlFlowRegion(INodeContainer nodeContainer, ControlFlowGraph graph, ControlFlowRegion parentRegion, ControlFlowBlock entryBlock, IEnumerable`1<ControlFlowBlock> blocks);
    [CompilerGeneratedAttribute]
public ControlFlowGraph get_Graph();
    [CompilerGeneratedAttribute]
protected void set_Graph(ControlFlowGraph value);
    [CompilerGeneratedAttribute]
public ControlFlowRegion get_ParentRegion();
    [CompilerGeneratedAttribute]
private void set_ParentRegion(ControlFlowRegion value);
    [CompilerGeneratedAttribute]
public ControlFlowBlock get_EntryBlock();
    [CompilerGeneratedAttribute]
protected void set_EntryBlock(ControlFlowBlock value);
    [CompilerGeneratedAttribute]
public JetHashSet`1<ControlFlowBlock> get_Blocks();
    [CompilerGeneratedAttribute]
public JetHashSet`1<ProtectedRegion> get_ProtectedRegions();
    public ControlFlowBlock AddInstructionBlock(IList`1<Instruction> instructions, IntRange instructionRange, IntRange msilRange, int layoutPriority);
    public ControlFlowBlock AddAuxBlock(int layoutPriority);
    private void RegisterBlock(ControlFlowBlock block);
    public void RemoveBlock(ControlFlowBlock block, bool suppressChecks);
    private void UnregisterBlock(ControlFlowBlock block);
    public ProtectedRegion AddProtectedRegion(ControlFlowBlock entryBlock, IEnumerable`1<ControlFlowBlock> blocks);
    public LoopRegion AddLoopRegion(ControlFlowBlock entryBlock, ControlFlowBlock exitBlock, IEnumerable`1<ControlFlowBlock> blocks, LoopType loopType, IExpression condition);
    public ForRegion AddForRegion(ControlFlowBlock entryBlock, ControlFlowBlock exitBlock, ControlFlowBlock iteratorBlock, IEnumerable`1<ControlFlowBlock> blocks, IExpression condition, IStatement initializer, IStatement iterator);
    public abstract virtual void Remove();
    internal virtual void SetParent(ControlFlowRegion parentRegion);
}
internal static class JetBrains.Decompiler.ControlFlow.ControlFlowUtil : object {
    public static bool IsReturnBlock(ControlFlowBlock block);
    private static bool HasValidJumpToReturnBlock(ControlFlowBlock predecessor, int variableIndex);
    public static bool IsEmptyJumpBlock(ControlFlowBlock block);
    public static bool IsEndFinallyBlock(ControlFlowBlock block);
    public static void SplitBlock(ControlFlowBlock block);
    private static ControlFlowBlock FollowJumpChain(ControlFlowBlock block);
    public static bool AreEquivalent(ControlFlowBlock block1, ControlFlowBlock block2);
    public static bool AreMergeable(ControlFlowBlock block, ControlFlowBlock successor);
    public static bool IsAncestorOf(ControlFlowRegion ancestor, ControlFlowRegion descendant);
    public static ControlFlowRegion ComputeLcaRegion(ControlFlowRegion region1, ControlFlowRegion region2);
    public static IEnumerable`1<UnwindingRegion> GetInvokedUnwindingRegions(ControlFlowBlock fromBlock, ControlFlowBlock toBlock);
    public static T GetNearestRegion(ControlFlowBlock block);
    public static AbstractLoopRegion GetLoopRegion(ControlFlowBlock block);
}
internal class JetBrains.Decompiler.ControlFlow.DominatorTree : object {
    [NotNullAttribute]
private Dictionary`2<ControlFlowBlock, DominatorTreeNode> myBlockToNode;
    private DominatorTreeNode myRoot;
    private int myDfsCounter;
    public ControlFlowBlock Root { get; }
    public DominatorTree(IList`1<Pair`2<ControlFlowBlock, ControlFlowBlock>> blockDominatorPairs);
    public ControlFlowBlock get_Root();
    [IteratorStateMachineAttribute("JetBrains.Decompiler.ControlFlow.DominatorTree/<GetChildren>d__6")]
[NotNullAttribute]
public IEnumerable`1<ControlFlowBlock> GetChildren(ControlFlowBlock block);
    public ControlFlowBlock GetParent(ControlFlowBlock block);
    public void VisitPreorder(ControlFlowBlock root, Action`1<ControlFlowBlock> action);
    public bool IsAncestorOf(ControlFlowBlock ancestor, ControlFlowBlock descendant);
    private void DfsVisit(DominatorTreeNode node);
}
internal class JetBrains.Decompiler.ControlFlow.DominatorTreeBuilder : object {
    private ControlFlowGraph myGraph;
    private int myDfsCounter;
    private List`1<ControlFlowBlock> myPostorderBlocks;
    private ExtensionManager`2<ControlFlowBlock, BlockExtension> myExtensions;
    private DominatorTreeBuilder(ControlFlowGraph graph);
    public static DominatorTree Run(ControlFlowGraph graph);
    private DominatorTree Run();
    private void DfsVisit(ControlFlowBlock block);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.ControlFlow.DominatorTreeBuilder/<GetSuccessors>d__9")]
private static IEnumerable`1<ControlFlowBlock> GetSuccessors(ControlFlowBlock block);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.ControlFlow.DominatorTreeBuilder/<GetPredecessors>d__10")]
private static IEnumerable`1<ControlFlowBlock> GetPredecessors(ControlFlowBlock block);
    private ControlFlowBlock Intersect(ControlFlowBlock block1, ControlFlowBlock block2);
    [CompilerGeneratedAttribute]
private Pair`2<ControlFlowBlock, ControlFlowBlock> <Run>b__7_0(ControlFlowBlock block);
}
internal class JetBrains.Decompiler.ControlFlow.DominatorTreeNode : object {
    [CompilerGeneratedAttribute]
private ControlFlowBlock <Block>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowBlock <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DominatorTreeNode> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PreorderIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PostorderIndex>k__BackingField;
    public ControlFlowBlock Block { get; }
    public ControlFlowBlock Parent { get; }
    public IList`1<DominatorTreeNode> Children { get; }
    public int PreorderIndex { get; public set; }
    public int PostorderIndex { get; public set; }
    public DominatorTreeNode(ControlFlowBlock block, ControlFlowBlock parent);
    [CompilerGeneratedAttribute]
public ControlFlowBlock get_Block();
    [CompilerGeneratedAttribute]
public ControlFlowBlock get_Parent();
    [CompilerGeneratedAttribute]
public IList`1<DominatorTreeNode> get_Children();
    [CompilerGeneratedAttribute]
public int get_PreorderIndex();
    [CompilerGeneratedAttribute]
public void set_PreorderIndex(int value);
    [CompilerGeneratedAttribute]
public int get_PostorderIndex();
    [CompilerGeneratedAttribute]
public void set_PostorderIndex(int value);
}
internal static class JetBrains.Decompiler.ControlFlow.EndFinallyCombiner : object {
    public static void Run(ControlFlowGraph graph);
}
internal class JetBrains.Decompiler.ControlFlow.FaultRegion : UnwindingRegion {
    public FaultRegion(INodeContainer nodeContainer, ControlFlowGraph graph, ProtectedRegion protectedRegion, ControlFlowBlock entryBlock, IEnumerable`1<ControlFlowBlock> blocks);
}
internal class JetBrains.Decompiler.ControlFlow.FilterRegion : HandlerRegion {
    [CompilerGeneratedAttribute]
private IMetadataType <ExceptionType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExceptionVariableIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private IInstructionReference <InstructionReference>k__BackingField;
    [CompilerGeneratedAttribute]
private CatchRegion <CatchRegion>k__BackingField;
    public IMetadataType ExceptionType { get; }
    public int ExceptionVariableIndex { get; public set; }
    [CanBeNullAttribute]
public IInstructionReference InstructionReference { get; public set; }
    public CatchRegion CatchRegion { get; public set; }
    public FilterRegion(INodeContainer nodeContainer, ControlFlowGraph graph, ProtectedRegion protectedRegion, ControlFlowBlock entryBlock, IEnumerable`1<ControlFlowBlock> blocks, IMetadataType exceptionType);
    [CompilerGeneratedAttribute]
public IMetadataType get_ExceptionType();
    [CompilerGeneratedAttribute]
public int get_ExceptionVariableIndex();
    [CompilerGeneratedAttribute]
public void set_ExceptionVariableIndex(int value);
    [CompilerGeneratedAttribute]
public IInstructionReference get_InstructionReference();
    [CompilerGeneratedAttribute]
public void set_InstructionReference(IInstructionReference value);
    [CompilerGeneratedAttribute]
public CatchRegion get_CatchRegion();
    [CompilerGeneratedAttribute]
public void set_CatchRegion(CatchRegion value);
    public void SetEntryBlock(ControlFlowBlock entryBlock);
}
internal class JetBrains.Decompiler.ControlFlow.FinallyRegion : UnwindingRegion {
    public FinallyRegion(INodeContainer nodeContainer, ControlFlowGraph graph, ProtectedRegion protectedRegion, ControlFlowBlock entryBlock, IEnumerable`1<ControlFlowBlock> blocks);
}
internal class JetBrains.Decompiler.ControlFlow.ForRegion : AbstractLoopRegion {
    [CompilerGeneratedAttribute]
private IExpression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowBlock <IteratorBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private IStatement <Initializer>k__BackingField;
    [CompilerGeneratedAttribute]
private IStatement <Iterator>k__BackingField;
    public IExpression Condition { get; }
    public ControlFlowBlock IteratorBlock { get; }
    public IStatement Initializer { get; }
    public IStatement Iterator { get; }
    public ForRegion(INodeContainer nodeContainer, ControlFlowGraph graph, ControlFlowRegion parentRegion, ControlFlowBlock entryBlock, IEnumerable`1<ControlFlowBlock> blocks, IExpression condition, ControlFlowBlock exitBlock, ControlFlowBlock iteratorBlock, IStatement initializer, IStatement iterator);
    [CompilerGeneratedAttribute]
public IExpression get_Condition();
    [CompilerGeneratedAttribute]
public ControlFlowBlock get_IteratorBlock();
    [CompilerGeneratedAttribute]
public IStatement get_Initializer();
    [CompilerGeneratedAttribute]
public IStatement get_Iterator();
}
internal class JetBrains.Decompiler.ControlFlow.GotoEdge : ValueType {
    [CompilerGeneratedAttribute]
private ControlFlowBlock <SourceBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowBlock <DestinationBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDestinationHead>k__BackingField;
    public ControlFlowBlock SourceBlock { get; }
    public ControlFlowBlock DestinationBlock { get; }
    public bool IsDestinationHead { get; }
    public GotoEdge(ControlFlowBlock sourceBlock, ControlFlowBlock destinationBlock, bool isDestinationHead);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ControlFlowBlock get_SourceBlock();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ControlFlowBlock get_DestinationBlock();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsDestinationHead();
}
internal class JetBrains.Decompiler.ControlFlow.GotoManager : object {
    private MethodDecompilerContext myContext;
    private LabelManager myLabelManager;
    private ControlFlowGraph myGraph;
    private Dictionary`2<ILabel, ControlFlowBlock> myLabelToBlock;
    private Dictionary`2<IGotoStatement, ControlFlowBlock> myGotoToBlock;
    private ExtensionManager`2<ControlFlowBlock, BlockExtension> myExtensions;
    private Dictionary`2<ControlFlowBlock, ControlFlowBlock> myGotoReductions;
    private DisjointSetUnion`1<BlockExtension> myBlockDsu;
    public GotoManager(MethodDecompilerContext context);
    public void Initialize();
    private void InitializeLabels();
    private void InitializeBlocks();
    public void MarkForGotoReduction(ControlFlowBlock block);
    public bool IsMarkedForGotoReduction(ControlFlowBlock block);
    private ControlFlowBlock ApplyGotoReductions(ControlFlowBlock block);
    public void RemoveRedundantLabels();
    public IGotoStatement CreateGoto(ControlFlowBlock sourceBlock, ControlFlowBlock destinationBlock);
    public GotoEdge GetEdge(IGotoStatement goto);
    public void RemoveGoto(IGotoStatement goto);
    public void ReplaceGoto(IGotoStatement goto, IStatement newStatement);
    private void UnregisterGoto(IGotoStatement goto);
    public IEnumerable`1<IGotoStatement> GetIncomingGotos(ControlFlowBlock block, bool applyReductions);
    public IEnumerable`1<IGotoStatement> GetOutcomingGotos(ControlFlowBlock block);
    public void HandleMerge(ControlFlowBlock topBlock, ControlFlowBlock bottomBlock);
    public ITryStatement WrapWithTry(ControlFlowBlock block, ICatchClause[] catchClauses, IBlockStatement finallyStatement, IBlockStatement faultStatement);
    public ILoopStatement WrapWithLoop(ControlFlowBlock block, LoopType loopType, IExpression condition);
    public IForStatement WrapWithFor(ControlFlowBlock block, IStatement initializer, IExpression condition, IStatement iterator);
    private T InternalWrapWith(ControlFlowBlock block, Func`2<IBlockStatement, T> wrapperCreator);
    private BlockExtension GetExtendedContainerBlock(ControlFlowBlock block);
}
internal class JetBrains.Decompiler.ControlFlow.HandlerRegion : ControlFlowRegion {
    [CompilerGeneratedAttribute]
private ProtectedRegion <ProtectedRegion>k__BackingField;
    public ProtectedRegion ProtectedRegion { get; }
    protected HandlerRegion(INodeContainer nodeContainer, ControlFlowGraph graph, ProtectedRegion protectedRegion, ControlFlowBlock entryBlock, IEnumerable`1<ControlFlowBlock> blocks);
    [CompilerGeneratedAttribute]
public ProtectedRegion get_ProtectedRegion();
    public virtual void Remove();
}
internal class JetBrains.Decompiler.ControlFlow.LoopRegion : AbstractLoopRegion {
    [CompilerGeneratedAttribute]
private LoopType <LoopType>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <Condition>k__BackingField;
    public LoopType LoopType { get; }
    public IExpression Condition { get; }
    public LoopRegion(INodeContainer nodeContainer, ControlFlowGraph graph, ControlFlowRegion parentRegion, ControlFlowBlock entryBlock, IEnumerable`1<ControlFlowBlock> blocks, LoopType loopType, IExpression condition, ControlFlowBlock exitBlock);
    [CompilerGeneratedAttribute]
public LoopType get_LoopType();
    [CompilerGeneratedAttribute]
public IExpression get_Condition();
}
internal class JetBrains.Decompiler.ControlFlow.LoopRegionExtractor : object {
    private DominatorTree myDominatorsTree;
    private GotoManager myGotoManager;
    private List`1<Action> myPendingMutations;
    private LoopRegionExtractor(DominatorTree dominatorsTree, GotoManager gotoManager);
    public static void Run(DominatorTree tree, GotoManager gotoManager);
    private void Run();
    private void ExtractConditionalLoops();
    private void HandleUnconditionalLoops();
    private bool IsLoopBackwardEdge(ControlFlowBlock sourceBlock, ControlFlowBlock destinationBlock);
    private bool TryExtractPreconditionalLoop(ControlFlowBlock sourceBlock, ControlFlowBlock destinationBlock);
    private bool TryExtractPreconditionalLoop(ControlFlowBlock branchBlock, ControlFlowBlock thenBlock, ControlFlowBlock elseBlock, bool negateCondition);
    private JetHashSet`1<ControlFlowBlock> GetPreconditionalLoopBody(ControlFlowBlock entryBlock, ControlFlowBlock headerBlock, ControlFlowBlock exitBlock, ControlFlowRegion enclosingRegion);
    private static bool IsForLoop(IExpression condition, ControlFlowBlock entryBlock, JetHashSet`1<ControlFlowBlock> body, ControlFlowBlock& iteratorBlock, IStatement& iterator);
    private static bool ExtractForLoopInitializer(IExpression condition, ControlFlowBlock entryBlock, JetHashSet`1<ControlFlowBlock> body, IStatement& initializer);
    private bool TryExtractPostconditionalLoop(ControlFlowBlock sourceBlock, ControlFlowBlock destinationBlock);
    private bool TryExtractPostconditionalLoop(ControlFlowBlock branchBlock, ControlFlowBlock thenBlock, ControlFlowBlock elseBlock, bool negateCondition);
    private IEnumerable`1<ControlFlowBlock> GetPostconditionalLoopBody(ControlFlowBlock entryBlock, ControlFlowBlock branchBlock, ControlFlowBlock exitBlock, ControlFlowRegion enclosingRegion);
    private bool TryExtractUnconditionalLoop(IList`1<ControlFlowBlock> sourceBlocks, ControlFlowBlock destinationBlock);
    private bool GetUnconditionalLoopBodyAndRegion(ControlFlowBlock entryBlock, IList`1<ControlFlowBlock> sourceBlocks, IEnumerable`1& body, ControlFlowRegion& enclosingRegion);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void ValidateBody(ControlFlowBlock entryBlock, ControlFlowBlock exitBlock, ControlFlowRegion enclosingRegion, IEnumerable`1<ControlFlowBlock> body);
    private JetHashSet`1<ControlFlowBlock> GetBodyClosure(ControlFlowBlock entryBlock, ControlFlowBlock exitBlock, IEnumerable`1<ControlFlowBlock> seeds, ControlFlowRegion enclosingRegion);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.ControlFlow.LoopRegionExtractor/<GetClosureBlocks>d__21")]
private static IEnumerable`1<ControlFlowBlock> GetClosureBlocks(ControlFlowBlock entryBlock, ControlFlowBlock currentBlock, ControlFlowRegion enclosingRegion);
    private static List`1<ControlFlowBlock> GetPredecessors(ControlFlowBlock currentBlock);
    private IEnumerable`1<ControlFlowBlock> GetMsilRangeSeeds(ControlFlowBlock fromBlock, ControlFlowBlock toBlock);
    private static ControlFlowRegion GetEnclosingRegion(IEnumerable`1<ControlFlowBlock> body);
    [CompilerGeneratedAttribute]
private void <ExtractConditionalLoops>b__6_0(ControlFlowBlock block);
}
internal class JetBrains.Decompiler.ControlFlow.ProtectedRegion : ControlFlowRegion {
    [CompilerGeneratedAttribute]
private IList`1<HandlerRegion> <HandlerRegions>k__BackingField;
    public IList`1<HandlerRegion> HandlerRegions { get; }
    public ProtectedRegion(INodeContainer nodeContainer, ControlFlowGraph graph, ControlFlowRegion parentRegion, ControlFlowBlock entryBlock, IEnumerable`1<ControlFlowBlock> blocks);
    [CompilerGeneratedAttribute]
public IList`1<HandlerRegion> get_HandlerRegions();
    public CatchRegion AddCatchRegion(ControlFlowBlock entryBlock, IEnumerable`1<ControlFlowBlock> blocks, IMetadataType exceptionType, FilterRegion filterRegion);
    public FilterRegion AddFilterRegion(ControlFlowBlock entryBlock, IEnumerable`1<ControlFlowBlock> blocks, IMetadataType exceptionType);
    public FinallyRegion AddFinallyRegion(ControlFlowBlock entryBlock, IEnumerable`1<ControlFlowBlock> blocks);
    public FaultRegion AddFaultRegion(ControlFlowBlock entryBlock, IEnumerable`1<ControlFlowBlock> blocks);
    public virtual void Remove();
    internal virtual void SetParent(ControlFlowRegion parentRegion);
}
internal static class JetBrains.Decompiler.ControlFlow.ReturnBlockSplitter : object {
    public static void Run(ControlFlowGraph graph);
}
internal class JetBrains.Decompiler.ControlFlow.UnwindingRegion : HandlerRegion {
    protected UnwindingRegion(INodeContainer nodeContainer, ControlFlowGraph graph, ProtectedRegion protectedRegion, ControlFlowBlock entryBlock, IEnumerable`1<ControlFlowBlock> blocks);
}
internal class JetBrains.Decompiler.DataFlow.DataFlowAnalyzer : object {
    private IMethodBody myMethodBody;
    private ControlFlowGraph myGraph;
    private Dictionary`2<Instruction, Node<Instruction>> myInstructionToNode;
    private DisjointSetUnion`1<Instruction> myInstructionDsu;
    private InstructionClassifier myInstructionClassifier;
    private UnwindingFollowersAnalyzer myUnwindingFollowersAnalyzer;
    public DataFlowAnalyzer(IMethodBody methodBody, ControlFlowGraph graph);
    public static bool IsLocalVariableInstruction(Instruction instruction);
    public Instruction GetRootInstruction(Instruction instruction);
    private void ProcessUncorrelatedInstructions();
    private void ComputeCorrelations();
    private void RunVisitor(DataFlowDfsVisitor visitor);
    private Node<Instruction> GetInstructionNode(Instruction instruction);
}
internal class JetBrains.Decompiler.DataFlow.DataFlowDfsVisitor : object {
    private IMethodBody myMethodBody;
    private InstructionClassifier myInstructionClassifier;
    private UnwindingFollowersAnalyzer myUnwindingFollowersAnalyzer;
    private ControlFlowBlock myOriginBlock;
    private Instruction myOriginInstruction;
    private Instruction myOriginStoreInstruction;
    private int myStartInstructionIndex;
    private Nullable`1<int> myStartStackBalanceLock;
    private bool myIsPinnedReset;
    private JetHashSet`1<ControlFlowBlock> myVisited;
    private List`1<Pair`2<Instruction, Instruction>> myCorrelations;
    public DataFlowDfsVisitor(IMethodBody methodBody, InstructionClassifier instructionClassifier, UnwindingFollowersAnalyzer unwindingFollowersAnalyzer, ControlFlowBlock originBlock, Instruction originInstruction, Instruction originStoreInstruction, int startInstructionIndex, Nullable`1<int> startStackBalanceLock, bool isPinnedReset);
    public IEnumerable`1<Pair`2<Instruction, Instruction>> ComputeCorrelations();
    private void DfsVisit(ControlFlowBlock currentBlock, int currentInstructionIndex, Nullable`1<int> stackBalanceLock);
    private static bool CanThrow(Instruction instruction);
    private void RegisterCorrelation(Instruction instruction1, Instruction instruction2);
}
internal class JetBrains.Decompiler.DataFlow.InstructionClassifier : object {
    private IMethodBody myMethodBody;
    public InstructionClassifier(IMethodBody methodBody);
    public bool IsPinnedVariableReset(InstructionMatcher matcher, InstructionMatcher& advancedMatcher, Instruction& storeInstruction);
    public bool IsStore(InstructionMatcher matcher, InstructionMatcher& advancedMatcher, Instruction& storeInstruction);
    public bool IsLoad(InstructionMatcher matcher, InstructionMatcher& advancedMatcher, Instruction& loadInstruction);
    public bool IsAlias(InstructionMatcher matcher, InstructionMatcher& advancedMatcher, Instruction& loadInstruction);
}
internal class JetBrains.Decompiler.DataFlow.UnwindingFollowersAnalyzer : object {
    private ControlFlowGraph myGraph;
    private OneToListMap`2<UnwindingRegion, ControlFlowBlock> myFinallyRegionToFollowers;
    public UnwindingFollowersAnalyzer(ControlFlowGraph graph);
    public IEnumerable`1<ControlFlowBlock> GetUnwindingRegionFollowers(UnwindingRegion region);
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.DataFlow.UsageClassifier : object {
    public static UsageType GetUsageType(IExpression expression);
    [CanBeNullAttribute]
public static IExpression GetInitializer(INode node);
    [ExtensionAttribute]
private static UsageType GetArgumentUsageType(IExpression argument, IMethodCallBaseExpression methodCall);
}
internal enum JetBrains.Decompiler.DataFlow.UsageType : Enum {
    public int value__;
    public static UsageType Read;
    public static UsageType Write;
    public static UsageType ReadWrite;
}
public class JetBrains.Decompiler.DecompiledClassCache : object {
    private Dictionary`2<IMetadataTypeInfo, IDecompiledClass> myDecompiledClassTypes;
    public IDecompiledClass GetOrCreateValue(IMetadataTypeInfo type, Func`2<IMetadataTypeInfo, IDecompiledClass> factory);
    public bool TryGetValue(IMetadataTypeInfo type, IDecompiledClass& decompiledClass);
}
public class JetBrains.Decompiler.DecompiledClassPreRenderOptimizations : PreRenderImportsOptimizations {
    private DecompiledClassCache myDecompiledClassCache;
    private IMetadataTypeInfo myTypeInfo;
    public DecompiledClassPreRenderOptimizations(DecompiledClassCache decompiledClassCache, ITypesCache typesCache, IMetadataTypeInfo typeInfo, bool projectionIsUsed);
    protected virtual void PostOptimizeImports(ITypesPresentation imports);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Decompiler.DecompilerOptions : object {
    [CompilerGeneratedAttribute]
private bool <DecodeNullables>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DecodeTuples>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DecompileProtectedAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DecompileLongMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveOptionalArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseDiscards>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseThrowExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseExpressionBodiedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseConditionalOperators>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseNullConditionalOperators>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseNullCoalescingOperators>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseWithExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseUserDefinedOperators>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseForeach>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSwitch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseUsing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseLock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseNameof>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsePlusInsteadOfStringConcat>k__BackingField;
    [NullableAttribute("0")]
public static DecompilerOptions Default;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public bool DecodeNullables { get; public set; }
    public bool DecodeTuples { get; public set; }
    public bool DecompileProtectedAssemblies { get; public set; }
    public bool DecompileLongMethods { get; public set; }
    public bool RemoveOptionalArguments { get; public set; }
    public bool UseDiscards { get; public set; }
    public bool UseThrowExpressions { get; public set; }
    public bool UseExpressionBodiedMembers { get; public set; }
    public bool UseConditionalOperators { get; public set; }
    public bool UseNullConditionalOperators { get; public set; }
    public bool UseNullCoalescingOperators { get; public set; }
    public bool UseWithExpressions { get; public set; }
    public bool UseUserDefinedOperators { get; public set; }
    public bool UseForeach { get; public set; }
    public bool UseSwitch { get; public set; }
    public bool UseUsing { get; public set; }
    public bool UseLock { get; public set; }
    public bool UseNameof { get; public set; }
    public bool UsePlusInsteadOfStringConcat { get; public set; }
    public DecompilerOptions(bool DecodeNullables, bool DecodeTuples, bool DecompileProtectedAssemblies, bool DecompileLongMethods, bool RemoveOptionalArguments, bool UseDiscards, bool UseThrowExpressions, bool UseExpressionBodiedMembers, bool UseConditionalOperators, bool UseNullConditionalOperators, bool UseNullCoalescingOperators, bool UseWithExpressions, bool UseUserDefinedOperators, bool UseForeach, bool UseSwitch, bool UseUsing, bool UseLock, bool UseNameof, bool UsePlusInsteadOfStringConcat);
    [CompilerGeneratedAttribute]
private DecompilerOptions(DecompilerOptions original);
    private static DecompilerOptions();
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_DecodeNullables();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DecodeNullables(bool value);
    [CompilerGeneratedAttribute]
public bool get_DecodeTuples();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DecodeTuples(bool value);
    [CompilerGeneratedAttribute]
public bool get_DecompileProtectedAssemblies();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DecompileProtectedAssemblies(bool value);
    [CompilerGeneratedAttribute]
public bool get_DecompileLongMethods();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DecompileLongMethods(bool value);
    [CompilerGeneratedAttribute]
public bool get_RemoveOptionalArguments();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RemoveOptionalArguments(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseDiscards();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseDiscards(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseThrowExpressions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseThrowExpressions(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseExpressionBodiedMembers();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseExpressionBodiedMembers(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseConditionalOperators();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseConditionalOperators(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseNullConditionalOperators();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseNullConditionalOperators(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseNullCoalescingOperators();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseNullCoalescingOperators(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseWithExpressions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseWithExpressions(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseUserDefinedOperators();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseUserDefinedOperators(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseForeach();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseForeach(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseSwitch();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseSwitch(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseUsing();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseUsing(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseLock();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseLock(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseNameof();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseNameof(bool value);
    [CompilerGeneratedAttribute]
public bool get_UsePlusInsteadOfStringConcat();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UsePlusInsteadOfStringConcat(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(DecompilerOptions left, DecompilerOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(DecompilerOptions left, DecompilerOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(DecompilerOptions other);
    [CompilerGeneratedAttribute]
public DecompilerOptions <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Boolean& DecodeNullables, Boolean& DecodeTuples, Boolean& DecompileProtectedAssemblies, Boolean& DecompileLongMethods, Boolean& RemoveOptionalArguments, Boolean& UseDiscards, Boolean& UseThrowExpressions, Boolean& UseExpressionBodiedMembers, Boolean& UseConditionalOperators, Boolean& UseNullConditionalOperators, Boolean& UseNullCoalescingOperators, Boolean& UseWithExpressions, Boolean& UseUserDefinedOperators, Boolean& UseForeach, Boolean& UseSwitch, Boolean& UseUsing, Boolean& UseLock, Boolean& UseNameof, Boolean& UsePlusInsteadOfStringConcat);
}
internal static class JetBrains.Decompiler.Dispatcher.ArithmeticInstructionHandlers : object {
    public static void Register();
}
internal class JetBrains.Decompiler.Dispatcher.BlockDecompilationContext : object {
    [CompilerGeneratedAttribute]
private IDecompiledMethodBase <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodBody <MethodBody>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataTypeCache <TypeCache>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalVariableManager <LocalVariableManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IInstructionRedirector <SequencePointInstructionRedirector>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowBlock <Block>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadonly>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <ConstrainedType>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack`1<EvaluationStackSlot> <Stack>k__BackingField;
    public IDecompiledMethodBase Method { get; }
    public IMethodBody MethodBody { get; }
    public MetadataTypeCache TypeCache { get; }
    public LocalVariableManager LocalVariableManager { get; }
    [NotNullAttribute]
public IInstructionRedirector SequencePointInstructionRedirector { get; }
    public ControlFlowBlock Block { get; }
    public bool IsReadonly { get; public set; }
    [CanBeNullAttribute]
public IMetadataType ConstrainedType { get; public set; }
    public Stack`1<EvaluationStackSlot> Stack { get; }
    public BlockDecompilationContext(IDecompiledMethodBase method, IMethodBody methodBody, MetadataTypeCache typeCache, LocalVariableManager localVariableManager, IInstructionRedirector sequencePointInstructionRedirector, ControlFlowBlock block, EvaluationStackSlot[] entryStack);
    [CompilerGeneratedAttribute]
public IDecompiledMethodBase get_Method();
    [CompilerGeneratedAttribute]
public IMethodBody get_MethodBody();
    [CompilerGeneratedAttribute]
public MetadataTypeCache get_TypeCache();
    [CompilerGeneratedAttribute]
public LocalVariableManager get_LocalVariableManager();
    [CompilerGeneratedAttribute]
public IInstructionRedirector get_SequencePointInstructionRedirector();
    [CompilerGeneratedAttribute]
public ControlFlowBlock get_Block();
    [CompilerGeneratedAttribute]
public bool get_IsReadonly();
    [CompilerGeneratedAttribute]
public void set_IsReadonly(bool value);
    [CompilerGeneratedAttribute]
public IMetadataType get_ConstrainedType();
    [CompilerGeneratedAttribute]
public void set_ConstrainedType(IMetadataType value);
    [CompilerGeneratedAttribute]
public Stack`1<EvaluationStackSlot> get_Stack();
    public void PushSlot(EvaluationStackSlot slot);
    public void PushVariable(CliType type, ILocalVariable variable);
    public EvaluationStackSlot PopSlot();
    public ILocalVariable PopVariable();
    public ILocalVariable PushExpression(CliType type, IExpression expression, IInstructionReference instructionReference);
    public ILocalVariableReferenceExpression PopExpression(IInstructionReference instructionReference);
    public void ClearStack();
    public void EmitStatement(IStatement statement);
    public void EmitStatement(IExpression expression, IInstructionReference instructionReference);
}
internal class JetBrains.Decompiler.Dispatcher.BlockDecompiler : object {
    private MethodDecompilerContext myContext;
    private ExtensionManager`2<ControlFlowBlock, BlockExtension> myExtensionManager;
    private BlockDecompiler(MethodDecompilerContext context);
    public static void Run(MethodDecompilerContext context);
    private void Run();
    private EvaluationStackSlot[] GetHandlerEntryStack(HandlerRegion region);
    private void VisitHandlers(ControlFlowBlock block);
    private void VisitBlock(ControlFlowBlock block, EvaluationStackSlot[] entryStack);
    private void InsertThunkBlock(ControlFlowBlock fromBlock, ControlFlowBlock toBlock);
}
internal static class JetBrains.Decompiler.Dispatcher.BranchInstructionHandlers : object {
    public static void Register();
}
internal static class JetBrains.Decompiler.Dispatcher.CallInstructionHandlers : object {
    public static void Register();
    private static IMetadataType GetConstrainedType(IExpression targetExpression, BlockDecompilationContext context);
    [CanBeNullAttribute]
private static Instruction TryGetSequencePointInstructionForReturn(Instruction returnInstruction, BlockDecompilationContext context);
    [CanBeNullAttribute]
private static Instruction TryGetEliminatedBlockInstructionBeforeBranchTarget(ControlFlowBlock targetBlock, ControlFlowBlock branchBlock, Instruction branchInstruction, Instruction[] methodInstructions);
    [CanBeNullAttribute]
private static Instruction TryGetEliminatedBlockInstructionBeforeSwitchTarget(ControlFlowBlock caseBlock, ControlFlowBlock switchBlock, Instruction switchInstruction, Instruction[] methodInstructions);
    [CanBeNullAttribute]
private static Instruction TryGetFirstJumpInstruction(int startInstructionOffset, Instruction[] methodInstructions);
    private static int PreviousInstructionsCount(Instruction targetInstruction, Instruction[] methodInstructions);
}
internal static class JetBrains.Decompiler.Dispatcher.ComparisonInstructionHandlers : object {
    public static void Register();
}
internal static class JetBrains.Decompiler.Dispatcher.EtcInstructionHandlers : object {
    public static void Register();
}
internal class JetBrains.Decompiler.Dispatcher.EvaluationStackSlot : ValueType {
    [CompilerGeneratedAttribute]
private CliType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ILocalVariable <Value>k__BackingField;
    public CliType Type { get; }
    public ILocalVariable Value { get; }
    public EvaluationStackSlot(CliType type, ILocalVariable value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CliType get_Type();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ILocalVariable get_Value();
}
internal static class JetBrains.Decompiler.Dispatcher.ExceptionInstructionHandlers : object {
    public static void Register();
}
internal static class JetBrains.Decompiler.Dispatcher.InstructionDispatcher : object {
    private static Dictionary`2<OpcodeValue, Action`2<BlockDecompilationContext, Instruction>> ourHandlers;
    private static InstructionDispatcher();
    public static void Dispatch(BlockDecompilationContext context, InstructionMatcher instructionMatcher);
    private static void InvokeHandler(BlockDecompilationContext context, Instruction instruction);
    public static void RegisterHandler(Action`2<BlockDecompilationContext, Instruction> handler, OpcodeValue opcodeValue);
    public static void RegisterHandler(Action`2<BlockDecompilationContext, Instruction> handler, OpcodeValue[] opcodeValues);
    [UsedImplicitlyAttribute]
public static IEnumerable`1<OpcodeValue> ComputeUncoveredOpcodeValues();
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.Dispatcher.InstructionHandlersUtil : object {
    public static void CreateParameterReference(BlockDecompilationContext context, Instruction instruction, IInstructionReference instructionReference, IExpression& reference, CliType& cliType);
    public static IExpression CreateParameterReference(BlockDecompilationContext context, Instruction instruction, IInstructionReference instructionReference);
    public static void CreateLocalVariableReference(BlockDecompilationContext context, Instruction instruction, IInstructionReference instructionReference, IExpression& reference, CliType& cliType);
    public static IExpression CreateLocalVariableReference(BlockDecompilationContext context, Instruction instruction, IInstructionReference instructionReference);
    public static void CreateFieldReference(Instruction instruction, IInstructionReference instructionReference, Nullable`1<EvaluationStackSlot> addressSlot, IExpression& reference, CliType& cliType);
    public static IExpression CreateFieldReference(Instruction instruction, IInstructionReference instructionReference, Nullable`1<EvaluationStackSlot> addressSlot);
    public static IExpression CreateComparison(BlockDecompilationContext context, Instruction instruction);
    public static IExpression[] PopArguments(BlockDecompilationContext context, IInstructionReference instructionReference, MethodInstantiation methodInstantiation);
    public static IExpression[] PopArguments(BlockDecompilationContext context, IInstructionReference instructionReference, MethodSignature signature);
    public static int GetExpectedStackHeight(IMetadataMethod method, Instruction instruction, int stackHeightBefore);
    [ExtensionAttribute]
public static IInstructionReference CreateInstructionReference(Instruction instruction, BlockDecompilationContext context);
}
internal static class JetBrains.Decompiler.Dispatcher.MethodPointerInstructionHandlers : object {
    public static void Register();
}
internal static class JetBrains.Decompiler.Dispatcher.ObjectModelInstructionHandlers : object {
    public static void Register();
}
internal static class JetBrains.Decompiler.Dispatcher.PrefixInstructionHandlers : object {
    public static void Register();
    public static bool IsPrefixInstruction(Instruction instruction);
    public static void ResetPrefixState(BlockDecompilationContext context);
}
internal static class JetBrains.Decompiler.Dispatcher.StackLoadInstructionHandlers : object {
    public static void Register();
}
internal static class JetBrains.Decompiler.Dispatcher.StackStoreInstructionHandlers : object {
    public static void Register();
}
internal static class JetBrains.Decompiler.Dispatcher.TypedReferencesInstructionHandlers : object {
    public static void Register();
}
internal class JetBrains.Decompiler.ExtensionMethodCache : object {
    private IMetadataAssembly myRootAssembly;
    private Lazy`1<OneToSetMap`2<string, IMetadataMethod>> myExtensionMethodCache;
    public ExtensionMethodCache(IMetadataAssembly rootAssembly);
    public IEnumerable`1<IMetadataMethod> GetExtensionMethodsByName(string name);
    private void PopulateCache(OneToSetMap`2<string, IMetadataMethod> cache);
    [CompilerGeneratedAttribute]
private OneToSetMap`2<string, IMetadataMethod> <.ctor>b__2_0();
}
internal class JetBrains.Decompiler.Inspections.FieldSafetyInspector : SafetyInspectorBase {
    private IDecompiledField myDecompiledField;
    private FieldSafetyInspector(IDecompiledField decompiledField, ExpressionTyper expressionTyper);
    public static void Run(IDecompiledField decompiledField, ExpressionTyper expressionTyper);
    private void Run();
    protected virtual void MarkUnsafe();
}
public class JetBrains.Decompiler.Inspections.MethodIssuesInspector : object {
    private IDecompiledMethodBase myMethod;
    private bool myWarnCompilerGeneratedEntitiesAccess;
    private NodeTreeAnalyzer myNodeTreeAnalyzer;
    private ReferencesFinder myFinder;
    private static string IssueText;
    private static string OutOfStatementScopeText;
    private MethodIssuesInspector(IDecompiledMethodBase method, bool warnCompilerGeneratedEntitiesAccess);
    public static void Run(IDecompiledMethodBase method, bool warnCompilerGeneratedEntitiesAccess);
    public static void MarkFailedMethod(IDecompiledMethodBase method);
    public static void MarkMethod(IDecompiledMethodBase method, string text);
    private void Run();
    private void AnalyzeFixed(IFixedStatement statement);
    private void AnalyzeEndFinally(IEndFinallyStatement statement);
    private void AnalyzePin(IPinStatement statement);
    private void AnalyzeUnpin(IUnpinStatement statement);
    private void AnalyzeMemoryCopy(IMemoryCopyStatement statement);
    private void AnalyzeMemoryInitialize(IMemoryInitializeStatement statement);
    private void AnalyzeJump(IJumpStatement statement);
    private void AnalyzeMemberCall(IMemberCallExpression expression);
    private void AnalyzeRefTypeToken(IRefTypeTokenExpression expression);
    private void AnalyzeFieldReference(IFieldReferenceExpression expression);
    private void AnalyzeTypeReference(ITypeReferenceExpression expression);
    private void AnalyzeMethodReference(IMethodReferenceExpression expression);
    private void AnalyzeObjectCreation(IObjectCreationExpression expression);
    private void AnalyzeCheckFinite(ICheckFiniteExpression expression);
    private void AnalyzeVirtualMethodPointer(IVirtualMethodPointerExpression expression);
    private void AnalyzeMethodPointer(IMethodPointerExpression expression);
    private void AnalyzeLocalVariableDeclaration(ILocalVariableDeclarationStatement statement);
    private void AnalyzeTry(ITryStatement statement);
    private void AnalyzeUntypedStackAlloc(IUntypedStackAllocExpression expression);
    private void AnalyzeMethodCall(IMethodCallBaseExpression expression);
    private void AnalyzeDelegateCreation(IDelegateCreationExpression expression);
    private void AnalyzeTypeCast(ITypeCastExpression expression);
    private void AnalyzeRef(IRefExpression expression);
    private void AnalyzeDeref(IDerefExpression expression);
    private void AnalyzeFieldAccess(IFieldAccessExpression expression);
    private void AnalyzeFunctionPointerCall(IFunctionPointerCallExpression expression);
    private void AnalyzeCatchClause(ICatchClause catchClause);
    private void MarkIssue(INode anchor, string text);
    [CompilerGeneratedAttribute]
private void <Run>b__8_0(INode node);
}
internal class JetBrains.Decompiler.Inspections.MethodSafetyInspector : SafetyInspectorBase {
    private IDecompiledMethodBase myMethod;
    private MethodSafetyInspector(IDecompiledMethodBase method, ExpressionTyper expressionTyper);
    public static void Run(IDecompiledMethodBase method, ExpressionTyper expressionTyper);
    private void Run();
    protected virtual void MarkUnsafe();
}
internal abstract class JetBrains.Decompiler.Inspections.SafetyInspectorBase : object {
    private ExpressionTyper myExpressionTyper;
    protected SafetyInspectorBase(ExpressionTyper expressionTyper);
    protected void InspectExpression(IExpression expression);
    protected void InspectType(IMetadataType type);
    protected abstract virtual void MarkUnsafe();
}
internal class JetBrains.Decompiler.InterruptionChecker : object {
    public InterruptionChecker(bool checkFirst);
    public void Check();
}
internal class JetBrains.Decompiler.IteratorContext : object {
    [CompilerGeneratedAttribute]
private IMetadataField <StateField>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <CurrentField>k__BackingField;
    public IMetadataField StateField { get; public set; }
    public IMetadataField CurrentField { get; public set; }
    [CompilerGeneratedAttribute]
public IMetadataField get_StateField();
    [CompilerGeneratedAttribute]
public void set_StateField(IMetadataField value);
    [CompilerGeneratedAttribute]
public IMetadataField get_CurrentField();
    [CompilerGeneratedAttribute]
public void set_CurrentField(IMetadataField value);
}
public interface JetBrains.Decompiler.IXmlDocProvider {
    [CanBeNullAttribute]
public abstract virtual string GetXmlDoc(IMetadataEntity metadataEntity);
}
internal class JetBrains.Decompiler.LabelManager : object {
    private IDecompiledMethodBase myMethod;
    private int myLabelCounter;
    [CompilerGeneratedAttribute]
private ICollection`1<ILabel> <Labels>k__BackingField;
    [NotNullAttribute]
public ICollection`1<ILabel> Labels { get; }
    public void Initialize(IDecompiledMethodBase method);
    public ILabel CreateLabel();
    [CompilerGeneratedAttribute]
public ICollection`1<ILabel> get_Labels();
    private string GenerateLabelName();
}
internal class JetBrains.Decompiler.LocalVariableManager : object {
    private IDecompiledMethodBase myMethod;
    private IMethodBody myMethodBody;
    private DataFlowAnalyzer myDataFlowAnalyzer;
    private IInstructionRedirector mySequencePointInstructionRedirector;
    private Dictionary`2<int, int> myMetadataVariableCounters;
    private Dictionary`2<CatchRegion, Pair`2<ILocalVariable, IInstructionReference>> myRegionToExceptionVariable;
    [CompilerGeneratedAttribute]
private ICollection`1<ILocalVariable> <Variables>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<Instruction, ILocalVariable> <InstructionToVariable>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalVariableManagerContext <Context>k__BackingField;
    [NotNullAttribute]
public ICollection`1<ILocalVariable> Variables { get; }
    [NotNullAttribute]
public Dictionary`2<Instruction, ILocalVariable> InstructionToVariable { get; }
    public LocalVariableManagerContext Context { get; }
    public LocalVariableManager(LocalVariableManagerContext context);
    [CompilerGeneratedAttribute]
public ICollection`1<ILocalVariable> get_Variables();
    [CompilerGeneratedAttribute]
public Dictionary`2<Instruction, ILocalVariable> get_InstructionToVariable();
    [CompilerGeneratedAttribute]
public LocalVariableManagerContext get_Context();
    public void Initialize(IDecompiledMethodBase method, IMethodBody methodBody, ControlFlowGraph graph, DataFlowAnalyzer dataFlowAnalyzer, IInstructionRedirector sequencePointInstructionRedirector);
    private void CollectExceptionVariables(ControlFlowRegion region);
    private ILocalVariable AddMetadataVariable(IMethodBody methodBody, Instruction instruction);
    public ILocalVariable GetVariableFromInstruction(Instruction instruction);
    [CanBeNullAttribute]
public ILocalVariable GetExceptionVariable(CatchRegion region);
    [CanBeNullAttribute]
public ILocalVariable GetExceptionVariable(FilterRegion filterRegion);
    [CanBeNullAttribute]
private ILocalVariable GetExceptionVariable(FilterRegion filterRegion, IInstructionReference& instructionReference);
    [CanBeNullAttribute]
public ILocalVariable GetExceptionVariable(CatchRegion region, IInstructionReference& instructionReference);
    private ILocalVariable AddExceptionVariable(IMetadataType type, CatchRegion region, IInstructionReference& instructionReference);
    [CanBeNullAttribute]
private IMethodBodyLocalVariable GetExceptionMetadataVariable(CatchRegion region, IInstructionReference& instructionReference);
    [CanBeNullAttribute]
private IMethodBodyLocalVariable GetExceptionMetadataVariable(FilterRegion filterRegion, IInstructionReference& instructionReference);
    [CanBeNullAttribute]
private IMethodBodyLocalVariable TryGetFirstStoredMetadataVariable(ControlFlowBlock block, IMetadataType variableType, IInstructionReference& instructionReference);
    [CanBeNullAttribute]
private IMethodBodyLocalVariable TryGetMethodBodyLocalVariable(int localVariableIndex, IMetadataType localVariableType);
    private IMetadataMethod TryGetMetadataMethod();
    public ILocalVariable AddTempVariable(IMetadataType type);
    public ILocalVariable AddForEachVariable(IMetadataType type, ILocalVariable existingVariable);
    public void ConvertToUsing(ILocalVariable existingVariable, bool generateName);
    public void ConvertToTuple(ILocalVariable existingVariable, bool generateName);
    public void ConvertToPattern(ILocalVariable existingVariable, bool generateName);
    public ILocalVariable AddPatternVariable(IMetadataType type);
    public ILocalVariable AddFixedVariable(IMetadataType type);
    public ILocalVariable CreateClosureVariable(IMetadataField field);
    public ILocalVariable CreateIteratorVariable(IMetadataField field);
    private string GenerateMetadataVariableName(int variableIndex);
    private string GenerateTempVariableName();
    private string GenerateExceptionVariableName();
    private string GenerateForEachVariableName();
    private string GenerateUsingVariableName();
    private string GenerateFixedVariableName();
    private string GeneratePatternVariableName();
    private string GenerateTupleVariableName();
    private string GenerateClosureVariableName(IMetadataField field);
    private string GenerateIteratorVariableName(IMetadataField field);
}
internal class JetBrains.Decompiler.LocalVariableManagerContext : object {
    [CompilerGeneratedAttribute]
private int <TempVariableCounter>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExceptionVariableCounter>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ForEachVariableCounter>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UsingVariableCounter>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FixedVariableCounter>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PatternVariableCounter>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TupleVariableCounter>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ClosureVariableCounter>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IteratorVariableCounter>k__BackingField;
    public int TempVariableCounter { get; public set; }
    public int ExceptionVariableCounter { get; public set; }
    public int ForEachVariableCounter { get; public set; }
    public int UsingVariableCounter { get; public set; }
    public int FixedVariableCounter { get; public set; }
    public int PatternVariableCounter { get; public set; }
    public int TupleVariableCounter { get; public set; }
    public int ClosureVariableCounter { get; public set; }
    public int IteratorVariableCounter { get; public set; }
    [CompilerGeneratedAttribute]
public int get_TempVariableCounter();
    [CompilerGeneratedAttribute]
public void set_TempVariableCounter(int value);
    [CompilerGeneratedAttribute]
public int get_ExceptionVariableCounter();
    [CompilerGeneratedAttribute]
public void set_ExceptionVariableCounter(int value);
    [CompilerGeneratedAttribute]
public int get_ForEachVariableCounter();
    [CompilerGeneratedAttribute]
public void set_ForEachVariableCounter(int value);
    [CompilerGeneratedAttribute]
public int get_UsingVariableCounter();
    [CompilerGeneratedAttribute]
public void set_UsingVariableCounter(int value);
    [CompilerGeneratedAttribute]
public int get_FixedVariableCounter();
    [CompilerGeneratedAttribute]
public void set_FixedVariableCounter(int value);
    [CompilerGeneratedAttribute]
public int get_PatternVariableCounter();
    [CompilerGeneratedAttribute]
public void set_PatternVariableCounter(int value);
    [CompilerGeneratedAttribute]
public int get_TupleVariableCounter();
    [CompilerGeneratedAttribute]
public void set_TupleVariableCounter(int value);
    [CompilerGeneratedAttribute]
public int get_ClosureVariableCounter();
    [CompilerGeneratedAttribute]
public void set_ClosureVariableCounter(int value);
    [CompilerGeneratedAttribute]
public int get_IteratorVariableCounter();
    [CompilerGeneratedAttribute]
public void set_IteratorVariableCounter(int value);
}
internal enum JetBrains.Decompiler.Metadata.BasicCliType : Enum {
    public int value__;
    public static BasicCliType Int32;
    public static BasicCliType Int64;
    public static BasicCliType NativeInt;
    public static BasicCliType Float;
    public static BasicCliType Object;
    public static BasicCliType Reference;
    public static BasicCliType Value;
}
internal class JetBrains.Decompiler.Metadata.CliType : ValueType {
    [CompilerGeneratedAttribute]
private BasicCliType <BasicCliType>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <ValueType>k__BackingField;
    public BasicCliType BasicCliType { get; private set; }
    public IMetadataType ValueType { get; private set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public BasicCliType get_BasicCliType();
    [CompilerGeneratedAttribute]
private void set_BasicCliType(BasicCliType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IMetadataType get_ValueType();
    [CompilerGeneratedAttribute]
private void set_ValueType(IMetadataType value);
    public static CliType FromBasicCliType(BasicCliType basicCliType);
    public static CliType FromValueType(IMetadataType valueType);
    public static CliType op_Implicit(BasicCliType basicCliType);
    public sealed virtual bool Equals(CliType other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CliType left, CliType right);
    public static bool op_Inequality(CliType left, CliType right);
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.Metadata.CliTypeEx : object {
    private static Dictionary`2<string, BasicCliType> NameToBasicType;
    private static CliTypeEx();
    [ExtensionAttribute]
public static CliType ToCliType(IMetadataType type);
    [ExtensionAttribute]
public static bool IsAnyOf(CliType lhs, CliType rhs1);
    [ExtensionAttribute]
public static bool IsAnyOf(CliType lhs, CliType rhs1, CliType rhs2);
    [ExtensionAttribute]
public static bool IsAnyOf(CliType lhs, CliType rhs1, CliType rhs2, CliType rhs3);
    [ExtensionAttribute]
public static bool IsAnyOf(CliType lhs, CliType rhs1, CliType rhs2, CliType rhs3, CliType rhs4);
    [ExtensionAttribute]
internal static ElementType ToElementType(BasicCliType type);
}
public class JetBrains.Decompiler.Metadata.EventSpecification : object {
    [CompilerGeneratedAttribute]
private IMetadataClassType <OwnerType>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataEvent <Event>k__BackingField;
    public IMetadataClassType OwnerType { get; }
    public IMetadataEvent Event { get; }
    public EventSpecification(IMetadataEvent event, IMetadataClassType ownerType);
    [CompilerGeneratedAttribute]
public IMetadataClassType get_OwnerType();
    [CompilerGeneratedAttribute]
public IMetadataEvent get_Event();
    public sealed virtual bool Equals(EventSpecification other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class JetBrains.Decompiler.Metadata.MetadataTypeCache : object {
    private MetadataLoader myMetadataLoader;
    private Dictionary`2<ElementType, IMetadataClassType> myElementTypesCache;
    private Dictionary`2<Type, IMetadataClassType> myTypeToClassType;
    [CompilerGeneratedAttribute]
private IMetadataAssembly <Corlib>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Void>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <TypedReference>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Enum>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <ValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <ObjectToString>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <ObjectEquals2>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Array>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataProperty <ArrayLength>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <String>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataProperty <StringLength>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataProperty <StringCharsInt>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <StringIsInterned>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <StringEquals1>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <RuntimeTypeHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <RuntimeMethodHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <RuntimeFieldHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <RuntimeArgumentHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <RuntimeHelpersInitializeArray>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataProperty <RuntimeHelpersOffsetToStringData>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <TypeGetTypeFromHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <IEnumerable>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <IEnumerator>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <IEnumerableGetEnumerator>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <IEnumeratorMoveNext>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataProperty <IEnumeratorCurrent>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <IEnumerable1>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <IEnumerator1>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <IEnumerable1GetEnumerator>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataProperty <IEnumerator1Current>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <IAsyncEnumerable1>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <IAsyncEnumerator1>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <IAsyncEnumerable1GetAsyncEnumerator>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataProperty <IAsyncEnumerator1Current>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <IDisposable>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <IDisposableDispose>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Char>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <CharMinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <CharMaxValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <SByte>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <SByteMinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <SByteMaxValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Byte>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <ByteMinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <ByteMaxValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Int16>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <Int16MinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <Int16MaxValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <UInt16>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <UInt16MinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <UInt16MaxValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Int32>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <Int32MinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <Int32MaxValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <UInt32>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <UInt32MinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <UInt32MaxValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Int64>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <Int64MinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <Int64MaxValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <UInt64>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <UInt64MinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <UInt64MaxValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <IntPtr>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <IntPtrToInt64>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <IntPtrZero>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <UIntPtr>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <UIntPtrZero>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Decimal>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Boolean>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Single>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <SingleMinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <SingleMaxValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <SingleEpsilon>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Double>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <DoubleMinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <DoubleMaxValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <DoubleEpsilon>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <DecimalMinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <DecimalMaxValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Math>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <MathPi>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <MathE>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <ActivatorCreateInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <DebuggerBreak>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <StringOpEquality>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Hashtable>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <HashtableAdd>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Delegate>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <DelegateCombine>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <DelegateRemove>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Nullable>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataProperty <NullableHasValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <NullableGetValueOrDefault>k__BackingField;
    [CanBeNullAttribute]
public IMetadataAssembly Corlib { get; }
    [NotNullAttribute]
public IMetadataClassType Void { get; }
    [NotNullAttribute]
public IMetadataClassType TypedReference { get; }
    [NotNullAttribute]
public IMetadataClassType Enum { get; }
    [NotNullAttribute]
public IMetadataClassType ValueType { get; }
    [NotNullAttribute]
public IMetadataClassType Exception { get; }
    [NotNullAttribute]
public IMetadataClassType Object { get; }
    [NotNullAttribute]
public IMetadataMethod ObjectToString { get; }
    [CanBeNullAttribute]
public IMetadataMethod ObjectEquals2 { get; }
    [NotNullAttribute]
public IMetadataClassType Array { get; }
    [CanBeNullAttribute]
public IMetadataProperty ArrayLength { get; }
    [NotNullAttribute]
public IMetadataClassType String { get; }
    [CanBeNullAttribute]
public IMetadataProperty StringLength { get; }
    [CanBeNullAttribute]
public IMetadataProperty StringCharsInt { get; }
    [CanBeNullAttribute]
public IMetadataMethod StringIsInterned { get; }
    [CanBeNullAttribute]
public IMetadataMethod StringEquals1 { get; }
    [NotNullAttribute]
public IMetadataClassType RuntimeTypeHandle { get; }
    [CanBeNullAttribute]
public IMetadataClassType RuntimeMethodHandle { get; }
    [CanBeNullAttribute]
public IMetadataClassType RuntimeFieldHandle { get; }
    [CanBeNullAttribute]
public IMetadataClassType RuntimeArgumentHandle { get; }
    [CanBeNullAttribute]
public IMetadataMethod RuntimeHelpersInitializeArray { get; }
    [CanBeNullAttribute]
public IMetadataProperty RuntimeHelpersOffsetToStringData { get; }
    [NotNullAttribute]
public IMetadataClassType Type { get; }
    [CanBeNullAttribute]
public IMetadataMethod TypeGetTypeFromHandle { get; }
    [NotNullAttribute]
public IMetadataClassType IEnumerable { get; }
    [NotNullAttribute]
public IMetadataClassType IEnumerator { get; }
    [CanBeNullAttribute]
public IMetadataMethod IEnumerableGetEnumerator { get; }
    [CanBeNullAttribute]
public IMetadataMethod IEnumeratorMoveNext { get; }
    [CanBeNullAttribute]
public IMetadataProperty IEnumeratorCurrent { get; }
    [CanBeNullAttribute]
public IMetadataClassType IEnumerable1 { get; }
    [CanBeNullAttribute]
public IMetadataClassType IEnumerator1 { get; }
    [CanBeNullAttribute]
public IMetadataMethod IEnumerable1GetEnumerator { get; }
    [CanBeNullAttribute]
public IMetadataProperty IEnumerator1Current { get; }
    [CanBeNullAttribute]
public IMetadataClassType IAsyncEnumerable1 { get; }
    [CanBeNullAttribute]
public IMetadataClassType IAsyncEnumerator1 { get; }
    [CanBeNullAttribute]
public IMetadataMethod IAsyncEnumerable1GetAsyncEnumerator { get; }
    [CanBeNullAttribute]
public IMetadataProperty IAsyncEnumerator1Current { get; }
    [CanBeNullAttribute]
public IMetadataClassType CancellationToken { get; }
    [NotNullAttribute]
public IMetadataClassType IDisposable { get; }
    [NotNullAttribute]
public IMetadataMethod IDisposableDispose { get; }
    [NotNullAttribute]
public IMetadataClassType Char { get; }
    [CanBeNullAttribute]
public IMetadataField CharMinValue { get; }
    [CanBeNullAttribute]
public IMetadataField CharMaxValue { get; }
    [NotNullAttribute]
public IMetadataClassType SByte { get; }
    [CanBeNullAttribute]
public IMetadataField SByteMinValue { get; }
    [CanBeNullAttribute]
public IMetadataField SByteMaxValue { get; }
    [NotNullAttribute]
public IMetadataClassType Byte { get; }
    [CanBeNullAttribute]
public IMetadataField ByteMinValue { get; }
    [CanBeNullAttribute]
public IMetadataField ByteMaxValue { get; }
    [NotNullAttribute]
public IMetadataClassType Int16 { get; }
    [CanBeNullAttribute]
public IMetadataField Int16MinValue { get; }
    [CanBeNullAttribute]
public IMetadataField Int16MaxValue { get; }
    [NotNullAttribute]
public IMetadataClassType UInt16 { get; }
    [CanBeNullAttribute]
public IMetadataField UInt16MinValue { get; }
    [CanBeNullAttribute]
public IMetadataField UInt16MaxValue { get; }
    [NotNullAttribute]
public IMetadataClassType Int32 { get; }
    [CanBeNullAttribute]
public IMetadataField Int32MinValue { get; }
    [CanBeNullAttribute]
public IMetadataField Int32MaxValue { get; }
    [NotNullAttribute]
public IMetadataClassType UInt32 { get; }
    [CanBeNullAttribute]
public IMetadataField UInt32MinValue { get; }
    [CanBeNullAttribute]
public IMetadataField UInt32MaxValue { get; }
    [NotNullAttribute]
public IMetadataClassType Int64 { get; }
    [CanBeNullAttribute]
public IMetadataField Int64MinValue { get; }
    [CanBeNullAttribute]
public IMetadataField Int64MaxValue { get; }
    [NotNullAttribute]
public IMetadataClassType UInt64 { get; }
    [CanBeNullAttribute]
public IMetadataField UInt64MinValue { get; }
    [CanBeNullAttribute]
public IMetadataField UInt64MaxValue { get; }
    [NotNullAttribute]
public IMetadataClassType IntPtr { get; }
    [CanBeNullAttribute]
public IMetadataMethod IntPtrToInt64 { get; }
    [CanBeNullAttribute]
public IMetadataField IntPtrZero { get; }
    [NotNullAttribute]
public IMetadataClassType UIntPtr { get; }
    [CanBeNullAttribute]
public IMetadataField UIntPtrZero { get; }
    [NotNullAttribute]
public IMetadataClassType Decimal { get; }
    [NotNullAttribute]
public IMetadataClassType Boolean { get; }
    [NotNullAttribute]
public IMetadataClassType Single { get; }
    [CanBeNullAttribute]
public IMetadataField SingleMinValue { get; }
    [CanBeNullAttribute]
public IMetadataField SingleMaxValue { get; }
    [CanBeNullAttribute]
public IMetadataField SingleEpsilon { get; }
    [NotNullAttribute]
public IMetadataClassType Double { get; }
    [CanBeNullAttribute]
public IMetadataField DoubleMinValue { get; }
    [CanBeNullAttribute]
public IMetadataField DoubleMaxValue { get; }
    [CanBeNullAttribute]
public IMetadataField DoubleEpsilon { get; }
    [CanBeNullAttribute]
public IMetadataField DecimalMinValue { get; }
    [CanBeNullAttribute]
public IMetadataField DecimalMaxValue { get; }
    [CanBeNullAttribute]
public IMetadataClassType Math { get; }
    [CanBeNullAttribute]
public IMetadataField MathPi { get; }
    [CanBeNullAttribute]
public IMetadataField MathE { get; }
    [NotNullAttribute]
public IMetadataMethod ActivatorCreateInstance { get; }
    [CanBeNullAttribute]
public IMetadataMethod DebuggerBreak { get; }
    [CanBeNullAttribute]
public IMetadataMethod StringOpEquality { get; }
    [CanBeNullAttribute]
public IMetadataClassType Hashtable { get; }
    [CanBeNullAttribute]
public IMetadataMethod HashtableAdd { get; }
    [NotNullAttribute]
public IMetadataClassType Delegate { get; }
    [CanBeNullAttribute]
public IMetadataMethod DelegateCombine { get; }
    [CanBeNullAttribute]
public IMetadataMethod DelegateRemove { get; }
    [CanBeNullAttribute]
public IMetadataClassType Nullable { get; }
    [CanBeNullAttribute]
public IMetadataProperty NullableHasValue { get; }
    [CanBeNullAttribute]
public IMetadataMethod NullableGetValueOrDefault { get; }
    public MetadataTypeCache(MetadataLoader metadataLoader);
    [CompilerGeneratedAttribute]
public IMetadataAssembly get_Corlib();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Void();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_TypedReference();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Enum();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_ValueType();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Exception();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Object();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_ObjectToString();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_ObjectEquals2();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Array();
    [CompilerGeneratedAttribute]
public IMetadataProperty get_ArrayLength();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_String();
    [CompilerGeneratedAttribute]
public IMetadataProperty get_StringLength();
    [CompilerGeneratedAttribute]
public IMetadataProperty get_StringCharsInt();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_StringIsInterned();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_StringEquals1();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_RuntimeTypeHandle();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_RuntimeMethodHandle();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_RuntimeFieldHandle();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_RuntimeArgumentHandle();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_RuntimeHelpersInitializeArray();
    [CompilerGeneratedAttribute]
public IMetadataProperty get_RuntimeHelpersOffsetToStringData();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Type();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_TypeGetTypeFromHandle();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_IEnumerable();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_IEnumerator();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_IEnumerableGetEnumerator();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_IEnumeratorMoveNext();
    [CompilerGeneratedAttribute]
public IMetadataProperty get_IEnumeratorCurrent();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_IEnumerable1();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_IEnumerator1();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_IEnumerable1GetEnumerator();
    [CompilerGeneratedAttribute]
public IMetadataProperty get_IEnumerator1Current();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_IAsyncEnumerable1();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_IAsyncEnumerator1();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_IAsyncEnumerable1GetAsyncEnumerator();
    [CompilerGeneratedAttribute]
public IMetadataProperty get_IAsyncEnumerator1Current();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_CancellationToken();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_IDisposable();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_IDisposableDispose();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Char();
    [CompilerGeneratedAttribute]
public IMetadataField get_CharMinValue();
    [CompilerGeneratedAttribute]
public IMetadataField get_CharMaxValue();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_SByte();
    [CompilerGeneratedAttribute]
public IMetadataField get_SByteMinValue();
    [CompilerGeneratedAttribute]
public IMetadataField get_SByteMaxValue();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Byte();
    [CompilerGeneratedAttribute]
public IMetadataField get_ByteMinValue();
    [CompilerGeneratedAttribute]
public IMetadataField get_ByteMaxValue();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Int16();
    [CompilerGeneratedAttribute]
public IMetadataField get_Int16MinValue();
    [CompilerGeneratedAttribute]
public IMetadataField get_Int16MaxValue();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_UInt16();
    [CompilerGeneratedAttribute]
public IMetadataField get_UInt16MinValue();
    [CompilerGeneratedAttribute]
public IMetadataField get_UInt16MaxValue();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Int32();
    [CompilerGeneratedAttribute]
public IMetadataField get_Int32MinValue();
    [CompilerGeneratedAttribute]
public IMetadataField get_Int32MaxValue();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_UInt32();
    [CompilerGeneratedAttribute]
public IMetadataField get_UInt32MinValue();
    [CompilerGeneratedAttribute]
public IMetadataField get_UInt32MaxValue();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Int64();
    [CompilerGeneratedAttribute]
public IMetadataField get_Int64MinValue();
    [CompilerGeneratedAttribute]
public IMetadataField get_Int64MaxValue();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_UInt64();
    [CompilerGeneratedAttribute]
public IMetadataField get_UInt64MinValue();
    [CompilerGeneratedAttribute]
public IMetadataField get_UInt64MaxValue();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_IntPtr();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_IntPtrToInt64();
    [CompilerGeneratedAttribute]
public IMetadataField get_IntPtrZero();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_UIntPtr();
    [CompilerGeneratedAttribute]
public IMetadataField get_UIntPtrZero();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Decimal();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Boolean();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Single();
    [CompilerGeneratedAttribute]
public IMetadataField get_SingleMinValue();
    [CompilerGeneratedAttribute]
public IMetadataField get_SingleMaxValue();
    [CompilerGeneratedAttribute]
public IMetadataField get_SingleEpsilon();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Double();
    [CompilerGeneratedAttribute]
public IMetadataField get_DoubleMinValue();
    [CompilerGeneratedAttribute]
public IMetadataField get_DoubleMaxValue();
    [CompilerGeneratedAttribute]
public IMetadataField get_DoubleEpsilon();
    [CompilerGeneratedAttribute]
public IMetadataField get_DecimalMinValue();
    [CompilerGeneratedAttribute]
public IMetadataField get_DecimalMaxValue();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Math();
    [CompilerGeneratedAttribute]
public IMetadataField get_MathPi();
    [CompilerGeneratedAttribute]
public IMetadataField get_MathE();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_ActivatorCreateInstance();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_DebuggerBreak();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_StringOpEquality();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Hashtable();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_HashtableAdd();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Delegate();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_DelegateCombine();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_DelegateRemove();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_Nullable();
    [CompilerGeneratedAttribute]
public IMetadataProperty get_NullableHasValue();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_NullableGetValueOrDefault();
    public IMetadataClassType GetType(ElementType elementType);
    public IMetadataClassType GetType(Type type);
    private IMetadataClassType GetType(string typeName, bool optional);
    private IMetadataProperty GetProperty(string typeName, string propertyName, IMetadataType hintPropertyType, bool optional);
    private IMetadataProperty GetProperty(string typeName, string propertyName, int hintPropertyTypeTypeParameterIndex, bool optional);
    private IMetadataProperty GetProperty(string typeName, string propertyName, IMetadataType hintPropertyType, IMetadataType[] parameterTypes, bool optional);
    private IMetadataProperty GetResolvedProperty(string typeName, string propertyName, IMetadataType[] parameterTypes, bool optional);
    private IMetadataProperty CreateUnresolvedProperty(string typeName, string propertyName, IMetadataType propertyType, IMetadataType[] parameterTypes);
    private IMetadataProperty CreateUnresolvedProperty(string typeName, string propertyName, int propertyTypeTypeParameterIndex);
    private IMetadataProperty CreateUnresolvedProperty(UnresolvedTypeInfo declaringType, string propertyName, IMetadataType propertyType, IMetadataType[] parameterTypes);
    private IMetadataMethod GetMethod(string typeName, string methodName, IMetadataType hintReturnType, bool optional);
    private IMetadataMethod GetMethod(string typeName, string methodName, IMetadataType hintReturnType, IMetadataType[] parameterTypes, bool optional);
    private MethodSignature GetUnresolvedMethodSignature(IMetadataType returnType, IMetadataType[] parameterTypes);
    private IMetadataField GetField(string typeName, string fieldName, bool optional);
    private IMetadataField GetField(string typeName, string fieldName, IMetadataType hintFieldType, bool optional);
}
internal class JetBrains.Decompiler.Metadata.ModifiersErasureTypeTransformer : object {
    public static IMetadataTypeTransformer Instance;
    private static ModifiersErasureTypeTransformer();
    public virtual IMetadataType TransformArrayType(IMetadataArrayType arrayType);
    public virtual IMetadataType TransformClassType(IMetadataClassType classType);
    public sealed virtual IMetadataType TransformTupleType(IMetadataTupleType tupleType);
    public virtual IMetadataType TransformPointerType(IMetadataPointerType pointerType);
    public virtual IMetadataType TransformReferenceType(IMetadataReferenceType referenceType);
    public virtual IMetadataType TransformTypeParameterReferenceType(IMetadataTypeParameterReferenceType typeParameterReferenceType);
    public sealed virtual IMetadataType TransformFunctionPointerType(IMetadataFunctionPointerType functionPointerType);
    public sealed virtual IMetadataType TransformBoxedType(IMetadataBoxedType boxedType);
}
public class JetBrains.Decompiler.Metadata.PropertySpecification : object {
    [CompilerGeneratedAttribute]
private IMetadataClassType <OwnerType>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataProperty <Property>k__BackingField;
    public IMetadataClassType OwnerType { get; }
    public IMetadataProperty Property { get; }
    public PropertySpecification(IMetadataProperty property, IMetadataClassType ownerType);
    public PropertySpecification(IMetadataProperty property);
    [CompilerGeneratedAttribute]
public IMetadataClassType get_OwnerType();
    [CompilerGeneratedAttribute]
public IMetadataProperty get_Property();
    public sealed virtual bool Equals(PropertySpecification other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal static class JetBrains.Decompiler.Metadata.UnresolvedMetadataTypeUtil : object {
    public static IMetadataType ComputeClosestSupertype_Unresolved(IMetadataType type1, IMetadataType type2, MetadataTypeCache typeCache);
    internal static IEnumerable`1<IMetadataType> GetBaseTypes_Unresolved(IMetadataType type, MetadataTypeCache typeCache);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Metadata.UnresolvedMetadataTypeUtil/<GetBaseTypes>d__2")]
private static IEnumerable`1<IMetadataType> GetBaseTypes(IMetadataType type, MetadataTypeCache typeCache);
}
internal class JetBrains.Decompiler.MethodDecompiler : object {
    [CanBeNullAttribute]
private MethodDecompilerContext myParentContext;
    [CanBeNullAttribute]
private ClosureContext myClosureContext;
    [CanBeNullAttribute]
private IteratorContext myIteratorContext;
    [NotNullAttribute]
private MethodDecompilerOptions myOptions;
    [NotNullAttribute]
private IMetadataAssembly myAssembly;
    [NotNullAttribute]
private IImageBodyReader myImageBodyReader;
    [CanBeNullAttribute]
private IDecompiledClass myDecompiledClass;
    [NotNullAttribute]
private IDebugDataCollector myDebugDataCollector;
    [CanBeNullAttribute]
private IMetadataLocalVariablesNameProvider myMetadataLocalVariablesNameProvider;
    private bool myDecompileBody;
    private MethodDecompilerContext myContext;
    private GraphTransformationPipeline myCorePipeline;
    private NodeTransformationPipeline myIdiomsPipeline;
    private GraphTransformationPipeline myExtractSimpleLocalFunctionsPipeline;
    private NodeTransformationPipeline myLiteralOptimizationPipeline;
    private NodeTransformationPipeline myExtractNameOfPipeline;
    private NodeTransformationPipeline myExtractInitializersPipeline;
    private BlockTransformationPipeline myReductionPipeline;
    private static int MethodMaxLength;
    [CanBeNullAttribute]
public MethodDecompilerContext Context { get; }
    public MethodDecompiler(MethodDecompilerOptions options, IMetadataAssembly assembly, IImageBodyReader imageBodyReader, IDebugDataCollector debugDataCollector, IMetadataLocalVariablesNameProvider metadataLocalVariablesNameProvider, bool decompileBody, IDecompiledClass decompiledClass);
    internal MethodDecompiler(MethodDecompilerOptions options, MethodDecompilerContext parentContext, ClosureContext closureContext, IteratorContext iteratorContext);
    private MethodDecompiler(MethodDecompilerOptions options, IMetadataAssembly assembly, IImageBodyReader imageBodyReader, IDebugDataCollector debugDataCollector, IMetadataLocalVariablesNameProvider metadataLocalVariablesNameProvider, IDecompiledClass decompiledClass, MethodDecompilerContext parentContext, ClosureContext closureContext, IteratorContext iteratorContext, bool decompileBody);
    public MethodDecompilerContext get_Context();
    [NotNullAttribute]
public IDecompiledMethod Decompile(IMetadataMethod metadataMethod);
    [NotNullAttribute]
public ILocalFunction DecompileLocalFunction(IMetadataMethod metadataMethod, IDecompiledMethodBase ownerMethod);
    [NotNullAttribute]
internal IDecompiledMethodBase UnguardedDecompile(IMetadataMethod metadataMethod, IDecompiledMethodBase ownerMethod);
    private void PreventStackOverflow(IMetadataMethod metadataMethod);
    private static void LogMoveNextDecompilingError(string stateMachineType, IMetadataMethod moveNextMethod);
    private static bool CheckForStubMethod(IDecompiledMethodBase decompiledMethod, IMethodBody methodBody);
    private void InitializePipelines(InterruptionChecker interruptionChecker);
    private void DecompileBody(InterruptionChecker interruptionChecker);
    private void RunReductionStage();
    private void RunCoreStage();
    private void RunIdiomsStage();
    private void ExtractSimpleLocalFunctionsStage();
    private void RunLiteralOptimizationStage();
    private void RunExtractNameOfStage();
    private void RunExtractInitializersStage();
    private void ResolveClosureReferences();
    private void ResolveClosureReferences(INode node, MethodDecompilerContext context);
    private static void ResolveParameterReferences(ILocalFunction localFunction, MethodDecompilerContext context);
    private void CollectLocalVariables();
    private void AddKickoffMethodToDebugData();
    [CanBeNullAttribute]
private static IDecompiledClass GetOwnerClass(IDecompiledMethodBase method);
}
internal class JetBrains.Decompiler.MethodDecompilerContext : object {
    [CompilerGeneratedAttribute]
private MethodDecompilerContext <RootContext>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodDecompilerContext <ParentContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ClosureContext <ClosureContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IteratorContext <IteratorContext>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodDecompilerOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataAssembly <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private IImageBodyReader <ImageBodyReader>k__BackingField;
    [CompilerGeneratedAttribute]
private IDecompiledMethodBase <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataTypeCache <TypeCache>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodBody <MethodBody>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowGraph <ControlFlowGraph>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferencesFinder <ReferencesFinder>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionTyper <ExpressionTyper>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalVariableManager <LocalVariableManager>k__BackingField;
    [CompilerGeneratedAttribute]
private TupleElementNameManager <TupleElementNameManager>k__BackingField;
    [CompilerGeneratedAttribute]
private LabelManager <LabelManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataLocalVariablesNameProvider <MetadataLocalVariablesNameProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IDebugDataCollector <DebugDataCollector>k__BackingField;
    [CompilerGeneratedAttribute]
private IInstructionRedirector <SequencePointInstructionRedirector>k__BackingField;
    public MethodDecompilerContext RootContext { get; public set; }
    public MethodDecompilerContext ParentContext { get; public set; }
    public ClosureContext ClosureContext { get; public set; }
    public IteratorContext IteratorContext { get; public set; }
    public MethodDecompilerOptions Options { get; public set; }
    public IMetadataAssembly Assembly { get; public set; }
    public IImageBodyReader ImageBodyReader { get; public set; }
    public IDecompiledMethodBase Method { get; public set; }
    public MetadataTypeCache TypeCache { get; public set; }
    public IMethodBody MethodBody { get; public set; }
    public ControlFlowGraph ControlFlowGraph { get; public set; }
    public ReferencesFinder ReferencesFinder { get; public set; }
    public ExpressionTyper ExpressionTyper { get; public set; }
    public LocalVariableManager LocalVariableManager { get; public set; }
    [CanBeNullAttribute]
public TupleElementNameManager TupleElementNameManager { get; public set; }
    public LabelManager LabelManager { get; public set; }
    [CanBeNullAttribute]
public IMetadataLocalVariablesNameProvider MetadataLocalVariablesNameProvider { get; public set; }
    public IDebugDataCollector DebugDataCollector { get; public set; }
    public IInstructionRedirector SequencePointInstructionRedirector { get; public set; }
    [CompilerGeneratedAttribute]
public MethodDecompilerContext get_RootContext();
    [CompilerGeneratedAttribute]
public void set_RootContext(MethodDecompilerContext value);
    [CompilerGeneratedAttribute]
public MethodDecompilerContext get_ParentContext();
    [CompilerGeneratedAttribute]
public void set_ParentContext(MethodDecompilerContext value);
    [CompilerGeneratedAttribute]
public ClosureContext get_ClosureContext();
    [CompilerGeneratedAttribute]
public void set_ClosureContext(ClosureContext value);
    [CompilerGeneratedAttribute]
public IteratorContext get_IteratorContext();
    [CompilerGeneratedAttribute]
public void set_IteratorContext(IteratorContext value);
    [CompilerGeneratedAttribute]
public MethodDecompilerOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(MethodDecompilerOptions value);
    [CompilerGeneratedAttribute]
public IMetadataAssembly get_Assembly();
    [CompilerGeneratedAttribute]
public void set_Assembly(IMetadataAssembly value);
    [CompilerGeneratedAttribute]
public IImageBodyReader get_ImageBodyReader();
    [CompilerGeneratedAttribute]
public void set_ImageBodyReader(IImageBodyReader value);
    [CompilerGeneratedAttribute]
public IDecompiledMethodBase get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(IDecompiledMethodBase value);
    [CompilerGeneratedAttribute]
public MetadataTypeCache get_TypeCache();
    [CompilerGeneratedAttribute]
public void set_TypeCache(MetadataTypeCache value);
    [CompilerGeneratedAttribute]
public IMethodBody get_MethodBody();
    [CompilerGeneratedAttribute]
public void set_MethodBody(IMethodBody value);
    [CompilerGeneratedAttribute]
public ControlFlowGraph get_ControlFlowGraph();
    [CompilerGeneratedAttribute]
public void set_ControlFlowGraph(ControlFlowGraph value);
    [CompilerGeneratedAttribute]
public ReferencesFinder get_ReferencesFinder();
    [CompilerGeneratedAttribute]
public void set_ReferencesFinder(ReferencesFinder value);
    [CompilerGeneratedAttribute]
public ExpressionTyper get_ExpressionTyper();
    [CompilerGeneratedAttribute]
public void set_ExpressionTyper(ExpressionTyper value);
    [CompilerGeneratedAttribute]
public LocalVariableManager get_LocalVariableManager();
    [CompilerGeneratedAttribute]
public void set_LocalVariableManager(LocalVariableManager value);
    [CompilerGeneratedAttribute]
public TupleElementNameManager get_TupleElementNameManager();
    [CompilerGeneratedAttribute]
public void set_TupleElementNameManager(TupleElementNameManager value);
    [CompilerGeneratedAttribute]
public LabelManager get_LabelManager();
    [CompilerGeneratedAttribute]
public void set_LabelManager(LabelManager value);
    [CompilerGeneratedAttribute]
public IMetadataLocalVariablesNameProvider get_MetadataLocalVariablesNameProvider();
    [CompilerGeneratedAttribute]
public void set_MetadataLocalVariablesNameProvider(IMetadataLocalVariablesNameProvider value);
    [CompilerGeneratedAttribute]
public IDebugDataCollector get_DebugDataCollector();
    [CompilerGeneratedAttribute]
public void set_DebugDataCollector(IDebugDataCollector value);
    [CompilerGeneratedAttribute]
public IInstructionRedirector get_SequencePointInstructionRedirector();
    [CompilerGeneratedAttribute]
public void set_SequencePointInstructionRedirector(IInstructionRedirector value);
}
internal enum JetBrains.Decompiler.MethodDecompilerMode : Enum {
    public int value__;
    public static MethodDecompilerMode Regular;
    public static MethodDecompilerMode IteratorMoveNext;
    public static MethodDecompilerMode IteratorFinally;
    public static MethodDecompilerMode AsyncIteratorMoveNext;
    public static MethodDecompilerMode AsyncMoveNext;
}
internal class JetBrains.Decompiler.MethodDecompilerOptions : object {
    [CompilerGeneratedAttribute]
private MethodDecompilerMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunSafetyInspection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunFinalTransformations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TransformHighLevelConstructs>k__BackingField;
    [CompilerGeneratedAttribute]
private DecompilerOptions <DecompilerOptions>k__BackingField;
    public MethodDecompilerMode Mode { get; public set; }
    public bool GenerateNames { get; public set; }
    public bool RunSafetyInspection { get; public set; }
    public bool RunFinalTransformations { get; public set; }
    public bool TransformHighLevelConstructs { get; public set; }
    public DecompilerOptions DecompilerOptions { get; public set; }
    public static MethodDecompilerOptions GetDefault(DecompilerOptions decompilerOptions);
    public static MethodDecompilerOptions GetDefault();
    [CompilerGeneratedAttribute]
public MethodDecompilerMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(MethodDecompilerMode value);
    [CompilerGeneratedAttribute]
public bool get_GenerateNames();
    [CompilerGeneratedAttribute]
public void set_GenerateNames(bool value);
    [CompilerGeneratedAttribute]
public bool get_RunSafetyInspection();
    [CompilerGeneratedAttribute]
public void set_RunSafetyInspection(bool value);
    [CompilerGeneratedAttribute]
public bool get_RunFinalTransformations();
    [CompilerGeneratedAttribute]
public void set_RunFinalTransformations(bool value);
    [CompilerGeneratedAttribute]
public bool get_TransformHighLevelConstructs();
    [CompilerGeneratedAttribute]
public void set_TransformHighLevelConstructs(bool value);
    [CompilerGeneratedAttribute]
public DecompilerOptions get_DecompilerOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DecompilerOptions(DecompilerOptions value);
    public MethodDecompilerOptions Clone();
    public MethodDecompilerOptions ToMinimal(MethodDecompilerMode mode);
}
internal static class JetBrains.Decompiler.MethodSignatureBuilder : object {
    public static void Run(IDecompiledMethodBase method, bool isLocalFunction);
}
internal enum JetBrains.Decompiler.Naming.DeclarationKind : Enum {
    public int value__;
    public static DeclarationKind Parameter;
    public static DeclarationKind MetadataVariable;
    public static DeclarationKind RegularVariable;
}
internal class JetBrains.Decompiler.Naming.DeclarationNameNode : NameNode {
    private Action`1<string> myNameSetter;
    [CompilerGeneratedAttribute]
private DeclarationKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private NameSuggestion <NameSuggestion>k__BackingField;
    public DeclarationKind Kind { get; }
    public NameSuggestion NameSuggestion { get; }
    public DeclarationNameNode(ScopeNameNode parent, DeclarationKind kind, Action`1<string> nameSetter, NameSuggestion nameSuggestion);
    [CompilerGeneratedAttribute]
public DeclarationKind get_Kind();
    [CompilerGeneratedAttribute]
public NameSuggestion get_NameSuggestion();
    public void SetName(string name);
    public virtual void VisitDeclarations(DeclarationKind kind, Action`1<DeclarationNameNode> action);
    public virtual void VisitScopes(Action`1<ScopeNameNode> action);
}
internal enum JetBrains.Decompiler.Naming.IdentifierKind : Enum {
    public int value__;
    public static IdentifierKind ClassName;
    public static IdentifierKind InterfaceName;
    public static IdentifierKind TypeParameterName;
    public static IdentifierKind MethodName;
    public static IdentifierKind PropertyName;
}
internal class JetBrains.Decompiler.Naming.NameGenerator : object {
    private MethodDecompilerContext myMethodDecompilerContext;
    private ScopeNameNode myRootNode;
    private NameScopeDeclarationManager myDeclarationManager;
    private JetHashSet`1<Pair`2<ScopeNameNode, string>> myConflictingDeclarations;
    private Dictionary`2<string, int> NameToOrdinal;
    private NameGenerator(MethodDecompilerContext methodDecompilerContext);
    public static void Run(MethodDecompilerContext methodDecompilerContext);
    private void Run();
    private void GenerateNames(DeclarationKind declarationKind);
    private void FindConflictingSuggestions(DeclarationKind declarationKind);
    private void SetNames(DeclarationKind declarationKind);
    private static string GenerateSerialName(string name, int serial);
    [CompilerGeneratedAttribute]
private void <SetNames>b__10_0(DeclarationNameNode node);
}
internal abstract class JetBrains.Decompiler.Naming.NameNode : object {
    [CompilerGeneratedAttribute]
private ScopeNameNode <Parent>k__BackingField;
    public ScopeNameNode Parent { get; }
    protected NameNode(ScopeNameNode parent);
    [CompilerGeneratedAttribute]
public ScopeNameNode get_Parent();
    public abstract virtual void VisitDeclarations(DeclarationKind kind, Action`1<DeclarationNameNode> action);
    public abstract virtual void VisitScopes(Action`1<ScopeNameNode> action);
}
internal class JetBrains.Decompiler.Naming.NameScopeDeclarationManager : object {
    private OneToSetMap`2<ScopeNameNode, string> myDeclaredNames;
    public void Declare(ScopeNameNode node, string name);
    public bool IsDeclaredInAncestor(ScopeNameNode node, string name, ScopeNameNode& ancestorNode);
    public bool IsDeclaredInAncestor(ScopeNameNode node, string name);
    public bool IsDeclaredInDescendant(ScopeNameNode node, string name);
    public bool IsDeclaredInRelated(ScopeNameNode node, string name);
}
internal class JetBrains.Decompiler.Naming.NameSuggester : object {
    private static NameSuggestion ourDefaultSuggestion;
    private static NameSuggestion ourNumericSuggestion;
    private static NameSuggestion ourCharSuggestion;
    private static NameSuggestion ourBooleanSuggestion;
    private static NameSuggestion ourObjectSuggestion;
    private static NameSuggestion ourStringSuggestion;
    private static NameSuggestion ourForIndexSuggestion;
    private static NameSuggestion ourExceptionSuggestion;
    private static NameSuggestion ourCollectionIndexSuggestion;
    private static NameSuggestion ourArrayLengthSuggestion;
    private static NameSuggestion ourAnonymousTypeSuggestion;
    private static NameSuggestion ourAnonymousDelegateSuggestion;
    private static NameSuggestion ourTupleTypeSuggestion;
    private static HashSet`1<string> ourGenericNames;
    private static HashSet`1<string> ourGetterNames;
    private static String[] ourGetOrCreateSequence;
    private static HashSet`1<string> ourForbiddenNames;
    private static HashSet`1<string> ourCollectionSuffixes;
    private static Dictionary`2<string, string> ourCollectionTypeSuffixes;
    private static string ArraySuffix;
    private static string PointerSuffix;
    private static int MaxPreferredIdLength;
    private ReferencesFinder myFinder;
    [CanBeNullAttribute]
private IMetadataLocalVariablesNameProvider myMetadataLocalVariablesNameProvider;
    public NameSuggester(MethodDecompilerContext methodDecompilerContext);
    private static NameSuggester();
    private static NameSuggestion SuggestFromParameter(IMethodParameter parameter);
    public NameSuggestion Suggest(IMethodParameter parameter);
    public NameSuggestion Suggest(ILocalVariableDeclarationStatement statement);
    public NameSuggestion Suggest(ITypePatternExpressionBase expression);
    public NameSuggestion Suggest(IUsingStatement statement);
    public NameSuggestion Suggest(IFixedStatement statement);
    public NameSuggestion Suggest(ITupleExpression tupleExpression, ILocalVariableReferenceExpression component);
    public NameSuggestion SuggestBoundVariable(ILocalVariable variable);
    public NameSuggestion Suggest(ICatchClause clause);
    private static void ChooseBestSuggestion(NameSuggestion& current, NameSuggestion candidate);
    private NameSuggestion SuggestFromMetadata(ILocalVariable variable);
    private static NameSuggestion SuggestFromType(IMetadataType type);
    private static NameSuggestion SuggestFromGenericCollectionType(IMetadataClassType classType);
    private static NameSuggestion AddSuggestionSuffix(NameSuggestion suggestion, string suffix, NameSuggestionKind kind);
    private static NameSuggestion SuggestFromParsedIdentifier(ParsedIdentifier parsedIdentifier, NameSuggestionKind kind, bool allowForbidden);
    private NameSuggestion SuggestFromUsages(ILocalVariable variable);
    private static NameSuggestion SuggestFromUsage(ILocalVariableReferenceExpression variableReference);
    private static NameSuggestion IgnoreTypeSuggestion(NameSuggestion suggestion, IMetadataType type);
    private static NameSuggestion SuggestElementNameFromCollection(IExpression expression);
    private static NameSuggestion SuggestElementNameFromCollection(ParsedIdentifier parsedCollectionName, NameSuggestionKind suggestionKind);
    private static NameSuggestion SuggestFromArgument(IExpression argument, NameSuggestionKind suggestionKind);
    private static IMetadataParameter[] GetDeconstructOutParameters(IMetadataMethod deconstructMethod);
    private static bool GetPropertyParameters(IMetadataProperty property, IMetadataParameter[]& parameters);
    private static NameSuggestion SuggestFromArgument(IExpression argument, IExpression[] arguments, IMetadataParameter[] parameters, NameSuggestionKind suggestionKind);
    private static NameSuggestion SuggestFromAssignment(IExpression rhsExpression);
    private static int TryGetGetterPrefixIndex(ParsedIdentifier parsedMethodName);
    private static bool MatchSequence(IList`1<string> source, int startIndex, String[] sequence);
    private static ParsedIdentifier SkipFieldPrefix(IMetadataField field);
    [NotNullAttribute]
private static IExpression GetMainExpression(IExpression expression);
    private static bool IsNullOrEmptyOrZeroLiteral(IExpression expression);
    private static bool IsZero(Constant constant);
    [NotNullAttribute]
private static IExpression GetWrappedExpression(IExpression expression, IMetadataType& type);
    private static bool IsValidDerivedName(string name);
}
internal class JetBrains.Decompiler.Naming.NameSuggestion : ValueType {
    public static NameSuggestion Null;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private NameSuggestionKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPlural>k__BackingField;
    [CanBeNullAttribute]
public string Name { get; }
    public NameSuggestionKind Kind { get; }
    public bool IsPlural { get; }
    public bool IsValid { get; }
    public NameSuggestion(string name, NameSuggestionKind kind);
    public NameSuggestion(string name, bool isPlural, NameSuggestionKind kind);
    private static NameSuggestion();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public NameSuggestionKind get_Kind();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsPlural();
    public bool get_IsValid();
    public bool IsBetterThan(NameSuggestion other);
}
internal enum JetBrains.Decompiler.Naming.NameSuggestionKind : Enum {
    public int value__;
    public static NameSuggestionKind Null;
    public static NameSuggestionKind Default;
    public static NameSuggestionKind Worst;
    public static NameSuggestionKind ElementType;
    public static NameSuggestionKind TypeName;
    public static NameSuggestionKind ForIndexVariable;
    public static NameSuggestionKind CollectionIndex;
    public static NameSuggestionKind ArrayLength;
    public static NameSuggestionKind Return;
    public static NameSuggestionKind Argument;
    public static NameSuggestionKind RefParameter;
    public static NameSuggestionKind Assignment;
    public static NameSuggestionKind OutParameter;
    public static NameSuggestionKind InParameter;
    public static NameSuggestionKind ExceptionVariable;
    public static NameSuggestionKind Metadata;
    public static NameSuggestionKind Best;
}
internal class JetBrains.Decompiler.Naming.NameTreeBuilder : object {
    private IDecompiledMethodBase myMethod;
    private NameSuggester myNameSuggester;
    private HashSet`1<IStatement> myAnalyzedStatements;
    private NameTreeBuilder(MethodDecompilerContext methodDecompilerContext);
    public static ScopeNameNode Run(MethodDecompilerContext methodDecompilerContext);
    private ScopeNameNode Run();
    private void AnalyzeStatement(IStatement statement, ScopeNameNode parentNode);
    private void AnalyzeAnonymousMethod(IFunctionSignature signature, IBlockStatement body, ScopeNameNode parentNode);
    private void AnalyzeBlockStatement(IBlockStatement block, ScopeNameNode parent);
    private void AnalyzeExpressions(INode node, Action`1<IExpression> analyze);
}
internal class JetBrains.Decompiler.Naming.ParsedIdentifier : ValueType {
    [CompilerGeneratedAttribute]
private IList`1<string> <Tokens>k__BackingField;
    public IList`1<string> Tokens { get; }
    public ParsedIdentifier(string id, IdentifierKind kind);
    private ParsedIdentifier(IEnumerable`1<string> tokens);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IList`1<string> get_Tokens();
    public ParsedIdentifier Slice(int startIndex, int length);
    public ParsedIdentifier Slice(int startIndex);
    public string FormatCamelCase();
    private static string Normalize(string id, IdentifierKind kind);
    private static List`1<string> Split(string id);
    private static int ExtractToken(string id, int startIndex);
    private static bool IsTokenStartCharacter(char ch);
    private static bool IsTokenPartCharacter(char ch);
}
internal class JetBrains.Decompiler.Naming.ScopeNameNode : NameNode {
    private List`1<NameNode> myNodes;
    public ScopeNameNode(ScopeNameNode parent);
    public void CreateDeclarationNode(ILocalVariable variable, NameSuggestion nameSuggestion);
    private static DeclarationKind GetDeclarationKind(ILocalVariable variable);
    public void CreateDeclarationNode(IMethodParameter parameter, NameSuggestion nameSuggestion);
    public ScopeNameNode CreateNestedScopeNode();
    public virtual void VisitDeclarations(DeclarationKind kind, Action`1<DeclarationNameNode> action);
    public virtual void VisitScopes(Action`1<ScopeNameNode> action);
}
internal class JetBrains.Decompiler.PreRenderOptimizationsContext : object {
    [CompilerGeneratedAttribute]
private ExpressionTyper <ExpressionTyper>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionMethodCache <ExtensionMethodCache>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ImportedNamespaces>k__BackingField;
    public ExpressionTyper ExpressionTyper { get; }
    public ExtensionMethodCache ExtensionMethodCache { get; }
    public HashSet`1<string> ImportedNamespaces { get; }
    public PreRenderOptimizationsContext(ExpressionTyper expressionTyper, ExtensionMethodCache extensionMethodCache, IEnumerable`1<string> importedNamespaces);
    [CompilerGeneratedAttribute]
public ExpressionTyper get_ExpressionTyper();
    [CompilerGeneratedAttribute]
public ExtensionMethodCache get_ExtensionMethodCache();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ImportedNamespaces();
}
public class JetBrains.Decompiler.Render.BeginMethodCodeMarker : BeginTypeMemberMarker {
    [CompilerGeneratedAttribute]
private IMetadataMethod <Method>k__BackingField;
    public IMetadataMethod Method { get; }
    public BeginMethodCodeMarker(IMetadataMethod method);
    [CompilerGeneratedAttribute]
public IMetadataMethod get_Method();
}
internal class JetBrains.Decompiler.Render.CSharp.AstRenderer : object {
    [NotNullAttribute]
private ICodeTextWriter myWriter;
    [CanBeNullAttribute]
private MetadataRenderer myMetadataRenderer;
    [CompilerGeneratedAttribute]
private bool <ShowIlCodeInComments>k__BackingField;
    private static int MaxSingleLineExpressionLength;
    internal static string ConditionalAccessSign;
    public static string DiscardSign;
    private static JetHashSet`1<UnicodeCategory> RegularCharCategories;
    private bool ShowCompilerGeneratedCode { get; }
    public bool ShowIlCodeInComments { get; public set; }
    public AstRenderer(ICodeTextWriter writer, MetadataRenderer metadataRenderer);
    private static AstRenderer();
    public void RenderMethod(IDecompiledMethodBase method);
    private bool RenderMethodBody(IDecompiledMethodBase method, bool onlyRenderAsExpressionBodied);
    private void RenderAsExpressionBodied(IExpression bodyExpression);
    private IDisposable WithBraces();
    public static IMetadataTypeParameter[] GetTypeParameters(IDecompiledMethodBase method);
    private void RenderFullSignature(IFunctionSignature signature);
    private void WriteParameter(RenderParameter parameter);
    private void RenderParameterTokenAndAttributes(IMetadataParameter parameter);
    private void RenderCompactSignature(IFunctionSignature signature);
    private void RenderCompactSingleSignature(IFunctionSignature signature);
    private void RenderSignature(IFunctionSignature signature, IMetadataMethod metadataMethod, bool isLocalOrAnonymousFunction);
    public void AppendNewLine();
    public void AppendText(string text);
    private TypeRenderingParameters GetTypeRenderingParameters(IMetadataEntity metadataEntity);
    private bool get_ShowCompilerGeneratedCode();
    [CompilerGeneratedAttribute]
public bool get_ShowIlCodeInComments();
    [CompilerGeneratedAttribute]
public void set_ShowIlCodeInComments(bool value);
    public void RenderExpression(IExpression expression);
    public void RenderConstant(Constant constant, LiteralFormat literalFormat, IMetadataField field);
    private void RenderExpression(IExpression expression, ExpressionRenderContext context, ArgumentPosition position);
    private void RenderMethodReference(IMethodReferenceExpression expression);
    private void RenderFieldReference(IFieldReferenceExpression expression);
    private void RenderTypeReference(ITypeReferenceExpression expression);
    private void RenderSizeOf(ISizeOfExpression expression);
    private void RenderTypeOf(ITypeOfExpression expression);
    private void RenderNameOf(INameOfExpression expression);
    private void RenderDefaultValue(IDefaultValueExpression expression);
    private void RenderArgListCreation(IArgListCreationExpression expression, ExpressionRenderContext context);
    private void RenderMakeRef(IMakeRefExpression expression, ExpressionRenderContext context);
    private void RenderRefType(IRefTypeExpression expression, ExpressionRenderContext context);
    private void RenderRefTypeToken(IRefTypeTokenExpression expression, ExpressionRenderContext context);
    private void RenderRefValue(IRefValueExpression expression, ExpressionRenderContext context);
    private void RenderConstantPattern(IConstantPatternExpression expression, ExpressionRenderContext context);
    private void RenderTypePatternBase(ITypePatternExpressionBase expression, ExpressionRenderContext nestedContext);
    private void RenderTypePattern(ITypePatternExpression expression, ExpressionRenderContext context);
    private void RenderCaseTypePattern(ICaseTypePatternExpression expression, ExpressionRenderContext context);
    private void RenderCaseConstantPattern(ICaseConstantPatternExpression expression, ExpressionRenderContext context);
    private void RenderCasePredicate(ICasePatternExpression expression);
    private void RenderCheckCast(ICheckCastExpression expression, ExpressionRenderContext context);
    private void RenderTryCast(ITryCastExpression expression, ExpressionRenderContext context);
    private void RenderThrowExpression(IThrowExpression expression);
    private void RenderExpressionList(IExpressionList expressionList, ExpressionRenderContext context);
    private void RenderParameterModifier(IParameterModifierExpression expression, ExpressionRenderContext context);
    private void RenderNamedArgument(INamedArgumentExpression expression, ExpressionRenderContext context);
    private void RenderRefModifier(IRefModifierExpression expression, ExpressionRenderContext context);
    private void RenderRef(IRefExpression expression, ExpressionRenderContext context);
    private void RenderAddressOf(IAddressOfExpression expression, ExpressionRenderContext context);
    private void RenderPointerIndirection(IPointerIndirectionExpression expression, ExpressionRenderContext context);
    private void RenderDeref(IDerefExpression expression, ExpressionRenderContext context);
    private void RenderAwait(IAwaitExpression expression, ExpressionRenderContext context);
    private void RenderBox(IBoxExpression expression, ExpressionRenderContext context);
    private void RenderUnbox(IUnboxExpression expression, ExpressionRenderContext context);
    private void RenderConditional(IConditionalExpression expression, ExpressionRenderContext context);
    private void RenderArrayAccess(IArrayElementAccessExpression expression, ExpressionRenderContext context);
    private void RenderPointerElementAccess(IPointerElementAccessExpression expression, ExpressionRenderContext context);
    private void RenderPropertyAccess(IPropertyAccessExpression expression, ExpressionRenderContext context);
    private void RenderEventAccess(IEventAccessExpression expression, ExpressionRenderContext context);
    private void RenderFieldAccess(IFieldAccessExpression expression, ExpressionRenderContext context);
    private void RenderOverflowCheckExpression(IExpression expression, ExpressionRenderContext context, Action`1<ExpressionRenderContext> action);
    private void RenderBinaryOperation(IAbstractBinaryOperationExpression expression, ExpressionRenderContext context);
    private void RenderUnaryOperation(IAbstractUnaryOperationExpression expression, ExpressionRenderContext context);
    private void RenderTypeCast(IAbstractTypeCastExpression expression, ExpressionRenderContext context);
    private void RenderLiteral(ILiteralExpression literal, ExpressionRenderContext context);
    private void RenderConstant(Constant constant, ExpressionRenderContext context, LiteralFormat literalFormat, IMetadataField field);
    private void RenderFloatLiteral(float value, IMetadataField field);
    private void RenderDoubleLiteral(double value, IMetadataField field);
    private void RenderStringLiteral(string value);
    private void RenderCharLiteral(char value);
    private void RenderArgumentList(IExpression[] arguments, ExpressionRenderContext context, ArgumentListStyle style);
    public void RenderInitializerArgumentList(IExpression[] initializerArguments);
    private void RenderMethodCall(IMethodCallExpression expression, ExpressionRenderContext context);
    private void RenderLocalFunctionCall(ILocalFunctionCallExpression expression, ExpressionRenderContext context);
    private static IExpression UnwrapParameterModifier(IExpression expression);
    private void RenderMethodInstantiation(MethodInstantiation methodInstantiation, bool methodIsLocalFunction, int skipTypeParametersCount);
    private void RenderIndexerCall(IIndexerCallExpression expression, ExpressionRenderContext context);
    private void RenderObjectCreation(IObjectCreationExpression expression, ExpressionRenderContext context);
    private void RenderTupleCreation(ITupleCreationExpression expression, ExpressionRenderContext context);
    private void RenderTuple(ITupleExpression expression, ExpressionRenderContext context);
    private void RenderTupleComponentAccess(ITupleComponentAccessExpression expression, ExpressionRenderContext context);
    private void RenderDiscard(IDiscardExpression expression, ExpressionRenderContext context);
    private void RenderNestedInitializer(INestedInitializer initializer, ExpressionRenderContext context);
    private void RenderArrayCreation(IArrayCreationExpression expression, ExpressionRenderContext context);
    private void RenderDelegateCreation(IDelegateCreationExpression expression, ExpressionRenderContext context);
    private void RenderLocalFunctionDelegateCreation(ILocalFunctionDelegateCreationExpression expression, ExpressionRenderContext context);
    private IDisposable WithDelegateCreation(IDelegateCreationBaseExpression expression);
    private static int GetLocalFunctionParentTypeParametersCount(IMetadataMethod localFunction, IMetadataMethod localFunctionOwnerMethod);
    private IDisposable WithMethodMarker(IMetadataMethod method);
    private void RenderMethodTokenAndIlHeaderAndAttributes(IMetadataMethod method, bool isLocalOrAnonymousFunction);
    private void RenderAnonymousDelegate(IAnonymousMethodExpression expression);
    private void RenderLambdaExpression(ILambdaExpression expression, ExpressionRenderContext context);
    private void RenderLambdaBlockExpression(ILambdaBlockExpression expression);
    private void RenderAnonymousObjectCreation(IAnonymousObjectCreationExpression expression, ExpressionRenderContext context);
    private void RenderWith(IWithExpression expression, ExpressionRenderContext context);
    private void RenderVirtualMethodPointer(IVirtualMethodPointerExpression expression, ExpressionRenderContext context);
    private void RenderMethodPointer(IMethodPointerExpression expression);
    private void RenderFunctionPointerCallExpression(IFunctionPointerCallExpression expression, ExpressionRenderContext context);
    private void RenderCheckFinite(ICheckFiniteExpression expression, ExpressionRenderContext context);
    private void RenderDelegateCall(IDelegateCallExpression expression, ExpressionRenderContext context);
    private void RenderUntypedStackAlloc(IUntypedStackAllocExpression expression, ExpressionRenderContext context);
    private void RenderStackAlloc(IStackAllocExpression expression, ExpressionRenderContext context);
    private void RenderMemberInitializer(IMemberInitializer initializer, ExpressionRenderContext context);
    private void RenderMemberInitializerList(IMemberInitializerList initializerList, ExpressionRenderContext context);
    private void RenderIlInstruction(IExpression expression);
    public void RenderExpressionWithMarkers(IExpression expression);
    private void RenderExpressionInsideTextWithMarkers(string openingText, IExpression expression, string closingText);
    private void TryRenderSingleLine(Action`2<AstRenderer, ExpressionRenderContext> renderAction, ExpressionRenderContext context, int maxSingleLineLength);
    private bool CanBeRenderedInSingleLine(Action`2<AstRenderer, ExpressionRenderContext> renderAction, ExpressionRenderContext context, int maxSingleLineLength);
    public void RenderStatement(IStatement statement, bool isEmbedded);
    private void RenderIlInstructions(IStatement statement);
    private void RenderComment(ICommentStatement statement);
    private void RenderLock(ILockStatement statement);
    private void RenderUsing(IUsingStatement statement);
    private void RenderPin(IPinStatement statement);
    private void RenderUnpin(IUnpinStatement statement);
    private void RenderFixed(IFixedStatement statement);
    private void RenderTry(ITryStatement statement);
    private void RenderFilter(IBlockStatement filter);
    private void RenderGoto(IGotoStatement statement);
    private void RenderBreak(IBreakStatement statement);
    private void RenderContinue(IContinueStatement statement);
    private void RenderGotoCase(IGotoCaseStatement gotoCase);
    private void RenderGotoDefault(IGotoDefaultStatement statement);
    private void RenderLabelDeclaration(ILabelDeclarationStatement declaration);
    private void RenderEmptyStatement(bool isEmbedded);
    private void RenderExpressionStatement(IExpressionStatement expressionStatement, bool isEmbedded);
    private void RenderFor(IForStatement statement);
    private void RenderForEach(IForEachStatement statement);
    private void RenderDeclaration(IDeclarationExpression declaration);
    private void RenderLocalVariableDeclaration(ILocalVariableDeclarationStatement declaration, bool isEmbedded);
    private void RenderLocalVariableDeclaration(ILocalVariableReferenceExpression variableReference, LocalVariableDeclarationModifierKind modifierKind);
    private void RenderReturn(IReturnStatement statement);
    private void RenderEndFinally(IEndFinallyStatement statement);
    private static bool PreferBlockStatement(IStatement statement);
    private void RenderNestedStatement(IStatement statement);
    private void RenderBlockStatement(IBlockStatement block, BlockStatementRenderStyle style);
    private void RenderLoop(ILoopStatement statement);
    private void RenderIf(IIfStatement statement);
    private void RenderRethrow(IRethrowStatement statement);
    private void RenderThrow(IThrowStatement statement);
    private void RenderSwitch(ISwitchStatement statement);
    private void RenderSwitchHandler(IBlockStatement handler);
    private void RenderLocalFunction(ILocalFunction localFunction);
    private void RenderMemoryCopy(IMemoryCopyStatement statement);
    private void RenderMemoryInitialize(IMemoryInitializeStatement statement);
    private void RenderJump(IJumpStatement statement);
    private void RenderYieldReturn(IYieldReturnStatement statement);
    private void RenderYieldBreak(IYieldBreakStatement statement);
    private void RenderSuccessfulFiltering(ISuccessfulFilteringStatement statement);
    public bool TryRenderMethodBody(IDecompiledMethodBase method, bool onlyRenderAsExpressionBodied);
    public void TryRenderTopLevelEntryPoint(IDecompiledMethodBase method);
    public void TryRenderStatement(IStatement statement, bool isEmbedded);
    [CompilerGeneratedAttribute]
private void <RenderMethod>b__0_1(RenderConstraint constraint);
    [CompilerGeneratedAttribute]
private void <RenderCompactSignature>b__12_0(IMethodParameter p, ICodeTextWriter wr);
    [CompilerGeneratedAttribute]
private void <RenderMethodInstantiation>b__90_1(IMetadataType type, ICodeTextWriter wr);
}
public static class JetBrains.Decompiler.Render.CSharp.AttributeTargets : object {
    public static string Assembly;
    public static string Module;
    public static string ReturnValue;
    public static string Parameter;
    public static string Field;
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.Render.CSharp.CSharpCodeTextWriterEx : object {
    [ExtensionAttribute]
public static ICodeTextWriter AppendAccessRights(ICodeTextWriter writer, MemberAccessibility accessRights);
    [ExtensionAttribute]
internal static ICodeTextWriter AppendReturnType(ICodeTextWriter writer, IMetadataReturnValue returnValue, TypeRenderingParameters typeRenderingParameters);
    [ExtensionAttribute]
internal static ICodeTextWriter AppendReturnType(ICodeTextWriter writer, IMetadataType returnType, IMetadataEntity owner, TypeRenderingParameters typeRenderingParameters);
    [ExtensionAttribute]
public static ICodeTextWriter AppendElementTypeNamePrefix(ICodeTextWriter writer, IMetadataType elementType, TypeRenderingParameters typeRenderingParameters);
    [ExtensionAttribute]
public static ICodeTextWriter AppendElementTypeNameSuffix(ICodeTextWriter writer, IMetadataType elementType);
    [ExtensionAttribute]
private static IDisposable WithSequencePointMarkers(ICodeTextWriter writer, IInstructionReference instructionReference);
    [ExtensionAttribute]
public static IDisposable WithSequencePointMarkersFromFirstInstruction(ICodeTextWriter writer, INode node);
    [ExtensionAttribute]
public static void WriteTextWithMarkersAndAppendNewLine(ICodeTextWriter writer, string text, INode node);
}
internal enum JetBrains.Decompiler.Render.CSharp.ExpressionPrecedence : Enum {
    public int value__;
    public static ExpressionPrecedence Highest;
    public static ExpressionPrecedence Primary;
    public static ExpressionPrecedence Unary;
    public static ExpressionPrecedence TypeConversion;
    public static ExpressionPrecedence Range;
    public static ExpressionPrecedence Switch;
    public static ExpressionPrecedence With;
    public static ExpressionPrecedence Multiplicative;
    public static ExpressionPrecedence Additive;
    public static ExpressionPrecedence Shift;
    public static ExpressionPrecedence RelationalAndTypeTesting;
    public static ExpressionPrecedence Equality;
    public static ExpressionPrecedence LogicalAnd;
    public static ExpressionPrecedence LogicalXor;
    public static ExpressionPrecedence LogicalOr;
    public static ExpressionPrecedence ConditionalAnd;
    public static ExpressionPrecedence ConditionalOr;
    public static ExpressionPrecedence NullCoalescing;
    public static ExpressionPrecedence Conditional;
    public static ExpressionPrecedence Assignment;
    public static ExpressionPrecedence Lambda;
    public static ExpressionPrecedence Lowest;
}
internal class JetBrains.Decompiler.Render.CSharp.ExpressionRenderContext : object {
    public static ExpressionRenderContext Root;
    [CompilerGeneratedAttribute]
private IExpression <ParentExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionRenderContext <ParentContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OverflowCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SingleLineRendering>k__BackingField;
    public IExpression ParentExpression { get; }
    public ExpressionRenderContext ParentContext { get; }
    public bool OverflowCheck { get; }
    public bool SingleLineRendering { get; }
    public ExpressionRenderContext(ExpressionRenderContext parentContext, IExpression parentExpression);
    public ExpressionRenderContext(ExpressionRenderContext parentContext, IExpression parentExpression, OverflowCheckType overflowCheck);
    public ExpressionRenderContext(ExpressionRenderContext baseContext, bool singleLineRendering);
    private static ExpressionRenderContext();
    [CompilerGeneratedAttribute]
public IExpression get_ParentExpression();
    [CompilerGeneratedAttribute]
public ExpressionRenderContext get_ParentContext();
    [CompilerGeneratedAttribute]
public bool get_OverflowCheck();
    [CompilerGeneratedAttribute]
public bool get_SingleLineRendering();
}
internal static class JetBrains.Decompiler.Render.CSharp.ExpressionUtil : object {
    public static ExpressionPrecedence GetPrecedence(IExpression expression, ExpressionRenderContext context);
    public static OperatorAssociativity GetAssociativity(IExpression expression);
}
[ExtensionAttribute]
public static class JetBrains.Decompiler.Render.CSharp.IdentifierUtil : object {
    public static HashSet`1<string> Keywords;
    private static IdentifierUtil();
    [ExtensionAttribute]
public static bool IsIdentifierStartCharacter(char c);
    [ExtensionAttribute]
public static bool IsIdentifierPartCharacter(char c);
    [ExtensionAttribute]
public static bool IsValidIdentifier(string id);
    [ExtensionAttribute]
public static bool IsKeyword(string id);
    [ExtensionAttribute]
public static string FixIdentifier(string id, bool replaceInvalidCharactersInIdentifiers);
    [ExtensionAttribute]
private static string ToVerbatim(string id);
    public static IIdentifierFixer GetIdentifierFixer(bool replaceInvalidCharactersInIdentifiers);
    private static string GetUnicodeEscapeSequence(char ch);
    [ExtensionAttribute]
private static bool IsLetterCharacter(char c);
    [ExtensionAttribute]
private static bool IsCombiningCharacter(char c);
    [ExtensionAttribute]
private static bool IsDecimalDigitCharacter(char c);
    [ExtensionAttribute]
private static bool IsConnectingCharacter(char c);
    [ExtensionAttribute]
private static bool IsFormattingCharacter(char c);
}
public enum JetBrains.Decompiler.Render.CSharp.LiteralFormat : Enum {
    public int value__;
    public static LiteralFormat Default;
    public static LiteralFormat Decimal;
    public static LiteralFormat Hexadecimal;
    public static LiteralFormat Binary;
}
public static class JetBrains.Decompiler.Render.CSharp.LiteralUtil : object {
    public static string PresentIntegerLiteral(long i, int bytes, LiteralFormat literalFormat);
    public static string PresentIntegerLiteral(ulong i, int bytes, LiteralFormat literalFormat);
}
public class JetBrains.Decompiler.Render.CSharp.MetadataRenderer : object {
    private HashSet`1<string> myExcludedAttributes;
    private static JetHashSet`1<string> ourSkipAttributes;
    private static Dictionary`2<string, string> ourBinaryOperatorsMap;
    private static Dictionary`2<string, string> ourUnaryOperatorsMap;
    private static HashSet`1<string> ourCheckedSignOperators;
    private int myBlockCommentNestingLevel;
    private IMetadataAssembly myAssembly;
    private ClassDecompiler myDecompiler;
    private ICodeTextWriter myWriter;
    private DecompiledClassCache myDecompiledClassCache;
    private Dictionary`2<IMetadataTypeInfo, bool> myNullableAnnotationContext;
    private bool myModuleHasNullablePublicOnlyAttribute;
    private bool myIncludesInternals;
    protected bool myNullableEnabled;
    private bool myNullableAnnotationsExist;
    private bool mySkipNullableAnnotations;
    private ClassDecompilerOptions myOptions;
    private Func`1<bool> myTerminationCheck;
    private MetadataTypeCache myTypeCache;
    private AstRenderer myAstRenderer;
    public static int SingleLineDeclarationLength;
    private static int SingleLineParameterLength;
    [CompilerGeneratedAttribute]
private FormatterOptions <FormatterOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DecodeTuples>k__BackingField;
    public static string ClassKeyword;
    public static string StructKeyword;
    public static string InterfaceKeyword;
    private static int FieldPriorityShift;
    private static int MethodPriorityShift;
    private static int TypePriorityShift;
    [NotNullAttribute]
public FormatterOptions FormatterOptions { get; }
    [NotNullAttribute]
internal ClassDecompilerOptions ClassDecompilerOptions { get; }
    private bool DecodeTuples { get; }
    public bool RenderNullableAnnotations { get; }
    protected int MaxSingleLineTypeConstraints { get; }
    protected bool ForceSingleLineRendering { get; }
    public MetadataRenderer(Lifetime lifetime, IMetadataAssembly assembly, ICodeTextWriter writer, DecompiledClassCache decompiledClassCache, FormatterOptions formatterOptions, ClassDecompilerOptions options, Func`1<bool> terminationCheck);
    private static MetadataRenderer();
    public void RenderAssemblyInfo(bool forProject);
    private void WriteComments();
    private void WriteAssemblyAttributes(bool extraFilter);
    private IMetadataCustomAttribute[] ExtraFilterCustomAttributes(IMetadataCustomAttribute[] attributes, bool filter);
    private void WriteModuleAttributes();
    private static IMetadataSecurityAttribute[] GetSecurityAttributes(IMetadataEntity entity);
    private void RenderAttributesPerLine(IEnumerable`1<T> attributes, string target, bool commented, Action`1<T> renderAttribute);
    internal void RenderAttributes(IMetadataEntity entity, AttributesPlacement attributesPlacement, string target, bool isLocalOrAnonymousFunction, string localFunctionName);
    internal bool HasAttributes(IMetadataEntity entity, bool isLocalOrAnonymousFunction);
    private void RenderAttributes(IMetadataCustomAttribute[] customAttributes, ICompilerSpecificAttribute[] compilerSpecificAttributes, IMetadataSecurityAttribute[] securityAttributes, AttributesPlacement attributesPlacement, string target);
    private void RenderAttribute(IMetadataSecurityAttribute attr);
    private void RenderAttributeTarget(string target);
    private void RenderAttribute(IMetadataCustomAttribute attr);
    private void RenderAttribute(ICompilerSpecificAttribute attr);
    private void RenderAttributeValue(MetadataAttributeValue value);
    private IMetadataCustomAttribute[] FilterCustomAttributes(IMetadataEntity owner, bool fieldTargeted, bool isLocalOrAnonymousFunction);
    private ICompilerSpecificAttribute[] FilterCompilerSpecificAttributes(IMetadataEntity owner, string localFunctionName);
    private IMetadataTypeInfo GetTypeInfoFromFqn(string typeFqn);
    private bool IsConversionOperator(IMetadataMethod method);
    private bool IsSignOperator(IMetadataMethod method);
    private bool IsRegularMethod(IMetadataMethod method);
    private IDisposable WithNamespace(string qualifiedName);
    private IDisposable WithBraces();
    internal IDisposable WithMethodMarker(IMetadataMethod method);
    private IDisposable WithTypeMemberMarker(IMetadataTypeMember typeMember);
    private IDisposable WithIncreaseNestingLevel();
    private IDisposable WithPseudoBlockComment();
    private IDisposable WithBlockComment();
    private IMetadataTypeInfo GetCorlibType(string fqn);
    [CompilerGeneratedAttribute]
public FormatterOptions get_FormatterOptions();
    internal ClassDecompilerOptions get_ClassDecompilerOptions();
    [CompilerGeneratedAttribute]
private bool get_DecodeTuples();
    public sealed virtual bool get_RenderNullableAnnotations();
    public sealed virtual void SetNullableAnnotationContext(bool nullableEnabled, bool forceWriteDirective);
    public sealed virtual IDisposable SkipNullableAnnotations();
    private void SwitchNullableAnnotationContextIfNeeded(IMetadataTypeMember typeMember);
    private static bool HasSimpleSignature(IMetadataTypeMember typeMember);
    private static bool IsSimple(IMetadataType type);
    public TypeRenderingParameters GetTypeRenderingParameters(IMetadataEntity metadataEntity, bool skipFirstNullableAnnotation, bool specialRenderer, bool checkNullablePublicOnlyAttribute, bool treatTypeAsAttribute);
    private IDecompiledClass DecompileClass(IMetadataTypeInfo type, IProgressIndicator indicator);
    private static IEnumerable`1<EnumMemberDescription> GetSortedEnumMembers(IMetadataTypeInfo declaredEnum);
    private static bool NeedToWriteEnumMemberValues(IMetadataTypeInfo declaredEnum);
    private void RenderEnumHeader(IMetadataTypeInfo enum);
    private void RenderFlagsEnum(IMetadataTypeInfo enum);
    private void RenderConstant(object value, LiteralFormat literalFormat);
    private void RenderOrdinalEnum(IMetadataTypeInfo enum);
    private void RenderCommentedHexadecimalPresentation(EnumMemberDescription member, bool checkSmallValues);
    private static EnumMemberDescription[] GetEnumMembers(IMetadataTypeInfo typeInfo);
    private void RenderIlCodeCommentIfNeeded(IDecompiledMethodBase method, bool needNewLineAfter);
    private void RenderHeader(Action`1<IlMetadataFormatter> renderMemberHeader, IMetadataTypeMember member, string memberType);
    private static void LogException(IMetadataTypeMember metadataMethod, Exception e);
    private void RenderTokenIfNeeded(IMetadataTypeMember member, string memberType, bool inline);
    private void RenderTokenInlineIfNeeded(IMetadataEntity entity, string entityType);
    private void RenderTypeTokenAndIlHeaderIfNeeded(IMetadataTypeInfo typeInfo);
    internal void RenderMethodTokenAndIlHeaderIfNeeded(IMetadataMethod method, bool inlineToken);
    private void RenderFieldTokenAndIlHeaderIfNeeded(IMetadataField field);
    private void RenderPropertyTokenAndIlHeaderIfNeeded(IMetadataProperty property);
    private void RenderEventTokenAndIlHeaderIfNeeded(IMetadataEvent event);
    private void RenderCustomAttributeTokenIfNeeded(IMetadataCustomAttribute attr);
    private void RenderParameterTokenIfNeeded(IMetadataParameter parameter);
    private void RenderTypeParameterTokenIfNeeded(IMetadataTypeParameter typeParameter);
    private void RenderDeclsecurityTokensIfNeeded(IMetadataEntity entity);
    public void RenderTopLevelType(IMetadataTypeInfo typeInfo, IProgressIndicator indicator, bool addPartialModifier);
    private void RenderXmlDoc(IMetadataEntity entity);
    private void RenderType(IMetadataTypeInfo typeInfo, IProgressIndicator indicator, bool addPartialModifier);
    private void RenderDelegate(IMetadataTypeInfo delegate);
    private void RenderAccessRights(IMetadataTypeMember accessRightsOwner);
    private void RenderClassLike(string kind, IMetadataTypeInfo typeInfo, bool isPartial, IProgressIndicator indicator);
    private void CheckUnsafe(IDecompiledClass decompiledClass);
    private void RenderClassLikeModifiers(IMetadataTypeInfo typeInfo, bool isPartial);
    public static void RenderClassLikeKind(ICodeTextWriter writer, string kind, bool isRecord);
    private void RenderInheritors(IMetadataTypeInfo typeInfo, bool isRecord, IConstructorInitializer primaryConstructorInitializer, Boolean& multiline);
    private void RenderTypeConstraints(IMetadataTypeParameter[] typeParameters, Boolean& multilineHeader);
    protected virtual int get_MaxSingleLineTypeConstraints();
    private void RenderTypeParameters(IMetadataTypeParameter[] typeParameters);
    protected void SetTopLevelNullableAnnotationContext(IMetadataTypeInfo typeInfo);
    protected virtual void SetTopLevelNullableAnnotationContext(bool nullableEnabled);
    private void TryRenderType(IMetadataTypeInfo typeInfo, IProgressIndicator indicator, bool addPartialModifier);
    private void TryRenderMethod(IDecompiledMethod decompiledMethod);
    private void TryRenderConstructor(IDecompiledMethod decompiledMethod);
    private void TryRenderDestructor(IDecompiledMethod decompiledMethod);
    private void TryRenderConversionOperator(IDecompiledMethod decompiledMethod);
    private void TryRenderSignOperator(IDecompiledMethod decompiledMethod);
    private void TryRenderField(IDecompiledField decompiledField);
    private void TryRenderProperty(IDecompiledProperty decompiledProperty);
    private void TryRenderEvent(IDecompiledEvent decompiledEvent);
    private void ProcessException(Exception e, string memberType, IDecompiledMethod method);
    private void ProcessException(Exception e, string memberType, IDecompiledClassMember member, IMetadataTypeMember metadataTypeMember);
    private static string GetErrorMessage(string memberType, IDecompiledClassMember member, IMetadataTypeMember metadataTypeMember, IList`1& sensitiveData);
    public bool RenderMethod(IMetadataMethod method, IProgressIndicator pi);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Render.CSharp.MetadataRenderer/<GetAllDecompiledMethods>d__127")]
private static IEnumerable`1<IDecompiledMethod> GetAllDecompiledMethods(IDecompiledClass decompiledClass);
    private void RenderTypeMembers(IDecompiledClass decompiledClass, IProgressIndicator indicator);
    private static void UpdatePriority(Int32& priority, IMetadataMethod metadataMethod);
    private static int GetPropertyPriority(IDecompiledProperty property);
    private static int GetEventPriority(IDecompiledEvent event);
    private static int GetFieldPriority(IDecompiledField field);
    private static int GetMethodPriority(IDecompiledMethodBase method);
    private static int GetMethodPriority(IMetadataMethod method);
    private static int GetTypePriority(IMetadataTypeInfo type);
    private static bool IsField(int priority);
    private static Pair`2[] Apply(IEnumerable`1<T> items, Action`1<T> action, Func`2<T, int> getPriority);
    private void RenderConversionOperator(IDecompiledMethod decompiledMethod);
    private void RenderDestructor(IDecompiledMethod decompiledMethod);
    private void RenderConstructor(IDecompiledMethod decompiledMethod);
    private static string GetExplicitImplementationPrefix(IMetadataInterfaceImplementation explicitInterface);
    private void RenderMethodName(string methodName, IMetadataInterfaceImplementation explicitInterface, IMetadataMethod method);
    private string GetShortNameAndRenderQualification(string name, IMetadataInterfaceImplementation explicitInterface);
    private void RenderExplicitInterfaceQualification(IMetadataInterfaceImplementation explicitInterface);
    public void RenderTopLevelEntryPoint(IDecompiledMethod decompiledMethod);
    public void RenderMethod(IDecompiledMethodBase decompiledMethod, bool isLocalFunction);
    protected virtual void RenderMethodAccessRights(IMetadataMethod method, bool isExplicitImplementation, bool isLocalFunction);
    protected virtual void RenderMethodModifiers(IMetadataMethod method, bool isStatic, bool isExplicitImplementation, bool isLocalFunction);
    public void RenderMethod(IDecompiledMethodBase decompiledMethod, IMetadataInterfaceImplementation explicitInterface);
    private static bool HasBody(IDecompiledMethodBase decompiledMethod);
    private bool RenderMethodBody(IDecompiledMethodBase decompiledMethod, bool needNewLineBefore, bool needNewLineAfter, bool renderIlCodeComment, bool onlyRenderAsExpressionBodied);
    private void RenderModifiers(IMetadataTypeMember typeMember, bool isStatic, bool isExplicitImplementation, bool isAutoProperty);
    private static bool IsReadOnly(IMetadataTypeMember typeMember);
    private void RenderNewModifierIfNeeded(IMetadataTypeMember typeMember);
    private void RenderExternModifierIfNeeded(IMetadataMethod method);
    private void RenderExternModifierIfNeeded(IDecompiledMethod m1, IDecompiledMethod m2);
    private void RenderExternModifierIfNeeded(IDecompiledEvent decompiledEvent);
    private void RenderExternModifierIfNeeded(IDecompiledProperty decompiledProperty);
    [CanBeNullAttribute]
private static string GetOperatorSign(IMetadataMethod signOperator);
    private static bool IsCheckedSignOperator(IMetadataMethod signOperator);
    [CanBeNullAttribute]
private static string GetConversionOperator(IMetadataMethod conversionOperator, Boolean& isChecked);
    private static string GetOperatorName(IMetadataMethod operator);
    private void RenderSignOperator(IDecompiledMethod decompiledMethod);
    private void RenderParameters(IMetadataMethod metadataMethod, IDecompiledMethodBase decompiledMethod, bool isVarArg, Boolean& onSingleLine);
    private void RenderParameters(IList`1<IMetadataParameter> metadataParameters, IList`1<IMethodParameter> functionParameters, bool isVarArg, Nullable`1<int> nonHiddenParametersCount, Boolean& onSingleLine);
    public static void RenderParameters(ICodeTextWriter writer, IList`1<TParameter> parameters, Action`2<ITextAndDebugDataWriter, TParameter> renderParameterForLengthEstimation, Action`1<TParameter> renderParameter, Boolean& onSingleLine, bool forceSingleLineRendering);
    protected virtual bool get_ForceSingleLineRendering();
    private static string GetParameterName(IMetadataParameter parameter, IMethodParameter functionParameter);
    private void RenderMetadataParameter(IMetadataParameter parameter);
    private void RenderFunctionParameter(IMethodParameter functionParameter);
    private IMetadataType RenderParameterKindTypeName(ICodeTextWriter writer, IMetadataParameter parameter, IMethodParameter functionParameter);
    internal void RenderParameterTokenAndAttributes(IMetadataParameter parameter);
    private void RenderParameter(IMetadataParameter parameter, IMethodParameter functionParameter);
    internal void RenderDefaultParameterValue(IMetadataParameter parameter, IMetadataType parameterType);
    private static string GetAccessorName(IMetadataEntity owner, IMetadataMethod accessor);
    private void RenderAccessor(IMetadataTypeMember owner, IDecompiledMethod decompiledMethod, bool renderAccessRights, bool inline, bool writeMethodMarkersTokenIlHeaderIlCode);
    private static bool NeedToRenderLastParameterAttribute(IMetadataMethod accessor, IMetadataTypeMember owner);
    private void RenderProperty(IDecompiledProperty decompiledProperty);
    private static IList`1<IMethodParameter> GetPropertyParameters(IDecompiledProperty property);
    private static void Sort(IDecompiledMethod& m1, IDecompiledMethod& m2);
    private void RenderEvent(IDecompiledEvent decompiledEvent);
    private void RenderEventModifiers(IMetadataEvent evt, bool isExplicitImplementation);
    private bool RenderFixedBufferFieldPart(IMetadataField field);
    private void RenderField(IDecompiledField decompiledField);
    private void RenderAttributeTypeRef(IMetadataTypeInfo type);
    private void RenderAttributeTypeRef(IMetadataType type);
    private void RenderFieldModifiers(IMetadataField field);
    private static IMetadataMethod GetAnyAccessor(IMetadataProperty property);
    private static IMetadataMethod GetAnyAccessor(IMetadataEvent evt);
    private void RenderPropertyModifiers(IMetadataProperty property, bool isExplicitImplementation, bool isAuto);
    private void RenderUnsafeModifierIfNeeded(IDecompiledMethodBase decompiledMethod);
    private void RenderUnsafeModifierIfNeeded(IDecompiledField decompiledField);
    private void RenderUnsafeModifierIfNeeded(IDecompiledProperty decompiledProperty);
    private void RenderUnsafeModifierIfNeeded(IDecompiledEvent decompiledEvent);
    private void RenderUnsafeModifierIf(bool condition);
    [CompilerGeneratedAttribute]
internal static bool <IsConversionOperator>g__IsConversionOperatorName|24_0(string name);
    [CompilerGeneratedAttribute]
private void <WithIncreaseNestingLevel>b__32_0();
    [CompilerGeneratedAttribute]
private void <WithIncreaseNestingLevel>b__32_1();
    [CompilerGeneratedAttribute]
private void <WithPseudoBlockComment>b__33_0();
    [CompilerGeneratedAttribute]
private void <WithPseudoBlockComment>b__33_1();
    [CompilerGeneratedAttribute]
private IDisposable <WithBlockComment>b__34_0();
    [CompilerGeneratedAttribute]
private void <SkipNullableAnnotations>b__64_0();
    [CompilerGeneratedAttribute]
private void <RenderTypeConstraints>b__108_4();
    [CompilerGeneratedAttribute]
private void <RenderTypeConstraints>b__108_6();
    [CompilerGeneratedAttribute]
private void <RenderTypeConstraints>b__108_0();
    [CompilerGeneratedAttribute]
private void <RenderTypeConstraints>b__108_1();
    [CompilerGeneratedAttribute]
private void <RenderTypeConstraints>b__108_2();
    [CompilerGeneratedAttribute]
private void <RenderTypeConstraints>b__108_3();
    [CompilerGeneratedAttribute]
private void <RenderTypeParameters>b__111_0(IMetadataTypeParameter p);
    [CompilerGeneratedAttribute]
private void <RenderParameters>b__168_0(ITextAndDebugDataWriter w, IMethodParameter p);
    [CompilerGeneratedAttribute]
private void <RenderParameters>b__168_1(ITextAndDebugDataWriter w, IMetadataParameter p);
}
internal enum JetBrains.Decompiler.Render.CSharp.OperatorAssociativity : Enum {
    public int value__;
    public static OperatorAssociativity Undefined;
    public static OperatorAssociativity Left;
    public static OperatorAssociativity Right;
}
public static class JetBrains.Decompiler.Render.CSharp.ParameterUtil : object {
    private static string ValueKeyword;
    private static ParameterUtil();
    public static IDisposable FixImplicitParameterName(IDecompiledMethod methodWithImplicitParameter);
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.Render.CSharp.RenderEx : object {
    private static Dictionary`2<OperationType, OperationEntry> OperationTypeToEntry;
    private static RenderEx();
    [ExtensionAttribute]
public static string ToCSharpToken(MemberAccessKind accessKind);
    [ExtensionAttribute]
public static string ToCSharpModifier(ParameterModifierKind kind);
    [ExtensionAttribute]
public static string ToCSharpOperator(OperationType operationType);
    [ExtensionAttribute]
public static ExpressionPrecedence ToPrecedence(OperationType operationType);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetContainingMethodTypeAssemblyInfo(INode node);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetContainingTypeAndAssemblyInfo(IDecompiledClassMember member);
    [ExtensionAttribute]
public static string GetTypeAndAssemblyInfo(IMetadataTypeInfo typeInfo);
}
public class JetBrains.Decompiler.Render.EndMethodCodeMarker : EndTypeMemberMarker {
}
internal static class JetBrains.Decompiler.SnippetUtil : object {
    public static void ImportSnippet(IDecompiledMethodBase snippetMethod, IDecompiledMethodBase containerMethod, MethodDecompilerContext snippedContext, MethodDecompilerContext containerContext, ILocalVariableDeclarationScope containerDeclarationScope);
}
internal class JetBrains.Decompiler.Transformations.AnonymousTypes.ExtractAnonymousObjectCreationTransformation : NodeTransformationBase`1<IObjectCreationExpression> {
    private MethodDecompiler myMethodDecompiler;
    public ExtractAnonymousObjectCreationTransformation(MethodDecompilerContext decompilerContext);
    protected virtual bool DoApply(IObjectCreationExpression objectCreation);
}
internal class JetBrains.Decompiler.Transformations.Arithmetic.ConvertRightShiftToUnsignedRightShiftTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    public ConvertRightShiftToUnsignedRightShiftTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IBinaryOperationExpression binaryOperation);
}
internal class JetBrains.Decompiler.Transformations.Arithmetic.EliminateShiftMaskTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    public EliminateShiftMaskTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IBinaryOperationExpression binaryOperation);
    private static int ToShiftMask(ElementType elementType);
}
internal class JetBrains.Decompiler.Transformations.Arithmetic.ReducePlusMinusTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    protected virtual bool DoApply(IBinaryOperationExpression node);
    private static bool DoApply(IBinaryOperationExpression binaryOperation, IExpression leftArgument, IExpression rightArgument);
    private static Constant MakeValuePositive(Constant value);
}
internal class JetBrains.Decompiler.Transformations.Arithmetic.ReduceSubtractFromZeroTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    public ReduceSubtractFromZeroTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IBinaryOperationExpression binaryOperation);
}
internal class JetBrains.Decompiler.Transformations.Arrays.EliminateArrayAccessTypeCastTransformation : EliminateArrayTypeCastTransformationBase`1<IArrayElementAccessExpression> {
    public EliminateArrayAccessTypeCastTransformation(MetadataTypeCache typeCache);
    protected virtual bool DoApply(IArrayElementAccessExpression arrayElementAccess);
}
internal class JetBrains.Decompiler.Transformations.Arrays.EliminateArrayAddressDerefTransformation : NodeTransformationBase`1<IDerefExpression> {
    protected virtual bool DoApply(IDerefExpression derefExpression);
}
internal class JetBrains.Decompiler.Transformations.Arrays.EliminateArrayDimensionTypeCastTransformation : EliminateArrayTypeCastTransformationBase`1<IArrayCreationExpression> {
    public EliminateArrayDimensionTypeCastTransformation(MetadataTypeCache typeCache);
    protected virtual bool DoApply(IArrayCreationExpression arrayCreation);
}
internal abstract class JetBrains.Decompiler.Transformations.Arrays.EliminateArrayTypeCastTransformationBase`1 : NodeTransformationBase`1<T> {
    private MetadataTypeCache myTypeCache;
    protected EliminateArrayTypeCastTransformationBase`1(MetadataTypeCache typeCache);
    protected bool Reduce(IExpression[] expressions);
}
internal class JetBrains.Decompiler.Transformations.Arrays.ExtractArrayAssignmentInitializerTransformation : NodeTransformationBase`1<IArrayCreationExpression> {
    private static int MaxInitializerItems;
    private static double MaxDefaultItemFraction;
    private static int MaxDefaultItemsWithoutFractionCheck;
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myFinder;
    private IImageBodyReader myImageBodyReader;
    public ExtractArrayAssignmentInitializerTransformation(MetadataTypeCache typeCache, ReferencesFinder finder, IImageBodyReader imageBodyReader);
    protected virtual bool DoApply(IArrayCreationExpression arrayCreation);
    private bool TryExtractLiteralInitializerFromInlinedArrayInitialization(IArrayCreationExpression arrayCreation, Int32[] dimensions);
    private static int GetTailNullsCount(IExpressionList initializer);
    [CanBeNullAttribute]
public static Byte[] GetLiteralInitializerData(MetadataTypeCache typeCache, ReferencesFinder finder, IImageBodyReader imageBodyReader, ILocalVariable arrayVariable, IStatement& currentStatement, IExpressionStatement& handleAssignmentStatement, IExpressionStatement& initStatement);
    private bool ExtractLiteralInitializer(IArrayCreationExpression arrayCreation, ILocalVariable arrayVariable, Int32[] dimensions, IStatement& currentStatement);
    private static void AddLiteralInitializer(IArrayCreationExpression arrayCreation, Int32[] dimensions, Byte[] data);
    private static bool ExtractAssignmentInitializers(IArrayCreationExpression arrayCreation, ILocalVariable arrayVariable, Int32[] dimensions, IStatement& currentStatement);
    private static bool IsInsideInitializersSection(IExpression expression);
    private bool ExtractAssignmentAfterLiteralInitializers(IArrayCreationExpression arrayCreation, ILocalVariable arrayVariable, Int32[] startIndexes, IStatement& currentStatement);
    private static Int32[] CreateStartIndexes(Int32[] dimensions);
    private static bool NextIndexes(Int32[] indexes, Int32[] dimensions);
    private static bool IsGreaterOrEqual(Int32[] x, Int32[] y);
    private static bool IsValidInitializerItem(IExpression item, ILocalVariable arrayVariable);
    private static Int32[] GetIndexes(IArrayElementAccessExpression arrayElementAccess);
    private static void SetInitializer(IArrayCreationExpression arrayCreation, Int32[] indexes, IExpression value);
    private static IExpression GetInitializerItem(ILocalVariable arrayVariable, IStatement currentStatement, Boolean& isValidInitializerItem, Int32[]& currentIndexes, InitializerExtractionMode mode);
    private static IExpression GetDefaultInitializerItem(IMetadataType type, IInstructionReference instructionReference);
    private static IExpression CreateAssignmentInitializer(List`1<IExpression> items, Int32[] dimensions, int currentRank, Int32& currentItemIndex, IInstructionReference instructionReference);
    private static Int32[] GetDimensions(IArrayCreationExpression arrayCreation);
}
internal class JetBrains.Decompiler.Transformations.Assignment.ExtractArrayCompoundAssignmentTransformation : ExtractArrayCompoundAssignmentTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    public ExtractArrayCompoundAssignmentTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool IsValidLhsTypeCast(ITypeCastExpression lhsTypeCast, IArrayElementAccessExpression arrayLoad);
    protected virtual IBinaryOperationExpression CreateBinaryOperation(IBinaryOperationExpression baseBinaryOperation, OperationType operationType, IExpression leftArgument, IExpression rightArgument);
}
internal abstract class JetBrains.Decompiler.Transformations.Assignment.ExtractArrayCompoundAssignmentTransformationBase`1 : CondNodeTransformationBase`1<IBinaryOperationExpression> {
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myFinder;
    protected ExtractArrayCompoundAssignmentTransformationBase`1(MethodDecompilerContext methodDecompilerContext, bool isEnabled);
    protected virtual bool DoApply(IBinaryOperationExpression outerAssignment);
    protected abstract virtual bool IsValidLhsTypeCast(ITypeCastExpression lhsTypeCast, IArrayElementAccessExpression arrayLoad);
    protected abstract virtual TBinaryOperationExpression CreateBinaryOperation(TBinaryOperationExpression baseBinaryOperation, OperationType operationType, IExpression leftArgument, IExpression rightArgument);
}
internal class JetBrains.Decompiler.Transformations.Assignment.ExtractArrayPostfixExpressionTransformation : ExtractArrayPostfixExpressionTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    public ExtractArrayPostfixExpressionTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual IBinaryOperationExpression ExtractTempAssignment(IBinaryOperationExpression operation);
    protected virtual bool CheckOperation(IBinaryOperationExpression operation);
    protected virtual bool ToPostfixOperationType(IBinaryOperationExpression operation, OperationType& operationType);
    protected virtual IExpression WrapUnary(IExpression expression, OperationType operationType, IBinaryOperationExpression operation);
}
internal abstract class JetBrains.Decompiler.Transformations.Assignment.ExtractArrayPostfixExpressionTransformationBase`1 : CondNodeTransformationBase`1<IExpressionStatement> {
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myFinder;
    protected ExtractArrayPostfixExpressionTransformationBase`1(MethodDecompilerContext methodDecompilerContext, bool isEnabled);
    protected virtual bool DoApply(IExpressionStatement outerAssignmentStatement);
    [CanBeNullAttribute]
protected abstract virtual IBinaryOperationExpression ExtractTempAssignment(TExpression operation);
    protected abstract virtual bool CheckOperation(TExpression operation);
    protected abstract virtual bool ToPostfixOperationType(TExpression operation, OperationType& operationType);
    protected abstract virtual IExpression WrapUnary(IExpression expression, OperationType operationType, TExpression operation);
}
internal class JetBrains.Decompiler.Transformations.Assignment.ExtractArrayPrefixTransformation : ExtractArrayPrefixTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    public ExtractArrayPrefixTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual IArrayElementAccessExpression ExtractArrayLoad(IBinaryOperationExpression operation);
    protected virtual bool CheckOperation(IBinaryOperationExpression operation);
    protected virtual bool ToPrefixOperationType(IBinaryOperationExpression operation, OperationType& operationType);
    protected virtual IExpression WrapUnary(IExpression expression, OperationType operationType, IBinaryOperationExpression operation);
}
internal abstract class JetBrains.Decompiler.Transformations.Assignment.ExtractArrayPrefixTransformationBase`1 : CondNodeTransformationBase`1<IBinaryOperationExpression> {
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myFinder;
    protected ExtractArrayPrefixTransformationBase`1(MethodDecompilerContext methodDecompilerContext, bool isEnabled);
    protected virtual bool DoApply(IBinaryOperationExpression outerAssignment);
    [CanBeNullAttribute]
protected abstract virtual IArrayElementAccessExpression ExtractArrayLoad(TExpression operation);
    protected abstract virtual bool CheckOperation(TExpression operation);
    protected abstract virtual bool ToPrefixOperationType(TExpression operation, OperationType& operationType);
    protected abstract virtual IExpression WrapUnary(IExpression expression, OperationType operationType, TExpression operation);
}
internal class JetBrains.Decompiler.Transformations.Assignment.ExtractCopyingCompoundAssignmentExpressionTransformation : ExtractCopyingCompoundAssignmentExpressionTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    public ExtractCopyingCompoundAssignmentExpressionTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool GetValidLhsAndEquivalentTypes(IExpression storeExpression, IMetadataType& lhsType, IMetadataType& equivalentType);
    protected virtual IMetadataType GetRhsType(IMetadataType lhsType, OperationType operationType);
    protected virtual IExpression CreateBinaryOperation(OperationType operationType, IBinaryOperationExpression baseBinaryOperation, IExpression leftArgument, IExpression rightArgument, OverflowCheckType overflowCheck, IMetadataType type);
}
internal abstract class JetBrains.Decompiler.Transformations.Assignment.ExtractCopyingCompoundAssignmentExpressionTransformationBase`1 : CondNodeTransformationBase`1<IExpressionStatement> {
    private ReferencesFinder myFinder;
    protected ExtractCopyingCompoundAssignmentExpressionTransformationBase`1(MethodDecompilerContext methodDecompilerContext, bool isEnabled);
    protected virtual bool DoApply(IExpressionStatement targetCopyAssignmentStatement);
    protected abstract virtual bool GetValidLhsAndEquivalentTypes(IExpression storeExpression, IMetadataType& lhsType, IMetadataType& equivalentType);
    [CanBeNullAttribute]
protected abstract virtual IMetadataType GetRhsType(IMetadataType lhsType, OperationType operationType);
    protected abstract virtual IExpression CreateBinaryOperation(OperationType operationType, TBinaryOperationExpression baseBinaryOperation, IExpression leftArgument, IExpression rightArgument, OverflowCheckType overflowCheck, IMetadataType type);
}
internal class JetBrains.Decompiler.Transformations.Assignment.ExtractCopyingCompoundAssignmentStatementTransformation : ExtractCopyingCompoundAssignmentStatementTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    public ExtractCopyingCompoundAssignmentStatementTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool GetValidLhsAndEquivalentTypes(IBinaryOperationExpression storeAssignment, IMetadataType& lhsType, IMetadataType& equivalentType);
    protected virtual IMetadataType GetRhsType(IMetadataType lhsType, OperationType operationType);
    protected virtual IBinaryOperationExpression CreateBinaryOperation(OperationType operationType, IBinaryOperationExpression baseBinaryOperation, IExpression leftArgument, IExpression rightArgument, OverflowCheckType overflowCheck);
}
internal abstract class JetBrains.Decompiler.Transformations.Assignment.ExtractCopyingCompoundAssignmentStatementTransformationBase`1 : CondNodeTransformationBase`1<IExpressionStatement> {
    private ReferencesFinder myFinder;
    protected ExtractCopyingCompoundAssignmentStatementTransformationBase`1(MethodDecompilerContext methodDecompilerContext, bool isEnabled);
    protected virtual bool DoApply(IExpressionStatement targetCopyAssignmentStatement);
    protected abstract virtual bool GetValidLhsAndEquivalentTypes(IBinaryOperationExpression storeAssignment, IMetadataType& lhsType, IMetadataType& equivalentType);
    [CanBeNullAttribute]
protected abstract virtual IMetadataType GetRhsType(IMetadataType lhsType, OperationType operationType);
    protected abstract virtual TBinaryOperationExpression CreateBinaryOperation(OperationType operationType, TBinaryOperationExpression baseBinaryOperation, IExpression leftArgument, IExpression rightArgument, OverflowCheckType overflowCheck);
}
internal class JetBrains.Decompiler.Transformations.Assignment.ExtractCopyingPostfixExpressionTransformation : ExtractCopyingPostfixExpressionTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    public ExtractCopyingPostfixExpressionTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool GetValidLhsAndEquivalentTypes(IExpression storeExpression, IMetadataType& lhsType, IMetadataType& equivalentType);
    protected virtual bool ToPostfixOperationType(IBinaryOperationExpression operation, OperationType& operationType);
    protected virtual bool GetInnerLoadAssignment(IBinaryOperationExpression operation, IBinaryOperationExpression& innerLoadAssignment, ITypeCastExpression& evaluationTypeCast);
    protected virtual OverflowCheckType GetOverflowCheck(IBinaryOperationExpression operation);
    protected virtual bool CheckOperation(IBinaryOperationExpression operation, IMetadataType lhsType, ITypeCastExpression evaluationTypeCast, ILocalVariable tempVariable1);
    protected virtual IExpression WrapUnary(IExpression expression, OperationType operationType, IBinaryOperationExpression baseOperation, OverflowCheckType overflowCheck, IMetadataType type);
}
internal abstract class JetBrains.Decompiler.Transformations.Assignment.ExtractCopyingPostfixExpressionTransformationBase`1 : CondNodeTransformationBase`1<IExpressionStatement> {
    private ReferencesFinder myFinder;
    protected ExtractCopyingPostfixExpressionTransformationBase`1(MethodDecompilerContext methodDecompilerContext, bool isEnabled);
    protected virtual bool DoApply(IExpressionStatement targetCopyAssignmentStatement);
    protected abstract virtual bool GetValidLhsAndEquivalentTypes(IExpression storeExpression, IMetadataType& lhsType, IMetadataType& equivalentType);
    protected abstract virtual bool ToPostfixOperationType(TExpression operation, OperationType& operationType);
    protected abstract virtual bool GetInnerLoadAssignment(TExpression operation, IBinaryOperationExpression& innerLoadAssignment, ITypeCastExpression& evaluationTypeCast);
    protected abstract virtual OverflowCheckType GetOverflowCheck(TExpression operation);
    protected abstract virtual bool CheckOperation(TExpression operation, IMetadataType lhsType, ITypeCastExpression evaluationTypeCast, ILocalVariable tempVariable1);
    protected abstract virtual IExpression WrapUnary(IExpression expression, OperationType operationType, TExpression baseOperation, OverflowCheckType overflowCheck, IMetadataType type);
}
internal class JetBrains.Decompiler.Transformations.Assignment.ExtractIndexerCompoundAssignmentTransformation : ExtractIndexerCompoundAssignmentTransformationBase`1<IBinaryOperationExpression> {
    private MetadataTypeCache myTypeCache;
    public ExtractIndexerCompoundAssignmentTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool GetValidLhsType(IIndexerCallExpression indexerStore, IMetadataType& lhsType);
    protected virtual IMetadataType GetRhsType(IMetadataType lhsType, OperationType operationType);
    protected virtual IBinaryOperationExpression CreateBinaryOperation(OperationType operationType, IBinaryOperationExpression baseBinaryOperation, IExpression leftArgument, IExpression rightArgument, IInstructionReference instructionReference, OverflowCheckType overflowCheck);
}
internal abstract class JetBrains.Decompiler.Transformations.Assignment.ExtractIndexerCompoundAssignmentTransformationBase`1 : CondNodeTransformationBase`1<IBinaryOperationExpression> {
    private ReferencesFinder myFinder;
    protected ExtractIndexerCompoundAssignmentTransformationBase`1(MethodDecompilerContext methodDecompilerContext, bool isEnabled);
    protected virtual bool DoApply(IBinaryOperationExpression outerAssignment);
    protected abstract virtual bool GetValidLhsType(IIndexerCallExpression indexerStore, IMetadataType& lhsType);
    [CanBeNullAttribute]
protected abstract virtual IMetadataType GetRhsType(IMetadataType lhsType, OperationType operationType);
    protected abstract virtual TBinaryOperationExpression CreateBinaryOperation(OperationType operationType, TBinaryOperationExpression baseBinaryOperation, IExpression leftArgument, IExpression rightArgument, IInstructionReference instructionReference, OverflowCheckType overflowCheck);
}
internal class JetBrains.Decompiler.Transformations.Assignment.ExtractIndexerPostfixExpressionTransformation : ExtractIndexerPostfixExpressionTransformationBase`1<IBinaryOperationExpression> {
    public ExtractIndexerPostfixExpressionTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool GetValidLhsType(IIndexerCallExpression indexerStore, IMetadataType& lhsType);
    protected virtual bool ToPostfixOperationType(IBinaryOperationExpression operation, OperationType& operationType);
    protected virtual bool GetTempAssignment(IBinaryOperationExpression operation, IBinaryOperationExpression& tempAssignment, ITypeCastExpression& evaluationTypeCast);
    protected virtual OverflowCheckType GetOverflowCheck(IBinaryOperationExpression operation);
    protected virtual bool CheckOperation(IBinaryOperationExpression operation, ITypeCastExpression evaluationTypeCast, IMetadataType lhsType);
    protected virtual IExpression WrapUnary(IExpression expression, OperationType operationType, IBinaryOperationExpression baseOperation, OverflowCheckType overflowCheck, IMetadataType type);
}
internal abstract class JetBrains.Decompiler.Transformations.Assignment.ExtractIndexerPostfixExpressionTransformationBase`1 : CondNodeTransformationBase`1<IBinaryOperationExpression> {
    private ReferencesFinder myFinder;
    protected ExtractIndexerPostfixExpressionTransformationBase`1(MethodDecompilerContext methodDecompilerContext, bool isEnabled);
    protected virtual bool DoApply(IBinaryOperationExpression outerAssignment);
    protected abstract virtual bool GetValidLhsType(IIndexerCallExpression indexerStore, IMetadataType& lhsType);
    protected abstract virtual bool ToPostfixOperationType(TExpression operation, OperationType& operationType);
    protected abstract virtual bool GetTempAssignment(TExpression operation, IBinaryOperationExpression& tempAssignment, ITypeCastExpression& evaluationTypeCast);
    protected abstract virtual OverflowCheckType GetOverflowCheck(TExpression operation);
    protected abstract virtual bool CheckOperation(TExpression operation, ITypeCastExpression evaluationTypeCast, IMetadataType lhsType);
    protected abstract virtual IExpression WrapUnary(IExpression expression, OperationType operationType, TExpression baseOperation, OverflowCheckType overflowCheck, IMetadataType type);
}
internal class JetBrains.Decompiler.Transformations.Assignment.ExtractRefParamCopyingPostfixExpressionTransformation : ExtractRefParamCopyingPostfixExpressionTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    public ExtractRefParamCopyingPostfixExpressionTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool CheckOperation(IBinaryOperationExpression operation, ILocalVariable localVariable, ITypeCastExpression& evaluationTypeCast);
    protected virtual bool ToPostfixOperationType(IBinaryOperationExpression operation, OperationType& operationType);
    protected virtual bool GetValidRefParamTypeAndEquivalentType(IExpression expression, IMetadataType& refParamType, IMetadataType& equivalentType);
    protected virtual OverflowCheckType GetOverflowCheck(IBinaryOperationExpression operation);
    protected virtual IExpression WrapUnary(IExpression expression, OperationType operationType, IBinaryOperationExpression baseOperation, OverflowCheckType overflowCheck, IMetadataType type);
}
internal abstract class JetBrains.Decompiler.Transformations.Assignment.ExtractRefParamCopyingPostfixExpressionTransformationBase`1 : CondNodeTransformationBase`1<IExpressionStatement> {
    private ReferencesFinder myFinder;
    protected ExtractRefParamCopyingPostfixExpressionTransformationBase`1(MethodDecompilerContext methodDecompilerContext, bool isEnabled);
    protected virtual bool DoApply(IExpressionStatement refParamCopyAssignmentStatement);
    protected abstract virtual bool CheckOperation(TExpression operation, ILocalVariable localVariable, ITypeCastExpression& evaluationTypeCast);
    protected abstract virtual bool ToPostfixOperationType(TExpression operation, OperationType& operationType);
    protected abstract virtual bool GetValidRefParamTypeAndEquivalentType(IExpression expression, IMetadataType& refParamType, IMetadataType& equivalentType);
    protected abstract virtual OverflowCheckType GetOverflowCheck(TExpression operation);
    protected abstract virtual IExpression WrapUnary(IExpression expression, OperationType operationType, TExpression baseOperation, OverflowCheckType overflowCheck, IMetadataType type);
}
internal class JetBrains.Decompiler.Transformations.Assignment.ExtractRefParamCopyingPrefixExpressionTransformation : ExtractRefParamCopyingPrefixExpressionTransformationBase`1<IBinaryOperationExpression> {
    private MetadataTypeCache myTypeCache;
    public ExtractRefParamCopyingPrefixExpressionTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool CheckOperation(IBinaryOperationExpression operation, IMethodParameter refParam, IMetadataType refParamType, ITypeCastExpression& evaluationTypeCast, IDerefExpression& derefRefParamExpression);
    protected virtual bool ToPrefixOperationType(IBinaryOperationExpression operation, OperationType& operationType);
    protected virtual bool GetEquivalentType(IMetadataType refParamType, IMetadataType& equivalentType);
    protected virtual OverflowCheckType GetOverflowCheck(IBinaryOperationExpression operation);
    protected virtual IExpression WrapUnary(IExpression expression, OperationType operationType, IBinaryOperationExpression baseOperation, OverflowCheckType overflowCheck, IMetadataType type);
}
internal abstract class JetBrains.Decompiler.Transformations.Assignment.ExtractRefParamCopyingPrefixExpressionTransformationBase`1 : CondNodeTransformationBase`1<IExpressionStatement> {
    private ReferencesFinder myFinder;
    protected ExtractRefParamCopyingPrefixExpressionTransformationBase`1(MethodDecompilerContext methodDecompilerContext, bool isEnabled);
    protected virtual bool DoApply(IExpressionStatement refParamCopyAssignmentStatement);
    protected abstract virtual bool CheckOperation(TExpression operation, IMethodParameter refParam, IMetadataType refParamType, ITypeCastExpression& evaluationTypeCast, IDerefExpression& derefRefParamExpression);
    protected abstract virtual bool ToPrefixOperationType(TExpression operation, OperationType& operationType);
    protected abstract virtual bool GetEquivalentType(IMetadataType refParamType, IMetadataType& equivalentType);
    protected abstract virtual OverflowCheckType GetOverflowCheck(TExpression operation);
    protected abstract virtual IExpression WrapUnary(IExpression expression, OperationType operationType, TExpression baseOperation, OverflowCheckType overflowCheck, IMetadataType type);
}
internal class JetBrains.Decompiler.Transformations.Assignment.ExtractSimpleCompoundAssignmentTransformation : ExtractSimpleCompoundAssignmentTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    public ExtractSimpleCompoundAssignmentTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool GetValidLhsType(IExpression lhsExpression, IMetadataType& lhsType);
    protected virtual IMetadataType GetRhsType(IMetadataType lhsType, OperationType operationType);
    protected virtual IBinaryOperationExpression CreateBinaryOperation(OperationType operationType, IBinaryOperationExpression baseBinaryOperation, IExpression leftArgument, IExpression rightArgument, OverflowCheckType overflowCheck);
}
internal abstract class JetBrains.Decompiler.Transformations.Assignment.ExtractSimpleCompoundAssignmentTransformationBase`1 : CondNodeTransformationBase`1<IBinaryOperationExpression> {
    protected ExtractSimpleCompoundAssignmentTransformationBase`1(bool isEnabled);
    protected virtual bool DoApply(IBinaryOperationExpression assignment);
    protected abstract virtual bool GetValidLhsType(IExpression lhsExpression, IMetadataType& lhsType);
    [CanBeNullAttribute]
protected abstract virtual IMetadataType GetRhsType(IMetadataType lhsType, OperationType operationType);
    protected abstract virtual TBinaryOperationExpression CreateBinaryOperation(OperationType operationType, TBinaryOperationExpression baseBinaryOperation, IExpression leftArgument, IExpression rightArgument, OverflowCheckType overflowCheck);
}
internal class JetBrains.Decompiler.Transformations.Assignment.ExtractSimplePostfixExpressionTransformation : NodeTransformationBase`1<IExpressionStatement> {
    private ExpressionTyper myExpressionTyper;
    private ReferencesFinder myReferencesFinder;
    public ExtractSimplePostfixExpressionTransformation(ExpressionTyper expressionTyper, ReferencesFinder referencesFinder);
    protected virtual bool DoApply(IExpressionStatement lhsTempAssignmentStatement);
}
internal class JetBrains.Decompiler.Transformations.Assignment.ExtractSimplePrefixExpressionTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    public ExtractSimplePrefixExpressionTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IBinaryOperationExpression binaryOperation);
}
internal class JetBrains.Decompiler.Transformations.Assignment.ExtractSimplePrefixExpressionTransformation2 : NodeTransformationBase`1<IExpressionStatement> {
    private ReferencesFinder myReferencesFinder;
    public ExtractSimplePrefixExpressionTransformation2(ReferencesFinder referencesFinder);
    protected virtual bool DoApply(IExpressionStatement localAssignmentStatement);
}
internal class JetBrains.Decompiler.Transformations.Async.AsyncDecompiler : AsyncDecompilerBase {
    private AsyncDecompiler(MethodDecompilerContext context);
    public static bool Run(MethodDecompilerContext context);
    protected virtual bool ProcessEqualityBranch(int state, ControlFlowBlock thenBlock);
    protected virtual bool MatchSetException(IStatement firstStatement, IStatement& lastStatement);
    protected virtual bool MatchSetResult(IStatement firstStatement, IStatement& lastStatement, IExpression& result);
    protected virtual IStatement CreateTerminationStatement(IInstructionReference instructionReference);
}
internal abstract class JetBrains.Decompiler.Transformations.Async.AsyncDecompilerBase : object {
    protected static int StartState;
    private static int FinishState;
    protected static string SetExceptionMethodName;
    protected static string SetResultMethodName;
    [CompilerGeneratedAttribute]
private MethodDecompilerContext <DecompilerContext>k__BackingField;
    [CanBeNullAttribute]
private ILocalVariableReferenceExpression myFlagVariable;
    [CanBeNullAttribute]
private ILocalVariableReferenceExpression myStateVariable;
    [NotNullAttribute]
public MethodDecompilerContext DecompilerContext { get; }
    [NotNullAttribute]
public IteratorContext IteratorContext { get; }
    protected AsyncDecompilerBase(MethodDecompilerContext decompilerContext);
    [CompilerGeneratedAttribute]
public sealed virtual MethodDecompilerContext get_DecompilerContext();
    public sealed virtual IteratorContext get_IteratorContext();
    protected bool Run();
    private bool AnalyzeSwitchBlock();
    protected abstract virtual bool ProcessEqualityBranch(int state, ControlFlowBlock thenBlock);
    private void FindBooleanFlagInit(ControlFlowBlock entryBlock);
    private void FindLocalVariableForStateInit(ControlFlowBlock entryBlock);
    protected virtual bool AssignEntryStateToBlock(ControlFlowBlock stateBlock, int state);
    private void ExtractAwaitBranches();
    protected virtual void DropAwaitingBranch(ControlFlowBlock awaitBlock, ControlFlowBlock nextBlock, ILocalVariable awaiterVariable);
    private void ExtractStateSwitches();
    private bool ExtractTopLevelCatch();
    protected virtual void RemoveRegion(ControlFlowRegion region);
    [ContractAnnotationAttribute("=> true, lastStatement: notnull; => false")]
protected abstract virtual bool MatchSetException(IStatement firstStatement, IStatement& lastStatement);
    [ContractAnnotationAttribute("=> true, lastStatement: notnull; => false")]
protected abstract virtual bool MatchSetResult(IStatement firstStatement, IStatement& lastStatement, IExpression& result);
    private bool ExtractMethodReturn();
    [CanBeNullAttribute]
private static IStatement GetRightSiblingSkipFieldNulling(IStatement statement, List`1& fieldNullingStatements);
    protected abstract virtual IStatement CreateTerminationStatement(IInstructionReference instructionReference);
    protected virtual void ProcessPredecessors(ControlFlowBlock terminateBlock);
    protected virtual bool ExtraSteps1();
    protected virtual bool ExtraSteps2();
    protected virtual bool ExtraSteps3();
    private void ExtractTryCatchWrappers();
    private void ExtractTryCatchWrappers(ControlFlowRegion region);
    private bool IsFlagOrStateCheck(IExpression checkExpression);
    private static bool IsAwaiterCompletionCheck(ControlFlowBlock block, IExpression& awaitedExpression, IExpression& targetExpression, IMetadataType& resultType, IStatement& awaiterCleanup, ILocalVariable& awaiterVariable);
    private static IMethodCallExpression FindGetResultCall(INode node, ILocalVariable awaiterVariable);
    [NotNullAttribute]
private static IMetadataType GetAwaiterResultType(IMethodCallExpression getResultCall);
    protected bool MatchFieldAccess(IExpression expression, IMetadataField field);
    protected bool MatchStateFieldAccess(IExpression expression);
    protected bool MatchStateFieldAssignment(IStatement statement, int state, bool withCachedStateLocal);
    protected bool MatchStateFieldAssignment(IStatement statement, Int32& state, bool withCachedStateLocal);
    private static bool HasThisOrDerefThisTarget(IFieldAccessExpression fieldAccess);
    protected bool MatchLocalVariableForStateField(IExpression expression);
    private bool MatchStateFieldOrCachedStateVariable(IExpression expression);
}
internal class JetBrains.Decompiler.Transformations.Async.AsyncIteratorContext : IteratorContext {
    [CompilerGeneratedAttribute]
private IMetadataField <BuilderField>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <PromiseOfValueOrEndField>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <DisposeModeField>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataField <CombinedTokensField>k__BackingField;
    public IMetadataField BuilderField { get; public set; }
    public IMetadataField PromiseOfValueOrEndField { get; public set; }
    public IMetadataField DisposeModeField { get; public set; }
    public IMetadataField CombinedTokensField { get; public set; }
    [CompilerGeneratedAttribute]
public IMetadataField get_BuilderField();
    [CompilerGeneratedAttribute]
public void set_BuilderField(IMetadataField value);
    [CompilerGeneratedAttribute]
public IMetadataField get_PromiseOfValueOrEndField();
    [CompilerGeneratedAttribute]
public void set_PromiseOfValueOrEndField(IMetadataField value);
    [CompilerGeneratedAttribute]
public IMetadataField get_DisposeModeField();
    [CompilerGeneratedAttribute]
public void set_DisposeModeField(IMetadataField value);
    [CompilerGeneratedAttribute]
public IMetadataField get_CombinedTokensField();
    [CompilerGeneratedAttribute]
public void set_CombinedTokensField(IMetadataField value);
}
internal class JetBrains.Decompiler.Transformations.Async.AsyncIteratorDecompiler : AsyncDecompilerBase {
    private static string CompleteMethodName;
    private static string AwaitUnsafeOnCompletedMethodName;
    private IteratorStates myIteratorStates;
    [NotNullAttribute]
private AsyncIteratorContext AsyncIteratorContext { get; }
    private AsyncIteratorDecompiler(MethodDecompilerContext context);
    public static bool Run(MethodDecompilerContext context);
    private AsyncIteratorContext get_AsyncIteratorContext();
    protected virtual bool AssignEntryStateToBlock(ControlFlowBlock stateBlock, int state);
    protected virtual bool ProcessEqualityBranch(int state, ControlFlowBlock thenBlock);
    protected virtual void RemoveRegion(ControlFlowRegion region);
    protected virtual IStatement CreateTerminationStatement(IInstructionReference instructionReference);
    protected virtual void ProcessPredecessors(ControlFlowBlock terminateBlock);
    protected virtual bool ExtraSteps1();
    protected virtual bool ExtraSteps2();
    protected virtual bool ExtraSteps3();
    private bool ExtractYields();
    private bool RemoveDisposeModeEdges();
    private bool RemoveDisposeModeTempVariables();
    private bool RemoveCombinedTokensDisposeBlocks();
    private bool RemoveEndfinallyBranches(ControlFlowRegion region);
    protected virtual void DropAwaitingBranch(ControlFlowBlock awaitBlock, ControlFlowBlock nextBlock, ILocalVariable awaiterVariable);
    protected virtual bool MatchSetException(IStatement firstStatement, IStatement& lastStatement);
    protected virtual bool MatchSetResult(IStatement firstStatement, IStatement& lastStatement, IExpression& result);
    [ContractAnnotationAttribute("=> true, statement: notnull; => false")]
private bool MatchPromiseOfValueOrEndFieldSetResult(IStatement statement, bool result);
    private bool MatchComplete(IStatement statement);
    public sealed virtual bool IsSplitStatement(IStatement statement, Int32& successorState);
}
internal class JetBrains.Decompiler.Transformations.Async.ExtractAsyncIteratorTransformation : ExtractIteratorTransformationBase`1<AsyncIteratorContext> {
    private static string ManualResetValueTaskSourceCoreReset;
    private static string CancellationTokenSourceCreateLinkedTokenSource;
    private static string CancellationTokenSourceToken;
    protected string IteratorStateMachineAttributeName { get; }
    protected string IteratorDebugName { get; }
    protected MethodDecompilerMode MoveNextMethodDecompilerMode { get; }
    public ExtractAsyncIteratorTransformation(MethodDecompilerContext decompilerContext);
    protected virtual bool GuessTypesFromReturn(IMetadataType returnType, IMetadataClassType& enumeratorType, IMetadataClassType& enumerableType);
    protected virtual string get_IteratorStateMachineAttributeName();
    protected virtual string get_IteratorDebugName();
    protected virtual bool IsGetCurrent(IMetadataMethod method);
    protected virtual bool IsGetEnumerator(IMetadataMethod method);
    protected virtual MethodDecompilerMode get_MoveNextMethodDecompilerMode();
    protected virtual void AddGeneratedFields(JetHashSet`1<IMetadataField> generatedFields, AsyncIteratorContext iteratorContext);
    protected virtual IStatement GetStateFieldAssignment(IBlockStatement ctorBody, AsyncIteratorContext iteratorContext);
    protected virtual bool GuessFromOtherMethods(IMetadataClassType iteratorType, AsyncIteratorContext iteratorContext);
    private bool GuessFromDisposeAsync(IMetadataClassType iteratorType, AsyncIteratorContext iteratorContext);
    protected virtual bool MatchSecondaryFieldInit(IStatement statement, AsyncIteratorContext iteratorContext, IMetadataField& secondaryField, IMetadataField& primaryField);
    private static bool MatchEqualsCall(IExpression expression, IMethodCallExpression& equals);
    private static bool MatchDefaultCancellationTokenCreation(IExpression expression);
    protected virtual void MarkIterator(IDecompiledMethodBase method);
}
internal class JetBrains.Decompiler.Transformations.Async.ExtractAsyncTransformation : NodeTransformationBase`1<IDecompiledMethodBase> {
    [NotNullAttribute]
private MethodDecompilerContext myContext;
    public ExtractAsyncTransformation(MethodDecompilerContext context);
    protected virtual bool DoApply(IDecompiledMethodBase method);
    private bool CreateContexts(IDecompiledMethodBase method, IMetadataClassType stateMachineType, List`1<Action> mutations, ClosureContext& closureContext, IteratorContext& iteratorContext);
    private bool DecompileAsyncBody(IMetadataClassType stateMachineType, IDecompiledMethodBase method, List`1<Action> mutations, ClosureContext closureContext, IteratorContext iteratorContext);
}
internal class JetBrains.Decompiler.Transformations.AutoProperties.ExtractAutoPropertiesTransformation : object {
    public sealed virtual bool Apply(IDecompiledClass decompiledClass);
    private static bool IsAutoProperty(IDecompiledProperty decompiledProperty, IMetadataField& backingField);
    private static bool MatchTarget(IExpression expression);
}
internal class JetBrains.Decompiler.Transformations.BlockNodeTransformation : object {
    private INodeTransformation myNodeTransformation;
    public BlockNodeTransformation(INodeTransformation nodeTransformation);
    public sealed virtual bool Apply(ControlFlowBlock block);
}
internal abstract class JetBrains.Decompiler.Transformations.BlockTransformationBase : object {
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    private bool IsEnabled { get; }
    protected BlockTransformationBase(bool isEnabled);
    public sealed virtual bool Apply(ControlFlowBlock block);
    protected abstract virtual bool DoApply(ControlFlowBlock block);
    [CompilerGeneratedAttribute]
private bool get_IsEnabled();
}
internal class JetBrains.Decompiler.Transformations.BlockTransformationPipeline : object {
    private bool myMultiPass;
    private InterruptionChecker myInterruptionChecker;
    private IEnumerable`1<IBlockTransformation> myTransformations;
    public BlockTransformationPipeline(bool multiPass, InterruptionChecker interruptionChecker, IBlockTransformation[] transformations);
    public sealed virtual bool Apply(ControlFlowGraph graph);
}
internal class JetBrains.Decompiler.Transformations.Bool.EliminateBoxedTrivialConditionalTransformation : NodeTransformationBase`1<IBoxExpression> {
    protected virtual bool DoApply(IBoxExpression boxExpression);
}
internal class JetBrains.Decompiler.Transformations.Bool.EliminateNegationTransformation : NodeTransformationBase`1<IUnaryOperationExpression> {
    private static Dictionary`2<OperationType, RewritingRule> RewritingRules;
    private static EliminateNegationTransformation();
    protected virtual bool DoApply(IUnaryOperationExpression node);
    public static IExpression Negate(IExpression expression);
}
internal class JetBrains.Decompiler.Transformations.Bool.EliminateTrivialBinaryOperationTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    protected virtual bool DoApply(IBinaryOperationExpression binaryOperation);
    private Nullable`1<bool> ToBool(IExpression expression);
}
internal class JetBrains.Decompiler.Transformations.Bool.EliminateTrivialConditionalTransformation : NodeTransformationBase`1<IConditionalExpression> {
    protected virtual bool DoApply(IConditionalExpression conditionalExpression);
}
internal class JetBrains.Decompiler.Transformations.Bool.ReduceBinaryBoolOperationTypeCastTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    public ReduceBinaryBoolOperationTypeCastTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IBinaryOperationExpression binaryOperation);
}
internal class JetBrains.Decompiler.Transformations.Bool.ReduceBoolToIntegerTypeCastTransformation : NodeTransformationBase`1<ITypeCastExpression> {
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    public ReduceBoolToIntegerTypeCastTransformation(ExpressionTyper expressionTyper, MetadataTypeCache typeCache);
    protected virtual bool DoApply(ITypeCastExpression typeCast);
}
internal class JetBrains.Decompiler.Transformations.Bool.ReduceIntegerToBoolTypeCastTransformation : NodeTransformationBase`1<ITypeCastExpression> {
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    public ReduceIntegerToBoolTypeCastTransformation(ExpressionTyper expressionTyper, MetadataTypeCache typeCache);
    protected virtual bool DoApply(ITypeCastExpression typeCast);
}
internal class JetBrains.Decompiler.Transformations.Bool.SimplifyBoolLiteralComparisonTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    public SimplifyBoolLiteralComparisonTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IBinaryOperationExpression node);
    private bool TransformEquality(IBinaryOperationExpression comparison, IExpression lhs, IExpression rhs);
    private bool TransformComparison(IBinaryOperationExpression comparison, IExpression greaterArgument, IExpression lessArgument);
}
internal class JetBrains.Decompiler.Transformations.Bool.SimplifyIntLiteralComparisonTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private MetadataTypeCache myTypeCache;
    public SimplifyIntLiteralComparisonTransformation(MetadataTypeCache typeCache);
    protected virtual bool DoApply(IBinaryOperationExpression binaryOperation);
}
internal class JetBrains.Decompiler.Transformations.Boxing.ReduceBoxTransformation : NodeTransformationBase`1<IBoxExpression> {
    private MetadataTypeCache myTypeCache;
    public ReduceBoxTransformation(MetadataTypeCache typeCache);
    protected virtual bool DoApply(IBoxExpression box);
    private IMetadataType GetBoxingConversionType(IMetadataType type);
}
internal class JetBrains.Decompiler.Transformations.Boxing.ReduceUnboxTransformation : NodeTransformationBase`1<IUnboxExpression> {
    protected virtual bool DoApply(IUnboxExpression unbox);
}
internal enum JetBrains.Decompiler.Transformations.ChildVisitOrder : Enum {
    public int value__;
    public static ChildVisitOrder Direct;
    public static ChildVisitOrder Reverse;
}
internal abstract class JetBrains.Decompiler.Transformations.ClassContentsTransformation : object {
    private DecompiledClassCache myDecompiledClassCache;
    protected ClassContentsTransformation(DecompiledClassCache decompiledClassCache);
    public sealed virtual bool Apply(IDecompiledClass decompiledClass);
    private void ProcessMethods(IDecompiledClass decompiledClass);
    private void ProcessProperties(IDecompiledClass decompiledClass);
    private void ProcessEvents(IDecompiledClass decompiledClass);
    private void ProcessFields(IDecompiledClass decompiledClass);
    private void ProcessNestedTypes(IDecompiledClass decompiledClass);
    protected abstract virtual void ProcessMethod(IDecompiledMethod decompiledMethod);
    protected abstract virtual void ProcessInitializer(IDecompiledClass decompiledClass, IExpression initializerExpression);
}
internal class JetBrains.Decompiler.Transformations.ClassTransformationPipeline : object {
    private bool myMultiPass;
    private IClassTransformation[] myTransformations;
    public ClassTransformationPipeline(bool multiPass, IClassTransformation[] transformations);
    public sealed virtual bool Apply(IDecompiledClass decompiledClass);
}
internal class JetBrains.Decompiler.Transformations.CombiningNodeTransformation : object {
    private InterruptionChecker myInterruptionChecker;
    private TypedTransformationMap myTransformationMap;
    public Type BaseNodeType { get; }
    public CombiningNodeTransformation(InterruptionChecker interruptionChecker, INodeTransformation[] transformations);
    public sealed virtual Type get_BaseNodeType();
    public sealed virtual bool Apply(INode node);
}
internal static class JetBrains.Decompiler.Transformations.CompoundAssignmentUtil : object {
    private static Dictionary`2<OperationType, OperationType> CompoundOperationTypeMap;
    private static CompoundAssignmentUtil();
    public static bool CanConvertToCompoundAssignment(INode parent, OverflowCheckType overflowCheck);
    public static bool IsValidLhsType(IMetadataType type);
    public static bool IsValidLhsTypeCast(IMetadataType lhsType, ITypeCastExpression typeCast);
    public static bool IsValidTempTypeCast(IMetadataType lhsType, ITypeCastExpression typeCast);
    public static bool IsValidEvaluationTypeCast(IMetadataType lhsType, ITypeCastExpression typeCast, bool isChecked);
    public static IMetadataType GetRhsType(MetadataTypeCache typeCache, IMetadataType lhsType, OperationType operationType);
    public static IMetadataType GetEquivalentType(MetadataTypeCache typeCache, IMetadataType lhsType);
    public static bool AreEqualTargets(IExpression expression1, IExpression expression2);
    public static bool AreEqualTargets(IIndexerCallExpression indexer1, IExpression expression1, IExpression expression2);
    public static bool ToCompoundOperationType(OperationType operationType, OperationType& assignmentOperationType);
    public static bool ToPrefixOperationType(UserDefinedOperator userDefinedOperator, OperationType& operationType);
    public static bool ToPostfixOperationType(UserDefinedOperator userDefinedOperator, OperationType& unaryOperationType);
    public static bool ToPrefixOperationType(OperationType binaryOperationType, OperationType& unaryOperationType);
    public static bool ToPostfixOperationType(OperationType binaryOperationType, OperationType& unaryOperationType);
    public static bool MatchIndexerExpressions(IIndexerCallExpression indexerLoad, IIndexerCallExpression indexerStore, ReferencesFinder finder, IExpression& target, IExpression[]& indices);
    public static bool MatchArrayElementAccessExpressions(IArrayElementAccessExpression arrayElementLoad, IArrayElementAccessExpression arrayElementStore, MetadataTypeCache typeCache, ReferencesFinder finder, IExpression& array, IExpression[]& indexes);
    public static bool MatchArrayElementAccessExpressions(IArrayElementAccessExpression arrayElementLoad, IArrayElementAccessExpression arrayElementStore, ReferencesFinder finder, IExpression& array, IExpression[]& indexes, IStatement[]& copyingStatements);
    private static bool MatchTargetCopyAcquisition(IExpression expression, ILocalVariable targetCopyVariable, IExpression& target);
    private static bool MatchTargetCopyReference(IExpression expression, ILocalVariable targetCopyVariable);
    public static bool MatchLoadExpression(ILocalVariable targetCopyVariable, IExpression loadExpression, IExpression target, IExpression& lhsExpression);
    public static bool MatchTargetCopyAssignmentStatement(IExpressionStatement targetCopyAssignmentStatement, ILocalVariable& targetCopyVariable, IExpression& target);
    public static bool MatchUnit(IExpression unitExpression, IMetadataType lhsType, IMetadataType evaluationType);
}
internal class JetBrains.Decompiler.Transformations.CondGraphTransformation : object {
    private IGraphTransformation myRealTransformation;
    private bool myConditionalResult;
    public CondGraphTransformation(bool conditionalResult, IGraphTransformation realTransformation);
    public sealed virtual bool Apply(ControlFlowGraph graph);
}
internal abstract class JetBrains.Decompiler.Transformations.Conditional.BranchBlockTransformationBase : object {
    public sealed virtual bool Apply(ControlFlowBlock block);
    protected abstract virtual bool DoApply(ControlFlowBlock branchBlock, ControlFlowBlock thenBlock, ControlFlowBlock elseBlock, bool negateCondition);
}
internal static class JetBrains.Decompiler.Transformations.Conditional.ConditionalExpressionUtil : object {
    public static bool CanConvertToConditional(IExpression thenExpression, IExpression elseExpression);
    public static bool ConditionalOperatorNeededForOtherTransformation(IExpression thenExpression, IExpression elseExpression);
    private static bool CanBeConvertedToBinaryConditional(IExpression thenExpression, IExpression elseExpression);
    private static bool CanBeBooleanLiteral(ILiteralExpression literalExpression);
    private static bool CanBeConvertedToFixed(IExpression thenExpression, IExpression elseExpression);
    public static bool NullCoalescingOperatorNeededForOtherTransformation(IMetadataType resultType);
}
internal class JetBrains.Decompiler.Transformations.Conditional.ConvertReturnToConditionalTransformation : NodeTransformationBase`1<IIfStatement> {
    private DecompilerOptions myDecompilerOptions;
    public ConvertReturnToConditionalTransformation(DecompilerOptions decompilerOptions);
    protected virtual bool DoApply(IIfStatement ifStatement);
}
internal class JetBrains.Decompiler.Transformations.Conditional.EliminateRedundantElseTransformation : NodeTransformationBase`1<IIfStatement> {
    protected virtual bool DoApply(IIfStatement ifStatement);
    private bool IsTerminal(IStatement statement);
    private bool IsTerminalBlock(IBlockStatement block);
}
internal class JetBrains.Decompiler.Transformations.Conditional.ExtractConditionalAccessTransformation : CondNodeTransformationBase`1<IIfStatement> {
    private MetadataTypeCache myTypeCache;
    private ExpressionTyper myExpressionTyper;
    public ExtractConditionalAccessTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(IIfStatement ifStatement);
    [CanBeNullAttribute]
private IExpression TryGetExpression(IExpression condition, IExpression thenExpression, IExpression elseExpression);
}
internal class JetBrains.Decompiler.Transformations.Conditional.ExtractConditionalAssignmentTransformation : object {
    private MetadataTypeCache myTypeCache;
    private ExpressionTyper myExpressionTyper;
    private DecompilerOptions myDecompilerOptions;
    public ExtractConditionalAssignmentTransformation(MetadataTypeCache typeCache, ExpressionTyper expressionTyper, DecompilerOptions decompilerOptions);
    public sealed virtual bool Apply(ControlFlowBlock branchBlock);
    private static bool IsNullAssignment(IBinaryOperationExpression assignment, ILocalVariable& variable, Boolean& isNullableResult);
}
internal class JetBrains.Decompiler.Transformations.Conditional.JoinBranchConditionsTransformation : BranchBlockTransformationBase {
    protected virtual bool DoApply(ControlFlowBlock branchBlock, ControlFlowBlock thenBlock, ControlFlowBlock elseBlock, bool negateCondition);
    private static bool DoApply(ControlFlowBlock branchBlock, ControlFlowBlock thenBlock, ControlFlowBlock elseBlock, bool negateFirstCondition, ControlFlowBlock elseThenBlock, ControlFlowBlock elseElseBlock, bool negateSecondCondition);
}
internal class JetBrains.Decompiler.Transformations.Conditional.LeftConditionalLiteralTransformation : NodeTransformationBase`1<IConditionalExpression> {
    protected virtual bool DoApply(IConditionalExpression conditional);
}
internal class JetBrains.Decompiler.Transformations.Conditional.PromoteTypeCastIntoConditionalTransformation : NodeTransformationBase`1<ITypeCastExpression> {
    protected virtual bool DoApply(ITypeCastExpression typeCast);
}
internal class JetBrains.Decompiler.Transformations.Conditional.RightConditionalLiteralTransformation : NodeTransformationBase`1<IConditionalExpression> {
    protected virtual bool DoApply(IConditionalExpression node);
}
internal class JetBrains.Decompiler.Transformations.Conditional.SimplifyConditionalWithLiteralComparisonTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    protected virtual bool DoApply(IBinaryOperationExpression binaryOperationExpression);
    private bool DoApply(IBinaryOperationExpression binaryOperation, IExpression greaterArgument, IExpression lessArgument);
    private void Replace(IBinaryOperationExpression binaryOperation, OperationType operationType, bool negateCondition, IExpression condition, IExpression expression, ILiteralExpression literal0U);
    private IExpression NegateIfNeeded(IExpression expression, bool negateCondition);
}
internal class JetBrains.Decompiler.Transformations.CondNodeTransformation : object {
    private bool myConditionResult;
    private INodeTransformation myRealTransformation;
    public Type BaseNodeType { get; }
    public CondNodeTransformation(bool conditionResult, INodeTransformation realTransformation);
    public sealed virtual Type get_BaseNodeType();
    public sealed virtual bool Apply(INode node);
}
internal class JetBrains.Decompiler.Transformations.CondNodeTransformation`1 : NodeTransformationBase`1<T> {
    private Predicate`1<T> myCondition;
    private INodeTransformation myRealTransformation;
    public CondNodeTransformation`1(Predicate`1<T> condition, INodeTransformation realTransformation);
    protected virtual bool DoApply(T node);
}
internal abstract class JetBrains.Decompiler.Transformations.CondNodeTransformationBase`1 : NodeTransformationBase`1<T> {
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    protected bool IsEnabled { get; }
    protected CondNodeTransformationBase`1(bool isEnabled);
    [CompilerGeneratedAttribute]
protected virtual bool get_IsEnabled();
}
internal static class JetBrains.Decompiler.Transformations.Delegates.AnonymousFunctionUtil : object {
    public static IExpression Decompile(IDelegateCreationExpression delegateCreation, MethodDecompilerContext decompilerContext, ClosureContext closureContext);
    internal static bool AnonymousDelegateHasParamArrayParameter(IMetadataType delegateType, int ownParametersCount);
    private static bool IsLambda(IDecompiledMethodBase decompiledBodyMethod);
    private static FunctionSignatureStyle GetSignatureStyle(IDecompiledMethodBase decompiledBodyMethod);
}
internal class JetBrains.Decompiler.Transformations.Delegates.EliminateCopiesOfClosureFrameVariableTransformation : NodeTransformationBase`1<IObjectCreationExpression> {
    private ReferencesFinder myReferencesFinder;
    public EliminateCopiesOfClosureFrameVariableTransformation(ReferencesFinder referencesFinder);
    protected virtual bool DoApply(IObjectCreationExpression frameCreation);
    private IList`1<IBinaryOperationExpression> GetFrameCopyAssignments(ILocalVariable frameVariable);
}
internal abstract class JetBrains.Decompiler.Transformations.Delegates.ExtractCachedAnonymousDelegateTransformationBase : BranchBlockTransformationBase {
    private MethodDecompilerContext myDecompilerContext;
    protected ReferencesFinder ReferencesFinder { get; }
    protected ExtractCachedAnonymousDelegateTransformationBase(MethodDecompilerContext decompilerContext);
    protected ReferencesFinder get_ReferencesFinder();
    protected IExpression Decompile(IDelegateCreationBaseExpression delegateCreationBase);
    [CanBeNullAttribute]
protected static IFieldAccessExpression GetDelegateAccess(IBlockStatement blockStatement, IMetadataField cachedDelegateField);
    [CanBeNullAttribute]
protected ILocalVariableReferenceExpression GetLocalVariableAccess(ILocalVariable local, ControlFlowBlockNode forbiddenBlock1, ControlFlowBlockNode forbiddenBlock2);
    protected void InsertAnonymousDelegateCreation(ControlFlowBlock block, IExpression anonymousDelegateCreation, IMetadataType delegateType, IInstructionReference instructionReference, ILocalVariable local);
}
internal class JetBrains.Decompiler.Transformations.Delegates.ExtractCachedAnonymousDelegateWithTempVariableTransformation : ExtractCachedAnonymousDelegateTransformationBase {
    public ExtractCachedAnonymousDelegateWithTempVariableTransformation(MethodDecompilerContext decompilerContext);
    protected virtual bool DoApply(ControlFlowBlock branchBlock, ControlFlowBlock thenBlock, ControlFlowBlock elseBlock, bool negateCondition);
    private int WriteUsagesCount(ILocalVariable local);
}
internal class JetBrains.Decompiler.Transformations.Delegates.ExtractClosuresTransformation : NodeTransformationBase`1<IDecompiledMethodBase> {
    private MethodDecompilerContext myContext;
    private Dictionary`2<ILocalVariable, ClosureContext> myVariableToClosureContext;
    private HashSet`1<ILocalVariable> myLocalFunctionsFrameVariables;
    private List`1<Action> myMutations;
    private Dictionary`2<ILocalVariable, List`1<Action>> myVariableToMutations;
    private OneToSetMap`2<ILocalVariable, ILocalVariable> myDependencies;
    private HashSet`1<IStatement> myFrameInitStatements;
    private HashSet`1<ILocalVariableReferenceExpression> myRecognizedReferences;
    private IDecompiledMethodBase myMethod;
    private bool myHasChanges;
    private bool myAbandonTransformation;
    [CanBeNullAttribute]
private NodeTreeAnalyzer myNodeTreeAnalyzer;
    public static DataKey`1<Dictionary`2<ILocalVariable, ClosureContext>> VariableToClosure;
    public ExtractClosuresTransformation(MethodDecompilerContext context);
    private static ExtractClosuresTransformation();
    protected virtual bool DoApply(IDecompiledMethodBase method);
    private void CollectVariableToClosureContext();
    private bool ExtractFrames();
    private void ProcessLocalFunctionCalls();
    private void ProcessMethodCall(IMethodCallExpression methodCall);
    private void ProcessObjectCreation(IObjectCreationExpression frameCreation);
    private void ProcessFrameVariableInitialization(ILocalVariable frameVariable, IMetadataClassType frameType, IStatement startStatement, bool startStatementIsFrameCreation);
    private void ReplaceWithLocalFunctionCall(IMethodCallExpression localFunctionCall);
    private void SelectIndependentFrames();
    private bool CheckFrameReferences();
    private bool IsFrameReferenceRecognized(ILocalVariableReferenceExpression reference);
    private void ExtractAnonymousDelegates();
    [CanBeNullAttribute]
private ILocalVariableReferenceExpression TryFindLocallyCachedDelegate(IDelegateCreationExpression delegateCreation, ILocalVariableReferenceExpression frameVariableReference, IIfStatement& ifStatement, IExpressionStatement& localAssignmentStatement);
    [CanBeNullAttribute]
private IBinaryOperationExpression TryFindNullCoalescing(IDelegateCreationExpression delegateCreation, ILocalVariableReferenceExpression frameVariableReference);
    private void ExtractLinqExpressions();
    private void StoreClosuresData();
    private void ApplyMutations();
    private void Cleanup();
    [CompilerGeneratedAttribute]
private void <ExtractAnonymousDelegates>b__25_0(IDelegateCreationExpression delegateCreation);
    [CompilerGeneratedAttribute]
private void <ExtractLinqExpressions>b__28_0(IMethodCallExpression methodCall);
}
internal class JetBrains.Decompiler.Transformations.Delegates.ExtractDelegateComparisonTransformation : CondNodeTransformationBase`1<IUserDefinedBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    public ExtractDelegateComparisonTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(IUserDefinedBinaryOperationExpression comparison);
}
internal class JetBrains.Decompiler.Transformations.Delegates.ExtractDelegateCreationTransformation : NodeTransformationBase`1<IExpressionStatement> {
    private MethodDecompilerContext myDecompilerContext;
    private ReferencesFinder myFinder;
    public ExtractDelegateCreationTransformation(MethodDecompilerContext decompilerContext);
    protected virtual bool DoApply(IExpressionStatement targetCopyAssignmentStatement);
    private static bool LocalFunctionOwnerTypeEquals(IMetadataClassType type1, IMetadataType t2, int localFunctionOwnerMethodTypeParametersCount);
}
internal class JetBrains.Decompiler.Transformations.Delegates.ExtractDelegateOperationTransformation : CondNodeTransformationBase`1<ITypeCastExpression> {
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    public ExtractDelegateOperationTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(ITypeCastExpression outerTypeCast);
}
internal class JetBrains.Decompiler.Transformations.Delegates.ExtractLocallyCachedAnonymousDelegateTransformation : BranchBlockTransformationBase {
    private ReferencesFinder myFinder;
    public ExtractLocallyCachedAnonymousDelegateTransformation(ReferencesFinder finder);
    protected virtual bool DoApply(ControlFlowBlock branchBlock, ControlFlowBlock thenBlock, ControlFlowBlock elseBlock, bool negateCondition);
    private static ILocalVariableReferenceExpression GetDelegateReference(IBlockStatement blockStatement, ILocalVariable cachedDelegateVariable);
}
internal class JetBrains.Decompiler.Transformations.Delegates.ExtractNullCoalescingCachedDelegateCreationTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private MethodDecompilerContext myDecompilerContext;
    public ExtractNullCoalescingCachedDelegateCreationTransformation(MethodDecompilerContext decompilerContext);
    protected virtual bool DoApply(IBinaryOperationExpression node);
}
internal class JetBrains.Decompiler.Transformations.Delegates.ExtractOptimizedDelegateCreationTransformation : NodeTransformationBase`1<IExpressionStatement> {
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myFinder;
    public ExtractOptimizedDelegateCreationTransformation(MetadataTypeCache typeCache, ReferencesFinder finder);
    protected virtual bool DoApply(IExpressionStatement methodPointerAssignmentStatement);
}
internal class JetBrains.Decompiler.Transformations.Delegates.ExtractReturnStaticallyCachedAnonymousDelegateTransformation : ExtractCachedAnonymousDelegateTransformationBase {
    public ExtractReturnStaticallyCachedAnonymousDelegateTransformation(MethodDecompilerContext decompilerContext);
    protected virtual bool DoApply(ControlFlowBlock branchBlock, ControlFlowBlock thenBlock, ControlFlowBlock elseBlock, bool negateCondition);
}
internal class JetBrains.Decompiler.Transformations.Delegates.ExtractReturnStaticallyCachedAnonymousDelegateWithTempVariableTransformation : ExtractCachedAnonymousDelegateTransformationBase {
    public ExtractReturnStaticallyCachedAnonymousDelegateWithTempVariableTransformation(MethodDecompilerContext decompilerContext);
    protected virtual bool DoApply(ControlFlowBlock branchBlock, ControlFlowBlock thenBlock, ControlFlowBlock elseBlock, bool negateCondition);
}
internal class JetBrains.Decompiler.Transformations.Delegates.ExtractSimpleAnonymousDelegateTransformation : NodeTransformationBase`1<IDelegateCreationExpression> {
    private MethodDecompilerContext myDecompilerContext;
    public ExtractSimpleAnonymousDelegateTransformation(MethodDecompilerContext decompilerContext);
    protected virtual bool DoApply(IDelegateCreationExpression delegateCreation);
}
internal class JetBrains.Decompiler.Transformations.Delegates.ExtractSimpleLocalFunctionTransformation : NodeTransformationBase`1<IMethodCallExpression> {
    private MethodDecompilerContext myDecompilerContext;
    public ExtractSimpleLocalFunctionTransformation(MethodDecompilerContext decompilerContext);
    protected virtual bool DoApply(IMethodCallExpression methodCall);
}
internal class JetBrains.Decompiler.Transformations.Delegates.ExtractStaticallyCachedAnonymousDelegateTransformation : ExtractCachedAnonymousDelegateTransformationBase {
    public ExtractStaticallyCachedAnonymousDelegateTransformation(MethodDecompilerContext decompilerContext);
    protected virtual bool DoApply(ControlFlowBlock branchBlock, ControlFlowBlock thenBlock, ControlFlowBlock elseBlock, bool negateCondition);
}
internal class JetBrains.Decompiler.Transformations.Delegates.ExtractVirtualDelegateCreationTransformation : NodeTransformationBase`1<IExpressionStatement> {
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myFinder;
    public ExtractVirtualDelegateCreationTransformation(MetadataTypeCache typeCache, ReferencesFinder finder);
    protected virtual bool DoApply(IExpressionStatement targetCopyAssignmentStatement);
}
internal class JetBrains.Decompiler.Transformations.Delegates.LocalFunctionsDeclarationsInserter : object {
    private IDecompiledMethodBase myMethod;
    private ReferencesFinder myReferencesFinder;
    private Dictionary`2<MetadataToken, IStatement> myDeclareAfter;
    private NodeTreeAnalyzer myNodeTreeAnalyzer;
    [NotNullAttribute]
private NodeTreeAnalyzer TreeAnalyzer { get; }
    private LocalFunctionsDeclarationsInserter(IDecompiledMethodBase method, ReferencesFinder referencesFinder);
    private NodeTreeAnalyzer get_TreeAnalyzer();
    public static void Run(IDecompiledMethodBase method, ReferencesFinder referencesFinder);
    private void Run();
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Transformations.Delegates.LocalFunctionsDeclarationsInserter/<FindDependencies>d__9")]
private IEnumerable`1<MetadataToken> FindDependencies(ILocalFunction localFunction);
    private void ConsiderLocalFunctionsDependencies();
    [CanBeNullAttribute]
private IStatement GetOwnerMethodLocalVariablesVisibilityPoint(ILocalFunction localFunction, IStatement startingDeclarationPoint);
    private static IStatement GetLastStatement(IStatement blockStatement);
    private static IStatement GetLastStatementInBlock(IStatement statementInBlock);
    private static void UpdateConflicts(Dictionary`2<IStatement, int> conflicts, IStatement declarationPoint);
    private static IStatement GetNonConflictingDeclarationPoint(Dictionary`2<IStatement, int> conflicts, IStatement declarationPoint);
    [CanBeNullAttribute]
private static IStatement GetParentNonBlockStatement(IStatement statement);
    private IStatement GetVisibilityPoint(IStatement declarationPoint1, IStatement declarationPoint2);
    private void DeclareLocalFunction(ILocalFunction localFunction, IStatement declareAfter);
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.Transformations.Delegates.NodeMatchingExtensions : object {
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, cachedDelegateField: notnull; => false, cachedDelegateField: null; expression: null => false")]
public static bool MatchCachedDelegateFieldAccess(IExpression expression, IMetadataField& cachedDelegateField, bool isStatic);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, cachedDelegateField: notnull; => false, cachedDelegateField: null; expression: null => false")]
public static bool MatchCachedDelegateFieldAccess(IExpression expression, IMetadataField& cachedDelegateField);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, cachedDelegateField: notnull; => false, cachedDelegateField: null; expression: null => false")]
public static bool MatchStaticallyCachedDelegateFieldIsNull(IExpression expression, bool negateCondition, IMetadataField& cachedDelegateField);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, delegateCreation: notnull; => false, delegateCreation: null; expression: null => false")]
public static bool MatchDelegateCreation(IExpression expression, IMetadataTypeInfo ownerType, IDelegateCreationBaseExpression& delegateCreation);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, delegateCreation: notnull; => false, delegateCreation: null; statement: null => false")]
public static bool MatchCachingDelegateCreationStatement(IStatement statement, IMetadataField cachedDelegateField, IMetadataTypeInfo ownerType, IDelegateCreationBaseExpression& delegateCreation);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, temp: notnull, delegateCreation: notnull; => false, temp: null, delegateCreation: null; statement: null => false")]
public static bool MatchDoubleAssignmentDelegateCreationStatement(IStatement statement, IMetadataField cachedDelegateField, IMetadataTypeInfo ownerType, ILocalVariable& temp, IDelegateCreationBaseExpression& delegateCreation);
}
internal class JetBrains.Decompiler.Transformations.Enums.ExtractEnumBinaryOperationTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    public ExtractEnumBinaryOperationTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IBinaryOperationExpression binaryOperation);
    private static bool IsSupportedRelationalOperation(OperationType operationType);
    private static bool IsSupportedFunctionalOperation(OperationType operationType);
    private static bool IsValidEvaluationTypeCast(IMetadataType enumType, OperationType operationType, ITypeCastExpression typeCast);
}
internal class JetBrains.Decompiler.Transformations.Enums.ExtractEnumUnaryOperationTransformation : NodeTransformationBase`1<IUnaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    public ExtractEnumUnaryOperationTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IUnaryOperationExpression unaryOperation);
    private static ElementType GetEvaluationElementType(IMetadataType enumType);
}
internal class JetBrains.Decompiler.Transformations.Events.ExtractFieldLikeEventsTransformation : object {
    public sealed virtual bool Apply(IDecompiledClass decompiledClass);
    private static bool IsFieldLikeEvent(IDecompiledEvent decompiledEvent, IMetadataField& backingField);
    private static bool MatchAccessor(IDecompiledMethod accessor, IMetadataField& backingField);
    private static void CopyFieldInitializer(IDecompiledClass decompiledClass, IDecompiledEvent decompiledEvent, IMetadataField backingField);
}
internal class JetBrains.Decompiler.Transformations.Exceptions.CombineTryCatchFinallyTransformation : NodeTransformationBase`1<ITryStatement> {
    protected virtual bool DoApply(ITryStatement outerTry);
    public static bool CombineTryCatchFinally(ITryStatement outerTry);
}
internal class JetBrains.Decompiler.Transformations.Exceptions.EliminateCatchVariableTransformation : NodeTransformationBase`1<ICatchClause> {
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myFinder;
    public EliminateCatchVariableTransformation(MetadataTypeCache typeCache, ReferencesFinder finder);
    protected virtual bool DoApply(ICatchClause catchClause);
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.Transformations.Exceptions.ExceptionEx : object {
    [ExtensionAttribute]
private static bool MatchThrowPattern(INode typedExceptionInitialization, ILocalVariable exceptionObjectVariable, bool patternMatching, IExpressionStatement& castToExceptionStatement, IIfStatement& ifStatement, IExpressionStatement& callStatement);
    [ExtensionAttribute]
public static bool MatchThrowPattern(IThrowStatement throw, ILocalVariableReferenceExpression exceptionObject, IExpressionStatement& castToExceptionStatement, IIfStatement& ifStatement, IExpressionStatement& callStatement);
    [ExtensionAttribute]
private static bool MatchThrowPattern(IBlockStatement block, ILocalVariable exceptionObjectVariable);
    [ExtensionAttribute]
public static bool MatchThrowPattern(IIfStatement ifStatement, ILocalVariable exceptionObjectVariable);
    [ExtensionAttribute]
private static bool IsExceptionDispatchInfoThrow(IMetadataMethod method);
    [ExtensionAttribute]
private static bool IsExceptionDispatchInfoCapture(IMetadataMethod method);
}
internal class JetBrains.Decompiler.Transformations.Exceptions.PromoteAwaitIntoCatchTransformation : NodeTransformationBase`1<ITryStatement> {
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myReferencesFinder;
    public PromoteAwaitIntoCatchTransformation(MetadataTypeCache typeCache, ReferencesFinder referencesFinder);
    protected virtual bool DoApply(ITryStatement tryStatement);
    private void PromoteAwaitIntoCatch(IStatement ifOrSwitchStatement, Dictionary`2<int, ICatchClause> catchesWithAwait, Dictionary`2<int, IStatement> catchesBodies);
    private bool TryReplaceTempExceptionVariableUsages(IStatement catchClauseFirstStatement, IStatement tempVariableNullingStatement, ILocalVariable catchExceptionVariable, bool exceptionObjectExists, ILocalVariable exceptionObjectVariable, INode scope);
    private void ReplaceExceptionObjectVariableUsagesInScope(ILocalVariableReferenceExpression exceptionObjectInitializationReference, ILocalVariable catchExceptionVariable, IBlockStatement scope);
    private static bool MatchAssignment(INode node, IExpressionStatement& assignmentStatement, ILocalVariable& leftVariable, IMetadataType type, ILocalVariable rightVariable);
    private static bool TryReplaceThrowPatternWithThrow(ILocalVariableReferenceExpression exceptionObject);
}
internal class JetBrains.Decompiler.Transformations.Exceptions.PromoteAwaitIntoFinallyTransformation : NodeTransformationBase`1<ITryStatement> {
    private MetadataTypeCache myTypeCache;
    public PromoteAwaitIntoFinallyTransformation(MetadataTypeCache typeCache);
    protected virtual bool DoApply(ITryStatement tryStatement);
}
internal class JetBrains.Decompiler.Transformations.Exceptions.PromoteLastTryStatementTransformation : NodeTransformationBase`1<ITryStatement> {
    protected virtual bool DoApply(ITryStatement try);
    private static bool CanPromote(IStatement statement);
}
internal class JetBrains.Decompiler.Transformations.Exceptions.ReplaceSingleThrowStatementWithThrowExpressionTransformation : NodeTransformationBase`1<IThrowStatement> {
    protected virtual bool DoApply(IThrowStatement throw);
}
internal class JetBrains.Decompiler.Transformations.Exceptions.ReplaceThrowStatementWithThrowExpressionTransformation : NodeTransformationBase`1<IThrowStatement> {
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myReferencesFinder;
    private DecompilerOptions myDecompilerOptions;
    public ReplaceThrowStatementWithThrowExpressionTransformation(MetadataTypeCache typeCache, ReferencesFinder referencesFinder, DecompilerOptions decompilerOptions);
    protected virtual bool DoApply(IThrowStatement throw);
    private static void Replace(IStatement oldStatement, IStatement newStatement, IBlockStatement newBlockStatement);
    private static bool FindIf(IThrowStatement throw, IIfStatement& ifStatement, IStatement& nextStatement, Boolean& negate);
    private static bool AreSimpleAndCorrelated(IExpression condition, IStatement nextStatement, IExpression nextExpression);
    public static bool IsSimple(IExpression expression);
}
internal class JetBrains.Decompiler.Transformations.Expressions.ExtractLinqExpressionTransformation : NodeTransformationBase`1<IMethodCallExpression> {
    private bool myApplyRewrite;
    [NotNullAttribute]
private MethodDecompilerContext myContext;
    [NotNullAttribute]
private Dictionary`2<ILocalVariable, IMethodParameter> myParameters;
    [CanBeNullAttribute]
private List`1<ILocalVariableReferenceExpression> myCaptures;
    private static string ExpressionFqn;
    private static string ExpressionOfTFqn;
    private static string ParameterExpressionFqn;
    private static string MemberBindingFqn;
    private static string ElementInitFqn;
    private static string FieldInfoFqn;
    private static string MemberInfoFqn;
    private static string MethodInfoFqn;
    private static string ConstructorInfoFqn;
    public IList`1<ILocalVariableReferenceExpression> Captures { get; }
    public ExtractLinqExpressionTransformation(MethodDecompilerContext context, bool applyRewrite);
    public IList`1<ILocalVariableReferenceExpression> get_Captures();
    protected virtual bool DoApply(IMethodCallExpression node);
    private bool Visit(IExpression node);
    private bool VisitExpressionLambda(IMethodCallExpression call);
    private bool VisitExpressionMethod(string methodName, IMethodCallExpression call);
    private bool VisitMemberInit(IMethodCallExpression call, IExpression[] arguments, bool isNested);
    private bool VisitListInit(IExpression call, IExpression[] arguments, bool isNested);
    private bool VisitArrayIndex(IMethodCallExpression call, IExpression[] arguments);
    private bool VisitNewArray(bool isInit, IMethodCallExpression call, IExpression[] arguments);
    private bool VisitArrayLength(IMethodCallExpression call, IExpression[] arguments);
    private bool VisitBinary(IMethodCallExpression call, IExpression[] arguments, OperationType operationType, OverflowCheckType overflowCheckType);
    private bool VisitUnary(IMethodCallExpression call, IExpression[] arguments, OperationType operationType, OverflowCheckType overflowCheckType);
    private bool VisitTypeCast(IMethodCallExpression call, IExpression[] arguments, OverflowCheckType overflowCheckType);
    private bool VisitTypeCheck(bool isCheck, IMethodCallExpression call, IExpression[] arguments);
    private bool VisitNestedQuote(IMethodCallExpression call, IExpression[] arguments);
    private bool VisitConditional(IMethodCallExpression call, IExpression[] arguments);
    private bool VisitNestedLambda(ITypeCastExpression typeCast);
    private bool VisitFieldAccess(IMethodCallExpression call, IExpression[] arguments);
    private bool VisitPropertyAccess(IMethodCallExpression call, IExpression[] arguments);
    private bool VisitMethodCall(IMethodCallExpression call, IExpression[] arguments);
    private bool VisitConstant(IMethodCallExpression call, IExpression[] arguments);
    private bool VisitNewObject(IMethodCallExpression call, IExpression[] arguments);
    private bool VisitDelegateInvoke(IMethodCallExpression call, IExpression[] arguments);
    [NotNullAttribute]
private static IExpression[] IterateArguments(IExpression[] arguments, int index, string arrayTypeFqn);
    private static bool IsEnumerableT(IMetadataType type, string tFqn);
    private bool VisitWithInlineLocal(IExpression expression, Func`2<IExpression, bool> action);
    private bool VisitArguments(IExpression[] arguments, int index);
    [NotNullAttribute]
private static IExpression[] DetachArguments(IExpression[] arguments, int index);
    [CanBeNullAttribute]
private static MethodInstantiation GetMethodInfo(IExpression expression, string typeFqn);
    [CanBeNullAttribute]
private static IMetadataProperty GetPropertyInfo(MethodInstantiation instantiation, bool allowGetter);
    [CanBeNullAttribute]
private static FieldSpecification GetFieldInfo(IExpression expression, string typeFqn);
    [CanBeNullAttribute]
private static TExpression GetSomethingInfo(IExpression expression, string typeFqn, string methodName);
    private bool NotIsLogical(IExpression expression);
    private static bool MatchStaticExpressionTarget(IExpression argument);
    [CanBeNullAttribute]
private static IMethodParameter MatchParameterDefinition(IExpression expression);
}
internal static class JetBrains.Decompiler.Transformations.Expressions.LinqExpressionUtil : object {
    private static string ExpressionFqn;
    public static bool IsExpressionCreation(IMethodCallExpression methodCall);
    public static void ProcessUsagesInExpression(IMethodCallExpression methodCall, HashSet`1<ILocalVariableReferenceExpression> recognizedReferences, Dictionary`2<ILocalVariable, ClosureContext> variableToClosureContext, MethodDecompilerContext context);
}
internal class JetBrains.Decompiler.Transformations.Generics.ExtractConditionalTypeArgumentCreationTransformation : NodeTransformationBase`1<IConditionalExpression> {
    private MetadataTypeCache myTypeCache;
    public ExtractConditionalTypeArgumentCreationTransformation(MetadataTypeCache typeCache);
    protected virtual bool DoApply(IConditionalExpression conditional);
}
internal class JetBrains.Decompiler.Transformations.Generics.ExtractReturnTypeArgumentCreationTransformation : NodeTransformationBase`1<IIfStatement> {
    private MetadataTypeCache myTypeCache;
    public ExtractReturnTypeArgumentCreationTransformation(MetadataTypeCache typeCache);
    protected virtual bool DoApply(IIfStatement ifStatement);
}
internal class JetBrains.Decompiler.Transformations.Generics.ExtractTypeArgumentCreationTransformation : NodeTransformationBase`1<IMethodCallExpression> {
    private MetadataTypeCache myTypeCache;
    public ExtractTypeArgumentCreationTransformation(MetadataTypeCache typeCache);
    protected virtual bool DoApply(IMethodCallExpression methodCall);
}
internal class JetBrains.Decompiler.Transformations.GraphStructure.EliminateEmptyPassthroughBlockTransformation : object {
    public sealed virtual bool Apply(ControlFlowBlock block);
}
internal static class JetBrains.Decompiler.Transformations.GraphStructure.EmptyBlockEliminator : object {
    public static void Run(ControlFlowGraph graph);
    private static void ProcessBlock(ControlFlowBlock block);
}
internal class JetBrains.Decompiler.Transformations.GraphStructure.MergeBlockChainTransformation : object {
    public sealed virtual bool Apply(ControlFlowBlock block);
}
internal class JetBrains.Decompiler.Transformations.GraphStructure.UnreachableBlockEliminator : object {
    private ControlFlowGraph myGraph;
    private JetHashSet`1<ControlFlowBlock> myVisitedBlocks;
    private UnreachableBlockEliminator(ControlFlowGraph graph);
    public static void Run(ControlFlowGraph graph);
    private void Run();
    private void VisitProtectedRegion(ProtectedRegion region);
    private void VisitRegion(ControlFlowRegion region);
    private void VisitBlock(ControlFlowBlock block);
}
internal abstract class JetBrains.Decompiler.Transformations.GraphTransformationBase : object {
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    private bool IsEnabled { get; }
    protected GraphTransformationBase(bool isEnabled);
    public sealed virtual bool Apply(ControlFlowGraph graph);
    protected abstract virtual bool DoApply(ControlFlowGraph graph);
    [CompilerGeneratedAttribute]
private bool get_IsEnabled();
}
internal class JetBrains.Decompiler.Transformations.GraphTransformationPipeline : object {
    private bool myMultiPass;
    private IGraphTransformation[] myTransformations;
    public GraphTransformationPipeline(bool multiPass, IGraphTransformation[] transformations);
    public sealed virtual bool Apply(ControlFlowGraph graph);
}
internal interface JetBrains.Decompiler.Transformations.IBlockTransformation {
    public abstract virtual bool Apply(ControlFlowBlock block);
}
internal interface JetBrains.Decompiler.Transformations.IClassTransformation {
    public abstract virtual bool Apply(IDecompiledClass decompiledClass);
}
internal interface JetBrains.Decompiler.Transformations.IGraphTransformation {
    public abstract virtual bool Apply(ControlFlowGraph graph);
}
internal interface JetBrains.Decompiler.Transformations.INodeTransformation {
    public Type BaseNodeType { get; }
    public abstract virtual Type get_BaseNodeType();
    public abstract virtual bool Apply(INode node);
}
internal class JetBrains.Decompiler.Transformations.Invocation.ExtractFabricatedBaseCallTransformation : NodeTransformationBase`1<IMethodCallExpression> {
    private MethodDecompilerContext myParentDecompilerContext;
    private MethodDecompiler myMethodDecompiler;
    public ExtractFabricatedBaseCallTransformation(MethodDecompilerContext decompilerContext);
    protected virtual bool DoApply(IMethodCallExpression methodCall);
    private static bool CheckBaseCallArguments(IExpression[] arguments);
    private static bool MatchMethodCall(IDecompiledMethod fabricatedMethod, IMethodCallExpression& methodCall);
    private static bool MatchPropertyRead(IMethodCallExpression methodCall, IDecompiledMethod fabricatedMethod, IPropertyAccessExpression& propertyAccess);
    private static bool MatchPropertyWrite(IMethodCallExpression methodCall, IDecompiledMethod fabricatedMethod, IPropertyAccessExpression& propertyAccess, IBinaryOperationExpression& assignment);
    private static bool MatchIndexerRead(IMethodCallExpression methodCall, IDecompiledMethod fabricatedMethod, IIndexerCallExpression& indexerCall);
    private static bool MatchIndexerWrite(IMethodCallExpression methodCall, IDecompiledMethod fabricatedMethod, IIndexerCallExpression& indexerCall, IBinaryOperationExpression& assignment);
    private static bool MatchEventAssignment(IMethodCallExpression methodCall, IDecompiledMethod fabricatedMethod, IEventAccessExpression& eventAccess, IUserDefinedBinaryOperationExpression& binaryOperation);
}
internal static class JetBrains.Decompiler.Transformations.Invocation.InvocationUtil : object {
    public static MethodInstantiation GetMethodInstantiation(IMemberCallExpression memberCall);
    private static MethodInstantiation GetPropertyAccessMethodInstantiation(IMemberCallExpression memberCall, PropertySpecification propertySpecification);
    public static int GetCandidateMethodsCount(MethodSpecification methodSpec, IMetadataType[] methodInstantiationGenericArguments, IMetadataType targetType, IMetadataType[] argumentTypes, bool skipCandidateLastParameter, IMetadataClassType callingType, bool hidingMethodsOnly);
    private static bool ArgumentsAreBetterSuited(Int32[] exactMatch1, Int32[] exactMatch2, bool ignoreRef);
    public static IMetadataType SubstituteGenericArguments(IMetadataType inputType, IMetadataMethod metadataMethod, IMetadataClassType ownerType, IMetadataType[] methodInstantiationGenericArguments);
    public static int GetCandidateWeight(IMetadataMethod candidateMethod, IMetadataType[] argumentTypes, bool skipFirstParameter, bool skipLastParameter, bool testImplicitNumericConversion, Func`2<IMetadataType, IMetadataType> substituteGenericArguments, Int32[]& exactMatch);
    [CanBeNullAttribute]
private static IMetadataArrayType TryGetParamsType(IMetadataParameter[] parameters);
    private static int GetOptionalParametersCount(IMetadataParameter[] parameters);
    private static bool IsAssignmentCompatibleWith_Unresolved(IMetadataParameter candidateMethodParameter, Func`2<IMetadataType, IMetadataType> substituteGenericArguments, IMetadataType argumentType, bool testImplicitNumericConversion, Int32& exactMatch);
    private static bool IsAssignmentCompatibleWith_Unresolved(IMetadataType weakerType, IMetadataType strongerType, bool testImplicitNumericConversion, bool isInputParameter, Int32& exactMatch);
    private static bool IsMethodVisible(IMetadataMethod candidateMethod, IMetadataType callingType, IMetadataType targetType);
    private static bool IsInternalsVisibleTo(IMetadataType internalType, IMetadataType consumingType);
    [CanBeNullAttribute]
public static MethodSpecification GetMethod(IArgumentable invocationExpression, ExpressionTyper expressionTyper, Int32& ownParametersCount, IMetadataClassType& ownerType, IMetadataClassType& targetType, IMetadataType[]& methodInstantiationGenericArguments);
    private static MethodSpecification GetMethod(PropertySpecification propertySpec, Int32& ownParametersCount);
    [CanBeNullAttribute]
private static IMetadataClassType GetTargetType(IExpression target, ExpressionTyper expressionTyper);
    public static bool CanBeUsedWithInModifier(IExpression argument, ExpressionTyper expressionTyper);
}
internal class JetBrains.Decompiler.Transformations.Invocation.MarkExtensionMethodCallTransformation : NodeTransformationBase`1<IMethodCallExpression> {
    public static DataKey`1<bool> IsExtensionMethodKey;
    private static MarkExtensionMethodCallTransformation();
    protected virtual bool DoApply(IMethodCallExpression methodCall);
}
internal class JetBrains.Decompiler.Transformations.Invocation.MarkForcedNonVirtualCallTransformation : NodeTransformationBase`1<IMemberCallExpression> {
    public static DataKey`1<bool> ForcedNonVirtualKey;
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    public MarkForcedNonVirtualCallTransformation(MetadataTypeCache typeCache, ExpressionTyper expressionTyper);
    private static MarkForcedNonVirtualCallTransformation();
    protected virtual bool DoApply(IMemberCallExpression memberCall);
    private bool IsForcedNonVirtual(IMemberCallExpression memberCall);
}
internal class JetBrains.Decompiler.Transformations.Invocation.OptimizeExtensionMethodCallTransformation : object {
    public static DataKey`1<bool> CanRenderAsExtensionMethodKey;
    private PreRenderOptimizationsContext myContext;
    private IMetadataTypeInfo myCallingTypeInfo;
    public Type BaseNodeType { get; }
    public OptimizeExtensionMethodCallTransformation(PreRenderOptimizationsContext context, IMetadataTypeInfo callingTypeInfo);
    private static OptimizeExtensionMethodCallTransformation();
    public sealed virtual Type get_BaseNodeType();
    public sealed virtual bool Apply(INode node);
    private bool HasCollisions(IMethodCallExpression methodCall);
    private IMetadataType GetExpressionType(IExpression expression);
    private static int GetCandidateInstanceMethodsCount(MethodInstantiation extensionMethodInstantiation, IMetadataType targetType, IMetadataType[] argumentTypes, IMetadataClassType callingType);
    private List`1<IMetadataMethod> GetCandidateImplicitlyImportedExtensionMethods(MethodInstantiation extensionMethodInstantiation, IMetadataType targetType, IMetadataType[] argumentTypes, IMetadataClassType callingType);
    private List`1<IMetadataMethod> GetCandidateExtensionMethods(MethodInstantiation extensionMethodInstantiation, IMetadataType targetType, IMetadataType[] argumentTypes);
    private List`1<IMetadataMethod> GetCandidateExtensionMethods(MethodInstantiation extensionMethodInstantiation, IMetadataType targetType, IMetadataType[] argumentTypes, IEnumerable`1<IMetadataMethod> extensionMethodsWithSameName);
    private static IMetadataType UnwrapFromReference(IMetadataType type);
    [CompilerGeneratedAttribute]
private bool <GetCandidateExtensionMethods>b__11_0(IMetadataMethod m);
}
internal class JetBrains.Decompiler.Transformations.Invocation.OptionalArgumentsRemover : object {
    public static void Run(IDecompiledMethodBase decompiledMethod, ExpressionTyper expressionTyper);
    private static void RemoveOptionalArguments(IArgumentable node, MethodSpecification methodSpec, IMetadataClassType ownerType, IMetadataClassType targetType, IMetadataClassType callingType, IMetadataType[] methodInstantiationGenericArguments, bool ignoreLastParameter, ExpressionTyper expressionTyper);
    private static bool CanSkip(IExpression argument, IMetadataParameter defaultValueProvider, IMetadataType parameterType);
    private static bool IsDefaultValue(ILiteralExpression literal, IMetadataParameter defaultValueProvider, IMetadataType parameterType);
}
internal class JetBrains.Decompiler.Transformations.Invocation.ParameterModifiersInserter : object {
    private ReferencesFinder myReferencesFinder;
    private ExpressionTyper myExpressionTyper;
    private ParameterModifiersInserter(MethodDecompilerContext methodDecompilerContext);
    public static void Run(IDecompiledMethodBase method, MethodDecompilerContext methodDecompilerContext);
    private void Run(IDecompiledMethodBase method);
    private void ProcessArguments(IMetadataMethod method, int parametersCount, IExpression[] arguments);
    private void ProcessArgument(IExpression expression, ParameterModifierKind modifierKind);
    [CompilerGeneratedAttribute]
private void <Run>b__4_0(IArgumentable node);
}
internal class JetBrains.Decompiler.Transformations.Invocation.ReduceParamArrayTransformation : NodeTransformationBase`1<IArgumentable> {
    private ExpressionTyper myExpressionTyper;
    public ReduceParamArrayTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IArgumentable call);
    [CanBeNullAttribute]
private static IMetadataParameter GetParamArrayParameter(IMetadataMethod method);
}
internal class JetBrains.Decompiler.Transformations.Iterators.ExtractIteratorTransformation : ExtractIteratorTransformationBase`1<IteratorContext> {
    protected string IteratorStateMachineAttributeName { get; }
    protected string IteratorDebugName { get; }
    protected MethodDecompilerMode MoveNextMethodDecompilerMode { get; }
    public ExtractIteratorTransformation(MethodDecompilerContext decompilerContext);
    protected virtual bool GuessTypesFromReturn(IMetadataType returnType, IMetadataClassType& enumeratorType, IMetadataClassType& enumerableType);
    private void ConstructTypesFromElement(IMetadataType elementType, IMetadataClassType& enumeratorType, IMetadataClassType& enumerableType);
    protected virtual string get_IteratorStateMachineAttributeName();
    protected virtual string get_IteratorDebugName();
    protected virtual bool IsGetCurrent(IMetadataMethod method);
    protected virtual bool IsGetEnumerator(IMetadataMethod method);
    protected virtual MethodDecompilerMode get_MoveNextMethodDecompilerMode();
    protected virtual IStatement GetStateFieldAssignment(IBlockStatement ctorBody, IteratorContext iteratorContext);
}
internal abstract class JetBrains.Decompiler.Transformations.Iterators.ExtractIteratorTransformationBase`1 : NodeTransformationBase`1<IDecompiledMethodBase> {
    protected MethodDecompilerContext DecompilerContext;
    protected string IteratorStateMachineAttributeName { get; }
    protected string IteratorDebugName { get; }
    protected MethodDecompilerMode MoveNextMethodDecompilerMode { get; }
    protected ExtractIteratorTransformationBase`1(MethodDecompilerContext decompilerContext);
    protected virtual bool DoApply(IDecompiledMethodBase method);
    protected abstract virtual bool GuessTypesFromReturn(IMetadataType returnType, IMetadataClassType& enumeratorType, IMetadataClassType& enumerableType);
    protected virtual void MarkIterator(IDecompiledMethodBase method);
    protected abstract virtual string get_IteratorStateMachineAttributeName();
    private bool CreateContexts(IObjectCreationExpression iteratorCreation, IMetadataClassType iteratorType, IMetadataClassType enumerableType, List`1<Action> mutations, ClosureContext& closureContext, TIteratorContext& iteratorContext);
    protected abstract virtual string get_IteratorDebugName();
    protected virtual void AddGeneratedFields(JetHashSet`1<IMetadataField> generatedFields, TIteratorContext iteratorContext);
    protected IDecompiledMethod Decompile(IMetadataMethod method);
    private bool GuessFromGetEnumerator(IMetadataClassType iteratorType, TIteratorContext iteratorContext, Dictionary`2& secondaryToPrimary);
    protected virtual bool MatchSecondaryFieldInit(IStatement statement, TIteratorContext iteratorContext, IMetadataField& secondaryField, IMetadataField& primaryField);
    protected abstract virtual bool IsGetEnumerator(IMetadataMethod method);
    private void AddFieldDependency(Dictionary`2<IMetadataField, IMetadataField> secondaryToPrimary, IMetadataField secondaryField, IMetadataField primaryField);
    private bool GuessFromCtor(IMetadataClassType iteratorType, TIteratorContext iteratorContext, IMetadataField& threadIdField);
    protected static bool MatchThisField(IExpression expression, IMetadataField& field);
    protected abstract virtual IStatement GetStateFieldAssignment(IBlockStatement ctorBody, TIteratorContext iteratorContext);
    protected virtual bool GuessFromOtherMethods(IMetadataClassType iteratorType, TIteratorContext iteratorContext);
    private bool GuessFromGetCurrent(IMetadataClassType iteratorType, TIteratorContext iteratorContext);
    protected abstract virtual bool IsGetCurrent(IMetadataMethod method);
    private bool DecompileIteratorBody(IMetadataClassType iteratorType, IDecompiledMethodBase method, ClosureContext closureContext, IteratorContext iteratorContext, List`1<Action> mutations);
    protected abstract virtual MethodDecompilerMode get_MoveNextMethodDecompilerMode();
    [CompilerGeneratedAttribute]
private bool <GuessFromGetEnumerator>b__12_0(IMetadataMethod aMethod);
    [CompilerGeneratedAttribute]
private bool <GuessFromGetCurrent>b__20_1(IMetadataMethod getter);
}
internal interface JetBrains.Decompiler.Transformations.Iterators.IIteratorDecompiler {
    [NotNullAttribute]
public MethodDecompilerContext DecompilerContext { get; }
    [NotNullAttribute]
public IteratorContext IteratorContext { get; }
    public abstract virtual MethodDecompilerContext get_DecompilerContext();
    public abstract virtual IteratorContext get_IteratorContext();
    public abstract virtual bool IsSplitStatement(IStatement statement, Int32& successorState);
}
internal class JetBrains.Decompiler.Transformations.Iterators.IteratorDecompiler : object {
    private static int StartState;
    private static int FinishState;
    [CompilerGeneratedAttribute]
private MethodDecompilerContext <DecompilerContext>k__BackingField;
    private IteratorStates myIteratorStates;
    private Dictionary`2<IMetadataMethod, FinallyHandler> myMethodToFinallyHandler;
    private ILocalVariable myResultVariable;
    private ControlFlowBlock myReturnResultVariableBlock;
    private bool myEmptyDisposeExpected;
    private IMetadataMethod myDisposeMethod;
    public MethodDecompilerContext DecompilerContext { get; }
    public IteratorContext IteratorContext { get; }
    private IteratorDecompiler(MethodDecompilerContext decompilerContext);
    public static bool Run(MethodDecompilerContext context);
    [CompilerGeneratedAttribute]
public sealed virtual MethodDecompilerContext get_DecompilerContext();
    public sealed virtual IteratorContext get_IteratorContext();
    private bool Run();
    private bool ExtractEmptySequenceIterator();
    public sealed virtual bool IsSplitStatement(IStatement statement, Int32& successorState);
    private bool AnalyzeSwitchBlock();
    private void ReplaceResultVariableAssignmentWithReturn();
    private bool ExtractYield(ControlFlowBlock block, bool terminateOrJump);
    private bool ExtractYields();
    private void SplitYieldBreakBlocks();
    private static bool ExtractYieldBreak(ControlFlowBlock block, IStatement statement);
    private bool ExtractYieldReturn(ControlFlowBlock block, IStatement lastStatement);
    private bool IsIteratorDisposeMethod(IMetadataMethod method);
    private bool IsIteratorTryFaultRegion(ProtectedRegion protectedRegion);
    private bool AnalyzeExceptionRegions();
    private bool AnalyzeFinallyHandlers();
    private void EliminateExplicitDisposeCalls();
    private bool AnalyzeDispose();
    private bool AnalyzeDispose(IBlockStatement handlerStatement, ILocalVariable stateVariable);
    private bool CollectStateValues(List`1<int> stateValues, IIfStatement ifStatement, ILocalVariable stateVariable);
    private bool CollectStateValues(List`1<int> stateValues, IExpression expression, ILocalVariable stateVariable);
    private static bool CollectStateValues(List`1<int> stateValues, ISwitchCase switchCase);
    private static bool MatchIfAndTry(IStatement statement, IIfStatement& ifStatement, ITryStatement& tryStatement);
    private bool AnalyzeIfAndTry(IIfStatement ifStatement, ITryStatement tryStatement, ILocalVariable stateVariable);
    private bool MatchStateAccess(IExpression expression, ILocalVariable stateVariable);
    private bool AnalyzeCaseInDispose(IStatement statement, IEnumerable`1<int> stateValues, ILocalVariable stateVariable);
    private bool ConstructProtectedRegion(IEnumerable`1<ControlFlowBlock> body, FinallyHandler finallyHandler);
    private static ControlFlowBlock ComputeEntryBlock(IEnumerable`1<ControlFlowBlock> body);
    private ControlFlowBlock ConstructFinallyClauseBlock(ControlFlowRegion parentRegion, FinallyHandler finallyHandler);
    private bool MatchStateFieldAccess(IExpression expression);
    private bool MatchCurrentFieldAccess(IExpression expression);
}
internal static class JetBrains.Decompiler.Transformations.Iterators.IteratorFinallyClauseDecompiler : object {
    public static bool Run(MethodDecompilerContext decompilerContext);
    private static void CombineReturns(MethodDecompilerContext decompilerContext);
}
internal class JetBrains.Decompiler.Transformations.Iterators.IteratorStates : object {
    private IIteratorDecompiler myIteratorDecompiler;
    private Nullable`1<int> mySpecialState;
    [CompilerGeneratedAttribute]
private Dictionary`2<ControlFlowRegion, Dictionary`2<int, ControlFlowBlock>> <EntryStateToBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private OneToSetMap`2<int, ControlFlowBlock> <StateToBlocks>k__BackingField;
    private Dictionary`2<ControlFlowBlock, int> myBlockToState;
    private JetHashSet`1<ControlFlowBlock> myBlocksWithPropagatedState;
    public Dictionary`2<ControlFlowRegion, Dictionary`2<int, ControlFlowBlock>> EntryStateToBlock { get; }
    public OneToSetMap`2<int, ControlFlowBlock> StateToBlocks { get; }
    public IteratorStates(IIteratorDecompiler iteratorDecompiler, Nullable`1<int> specialState);
    [CompilerGeneratedAttribute]
public Dictionary`2<ControlFlowRegion, Dictionary`2<int, ControlFlowBlock>> get_EntryStateToBlock();
    [CompilerGeneratedAttribute]
public OneToSetMap`2<int, ControlFlowBlock> get_StateToBlocks();
    public bool SplitBlocksByStateTransitions();
    private bool SplitBlockByStateTransition(ControlFlowBlock block);
    public bool PropagateStates();
    private bool PropagateStateDfs(ControlFlowBlock block, int state);
    private bool PropagateStateDfsStep(ControlFlowBlock successor, int state);
    private bool AssignStateToBlock(ControlFlowBlock block, int state, bool setBlockToState);
    public bool AssignEntryStateToBlock(ControlFlowBlock block, int state, bool setBlockToState);
    public bool TryGetBlock(ControlFlowRegion region, int state, ControlFlowBlock& block);
    public void RemoveRegion(ControlFlowRegion region);
    private void AssignPropagatedStateToBlock(ControlFlowBlock block, int state);
}
internal class JetBrains.Decompiler.Transformations.Literals.ConvertDecimalCreationToDecimalLiteralTransformation : NodeTransformationBase`1<IObjectCreationExpression> {
    private MetadataTypeCache myTypeCache;
    public ConvertDecimalCreationToDecimalLiteralTransformation(MetadataTypeCache typeCache);
    protected virtual bool DoApply(IObjectCreationExpression node);
    private bool TryGetDecimal(IExpression expression, Decimal& decimalValue);
    private bool TryGetInt(IExpression expression, Int32& intValue);
    private bool TryGetBool(IExpression expression, Boolean& boolValue);
    private bool TryGetByte(IExpression expression, Byte& byteValue);
}
internal class JetBrains.Decompiler.Transformations.Literals.ConvertDecimalFieldToDecimalLiteralTransformation : NodeTransformationBase`1<IFieldAccessExpression> {
    private MetadataTypeCache myTypeCache;
    public ConvertDecimalFieldToDecimalLiteralTransformation(MetadataTypeCache typeCache);
    protected virtual bool DoApply(IFieldAccessExpression node);
}
internal class JetBrains.Decompiler.Transformations.Literals.ReduceLiteralsToFractionsTransformation : NodeTransformationBase`1<ILiteralExpression> {
    private static double GoodEnoughEpsilon;
    private static double GoodEnoughEpsilonForFloat;
    private static int MaximumDenominator;
    private static int MaximumNumerator;
    private MetadataTypeCache myTypeCache;
    private bool myIsDouble;
    public ReduceLiteralsToFractionsTransformation(MetadataTypeCache typeCache);
    protected virtual bool DoApply(ILiteralExpression literal);
    private bool PresentRationalConstant(ILiteralExpression currentLiternal, double value);
    private bool PresentConstant(ILiteralExpression currentLiternal, double value, double constant, double epsilon, IMetadataField constantField);
    private bool PresentProduct(ILiteralExpression currentLiternal, double value, double constant, double epsilon, IMetadataField constantField);
    private bool PresentDivision(ILiteralExpression currentLiternal, double value, double constant, double epsilon, IMetadataField constantField);
    private bool CheckRational(Rational rational);
    private ILiteralExpression CreateLiteral(long l, IInstructionReference instructionReference);
}
internal class JetBrains.Decompiler.Transformations.Literals.ReduceWellKnownLiteralTransformation : NodeTransformationBase`1<ILiteralExpression> {
    private Dictionary`2<object, ConstantInfo> myValueToField;
    public ReduceWellKnownLiteralTransformation(MetadataTypeCache typeCache);
    protected virtual bool DoApply(ILiteralExpression literal);
}
internal static class JetBrains.Decompiler.Transformations.LocalVariables.DiscardsInserter : object {
    public static void Run(IDecompiledMethodBase method, ReferencesFinder finder);
    private static void ReplaceWithDiscard(ILocalVariableReferenceExpression reference, bool explicitType);
}
internal class JetBrains.Decompiler.Transformations.LocalVariables.EliminateUnusedLocalVariablesAssignmentTransformation : NodeTransformationBase`1<IDecompiledMethodBase> {
    private ExpressionTyper myExpressionTyper;
    private ReferencesFinder myFinder;
    public EliminateUnusedLocalVariablesAssignmentTransformation(ExpressionTyper expressionTyper, ReferencesFinder finder);
    protected virtual bool DoApply(IDecompiledMethodBase method);
    private bool PerformElimination(IBinaryOperationExpression assignment);
    private static bool IsConstant(IExpression expression);
    private static bool IsConstantFieldAccess(IFieldAccessExpression fieldAccessExpression);
}
internal class JetBrains.Decompiler.Transformations.LocalVariables.EvaluationSequence : object {
    [CompilerGeneratedAttribute]
private List`1<ILocalVariableReferenceExpression> <VariableReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsComplete>k__BackingField;
    public List`1<ILocalVariableReferenceExpression> VariableReferences { get; }
    public bool IsComplete { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<ILocalVariableReferenceExpression> get_VariableReferences();
    [CompilerGeneratedAttribute]
public bool get_IsComplete();
    [CompilerGeneratedAttribute]
public void set_IsComplete(bool value);
}
internal class JetBrains.Decompiler.Transformations.LocalVariables.InlineArrayInitializersTransformation : NodeTransformationBase`1<IArrayCreationExpression> {
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myFinder;
    private IImageBodyReader myImageBodyReader;
    public InlineArrayInitializersTransformation(MetadataTypeCache typeCache, ReferencesFinder finder, IImageBodyReader imageBodyReader);
    protected virtual bool DoApply(IArrayCreationExpression arrayCreation);
    private bool MatchIndices(List`1<InlineCandidate> inlineCandidates, IExpression[] indices, bool mainExpressionIsAlreadyInlined);
}
internal class JetBrains.Decompiler.Transformations.LocalVariables.InlineCandidate : object {
    private ILocalVariable myTempVariable;
    private IExpression myExpression;
    private IStatement myStatementToRemove;
    [CompilerGeneratedAttribute]
private ILocalVariableReferenceExpression <TempVariableUsageToReplace>k__BackingField;
    public ILocalVariableReferenceExpression TempVariableUsageToReplace { get; public set; }
    public InlineCandidate(ILocalVariable tempVariable, IExpression expression, IStatement statementToRemove);
    [CompilerGeneratedAttribute]
public ILocalVariableReferenceExpression get_TempVariableUsageToReplace();
    [CompilerGeneratedAttribute]
public void set_TempVariableUsageToReplace(ILocalVariableReferenceExpression value);
    public bool MatchVariable(ILocalVariable variable);
    public bool ExpressionCanChangeState();
    public void Inline();
}
internal class JetBrains.Decompiler.Transformations.LocalVariables.InlineCollectionInitializersTransformation : NodeTransformationBase`1<IObjectCreationExpression> {
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myFinder;
    public InlineCollectionInitializersTransformation(MetadataTypeCache typeCache, ReferencesFinder finder);
    protected virtual bool DoApply(IObjectCreationExpression objectCreation);
    private static bool MatchArguments(List`1<InlineCandidate> inlineCandidates, IExpression[] arguments);
}
internal class JetBrains.Decompiler.Transformations.LocalVariables.InlineExceptionVariableTransformation : NodeTransformationBase`1<ICatchClause> {
    private ReferencesFinder myFinder;
    public InlineExceptionVariableTransformation(ReferencesFinder finder);
    protected virtual bool DoApply(ICatchClause catchClause);
}
internal class JetBrains.Decompiler.Transformations.LocalVariables.InlineLiteralTransformation : InlineTransformationBase`1<ILiteralExpression> {
    public InlineLiteralTransformation(ReferencesFinder finder);
}
internal class JetBrains.Decompiler.Transformations.LocalVariables.InlineLocalVariablesTransformation : object {
    private ExpressionTyper myExpressionTyper;
    private ReferencesFinder myFinder;
    private List`1<InliningCandidate> myCandidates;
    private bool myChanged;
    private MethodDecompilerContext myMethodDecompilerContext;
    public Type BaseNodeType { get; }
    public InlineLocalVariablesTransformation(MethodDecompilerContext decompilerContext);
    public sealed virtual Type get_BaseNodeType();
    public sealed virtual bool Apply(INode node);
    private void ProcessFragment(SequentialFragment fragment);
    private void ProcessNode(INode node);
    private void CreateCandidateFromNode(INode node);
    private bool InlineProxyFromNode(INode node);
    private void InlineForNode(INode node);
    private int GetCandidatesStackIndex(ILocalVariable variable);
    private InliningCandidate GetCandidateFromNode(INode node);
    private static bool IsExpressionSuitableForInlining(IExpression expression);
    private bool IsVariableSuitableForInlining(ILocalVariable variable);
    private EvaluationSequence GetEvaluationSequence(INode node);
    private void Traverse(INode node, EvaluationSequence evaluationSequence);
    private static bool ShouldSkip(INode node);
    private static bool ShouldStopAtNode(INode node);
    private bool CanBeInlined(IRefExpression refExpression, ILocalVariableReferenceExpression refArgumentVariableReference);
    [CanBeNullAttribute]
private ILocalVariableReferenceExpression GetAnotherReference(ILocalVariableReferenceExpression variableReference);
    private bool IsParameterWithInModifier(INode expression, MethodSpecification& methodSpec, IArgumentable& invocationExpression, INode& argument, IMetadataClassType& targetType, IMetadataType[]& methodInstantiationGenericArguments);
    private bool HasOverloadingConflictsWithoutInModifier(MethodSpecification methodSpec, IArgumentable invocationExpression, INode argument, IMetadataClassType targetType, IMetadataType[] methodInstantiationGenericArguments);
}
internal class JetBrains.Decompiler.Transformations.LocalVariables.InlineMemberInitializersTransformation : NodeTransformationBase`1<IObjectCreationExpression> {
    private ReferencesFinder myFinder;
    public InlineMemberInitializersTransformation(ReferencesFinder finder);
    protected virtual bool DoApply(IObjectCreationExpression objectCreation);
}
internal class JetBrains.Decompiler.Transformations.LocalVariables.InlineThisTransformation : InlineTransformationBase`1<IThisReferenceExpression> {
    public InlineThisTransformation(ReferencesFinder finder);
}
internal class JetBrains.Decompiler.Transformations.LocalVariables.InlineTransformationBase`1 : NodeTransformationBase`1<T> {
    private ReferencesFinder myFinder;
    public InlineTransformationBase`1(ReferencesFinder finder);
    protected virtual bool DoApply(T expression);
}
internal static class JetBrains.Decompiler.Transformations.LocalVariables.InlineUtil : object {
    public static bool TryInlineImmutableVariable(ReferencesFinder finder, IStatement possibleCopyAssignment, ILocalVariableReferenceExpression immutableVariableDeclaration);
    public static bool TryInlineThisReference(ReferencesFinder finder, IThisReferenceExpression thisReference, IEnumerable`1<ILocalVariable> forbiddenVariables);
    public static bool ExpressionCanChangeState(IExpression expression);
    public static List`1<InlineCandidate> CollectInlineCandidates(IStatement& currentStatement, ReferencesFinder finder);
    public static void InlineIteratorVariables(MethodDecompilerContext context);
}
internal class JetBrains.Decompiler.Transformations.LocalVariables.LocalVariablesDeclarationsInserter : object {
    private IDecompiledMethodBase myMethod;
    private ReferencesFinder myFinder;
    private NodeTreeAnalyzer myNodeTreeAnalyzer;
    private List`1<Action> myInitDeclarationMutations;
    private List`1<Action> myUninitDeclarationMutations;
    private Dictionary`2<ILocalVariable, Nullable`1<LocalVariableDeclarationModifierKind>> myVariableModifierKinds;
    private OneToSetMap`2<ILocalVariable, ILocalVariable> myVarToVars;
    private LocalVariablesDeclarationsInserter(IDecompiledMethodBase method, ReferencesFinder finder);
    public static void Run(IDecompiledMethodBase method, ReferencesFinder finder);
    private void Run();
    public static bool NeedsDeclaration(ILocalVariable variable);
    [NotNullAttribute]
public static IStatement AdjustWithDeclarationScope(IStatement declarationPoint, ILocalVariableDeclarationScope declarationScope);
    private void DeclareLocalVariable(ILocalVariable variable, IStatement statement);
    private void RegisterInitVariableMutation(IBinaryOperationExpression assignmentExpression, ILocalVariable variable);
    private Nullable`1<LocalVariableDeclarationModifierKind> DetectAndPropagateDeclarationModifier(IExpression variableInitializer, ILocalVariable variable);
    private Nullable`1<LocalVariableDeclarationModifierKind> DetectDeclarationModifier(IExpression variableInitializer, ILocalVariable variable);
    private static bool IsReadonlyResult(IMemberAccessExpression memberAccess);
    private static bool IsReadonlyResult(IMethodCallBaseExpression methodCall);
    private void RegisterUninitVariableMutation(IStatement declareBefore, ILocalVariable variable);
    private void RunMutations();
}
internal class JetBrains.Decompiler.Transformations.LocalVariables.LocalVariablesTyper : object {
    private ControlFlowGraph myGraph;
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    private bool myHasChanges;
    private LocalVariablesTyper(ControlFlowGraph graph, ExpressionTyper expressionTyper, MetadataTypeCache typeCache);
    public static void Run(ControlFlowGraph graph, ExpressionTyper expressionTyper, MetadataTypeCache typeCache);
    private void Run();
    private void ProcessAssignment(Assignment assignment);
    [CanBeNullAttribute]
private IMetadataType UnifyTypes(IMetadataType type1, IMetadataType type2);
    private IMetadataType UnifyTypesDirectly(IMetadataType type1, IMetadataType type2);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Transformations.LocalVariables.LocalVariablesTyper/<ReduceTypeConstraints>d__11")]
private IEnumerable`1<IMetadataType> ReduceTypeConstraints(IMetadataType type);
}
internal class JetBrains.Decompiler.Transformations.LocalVariables.SequentialFragment : object {
    [CompilerGeneratedAttribute]
private INode[] <Nodes>k__BackingField;
    public INode[] Nodes { get; }
    public SequentialFragment(INode[] nodes);
    [CompilerGeneratedAttribute]
public INode[] get_Nodes();
}
internal class JetBrains.Decompiler.Transformations.LocalVariables.SequentialFragmentPartitioner : object {
    private IList`1<SequentialFragment> myFragments;
    private IList`1<INode> myCurrentFragmentNodes;
    public static IList`1<SequentialFragment> Run(INode root);
    private void VisitNode(INode root);
    private void VisitChildren(INode node);
    private void AddNode(INode node);
    private void FlushFragment();
}
internal static class JetBrains.Decompiler.Transformations.LocalVariables.UnreferencedLocalVariableEliminator : object {
    public static void Run(IDecompiledMethodBase method, ReferencesFinder finder);
}
internal class JetBrains.Decompiler.Transformations.Lock.ExtractLock20Transformation : CondNodeTransformationBase`1<ITryStatement> {
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myFinder;
    public ExtractLock20Transformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(ITryStatement tryStatement);
}
internal class JetBrains.Decompiler.Transformations.Lock.ExtractLock40Transformation : CondNodeTransformationBase`1<ITryStatement> {
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myFinder;
    public ExtractLock40Transformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(ITryStatement tryStatement);
}
internal class JetBrains.Decompiler.Transformations.Lock.ExtractLockNull20Transformation : CondNodeTransformationBase`1<ITryStatement> {
    private MetadataTypeCache myTypeCache;
    public ExtractLockNull20Transformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(ITryStatement tryStatement);
}
internal class JetBrains.Decompiler.Transformations.Lock.ExtractLockNull40Transformation : CondNodeTransformationBase`1<ITryStatement> {
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myFinder;
    public ExtractLockNull40Transformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(ITryStatement tryStatement);
}
internal static class JetBrains.Decompiler.Transformations.Lock.LockUtils : object {
    public static bool IsMonitorExit(IMetadataMethod method);
    public static bool IsMonitorEnter1(IMetadataMethod method);
    public static bool IsMonitorEnter2(IMetadataMethod method);
}
internal class JetBrains.Decompiler.Transformations.Loops.EliminateRedundantContinueTransformation : NodeTransformationBase`1<IAbstractLoopStatement> {
    protected virtual bool DoApply(IAbstractLoopStatement loop);
    private static bool IsFollowedByNextIteration(IStatement statement);
}
internal class JetBrains.Decompiler.Transformations.Loops.ExtractAwaitForEachTransformation : ExtractForEachTransformationBase`1<ILoopStatement> {
    [CanBeNullAttribute]
private TupleElementNameManager myTupleElementNameManager;
    public ExtractAwaitForEachTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(ILoopStatement loop);
    [CanBeNullAttribute]
private static IStatement GetLoopBody(ILoopStatement loop, IExpression& condition);
    [CanBeNullAttribute]
private static IStatement GetEnumeratorAssignment(ILoopStatement loop, IStatement& middleStatement, ITryStatement& tryStatement);
    private void InlineConfiguredCancelableCollection(IExpression& collection, IMetadataType elementType, IStatement enumeratorAssignmentStatement);
    private static bool IsAwaitEnumeratorMoveNextAsync(IExpression condition, ILocalVariable enumerator);
    private static bool MatchGetAsyncEnumeratorCall(IExpression expression, IMethodCallExpression& getAsyncEnumeratorCall);
    [CompilerGeneratedAttribute]
internal static IExpression <InlineConfiguredCancelableCollection>g__GetRealCollection|5_0(IStatement tempAssignmentStatement, ILocalVariable temp, IMetadataClassType configuredCancelableAsyncEnumerable);
    [CompilerGeneratedAttribute]
internal static ILocalVariable <InlineConfiguredCancelableCollection>g__GetTempVariable|5_1(IExpression collection, IMetadataType elementType, IMetadataClassType& configuredCancelableAsyncEnumerable);
    [CompilerGeneratedAttribute]
internal static bool <InlineConfiguredCancelableCollection>g__IsConfiguredCancelableAsyncEnumerable|5_2(IMetadataType type, IMetadataType elementType, IMetadataClassType& configuredCancelableAsyncEnumerable);
}
internal class JetBrains.Decompiler.Transformations.Loops.ExtractEnumerableForEachTransformation : ExtractForEachTransformationBase`1<ILoopStatement> {
    private ExpressionTyper myExpressionTyper;
    [CanBeNullAttribute]
private TupleElementNameManager myTupleElementNameManager;
    private MetadataTypeCache myTypeCache;
    private MethodSpecification myDisposeSpecification;
    private MethodSpecification DisposeSpecification { get; }
    public ExtractEnumerableForEachTransformation(MethodDecompilerContext methodDecompilerContext);
    private MethodSpecification get_DisposeSpecification();
    protected virtual bool DoApply(ILoopStatement node);
    private bool CheckLoop(ILoopStatement loop, ILocalVariable enumerator);
    private bool CheckTryFinally(ITryStatement tryStatement, ILocalVariable enumerator, IMetadataClassType enumeratorType);
    private static bool MatchGetEnumeratorCall(IExpression expression, IMethodCallExpression& getEnumeratorCall);
    [CanBeNullAttribute]
private IExpression UnwrapUnresolvedStructTypeCast(IExpression expression);
    private bool IsIfNotNullDispose(IIfStatement if, ILocalVariable disposable, bool maybeTargetCastToIDisposable);
    private bool IsTryCastToIDisposable(IExpression expression, ILocalVariable argument);
}
internal abstract class JetBrains.Decompiler.Transformations.Loops.ExtractForEachTransformationBase`1 : CondNodeTransformationBase`1<T> {
    protected ReferencesFinder myFinder;
    protected LocalVariableManager myLocalVariableManager;
    protected ExtractForEachTransformationBase`1(MethodDecompilerContext methodDecompilerContext);
    [NotNullAttribute]
private ILocalVariable InlineItemVariable(ILocalVariableReferenceExpression itemReference, IStatement loopBody, Boolean& inlined);
    private ILocalVariable PrepareItemVariable(IExpression itemAccess, IMetadataType basicItemType, ILocalVariable existingVariable);
    [CanBeNullAttribute]
private ILocalVariable FindReducedItemLocalVariable(IInstructionReference itemAccessInstructionReference);
    private static bool SkipBeforeStloc(Instruction instruction);
    protected ILocalVariable PrepareItemVariableAndReplaceItemAccess(IExpression itemAccess, IMetadataType basicItemType, IStatement loopBody);
}
internal class JetBrains.Decompiler.Transformations.Loops.ExtractIndexForEachTransformation : ExtractForEachTransformationBase`1<IForStatement> {
    private MetadataTypeCache myTypeCache;
    public ExtractIndexForEachTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(IForStatement forStatement);
    private IMetadataProperty GetLengthProperty(IMetadataType listType);
    [CanBeNullAttribute]
private static IExpression GetListAccess(IEnumerable`1<ILocalVariableReferenceExpression> references);
    private bool ValidateListAccess(IExpression expression, ILocalVariable listVariable, ILocalVariable indexVariable);
    private IMetadataType GetElementType(IMetadataType listType);
    private ILocalVariable PrepareItemVariable(IForStatement forStatement, IExpression itemAccess, IMetadataType itemType);
    private ILocalVariable GuessExistingItemVariable(IForStatement forStatement, IExpression listAccess, IMetadataType itemType);
}
internal abstract class JetBrains.Decompiler.Transformations.NodeTransformationBase`1 : object {
    private DataKey`1<bool> AppliedToNode;
    public Type BaseNodeType { get; }
    protected bool IsEnabled { get; }
    protected bool ApplyOnce { get; }
    public sealed virtual Type get_BaseNodeType();
    public sealed virtual bool Apply(INode node);
    protected abstract virtual bool DoApply(T node);
    protected void SuppressApply(INode node);
    protected virtual bool get_IsEnabled();
    protected virtual bool get_ApplyOnce();
}
internal class JetBrains.Decompiler.Transformations.NodeTransformationPipeline : object {
    private bool myMultiPass;
    private InterruptionChecker myInterruptionChecker;
    private IEnumerable`1<INodeTransformation> myTransformations;
    public Type BaseNodeType { get; }
    public NodeTransformationPipeline(bool multiPass, InterruptionChecker interruptionChecker, INodeTransformation[] transformations);
    public sealed virtual Type get_BaseNodeType();
    public sealed virtual bool Apply(INode node);
}
internal class JetBrains.Decompiler.Transformations.NullCoalescing.ExtractNullCoalescingAssignmentTransformation : object {
    private DecompilerOptions myDecompilerOptions;
    public ExtractNullCoalescingAssignmentTransformation(DecompilerOptions decompilerOptions);
    public sealed virtual bool Apply(ControlFlowBlock branchBlock);
}
internal class JetBrains.Decompiler.Transformations.NullCoalescing.ExtractNullCoalescingReturnTransformation : object {
    private MetadataTypeCache myTypeCache;
    private IDecompiledMethodBase myMethod;
    private DecompilerOptions myDecompilerOptions;
    public ExtractNullCoalescingReturnTransformation(MetadataTypeCache typeCache, IDecompiledMethodBase method, DecompilerOptions decompilerOptions);
    public sealed virtual bool Apply(ControlFlowBlock branchBlock);
}
internal class JetBrains.Decompiler.Transformations.ObjectModel.ConvertBackingFieldToAutoGetOnlyPropertyInCtorTransformation : NodeTransformationBase`1<IDecompiledMethod> {
    protected virtual bool DoApply(IDecompiledMethod method);
}
internal class JetBrains.Decompiler.Transformations.ObjectModel.ExtractCheckCastTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    protected virtual bool DoApply(IBinaryOperationExpression binaryOperation);
}
internal abstract class JetBrains.Decompiler.Transformations.ObjectModel.ExtractCtorInitializerTransformationBase : NodeTransformationBase`1<IDecompiledMethod> {
    protected bool ApplyOnce { get; }
    protected virtual bool get_ApplyOnce();
    protected static IList`1<FieldInitializer> ExtractInitializers(IDecompiledMethod method, IStatement& currentStatement);
    private static bool MatchFieldInitializer(IDecompiledMethod method, IStatement statement, IMetadataField& field, IExpression& initializer);
    private static IExpression GetInitializer(IBinaryOperationExpression assignment);
    protected static void RegisterInitializers(IDecompiledClass decompiledClass, IList`1<FieldInitializer> initializers);
    private static bool ContainsParameterReference(IExpression expression, IList`1<IMethodParameter> parameters);
}
internal class JetBrains.Decompiler.Transformations.ObjectModel.ExtractInstanceCtorInitializerTransformation : ExtractCtorInitializerTransformationBase {
    private static DataKey`1<bool> AppliedToClass;
    private static ExtractInstanceCtorInitializerTransformation();
    protected virtual bool DoApply(IDecompiledMethod method);
}
internal class JetBrains.Decompiler.Transformations.ObjectModel.ExtractObjectAndCollectionInitializersTransformation : NodeTransformationBase`1<IObjectCreationExpression> {
    private static string AddMethodName;
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myFinder;
    public ExtractObjectAndCollectionInitializersTransformation(MetadataTypeCache typeCache, ReferencesFinder finder);
    protected virtual bool DoApply(IObjectCreationExpression objectCreation);
    private bool IsAddCall(IMethodCallExpression methodCall);
    public static bool IsAddCall(IMethodCallExpression methodCall, MetadataTypeCache typeCache);
    private static IList`1<MemberWithArguments> GetAccessPath(IExpression expression, ILocalVariable tempVariable, Boolean& initializationInterrupted);
    private static int ComputeLcpLength(IList`1<MemberWithArguments> accessPath1, IList`1<MemberWithArguments> accessPath2);
    private static bool PushNestedScope(IList`1<MemberWithArguments> currentAccessPath, Stack`1<InitializationScope> currentScopeStack, MemberWithArguments newMemberWithArguments);
    private static bool PushNestedScopes(IList`1<MemberWithArguments> currentAccessPath, Stack`1<InitializationScope> currentScopeStack, IList`1<MemberWithArguments> desiredAccessPath);
    private static void PopNestedScope(IList`1<MemberWithArguments> currentAccessPath, Stack`1<InitializationScope> currentScopeStack);
    private static void PopNestedScopes(IList`1<MemberWithArguments> currentAccessPath, Stack`1<InitializationScope> currentScopeStack, int desiredAccessPathLength);
    private static IExpression CreateCollectionItem(IExpression[] arguments);
}
internal class JetBrains.Decompiler.Transformations.ObjectModel.ExtractRecordWithExpressionTransformation : CondNodeTransformationBase`1<IMethodCallExpression> {
    private ExpressionTyper myExpressionTyper;
    public ExtractRecordWithExpressionTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(IMethodCallExpression cloneCall);
    [CanBeNullAttribute]
public static IMemberInitializerList CollectInitializers(IStatement firstStatement, ILocalVariable variable, List`1& statementsToRemove);
}
internal class JetBrains.Decompiler.Transformations.ObjectModel.ExtractRefTypeTransformation : NodeTransformationBase`1<IMethodCallExpression> {
    private MetadataTypeCache myTypeCache;
    public ExtractRefTypeTransformation(MetadataTypeCache typeCache);
    protected virtual bool DoApply(IMethodCallExpression methodCall);
}
internal class JetBrains.Decompiler.Transformations.ObjectModel.ExtractStaticCtorInitializerTransformation : ExtractCtorInitializerTransformationBase {
    protected virtual bool DoApply(IDecompiledMethod method);
}
internal class JetBrains.Decompiler.Transformations.ObjectModel.ExtractStructWithExpressionTransformation : CondNodeTransformationBase`1<IMemberAccessExpression> {
    public ExtractStructWithExpressionTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(IMemberAccessExpression memberAccess);
}
internal class JetBrains.Decompiler.Transformations.ObjectModel.ExtractTypeOfTransformation : NodeTransformationBase`1<IMethodCallExpression> {
    private MetadataTypeCache myTypeCache;
    public ExtractTypeOfTransformation(MetadataTypeCache typeCache);
    protected virtual bool DoApply(IMethodCallExpression methodCall);
}
internal class JetBrains.Decompiler.Transformations.ObjectModel.ReduceNullComparisonTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    protected virtual bool DoApply(IBinaryOperationExpression binaryOperation);
}
internal class JetBrains.Decompiler.Transformations.ObjectModel.UnwrapFinalizerTransformation : NodeTransformationBase`1<IDecompiledMethod> {
    protected bool ApplyOnce { get; }
    protected virtual bool DoApply(IDecompiledMethod method);
    protected virtual bool get_ApplyOnce();
}
internal class JetBrains.Decompiler.Transformations.PatternMatching.ExtractConstantPatternMatchingTransformation : NodeTransformationBase`1<ILiteralExpression> {
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myReferencesFinder;
    public ExtractConstantPatternMatchingTransformation(MetadataTypeCache typeCache, ReferencesFinder referencesFinder);
    protected virtual bool DoApply(ILiteralExpression literal);
    private IMethodCallExpression GetObjectEquals(ITypeCastExpression firstArgument);
}
internal class JetBrains.Decompiler.Transformations.PatternMatching.ExtractGenericTypePatternMatchingTransformation : object {
    private LocalVariableManager myLocalVariableManager;
    public ExtractGenericTypePatternMatchingTransformation(LocalVariableManager localVariableManager);
    public sealed virtual bool Apply(ControlFlowBlock block);
}
internal class JetBrains.Decompiler.Transformations.PatternMatching.ExtractStructTypePatternMatchingTransformation : object {
    private ReferencesFinder myReferencesFinder;
    private LocalVariableManager myLocalVariableManager;
    public ExtractStructTypePatternMatchingTransformation(ReferencesFinder referencesFinder, LocalVariableManager localVariableManager);
    public sealed virtual bool Apply(ControlFlowBlock block);
    [CanBeNullAttribute]
private IUnboxExpression FindSingleUnboxInBlock(IEnumerable`1<IExpression> references, IExpression referenceToSkip, ControlFlowBlock block, IMetadataType unboxType);
}
internal class JetBrains.Decompiler.Transformations.PatternMatching.ExtractTypePatternMatchingTransformation : NodeTransformationBase`1<ITryCastExpression> {
    private MetadataTypeCache myTypeCache;
    private LocalVariableManager myLocalVariableManager;
    private ReferencesFinder myReferencesFinder;
    public ExtractTypePatternMatchingTransformation(MetadataTypeCache typeCache, LocalVariableManager localVariableManager, ReferencesFinder referencesFinder);
    protected virtual bool DoApply(ITryCastExpression tryCast);
    private bool TryReplaceBranchExpressionWithTypePattern(IExpressionStatement castAssignmentStatement, IExpression argument, IMetadataType targetType, ILocalVariableReferenceExpression castLocal);
    private bool TryReplaceWithTypePatternCastLocal(INode nullComparisonNode, IExpression argument, IMetadataType targetType, ILocalVariableReferenceExpression castLocal);
    private bool TryReplaceWithTypePatternTempLocal(INode nullComparisonNode, IExpression argument, IMetadataType targetType, ILocalVariableReferenceExpression tempReference1);
    [CanBeNullAttribute]
private IExpression GetInitializer(ILocalVariableReferenceExpression tempReference2, IMetadataType targetType);
}
internal class JetBrains.Decompiler.Transformations.PatternMatching.InlineTypePatternVariableTransformation : NodeTransformationBase`1<ITypePatternExpression> {
    private ReferencesFinder myReferencesFinder;
    private LocalVariableManager myLocalVariableManager;
    public InlineTypePatternVariableTransformation(ReferencesFinder referencesFinder, LocalVariableManager localVariableManager);
    protected virtual bool DoApply(ITypePatternExpression typePattern);
    [CanBeNullAttribute]
private ILocalVariableReferenceExpression GetRealVariable(ILocalVariableReferenceExpression tempVariableReference1, IExpressionStatement& realVariableInitialization);
}
internal static class JetBrains.Decompiler.Transformations.PatternMatching.PatternMatchingUtil : object {
    public static bool ArgumentsAreEqual(IExpression argument1, IExpression argument2);
    public static void ReplaceWithTypePattern(IExpression expression, IExpression argument, IMetadataType targetType, ILocalVariableReferenceExpression targetLocal, bool negate, LocalVariableManager localVariableManager);
}
internal class JetBrains.Decompiler.Transformations.Records.DetectRecordTransformation : object {
    public sealed virtual bool Apply(IDecompiledClass decompiledClass);
    private static ValueTuple`8<List`1<IDecompiledMethod>, List`1<IDecompiledMethod>, IDecompiledMethod, IDecompiledMethod, IDecompiledMethod, IDecompiledMethod, IDecompiledMethod, ValueTuple`3<IDecompiledMethod, IDecompiledMethod, IDecompiledMethod>> GetRecordMembersFromDecompiledMethods(IDecompiledClass decompiledClass);
    private static ValueTuple`3<bool, bool, bool> GetRecordCGMembersFromMetadataMethods(IMetadataTypeInfo type);
    private static bool IsSynthesizedPrintMembers(IDecompiledMethod printMembers, List`1<string> synthesizedAutoPropertiesNames, bool isStruct);
    private static bool IsSynthesizedToString(IDecompiledMethod toString, bool isStruct);
    private static bool IsSynthesizedOpEquality(IDecompiledMethod opEquality, bool isStruct);
    private static bool IsSynthesizedOpInequality(IDecompiledMethod opInequality);
    private static bool IsSynthesizedGetHashCode(IDecompiledMethod getHashCode, Dictionary`2<IMetadataField, IDecompiledProperty> synthesizedAutoProperties, IDecompiledProperty equalityContract, bool isStruct);
    private static bool IsSynthesizedObjectEquals(IDecompiledMethod equalsObj, IMetadataTypeInfo type, bool isStruct);
    private static bool IsSynthesizedTypedEquals(IDecompiledMethod equalsT, Dictionary`2<IMetadataField, IDecompiledProperty> synthesizedAutoProperties, IDecompiledProperty equalityContract);
    private static bool HasSynthesizedDeconstructorSignature(IMetadataMethod deconstruct, List`1<string> synthesizedAutoPropertiesNames);
    private static bool IsSynthesizedDeconstructor(IDecompiledMethod deconstruct, List`1<string> synthesizedAutoPropertiesNames, bool isStruct);
    private static bool IsPrimaryConstructor(IDecompiledMethod constructor, Dictionary`2<IMetadataField, IDecompiledProperty> synthesizedAutoProperties, List`1<string> synthesizedAutoPropertiesNames, bool isStruct);
    private static bool IsSynthesizedCopyConstructor(IDecompiledMethod copyConstructor, Dictionary`2<IMetadataField, IDecompiledProperty> synthesizedAutoProperties, IDecompiledClass decompiledClass);
    private static bool ImplementsIEquatable(IMetadataTypeInfo type);
    public static bool IsIEquatableT(IMetadataClassType type, IMetadataTypeInfo argument);
    private static bool HasFqn(IMetadataType type, string fqn);
    private static bool HasCloneSignature(IMetadataMethod method);
    private static bool HasOperatorSignature(IMetadataMethod method);
    private static bool HasPrintMembersSignature(IMetadataMethod method);
    private static bool HasToStringSignature(IMetadataMethod method);
    private static bool HasGetHashCodeSignature(IMetadataMethod method);
    private static bool HasTypedEqualsSignature(IMetadataMethod method);
    private static bool HasObjectEqualsSignature(IMetadataMethod method);
    private static bool HasCopyConstructorSignature(IMetadataMethod constructor);
    private static bool HasSignature(IMetadataMethod method, string returnTypeFqn);
    private static bool HasSignature(IMetadataMethod method, string returnTypeFqn, string parameterFqn);
    private static bool IsEqualityContract(IDecompiledProperty property);
    private static void Remove(IList`1<T> collection, HashSet`1<T> elements);
    private static IExpression SkipDeref(IExpression expression, bool isStruct);
    private static bool HasBackingFieldAccess(IBlockStatement methodBody, Dictionary`2<IMetadataField, IDecompiledProperty> synthesizedAutoProperties);
    [CompilerGeneratedAttribute]
internal static IExpression <IsSynthesizedPrintMembers>g__GetBuilderAppendArgument|3_0(IExpression builderAppend, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static IExpression <IsSynthesizedToString>g__GetBuilderAppendArgument|4_0(IStatement builderAppendStatement, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsSynthesizedToString>g__MatchLiteralAgainstValue|4_1(IExpression expression, char value1, string value2);
    [CompilerGeneratedAttribute]
internal static IExpression <IsSynthesizedObjectEquals>g__GetTypedEqualsCallArgument|8_0(IExpression expression, <>c__DisplayClass8_0& );
}
internal class JetBrains.Decompiler.Transformations.RecursiveNodeTransformation : object {
    private ChildVisitOrder myOrder;
    private InterruptionChecker myInterruptionChecker;
    private INodeTransformation myTransformation;
    public Type BaseNodeType { get; }
    public RecursiveNodeTransformation(ChildVisitOrder order, InterruptionChecker interruptionChecker, INodeTransformation transformation);
    public RecursiveNodeTransformation(InterruptionChecker interruptionChecker, INodeTransformation transformation);
    public sealed virtual Type get_BaseNodeType();
    public sealed virtual bool Apply(INode node);
    private void Visit(INode node, Boolean& hasChanges);
}
internal class JetBrains.Decompiler.Transformations.References.EliminateDerefRefTransformation : NodeTransformationBase`1<IDerefExpression> {
    protected virtual bool DoApply(IDerefExpression derefExpression);
}
internal static class JetBrains.Decompiler.Transformations.References.ImplicitDerefInserter : object {
    public static void Run(IDecompiledMethodBase method, ReferencesFinder referencesFinder, ExpressionTyper expressionTyper);
    private static void ProcessReference(IExpression reference);
}
internal static class JetBrains.Decompiler.Transformations.References.RefModifierInserter : object {
    public static void Run(IDecompiledMethodBase method, ExpressionTyper expressionTyper);
}
internal class JetBrains.Decompiler.Transformations.StatementStructure.EliminateEmptyBlockStatementTransformation : NodeTransformationBase`1<IBlockStatement> {
    protected virtual bool DoApply(IBlockStatement block);
}
internal class JetBrains.Decompiler.Transformations.StatementStructure.EliminateEmptyStatementTransformation : NodeTransformationBase`1<IEmptyStatement> {
    protected virtual bool DoApply(IEmptyStatement statement);
}
internal class JetBrains.Decompiler.Transformations.StatementStructure.ReduceReturnOrYieldBreakTransformation : NodeTransformationBase`1<IDecompiledMethodBase> {
    protected virtual bool DoApply(IDecompiledMethodBase method);
    private static bool IsFollowedByTerminate(IStatement statement);
    private static IStatement GetContainingSwitchOrLoop(IStatement statement);
    private static bool IsReplaceableWithBreak(IStatement statement);
}
internal class JetBrains.Decompiler.Transformations.StatementStructure.SimplifyIfTransformation : NodeTransformationBase`1<IIfStatement> {
    protected virtual bool DoApply(IIfStatement ifStatement);
}
internal class JetBrains.Decompiler.Transformations.StatementStructure.SimplifySingleStatementBlockTransformation : NodeTransformationBase`1<IBlockStatement> {
    protected virtual bool DoApply(IBlockStatement node);
}
internal class JetBrains.Decompiler.Transformations.Strings.ExtractNameOfTransformation : NodeTransformationBase`1<ILiteralExpression> {
    private MethodDecompilerContext myContext;
    private Lazy`1<bool> myCanUseNameOf;
    private Lazy`1<Dictionary`2<string, string>> myNameofArguments;
    private static string NameOfKeyword;
    public ExtractNameOfTransformation(MethodDecompilerContext context);
    protected virtual bool DoApply(ILiteralExpression literal);
    private bool CanUseNameOf();
    private bool CanUseNameOf(IMetadataTypeInfo type);
    private Dictionary`2<string, string> GetNameofArguments();
    private static void AddKeyValue(Dictionary`2<string, string> d, string keyValue);
    private static void AddType(Dictionary`2<string, string> d, IMetadataTypeInfo type);
    private static string BuildGenericTypeName(IMetadataTypeInfo type);
}
internal class JetBrains.Decompiler.Transformations.Strings.StringConcatTransformation : CondNodeTransformationBase`1<IMethodCallExpression> {
    private MetadataTypeCache myTypeCache;
    private ExpressionTyper myExpressionTyper;
    public StringConcatTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(IMethodCallExpression methodCall);
    private IExpression ConvertToSum(IExpression[] expressions, IInstructionReference instructionReference);
    private IExpression WrapIfNeeded(IExpression expression);
    private IExpression UnwrapIfNeeded(IExpression expression);
}
internal class JetBrains.Decompiler.Transformations.Switch.ExtractBoolSwitchTransformation : NodeTransformationBase`1<ISwitchStatement> {
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    public ExtractBoolSwitchTransformation(ExpressionTyper expressionTyper, MetadataTypeCache typeCache);
    protected virtual bool DoApply(ISwitchStatement statement);
}
internal class JetBrains.Decompiler.Transformations.Switch.ExtractLargeStringSwitch10Transformation : GraphTransformationBase {
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myFinder;
    private Dictionary`2<IMetadataField, SwitchInitializer> myFieldToInitializer;
    private ControlFlowGraph myGraph;
    private ControlFlowBlock myPostinitBlock;
    public ExtractLargeStringSwitch10Transformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(ControlFlowGraph graph);
    private bool AnalyzeInitializers();
    private void AnalyzeSwitchBlock(ControlFlowBlock switchBlock);
    private bool AnalyzeHashtableInitializerBlock(ControlFlowBlock branchBlock, IMetadataField hashtableField);
}
internal class JetBrains.Decompiler.Transformations.Switch.ExtractLargeStringSwitch20Transformation : GraphTransformationBase {
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myFinder;
    private bool myHasChanges;
    public ExtractLargeStringSwitch20Transformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(ControlFlowGraph graph);
    private void AnalyzeSwitchBlock(ControlFlowBlock switchBlock);
    private static bool AnalyzeInitializerCheckBlock(ControlFlowBlock initializerCheckBlock, IMetadataField dictionaryField);
    private bool AnalyzeDictionaryCheckBlock(ControlFlowBlock dictionaryCheckBlock, IMetadataField& dictionaryField, ILocalVariable& switchValueVariable, ILocalVariable& caseVariable);
    private bool ComputeSwitchCases(ControlFlowBlock switchBlock, ControlFlowBlock nullCheckBlock, List`1<string> keys, List`1& switchCases);
    private bool AnalyzeSimpleNullCheckBlock(ILocalVariable switchValueVariable, ControlFlowBlock nullCheckBlock, IExpression& switchExpression, IStatement& switchVariableAssignmentStatement);
    private bool AnalyzeInlinedNullCheckBlock(ILocalVariable switchValueVariable, ControlFlowBlock nullCheckBlock, IExpression& switchExpression, IStatement& switchVariableAssignmentStatement);
    private bool AnalyzeDictionaryInitializerBlock(ControlFlowBlock initializerBlock, IMetadataField dictionaryField, List`1& keys);
    public static bool IsDictionaryStringInt(IMetadataType type);
    public static bool IsDictionaryTryGetValue(IMetadataMethod method);
    public static bool IsDictionaryAdd(IMetadataMethod method);
}
internal class JetBrains.Decompiler.Transformations.Switch.ExtractLargeStringSwitchRoslynTransformation : GraphTransformationBase {
    private MetadataTypeCache myTypeCache;
    private ExpressionTyper myExpressionTyper;
    private ReferencesFinder myReferencesFinder;
    private static string ComputeStringHashMethodName;
    public ExtractLargeStringSwitchRoslynTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(ControlFlowGraph graph);
    private bool Apply(ControlFlowBlock switchBlock);
    private bool IsComputeStringHashMethod(IMethodCallExpression methodCall);
    private void MergeWithDefault(ControlFlowBlock switchBlock);
    [CompilerGeneratedAttribute]
internal static List`1<ControlFlowBlock> <DoApply>g__GetAllSwitchBlocks|5_0(ControlFlowGraph graph);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<Pair`2<ControlFlowBlock, ISwitchCaseValue>> <MergeWithDefault>g__GetAllNonDefaultSwitchCases|8_0(ControlFlowBlock switchBlock);
}
internal class JetBrains.Decompiler.Transformations.Switch.ExtractSmallStringSwitch10Transformation : BlockTransformationBase {
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myFinder;
    public ExtractSmallStringSwitch10Transformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(ControlFlowBlock nullCheckBlock);
    private static bool AnalyzeNullCheckBlock(ControlFlowBlock nullCheckBlock, ILocalVariable& switchValueVariable, IExpression& switchExpression, ControlFlowBlock& thenBlock, ControlFlowBlock& elseBlock);
    private bool AnalyzeDummyInternBlock(ControlFlowBlock nullCheckBlock, ControlFlowBlock nullCaseBlock, ControlFlowBlock internBlock, ILocalVariable switchValueVariable, List`1& switchCases, JetHashSet`1& visitedBlocks);
    private bool AnalyzeInlinedInternBlock(ControlFlowBlock nullCheckBlock, ControlFlowBlock nullCaseBlock, ControlFlowBlock internBlock, ILocalVariable switchValueVariable, List`1& switchCases, JetHashSet`1& visitedBlocks);
    private bool AnalyzeRegularSwitchTree(ControlFlowBlock nullCheckBlock, ControlFlowBlock nullCaseBlock, ControlFlowBlock internBlock, ILocalVariable switchValueVariable, List`1& switchCases, JetHashSet`1& visitedBlocks);
    private bool AnalyzeInternBlock(ControlFlowBlock internBlock, ILocalVariable switchValueVariable, ILocalVariable& internedSwitchValueVariable);
    private bool AnalyzeCaseBranchBlock(ControlFlowBlock caseBranchBlock, ILocalVariable switchValueVariable, String& key, ControlFlowBlock& thenBlock, ControlFlowBlock& elseBlock);
}
internal class JetBrains.Decompiler.Transformations.Switch.ExtractSwitchTreeTransformation : GraphTransformationBase {
    private MetadataTypeCache myTypeCache;
    private ExpressionTyper myExpressionTyper;
    private ReferencesFinder myReferencesFinder;
    private Dictionary`2<ControlFlowBlock, TreeNode> myTreeNodes;
    private bool myChanged;
    private static long MaxRangeLength;
    public ExtractSwitchTreeTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(ControlFlowGraph graph);
    [CanBeNullAttribute]
private static ILocalVariable GetSwitchTempVariable(IExpression switchExpression);
    private bool IsRootBlock(ControlFlowBlock block);
    [NotNullAttribute]
private static TreeNode CreateBranchTreeNode(ControlFlowBlock block, OperationType comparisonOperationType, IExpression switchExpression, long comparisonValue);
    private static TreeNode CreateStringBranchTreeNode(ControlFlowBlock block, IExpression switchExpression, bool negation, string comparisonValue);
    private static bool MatchConstant(IExpression expression, Int64& value);
    [CanBeNullAttribute]
private TreeNode CreateTreeNodeFromBlock(ControlFlowBlock block);
    private TreeNode CreateFromBranch(ControlFlowBlock block, IExpression branchExpression);
    [CanBeNullAttribute]
private TreeNode CreateFromEqualOrNotEqualComparison(IBinaryOperationExpression comparison, ControlFlowBlock block);
    [CanBeNullAttribute]
private TreeNode CreateFromLessOrGreaterComparison(IBinaryOperationExpression comparison, ControlFlowBlock block);
    [CanBeNullAttribute]
private TreeNode CreateRangeFromUnsignedComparison(IBinaryOperationExpression comparison, bool negation, ControlFlowBlock block);
    private bool CollectCases(IExpression branchExpression, IExpression& switchExpression, List`1& cases, Boolean& negation);
    [CanBeNullAttribute]
private TreeNode CreateFromSwitch(IExpression branchExpression, ControlFlowBlock block);
    private static bool MatchOptionalDoubleTypeCast(IExpression expression, IMetadataType expectedType1, IMetadataType expectedType2, T& innerExpression);
    private bool IsUnsigned(IExpression expression);
    [CanBeNullAttribute]
private TreeNode GetTreeNodeFromBlock(ControlFlowBlock block);
    [CompilerGeneratedAttribute]
internal static bool <CollectCases>g__UpdateSwitchExpression|29_0(IExpression& switch, IExpression newSwitchExpression);
    [CompilerGeneratedAttribute]
internal static void <CollectCases>g__AddCase|29_1(List`1& casesList, PatternCase case);
}
internal class JetBrains.Decompiler.Transformations.Switch.ReduceSwitchTypeCastTransformation : NodeTransformationBase`1<ISwitchStatement> {
    private ExpressionTyper myExpressionTyper;
    public ReduceSwitchTypeCastTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(ISwitchStatement switchStatement);
    private void WrapGotoCaseValues(IStatement statement, IMetadataType type);
}
internal class JetBrains.Decompiler.Transformations.Switch.SimplifySwitchTransformation : NodeTransformationBase`1<ISwitchStatement> {
    protected virtual bool DoApply(ISwitchStatement switch);
    private static bool IsEmptyCase(IBlockStatement caseStatement);
}
internal static class JetBrains.Decompiler.Transformations.Switch.SwitchUtil : object {
    public static bool MatchStringComparison(IExpression expression, MetadataTypeCache typeCache, ExpressionTyper expressionTyper, IExpression& stringExpression, String& value, Boolean& negate);
    private static bool MatchStringLength(IExpression expression, MetadataTypeCache typeCache, IExpression& stringExpression);
}
internal class JetBrains.Decompiler.Transformations.Tuples.ExtractDeconstructionTransformation : ExtractDeconstructionTransformationBase`1<IExpressionStatement> {
    public ExtractDeconstructionTransformation(ExpressionTyper expressionTyper, ReferencesFinder referencesFinder, TupleElementNameManager tupleElementNameManager);
    protected virtual IExpressionStatement GetFirstDeconstructionStatement(IExpressionStatement statement);
    protected virtual void InitTupleData(TupleData tupleData, IExpressionStatement statement);
    protected virtual bool CheckDeconstruction(TupleData tupleData);
    protected virtual void Transform(IExpressionStatement statement, ITupleExpression tuple, TupleData tupleData);
}
internal abstract class JetBrains.Decompiler.Transformations.Tuples.ExtractDeconstructionTransformationBase`1 : NodeTransformationBase`1<TStatement> {
    private ExpressionTyper myExpressionTyper;
    private ReferencesFinder myReferencesFinder;
    private TupleElementNameManager myTupleElementNameManager;
    protected ExtractDeconstructionTransformationBase`1(ExpressionTyper expressionTyper, ReferencesFinder referencesFinder, TupleElementNameManager tupleElementNameManager);
    protected virtual bool DoApply(TStatement statement);
    [CanBeNullAttribute]
protected abstract virtual IExpressionStatement GetFirstDeconstructionStatement(TStatement statement);
    protected abstract virtual void InitTupleData(TupleData tupleData, TStatement statement);
    protected abstract virtual bool CheckDeconstruction(TupleData tupleData);
    protected abstract virtual void Transform(TStatement statement, ITupleExpression tuple, TupleData tupleData);
    [CanBeNullAttribute]
private TupleData ExtractDeconstruction(TStatement statement, List`1& statementsToDelete);
    private bool AnalyzeExpression(IExpression currentStatementExpression, TupleData tupleData, State& state);
    protected static bool IsDeconstructMethod(IMethodCallExpression method);
    private IExpression CreateTupleComponent(TupleTreeNode node);
    [CanBeNullAttribute]
private static IMetadataTupleType GetTupleType(IMetadataType type);
    protected bool AnalyzeTupleAssignment(ILocalVariable newTupleVariable, IExpression rightArgument, IInstructionReference ir, TupleData tupleData);
    private bool AnalyzeDeconstructCall(IMethodCallExpression deconstructCall, TupleData tupleData);
    private bool AnalyzeCast(IExpression leftArgument, ITypeCastExpression cast, TupleData tupleData);
    private bool AnalyzeTupleComponentAssignment(IExpression leftArgument, IFieldAccessExpression tupleComponentAccess, TupleData tupleData);
    private static bool AnalyzeVariableAssignment(IExpression leftArgument, ILocalVariable rightVariable, TupleData tupleData);
    private bool AnalyzeTempVariableAssignment(ILocalVariableReferenceExpression newVariableReference, ILocalVariable oldVariable, TupleData tupleData);
    private IExpression SkipUnusedVariableAssignment(IExpression expression);
    public bool MatchTupleComponentAccess(IFieldAccessExpression tupleComponentAccess, ILocalVariable& tupleVariable, List`1& indices, List`1& types);
    public bool VariableValueIsNotUsed(ILocalVariable variable);
}
internal class JetBrains.Decompiler.Transformations.Tuples.ExtractForeachDeconstructionTransformation : ExtractDeconstructionTransformationBase`1<IForEachStatement> {
    public ExtractForeachDeconstructionTransformation(ExpressionTyper expressionTyper, ReferencesFinder referencesFinder, TupleElementNameManager tupleElementNameManager);
    protected virtual IExpressionStatement GetFirstDeconstructionStatement(IForEachStatement statement);
    protected virtual void InitTupleData(TupleData tupleData, IForEachStatement statement);
    protected virtual bool CheckDeconstruction(TupleData tupleData);
    private static bool TestTupleTree(TupleTreeNode node);
    protected virtual void Transform(IForEachStatement foreachStatement, ITupleExpression tuple, TupleData tupleData);
}
internal class JetBrains.Decompiler.Transformations.Tuples.ExtractTupleCreationTransformation : NodeTransformationBase`1<IObjectCreationExpression> {
    protected virtual bool DoApply(IObjectCreationExpression objectCreation);
}
internal class JetBrains.Decompiler.Transformations.Tuples.GenericArgumentCollector : object {
    private OneToListMap`2<IMetadataTypeParameter, IMetadataType> mySubstitutions;
    public void Collect(IMetadataType type, IMetadataType typeWithSubstitution);
    [CanBeNullAttribute]
public IMetadataType GetSubstitution(IMetadataTypeParameter typeParameter);
}
internal class JetBrains.Decompiler.Transformations.Tuples.TupleComponentAccessInserter : object {
    private IDecompiledMethodBase myMethod;
    private TupleElementNameManager myTupleElementNameManager;
    private ExpressionTyper myExpressionTyper;
    private TupleComponentAccessInserter(IDecompiledMethodBase method, TupleElementNameManager tupleElementNameManager, ExpressionTyper expressionTyper);
    public static void Run(IDecompiledMethodBase method, TupleElementNameManager tupleElementNameManager, ExpressionTyper expressionTyper);
    private void Run();
    private void ProcessFieldAccess(IFieldAccessExpression fieldAccess);
}
internal class JetBrains.Decompiler.Transformations.Tuples.TupleData : object {
    private TupleElementNameManager myTupleElementNameManager;
    [CompilerGeneratedAttribute]
private TupleTreeNode <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <Target>k__BackingField;
    public Dictionary`2<ILocalVariable, TupleTreeNode> ComponentVariableToTupleTreeNode;
    private Dictionary`2<ILocalVariable, int> myRemainingUsagesCount;
    private TupleTreeNode myPrevIndex;
    private bool myStopped;
    private HashSet`1<ILocalVariable> myPendingVariables;
    public TupleTreeNode Root { get; private set; }
    public IExpression Target { get; private set; }
    public TupleData(TupleElementNameManager tupleElementNameManager);
    [CompilerGeneratedAttribute]
public TupleTreeNode get_Root();
    [CompilerGeneratedAttribute]
private void set_Root(TupleTreeNode value);
    [CompilerGeneratedAttribute]
public IExpression get_Target();
    [CompilerGeneratedAttribute]
private void set_Target(IExpression value);
    public void SetTarget(IExpression target);
    public bool DecreaseUsagesCount(ILocalVariable variable, bool ensureLastUsage);
    public bool NoRemainingUsages();
    private bool NoPendingVariables();
    public bool ContinueBuilding();
    public bool TryStopBuilding();
    public bool IsStopped();
    public void SetVariableInfo(ILocalVariable componentVariable, int remainingUsagesCount, TupleTreeNode componentNode, bool pending);
    public bool ReplaceVariable(ILocalVariable newVariable, ILocalVariable oldVariable, int newVariableRemainingUsagesCount, bool pending);
    public bool TryCreateTupleComponent(ILocalVariable tupleVariable, List`1<int> indices, List`1<IMetadataClassType> types, Func`3<int, TupleTreeNode, TupleTreeNode> createNode, TupleTreeNode& componentNode);
    public bool SetNewIndex(TupleTreeNode index);
}
internal class JetBrains.Decompiler.Transformations.Tuples.TupleDeconstructionDeclarationsInserter : object {
    private IDecompiledMethodBase myMethod;
    private ReferencesFinder myFinder;
    private LocalVariableManager myLocalVariableManager;
    private NodeTreeAnalyzer myNodeTreeAnalyzer;
    private TupleDeconstructionDeclarationsInserter(IDecompiledMethodBase method, ReferencesFinder finder, LocalVariableManager localVariableManager);
    public static void Run(IDecompiledMethodBase method, ReferencesFinder finder, LocalVariableManager localVariableManager);
    private void Run();
    private static bool DeconstructionDeclarationIsAllowedInThisPosition(ITupleExpression topLevelTuple, IStatement containingStatement);
    private static bool CanBeDeconstructionDeclaration(ITupleExpression tuple, HashSet`1<ILocalVariable> variables);
    private static void SetIsDeclarationRecursive(ITupleExpression tuple);
    [NotNullAttribute]
private static ITupleExpression GetTopLevelTuple(ITupleExpression tuple);
}
internal class JetBrains.Decompiler.Transformations.Tuples.TupleElementNameManager : object {
    private static DataKey`1<IMetadataType> TupleElementNamesKey;
    private ExpressionTyper myExpressionTyper;
    private ReferencesFinder myReferencesFinder;
    [CanBeNullAttribute]
private IMetadataLocalVariablesNameProvider myMetadataLocalVariablesNameProvider;
    private Dictionary`2<Pair`2<IMetadataClassType, IMetadataEntity>, IMetadataType> myEntityTupleElementNames;
    private Dictionary`2<Pair`2<IMetadataClassType, IMetadataClassType>, IMetadataClassType> myBaseTypeOrInterfaceTupleElementNames;
    private Dictionary`2<ILocalVariable, IMetadataType> myVariableTupleElementNames;
    public TupleElementNameManager(ExpressionTyper expressionTyper, ReferencesFinder referencesFinder, IMetadataLocalVariablesNameProvider metadataLocalVariablesNameProvider);
    private static TupleElementNameManager();
    [CanBeNullAttribute]
public IMetadataType GetTupleElementNames(IExpression expression);
    public void SetTupleElementNames(ILocalVariable variable);
    [CanBeNullAttribute]
[ItemCanBeNullAttribute]
public String[] GetTupleElementNames(ILocalVariable variable);
    [CanBeNullAttribute]
private IMetadataType CalculateTupleElementNames(IExpression expression);
    [CanBeNullAttribute]
private IMetadataType GetElementNames(IExpression target, int componentIndex);
    [CanBeNullAttribute]
private IMetadataType GetVariableTupleElementNames(ILocalVariable variable);
    private IMetadataType InferVariableTenFromSingleWriteUsage(ILocalVariable variable);
    private IMetadataType GetVariableTenFromDebugData(ILocalVariable variable);
    [CanBeNullAttribute]
private IMetadataType GetEntityTupleElementNames(ITargetable targetOwner, IMetadataClassType entityOwnerType, IMetadataEntity entity, IMetadataType type);
    [CanBeNullAttribute]
private IMetadataType GetTargetType(ITargetable targetable);
    [CanBeNullAttribute]
private IMetadataType GetTupleElementNames(IMetadataType type, IMetadataType tenSubstitutionProvider);
    [NotNullAttribute]
private IMetadataClassType GetTupleElementNames(IMetadataClassType type, IMetadataClassType tenSubstitutionProvider);
    [NotNullAttribute]
private IMetadataClassType GetBaseTypeTupleElementNames(IMetadataClassType baseType, IMetadataClassType tenSubstitutionProvider);
    [NotNullAttribute]
private IMetadataClassType GetInterfaceTupleElementNames(IMetadataClassType interface, IMetadataClassType tenSubstitutionProvider);
    private bool ContainsGenericValueTupleInGenericArguments(IMetadataClassType type);
    [CanBeNullAttribute]
private IMetadataType GetReturnValueTupleElementNames(IMethodCallBaseExpression methodCall);
    [CanBeNullAttribute]
private IMetadataType GetArgumentTupleElementNames(IExpression argument, IMethodCallBaseExpression methodCall);
    [CanBeNullAttribute]
private IMetadataType GetReturnValueOrArgumentTupleElementNames(IMetadataEntity returnValueOrParameter, IMetadataType returnValueOrParameterType, IMethodCallBaseExpression methodCall);
    private IMetadataType GetCreatedInstanceTupleElementNames(IObjectCreationExpression creation);
    private GenericArgumentCollector InferGenericArgumentsFromMethodArguments(MethodSpecification methodSpecification, IMetadataType[] methodInstantiationGenericArguments, IExpression[] arguments);
}
internal class JetBrains.Decompiler.Transformations.Tuples.TupleTreeNode : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private TupleTreeNode <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private TupleTreeNode[] <NestedTuple>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSpecification <DeconstructMethodSpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <TupleElementNames>k__BackingField;
    [CompilerGeneratedAttribute]
private IInstructionReference <DeconstructionInstructionReference>k__BackingField;
    private IMetadataType myNestedTupleType;
    public int Index { get; }
    [CanBeNullAttribute]
public TupleTreeNode Parent { get; }
    [CanBeNullAttribute]
public IExpression Component { get; private set; }
    [CanBeNullAttribute]
[ItemCanBeNullAttribute]
public TupleTreeNode[] NestedTuple { get; private set; }
    [CanBeNullAttribute]
public MethodSpecification DeconstructMethodSpecification { get; private set; }
    [CanBeNullAttribute]
public IMetadataType TupleElementNames { get; private set; }
    [CanBeNullAttribute]
public IInstructionReference DeconstructionInstructionReference { get; private set; }
    private TupleTreeNode(int index, TupleTreeNode parent, IExpression component, TupleTreeNode[] nestedTuple, IMetadataType nestedTupleType, IMetadataType tupleElementNames, MethodSpecification deconstructMethodSpecification, IInstructionReference deconstructionInstructionReference);
    public TupleTreeNode(int index, TupleTreeNode parent, IExpression component);
    public TupleTreeNode(int index, TupleTreeNode parent, TupleTreeNode[] nestedTuple, IMetadataType nestedTupleType, IMetadataType tupleElementNames, MethodSpecification deconstructMethodSpecification, IInstructionReference deconstructionInstructionReference);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public TupleTreeNode get_Parent();
    [CompilerGeneratedAttribute]
public IExpression get_Component();
    [CompilerGeneratedAttribute]
private void set_Component(IExpression value);
    [CompilerGeneratedAttribute]
public TupleTreeNode[] get_NestedTuple();
    [CompilerGeneratedAttribute]
private void set_NestedTuple(TupleTreeNode[] value);
    [CompilerGeneratedAttribute]
public MethodSpecification get_DeconstructMethodSpecification();
    [CompilerGeneratedAttribute]
private void set_DeconstructMethodSpecification(MethodSpecification value);
    [CompilerGeneratedAttribute]
public IMetadataType get_TupleElementNames();
    [CompilerGeneratedAttribute]
private void set_TupleElementNames(IMetadataType value);
    [CompilerGeneratedAttribute]
public IInstructionReference get_DeconstructionInstructionReference();
    [CompilerGeneratedAttribute]
private void set_DeconstructionInstructionReference(IInstructionReference value);
    public void SetNestedTuple(TupleTreeNode[] nestedTuple, IMetadataType nestedTupleType, IMetadataType tupleElementNames, MethodSpecification deconstructMethodSpecification, IInstructionReference deconstructionInstructionReference);
    public virtual string ToString();
    public bool ReplaceComponent(IExpression newComponent);
    private static int GetLevel(TupleTreeNode node);
    private static int Compare(TupleTreeNode node1, int level1, TupleTreeNode node2, int level2);
    public sealed virtual int CompareTo(TupleTreeNode other);
    public IMetadataType GetComponentType(int i);
}
internal static class JetBrains.Decompiler.Transformations.Tuples.TupleUtil : object {
    public static int GetTupleComponentIndex(IFieldAccessExpression tupleComponentAccess, IExpression& target);
    public static bool IsImplicitTupleConvertible(IMetadataType from, IMetadataType to);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.EliminateDoubleNumericTypeCastTransformation : NodeTransformationBase`1<ITypeCastExpression> {
    private ExpressionTyper myExpressionTyper;
    public EliminateDoubleNumericTypeCastTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(ITypeCastExpression outerTypeCast);
    private static bool IsFeasibleUncheckedElimination(IMetadataType sourceType, IMetadataType innerType, IMetadataType outerType);
    private static bool IsFeasibleCheckedElimination(IMetadataType sourceType, IMetadataType innerType, IMetadataType outerType);
    private static bool IsFeasibleCheckedMerge(IMetadataType sourceType, IMetadataType innerType, IMetadataType outerType);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.EliminateDoubleRefTypeCastTransformation : NodeTransformationBase`1<ITypeCastExpression> {
    private ExpressionTyper myExpressionTyper;
    public EliminateDoubleRefTypeCastTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(ITypeCastExpression outerTypeCast);
    private bool IsFeasibleElimination(IMetadataType sourceType, IMetadataType innerType, IMetadataType outerType);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.EliminateReadOnlySpanTypeCastForStackallocTransformation : NodeTransformationBase`1<IStackAllocExpression> {
    protected virtual bool DoApply(IStackAllocExpression stackAlloc);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.EliminateRecursivelyAnonymousTypeCastTransformation : NodeTransformationBase`1<ITypeCastExpression> {
    protected virtual bool DoApply(ITypeCastExpression typeCast);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.EliminateRedundantEqualityTypeCastTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    public EliminateRedundantEqualityTypeCastTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IBinaryOperationExpression binaryOperation);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.EliminateRedundantFieldAccessTypeCastTransformation : NodeTransformationBase`1<IFieldAccessExpression> {
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    public EliminateRedundantFieldAccessTypeCastTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(IFieldAccessExpression fieldAccess);
    private IMetadataType GetHidingType(FieldSpecification fieldSpecification, IMetadataType targetType);
    private static bool CanHide(IMetadataField hider, IMetadataField hidee);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.EliminateRedundantLiteralEqualityTypeCastTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    public EliminateRedundantLiteralEqualityTypeCastTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IBinaryOperationExpression binaryOperation);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.EliminateRedundantMemberCallTypeCastTransformation : NodeTransformationBase`1<IMemberCallExpression> {
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    public EliminateRedundantMemberCallTypeCastTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(IMemberCallExpression memberCall);
    private static bool IsExplicitImplementation(IMetadataMethod method, IMetadataType targetType);
    private IMetadataType GetHidingType(IMemberCallExpression memberCall, IMetadataType targetType);
    private static bool CanHide(IMetadataMethod hider, MethodSpecification hideeMethodSpecification, bool isVirtualCall);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.EliminateRedundantTypeCastTransformation : NodeTransformationBase`1<ITypeCastExpression> {
    private ExpressionTyper myExpressionTyper;
    public EliminateRedundantTypeCastTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(ITypeCastExpression typeCast);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.EliminateUnaryOperationDoubleTypeCastTransformation : NodeTransformationBase`1<ITypeCastExpression> {
    private ExpressionTyper myExpressionTyper;
    public EliminateUnaryOperationDoubleTypeCastTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(ITypeCastExpression outerTypeCast);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.EliminateUnaryOperationTypePromotionTransformation : NodeTransformationBase`1<IUnaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    public EliminateUnaryOperationTypePromotionTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IUnaryOperationExpression unaryOperation);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.EliminateUnsignedTypeCastInZeroComparisonTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    public EliminateUnsignedTypeCastInZeroComparisonTransformation(ExpressionTyper expressionTyper, MetadataTypeCache typeCache);
    protected virtual bool DoApply(IBinaryOperationExpression comparison);
    private static bool IsUnsignedZero(Constant constant);
    private Constant CreateZero(IMetadataType type);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.MoveTypeCastToLiteralInComparisonTransformation : NodeTransformationBase`1<ILiteralExpression> {
    private static HashSet`1<Pair`2<ElementType, ElementType>> ourValidConversions;
    private static HashSet`1<Pair`2<ElementType, ElementType>> ourValidConversionsForEquality;
    private ExpressionTyper myExpressionTyper;
    public MoveTypeCastToLiteralInComparisonTransformation(ExpressionTyper expressionTyper);
    private static MoveTypeCastToLiteralInComparisonTransformation();
    protected virtual bool DoApply(ILiteralExpression literal);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.PromoteTypeCastIntoBinaryOperationTransformation : NodeTransformationBase`1<ITypeCastExpression> {
    private ExpressionTyper myExpressionTyper;
    public PromoteTypeCastIntoBinaryOperationTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(ITypeCastExpression typeCast);
    private static bool IsTypeCast(IExpression expression, ElementType type);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.ReduceLiteralTypeCastTransformation : NodeTransformationBase`1<ITypeCastExpression> {
    protected virtual bool DoApply(ITypeCastExpression typeCast);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.ReducePointerToReferenceTypeCastTransformation : NodeTransformationBase`1<ITypeCastExpression> {
    private ExpressionTyper myExpressionTyper;
    public ReducePointerToReferenceTypeCastTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(ITypeCastExpression typeCast);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.ReduceReadDerefTypeCastTransformation : NodeTransformationBase`1<IDerefExpression> {
    private ExpressionTyper myExpressionTyper;
    public ReduceReadDerefTypeCastTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IDerefExpression derefExpression);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.ReduceReadPointerIndirectionTypeCastTransformation : NodeTransformationBase`1<IPointerIndirectionExpression> {
    private ExpressionTyper myExpressionTyper;
    public ReduceReadPointerIndirectionTypeCastTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IPointerIndirectionExpression indirectionExpression);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.ReduceWriteDerefTypeCastTransformation : NodeTransformationBase`1<IDerefExpression> {
    private ExpressionTyper myExpressionTyper;
    public ReduceWriteDerefTypeCastTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IDerefExpression derefExpression);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.ReduceWritePointerIndirectionTypeCastTransformation : NodeTransformationBase`1<IExpressionStatement> {
    private ExpressionTyper myExpressionTyper;
    public ReduceWritePointerIndirectionTypeCastTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IExpressionStatement assignmentStatement);
}
internal class JetBrains.Decompiler.Transformations.TypeCasts.SuppressPromotionOverflowCheckTransformation : NodeTransformationBase`1<ITypeCastExpression> {
    private ExpressionTyper myExpressionTyper;
    public SuppressPromotionOverflowCheckTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(ITypeCastExpression typeCast);
    private static bool IsPromotion(ElementType sourceTtype, ElementType targetType);
}
internal static class JetBrains.Decompiler.Transformations.TypeCasts.TypeCastUtil : object {
    public static bool PrepareTargetForTypeCastElimination(ExpressionTyper expressionTyper, IMemberAccessExpression memberAccess, IMetadataType memberOwnerType, IExpression& target, IMetadataType& targetType);
    private static bool IsExtensionMethod(IMemberAccessExpression memberAccess);
    public static bool IsThisTarget(IExpression target);
}
internal class JetBrains.Decompiler.Transformations.TypedTransformationMap : object {
    private static OneToListMap`2<Type, Type> ourInterfaceToImplementations;
    private OneToListMap`2<Type, INodeTransformation> myTypeToTransformations;
    private static TypedTransformationMap();
    public TypedTransformationMap(IEnumerable`1<INodeTransformation> transformations);
    public IEnumerable`1<INodeTransformation> GetApplicableTransformations(INode node);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractAddressOfTransformation : NodeTransformationBase`1<ITypeCastExpression> {
    protected virtual bool DoApply(ITypeCastExpression typeCast);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractByteStackAllocTransformation : ExtractStackAllocTransformationBase {
    private IImageBodyReader myImageBodyReader;
    public ExtractByteStackAllocTransformation(MethodDecompilerContext context);
    protected virtual bool DoApply(IUntypedStackAllocExpression untypedStackAlloc);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractFixedStatementTransformation : NodeTransformationBase`1<IPinStatement> {
    private ReferencesFinder myFinder;
    public ExtractFixedStatementTransformation(ReferencesFinder finder);
    protected virtual bool DoApply(IPinStatement pinStatement);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractMultibyteStackAllocTransformation : ExtractStackAllocTransformationBase {
    public ExtractMultibyteStackAllocTransformation(MethodDecompilerContext context);
    protected virtual bool DoApply(IUntypedStackAllocExpression untypedStackAlloc);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractNullPointerTransformation : NodeTransformationBase`1<ITypeCastExpression> {
    protected virtual bool DoApply(ITypeCastExpression typeCast);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractPointerArrayCompoundAssignmentTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private ReferencesFinder myFinder;
    private ExpressionTyper myExpressionTyper;
    public ExtractPointerArrayCompoundAssignmentTransformation(ReferencesFinder finder, ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IBinaryOperationExpression arrayElementAssignment);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractPointerArrayPostfixTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private ReferencesFinder myFinder;
    private ExpressionTyper myExpressionTyper;
    public ExtractPointerArrayPostfixTransformation(ReferencesFinder finder, ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IBinaryOperationExpression arrayElementStoreAssignment);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractPointerArrayPrefixTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private ReferencesFinder myFinder;
    private ExpressionTyper myExpressionTyper;
    public ExtractPointerArrayPrefixTransformation(ReferencesFinder finder, ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IBinaryOperationExpression arrayElementOp1);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractPointerElementAccessTransformation : NodeTransformationBase`1<IPointerIndirectionExpression> {
    private ExpressionTyper myExpressionTyper;
    public ExtractPointerElementAccessTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IPointerIndirectionExpression indirectionExpression);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractPointerFieldAccessTransformation : NodeTransformationBase`1<IFieldAccessExpression> {
    private ExpressionTyper myExpressionTyper;
    public ExtractPointerFieldAccessTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IFieldAccessExpression fieldAccess);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractPointerMethodCallTransformation : NodeTransformationBase`1<IMethodCallExpression> {
    private ExpressionTyper myExpressionTyper;
    public ExtractPointerMethodCallTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IMethodCallExpression methodCall);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractPointerOrReferenceComparisonTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    public ExtractPointerOrReferenceComparisonTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IBinaryOperationExpression comparison);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractPointerPropertyAccessTransformation : NodeTransformationBase`1<IPropertyAccessExpression> {
    private ExpressionTyper myExpressionTyper;
    public ExtractPointerPropertyAccessTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IPropertyAccessExpression propertyAccess);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractPointerShiftTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    public ExtractPointerShiftTransformation(ExpressionTyper expressionTyper, MetadataTypeCache typeCache);
    protected virtual bool DoApply(IBinaryOperationExpression binaryOperation);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractPointerSubtractionTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private MetadataTypeCache myTypeCache;
    private ExpressionTyper myExpressionTyper;
    public ExtractPointerSubtractionTransformation(ExpressionTyper expressionTyper, MetadataTypeCache typeCache);
    protected virtual bool DoApply(IBinaryOperationExpression division);
    private void Reduce(IExpression division, IMetadataType underlyingType, IExpression lhsExpression, IExpression rhsExpression, IInstructionReference subtractInstructionReference);
    private IMetadataType GetGenericTypeFromSize(int size);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractReferencePinInlinedTransformation : ExtractReferencePinTransformationBase`1<IAddressOfExpression> {
    public ExtractReferencePinInlinedTransformation(MetadataTypeCache typeCache, ReferencesFinder finder, ExpressionTyper expressionTyper, LocalVariableManager localVariableManager);
    protected virtual bool DoApply(IAddressOfExpression arrayAddress);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractReferencePinTransformation : ExtractReferencePinTransformationBase`1<IExpressionStatement> {
    public ExtractReferencePinTransformation(MetadataTypeCache typeCache, ReferencesFinder finder, ExpressionTyper expressionTyper, LocalVariableManager localVariableManager);
    protected virtual bool DoApply(IExpressionStatement tempVariableAssignmentStatement);
}
internal abstract class JetBrains.Decompiler.Transformations.Unsafe.ExtractReferencePinTransformationBase`1 : NodeTransformationBase`1<T> {
    protected MetadataTypeCache myTypeCache;
    protected ReferencesFinder myFinder;
    protected ExpressionTyper myExpressionTyper;
    protected LocalVariableManager myLocalVariableManager;
    protected ExtractReferencePinTransformationBase`1(MetadataTypeCache typeCache, ReferencesFinder finder, ExpressionTyper expressionTyper, LocalVariableManager localVariableManager);
    protected bool ExtractArrayInitializer(IExpression genericInitializer, IMetadataType tempType, bool arrayIsPinned, IExpression& arrayInitializer, IExpressionStatement& arrayNulling, IStatement& arrayInitializerStatementToRemove);
    private static bool ExtractArrayAssignment(IExpression expression, IBinaryOperationExpression& arrayAssignment, IStatement& arrayInitializerStatementToRemove);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractStackAllocInitializerFromElementsInitializationTransformation : NodeTransformationBase`1<IStackAllocExpression> {
    private ReferencesFinder myFinder;
    public ExtractStackAllocInitializerFromElementsInitializationTransformation(MethodDecompilerContext context);
    protected virtual bool DoApply(IStackAllocExpression stackAlloc);
}
internal abstract class JetBrains.Decompiler.Transformations.Unsafe.ExtractStackAllocTransformationBase : NodeTransformationBase`1<IUntypedStackAllocExpression> {
    protected MetadataTypeCache myTypeCache;
    protected ReferencesFinder myFinder;
    private LocalVariableManager myLocalVariableManager;
    protected ExtractStackAllocTransformationBase(MethodDecompilerContext context);
    protected bool IsLengthAssignment(IExpressionStatement lengthTempAssignmentStatement, ILocalVariable& lengthTempVariable, IExpression& lengthExpression);
    protected static bool IsArrayTempAssignment(IExpressionStatement arrayTempAssignmentStatement, ILocalVariable lengthVariable, ILocalVariableReferenceExpression& arrayTempReference);
    protected static bool IsSpanCreation(IStatement spanLengthAssignmentStatement, IObjectCreationExpression spanCreation, IExpression& spanLengthExpression);
    [ContractAnnotationAttribute("=> notnull, lengthTemp2AssignmentStatement: notnull;=> null, lengthTemp2AssignmentStatement: null")]
protected IExpression GetRealLengthExpression(IExpressionStatement lengthTempAssignmentStatement, IExpression lengthExpression, IExpressionStatement& lengthTemp2AssignmentStatement);
    protected bool HasArrayTempUsage(IStatement arrayTempUsageStatement, ITypeCastExpression& arrayTempUsage, Boolean& isArrayAssignment, ILocalVariableReferenceExpression[] arrayTempReferences);
    [CanBeNullAttribute]
protected IMetadataType GetElementType(ILocalVariableReferenceExpression arrayTempInitReference, IMetadataPointerType& arrayType, IMetadataClassType& spanType, IObjectCreationExpression& spanCreation);
    protected void ReplaceWithStackAlloc(ITypeCastExpression arrayTempUsage, IMetadataType elementType, IMetadataPointerType arrayType, IExpression lengthExpression, IExpressionList initializer, IInstructionReference instructionReference, bool isArrayAssignment);
    protected void ReplaceWithStackAlloc(IExpressionStatement arrayTempAssignmentStatement, ILocalVariableReferenceExpression arrayTempInitReference, IMetadataType elementType, IMetadataPointerType arrayType, IExpression lengthExpression, IExpressionList initializer, IInstructionReference instructionReference);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractStringPinTransformation : NodeTransformationBase`1<IExpressionStatement> {
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myFinder;
    private ExpressionTyper myExpressionTyper;
    private LocalVariableManager myLocalVariableManager;
    public ExtractStringPinTransformation(MetadataTypeCache typeCache, ReferencesFinder finder, ExpressionTyper expressionTyper, LocalVariableManager localVariableManager);
    private bool MatchRuntimeHelpersOffsetToStringData(IExpression expression);
    protected virtual bool DoApply(IExpressionStatement pinnedVariableAssignmentStatement);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ExtractStructVariableInitializationTransformation : NodeTransformationBase`1<IRefExpression> {
    private ReferencesFinder myReferencesFinder;
    private ExpressionTyper myExpressionTyper;
    public ExtractStructVariableInitializationTransformation(ReferencesFinder referencesFinder, ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IRefExpression refExpression);
}
internal static class JetBrains.Decompiler.Transformations.Unsafe.FixedElementFieldEliminator : object {
    public static void Run(IDecompiledMethodBase method, MetadataTypeCache typeCache, ExpressionTyper expressionTyper);
}
internal static class JetBrains.Decompiler.Transformations.Unsafe.IndirectionToZeroElementAccessReducer : object {
    public static void Run(IDecompiledMethodBase method, MetadataTypeCache typeCache, ExpressionTyper expressionTyper);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.InlineIntPtrTypeCastTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    private ReferencesFinder myReferencesFinder;
    private LocalVariableManager myLocalVariableManager;
    public InlineIntPtrTypeCastTransformation(ExpressionTyper expressionTyper, MetadataTypeCache typeCache, ReferencesFinder referencesFinder, LocalVariableManager localVariableManager);
    protected virtual bool DoApply(IBinaryOperationExpression assignment);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.MarkUnsafeFieldsTransformation : object {
    public sealed virtual bool Apply(IDecompiledClass decompiledClass);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ReduceIntPtrInPointerBinaryOperationTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private MetadataTypeCache myTypeCache;
    private ExpressionTyper myExpressionTyper;
    public ReduceIntPtrInPointerBinaryOperationTransformation(MetadataTypeCache typeCache, ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IBinaryOperationExpression binaryOperation);
    private bool ReduceArgument(IExpression expression);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ReducePointerAccessTransformation : NodeTransformationBase`1<IAddressOfExpression> {
    protected virtual bool DoApply(IAddressOfExpression addressOf);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ReducePointerDiffTypeCastTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    public ReducePointerDiffTypeCastTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IBinaryOperationExpression diff);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.ReduceReferenceArithmeticTransformation : NodeTransformationBase`1<IBinaryOperationExpression> {
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    public ReduceReferenceArithmeticTransformation(ExpressionTyper expressionTyper, MetadataTypeCache typeCache);
    protected virtual bool DoApply(IBinaryOperationExpression binaryOperation);
}
internal class JetBrains.Decompiler.Transformations.Unsafe.SimplifyPointerParameterAccessTransformation : NodeTransformationBase`1<IPointerIndirectionExpression> {
    private ExpressionTyper myExpressionTyper;
    public SimplifyPointerParameterAccessTransformation(ExpressionTyper expressionTyper);
    protected virtual bool DoApply(IPointerIndirectionExpression indirection);
}
internal static class JetBrains.Decompiler.Transformations.Unsafe.UnsafeUtil : object {
    public static IMetadataType TryGetUnderlyingPointerType(IMetadataType type);
    public static IMetadataType TryGetUnderlyingReferenceType(IMetadataType type);
    public static IMetadataType TryGetUnderlyingType(IMetadataType type);
    public static IMetadataType GetUnderlyingType(IMetadataType type);
    [CanBeNullAttribute]
public static IArrayElementAccessExpression GetArrayElementAccessPinned(IExpression thenTypeCastArgument, IExpression else, IMetadataType type, ILocalVariable pinnedArrayVariable);
    [CanBeNullAttribute]
public static IArrayElementAccessExpression GetArrayElementAccess(IExpression thenTypeCastArgument, IExpression else, IMetadataType type, ILocalVariable pinnedArrayVariable);
    [CanBeNullAttribute]
private static IArrayElementAccessExpression GetArrayElementAccess(IExpression argument, ILocalVariable arrayVariable);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractArrayUserDefinedCompoundAssignmentTransformation : ExtractArrayCompoundAssignmentTransformationBase`1<IUserDefinedBinaryOperationExpression> {
    public ExtractArrayUserDefinedCompoundAssignmentTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool IsValidLhsTypeCast(ITypeCastExpression lhsTypeCast, IArrayElementAccessExpression arrayLoad);
    protected virtual IUserDefinedBinaryOperationExpression CreateBinaryOperation(IUserDefinedBinaryOperationExpression baseBinaryOperation, OperationType operationType, IExpression leftArgument, IExpression rightArgument);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractArrayUserDefinedPostfixExpressionTransformation : ExtractArrayPostfixExpressionTransformationBase`1<IMethodCallExpression> {
    public ExtractArrayUserDefinedPostfixExpressionTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual IBinaryOperationExpression ExtractTempAssignment(IMethodCallExpression operation);
    protected virtual bool CheckOperation(IMethodCallExpression operation);
    protected virtual bool ToPostfixOperationType(IMethodCallExpression operation, OperationType& operationType);
    protected virtual IExpression WrapUnary(IExpression expression, OperationType operationType, IMethodCallExpression operation);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractArrayUserDefinedPrefixTransformation : ExtractArrayPrefixTransformationBase`1<IMethodCallExpression> {
    public ExtractArrayUserDefinedPrefixTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual IArrayElementAccessExpression ExtractArrayLoad(IMethodCallExpression operation);
    protected virtual bool CheckOperation(IMethodCallExpression operation);
    protected virtual bool ToPrefixOperationType(IMethodCallExpression operation, OperationType& operationType);
    protected virtual IExpression WrapUnary(IExpression expression, OperationType operationType, IMethodCallExpression operation);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractCopyingPrefixExpressionTransformation : CondNodeTransformationBase`1<IExpressionStatement> {
    private ReferencesFinder myFinder;
    public ExtractCopyingPrefixExpressionTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(IExpressionStatement targetCopyAssignmentStatement);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractCopyingPrefixStatementTransformation : CondNodeTransformationBase`1<IExpressionStatement> {
    private ReferencesFinder myFinder;
    public ExtractCopyingPrefixStatementTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(IExpressionStatement targetCopyAssignmentStatement);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractCopyingUserDefinedCompoundAssignmentExpressionTransformation : ExtractCopyingCompoundAssignmentExpressionTransformationBase`1<IUserDefinedBinaryOperationExpression> {
    public ExtractCopyingUserDefinedCompoundAssignmentExpressionTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool GetValidLhsAndEquivalentTypes(IExpression storeExpression, IMetadataType& lhsType, IMetadataType& equivalentType);
    protected virtual IMetadataType GetRhsType(IMetadataType lhsType, OperationType operationType);
    protected virtual IExpression CreateBinaryOperation(OperationType operationType, IUserDefinedBinaryOperationExpression baseBinaryOperation, IExpression leftArgument, IExpression rightArgument, OverflowCheckType overflowCheck, IMetadataType type);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractCopyingUserDefinedCompoundAssignmentStatementTransformation : ExtractCopyingCompoundAssignmentStatementTransformationBase`1<IUserDefinedBinaryOperationExpression> {
    public ExtractCopyingUserDefinedCompoundAssignmentStatementTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool GetValidLhsAndEquivalentTypes(IBinaryOperationExpression storeAssignment, IMetadataType& lhsType, IMetadataType& equivalentType);
    protected virtual IMetadataType GetRhsType(IMetadataType lhsType, OperationType operationType);
    protected virtual IUserDefinedBinaryOperationExpression CreateBinaryOperation(OperationType operationType, IUserDefinedBinaryOperationExpression baseBinaryOperation, IExpression leftArgument, IExpression rightArgument, OverflowCheckType overflowCheck);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractCopyingUserDefinedPostfixExpressionTransformation : ExtractCopyingPostfixExpressionTransformationBase`1<IMethodCallExpression> {
    public ExtractCopyingUserDefinedPostfixExpressionTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool GetValidLhsAndEquivalentTypes(IExpression storeExpression, IMetadataType& lhsType, IMetadataType& equivalentType);
    protected virtual bool ToPostfixOperationType(IMethodCallExpression operation, OperationType& operationType);
    protected virtual bool GetInnerLoadAssignment(IMethodCallExpression operation, IBinaryOperationExpression& innerLoadAssignment, ITypeCastExpression& evaluationTypeCast);
    protected virtual OverflowCheckType GetOverflowCheck(IMethodCallExpression operation);
    protected virtual bool CheckOperation(IMethodCallExpression operation, IMetadataType lhsType, ITypeCastExpression evaluationTypeCast, ILocalVariable tempVariable1);
    protected virtual IExpression WrapUnary(IExpression expression, OperationType operationType, IMethodCallExpression baseOperation, OverflowCheckType overflowCheck, IMetadataType type);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractIndexerPrefixTransformation : CondNodeTransformationBase`1<IBinaryOperationExpression> {
    private ReferencesFinder myFinder;
    public ExtractIndexerPrefixTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(IBinaryOperationExpression outerAssignment);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractIndexerUserDefinedCompoundAssignmentTransformation : ExtractIndexerCompoundAssignmentTransformationBase`1<IUserDefinedBinaryOperationExpression> {
    public ExtractIndexerUserDefinedCompoundAssignmentTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool GetValidLhsType(IIndexerCallExpression indexerStore, IMetadataType& lhsType);
    protected virtual IMetadataType GetRhsType(IMetadataType lhsType, OperationType operationType);
    protected virtual IUserDefinedBinaryOperationExpression CreateBinaryOperation(OperationType operationType, IUserDefinedBinaryOperationExpression baseBinaryOperation, IExpression leftArgument, IExpression rightArgument, IInstructionReference instructionReference, OverflowCheckType overflowCheck);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractIndexerUserDefinedPostfixExpressionTransformation : ExtractIndexerPostfixExpressionTransformationBase`1<IMethodCallExpression> {
    public ExtractIndexerUserDefinedPostfixExpressionTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool GetValidLhsType(IIndexerCallExpression indexerStore, IMetadataType& lhsType);
    protected virtual bool ToPostfixOperationType(IMethodCallExpression operation, OperationType& operationType);
    protected virtual bool GetTempAssignment(IMethodCallExpression operation, IBinaryOperationExpression& tempAssignment, ITypeCastExpression& evaluationTypeCast);
    protected virtual OverflowCheckType GetOverflowCheck(IMethodCallExpression operation);
    protected virtual bool CheckOperation(IMethodCallExpression operation, ITypeCastExpression evaluationTypeCast, IMetadataType lhsType);
    protected virtual IExpression WrapUnary(IExpression expression, OperationType operationType, IMethodCallExpression baseOperation, OverflowCheckType overflowCheck, IMetadataType type);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractRefParamCopyingUserDefinedPostfixExpressionTransformation : ExtractRefParamCopyingPostfixExpressionTransformationBase`1<IMethodCallExpression> {
    public ExtractRefParamCopyingUserDefinedPostfixExpressionTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool CheckOperation(IMethodCallExpression operation, ILocalVariable localVariable, ITypeCastExpression& evaluationTypeCast);
    protected virtual bool ToPostfixOperationType(IMethodCallExpression operation, OperationType& operationType);
    protected virtual bool GetValidRefParamTypeAndEquivalentType(IExpression expression, IMetadataType& refParamType, IMetadataType& equivalentType);
    protected virtual OverflowCheckType GetOverflowCheck(IMethodCallExpression operation);
    protected virtual IExpression WrapUnary(IExpression expression, OperationType operationType, IMethodCallExpression baseOperation, OverflowCheckType overflowCheck, IMetadataType type);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractRefParamCopyingUserDefinedPrefixExpressionTransformation : ExtractRefParamCopyingPrefixExpressionTransformationBase`1<IMethodCallExpression> {
    public ExtractRefParamCopyingUserDefinedPrefixExpressionTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool CheckOperation(IMethodCallExpression operation, IMethodParameter refParam, IMetadataType refParamType, ITypeCastExpression& evaluationTypeCast, IDerefExpression& derefRefParamExpression);
    protected virtual bool ToPrefixOperationType(IMethodCallExpression operation, OperationType& operationType);
    protected virtual bool GetEquivalentType(IMetadataType refParamType, IMetadataType& equivalentType);
    protected virtual OverflowCheckType GetOverflowCheck(IMethodCallExpression operation);
    protected virtual IExpression WrapUnary(IExpression expression, OperationType operationType, IMethodCallExpression baseOperation, OverflowCheckType overflowCheck, IMetadataType type);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractSimpleUserDefinedCompoundAssignmentTransformation : ExtractSimpleCompoundAssignmentTransformationBase`1<IUserDefinedBinaryOperationExpression> {
    public ExtractSimpleUserDefinedCompoundAssignmentTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool GetValidLhsType(IExpression lhsExpression, IMetadataType& lhsType);
    protected virtual IMetadataType GetRhsType(IMetadataType lhsType, OperationType operationType);
    protected virtual IUserDefinedBinaryOperationExpression CreateBinaryOperation(OperationType operationType, IUserDefinedBinaryOperationExpression baseBinaryOperation, IExpression leftArgument, IExpression rightArgument, OverflowCheckType overflowCheck);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractSimpleUserDefinedPostfixExpressionTransformation : CondNodeTransformationBase`1<IExpressionStatement> {
    private ReferencesFinder myReferencesFinder;
    public ExtractSimpleUserDefinedPostfixExpressionTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(IExpressionStatement tempAssignmentStatement);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractSimpleUserDefinedPrefixExpressionTransformation : CondNodeTransformationBase`1<IBinaryOperationExpression> {
    public ExtractSimpleUserDefinedPrefixExpressionTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(IBinaryOperationExpression assignment);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractSimpleUserDefinedPrefixExpressionTransformation2 : CondNodeTransformationBase`1<IExpressionStatement> {
    private ReferencesFinder myReferencesFinder;
    public ExtractSimpleUserDefinedPrefixExpressionTransformation2(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(IExpressionStatement tempAssignmentStatement);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractUserDefinedConditionalLogicTransformation : object {
    private bool myIsEnabled;
    public ExtractUserDefinedConditionalLogicTransformation(MethodDecompilerContext methodDecompilerContext);
    public sealed virtual bool Apply(ControlFlowBlock branchBlock);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractUserDefinedConditionalLogicTransformation2 : object {
    private bool myIsEnabled;
    private ReferencesFinder myReferencesFinder;
    public ExtractUserDefinedConditionalLogicTransformation2(MethodDecompilerContext methodDecompilerContext);
    public sealed virtual bool Apply(ControlFlowBlock branchBlock);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractUserDefinedOperatorTransformation : CondNodeTransformationBase`1<IMethodCallExpression> {
    private static Dictionary`2<UserDefinedOperator, OperationType> Map;
    public ExtractUserDefinedOperatorTransformation(MethodDecompilerContext methodDecompilerContext);
    private static ExtractUserDefinedOperatorTransformation();
    protected virtual bool DoApply(IMethodCallExpression methodCall);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractUserDefinedTypeCastTransformation : CondNodeTransformationBase`1<IMethodCallExpression> {
    public ExtractUserDefinedTypeCastTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(IMethodCallExpression methodCall);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ReduceOpFalseTransformation : NodeTransformationBase`1<IMethodCallExpression> {
    private MetadataTypeCache myTypeCache;
    public ReduceOpFalseTransformation(MetadataTypeCache typeCache);
    protected virtual bool DoApply(IMethodCallExpression methodCall);
}
internal class JetBrains.Decompiler.Transformations.UserDefinedOperators.ReduceOpTrueTransformation : NodeTransformationBase`1<IMethodCallExpression> {
    private MetadataTypeCache myTypeCache;
    public ReduceOpTrueTransformation(MetadataTypeCache typeCache);
    protected virtual bool DoApply(IMethodCallExpression methodCall);
}
internal enum JetBrains.Decompiler.Transformations.UserDefinedOperators.UserDefinedOperator : Enum {
    public int value__;
    public static UserDefinedOperator None;
    public static UserDefinedOperator Decrement;
    public static UserDefinedOperator Increment;
    public static UserDefinedOperator UnaryNegation;
    public static UserDefinedOperator UnaryPlus;
    public static UserDefinedOperator LogicalNot;
    public static UserDefinedOperator True;
    public static UserDefinedOperator False;
    public static UserDefinedOperator AddressOf;
    public static UserDefinedOperator OnesComplement;
    public static UserDefinedOperator PointerDereference;
    public static UserDefinedOperator Addition;
    public static UserDefinedOperator Subtraction;
    public static UserDefinedOperator Multiply;
    public static UserDefinedOperator Division;
    public static UserDefinedOperator Modulus;
    public static UserDefinedOperator ExclusiveOr;
    public static UserDefinedOperator BitwiseAnd;
    public static UserDefinedOperator BitwiseOr;
    public static UserDefinedOperator LogicalAnd;
    public static UserDefinedOperator LogicalOr;
    public static UserDefinedOperator Assign;
    public static UserDefinedOperator LeftShift;
    public static UserDefinedOperator RightShift;
    public static UserDefinedOperator SignedRightShift;
    public static UserDefinedOperator UnsignedRightShift;
    public static UserDefinedOperator Equality;
    public static UserDefinedOperator GreaterThan;
    public static UserDefinedOperator LessThan;
    public static UserDefinedOperator Inequality;
    public static UserDefinedOperator GreaterThanOrEqual;
    public static UserDefinedOperator LessThanOrEqual;
    public static UserDefinedOperator UnsignedRightShiftAssignment;
    public static UserDefinedOperator MemberSelection;
    public static UserDefinedOperator RightShiftAssignment;
    public static UserDefinedOperator MultiplicationAssignment;
    public static UserDefinedOperator PointerToMemberSelection;
    public static UserDefinedOperator SubtractionAssignment;
    public static UserDefinedOperator ExclusiveOrAssignment;
    public static UserDefinedOperator LeftShiftAssignment;
    public static UserDefinedOperator ModulusAssignment;
    public static UserDefinedOperator AdditionAssignment;
    public static UserDefinedOperator BitwiseAndAssignment;
    public static UserDefinedOperator BitwiseOrAssignment;
    public static UserDefinedOperator Comma;
    public static UserDefinedOperator DivisionAssignment;
    public static UserDefinedOperator Implicit;
    public static UserDefinedOperator Explicit;
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.Transformations.UserDefinedOperators.UserDefinedOperatorEx : object {
    private static DataKey`1<UserDefinedOperator> ourOperatorKey;
    private static DataKey`1<OverflowCheckType> ourOverflowCheckKey;
    private static Dictionary`2<string, UserDefinedOperator> Map;
    private static HashSet`1<string> ourCheckedOperators;
    private static Dictionary`2<string, string> ourUncheckedToChecked;
    private static UserDefinedOperatorEx();
    [ExtensionAttribute]
public static UserDefinedOperator ToUserDefinedOperator(IMethodCallExpression methodCall);
    private static UserDefinedOperator ResolveOperator(IMethodCallExpression methodCall);
    [ExtensionAttribute]
public static OverflowCheckType GetUserDefinedOperatorOverflowCheck(IMethodCallExpression methodCall);
    private static OverflowCheckType GetOverflowCheck(IMethodCallExpression methodCall);
    [ExtensionAttribute]
public static bool IsInBooleanExpressionPosition(IExpression condition);
}
internal class JetBrains.Decompiler.Transformations.Using.ExtractAwaitUsingTransformation : ExtractUsingTransformationBase {
    public ExtractAwaitUsingTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool IsAwait();
    protected virtual bool DoApply(ITryStatement tryStatement);
    public static bool IsFinallyDisposeAsync(ITryStatement tryStatement, ILocalVariable disposable, Int32& disposableReferencesCount);
    public static bool IsDisposeAsync(IStatement statement, ILocalVariable disposable, Int32& disposableReferencesCount);
    private static bool IsIfNotNullDisposeAsync(IIfStatement if, ILocalVariable disposable);
    private static bool IsDisposeAsync(IStatement statement, ILocalVariable disposable);
    private static bool IsDisposeAsync(IMethodCallExpression methodCall);
}
internal class JetBrains.Decompiler.Transformations.Using.ExtractAwaitUsingWithReturnTransformation : ExtractUsingTransformationBase {
    public ExtractAwaitUsingWithReturnTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool IsAwait();
    protected virtual bool DoApply(ITryStatement tryStatement);
    private void InlineReturn(IUsingStatement usingStatement, ILocalVariable result, IExpressionStatement resultClearingStatement, ILocalVariable returnMark, IExpressionStatement returnMarkInitAssignmentStatement, IIfStatement returnMarkCheck, ILabelDeclarationStatement noReturnLabelDeclaration, IStatement nextStatement);
    private static void RemoveUnusedLabelsAndGotos(IUsingStatement usingStatement, ILabelDeclarationStatement noReturnLabelDeclaration, ILabelDeclarationStatement returnLabelDeclaration, List`1<IGotoStatement> gotoReturnLabelStatements);
    [CanBeNullAttribute]
private static ILabelDeclarationStatement FindReturnLabel(IUsingStatement usingStatement, ILocalVariable returnMark);
    private static bool IsReturnMarkSet1(IStatement statement, ILocalVariable returnMark);
    [CanBeNullAttribute]
private static IStatement GetNextStatementSkipGoto(IStatement statement, ILabelDeclarationStatement labelDeclaration, IGotoStatement& gotoStatement);
    [CanBeNullAttribute]
private static IStatement GetNextStatement(IStatement statement);
    private static bool IsEndPointOf(IStatement statement, IStatement outerStatement);
}
internal class JetBrains.Decompiler.Transformations.Using.ExtractNotNullableUsingTransformation : ExtractUsingTransformationBase {
    private MethodSpecification myDisposeSpecification;
    private MethodSpecification DisposeSpecification { get; }
    public ExtractNotNullableUsingTransformation(MethodDecompilerContext methodDecompilerContext);
    private MethodSpecification get_DisposeSpecification();
    protected virtual bool DoApply(ITryStatement tryStatement);
}
internal class JetBrains.Decompiler.Transformations.Using.ExtractNullableUsingTransformation : ExtractUsingTransformationBase {
    public ExtractNullableUsingTransformation(MethodDecompilerContext methodDecompilerContext);
    protected virtual bool DoApply(ITryStatement tryStatement);
}
internal abstract class JetBrains.Decompiler.Transformations.Using.ExtractUsingTransformationBase : CondNodeTransformationBase`1<ITryStatement> {
    protected ReferencesFinder Finder;
    private LocalVariableManager myLocalVariableManager;
    protected MetadataTypeCache myTypeCache;
    protected ExtractUsingTransformationBase(MethodDecompilerContext methodDecompilerContext);
    protected bool TryExtract(ITryStatement tryStatement, IUsingStatement& usingStatement, ILocalVariable disposableCopy, IBinaryOperationExpression copyAssignment, IExpression disposable, IBinaryOperationExpression copyClearing, int auxCopyReferencesCount, bool copyVariableCanBeReused, IStatement[] statementsToRemove);
    protected static bool MatchClearingAssignmentStatement(IStatement statement, ILocalVariable clearingVariable, IExpressionStatement& clearingAssignmentStatement, IBinaryOperationExpression& clearingAssignment);
    protected virtual bool IsAwait();
}
internal class JetBrains.Decompiler.Typing.ExpressionTyper : object {
    internal static DataKey`1<IMetadataType> TypeKey;
    private static DataKey`1<bool> IsPropagatedConditionalAccessKey;
    private static DataKey`1<bool> IsFixedArrayFieldKey;
    private MetadataTypeCache myTypeCache;
    private IDecompiledMethodBase myMethod;
    private IMetadataTypeInfo myDeclaringTypeInfo;
    public ExpressionTyper(MetadataTypeCache typeCache, IDecompiledMethodBase method);
    public ExpressionTyper(MetadataTypeCache typeCache, IDecompiledMethodBase method, IMetadataTypeInfo declaringTypeInfo);
    private static ExpressionTyper();
    public bool HasType(IExpression expression);
    [CanBeNullAttribute]
public IMetadataType GetType(IExpression expression);
    private static bool IsPropagatedConditionalAccess(IAccessExpression access);
    public void ResetTypes(INode root);
    public void ResetType(INode node);
    public void SetFixedArrayFieldType(IFieldAccessExpression fixedArrayField);
    public bool IsFixedArrayField(IFieldAccessExpression fieldAccess);
    [CanBeNullAttribute]
private IMetadataType InferType(IExpression expression);
    private IMetadataType InferThisType(IThisReferenceExpression expression);
    private IMetadataType InferBaseType(IBaseReferenceExpression expression);
    private static IMetadataType InferLiteralType(ILiteralExpression literal);
    private IMetadataType InferBinaryOperationType(IBinaryOperationExpression expression);
    [CanBeNullAttribute]
private IMetadataType InferBinaryOperationTypeCore(OperationType operationType, IMetadataType leftType, IMetadataType rightType);
    private IMetadataType InferConditionalType(IConditionalExpression expression);
    private IMetadataType InferThrowExpressionType(IThrowExpression throw);
    private IMetadataType InferEntityAccessType(IAccessExpression entityAccess, IMetadataType entityType);
    private IMetadataType ToNullableIfValueType(IMetadataType type);
}
internal class JetBrains.Decompiler.Typing.PointerTemporaryTypeFixer : object {
    private MetadataTypeCache myTypeCache;
    private LocalVariableManager myLocalVariableManager;
    private ReferencesFinder myFinder;
    private ExpressionTyper myExpressionTyper;
    private IDecompiledMethodBase myMethod;
    private PointerTemporaryTypeFixer(MetadataTypeCache typeCache, LocalVariableManager localVariableManager, ReferencesFinder finder, ExpressionTyper expressionTyper, IDecompiledMethodBase method);
    public static void Run(MetadataTypeCache typeCache, LocalVariableManager localVariableManager, ReferencesFinder finder, ExpressionTyper expressionTyper, IDecompiledMethodBase method);
    private void Run();
    private void Fix(IBinaryOperationExpression assignment, ILocalVariable variable, IExpression argument, IMetadataPointerType argumentType);
}
internal class JetBrains.Decompiler.Typing.TypeCastInserter : object {
    private ControlFlowGraph myGraph;
    private ExpressionTyper myExpressionTyper;
    private MetadataTypeCache myTypeCache;
    private Dictionary`2<Pair`2<MetadataToken, MetadataToken>, bool> myHasOverloadedEqualityOperator;
    private TypeCastInserter(ControlFlowGraph graph, ExpressionTyper expressionTyper, MetadataTypeCache typeCache);
    public static void Run(ControlFlowGraph graph, ExpressionTyper expressionTyper, MetadataTypeCache typeCache);
    private void Run();
    private bool TryGetType(IExpression expression, IMetadataTypeInfo& type, Boolean& isNullType);
    private bool HasOverloadedEqualityOperatorCached(IMetadataTypeInfo type);
    private static bool HasOverloadedEqualityOperator(IMetadataTypeInfo type);
    private void InsertTypeCast(IExpression expression, IMetadataType expectedType);
    [CompilerGeneratedAttribute]
private void <Run>b__6_0(IBinaryOperationExpression expression);
}
internal static class JetBrains.Decompiler.Utils.AstDumpUtil : object {
    private static string Indent;
    public static void DumpCSharpPresentationToNotepad(INode node, string comment);
    public static void DumpCSharpPresentationToNotepad(ControlFlowRegion region, string comment);
    public static void DumpToGraphDescriptionLanguage(ControlFlowRegion region, string comment);
    private static void ShowFile(Action`1<StreamWriter> dumpAction);
    public static void DumpToNotepad(ControlFlowRegion region, string comment, bool instructionInfo);
    public static void DumpToNotepad(INode node, string comment, bool instructionInfo);
    private static void DumpToGraphDescriptionLanguage(ControlFlowRegion region, string comment, StreamWriter sw);
    public static string GetEdge(ControlFlowBlock from, ControlFlowBlock to, string label, string color);
    public static string GetId(ControlFlowBlock block);
    public static string CodeHtml(ControlFlowBlock block);
    private static void Dump(ControlFlowRegion region, string comment, StreamWriter sw, bool instructionInfo, NodePresentationStyle style);
    private static void DumpBlockTree(ControlFlowBlock block, StreamWriter sw, string indent, bool instructionInfo);
    private static void DumpBlockCode(ControlFlowBlock block, StreamWriter sw);
    private static void DumpNode(INode node, StreamWriter sw, string indent, bool noIndent, bool instructionInfo);
    private static string RenderInstructionInfoIf(IInstructionReference instructionReference, bool condition);
    private static string GetInstructionInfo(IInstructionReference instructionReference);
    private static string GetOperandInfo(object operand);
    private static string GetNodeInfo(INode node);
    private static string GetOverflowCheck(OverflowCheckType overflowCheck);
    private static string GetFunctionSignatureInfo(FunctionSignature functionSignature);
    private static string GetTypeName(IMetadataType type);
    public static string PresentConstant(Constant constant);
}
internal static class JetBrains.Decompiler.Utils.CorrelationUtil : object {
    public static bool AreCorrelated(IExpression readExpression, IStatement writeStatement);
    public static void CollectCorrelations(INode node, CorrelationMode mode, JetHashSet`1<IMetadataTypeMember> members, JetHashSet`1<object> byRefEntities);
}
public class JetBrains.Decompiler.Utils.DataHolder : object {
    private LocalList`1<KeyValuePair`2<object, object>> mySlots;
    public bool TryGetValue(DataKey`1<T> key, T& value);
    public T GetValue(DataKey`1<T> key, T defaultValue);
    public T GetValue(DataKey`1<T> key);
    public void SetValue(DataKey`1<T> key, T value);
    public void SetValueUntyped(object key, object value);
    public bool RemoveValue(DataKey`1<T> key);
    public bool RemoveValueUntyped(object key);
    private int FindKey(object key);
    [IteratorStateMachineAttribute("JetBrains.Decompiler.Utils.DataHolder/<GetEnumerator>d__9")]
public sealed virtual IEnumerator`1<KeyValuePair`2<object, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DebuggerDisplayAttribute("Key: {ToString()}")]
public class JetBrains.Decompiler.Utils.DataKey`1 : object {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; }
    public DataKey`1(string text);
    [CompilerGeneratedAttribute]
public string get_Text();
    public virtual string ToString();
}
internal class JetBrains.Decompiler.Utils.DisjointSetUnion`1 : object {
    public Node<T> AddSingleton(T value);
    public Node<T> GetRoot(Node<T> node);
    public Node<T> Unite(Node<T> node1, Node<T> node2);
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.Utils.DisposableUtil : object {
    public static bool TryDispose(object obj);
    public static bool TryDisposeAndSetNull(T& disposable);
    [ExtensionAttribute]
public static bool TryDispose(IDisposable disposable);
}
internal static class JetBrains.Decompiler.Utils.EnumValueUtil : object {
    public static IExpression ParseConstant(Constant constant);
    private static IExpression JoinEnumElements(IEnumerable`1<EnumMember> members);
    private static IExpression CreateDefaultEnumExpression(Constant constant, bool convertValue);
    private static Nullable`1<EnumMember> FindValue(IEnumerable`1<EnumMember> members, ulong value);
    private static IEnumerable`1<EnumMember> DecomposeValue(IList`1<EnumMember> members, ulong value);
    private static int NumberOfSetBits(ulong value);
    private static IList`1<EnumMember> GetEnumMembers(IMetadataType enumType);
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.Utils.ExpressionBodiedMembersUtil : object {
    private static int ComplexityThreshold;
    private static int MaxComplexity;
    [ExtensionAttribute]
public static bool IsExpressionBodied(IDecompiledMethodBase decompiledMethod);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IExpression GetBodyExpression(IBlockStatement methodBody);
    public static void TryConvertToExpressionBodied(IDecompiledMethodBase method);
    private static int GetComplexity(INode node);
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.Utils.ExpressionEx : object {
    [ExtensionAttribute]
public static bool IsExtensionMethod(IMethodCallExpression methodCall);
    [ExtensionAttribute]
public static bool IsNullComparison(IExpression expression, bool negate, ILocalVariable& targetVariable, IExpression& target);
    [ExtensionAttribute]
public static bool IsNullComparison(IBinaryOperationExpression nullComparison, Boolean& negation);
    [ExtensionAttribute]
public static bool IsNullableHasValue(IExpression expression, bool negate, MetadataTypeCache typeCache, ILocalVariable& targetVariable, IExpression& target);
    private static bool IsAcceptableTarget(IExpression target);
    [ExtensionAttribute]
public static bool IsNullableGetValueOrDefault(IExpression expression, ILocalVariable targetVariable, IExpression target, MetadataTypeCache typeCache);
    [ExtensionAttribute]
private static bool MatchVariableOrExpression(IExpression expression, ILocalVariable targetVariable, IExpression target);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static INode GetParentSkipCast(IExpression expression, bool isMandatory, IMetadataType expectedType);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IExpression GetParentCastOrCurrent(IExpression expression, bool isMandatory, IMetadataType expectedType);
    [ExtensionAttribute]
public static IExpression SkipTypeCast(IExpression expression);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITypeCastExpression GetOuterTypeCast(IExpression expression);
    [ExtensionAttribute]
public static bool TryGetNonConditionalEntityAccess(IExpression expression, bool isNullableTarget, ILocalVariable targetVariable, IExpression target, MetadataTypeCache typeCache, IAccessExpression& entityAccess, IExpression& entityAccessTarget);
    [ExtensionAttribute]
public static bool TryUnwrapNullableCreation(IExpression expression, bool isNullable, ExpressionTyper expressionTyper, IExpression& unwrappedExpression);
    [ExtensionAttribute]
public static bool IsNull(IExpression expression, Boolean& isNullable);
    [ExtensionAttribute]
public static bool IsDisposeCall(IMethodCallExpression disposeCall, bool conditional, MetadataTypeCache typeCache);
    [ExtensionAttribute]
public static bool IsDisposeCall(IMethodCallExpression disposeCall, bool conditional, ILocalVariable target, bool maybeTargetCastToIDisposable, MetadataTypeCache typeCache);
    [ExtensionAttribute]
public static bool IsLocalVariableMaybeCastRef(IExpression expression, ILocalVariable variable);
    [ExtensionAttribute]
public static bool IsSimple(IExpression expression);
    [ExtensionAttribute]
public static bool IsSimple2(IExpression expression);
    [ExtensionAttribute]
public static bool IsSimpleIndexer(IExpression expression, IIndexerCallExpression& indexer);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ILocalVariableReferenceExpression GetOtherReference(ReferencesFinder referencesFinder, ILocalVariableReferenceExpression reference);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ILocalVariableReferenceExpression GetOtherReference(ReferencesFinder referencesFinder, ILocalVariableReferenceExpression[] references);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, target: notnull, methodPointer: notnull; => false, target: null, methodPointer: null")]
public static bool IsDelegateCreation(IObjectCreationExpression objectCreation, MetadataTypeCache typeCache, IExpression& target, IExpression& methodPointer);
    [ExtensionAttribute]
public static bool IsDelegateCreation(IObjectCreationExpression objectCreation, MetadataTypeCache typeCache, ILocalVariable targetVariable, ILocalVariable methodPointerVariable);
}
[DefaultMemberAttribute("Item")]
internal class JetBrains.Decompiler.Utils.ExtensionManager`2 : object {
    private Func`2<TExtendable, TExtension> myExtensionFactory;
    private Dictionary`2<TExtendable, TExtension> myExtensions;
    public TExtension Item { get; }
    public ExtensionManager`2(Func`2<TExtendable, TExtension> extensionFactory);
    public bool HasExtension(TExtendable extendable);
    public bool RemoveExtension(TExtendable extendable);
    public TExtension get_Item(TExtendable extendable);
}
internal class JetBrains.Decompiler.Utils.IdGenerator`1 : object {
    private BidirectionalMap`2<T, int> myMap;
    private int myCurrentId;
    public IdGenerator`1(IEnumerable`1<T> keys);
    public int GetId(T key);
    public T GetKey(int id);
}
internal class JetBrains.Decompiler.Utils.InstructionMatcher : object {
    private IList`1<Instruction> myInstructions;
    private bool myIsMatch;
    [CompilerGeneratedAttribute]
private int <CurrentIndex>k__BackingField;
    public int CurrentIndex { get; public set; }
    public Instruction CurrentInstruction { get; }
    public bool IsAfterLast { get; }
    public bool IsBeforeFirst { get; }
    public InstructionMatcher(IList`1<Instruction> instructions);
    public InstructionMatcher(IList`1<Instruction> instructions, int currentIndex);
    [CompilerGeneratedAttribute]
public int get_CurrentIndex();
    [CompilerGeneratedAttribute]
public void set_CurrentIndex(int value);
    public Instruction get_CurrentInstruction();
    public bool get_IsAfterLast();
    public bool get_IsBeforeFirst();
    public InstructionMatcher Clone();
    public static bool op_Implicit(InstructionMatcher matcher);
    public InstructionMatcher SkipForward(Predicate`1<Instruction> predicate);
    public InstructionMatcher SkipForward(OpcodeValue opcodeValue);
    public InstructionMatcher MatchForward(Predicate`1<Instruction> predicate);
    public InstructionMatcher MatchForward(OpcodeValue opcodeValue);
    public InstructionMatcher MatchForward(Instruction& instruction, OpcodeValue opcodeValue);
    public InstructionMatcher MatchForward(Instruction& instruction, Predicate`1<Instruction> predicate);
    public InstructionMatcher MatchForward(Instruction& instruction, Nullable`1<OpcodeValue> opcodeValue, Predicate`1<Instruction> predicate);
    public InstructionMatcher MatchBackward(Predicate`1<Instruction> predicate);
    public InstructionMatcher MatchBackward(OpcodeValue opcodeValue);
    public InstructionMatcher MatchBackward(Instruction& instruction, OpcodeValue opcodeValue);
    public InstructionMatcher MatchBackward(Instruction& instruction, Predicate`1<Instruction> predicate);
    public InstructionMatcher MatchBackward(Instruction& instruction, Nullable`1<OpcodeValue> opcodeValue, Predicate`1<Instruction> predicate);
    private InstructionMatcher Fail();
}
internal class JetBrains.Decompiler.Utils.IntRange : ValueType {
    public static IntRange Empty;
    [CompilerGeneratedAttribute]
private int <First>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Last>k__BackingField;
    public int First { get; }
    public int Last { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public IntRange(int first, int last);
    private static IntRange();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_First();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Last();
    public int get_Length();
    public bool get_IsEmpty();
    public bool Contains(int value);
    public bool Contains(IntRange other);
    public bool Intersects(IntRange other);
    public bool Equals(IntRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal static class JetBrains.Decompiler.Utils.LocalFunctionUtil : object {
    public static void ReplaceWithLocalFunctionCall(IMethodCallExpression methodCall, MethodDecompilerContext context, ClosureContext closureContext);
    public static void ReplaceWithLocalFunctionDelegateCreation(IObjectCreationExpression objectCreation, IMethodPointerExpression methodPointer, MethodDecompilerContext context, ClosureContext closureContext);
    public static void ReplaceWithLocalFunctionDelegateCreation(IDelegateCreationExpression delegateCreation, MethodDecompilerContext context, ClosureContext closureContext);
    private static void ReplaceWithLocalFunctionDelegateCreation(ICreationExpression objectCreation, MethodInstantiation methodInstantiation, MethodDecompilerContext context, ClosureContext closureContext);
    private static IExpression[] DetachArgumentsForLocalFunction(IMethodCallExpression methodCall);
    [CanBeNullAttribute]
private static IMetadataTypeInfo GetParentContextParameterType(IMetadataMethod localFunction);
    public static int IndexOfContextParameter(IMetadataMethod localFunction, IMetadataTypeInfo contextParameterType);
    private static bool ContainsContextParameter(IMetadataMethod localFunction, IMetadataTypeInfo contextParameterType);
    [NotNullAttribute]
public static IList`1<ILocalVariable> GetLocalFunctionClosureFrameVariables(IMethodCallExpression localFunctionCall);
    [CanBeNullAttribute]
public static ClosureContext FindClosureContext(IMetadataMethod localFunction, MethodDecompilerContext context);
    private static IDecompiledMethodBase GetOwnerMethod(IMetadataMethod localFunction, MethodDecompilerContext context, ClosureContext closureContext);
    private static ILocalFunction DecompileLocalFunctionIfNeeded(IMetadataMethod localFunction, IDecompiledMethodBase ownerMethod, MethodDecompilerContext context, ClosureContext closureContext);
    public static void CollectLocalFunctionsUsages(INode node, OneToSetMap`2<string, MetadataToken> usages);
    public static OneToListMap`2<MetadataToken, IExpression> GetLocalFunctionsReferences(INode node);
    public static ICollection`1<ILocalVariable> CollectOwnerMethodLocalVariables(ILocalFunction localFunction);
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.Utils.MatcherEx : object {
    [ExtensionAttribute]
public static bool Capture(T source, T& destination);
    [ExtensionAttribute]
public static bool TryCapture(TSource source, TDestination& destination);
}
public static class JetBrains.Decompiler.Utils.MemberInheritanceUtil : object {
    private static bool GetMethodFlag(IMetadataTypeMember typeMember, Func`2<IMetadataMethod, bool> methodFlagFunc);
    private static bool IsPrivate(IMetadataTypeMember typeMember);
    private static bool IsVirtual(IMetadataTypeMember typeMember);
    private static bool IsFinal(IMetadataTypeMember typeMember);
    private static bool IsAbstract(IMetadataTypeMember typeMember);
    private static bool IsNewSlot(IMetadataTypeMember typeMember);
    private static bool IsNewFinalVirtual(IMetadataTypeMember typeMember);
    public static InheritanceModifiers GetInheritanceModifiers(IMetadataTypeMember typeMember);
    [CanBeNullAttribute]
public static IMetadataTypeMember GetBaseMemberByNameAndSig(IMetadataTypeMember typeMember);
    public static bool HasMember(IMetadataClassType type, IMetadataTypeMember referenceMember);
    public static bool BaseInterfaceMemberIsHidden(IMetadataTypeMember typeMember);
    private static bool BaseInterfaceMemberIsHidden(IMetadataTypeMember typeMember, IMetadataClassType interface, Func`2<IMetadataType, IMetadataType> substitutor);
    [CanBeNullAttribute]
private static IMetadataTypeMember TryGetHiddenMember(IMetadataTypeMember typeMember, IMetadataClassType baseType, Func`2<IMetadataType, IMetadataType> substitutor);
}
internal static class JetBrains.Decompiler.Utils.NamingUtil : object {
    public static string GetClosureVariableName(IMetadataField field);
    public static string GetIteratorVariableName(IMetadataField field);
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.Utils.NodeMatchingEx : object {
    [ExtensionAttribute]
[ContractAnnotationAttribute("expression: null => false")]
public static bool MatchLocalVariableReference(IExpression expression, ILocalVariable variable);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, variable: notnull; => false, variable: null; expression: null => false")]
public static bool MatchLocalVariableReference(IExpression expression, ILocalVariable& variable);
    [ExtensionAttribute]
[ContractAnnotationAttribute("expression: null => false")]
public static bool MatchParameterReference(IExpression expression, IMethodParameter parameter);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, parameter: notnull; => false, parameter: null; expression: null => false")]
public static bool MatchParameterReference(IExpression expression, IMethodParameter& parameter);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, typedNode: notnull; => false, typedNode: null; node: null => false")]
public static bool Match(INode node, T& typedNode);
    [ExtensionAttribute]
[ContractAnnotationAttribute("node: null => false")]
public static bool MatchNullRightSibling(INode node);
    [ExtensionAttribute]
[ContractAnnotationAttribute("expression: null => false")]
public static bool MatchNullLiteral(IExpression expression);
    [ExtensionAttribute]
[ContractAnnotationAttribute("expression: null => false")]
public static bool MatchLiteralAgainstValue(IExpression expression, object value);
    [ExtensionAttribute]
[ContractAnnotationAttribute("expression: null => false")]
public static bool MatchLiteralAgainstConstant(IExpression expression, Constant value);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, value: notnull; => false, value: null; expression: null => false")]
public static bool MatchLiteral(IExpression expression, T& value);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, argument: notnull; => false, argument: null; expression: null => false")]
public static bool MatchTypeCast(IExpression expression, bool isMandatory, IMetadataType expectedType, T& argument);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, assignment: notnull; => false, assignment: null; expression: null => false")]
public static bool MatchAssignment(INode expression, IBinaryOperationExpression& assignment);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, assignment: notnull; => false, assignment: null; statement: null => false")]
public static bool MatchAssignmentStatement(INode statement, IBinaryOperationExpression& assignment);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, assignmentExpressionStatement: notnull, assignment: notnull; => false, assignmentExpressionStatement: null, assignment: null; statement: null => false")]
public static bool MatchAssignmentStatement(INode statement, IExpressionStatement& assignmentExpressionStatement, IBinaryOperationExpression& assignment);
    [ExtensionAttribute]
public static bool MatchClearingAssignmentStatement(INode statement, ILocalVariable variable, IMetadataClassType variableType, IBinaryOperationExpression& variableClearingAssignment);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, comparison: notnull; => false, comparison: null; expression: null => false")]
public static bool MatchEqualityComparison(IExpression expression, Boolean& negate, T& comparison);
    [ExtensionAttribute]
public static bool MatchEqualityComparison(IAbstractBinaryOperationExpression comparison, Boolean& negate);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, binaryOperation: notnull; => false, binaryOperation: null; expression: null => false")]
public static bool MatchBinaryOperation(INode expression, OperationType operationType, IBinaryOperationExpression& binaryOperation);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, nulling: notnull; => false, nulling: null; statement: null => false")]
public static bool MatchVariableNulling(INode statement, ILocalVariable variable, IMetadataType type, IExpressionStatement& nulling);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, nulling: notnull; => false, nulling: null; statement: null => false")]
public static bool MatchVariableNulling(INode statement, IMetadataType type, IExpressionStatement& nulling, ILocalVariable& variable);
    [ExtensionAttribute]
[ContractAnnotationAttribute("expression: null => false")]
public static bool MatchFieldAccess(IExpression expression, IMetadataField field);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, field: notnull; => false, field: null; expression: null => false")]
public static bool MatchFieldAccess(IExpression expression, IMetadataField& field);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("expression: null => null")]
public static IExpression GetUnaryOperationArgument(INode expression, OperationType operationType);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("statement: null => null")]
public static IExpression GetExpressionStatementArgument(INode statement);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("=> notnull, expressionStatement: notnull; => null, expressionStatement: null")]
public static IExpression GetExpressionStatementArgument(INode statement, IExpressionStatement& expressionStatement);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("typeCast: null => null")]
public static IExpression GetTypeCastArgument(IExpression typeCast, IMetadataType expectedType);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("typeCast: null => null, typeCast: null; => notnull, typeCast: notnull")]
public static IExpression GetTypeCastArgument(IExpression typeCastExpression, IMetadataType expectedType, ITypeCastExpression& typeCast);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("deref: null => null")]
public static IExpression GetDerefArgument(IExpression deref);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("ref: null => null")]
public static IExpression GetRefArgument(IExpression ref);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("box: null => null")]
public static IExpression GetBoxArgument(IExpression box);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("box: null => null")]
public static IExpression GetBoxArgument(IExpression box, IMetadataType type);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("expression: null => null")]
public static IExpression SkipBox(IExpression expression, IMetadataType type);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("expression: null => null")]
public static IExpression SkipBox(IExpression expression);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("expression: notnull => notnull; expression: null => null")]
public static IExpression SkipNegation(IExpression expression, Boolean& negation);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("expression: null => null")]
public static IExpression SkipNegation(IExpression expression, bool negation);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("expression: null => null")]
public static IExpression SkipTypeCast(IExpression expression, IMetadataType expectedType);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("expression: null => null, typeCast: null")]
public static IExpression SkipTypeCast(IExpression expression, IMetadataType expectedType, ITypeCastExpression& typeCast);
}
internal class JetBrains.Decompiler.Utils.NodeTreeAnalyzer : object {
    private ExtensionManager`2<INode, Entry> myExtensionManager;
    private int myCurrentIndex;
    public NodeTreeAnalyzer(INode root);
    public bool IsAncestorOf(INode ancestor, INode descendant);
    public int GetPreorderIndex(INode node);
    [CanBeNullAttribute]
public IStatement GetDeclarationPoint(IEnumerable`1<IExpression> references);
    private IStatement CombineDeclarationPoints(IStatement existingPoint, IStatement newPoint);
    private void Visit(INode node);
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.Utils.OpcodeValueEx : object {
    [ExtensionAttribute]
public static OperationType ToOperationType(OpcodeValue opcodeValue);
    [ExtensionAttribute]
public static OverflowCheckType ToOverflowCheck(OpcodeValue opcodeValue);
}
[ExtensionAttribute]
internal static class JetBrains.Decompiler.Utils.OperationTypeEx : object {
    [ExtensionAttribute]
public static bool IsAnyOf(OperationType lhs, OperationType rhs1);
    [ExtensionAttribute]
public static bool IsAnyOf(OperationType lhs, OperationType rhs1, OperationType rhs2);
    [ExtensionAttribute]
public static bool IsAnyOf(OperationType lhs, OperationType rhs1, OperationType rhs2, OperationType rhs3);
    [ExtensionAttribute]
public static bool IsAnyOf(OperationType lhs, OperationType rhs1, OperationType rhs2, OperationType rhs3, OperationType rhs4);
    [ExtensionAttribute]
public static bool IsAnyOf(OperationType lhs, OperationType[] rhs);
}
public class JetBrains.Decompiler.Utils.Rational : ValueType {
    public static Rational Invalid;
    public long Denominator;
    public long Numerator;
    public bool IsValid { get; }
    public Rational(long numerator, long denominator);
    private static Rational();
    public bool get_IsValid();
    public bool Equals(Rational other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public double AsDouble();
    public virtual string ToString();
}
public static class JetBrains.Decompiler.Utils.RationalUtil : object {
    public static Rational GetRationalApproximation(double r, int maximumDenominator, double epsilon);
    private static Rational CheckEquality(double expectedResult, Rational candidate, double epsilon);
}
internal static class JetBrains.Decompiler.Utils.SimpleTypeUtil : object {
    public static object ReadValue(BinaryReader reader, ElementType elementType);
    private static object TryGetDefaultValueInternal(IMetadataType type);
    public static Constant TryGetDefaultValue(IMetadataType type);
    private static bool IsConvertibleElementType(ElementType elementType);
    private static object TryConvertInternal(object value, ElementType targetElementType);
    public static Constant TryConvert(Constant constant, IMetadataType targetType);
    public static object Convert(object value, ElementType targetElementType);
    public static long ToLong(object value);
    public static ulong ToULong(object value);
    public static int GetSize(IMetadataType type, ElementType& elementType);
    public static IExpressionList CreateLiteralInitializer(Byte[] data, IMetadataType type, ElementType elementType, int length, IInstructionReference instructionReference);
    public static IExpressionList CreateLiteralInitializer(Byte[] data, IMetadataType type, ElementType elementType, Int32[] dimensions, IInstructionReference instructionReference);
    private static IExpression CreateLiteralInitializer(BinaryReader reader, IMetadataType type, ElementType elementType, Int32[] dimensions, int currentRank, IInstructionReference instructionReference);
}
internal static class JetBrains.Decompiler.Utils.SwapUtil : object {
    public static void Swap(T& a, T& b);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
