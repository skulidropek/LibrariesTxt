public class JetBrains.Application.AssemblyReferenceClass_ComponentModel : object {
}
[ExtensionAttribute]
public static class JetBrains.Application.Bindings.AssemblyBinderExtensions : object {
    private static OnError OnErrorForAssemblyBinderErrors;
    private static OnError OnErrorForAssemblyBinderExpectedFailures;
    private static AssemblyBinderExtensions();
    [ExtensionAttribute]
public static IMetadataAssembly BindToMetadataAssembly(IAssemblyMasterBinder thіs, AssemblyNameInfo assembly, MetadataLoader loader, OnError onerror);
    [ExtensionAttribute]
[NotNullAttribute]
public static AssemblyItem CreateAssemblyItem(IAssemblyBinder thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static MetadataLoader CreateMetadataLoader(IAssemblyMasterBinder thіs, Lifetime lifetime, OnError onerrorBinderErrors, OnError onerrorExpectedBinderFailures);
    [ExtensionAttribute]
public static IAssemblyBinder GetBinder(IAssemblyMasterBinder thіs, AssemblyNameInfo assembly);
    [ExtensionAttribute]
public static void InstallAppDomainAssemblyResolver(IAssemblyMasterBinder masterbinder, Lifetime lifetime);
    [ExtensionAttribute]
public static void InstallAppDomainAssemblyResolverByList(AssemblyMasterBinderOnAssemblyItems masterbinder, Lifetime lifetime);
    [CompilerGeneratedAttribute]
internal static int <CreateMetadataLoader>g__CompareByFirstWord|4_3(string x, string y);
}
public class JetBrains.Application.Bindings.AssemblyMasterBinderOnAssemblyItems : object {
    [NotNullAttribute]
private static ILogger Logger;
    private static string UnresolvedAssemblyMessage;
    private FrugalLocalLazy`1<ConcurrentDictionary`2<AssemblyNameInfo, Assembly>> myCacheRuntimeAssemblies;
    private Lifetime myLifetime;
    private Dictionary`2<AssemblyNameInfo, IAssemblyItem> myMapAssemblyItems;
    [CanBeNullAttribute]
private JetHashSet`1<AssemblyNameInfo> myPossiblyMissingAssemblies;
    private static LocalLazy`1<IFolderBasedAssemblyResolver> myRuntimeAssemblyResolver;
    private IRealizedAssemblyItemUnification myUnification;
    public JetHashSet`1<AssemblyNameInfo> AssembilesWhitelistedToBeMissing { get; }
    [NotNullAttribute]
public IDictionary`2<AssemblyNameInfo, IAssemblyItem> AssemblyItems { get; }
    [NotNullAttribute]
public IRealizedAssemblyItemUnification RealizedAssemblyItemUnification { get; }
    public AssemblyMasterBinderOnAssemblyItems(Lifetime lifetime, ICollection`1<IAssemblyItem> assemblyitems, IRealizedAssemblyItemUnification unification, IEnumerable`1<AssemblyNameInfo> possiblymissings);
    private static AssemblyMasterBinderOnAssemblyItems();
    public sealed virtual JetHashSet`1<AssemblyNameInfo> get_AssembilesWhitelistedToBeMissing();
    public IDictionary`2<AssemblyNameInfo, IAssemblyItem> get_AssemblyItems();
    public IRealizedAssemblyItemUnification get_RealizedAssemblyItemUnification();
    private sealed virtual override FileSystemPath JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToDiskPath(AssemblyNameInfo assembly, OnError onerror);
    private sealed virtual override IMetadataAccess JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToMetadataAccess(AssemblyNameInfo assembly, IModuleReferenceResolveContext ctx, OnError onerror);
    private sealed virtual override Assembly JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToRuntimeAssembly(AssemblyNameInfo assembly, OnError onerror);
    private sealed virtual override Stream JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToStream(Lifetime lifetime, AssemblyNameInfo assembly, OnError onerror);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Application.Bindings.AssemblyMasterBinderOnDiskFiles : object {
    private static ILogger Logger;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static IComparer`1<ValueTuple`2<string, FileSystemPath>> mySimpleNameComparer;
    private static string UnresolvedAssemblyMessage;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<AssemblyNameInfo, Assembly> myBoundToRuntimeAssemblies;
    private Nullable`1<RuntimeAssemblySources> myGacsources;
    private ConcurrentDictionary`2<FileSystemPath, FoundName> myMapPathToName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<string, ImmutableArray`1<FoundPath>> myMapSimpleNameToPaths;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<string, FileSystemPath>> myPathsNotReadForNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JetHashSet`1<AssemblyNameInfo> myPossiblyMissingAssemblies;
    [NullableAttribute("2")]
private AssemblyVersionRedirection myRedirections;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static LocalLazy`2<IFolderBasedAssemblyResolver, Nullable`1<RuntimeAssemblySources>> myRuntimeAssemblyResolver;
    public JetHashSet`1<AssemblyNameInfo> AssembilesWhitelistedToBeMissing { get; }
    public AssemblyMasterBinderOnDiskFiles(Lifetime lifetime, IEnumerable`1<AssemblyNameAndLocation> items, Nullable`1<RuntimeAssemblySources> gacsources, IEnumerable`1<AssemblyNameInfo> possiblymissings, AssemblyVersionRedirection redirections);
    private static AssemblyMasterBinderOnDiskFiles();
    public sealed virtual JetHashSet`1<AssemblyNameInfo> get_AssembilesWhitelistedToBeMissing();
    public AssemblyNameInfo GetNameByPath(FileSystemPath path, OnError onerror);
    public FileSystemPath GetPathByName(AssemblyNameInfo name, OnError onerror);
    private sealed virtual override FileSystemPath JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToDiskPath(AssemblyNameInfo assembly, OnError onerror);
    private sealed virtual override IMetadataAccess JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToMetadataAccess(AssemblyNameInfo assembly, IModuleReferenceResolveContext ctx, OnError onerror);
    private sealed virtual override Assembly JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToRuntimeAssembly(AssemblyNameInfo name, OnError onerror);
    private sealed virtual override Stream JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToStream(Lifetime lifetime, AssemblyNameInfo assembly, OnError onerror);
    private FoundName GetNameByPathCore(FileSystemPath path, OnError onerror);
    private void GetPathByName_ReportError(AssemblyNameInfo name, OnError onerror, IModuleReferenceResolveContext ctx);
    private FoundPath GetPathByNameCore(AssemblyNameInfo name, OnError onerror, IModuleReferenceResolveContext ctx);
    private Nullable`1<FoundPath> GetPathByNameCore_FromGac(AssemblyNameInfo name, ConcurrentDictionary`2<string, ImmutableArray`1<FoundPath>> map);
    private Nullable`1<FoundPath> GetPathByNameCore_ProcessAllEntriesFromPathsNotRead(AssemblyNameInfo name, ConcurrentDictionary`2<string, ImmutableArray`1<FoundPath>> map);
    private Nullable`1<FoundPath> GetPathByNameCore_ProcessEntryFromPathsNotRead(FileSystemPath path, AssemblyNameInfo name, ConcurrentDictionary`2<string, ImmutableArray`1<FoundPath>> map);
    private ConcurrentDictionary`2<string, ImmutableArray`1<FoundPath>> FirstTimeFillNameToPathMapFromReverse();
}
public class JetBrains.Application.Bindings.AssemblyMasterBinderOnRuntimeAssemblies : object {
    private static IComparer`1<AssemblyNameAndLocation> ComparerByAssemblyName;
    [NotNullAttribute]
private static ILogger Logger;
    private IAssemblyMasterBinder myDiskFileBinder;
    public IDictionary`2<AssemblyNameInfo, Assembly> OriginalAssemblies;
    private JetHashSet`1<AssemblyNameInfo> JetBrains.Application.Bindings.IAssemblyMasterBinder.AssembilesWhitelistedToBeMissing { get; }
    public AssemblyMasterBinderOnRuntimeAssemblies(Lifetime lifetime, IEnumerable`1<Assembly> assemblies, Nullable`1<RuntimeAssemblySources> gacsources, bool isAddingReferencesTransitively);
    private static AssemblyMasterBinderOnRuntimeAssemblies();
    private sealed virtual override JetHashSet`1<AssemblyNameInfo> JetBrains.Application.Bindings.IAssemblyMasterBinder.get_AssembilesWhitelistedToBeMissing();
    private sealed virtual override FileSystemPath JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToDiskPath(AssemblyNameInfo assembly, OnError onerror);
    private sealed virtual override IMetadataAccess JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToMetadataAccess(AssemblyNameInfo assembly, IModuleReferenceResolveContext ctx, OnError onerror);
    private sealed virtual override Assembly JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToRuntimeAssembly(AssemblyNameInfo assembly, OnError onerror);
    private sealed virtual override Stream JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToStream(Lifetime lifetime, AssemblyNameInfo assembly, OnError onerror);
}
public interface JetBrains.Application.Bindings.AssemblyUnification.IRealizedAssemblyItemUnification {
    [NotNullAttribute]
public abstract virtual FileSystemPath RealizeAssemblyItem(Lifetime lifetime, IAssemblyItem item);
    public abstract virtual FileSystemPath RealizeAssemblyItemNew(Lifetime lifetime, IAssemblyItem item, RelativePath pathManualSubfolder);
    public abstract virtual FileSystemPath RealizeAssemblyItemNew(Lifetime lifetime, AssemblyNameInfo assemblyname, Func`1<FileSystemPath[]> λWrite);
}
public interface JetBrains.Application.Bindings.AssemblyUnification.IRealizedAssemblyItemUnificationMaster {
    public abstract virtual void MasterExportForReuseInSlave(IStructuredStorage sstg);
    public abstract virtual void MasterImportForReleaseFromSlave(IStructuredStorage sstg);
}
public interface JetBrains.Application.Bindings.AssemblyUnification.IRealizedAssemblyItemUnificationSlave {
}
public class JetBrains.Application.Bindings.AssemblyUnification.RealizedAssemblyItemData : object {
    [CompilerGeneratedAttribute]
private AssemblyNameInfo <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentHashBase64>k__BackingField;
    [DesignerSerializationVisibilityAttribute("0")]
public IList`1<object> Locks;
    [CompilerGeneratedAttribute]
private FileSystemPath[] <Paths>k__BackingField;
    [NotNullAttribute]
public AssemblyNameInfo AssemblyName { get; }
    public string ContentHashBase64 { get; public set; }
    public FileSystemPath DllPath { get; }
    [NotNullAttribute]
public FileSystemPath[] Paths { get; }
    public RealizedAssemblyItemData(AssemblyNameInfo assname, FileSystemPath[] paths);
    [CompilerGeneratedAttribute]
public AssemblyNameInfo get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_ContentHashBase64();
    [CompilerGeneratedAttribute]
public void set_ContentHashBase64(string value);
    public FileSystemPath get_DllPath();
    [CompilerGeneratedAttribute]
public FileSystemPath[] get_Paths();
    public virtual string ToString();
}
public abstract class JetBrains.Application.Bindings.AssemblyUnification.RealizedAssemblyItemUnification : object {
    private static ILogger Logger;
    private static string StreamName_MasterToSlave;
    private static string StreamName_SlaveToMaster;
    private RelativePath ManualFolderName;
    private Lifetime myLifetimeCommon;
    private LockObject myLockObject;
    private IDictionary`2<AssemblyNameInfo, RealizedAssemblyItemData> myMapAssemblies;
    private Role myRole;
    private string myTokenImportedFromMaster;
    private IWorkingDirectory myWorkdir;
    private string StreamName_WorkDir;
    protected RealizedAssemblyItemUnification(Lifetime lifetimeCommon, IWorkingDirectory workdir, Role role);
    private static RealizedAssemblyItemUnification();
    public void InstallAssemblyResolver(Lifetime lifetime);
    [NotNullAttribute]
public sealed virtual FileSystemPath RealizeAssemblyItem(Lifetime lifetime, IAssemblyItem item);
    public sealed virtual FileSystemPath RealizeAssemblyItemNew(Lifetime lifetime, IAssemblyItem item, RelativePath pathManualSubfolder);
    public sealed virtual FileSystemPath RealizeAssemblyItemNew(Lifetime lifetime, AssemblyNameInfo assemblyname, Func`1<FileSystemPath[]> λWrite);
    private void MasterEnsureReleaseOnShutdown();
    protected void MasterExportForReuseInSlave(IStructuredStorage sstg);
    protected void MasterImportForReleaseFromSlave(IStructuredStorage sstg);
    [IteratorStateMachineAttribute("JetBrains.Application.Bindings.AssemblyUnification.RealizedAssemblyItemUnification/<ReadSerializedLines>d__19")]
[NotNullAttribute]
private static IEnumerable`1<Pair`2<AssemblyNameInfo, FileSystemPath[]>> ReadSerializedLines(IStructuredStorage sstg, string sStreamName);
    [NotNullAttribute]
private RealizedAssemblyItemData RealizeCore(Lifetime lifetime, AssemblyNameInfo assemblyname, Func`1<FileSystemPath[]> λWrite);
    [NotNullAttribute]
private static FileSystemPath RealizeSingleFile(ImmutableFileItem file, FileSystemPath targetdir);
    private void SerializeItemData(RealizedAssemblyItemData data, StringBuilder sb);
    protected void SlaveExportForReleaseByMaster(IStructuredStorage sstg);
    protected void SlaveImportForReuseFromMaster(Lifetime lifetime, IStructuredStorage sstg);
    private static bool UnrealizeAssemblyItem(RealizedAssemblyItemData data, FilesInUse filesinuse);
    [CompilerGeneratedAttribute]
private bool <MasterEnsureReleaseOnShutdown>b__16_0(ReadonlyToken lck);
    [CompilerGeneratedAttribute]
private bool <SlaveExportForReleaseByMaster>b__23_0(ReadonlyToken lck);
    [CompilerGeneratedAttribute]
private bool <SlaveImportForReuseFromMaster>b__24_2(object lck);
}
[ExtensionAttribute]
public static class JetBrains.Application.Bindings.AssemblyUnification.RealizedAssemblyItemUnificationEx : object {
    private static ILogger Logger;
    private static RealizedAssemblyItemUnificationEx();
    [ExtensionAttribute]
public static void RealizeOnAssemblyResolveDemand(IRealizedAssemblyItemUnification unification, Lifetime lifetime, ICollection`1<AssemblyItem> assemblies);
}
public class JetBrains.Application.Bindings.AssemblyUnification.RealizedAssemblyItemUnificationMaster : RealizedAssemblyItemUnification {
    public RealizedAssemblyItemUnificationMaster(Lifetime lifetimeCommon, IWorkingDirectory workdir);
    private sealed virtual override void JetBrains.Application.Bindings.AssemblyUnification.IRealizedAssemblyItemUnificationMaster.MasterExportForReuseInSlave(IStructuredStorage sstg);
    private sealed virtual override void JetBrains.Application.Bindings.AssemblyUnification.IRealizedAssemblyItemUnificationMaster.MasterImportForReleaseFromSlave(IStructuredStorage sstg);
}
public class JetBrains.Application.Bindings.AssemblyUnification.RealizedAssemblyItemUnificationSlave : RealizedAssemblyItemUnification {
    public RealizedAssemblyItemUnificationSlave(Lifetime lifetimeCommon, IStructuredStorage storageImportFromMaster, Func`2<Lifetime, IStructuredStorage> λStorageExportToMaster);
}
public class JetBrains.Application.Bindings.AssemblyVersionRedirection : object {
    private List`1<Redir> myRedirectAlways;
    public IReadOnlyCollection`1<Redir> RedirectAlways { get; }
    public AssemblyVersionRedirection(IReadOnlyCollection`1<Redir> redirectAlways);
    public IReadOnlyCollection`1<Redir> get_RedirectAlways();
    [CanBeNullAttribute]
public AssemblyNameInfo TryRedirectUnconditionally(AssemblyNameInfo original);
}
public interface JetBrains.Application.Bindings.IAssemblyBinder {
    [NotNullAttribute]
public AssemblyNameInfo AssemblyName { get; }
    public abstract virtual AssemblyNameInfo get_AssemblyName();
    public abstract virtual FileSystemPath BindToDiskPath(OnError onerror);
    public abstract virtual IMetadataAssembly BindToMetadataAssembly(Lifetime lifetime, OnError onerror);
    public abstract virtual Assembly BindToRuntimeAssembly(OnError onerror);
    public abstract virtual Stream BindToStream(Lifetime lifetime, OnError onerror);
}
[NullableContextAttribute("1")]
public interface JetBrains.Application.Bindings.IAssemblyMasterBinder {
    public JetHashSet`1<AssemblyNameInfo> AssembilesWhitelistedToBeMissing { get; }
    public abstract virtual JetHashSet`1<AssemblyNameInfo> get_AssembilesWhitelistedToBeMissing();
    public abstract virtual FileSystemPath BindToDiskPath(AssemblyNameInfo assembly, OnError onerror);
    public abstract virtual IMetadataAccess BindToMetadataAccess(AssemblyNameInfo assembly, IModuleReferenceResolveContext ctx, OnError onerror);
    public abstract virtual Assembly BindToRuntimeAssembly(AssemblyNameInfo assembly, OnError onerror);
    public abstract virtual Stream BindToStream(Lifetime lifetime, AssemblyNameInfo assembly, OnError onerror);
}
public class JetBrains.Application.Bindings.MetadataLoaderAssemblyResolverOnMasterBinder : object {
    [NotNullAttribute]
public IAssemblyMasterBinder MasterBinder;
    public MetadataLoaderAssemblyResolverOnMasterBinder(IAssemblyMasterBinder masterbinder);
    private sealed virtual override void JetBrains.Metadata.Reader.API.IAssemblyResolver.DumpDebugInformation(IndentedTextWriter textWriter);
    private sealed virtual override IMetadataAccess JetBrains.Metadata.Reader.API.IAssemblyResolver.ResolveAssembly(AssemblyNameInfo name, IAssemblyLocation& assemblyLocation, IModuleReferenceResolveContext ctx);
}
public static class JetBrains.Application.Bindings.PartCatalogAttributeBinding : object {
    public static object CreateInstance(PartCatalogAttribute attribute, OnError onerror);
    public static object CreateInstance(PartCatalogType typeAttr, Nullable`1<CollectionSource`1<PartCatalogType>> constructorFormalParameterTypes, CollectionSource`1<PartCatalogAttributeArgument> arguments, OnError onerror);
}
public static class JetBrains.Application.Bindings.PartCatalogTypeBinding : object {
    [NotNullAttribute]
public static Type BindToRuntimeType(PartCatalogType pctype);
}
public static class JetBrains.Application.Bindings.PartCatalogTypeMemberBinding : object {
    [NotNullAttribute]
public static MemberInfo BindToRuntimeMember(PartCatalogTypeMember member);
    private static MemberInfo BindToCtor(PartCatalogTypeMember member);
    private static MemberInfo BindToField(PartCatalogTypeMember member);
    private static MemberInfo BindToMethod(PartCatalogTypeMember member);
    private static MemberInfo BindToProperty(PartCatalogTypeMember member);
}
public class JetBrains.Application.Catalogs.CatalogAssemblyToken : ValueType {
}
public class JetBrains.Application.Catalogs.CatalogAttributeArgumentToken : ValueType {
}
public class JetBrains.Application.Catalogs.CatalogAttributeToken : ValueType {
}
public class JetBrains.Application.Catalogs.CatalogMemberToken : ValueType {
}
public class JetBrains.Application.Catalogs.CatalogTypeToken : ValueType {
}
public class JetBrains.Application.Catalogs.Filtering.AllPartSelector : object {
    public sealed virtual IEnumerable`1<PartCatalogType> SelectParts(IEnumerable`1<PartCatalogType> parts);
}
public class JetBrains.Application.Catalogs.Filtering.CatalogAttributeFilter : object {
    private Type myAttributeType;
    private PartCatalogTraitOperations myTraits;
    private PartCatalogTraitOperations JetBrains.Application.Catalogs.Filtering.IPartCatalogFilterRequiresTraits.Traits { get; }
    public CatalogAttributeFilter(Type attributeType);
    public sealed virtual CollectionSource`1<PartCatalogType> GetParts(CollectionSource`1<PartCatalogType> parts);
    [IteratorStateMachineAttribute("JetBrains.Application.Catalogs.Filtering.CatalogAttributeFilter/<GetPartsCore>d__4")]
private IEnumerable`1<PartCatalogType> GetPartsCore(CollectionSource`1<PartCatalogType> parts);
    private sealed virtual override bool JetBrains.Application.Catalogs.Filtering.IPartCatalogFilter.IsPassing(PartCatalogType part);
    private sealed virtual override PartCatalogTraitOperations JetBrains.Application.Catalogs.Filtering.IPartCatalogFilterRequiresTraits.get_Traits();
}
public class JetBrains.Application.Catalogs.Filtering.CatalogAttributeFilter`1 : CatalogAttributeFilter {
    public static CatalogAttributeFilter`1<TAttribute> Instance;
    private static CatalogAttributeFilter`1();
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.Filtering.CatalogAttributePartsEx : object {
    [ExtensionAttribute]
public static CollectionSource`1<PartCatalogType> GetPartsWithAttribute(PartCatalog thіs);
    [ExtensionAttribute]
public static PartCatalogAttribute GetSingleAttribute(PartCatalogType thіs, Type typeAttribute);
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.Filtering.CatalogIntersectFilterEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IPartCatalogFilter Intersect(IEnumerable`1<IPartCatalogFilter> thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static IPartCatalogFilter IntersectIfNotNull(IPartCatalogFilter thіs, IPartCatalogFilter other);
    [ExtensionAttribute]
[NotNullAttribute]
public static PartCatalogFilterGroup IntersectWith(IPartCatalogFilter thіs, IPartCatalogFilter other);
}
public interface JetBrains.Application.Catalogs.Filtering.IPartCatalogFilter {
    public abstract virtual CollectionSource`1<PartCatalogType> GetParts(CollectionSource`1<PartCatalogType> parts);
    public abstract virtual bool IsPassing(PartCatalogType part);
}
public interface JetBrains.Application.Catalogs.Filtering.IPartCatalogFilterRequiresTraits {
    public PartCatalogTraitOperations Traits { get; }
    public abstract virtual PartCatalogTraitOperations get_Traits();
}
public interface JetBrains.Application.Catalogs.Filtering.IPartSelector {
    [NotNullAttribute]
public abstract virtual IEnumerable`1<PartCatalogType> SelectParts(IEnumerable`1<PartCatalogType> parts);
}
public class JetBrains.Application.Catalogs.Filtering.LeafAndHidePartSelector : object {
    private static StringSource SsHidesName;
    private static LeafAndHidePartSelector();
    public sealed virtual IEnumerable`1<PartCatalogType> SelectParts(IEnumerable`1<PartCatalogType> parts);
}
public class JetBrains.Application.Catalogs.Filtering.LeafPartSelector : object {
    public sealed virtual IEnumerable`1<PartCatalogType> SelectParts(IEnumerable`1<PartCatalogType> parts);
}
public class JetBrains.Application.Catalogs.Filtering.PartCatalogFilterGroup : object {
    protected ICollection`1<IPartCatalogFilter> myFilters;
    [CanBeNullAttribute]
private ICollection`1<IPartCatalogFilter> myNonTraitRequiringFilters;
    [CanBeNullAttribute]
private Nullable`1<PartCatalogTraitOperations> myRequiredTraits;
    [NotNullAttribute]
public ICollection`1<IPartCatalogFilter> AllFilters { get; }
    [NotNullAttribute]
public ICollection`1<IPartCatalogFilter> NonTraitRequiringFilters { get; }
    public PartCatalogTraitOperations RequiredTraits { get; }
    private PartCatalogFilterGroup(ICollection`1<IPartCatalogFilter> filters);
    public ICollection`1<IPartCatalogFilter> get_AllFilters();
    public ICollection`1<IPartCatalogFilter> get_NonTraitRequiringFilters();
    public PartCatalogTraitOperations get_RequiredTraits();
    [NotNullAttribute]
public static IPartCatalogFilter CreateIntersection(IEnumerable`1<IPartCatalogFilter> filters);
    [NotNullAttribute]
public static PartCatalogFilterGroup CreateIntersection(IPartCatalogFilter black, IPartCatalogFilter white);
    public sealed virtual CollectionSource`1<PartCatalogType> GetParts(CollectionSource`1<PartCatalogType> parts);
    private sealed virtual override bool JetBrains.Application.Catalogs.Filtering.IPartCatalogFilter.IsPassing(PartCatalogType part);
}
public class JetBrains.Application.Catalogs.Filtering.PartCatalogTrait : ValueType {
    public string LocalName;
    public string Namespace;
    public sealed virtual bool Equals(PartCatalogTrait other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PartCatalogTrait left, PartCatalogTrait right);
    public static bool op_Inequality(PartCatalogTrait left, PartCatalogTrait right);
    public virtual string ToString();
}
public class JetBrains.Application.Catalogs.Filtering.PartCatalogTraitOperations : ValueType {
    public FrugalLocalList`1<Operation> Operations;
    public UInt32 TotalTraitsCount { get; }
    public UInt32 get_TotalTraitsCount();
    public sealed virtual bool Equals(PartCatalogTraitOperations other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static PartCatalogTraitOperations HasAtLeast(PartCatalogTrait trait);
    public bool IsEmpty();
    public virtual string ToString();
}
public static class JetBrains.Application.Catalogs.Filtering.PartSelector : object {
    public static IPartSelector All;
    public static IPartSelector Default;
    public static IPartSelector Leafs;
    public static IPartSelector LeafsAndHides;
    private static PartSelector();
}
public interface JetBrains.Application.Catalogs.IPartCatalogSet {
    public PartCatalog Catalog { get; }
    public abstract virtual PartCatalog get_Catalog();
}
public interface JetBrains.Application.Catalogs.IPartCatalogStorage {
    [NotNullAttribute]
public abstract virtual IPartCatalogStorage ApplyFilter(IPartCatalogFilter filter);
    [NotNullAttribute]
public abstract virtual IAssemblyBinder AssemblyGetBinder(Int32`1<CatalogAssemblyToken> token);
    public abstract virtual StringSource AssemblyGetFullName(Int32`1<CatalogAssemblyToken> token);
    public abstract virtual int AssemblyGetHashCode(Int32`1<CatalogAssemblyToken> token);
    [NotNullAttribute]
public abstract virtual AssemblyNameInfo AssemblyGetNameInfo(Int32`1<CatalogAssemblyToken> token);
    public abstract virtual CollectionSource`1<PartCatalogAttribute> AssemblyGetPartAttributes(Int32`1<CatalogAssemblyToken> token, Type typeFilter);
    public abstract virtual CollectionSource`1<PartCatalogType> AssemblyGetPartTypes(Int32`1<CatalogAssemblyToken> token);
    public abstract virtual CollectionSource`1<PartCatalogAssembly> AssemblyGetReferencedAssemblies(Int32`1<CatalogAssemblyToken> token);
    public abstract virtual StringSource AssemblyGetSimpleName(Int32`1<CatalogAssemblyToken> token);
    public abstract virtual bool AssemblyIsCataloged(Int32`1<CatalogAssemblyToken> token);
    [CanBeNullAttribute]
public abstract virtual object AttributeArgumentGetBoxedValue(Int32`1<CatalogAttributeArgumentToken> token);
    public abstract virtual PartCatalogAttributeArgumentDisposition AttributeArgumentGetDisposition(Int32`1<CatalogAttributeArgumentToken> token);
    public abstract virtual StringSource AttributeArgumentGetName(Int32`1<CatalogAttributeArgumentToken> token);
    public abstract virtual ulong AttributeArgumentGetPrimitiveValue(Int32`1<CatalogAttributeArgumentToken> token, Nullable`1<AttributeArgumentValueElementType> typeExpected);
    public abstract virtual StringSource AttributeArgumentGetStringValue(Int32`1<CatalogAttributeArgumentToken> token);
    public abstract virtual PartCatalogType AttributeArgumentGetTypeValue(Int32`1<CatalogAttributeArgumentToken> token);
    public abstract virtual AttributeArgumentValueElementType AttributeArgumentGetValueElementType(Int32`1<CatalogAttributeArgumentToken> token);
    public abstract virtual CollectionSource`1<PartCatalogAttributeArgument> AttributeGetArguments(Int32`1<CatalogAttributeToken> token);
    public abstract virtual object AttributeGetInstance(Int32`1<CatalogAttributeToken> token, OnError onerror);
    public abstract virtual PartCatalogType AttributeGetType(Int32`1<CatalogAttributeToken> token);
    public abstract virtual Nullable`1<PartCatalogAttributeArgument> AttributeTryGetArgumentByName(Int32`1<CatalogAttributeToken> token, string name);
    public abstract virtual Nullable`1<CollectionSource`1<PartCatalogType>> AttributeTryGetConstructorFormalParameterTypes(Int32`1<CatalogAttributeToken> token);
    public abstract virtual StringSource GetTypeLocalName(Int32`1<CatalogTypeToken> token);
    public abstract virtual CollectionSource`1<PartCatalogType> GlobalGetAllPartTypes();
    public abstract virtual CollectionSource`1<PartCatalogAssembly> GlobalGetCatalogedAssemblies();
    [NotNullAttribute]
public abstract virtual MemberInfo MemberBind(Int32`1<CatalogMemberToken> token);
    public abstract virtual PartCatalogType MemberGetDeclaringType(Int32`1<CatalogMemberToken> token);
    public abstract virtual int MemberGetHashCode(Int32`1<CatalogMemberToken> token);
    public abstract virtual PartCatalogTypeMemberKind MemberGetKind(Int32`1<CatalogMemberToken> token);
    public abstract virtual StringSource MemberGetName(Int32`1<CatalogMemberToken> token);
    public abstract virtual CollectionSource`1<PartCatalogType> MemberGetParameterTypes(Int32`1<CatalogMemberToken> token);
    public abstract virtual CollectionSource`1<PartCatalogAttribute> MemberGetPartAttributes(Int32`1<CatalogMemberToken> token, Type typeFilter);
    public abstract virtual PartCatalogType MemberGetValueType(Int32`1<CatalogMemberToken> token);
    [NotNullAttribute]
public abstract virtual Type TypeBind(Int32`1<CatalogTypeToken> token);
    public abstract virtual bool TypeEqualsRuntimeType(Int32`1<CatalogTypeToken> token, Type typeRuntime);
    public abstract virtual PartCatalogAssembly TypeGetAssembly(Int32`1<CatalogTypeToken> token);
    public abstract virtual StringSource TypeGetAssemblyQualifiedName(Int32`1<CatalogTypeToken> token);
    public abstract virtual CollectionSource`1<PartCatalogType> TypeGetBaseTypes(Int32`1<CatalogTypeToken> token);
    public abstract virtual CollectionSource`1<PartCatalogType> TypeGetExtraTypes(Int32`1<CatalogTypeToken> token);
    public abstract virtual StringSource TypeGetFullName(Int32`1<CatalogTypeToken> token);
    public abstract virtual int TypeGetHashCode(Int32`1<CatalogTypeToken> token);
    public abstract virtual PartCatalogTypeKind TypeGetKind(Int32`1<CatalogTypeToken> token);
    public abstract virtual CollectionSource`1<PartCatalogAttribute> TypeGetPartAttributes(Int32`1<CatalogTypeToken> token, Type typeFilter);
    public abstract virtual CollectionSource`1<PartCatalogTypeMember> TypeGetPartMembers(Int32`1<CatalogTypeToken> token);
    [CanBeNullAttribute]
public abstract virtual Type TypeTryGetBoundType(Int32`1<CatalogTypeToken> token);
}
public class JetBrains.Application.Catalogs.LegacyPartCatalogStorage : object {
    private IPartCatalogFilter myFilter;
    private IPartsCatalogue myLegacy;
    private BidirectionalMap`2<Int32`1<CatalogAttributeArgumentToken>, PartCatalogueAttributeProperty> myMapArguments;
    private BidirectionalMap`2<Int32`1<CatalogAssemblyToken>, PartCatalogueAssembly> myMapAssemblies;
    private BidirectionalMap`2<Int32`1<CatalogAttributeToken>, PartCatalogueAttribute> myMapAttributes;
    private BidirectionalMap`2<Int32`1<CatalogMemberToken>, PartCatalogueTypeMember> myMapMembers;
    private BidirectionalMap`2<Int32`1<CatalogTypeToken>, PartCatalogueType> myMapTypes;
    private int myNextToken;
    public LegacyPartCatalogStorage(IPartsCatalogue legacy, IPartCatalogFilter filter);
    private sealed virtual override IPartCatalogStorage JetBrains.Application.Catalogs.IPartCatalogStorage.ApplyFilter(IPartCatalogFilter filter);
    private sealed virtual override IAssemblyBinder JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetBinder(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetFullName(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override int JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetHashCode(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override AssemblyNameInfo JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetNameInfo(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttribute> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetPartAttributes(Int32`1<CatalogAssemblyToken> token, Type typeFilter);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetPartTypes(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAssembly> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetReferencedAssemblies(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetSimpleName(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override bool JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyIsCataloged(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override object JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetBoxedValue(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override PartCatalogAttributeArgumentDisposition JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetDisposition(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetName(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override ulong JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetPrimitiveValue(Int32`1<CatalogAttributeArgumentToken> token, Nullable`1<AttributeArgumentValueElementType> typeExpected);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetStringValue(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetTypeValue(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override AttributeArgumentValueElementType JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetValueElementType(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttributeArgument> JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetArguments(Int32`1<CatalogAttributeToken> token);
    private sealed virtual override object JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetInstance(Int32`1<CatalogAttributeToken> token, OnError onerror);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetType(Int32`1<CatalogAttributeToken> token);
    private sealed virtual override Nullable`1<PartCatalogAttributeArgument> JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeTryGetArgumentByName(Int32`1<CatalogAttributeToken> token, string name);
    private sealed virtual override Nullable`1<CollectionSource`1<PartCatalogType>> JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeTryGetConstructorFormalParameterTypes(Int32`1<CatalogAttributeToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.GetTypeLocalName(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.GlobalGetAllPartTypes();
    private sealed virtual override CollectionSource`1<PartCatalogAssembly> JetBrains.Application.Catalogs.IPartCatalogStorage.GlobalGetCatalogedAssemblies();
    private sealed virtual override MemberInfo JetBrains.Application.Catalogs.IPartCatalogStorage.MemberBind(Int32`1<CatalogMemberToken> token);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetDeclaringType(Int32`1<CatalogMemberToken> token);
    private sealed virtual override int JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetHashCode(Int32`1<CatalogMemberToken> token);
    private sealed virtual override PartCatalogTypeMemberKind JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetKind(Int32`1<CatalogMemberToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetName(Int32`1<CatalogMemberToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetParameterTypes(Int32`1<CatalogMemberToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttribute> JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetPartAttributes(Int32`1<CatalogMemberToken> token, Type typeFilter);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetValueType(Int32`1<CatalogMemberToken> token);
    private sealed virtual override Type JetBrains.Application.Catalogs.IPartCatalogStorage.TypeBind(Int32`1<CatalogTypeToken> token);
    private sealed virtual override bool JetBrains.Application.Catalogs.IPartCatalogStorage.TypeEqualsRuntimeType(Int32`1<CatalogTypeToken> token, Type typeRuntime);
    private sealed virtual override PartCatalogAssembly JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetAssembly(Int32`1<CatalogTypeToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetAssemblyQualifiedName(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetBaseTypes(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetExtraTypes(Int32`1<CatalogTypeToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetFullName(Int32`1<CatalogTypeToken> token);
    private sealed virtual override int JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetHashCode(Int32`1<CatalogTypeToken> token);
    private sealed virtual override PartCatalogTypeKind JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetKind(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttribute> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetPartAttributes(Int32`1<CatalogTypeToken> token, Type typeFilter);
    private sealed virtual override CollectionSource`1<PartCatalogTypeMember> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetPartMembers(Int32`1<CatalogTypeToken> token);
    private sealed virtual override Type JetBrains.Application.Catalogs.IPartCatalogStorage.TypeTryGetBoundType(Int32`1<CatalogTypeToken> token);
    [CanBeNullAttribute]
private object WrapArgumentValue(object value);
    private PartCatalogAssembly WrapAssembly(PartCatalogueAssembly pcass);
    private IList`1<PartCatalogAttribute> WrapAttributes(IEnumerable`1<PartCatalogueAttribute> pattrs);
    private PartCatalogType WrapType(PartCatalogueType pctype);
    [CompilerGeneratedAttribute]
private PartCatalogAttributeArgument <JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetArguments>b__26_0(PartCatalogueAttributeProperty property);
    [CompilerGeneratedAttribute]
private Int32`1<CatalogAttributeArgumentToken> <JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetArguments>b__26_1(PartCatalogueAttributeProperty p);
    [CompilerGeneratedAttribute]
private PartCatalogTypeMember <JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetPartMembers>b__52_0(PartCatalogueTypeMember pctm);
    [CompilerGeneratedAttribute]
private Int32`1<CatalogMemberToken> <JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetPartMembers>b__52_1(PartCatalogueTypeMember member);
    [CompilerGeneratedAttribute]
private object <WrapArgumentValue>b__54_0(object o);
    [CompilerGeneratedAttribute]
private Int32`1<CatalogAssemblyToken> <WrapAssembly>b__55_0(PartCatalogueAssembly type);
    [CompilerGeneratedAttribute]
private PartCatalogAttribute <WrapAttributes>b__56_0(PartCatalogueAttribute pattr);
    [CompilerGeneratedAttribute]
private Int32`1<CatalogAttributeToken> <WrapAttributes>b__56_1(PartCatalogueAttribute attribute);
    [CompilerGeneratedAttribute]
private Int32`1<CatalogTypeToken> <WrapType>b__57_0(PartCatalogueType type);
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.LegacyWrappedPartCatalogs : object {
    [NotNullAttribute]
public static PartCatalog Create(IList`1<PartCatalogAssembly> assemblies);
    [NotNullAttribute]
public static PartCatalog CreateFromRuntimeAssemblies(IEnumerable`1<Assembly> assemblies, IPartCatalogueFactory typeFactory, RuntimePartsPassFilter filter);
    [NotNullAttribute]
public static PartCatalog CreateFromRuntimeAssembly(Assembly assembly, IPartCatalogueFactory typeFactory, RuntimePartsPassFilter filter);
    public static PartCatalog CreateFromRuntimeTypes(IEnumerable`1<Type> types);
    public static PartCatalog CreateFromRuntimeTypes(Type[] types);
    [NotNullAttribute]
public static PartCatalog CreateWithMetadataReader(IEnumerable`1<AssemblyNameInfo> assemblies, IAssemblyMasterBinder masterbinder, IPartCatalogueFactory typeFactory, IMetadataPartsPassFilter filter);
    [NotNullAttribute]
public static PartCatalog CreateWithMetadataReaderFromAssemblyFiles(IList`1<FileSystemPath> assemblyLocations, IPartCatalogueFactory typeFactory, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, IMetadataPartsPassFilter filter);
    [NotNullAttribute]
public static PartCatalog CreateWithMetadataReaderFromAssemblyFiles(IList`1<FileSystemPath> assemblyLocations, IList`1<FileSystemPath> filesAdditionalAssemblyReferences, IPartCatalogueFactory typeFactory, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, IMetadataPartsPassFilter filter);
    [ExtensionAttribute]
public static PartCatalog WrapLegacy(IPartsCatalogue legacy);
}
public class JetBrains.Application.Catalogs.PartCatalog : ValueType {
    private IPartCatalogStorage myStorage;
    public CollectionSource`1<PartCatalogType> AllPartTypes { get; }
    public CollectionSource`1<PartCatalogAssembly> CatalogedAssemblies { get; }
    public PartCatalog(IPartCatalogStorage storage);
    public CollectionSource`1<PartCatalogType> get_AllPartTypes();
    [PureAttribute]
public CollectionSource`1<PartCatalogAssembly> get_CatalogedAssemblies();
    [PureAttribute]
public PartCatalog ApplyFilter(IPartCatalogFilter filter);
}
public class JetBrains.Application.Catalogs.PartCatalogAssembly : ValueType {
    private IPartCatalogStorage myStorage;
    internal Int32`1<CatalogAssemblyToken> Token;
    [NotNullAttribute]
public IAssemblyBinder Binder { get; }
    public StringSource FullName { get; }
    public bool IsCataloged { get; }
    public CollectionSource`1<PartCatalogType> PartTypes { get; }
    public CollectionSource`1<PartCatalogAssembly> ReferencedAssemblies { get; }
    public StringSource SimpleName { get; }
    internal PartCatalogAssembly(Int32`1<CatalogAssemblyToken> token, IPartCatalogStorage storage);
    [PureAttribute]
public IAssemblyBinder get_Binder();
    [PureAttribute]
public StringSource get_FullName();
    [PureAttribute]
public bool get_IsCataloged();
    [PureAttribute]
public CollectionSource`1<PartCatalogType> get_PartTypes();
    [PureAttribute]
public CollectionSource`1<PartCatalogAssembly> get_ReferencedAssemblies();
    [PureAttribute]
public StringSource get_SimpleName();
    [NotNullAttribute]
[PureAttribute]
public AssemblyNameInfo CreateAssemblyName();
    [PureAttribute]
public sealed virtual bool Equals(PartCatalogAssembly other);
    [PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public CollectionSource`1<PartCatalogAttribute> GetPartAttributes();
    [PureAttribute]
public CollectionSource`1<PartCatalogAttribute> GetPartAttributes(Type typeAttrBase);
    [PureAttribute]
public static bool op_Equality(PartCatalogAssembly left, PartCatalogAssembly right);
    [PureAttribute]
public static bool op_Inequality(PartCatalogAssembly left, PartCatalogAssembly right);
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
private sealed virtual override int System.IComparable<JetBrains.Application.Catalogs.PartCatalogAssembly>.CompareTo(PartCatalogAssembly other);
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.PartCatalogAssemblyEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static Assembly Bind(PartCatalogAssembly thіs);
    [ExtensionAttribute]
[PureAttribute]
public static CollectionSource`1<PartCatalogAttribute> GetPartAttributes(PartCatalogAssembly thіs);
}
public class JetBrains.Application.Catalogs.PartCatalogAttribute : ValueType {
    internal IPartCatalogStorage myStorage;
    internal Int32`1<CatalogAttributeToken> Token;
    public PartCatalogAttributeArguments Arguments { get; }
    public PartCatalogAttributeArgumentsNullable ArgumentsOptional { get; }
    public bool IsConstructorKnown { get; }
    public PartCatalogType Type { get; }
    public PartCatalogAttribute(Int32`1<CatalogAttributeToken> token, IPartCatalogStorage storage);
    [PureAttribute]
public PartCatalogAttributeArguments get_Arguments();
    [PureAttribute]
public PartCatalogAttributeArgumentsNullable get_ArgumentsOptional();
    [PureAttribute]
public bool get_IsConstructorKnown();
    [PureAttribute]
public PartCatalogType get_Type();
    [PureAttribute]
public CollectionSource`1<PartCatalogAttributeArgument> GetArguments();
    [PureAttribute]
public CollectionSource`1<PartCatalogType> GetConstructorFormalParameterTypes();
    [PureAttribute]
public object GetInstance(OnError onerror);
    public virtual string ToString();
    [PureAttribute]
public Nullable`1<PartCatalogAttributeArgument> TryFindArgument(string name);
}
public class JetBrains.Application.Catalogs.PartCatalogAttributeArgument : ValueType {
    private IPartCatalogStorage myStorage;
    internal Int32`1<CatalogAttributeArgumentToken> Token;
    public PartCatalogAttributeArgumentDisposition Disposition { get; }
    public StringSource Name { get; }
    public PartCatalogAttributeArgument(Int32`1<CatalogAttributeArgumentToken> token, IPartCatalogStorage storage);
    [PureAttribute]
public PartCatalogAttributeArgumentDisposition get_Disposition();
    public StringSource get_Name();
    [PureAttribute]
[NotNullAttribute]
public Object[] GetArrayValue();
    [PureAttribute]
public bool GetBooleanValue();
    [PureAttribute]
[CanBeNullAttribute]
public object GetBoxedValue();
    [PureAttribute]
public byte GetByteValue();
    [PureAttribute]
public char GetCharValue();
    [PureAttribute]
public double GetDoubleValue();
    [PureAttribute]
public short GetInt16Value();
    [PureAttribute]
public int GetInt32Value();
    [PureAttribute]
public long GetInt64Value();
    [PureAttribute]
public bool GetIsNullValue();
    [PureAttribute]
public ulong GetRawPrimitiveValue();
    [PureAttribute]
public sbyte GetSByteValue();
    [PureAttribute]
public float GetSingleValue();
    [PureAttribute]
public StringSource GetStringValue();
    [PureAttribute]
public PartCatalogType GetTypeValue();
    [PureAttribute]
public ushort GetUInt16Value();
    [PureAttribute]
public UInt32 GetUInt32Value();
    [PureAttribute]
public ulong GetUInt64Value();
    [PureAttribute]
public AttributeArgumentValueElementType GetValueElementType();
    [PureAttribute]
public virtual string ToString();
}
public class JetBrains.Application.Catalogs.PartCatalogAttributeArgumentDisposition : ValueType {
    private static int FieldValue;
    public static PartCatalogAttributeArgumentDisposition Field;
    private static int PropertyValue;
    public static PartCatalogAttributeArgumentDisposition Property;
    private int myValue;
    public int CtorParameterIndex { get; }
    public bool IsCtorParameter { get; }
    public bool IsField { get; }
    public bool IsProperty { get; }
    private PartCatalogAttributeArgumentDisposition(int value);
    private static PartCatalogAttributeArgumentDisposition();
    public int get_CtorParameterIndex();
    public bool get_IsCtorParameter();
    public bool get_IsField();
    public bool get_IsProperty();
    public static PartCatalogAttributeArgumentDisposition CtorParameter(int index);
    public static int op_Explicit(PartCatalogAttributeArgumentDisposition disposition);
    public static PartCatalogAttributeArgumentDisposition op_Explicit(int value);
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.PartCatalogAttributeArgumentEx : object {
    private static Type TypeOfNullableOfPartCatalogType;
    private static Type TypeOfNullableOfStringSource;
    private static Type TypeOfObjectArray;
    private static Type TypeOfPartCatalogType;
    private static Type TypeOfStringSource;
    private static PartCatalogAttributeArgumentEx();
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static Object[] GetArrayValueOrNull(PartCatalogAttributeArgument thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<StringSource> GetStringValueOrNull(PartCatalogAttributeArgument thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<PartCatalogType> GetTypeValueOrNull(PartCatalogAttributeArgument thіs);
    [ExtensionAttribute]
[PureAttribute]
public static TValue GetValue(PartCatalogAttributeArgument argument);
}
public static class JetBrains.Application.Catalogs.PartCatalogAttributeArgumentHelpers : object {
    public static AttributeArgumentValueElementType GetElementTypeFromBoxedValue(object oValue);
    public static bool IsPrimitiveTypeCoercible(AttributeArgumentValueElementType typeActual, Nullable`1<AttributeArgumentValueElementType> typeCoerceTo, OnError onerror);
    public static Nullable`1<AttributeArgumentValueElementType> TryGetElementTypeFromTypeCode(TypeCode tc, bool isPrimitiveTypesOnly);
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.PartCatalogAttributeArgumentNullableEx : object {
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static Object[] GetArrayValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<bool> GetBooleanValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static object GetBoxedValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<byte> GetByteValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<char> GetCharValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<double> GetDoubleValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<short> GetInt16ValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<int> GetInt32ValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<long> GetInt64ValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<bool> GetIsNullValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<ulong> GetRawPrimitiveValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<sbyte> GetSByteValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<float> GetSingleValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<StringSource> GetStringValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<PartCatalogType> GetTypeValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<ushort> GetUInt16ValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<UInt32> GetUInt32ValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<ulong> GetUInt64ValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<AttributeArgumentValueElementType> GetValueElementTypeIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Application.Catalogs.PartCatalogAttributeArguments : ValueType {
    internal PartCatalogAttribute myParent;
    public CollectionSource`1<PartCatalogAttributeArgument> All { get; }
    public PartCatalogAttributeArgument Item { get; }
    public PartCatalogAttribute Parent { get; }
    [PureAttribute]
public CollectionSource`1<PartCatalogAttributeArgument> get_All();
    [PureAttribute]
public PartCatalogAttributeArgument get_Item(string name);
    [PureAttribute]
public PartCatalogAttribute get_Parent();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Application.Catalogs.PartCatalogAttributeArgumentsNullable : ValueType {
    internal PartCatalogAttribute myParent;
    public CollectionSource`1<PartCatalogAttributeArgument> All { get; }
    public Nullable`1<PartCatalogAttributeArgument> Item { get; }
    public PartCatalogAttribute Parent { get; }
    [PureAttribute]
public CollectionSource`1<PartCatalogAttributeArgument> get_All();
    [PureAttribute]
public Nullable`1<PartCatalogAttributeArgument> get_Item(string name);
    [PureAttribute]
public PartCatalogAttribute get_Parent();
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.PartCatalogAttributeEx : object {
    [ExtensionAttribute]
public static Exception AddData(Exception ex, PartCatalogAttribute attr, string prefix);
    [ExtensionAttribute]
[PureAttribute]
public static PartCatalogAttributeArgument Find(PartCatalogAttributeArguments thіs, Expression`1<Func`2<TAttribute, TArgument>> expression);
    [ExtensionAttribute]
[PureAttribute]
public static PartCatalogAttributeArgument Find(PartCatalogAttributeArguments thіs, AttributeArgumentValueElementType type);
    [ExtensionAttribute]
[PureAttribute]
public static PartCatalogAttributeArgument FindArgument(PartCatalogAttribute thіs, string name);
    [ExtensionAttribute]
[PureAttribute]
public static PartCatalogAttributeArgument FindArgument(PartCatalogAttribute thіs, Expression`1<Func`2<TAttribute, TArgument>> expression);
    [ExtensionAttribute]
[ObsoleteAttribute("This method either boxes some primitive values, or uses nontrivial hacks to avoid that boxing. So the recommended way is to get the argument with Arguments[] or ArgumentsOptional[], and then take its value of a specific type (enum types must be cast manually due to boxing issues). Also this would have better handling and understanding for missing values.")]
public static TValue GetArgumentValueOrDefault(PartCatalogAttribute thіs, string argumentname, TValue default);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ObsoleteAttribute("This method either boxes some primitive values, or uses nontrivial hacks to avoid that boxing. So the recommended way is to get the argument with Arguments[] or ArgumentsOptional[], and then take its value of a specific type (enum types must be cast manually due to boxing issues). Also this would have better handling and understanding for missing values.")]
public static TValue TryGetArgumentValue(PartCatalogAttribute thіs, string argumentname);
    [ExtensionAttribute]
[ObsoleteAttribute("This method either boxes some primitive values, or uses nontrivial hacks to avoid that boxing. So the recommended way is to get the argument with Arguments[] or ArgumentsOptional[], and then take its value of a specific type (enum types must be cast manually due to boxing issues). Also this would have better handling and understanding for missing values.")]
public static bool TryGetArgumentValue(PartCatalogAttribute thіs, string argumentname, TValue& value);
}
[ExtensionAttribute]
[ObsoleteAttribute("These methods box all values, get the argument then get its value of the specific type.")]
public static class JetBrains.Application.Catalogs.PartCatalogAttributeEx_Obsolete : object {
    [ExtensionAttribute]
[ObsoleteAttribute("This method boxes all values, get the argument then get its value of the specific type.")]
public static TConvertedValue GetProperty(PartCatalogAttribute thіs, Expression`1<Func`2<TSource, TValue>> expression);
    [ExtensionAttribute]
[ObsoleteAttribute("This method boxes all values, get the argument then get its value of the specific type.")]
public static TValue GetProperty(PartCatalogAttribute thіs, Expression`1<Func`2<TSource, TValue>> expression);
    [ExtensionAttribute]
[ObsoleteAttribute("This method boxes all values, get the argument then get its value of the specific type.")]
public static T GetProperty(PartCatalogAttribute thіs, string propname);
    [ExtensionAttribute]
[ObsoleteAttribute("This method boxes all values, get the argument then get its value of the specific type.")]
public static T TryGetProperty(PartCatalogAttribute thіs, string propname, T defaultValue);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ObsoleteAttribute("This method boxes all values, get the argument then get its value of the specific type.")]
public static TValue TryGetProperty(PartCatalogAttribute thіs, string propname);
    [ExtensionAttribute]
[ObsoleteAttribute("This method boxes all values, get the argument then get its value of the specific type.")]
public static TValue TryGetProperty(PartCatalogAttribute thіs, Expression`1<Func`2<TSource, TValue>> expression, TValue defaultValue);
    [ExtensionAttribute]
[ObsoleteAttribute("This method boxes all values, get the argument then get its value of the specific type.")]
public static TValue TryGetProperty(PartCatalogAttribute thіs, Expression`1<Func`2<TSource, TValue>> expression);
    [ExtensionAttribute]
[ObsoleteAttribute("This method boxes all values, get the argument then get its value of the specific type.")]
public static TConvertedValue TryGetProperty(PartCatalogAttribute thіs, Expression`1<Func`2<TSource, TValue>> expression, TConvertedValue defaultValue);
    [ExtensionAttribute]
[ObsoleteAttribute("This method boxes all values, get the argument then get its value of the specific type.")]
public static bool TryGetProperty(PartCatalogAttribute thіs, string propname, T& value);
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.PartCatalogEx : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void DiagnosticsDumpCatalogToExcel(PartCatalog thіs);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void DiagnosticsDumpCatalogToExcel(CatalogTables thіs);
    [ExtensionAttribute]
[ObsoleteAttribute("Use PartCatalog::AllPartTypes.")]
public static CollectionSource`1<PartCatalogType> GetTypesFromAllAssemblies(PartCatalog thіs);
}
public class JetBrains.Application.Catalogs.PartCatalogSet : object {
    [CompilerGeneratedAttribute]
private PartCatalog <Catalog>k__BackingField;
    public PartCatalog Catalog { get; }
    public PartCatalogSet(PartCatalog& initial);
    [CompilerGeneratedAttribute]
public sealed virtual PartCatalog get_Catalog();
}
public static class JetBrains.Application.Catalogs.PartCatalogStorageHelpers : object {
    public static int TypeGetHashCode(PartCatalogTypeKind typekind, StringSource fullname, StringSource assemblyname);
}
public class JetBrains.Application.Catalogs.PartCatalogType : ValueType {
    internal IPartCatalogStorage myStorage;
    internal Int32`1<CatalogTypeToken> Token;
    public PartCatalogAssembly Assembly { get; }
    public StringSource AssemblyQualifiedName { get; }
    public CollectionSource`1<PartCatalogType> BaseTypes { get; }
    public CollectionSource`1<PartCatalogType> ExtraTypes { get; }
    public StringSource FullName { get; }
    public bool IsArray { get; }
    public bool IsGenericTypeDeclaraion { get; }
    public bool IsGenericTypeSpecialization { get; }
    public bool IsReference { get; }
    public PartCatalogTypeKind Kind { get; }
    public StringSource LocalName { get; }
    public CollectionSource`1<PartCatalogTypeMember> PartMembers { get; }
    internal PartCatalogType(Int32`1<CatalogTypeToken> token, IPartCatalogStorage storage);
    [PureAttribute]
public PartCatalogAssembly get_Assembly();
    [PureAttribute]
public StringSource get_AssemblyQualifiedName();
    [PureAttribute]
public CollectionSource`1<PartCatalogType> get_BaseTypes();
    [PureAttribute]
public CollectionSource`1<PartCatalogType> get_ExtraTypes();
    [PureAttribute]
public StringSource get_FullName();
    [PureAttribute]
public bool get_IsArray();
    [PureAttribute]
public bool get_IsGenericTypeDeclaraion();
    [PureAttribute]
public bool get_IsGenericTypeSpecialization();
    [PureAttribute]
public bool get_IsReference();
    [PureAttribute]
public PartCatalogTypeKind get_Kind();
    [PureAttribute]
public StringSource get_LocalName();
    [PureAttribute]
public CollectionSource`1<PartCatalogTypeMember> get_PartMembers();
    [NotNullAttribute]
[PureAttribute]
public Type Bind();
    [PureAttribute]
public sealed virtual bool Equals(PartCatalogType other);
    [PureAttribute]
public bool Equals();
    [PureAttribute]
public bool Equals(Type typeRuntime);
    [PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public PartCatalogType GenericTypeParameterOwner();
    [PureAttribute]
public PartCatalogType GetArrayItemType();
    [PureAttribute]
public CollectionSource`1<PartCatalogType> GetGenericActualParameters();
    [PureAttribute]
public StringSource GetGenericTypeDeclarationFullName();
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public CollectionSource`1<PartCatalogAttribute> GetPartAttributes();
    [PureAttribute]
public CollectionSource`1<PartCatalogAttribute> GetPartAttributes(Type typeAttrBase);
    [PureAttribute]
public PartCatalogType GetReferenceTargetType();
    [PureAttribute]
public static bool op_Equality(PartCatalogType left, PartCatalogType right);
    [PureAttribute]
public static bool op_Inequality(PartCatalogType left, PartCatalogType right);
    public virtual string ToString();
    [CanBeNullAttribute]
[PureAttribute]
public Type TryGetBoundType();
    private sealed virtual override int System.IComparable<JetBrains.Application.Catalogs.PartCatalogType>.CompareTo(PartCatalogType other);
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.PartCatalogTypeEx : object {
    [ExtensionAttribute]
public static CollectionSource`1<PartCatalogAttribute> GetPartAttributes(PartCatalogType thіs);
    [ExtensionAttribute]
public static bool IsEnum(PartCatalogType type);
    [ExtensionAttribute]
public static bool IsJetBrainsType(PartCatalogType type);
}
public class JetBrains.Application.Catalogs.PartCatalogTypeIdentityComparer : object {
    public static IEqualityComparer`1<PartCatalogType> Instance;
    private static PartCatalogTypeIdentityComparer();
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<JetBrains.Application.Catalogs.PartCatalogType>.Equals(PartCatalogType black, PartCatalogType white);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<JetBrains.Application.Catalogs.PartCatalogType>.GetHashCode(PartCatalogType item);
}
public enum JetBrains.Application.Catalogs.PartCatalogTypeKind : Enum {
    public byte value__;
    public static PartCatalogTypeKind Regular;
    public static PartCatalogTypeKind GenericDeclaration;
    public static PartCatalogTypeKind GenericSpecialization;
    public static PartCatalogTypeKind Array;
    public static PartCatalogTypeKind Reference;
    public static PartCatalogTypeKind GenericTypeParameterReference;
    public static PartCatalogTypeKind GenericMethodParameterReference;
}
public class JetBrains.Application.Catalogs.PartCatalogTypeMember : ValueType {
    private IPartCatalogStorage myStorage;
    internal Int32`1<CatalogMemberToken> Token;
    public PartCatalogType DeclaringType { get; }
    public StringSource FullName { get; }
    public PartCatalogTypeMemberKind Kind { get; }
    public StringSource Name { get; }
    public CollectionSource`1<PartCatalogType> ParameterTypes { get; }
    public PartCatalogType ValueType { get; }
    public PartCatalogTypeMember(Int32`1<CatalogMemberToken> token, IPartCatalogStorage storage);
    [PureAttribute]
public PartCatalogType get_DeclaringType();
    [PureAttribute]
public StringSource get_FullName();
    [PureAttribute]
public PartCatalogTypeMemberKind get_Kind();
    [PureAttribute]
public StringSource get_Name();
    [PureAttribute]
public CollectionSource`1<PartCatalogType> get_ParameterTypes();
    [PureAttribute]
public PartCatalogType get_ValueType();
    [PureAttribute]
[NotNullAttribute]
public MemberInfo Bind();
    public sealed virtual bool Equals(PartCatalogTypeMember other);
    public virtual bool Equals(object obj);
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public CollectionSource`1<PartCatalogAttribute> GetPartAttributes();
    [PureAttribute]
public CollectionSource`1<PartCatalogAttribute> GetPartAttributes(Type typeAttrBase);
    [PureAttribute]
public static bool op_Equality(PartCatalogTypeMember left, PartCatalogTypeMember right);
    [PureAttribute]
public static bool op_Inequality(PartCatalogTypeMember left, PartCatalogTypeMember right);
    public virtual string ToString();
    private sealed virtual override int System.IComparable<JetBrains.Application.Catalogs.PartCatalogTypeMember>.CompareTo(PartCatalogTypeMember other);
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.PartCatalogTypeMemberEx : object {
    [ExtensionAttribute]
public static CollectionSource`1<PartCatalogAttribute> GetPartAttributes(PartCatalogTypeMember thіs);
}
public enum JetBrains.Application.Catalogs.PartCatalogTypeMemberKind : Enum {
    public byte value__;
    public static PartCatalogTypeMemberKind Method;
    public static PartCatalogTypeMemberKind Property;
    public static PartCatalogTypeMemberKind Field;
    public static PartCatalogTypeMemberKind Constructor;
}
public class JetBrains.Application.Components.AsyncAccessOnlySyncGetValueException : InvalidOperationException {
    public AsyncAccessOnlySyncGetValueException(IValueDescriptorWithToStringDebug descriptor);
}
public static class JetBrains.Application.Components.AsyncContext : object {
    [ThreadStaticAttribute]
private static int ourPreferAsync;
    public static bool PreferAsync { get; }
    public static bool get_PreferAsync();
    public static LocalDisposable UsingPreferAsync();
}
public abstract class JetBrains.Application.Components.AsyncDescriptorBase : object {
    protected static ILogger Logger;
    private ComponentState modreq(System.Runtime.CompilerServices.IsVolatile) myState;
    private IComponentContainer myComponentContainer;
    private IReadOnlyList`1 modreq(System.Runtime.CompilerServices.IsVolatile) myCachedDependencies;
    [ThreadStaticAttribute]
private static bool ourIsReentrantGetValueProhibited;
    [ThreadStaticAttribute]
private static int ourActivationCount;
    [ThreadStaticAttribute]
private static AsyncDescriptorBase ourDescriptorWithAllowanceIgnoreTaskPriority;
    private IContainerThreading myThreading;
    [CanBeNullAttribute]
private Action[] myValueCreatedSinks;
    private bool IsCreationAllowed { get; }
    protected bool ShouldFilterFailedDependencies { get; }
    protected bool ShouldReportFailedDependencies { get; }
    private static TimeSpan SyncWaitForAsyncCreationTimeout { get; }
    public ComponentProperties Properties { get; }
    public bool IsAlive { get; }
    public bool IsInitialized { get; }
    public bool IsDeadlockSafe { get; }
    public bool IsAsyncAccessOnly { get; }
    private ValueDescriptorIdentifier JetBrains.Application.Components.IValueDescriptor.UsageStatisticsId { get; }
    protected ValueDescriptorIdentifier UsageStatisticsId { get; }
    private bool HasDependencies { get; }
    internal static bool IsInsideComponentConstructor { get; }
    private bool IsSyncMode { get; }
    private bool IsPrimaryThread { get; }
    private bool ShouldCancelBackgroundRead { get; }
    public bool IsValueCreationStarted { get; }
    public bool IsValueReady { get; }
    protected AsyncDescriptorBase(IContainerThreading threading);
    private static AsyncDescriptorBase();
    private bool get_IsCreationAllowed();
    protected virtual bool get_ShouldFilterFailedDependencies();
    protected virtual bool get_ShouldReportFailedDependencies();
    private bool TryGetOrSetActivatingState(Object[] dependencyValues, ActivatingComponentState& result);
    private object TryActivate(Object[] dependencyValues);
    private object Activate(Object[] dependencyValues);
    private ValueTask`1<object> ActivateAsync(Object[] dependencyValues, TaskPriority priority);
    private void FinalizeCreation(object instance);
    protected virtual void InterruptActivation();
    protected virtual void DisposeInternalResources();
    protected virtual void RegisterInstance(object instance);
    protected abstract virtual object CreateInstance(Object[] dependencies);
    private static TimeSpan get_SyncWaitForAsyncCreationTimeout();
    public abstract virtual ComponentProperties get_Properties();
    public sealed virtual bool get_IsAlive();
    public sealed virtual bool get_IsInitialized();
    public sealed virtual bool get_IsDeadlockSafe();
    public sealed virtual bool get_IsAsyncAccessOnly();
    public sealed virtual object TryGetValueWithoutCreation();
    public sealed virtual object TryGetOrCreateValue();
    public sealed virtual object GetValue();
    public sealed virtual ValueTask`1<object> GetValueAsync(TaskPriority priority);
    private bool IsInlineCreationAllowed(TaskPriority priority);
    private ValueTask`1<object> GetValueInParallelAsync(TaskPriority priority);
    protected internal void AddExceptionData(Exception ex);
    [IteratorStateMachineAttribute("JetBrains.Application.Components.AsyncDescriptorBase/<GetExceptionData>d__37")]
protected virtual IEnumerable`1<KeyValuePair`2<string, Func`1<object>>> GetExceptionData();
    private sealed virtual override ValueDescriptorIdentifier JetBrains.Application.Components.IValueDescriptor.get_UsageStatisticsId();
    protected abstract virtual ValueDescriptorIdentifier get_UsageStatisticsId();
    protected abstract virtual string Present();
    protected virtual string PresentDebug();
    public sealed virtual string ToStringDebug();
    public virtual string ToString();
    public sealed virtual void Dispose();
    private void DoDisposeSafe(object instance);
    protected void AssertBadState();
    public sealed virtual void BindToContainer(IComponentContainer container);
    private void SetCorruptedState(Exception e);
    private bool TryGetInitializedState(InitializedComponentState& result);
    private bool get_HasDependencies();
    private Object[] TryGetDependencyValues();
    private Object[] GetDependencyValues();
    private ValueTask`1<Object[]> GetDependencyValuesInParallelAsync(TaskPriority priority);
    private bool TryGetOrSetInitializingDependenciesState(InitializingDependenciesComponentState& result);
    public sealed virtual IReadOnlyList`1<IValueDescriptor> GetDependencies();
    [NotNullAttribute]
public virtual IReadOnlyList`1<IValueDescriptor> DoGetDependencies();
    internal static bool get_IsInsideComponentConstructor();
    private bool get_IsSyncMode();
    private bool get_IsPrimaryThread();
    private bool get_ShouldCancelBackgroundRead();
    private SchedulerAwaiter YieldToConstructionScheduler(TaskPriority priority);
    [CanBeNullAttribute]
private TaskScheduler GetConstructionTaskScheduler();
    internal static LocalRefDisposable AllowToIgnoreTaskPriority(IValueDescriptor descriptor);
    private bool CheckReentrantGetValue();
    private void AssertReentrantGetValue();
    private void AssertAsyncOnlyAccess();
    protected virtual void AssertPrimaryThreadComponentsAccess();
    public sealed virtual bool get_IsValueCreationStarted();
    public sealed virtual bool get_IsValueReady();
    public sealed virtual bool TryAdviseValueCreated(Lifetime lifetime, Action fWhenCreated);
    private bool TryAddSink(Lifetime lifetime, Action item);
    private void RemoveSink(Action item);
    private void NotifySinks();
    [CompilerGeneratedAttribute]
private Nullable`1<ValueTask`1<object>> <GetValue>g__GetValueWithHighPriorityIfSupportedAsync|32_0();
    [CompilerGeneratedAttribute]
private object <GetExceptionData>b__37_0();
    [CompilerGeneratedAttribute]
private object <GetExceptionData>b__37_1();
    [CompilerGeneratedAttribute]
private object <GetExceptionData>b__37_2();
    [CompilerGeneratedAttribute]
private object <GetExceptionData>b__37_3();
    [CompilerGeneratedAttribute]
private object <GetExceptionData>b__37_4();
    [CompilerGeneratedAttribute]
private object <GetExceptionData>b__37_5();
    [CompilerGeneratedAttribute]
private object <GetExceptionData>b__37_6();
    [CompilerGeneratedAttribute]
private object <GetExceptionData>b__37_7();
    [CompilerGeneratedAttribute]
private object <GetExceptionData>b__37_8();
}
public abstract class JetBrains.Application.Components.AsyncInitializationStrategyBase : InitializationStrategyBase {
    [CompilerGeneratedAttribute]
private static bool <NeedToAnalyseLazyInjects>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <NeedToAnalyseDependencies>k__BackingField;
    private static ILogger ourPerforatorLogger;
    private static ILogger ourLogger;
    private IAsyncComposeManager myAsyncComposeManager;
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private IContainerThreading <ContainerThreading>k__BackingField;
    private static bool NeedToAnalyseLazyInjects { get; }
    private static bool NeedToAnalyseDependencies { get; }
    protected Lifetime Lifetime { get; }
    [NotNullAttribute]
public IContainerThreading ContainerThreading { get; }
    protected AsyncInitializationStrategyBase(Lifetime lifetime, ITaskHost taskHost, IAsyncComposeManager asyncComposeManager);
    protected AsyncInitializationStrategyBase(Lifetime lifetime, IContainerThreading threading, IAsyncComposeManager asyncComposeManager);
    private static AsyncInitializationStrategyBase();
    [CompilerGeneratedAttribute]
private static bool get_NeedToAnalyseLazyInjects();
    [CompilerGeneratedAttribute]
private static bool get_NeedToAnalyseDependencies();
    [CompilerGeneratedAttribute]
protected Lifetime get_Lifetime();
    [CompilerGeneratedAttribute]
public sealed virtual IContainerThreading get_ContainerThreading();
    public sealed virtual void Schedule(Lifetime lifetime, ICollection`1<IComponentDescriptor> dscs, string containedId, IComponentContainer container, ContainerComposingProgress progress);
    public abstract virtual void Wait(Action whenDone, Lifetime lifetime, string waitReason);
    protected abstract virtual void DoSchedule(Lifetime lifetime, ICollection`1<IComponentDescriptor> dscs, string containedId, IComponentContainer container, LifetimeDefinition laterAsyncLifetimeDef);
    [AsyncStateMachineAttribute("JetBrains.Application.Components.AsyncInitializationStrategyBase/<InitDescriptorAsync>d__20")]
private static Task InitDescriptorAsync(Lifetime lt, IComponentContainer container, ContainerStrategyStage stage, IValueDescriptor descriptor, TaskPriority priority);
    [AsyncStateMachineAttribute("JetBrains.Application.Components.AsyncInitializationStrategyBase/<InitLaterAsyncComponentsAsync>d__21")]
protected virtual Task InitLaterAsyncComponentsAsync(Lifetime lifetime, string containerId, IComponentContainer container, ICollection`1<IComponentDescriptor> descriptors, LifetimeDefinition laterAsyncLifetimeDef);
    [AsyncStateMachineAttribute("JetBrains.Application.Components.AsyncInitializationStrategyBase/<LaterAsyncInitPrepareAsync>d__22")]
private Task LaterAsyncInitPrepareAsync(Lifetime lifetime, ICollection`1<IComponentDescriptor> descriptors);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertDescriptorsAlreadyInitialized(IEnumerable`1<IValueDescriptor> descriptors, string message);
    private static IReadOnlyList`1<IValueDescriptor> GetSortedDescriptors(IEnumerable`1<IValueDescriptor> descriptors);
    private static IReadOnlyList`1<IValueDescriptor> GetSortedDescriptors2(IEnumerable`1<IValueDescriptor> descriptors, IEnumerable`1<IValueDescriptor> ready);
    protected Task InitContainerSyncComponentsInParallelAsync(Lifetime lifetime, Schedulers schedulers, ICollection`1<IComponentDescriptor> componentDescriptors, string containerId, IComponentContainer container);
    protected Task InitContainerAsyncComponentsInParallelAsync(Lifetime lifetime, Schedulers schedulers, ICollection`1<IComponentDescriptor> componentDescriptors, string containerId, IComponentContainer container);
    protected virtual bool IsComponentForAsyncStage(IComponentDescriptor descriptor);
    protected Task InitLaterAsyncComponentsInParallelAsync(Lifetime lifetime, Schedulers schedulers, ICollection`1<IComponentDescriptor> componentDescriptors, string containerId, IComponentContainer container, LifetimeDefinition laterAsyncLifetimeDef);
    protected Task InitContainerComponentsInParallelAsync(Lifetime lifetime, Schedulers schedulers, ICollection`1<IComponentDescriptor> componentDescriptors, Predicate`1<IComponentDescriptor> filter, ContainerStrategyStage stage, string containerId, IComponentContainer container, TaskPriority taskPriority, string loggerSuffix, bool startOnMainScheduler, Func`1<Task> awaitTask);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void PrepareDependenciesForDump(IReadOnlyList`1[] waves);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private static void AnalysePossibleLazyInjects(string containerId, IReadOnlyList`1<IValueDescriptor> dependencies, ILogger logger, IValueDescriptor valueDescriptor);
    private static ILogger GetLogger(string containerId, string loggerSuffix);
    private static Task StartDetachedAsync(Lifetime lifetime, TaskScheduler scheduler, Func`1<Task> func);
    private static Task StartDetachedAsync(Lifetime lifetime, TaskScheduler scheduler, Action action);
    [AsyncStateMachineAttribute("JetBrains.Application.Components.AsyncInitializationStrategyBase/<CreateDescriptorAsync>d__36")]
private Task CreateDescriptorAsync(Lifetime lifetime, Schedulers schedulers, IComponentContainer container, IValueDescriptor valueDescriptor, ContainerStrategyStage stage, TaskPriority taskPriority, ILogger logger);
    protected void ProcessByInlineScheduler(Func`2<Schedulers, Task> asyncPart, Action syncPart);
    protected Task StartAndWaitOnTerminationForCompletionAsync(Lifetime lifetime, PumpingScheduler pumper, string id, Func`1<Task> asyncPart);
    [AsyncStateMachineAttribute("JetBrains.Application.Components.AsyncInitializationStrategyBase/<<InitContainerComponentsInParallelAsync>g__WhenAllAsync|30_1>d")]
[CompilerGeneratedAttribute]
internal static Task <InitContainerComponentsInParallelAsync>g__WhenAllAsync|30_1(Dictionary`2<IValueDescriptor, Lazy`1<Task>> asyncLazyMap, IReadOnlyList`1[] waves);
    [AsyncStateMachineAttribute("JetBrains.Application.Components.AsyncInitializationStrategyBase/<<InitContainerComponentsInParallelAsync>g__WaitForDependencyWithTrace|30_2>d")]
[CompilerGeneratedAttribute]
internal static Task <InitContainerComponentsInParallelAsync>g__WaitForDependencyWithTrace|30_2(ILogger logger, IValueDescriptor descriptor, IValueDescriptor dependency, Task task);
    [CompilerGeneratedAttribute]
internal static IReadOnlyList`1[] <InitContainerComponentsInParallelAsync>g__Flatten|30_3(ILogger logger, string id, ICollection`1<IComponentDescriptor> descriptors, Predicate`1<IComponentDescriptor> filter);
    [AsyncStateMachineAttribute("JetBrains.Application.Components.AsyncInitializationStrategyBase/<<CreateDescriptorAsync>g__CreateValueDescriptorSafe|36_1>d")]
[CompilerGeneratedAttribute]
internal static Task <CreateDescriptorAsync>g__CreateValueDescriptorSafe|36_1(Lifetime lifetime, IComponentContainer container, ContainerStrategyStage stage, IValueDescriptor descriptor, TaskPriority taskPriority, ILogger logger);
    [CompilerGeneratedAttribute]
internal static Task <CreateDescriptorAsync>g__CreateValueDescriptorSafeSync|36_2(Lifetime lifetime, IComponentContainer container, ContainerStrategyStage stage, IValueDescriptor descriptor, TaskPriority taskPriority, ILogger logger);
}
public class JetBrains.Application.Components.AsyncLazyValueResolver : object {
    [NotNullAttribute]
public static AsyncLazyValueResolver Default;
    private static Type ourTypeofILazy1;
    private static AsyncLazyValueResolver();
    [NotNullAttribute]
public static IValueDescriptor Create(Type typeUnderAsyncLazy, IValueDescriptor descriptorUnderAsyncLazy);
    public sealed virtual IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags, IValueResolveContext context);
    [CanBeNullAttribute]
public static Type TryExtractTypeUnderAsyncLazy(ResolveRequest request);
    [CanBeNullAttribute]
public static Type TryExtractTypeUnderAsyncLazy(Type typePossiblyAsyncLazy);
}
public class JetBrains.Application.Components.AsyncOnlyParallelLifecycleInitializationStrategy : AsyncParallelLifecycleInitializationStrategy {
    public AsyncOnlyParallelLifecycleInitializationStrategy(Lifetime lifetime, ITaskHost taskHost, IAsyncComposeManager asyncComposeManager, TaskPriority mainSchedulerPriority);
    public AsyncOnlyParallelLifecycleInitializationStrategy(Lifetime lifetime, IContainerThreading threading, IAsyncComposeManager asyncComposeManager, TaskPriority mainSchedulerPriority);
    protected virtual Task InitContainerSyncComponents(Lifetime lifetime, ICollection`1<IComponentDescriptor> componentDescriptors, string containerId, IComponentContainer container);
}
public class JetBrains.Application.Components.AsyncParallelLifecycleInitializationStrategy : AsyncInitializationStrategyBase {
    private PriorityMainScheduler myScheduler;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myScheduleCount;
    private ViewableProperty`1<bool> myWhenDoneProperty;
    public AsyncParallelLifecycleInitializationStrategy(Lifetime lifetime, ITaskHost taskHost, IAsyncComposeManager asyncComposeManager, TaskPriority mainSchedulerPriority);
    public AsyncParallelLifecycleInitializationStrategy(Lifetime lifetime, IContainerThreading threading, IAsyncComposeManager asyncComposeManager, TaskPriority mainSchedulerPriority);
    protected virtual void DoSchedule(Lifetime lifetime, ICollection`1<IComponentDescriptor> descriptors, string containerId, IComponentContainer container, LifetimeDefinition laterAsyncLifetimeDef);
    protected virtual Task InitContainerSyncComponents(Lifetime lifetime, ICollection`1<IComponentDescriptor> componentDescriptors, string containerId, IComponentContainer container);
    protected Schedulers GetAsyncInitializationSchedulers();
    public virtual void Wait(Action whenDone, Lifetime lifetime, string waitReason);
}
public class JetBrains.Application.Components.AutocreateWithPartTypeRegistration : object {
    private PartCatalogType myPartType;
    private object JetBrains.Application.Components.IAutocreateWithRegistration.Request { get; }
    private string JetBrains.Application.Components.IValueRegistration.TypeAssemblyQualifiedName { get; }
    public AutocreateWithPartTypeRegistration(PartCatalogType partType);
    private sealed virtual override bool JetBrains.Application.Components.IValueRegistration.Accepts(object request);
    private sealed virtual override object JetBrains.Application.Components.IAutocreateWithRegistration.get_Request();
    private sealed virtual override string JetBrains.Application.Components.IValueRegistration.get_TypeAssemblyQualifiedName();
}
internal enum JetBrains.Application.Components.ComponentAccessCardinality : Enum {
    public int value__;
    public static ComponentAccessCardinality Unaccessed;
    public static ComponentAccessCardinality Single;
    public static ComponentAccessCardinality Multiple;
}
public class JetBrains.Application.Components.ComponentContainer : object {
    private Lifetime myLifetime;
    private string myId;
    private IInitializationStrategy myInitializationStrategy;
    private ReadonlyToken myStateReadonlyToken;
    private ConcurrentDictionary`2<ResolveCacheIdentity, IValueDescriptor> myResolveCache;
    private IValueResolveContext myDynamicContextForEndpoint;
    private IValueResolveContext myUnknownContextForChained;
    protected ComponentStorage ComponentStorage;
    private List`1<IValueResolver> myResolversExternallyRegistered;
    private EnumerableValueResolver myEnumerableResolver;
    private LazyImmutableListValueResolver myLazyImmutableListResolver;
    private NestedComponentContainerValueResolver myNestedComponentContainerResolver;
    private SplittedComponentContainerServiceResolver mySplittedComponentContainerServiceResolver;
    [CompilerGeneratedAttribute]
private IProperty`1<ComponentContainerState> <State>k__BackingField;
    public IContainerThreading Threading { get; }
    public IProperty`1<ComponentContainerState> State { get; }
    public ComponentContainer(Lifetime lifetime, string id, IInitializationStrategy initializationStrategy);
    public virtual IContainerThreading get_Threading();
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<ComponentContainerState> get_State();
    public sealed virtual IValueResolveContext CreateResolveContext(ValueResolveRequester requester);
    [ObsoleteAttribute("Use ComposeAsync")]
public ComponentContainer Compose();
    public virtual IContainerComposingProgress ComposeAsync();
    public ComponentContainer RegisterResolver(IValueResolver resolver);
    public ComponentContainer RegisterDescriptors(IReadOnlyList`1<IComponentDescriptor> descriptors);
    public IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags, IValueResolveContext context);
    private IValueDescriptor ResolveCore(ResolveRequest request, ValueResolveFlags flags, IValueResolveContext context);
    private static IValueDescriptor ResolveFirstOrDefault(ICollection`1<IValueResolver> resolvers, ResolveRequest request, ValueResolveFlags flags, IValueResolveContext context);
    public virtual string ToString();
    private sealed virtual override IMemoryGrave JetBrains.Util.Memory.IMemoryGraveProvider.GetOrCreateMemoryGrave();
    private void ShiftState(ComponentContainerState from, ComponentContainerState to);
    [CompilerGeneratedAttribute]
private void <.ctor>b__14_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__14_1();
    [CompilerGeneratedAttribute]
private void <ComposeAsync>b__22_0();
}
[ExtensionAttribute]
public static class JetBrains.Application.Components.ComponentContainerEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IReadyImmutableList`1<TInterface> GetComponents(IComponentContainer container);
    [ExtensionAttribute]
public static ValueTask`1<TInterface> GetComponentAsync(IComponentContainer container, TaskPriority priority);
    [ExtensionAttribute]
public static ValueTask`1<TInterface> TryGetComponentAsync(IComponentContainer container, TaskPriority priority);
    [ExtensionAttribute]
public static ValueTask`1<IEnumerable`1<TInterface>> GetComponentsAsync(IComponentContainer container, TaskPriority priority);
    [ExtensionAttribute]
[NotNullAttribute]
public static object GetComponent(IComponentContainer container, Type service);
    [ExtensionAttribute]
[NotNullAttribute]
public static TInterface GetComponent(IComponentContainer container);
    [ExtensionAttribute]
[CanBeNullAttribute]
internal static IValueDescriptor TryGetComponentDescriptor(IComponentContainer container, Type service);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TInterface TryGetComponent(IComponentContainer container);
    [ExtensionAttribute]
[CanBeNullAttribute]
internal static TInterface TryGetComponentWithoutCreation(IComponentContainer container);
    [ExtensionAttribute]
public static bool HasComponent(IComponentContainer container);
    [ExtensionAttribute]
[ObsoleteAttribute("Use an overload with instantiation", "True")]
public static ComponentContainer Register(ComponentContainer container, Type type);
    [ExtensionAttribute]
public static ComponentContainer Register(ComponentContainer container, Type type, Instantiation instantiation);
    [ExtensionAttribute]
public static ComponentContainer Register(ComponentContainer container, object instance);
    [ExtensionAttribute]
[ObsoleteAttribute("Use an overload with instantiation", "True")]
public static IComponentContainer Register(ComponentContainer container, Func`2<IValueResolveContext, T> factory);
    [ExtensionAttribute]
public static IComponentContainer Register(ComponentContainer container, Func`2<IValueResolveContext, T> factory, Instantiation instantiation);
    [ExtensionAttribute]
[ObsoleteAttribute("Use an overload with instantiation", "True")]
public static ComponentContainer Register(ComponentContainer container);
    [ExtensionAttribute]
public static ComponentContainer Register(ComponentContainer container, Instantiation instantiation);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private static void AssertTypeInstantiation(Type type, Instantiation instantiation);
}
[ExtensionAttribute]
public static class JetBrains.Application.Components.ComponentContainerServiceEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<TInterface> GetServices(IComponentContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static TInterface GetService(IComponentContainer container);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TInterface TryGetService(IComponentContainer container);
    [ExtensionAttribute]
public static bool HasService(IComponentContainer container);
}
public enum JetBrains.Application.Components.ComponentContainerState : Enum {
    public int value__;
    public static ComponentContainerState Created;
    public static ComponentContainerState Composed;
    public static ComponentContainerState Disposed;
}
public enum JetBrains.Application.Components.ComponentInstantiation : Enum {
    public int value__;
    public static ComponentInstantiation Default;
    public static ComponentInstantiation WithEnvironment;
    public static ComponentInstantiation OnDemand;
}
internal class JetBrains.Application.Components.ComponentRegister : object {
    [CanBeNullAttribute]
private DirectMappedCache`2<object, ComponentRegisterEntry> myCache;
    public ComponentRegister(ICollection`1<IComponentDescriptor> descriptors);
    public bool TryGetValue(TRequest request, ComponentRegisterEntry& entry);
}
internal class JetBrains.Application.Components.ComponentRegisterEntry : object {
    private object myDescriptors;
    private ComponentAccessCardinality myCardinality;
    private object myCardinalityContext;
    public ComponentRegisterEntry(IComponentDescriptor first);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<IComponentDescriptor> GetEnumerator();
    public IComponentDescriptor SingleOrDefault();
    public void VerifyCardinality(ComponentAccessCardinality value, object registration, object context);
    public void Add(IComponentDescriptor descriptor);
    public virtual string ToString();
}
public class JetBrains.Application.Components.ComponentRegistrationEqualityComparer : object {
    public static ComponentRegistrationEqualityComparer Instance;
    private static ComponentRegistrationEqualityComparer();
    public sealed virtual int GetHashCode(object obj);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object x, object y);
    [CompilerGeneratedAttribute]
internal static object <System.Collections.Generic.IEqualityComparer<System.Object>.Equals>g__GetType|3_0(object obj);
    [CompilerGeneratedAttribute]
internal static bool <System.Collections.Generic.IEqualityComparer<System.Object>.Equals>g__TypeEquals|3_1(object a, object b);
}
internal class JetBrains.Application.Components.ComponentResolveContext : object {
    private static bool ourIsExtraDataForCheckCircularDependenciesEnabled;
    [ThreadStaticAttribute]
private static Stack`1<IComponentDescriptor> ourRequesters;
    [NotNullAttribute]
private ComponentContainer myContainer;
    private ValueResolveRequester myRequester;
    internal static IReadOnlyCollection`1<IComponentDescriptor> Requesters { get; }
    public ValueResolveRequester Requester { get; }
    [NotNullAttribute]
public IComponentContainer Container { get; }
    public ComponentResolveContext(ComponentContainer container, ValueResolveRequester requester);
    private static ComponentResolveContext();
    internal static IReadOnlyCollection`1<IComponentDescriptor> get_Requesters();
    internal static RequesterContext UsingRequesterContext(ValueResolveRequester requester);
    public sealed virtual ValueResolveRequester get_Requester();
    public IComponentContainer get_Container();
    public virtual string ToString();
    public sealed virtual IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags);
}
public class JetBrains.Application.Components.ComponentStorage : object {
    private static ILogger ourPerforatorLogger;
    private Lifetime myLifetime;
    private string myId;
    private IComponentContainer myComponentContainer;
    private IInitializationStrategy myInitializationStrategy;
    private ComponentStorageState modreq(System.Runtime.CompilerServices.IsVolatile) myState;
    private HashSet`1<IComponentDescriptor> myDescriptors;
    private ComponentRegister modreq(System.Runtime.CompilerServices.IsVolatile) myComponentRegister;
    private OneToSetMap`2<IComponentDescriptor, Pair`2<object, string>> myTypeDependencies;
    private ILogger myLogger;
    private object myStateLock;
    private string myContainerClassId;
    private bool IsUnannotated { get; }
    private string ContainerClassId { get; }
    public ComponentStorage(Lifetime lifetime, string id, IComponentContainer container, IInitializationStrategy initializationStrategy);
    private static ComponentStorage();
    private bool get_IsUnannotated();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertInitialized();
    private IValueDescriptor ResolveImpl(TRequest request, ValueResolveFlags flags, IValueResolveContext context);
    private void VerifyRequester(IComponentDescriptor descriptor, ValueResolveFlags flags, IValueResolveContext context);
    public void RegisterDependency(TRequest request, IValueResolveContext context);
    private void RegisterDependency(TRequest request, IComponentDescriptor requestingDescriptor);
    private IEnumerable`1<IValueDescriptor> ResolveMultipleImpl(TRequest request, IValueResolveContext context);
    [IteratorStateMachineAttribute("JetBrains.Application.Components.ComponentStorage/<EnumerateDescriptors>d__20`1")]
private IEnumerable`1<IValueDescriptor> EnumerateDescriptors(TRequest request, IValueResolveContext context);
    public void RegisterDescriptors(IReadOnlyList`1<IComponentDescriptor> descriptors);
    public void Compose(ContainerComposingProgress progress);
    private void Terminate();
    private void LoadLazyDependencies();
    private void ComposeDescriptors(ICollection`1<IComponentDescriptor> descriptors, ContainerComposingProgress progress);
    protected static void WarmUpDescriptors(Lifetime lifetime, ICollection`1<IComponentDescriptor> descriptors, string containerId);
    private IEnumerable`1<IComponentDescriptor> EnumerateDescriptorsInDisposeOrder(ICollection`1<IComponentDescriptor> descriptors);
    private void DisposeDescriptor(IComponentDescriptor descriptor);
    private void AddExceptionData(Exception ex);
    private string get_ContainerClassId();
    public sealed virtual IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags, IValueResolveContext context);
    public IEnumerable`1<IValueDescriptor> ResolveMultiple(TRequest request, IValueResolveContext context);
    public void RegisterAdditionalDependency(object target, IComponentDescriptor sourceDescriptor);
    public virtual string ToString();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void CheckCircularDependencies(IComponentDescriptor rootDescriptor, IComponentDescriptor lastDescriptor, object request, string extraData, Stack`1<Tuple`3<IComponentDescriptor, object, string>> currentTypes, HashSet`1<object> visited);
    [CompilerGeneratedAttribute]
private void <RegisterDescriptors>g__AssertInitialState|21_0();
    [CompilerGeneratedAttribute]
private object <AddExceptionData>b__29_0();
    [CompilerGeneratedAttribute]
private object <AddExceptionData>b__29_1();
}
public enum JetBrains.Application.Components.ComponentStorageState : Enum {
    public int value__;
    public static ComponentStorageState Initial;
    public static ComponentStorageState Initialized;
    public static ComponentStorageState Disposing;
    public static ComponentStorageState Disposed;
}
public class JetBrains.Application.Components.ConstructiorBindigns : SingletonDescriptorBindings`1<ConstructorInfo> {
    [CompilerGeneratedAttribute]
private static ConstructiorBindigns <Empty>k__BackingField;
    public static ConstructiorBindigns Empty { get; }
    public ConstructiorBindigns(ConstructorInfo method, IReadOnlyList`1<IValueDescriptor> descriptors, IValueDescriptor ownerDescriptor);
    private static ConstructiorBindigns();
    [CompilerGeneratedAttribute]
public static ConstructiorBindigns get_Empty();
    public object Activate(ISingletonDescriptor descriptor, Object[] dependencies);
}
public static class JetBrains.Application.Components.ContainerAssertions : object {
    private static ILogger ourLogger;
    private static ContainerAssertions();
    public static void AssertIsNotInsideComponentConstructor(string message);
}
public class JetBrains.Application.Components.ContainerComposingProgress : object {
    private TaskCompletionSource`1<Missing> myContainerSyncTaskCompletionSource;
    private TaskCompletionSource`1<Missing> myContainerAsyncTaskCompletionSource;
    private TaskCompletionSource`1<Missing> myLaterAsyncTaskCompletionSource;
    public ContainerComposingProgress(Lifetime lifetime);
    public sealed virtual Task WhenContainerSyncComposed();
    public sealed virtual Task WhenContainerAsyncComposed();
    public sealed virtual Task WhenLaterAsyncComposed();
    public void ContainerSyncComposed();
    public void ContainerAsyncComposed();
    public void LaterAsyncComposed();
}
public enum JetBrains.Application.Components.ContainerStrategyStage : Enum {
    public int value__;
    public static ContainerStrategyStage Sync;
    public static ContainerStrategyStage Async;
    public static ContainerStrategyStage Later;
}
public class JetBrains.Application.Components.ContainerThreading : object {
    [CompilerGeneratedAttribute]
private ITaskHost <TaskHost>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSyncMode>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskScheduler <UnguardedScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskScheduler <GuardedScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskScheduler <BackgroundScheduler>k__BackingField;
    public ITaskHost TaskHost { get; }
    public bool IsSyncMode { get; }
    public bool IsPrimaryThread { get; }
    public TaskScheduler UnguardedScheduler { get; }
    public TaskScheduler GuardedScheduler { get; }
    public TaskScheduler BackgroundScheduler { get; }
    public ReentrancyGuard ReentrancyGuard { get; }
    public IReaderWriterLock RwLock { get; }
    protected ContainerThreading(ITaskHost taskHost, TaskScheduler backgroundScheduler, TaskScheduler unguardedScheduler, TaskScheduler guardedScheduler, bool isSyncMode);
    [CompilerGeneratedAttribute]
public ITaskHost get_TaskHost();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSyncMode();
    public sealed virtual bool get_IsPrimaryThread();
    [CompilerGeneratedAttribute]
public sealed virtual TaskScheduler get_UnguardedScheduler();
    [CompilerGeneratedAttribute]
public sealed virtual TaskScheduler get_GuardedScheduler();
    [CompilerGeneratedAttribute]
public sealed virtual TaskScheduler get_BackgroundScheduler();
    public sealed virtual ReentrancyGuard get_ReentrancyGuard();
    public sealed virtual SchedulerAwaiter YieldToBackground(TaskPriority priority);
    public sealed virtual SchedulerAwaiter YieldToMainThreadScheduler(TaskPriority priority);
    public sealed virtual SyncContextCookie CreateBackgroundSyncContextCookie(TaskPriority priority);
    public virtual IReaderWriterLock get_RwLock();
    [CanBeNullAttribute]
public static ContainerThreading TryCreate(ITaskHost taskHost, Nullable`1<bool> isSyncMode);
    [NotNullAttribute]
public static ContainerThreading Create(ITaskHost taskHost, Nullable`1<bool> isSyncMode);
}
public class JetBrains.Application.Components.DelegatingComponentContainer : object {
    private IComponentContainer myTarget;
    private IValueResolveContext myContext;
    private IValueResolveContext myDynamicContext;
    private Lazy`1<DeadlockSafetyOverridesData> myDeadlockSafetyOverrides;
    [CompilerGeneratedAttribute]
private IProperty`1<ComponentContainerState> <State>k__BackingField;
    public bool IsInitialized { get; }
    public bool IsAlive { get; }
    public bool IsDeadlockSafe { get; }
    public bool IsAsyncAccessOnly { get; }
    public IValueResolveContext Context { get; }
    public IContainerThreading Threading { get; }
    public IProperty`1<ComponentContainerState> State { get; }
    private ValueDescriptorIdentifier JetBrains.Application.Components.IValueDescriptor.UsageStatisticsId { get; }
    public DelegatingComponentContainer(IComponentContainer target, IValueResolveContext context, IValueResolveContext dynamicContext);
    public DelegatingComponentContainer(IValueResolveContext contextNormalAndDynamic);
    public sealed virtual bool get_IsInitialized();
    public sealed virtual bool get_IsAlive();
    public sealed virtual bool get_IsDeadlockSafe();
    public sealed virtual bool get_IsAsyncAccessOnly();
    public IValueResolveContext get_Context();
    public sealed virtual IContainerThreading get_Threading();
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<ComponentContainerState> get_State();
    public sealed virtual IValueResolveContext CreateResolveContext(ValueResolveRequester requester);
    public sealed virtual IReadOnlyList`1<IValueDescriptor> GetDependencies();
    public sealed virtual object GetValue();
    public sealed virtual ValueTask`1<object> GetValueAsync(TaskPriority priority);
    public sealed virtual object TryGetValueWithoutCreation();
    public sealed virtual object TryGetOrCreateValue();
    public virtual string ToString();
    private sealed virtual override ValueDescriptorIdentifier JetBrains.Application.Components.IValueDescriptor.get_UsageStatisticsId();
    public sealed virtual IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags, IValueResolveContext context);
    private static bool IsOverridableDescriptor(IValueDescriptor descriptor);
}
[ExtensionAttribute]
public static class JetBrains.Application.Components.DelegatingContainer : object {
    [ExtensionAttribute]
public static ComponentContainer ChainTo(ComponentContainer container, IComponentContainer parentContainer);
}
public class JetBrains.Application.Components.DelegatingContainerValueResolver : object {
    public static DelegatingContainerValueResolver Instance;
    private static DelegatingContainerValueResolver();
    public sealed virtual IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags, IValueResolveContext context);
}
[ExtensionAttribute]
public static class JetBrains.Application.Components.Diagnostics.ComponentContainersStatistics : object {
    public static LocalStopwatch Stopwatch;
    private static int CtorOwnTimeThreshold;
    private static int TotalTimeThreshold;
    private static bool ourCollectCompositionGraph;
    private static ILogger ourLogger;
    [ThreadStaticAttribute]
private static int ourCreatedOnThreadComponentsCount;
    [CompilerGeneratedAttribute]
private static ISignal`1<string> <ContainerComposeStarted>k__BackingField;
    [CompilerGeneratedAttribute]
private static ISignal`1<IContainerInfo> <ContainerComposed>k__BackingField;
    private static ConcurrentDictionary`2<IComponentContainer, ContainerInfo> ourContainers;
    private static ConcurrentDictionary`2<string, ComponentHistoricalInfo> ourComponentsHistory;
    public static ISignal`1<string> ContainerComposeStarted { get; }
    public static ISignal`1<IContainerInfo> ContainerComposed { get; }
    private static ComponentContainersStatistics();
    [CompilerGeneratedAttribute]
public static ISignal`1<string> get_ContainerComposeStarted();
    [CompilerGeneratedAttribute]
public static ISignal`1<IContainerInfo> get_ContainerComposed();
    public static void RegisterContainer(Lifetime lifetime, string containerId, IComponentContainer container);
    private static void FireContainerComposeStarted(IContainerInfo containerInfo);
    private static void FireContainerComposed(IContainerInfo containerInfo);
    public static void DelayedStrategyCreatesContainer(Lifetime lifetime, IComponentContainer container, int componentsCount);
    [CanBeNullAttribute]
public static IDisposable SyncStrategyCreatesContainer(IComponentContainer container, int componentsCount);
    public static void NoInitStrategyCreatesContainer(IComponentContainer container);
    [CanBeNullAttribute]
[MustDisposeResourceAttribute]
public static IDisposable StrategyCreatesComponent(IComponentContainer container, IComponentDescriptor descriptor, ContainerStrategyStage stage);
    [CanBeNullAttribute]
public static IDisposable DescriptorCreatesInstance(IComponentContainer container, IComponentDescriptor descriptor);
    public static InitializationStepCookie DescriptorSyncInitializeDependencies(ISingletonDescriptor descriptor);
    public static InitializationStepCookie DescriptorInvokesCtor(IComponentContainer container, IComponentDescriptor descriptor);
    [CanBeNullAttribute]
public static IDisposable GettingExternalManagedInterface();
    [CanBeNullAttribute]
public static IDisposable GettingExternalComInterface(Type typeService, Type typeInterface);
    public static void Dump(TextWriter writer);
    [ExtensionAttribute]
private static bool IsPrimaryThread(IComponentContainer container);
    private static IDisposable MeasureCompositionStep(CompositionStep step, ContainerInfo containerInfo, bool isPrimaryThread);
    private static IDisposable MeasureExternalCompositionStep(string name);
    private static string GetComponentName(IComponentDescriptor descriptor);
    private static void SaveComponentsFirstRunInfo(ContainerInfo container);
    private static void DumpContainersDiffWithHistoricData(TextWriter writer);
    private static void DumpContainersSummary(TextWriter writer);
    private static void DumpContainersDetails(TextWriter writer);
    private static void DumpTopComponentsTotalTime(TextWriter writer);
    private static void DumpTopComponentsCtorTotalTime(TextWriter writer);
    public static void DumpTopComponentsCtorOwnTime(TextWriter writer);
    private static void DumpTopComponentsCtorOwnTimeImpl(TextWriter writer, IList`1<ContainerInfo> containers, int ownTimeThreshold);
    public static void DumpTopComponentsCtorOwnTimeForCertainContainers(TextWriter writer, Func`2<IContainerInfo, bool> filter);
    [IteratorStateMachineAttribute("JetBrains.Application.Components.Diagnostics.ComponentContainersStatistics/<DumpCtorStepsToJson>d__62")]
public static IEnumerable`1<EventData> DumpCtorStepsToJson();
    public static IList`1<IContainerInfo> GetAllContainerInfos();
    public static IList`1<IContainerInfo> GetComposedContainerInfos();
    private static void DumpExternalComponents(TextWriter writer);
    private static void CollectExternalComponents(CompositionStep compositionStep, IDictionary`2<string, double> externals);
    private static void DumpInnerSteps(TextWriter writer, CompositionStep step, int level);
    private static void WriteCompositionStep(TextWriter writer, CompositionStep step, int level);
}
public static class JetBrains.Application.Components.Diagnostics.ComponentDependenciesDumper : object {
    private static OneToSetMap`2<string, Pair`2<string, bool>> ourBackRefs;
    private static ComponentDependenciesDumper();
    public static void Add(string source, string target, bool sourceIsDemand);
    public static void Dump(StreamWriter writer, string filter);
    private static void DumpByTarget(StreamWriter writer, string target, int indent);
}
[IsReadOnlyAttribute]
public class JetBrains.Application.Components.Diagnostics.EventData : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Categories>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ThreadName>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    public string Name { get; public set; }
    public string Type { get; public set; }
    public String[] Categories { get; public set; }
    public int ThreadId { get; public set; }
    public string ThreadName { get; public set; }
    public TimeSpan Start { get; public set; }
    public TimeSpan Duration { get; public set; }
    public EventData(string Name, string Type, String[] Categories, int ThreadId, string ThreadName, TimeSpan Start, TimeSpan Duration);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Type(string value);
    [CompilerGeneratedAttribute]
public String[] get_Categories();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Categories(String[] value);
    [CompilerGeneratedAttribute]
public int get_ThreadId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ThreadId(int value);
    [CompilerGeneratedAttribute]
public string get_ThreadName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ThreadName(string value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Start();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Start(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(EventData left, EventData right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(EventData left, EventData right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(EventData other);
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Name, String& Type, String[]& Categories, Int32& ThreadId, String& ThreadName, TimeSpan& Start, TimeSpan& Duration);
}
internal class JetBrains.Application.Components.DynamicContext : ValueType {
    [ThreadStaticAttribute]
private static Stack`1<IValueResolveContext> ThreadContext;
    private IValueResolveContext myContext;
    private DynamicContext(IValueResolveContext context);
    public static IValueResolveContext PeekOrCreate(IComponentContainer container);
    public static DynamicContext Push(IValueResolveContext context);
    public sealed virtual void Dispose();
}
public static class JetBrains.Application.Components.EmptyLazyImmutableListObject`1 : object {
    public static IParallelImmutableList`1<TComponent> Instance;
    private static EmptyLazyImmutableListObject`1();
}
public static class JetBrains.Application.Components.EmptyOrderedLazyImmutableListObject`1 : object {
    public static IOrderedImmutableList`1<TComponent> Instance;
    private static EmptyOrderedLazyImmutableListObject`1();
}
public static class JetBrains.Application.Components.EmptyOrderedLazyImmutableListObject`2 : object {
    public static IOrderedImmutableList`2<TComponent, TAttribute> Instance;
    private static EmptyOrderedLazyImmutableListObject`2();
}
public static class JetBrains.Application.Components.EmptyReadyImmutableListObject`1 : object {
    public static IReadyImmutableList`1<TComponent> Instance;
    private static EmptyReadyImmutableListObject`1();
}
public class JetBrains.Application.Components.EnumerableValueResolver : object {
    private Lifetime myLifetime;
    private AddDependencyDelegate myComponentStorageAddDependency;
    private ResolveMultipleDelegate myComponentStorageResolveMultiple;
    [CanBeNullAttribute]
private ICollection`1<IValueResolver> myLinkedResolvers;
    [CanBeNullAttribute]
private IContainerThreading myThreading;
    private bool myIsResolvingNullWhenNoValues;
    private Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) myEnumerablesCache;
    [NotNullAttribute]
private static Type ourIEnumerableType;
    [NotNullAttribute]
private static Type ourIReadonlyListType;
    [NotNullAttribute]
private static Type ourIJetReadonlyListType;
    [NotNullAttribute]
private static Type ourIReadyImmutableListType;
    public EnumerableValueResolver(Lifetime lifetime, AddDependencyDelegate componentStorageAddDependency, ResolveMultipleDelegate componentStorageResolveMultiple, ICollection`1<IValueResolver> linkedResolvers, IContainerThreading threading, bool isResolvingNullWhenNoValues);
    private static EnumerableValueResolver();
    public sealed virtual IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags, IValueResolveContext context);
    private static bool IsSupported(Type type);
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_0();
}
public static class JetBrains.Application.Components.FactoryComponentContainer : object {
    [NotNullAttribute]
public static TInstance CreateInstance(Lifetime lifetime, IComponentContainer parent, Object[] args);
    [NotNullAttribute]
public static object CreateInstance(Lifetime lifetime, Type objecttype, IComponentContainer parent, Object[] args);
    [NotNullAttribute]
public static object CreateInstance(Lifetime lifetime, Type objecttype, IComponentContainer parent, Instantiation instantiation, Object[] args);
    [AsyncStateMachineAttribute("JetBrains.Application.Components.FactoryComponentContainer/<CreateInstanceAsync>d__3")]
[NotNullAttribute]
public static Task`1<object> CreateInstanceAsync(Lifetime lifetime, Type objecttype, IComponentContainer parent, IInitializationStrategy initializationStrategy, TaskPriority taskPriority, Object[] args);
    [AsyncStateMachineAttribute("JetBrains.Application.Components.FactoryComponentContainer/<CreateInstanceAsync>d__4")]
[NotNullAttribute]
public static Task`1<object> CreateInstanceAsync(Lifetime lifetime, Type objecttype, IComponentContainer parent, IInitializationStrategy initializationStrategy, TaskPriority taskPriority, Instantiation instantiation, Object[] args);
    [NotNullAttribute]
public static object CreateInstanceWithoutContainer(Lifetime lifetime, Type objecttype, Object[] args);
    public static object InvokeLive(Lifetime lifetime, IComponentContainer parent, MemberInfo method, object instance, Object[] args, Instantiation instantiation);
    public static void InvokeLiveExpression(Lifetime lifetime, IComponentContainer parent, Expression`1<Action> expr, Object[] args);
    public static void InvokeTransientExpression(IComponentContainer parent, Expression`1<Action> expr);
    [CanBeNullAttribute]
public static object InvokeTransientExpression(IComponentContainer parent, Expression`1<Action> expr, Object[] args);
    [CanBeNullAttribute]
public static object InvokeTransientMethod(IComponentContainer parent, object instance, MethodInfo method, Object[] args);
    [NotNullAttribute]
private static Task`1<object> CreateInstanceCoreAsync(Lifetime lifetime, Type type, IComponentContainer parent, IInitializationStrategy initializationStrategy, TaskPriority taskPriority, Instantiation instantiation, Object[] args);
    private static Task`1<object> GetComponentAsync(IComponentContainer container, Type request, TaskPriority taskPriority);
    [NotNullAttribute]
public static List`1<IComponentDescriptor> GetExplicitArgumentDescriptors(Object[] args);
}
public interface JetBrains.Application.Components.IAsyncComposeManager {
    public abstract virtual void RegisterAsyncCompose(Lifetime lifetime, string containerId);
    public abstract virtual void SuspendLaterAsync(Lifetime lifetime, string containerId);
    public abstract virtual Task WhenLaterAsyncSuspenseCompleted(Lifetime lifetime);
}
public interface JetBrains.Application.Components.IAutocreateWith`1 {
}
public interface JetBrains.Application.Components.IAutocreateWithRegistration {
    [NotNullAttribute]
public object Request { get; }
    public abstract virtual object get_Request();
}
public interface JetBrains.Application.Components.IComponentComparer {
    public abstract virtual int Compare(IValueDescriptor x, IValueDescriptor y);
}
public interface JetBrains.Application.Components.IComponentContainer {
    [CanBeNullAttribute]
public IProperty`1<ComponentContainerState> State { get; }
    [CanBeNullAttribute]
public IContainerThreading Threading { get; }
    public abstract virtual IProperty`1<ComponentContainerState> get_State();
    public abstract virtual IContainerThreading get_Threading();
    [NotNullAttribute]
public abstract virtual IValueResolveContext CreateResolveContext(ValueResolveRequester requester);
}
public interface JetBrains.Application.Components.IComponentContainerExtender {
    [NotNullAttribute]
[ItemNotNullAttribute]
public IViewableSet`1<object> CreatedComponents { get; }
    public abstract virtual IViewableSet`1<object> get_CreatedComponents();
    [CanBeNullAttribute]
public abstract virtual IValueResolver TryCreateValueResolver(Lifetime containerLifetime, IPartCatalogSet partCatalog, IComponentContainer componentContainer);
}
public interface JetBrains.Application.Components.IComponentDescriptor {
    public ComponentProperties Properties { get; }
    public abstract virtual ComponentProperties get_Properties();
    public abstract virtual IEnumerable`1<IValueRegistration> GetRegistrations();
}
public interface JetBrains.Application.Components.IContainerBoundDescriptor {
    public abstract virtual void BindToContainer(IComponentContainer container);
}
public interface JetBrains.Application.Components.IContainerComposingProgress {
    public abstract virtual Task WhenContainerSyncComposed();
    public abstract virtual Task WhenContainerAsyncComposed();
    public abstract virtual Task WhenLaterAsyncComposed();
}
public interface JetBrains.Application.Components.IContainerThreading {
    public bool IsSyncMode { get; }
    public bool IsPrimaryThread { get; }
    public TaskScheduler UnguardedScheduler { get; }
    public TaskScheduler GuardedScheduler { get; }
    public TaskScheduler BackgroundScheduler { get; }
    [NotNullAttribute]
public IReaderWriterLock RwLock { get; }
    public ReentrancyGuard ReentrancyGuard { get; }
    public abstract virtual bool get_IsSyncMode();
    public abstract virtual bool get_IsPrimaryThread();
    public abstract virtual TaskScheduler get_UnguardedScheduler();
    public abstract virtual TaskScheduler get_GuardedScheduler();
    public abstract virtual TaskScheduler get_BackgroundScheduler();
    public abstract virtual SchedulerAwaiter YieldToBackground(TaskPriority priority);
    public abstract virtual SchedulerAwaiter YieldToMainThreadScheduler(TaskPriority priority);
    public abstract virtual SyncContextCookie CreateBackgroundSyncContextCookie(TaskPriority priority);
    public abstract virtual IReaderWriterLock get_RwLock();
    public abstract virtual ReentrancyGuard get_ReentrancyGuard();
}
public interface JetBrains.Application.Components.IEnumerableValueDescriptor {
    public bool IsValueAccessed { get; }
    public abstract virtual IEnumerable`1<IValueDescriptor> GetDescriptors();
    public abstract virtual bool get_IsValueAccessed();
}
public interface JetBrains.Application.Components.IHideImplementation`1 {
}
public interface JetBrains.Application.Components.IImmutableList`1 {
}
public interface JetBrains.Application.Components.IImmutableListOfLazy`1 {
}
public interface JetBrains.Application.Components.IInitializationStrategy {
    [CanBeNullAttribute]
public IContainerThreading ContainerThreading { get; }
    public abstract virtual IContainerThreading get_ContainerThreading();
    public abstract virtual void Schedule(Lifetime lifetime, ICollection`1<IComponentDescriptor> descriptors, string containedId, IComponentContainer container, ContainerComposingProgress progress);
    public abstract virtual void Wait(Action whenDone, Lifetime lifetime, string waitReason);
}
[DerivedComponentsInstantiationRequirementAttribute("1")]
public interface JetBrains.Application.Components.IInitializationStrategyProvider {
    public abstract virtual IInitializationStrategy InitializationStrategy(Lifetime lifetime);
}
public interface JetBrains.Application.Components.ILazy {
}
public interface JetBrains.Application.Components.ILazy`1 {
    [NotNullAttribute]
public TComponent Value { get; }
    public bool IsValueCreated { get; }
    public abstract virtual TComponent get_Value();
    [NotNullAttribute]
[ObsoleteAttribute("Use Value")]
public abstract virtual TComponent GetValueSync();
    [CanBeNullAttribute]
public abstract virtual TComponent TryGetValueSyncWithoutCreation();
    public abstract virtual bool get_IsValueCreated();
    public abstract virtual ValueTaskAwaiter`1<TComponent> GetAwaiter();
    [ItemNotNullAttribute]
public abstract virtual ValueTask`1<TComponent> GetValueAsync(TaskPriority priority);
}
public interface JetBrains.Application.Components.ILazyDescriptor {
    public bool IsValueAccessed { get; }
    public abstract virtual bool get_IsValueAccessed();
}
public interface JetBrains.Application.Components.ILazyImmutableList {
}
public interface JetBrains.Application.Components.ILazyImmutableList`1 {
}
public interface JetBrains.Application.Components.ILazyImmutableListOfLazy`1 {
}
public interface JetBrains.Application.Components.ILazyOrderedImmutableList`1 {
}
public interface JetBrains.Application.Components.ILazyOrderedImmutableList`2 {
}
public interface JetBrains.Application.Components.ILazyOrderedImmutableList`3 {
}
public interface JetBrains.Application.Components.ILazyOrderedImmutableListOfLazy`1 {
}
public interface JetBrains.Application.Components.ILazyOrderedImmutableListOfLazy`2 {
}
public interface JetBrains.Application.Components.ILazyOrderedImmutableListOfLazy`3 {
}
public interface JetBrains.Application.Components.ILazyProxyDescriptor {
    public abstract virtual IEnumerable`1<IValueDescriptor> GetTargetDescriptors();
}
public interface JetBrains.Application.Components.ILifetimeDescriptor {
}
[ExtensionAttribute]
public static class JetBrains.Application.Components.ImmutableListObject : object {
    [ExtensionAttribute]
public static IReadyImmutableList`1<TComponent> ToReadyImmutableList(IEnumerable`1<TComponent> enumerable);
    [ExtensionAttribute]
public static IReadyImmutableList`1<ILazy`1<TComponent>> ToReadyImmutableListOfLazy(IEnumerable`1<TComponent> enumerable);
    [ExtensionAttribute]
public static IImmutableList`1<TComponent> ToLazyImmutableList(ILazy`1<IEnumerable`1<TComponent>> enumerable);
    [ExtensionAttribute]
public static IImmutableList`1<TComponent> ToLazyImmutableList(IEnumerable`1<ILazy`1<TComponent>> enumerable);
    [ExtensionAttribute]
public static IParallelImmutableList`1<TComponent> ToParallelLazyImmutableList(ILazy`1<IEnumerable`1<TComponent>> enumerable);
    [ExtensionAttribute]
public static IParallelImmutableList`1<TComponent> ToParallelLazyImmutableList(IEnumerable`1<ILazy`1<TComponent>> enumerable);
    [ExtensionAttribute]
public static ILazyImmutableListOfLazy`1<ILazy`1<TComponent>> ToUnsafeImmutableList(ILazy`1<IEnumerable`1<TComponent>> enumerable);
    [ExtensionAttribute]
public static ILazyImmutableListOfLazy`1<ILazy`1<TComponent>> ToUnsafeImmutableList(IEnumerable`1<ILazy`1<TComponent>> enumerable);
    public static IReadyImmutableList`1<TComponent> CreateReadyList(TComponent[] enumerable);
    public static IReadyImmutableList`1<ILazy`1<TComponent>> CreateReadyListOfLazy(Func`1<IEnumerable`1<TComponent>> f);
    public static IImmutableList`1<TComponent> CreateList(TComponent[] enumerable);
    public static IImmutableList`1<TComponent> CreateList(Func`1<IList`1<TComponent>> f);
    public static IParallelImmutableList`1<TComponent> CreateParallelList(TComponent[] enumerable);
    public static ILazyImmutableListOfLazy`1<ILazy`1<TComponent>> CreateUnsafeListOfLazy(Func`1<IEnumerable`1<TComponent>> f);
    internal static void StartInitAsync(IEnumerable`1<ILazy`1<T>> lazies);
}
public interface JetBrains.Application.Components.INestedComponentContainerComponentDescriptorFilter {
    public abstract virtual bool ShouldForceInitialization(IComponentDescriptor componentDescriptor);
}
public interface JetBrains.Application.Components.INestedComponentContainerDictionary`2 {
}
public interface JetBrains.Application.Components.INestedComponentContainerDictionaryRegisterStrategy`1 {
    public abstract virtual IDictionary`2<TKey, INestedComponentContainerRegisterStrategy> GetStrategies();
}
public interface JetBrains.Application.Components.INestedComponentContainerOwner {
    [CanBeNullAttribute]
public abstract virtual T TryGetOwnerComponent();
    [CanBeNullAttribute]
public abstract virtual T GetOwnerComponentOrThrow();
}
public interface JetBrains.Application.Components.INestedComponentContainerRegisterStrategy {
    public string Id { get; }
    public Type PartCatalogSetType { get; }
    public Type PartCatalogAttributeType { get; }
    public IPartSelector PartSelector { get; }
    public IPartCatalogFilter[] Filter { get; }
    public abstract virtual string get_Id();
    public abstract virtual Type get_PartCatalogSetType();
    public abstract virtual Type get_PartCatalogAttributeType();
    public abstract virtual IPartSelector get_PartSelector();
    public abstract virtual IPartCatalogFilter[] get_Filter();
    public abstract virtual bool ShouldForceInitialization(IComponentDescriptor componentDescriptor);
}
public abstract class JetBrains.Application.Components.InitializationStrategyBase : object {
    private static ILogger ourLogger;
    private static InitializationStrategyBase();
    protected static void InitDescriptorSync(Lifetime lifetime, IComponentContainer container, IComponentDescriptor descriptor, ContainerStrategyStage stage);
}
[ExtensionAttribute]
public static class JetBrains.Application.Components.InitializationStrategyEx : object {
    [ExtensionAttribute]
public static void WaitOnce(IInitializationStrategy initializationStrategy, Action whenDone, Lifetime lifetime, string waitReason);
}
public class JetBrains.Application.Components.InitializationStrategyLegacy : InitializationStrategyBase {
    public IContainerThreading ContainerThreading { get; }
    public sealed virtual IContainerThreading get_ContainerThreading();
    public sealed virtual void Schedule(Lifetime lifetime, ICollection`1<IComponentDescriptor> dscs, string containedId, IComponentContainer container, ContainerComposingProgress progress);
    public sealed virtual void Wait(Action whenDone, Lifetime lifetime, string waitReason);
}
internal static class JetBrains.Application.Components.InitializingDescriptorsStack : object {
    [ThreadStaticAttribute]
private static List`1<InitializingDescriptor> ourInitializingValueDescriptors;
    [ThreadStaticAttribute]
private static Nullable`1<int> ourFirstByInitializationStrategyIndex;
    internal static IValueDescriptor FirstByInitializationStrategy { get; }
    internal static Nullable`1<InitializingDescriptor> First { get; }
    internal static Nullable`1<InitializingDescriptor> Last { get; }
    internal static IValueDescriptor get_FirstByInitializationStrategy();
    internal static Nullable`1<InitializingDescriptor> get_First();
    internal static Nullable`1<InitializingDescriptor> get_Last();
    internal static IEnumerable`1<InitializingDescriptor> ToEnumerable();
    internal static LocalRefDisposable UsingInitialization(IValueDescriptor descriptor, bool byStrategy);
}
[NullableContextAttribute("1")]
public interface JetBrains.Application.Components.IOptional {
    [NullableAttribute("2")]
public object CanBeNull { get; }
    public bool IsNotNull { get; }
    public bool IsNull { get; }
    public object NotNull { get; }
    [NullableContextAttribute("2")]
public abstract virtual object get_CanBeNull();
    public abstract virtual bool get_IsNotNull();
    public abstract virtual bool get_IsNull();
    public abstract virtual object get_NotNull();
}
[NullableContextAttribute("2")]
public interface JetBrains.Application.Components.IOptional`1 {
    public T CanBeNull { get; }
    [NullableAttribute("1")]
public T NotNull { get; }
    public abstract virtual T get_CanBeNull();
    [NullableContextAttribute("1")]
public abstract virtual T get_NotNull();
}
public interface JetBrains.Application.Components.IOrderedImmutableList`1 {
}
public interface JetBrains.Application.Components.IOrderedImmutableList`2 {
}
public interface JetBrains.Application.Components.IOrderedImmutableList`3 {
}
public interface JetBrains.Application.Components.IOrderedImmutableListOfLazy`1 {
}
public interface JetBrains.Application.Components.IOrderedImmutableListOfLazy`2 {
}
public interface JetBrains.Application.Components.IOrderedImmutableListOfLazy`3 {
}
public interface JetBrains.Application.Components.IParallelImmutableList`1 {
}
public interface JetBrains.Application.Components.IProxyDescriptor {
    public IValueDescriptor Target { get; }
    public abstract virtual IValueDescriptor get_Target();
}
public interface JetBrains.Application.Components.IReadyImmutableList`1 {
}
public interface JetBrains.Application.Components.ISingletonComponentDescriptor {
    public Type Type { get; }
    public abstract virtual Type get_Type();
}
public interface JetBrains.Application.Components.ISingletonDescriptor {
    public IValueResolveContext ValueResolveContext { get; }
    public IComponentContainer Container { get; }
    public abstract virtual IValueResolveContext get_ValueResolveContext();
    public abstract virtual IComponentContainer get_Container();
}
public interface JetBrains.Application.Components.ISplittedComponentContainerServiceProvider`6 {
    public TService Service { get; }
    public abstract virtual TService get_Service();
}
public interface JetBrains.Application.Components.IValueDescriptor {
    public bool IsInitialized { get; }
    public bool IsAlive { get; }
    public bool IsDeadlockSafe { get; }
    public bool IsAsyncAccessOnly { get; }
    public ValueDescriptorIdentifier UsageStatisticsId { get; }
    public abstract virtual bool get_IsInitialized();
    public abstract virtual bool get_IsAlive();
    public abstract virtual bool get_IsDeadlockSafe();
    public abstract virtual bool get_IsAsyncAccessOnly();
    [NotNullAttribute]
[ItemCanBeNullAttribute]
public abstract virtual IReadOnlyList`1<IValueDescriptor> GetDependencies();
    [NotNullAttribute]
public abstract virtual object GetValue();
    [ItemNotNullAttribute]
public abstract virtual ValueTask`1<object> GetValueAsync(TaskPriority priority);
    [CanBeNullAttribute]
public abstract virtual object TryGetValueWithoutCreation();
    [CanBeNullAttribute]
public abstract virtual object TryGetOrCreateValue();
    public abstract virtual ValueDescriptorIdentifier get_UsageStatisticsId();
}
public interface JetBrains.Application.Components.IValueDescriptorNotify {
    public bool IsValueCreationStarted { get; }
    public bool IsValueReady { get; }
    public abstract virtual bool get_IsValueCreationStarted();
    public abstract virtual bool get_IsValueReady();
    public abstract virtual bool TryAdviseValueCreated(Lifetime lifetime, Action FWhenCreated);
}
public interface JetBrains.Application.Components.IValueDescriptorWithCalculatedDeadlockSafe {
    public abstract virtual string GetReasonWhyIsNotDeadlockSafe();
}
public interface JetBrains.Application.Components.IValueDescriptorWithToStringDebug {
    public abstract virtual string ToStringDebug();
}
public interface JetBrains.Application.Components.IValueRegistration {
    [ObsoleteAttribute("For usage statistics purposes only")]
public string TypeAssemblyQualifiedName { get; }
    public abstract virtual bool Accepts(object request);
    public abstract virtual string get_TypeAssemblyQualifiedName();
}
public interface JetBrains.Application.Components.IValueResolveContext {
    public ValueResolveRequester Requester { get; }
    public abstract virtual IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags);
    public abstract virtual ValueResolveRequester get_Requester();
}
public interface JetBrains.Application.Components.IValueResolver {
    public abstract virtual IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags, IValueResolveContext context);
}
[ExtensionAttribute]
public static class JetBrains.Application.Components.LazyComponentObject : object {
    [NotNullAttribute]
public static ILazy`1<TComponent> Create(Lazy`1<TComponent> lazy);
    [NotNullAttribute]
public static ILazy`1<TComponent> Create(Func`1<TComponent> f);
    [NotNullAttribute]
public static ILazy`1<TComponent> Create(TComponent instance);
    [ExtensionAttribute]
public static ILazy`1<TComponent> ToLazyComponent(TComponent instance);
}
public class JetBrains.Application.Components.LazyImmutableListValueResolver : object {
    [CompilerGeneratedAttribute]
private IComponentContainer <container>P;
    [CompilerGeneratedAttribute]
private static bool <IsDefaultResolverForEnumerable>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <NeedToAnalyseLazyInjects>k__BackingField;
    private static ConcurrentDictionary`2<Type, IComponentComparer> ourComparers;
    private static Type ourComponentsByPriorityComparer;
    private static Type ourIEnumerableType;
    private static Type ourIReadonlyListType;
    private static Type ourIJetReadonlyListType;
    private static Type ourTypeOfImmutableListOfLazy1;
    private static Type ourTypeOfLazyImmutableListOfLazy1;
    private static Type ourTypeOfImmutableList1;
    private static Type ourTypeOfLazyImmutableList1;
    private static Type ourTypeOfParallelImmutableList1;
    private static Type ourTypeOfOrderedImmutableListOfLazy1;
    private static Type ourTypeOfOrderedImmutableListOfLazy2;
    private static Type ourTypeOfOrderedImmutableListOfLazy3;
    private static Type ourTypeOfLazyOrderedImmutableListOfLazy1;
    private static Type ourTypeOfLazyOrderedImmutableListOfLazy2;
    private static Type ourTypeOfLazyOrderedImmutableListOfLazy3;
    private static Type ourTypeOfOrderedImmutableList1;
    private static Type ourTypeOfOrderedImmutableList2;
    private static Type ourTypeOfOrderedImmutableList3;
    private static Type ourTypeOfLazyOrderedImmutableList1;
    private static Type ourTypeOfLazyOrderedImmutableList2;
    private static Type ourTypeOfLazyOrderedImmutableList3;
    internal static bool IsDefaultResolverForEnumerable { get; }
    private static bool NeedToAnalyseLazyInjects { get; }
    public LazyImmutableListValueResolver(IComponentContainer container);
    private static LazyImmutableListValueResolver();
    [CompilerGeneratedAttribute]
internal static bool get_IsDefaultResolverForEnumerable();
    [CompilerGeneratedAttribute]
private static bool get_NeedToAnalyseLazyInjects();
    public sealed virtual IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags, IValueResolveContext context);
    [CanBeNullAttribute]
private static Type TryExtractTypeUnderLazyEnumerable(ResolveRequest request, Boolean& parallel, Boolean& ordered, Boolean& deadlockUnsafe, Type& attributeType, Type& comparerType);
    protected static IComponentComparer GetOrCreateComponentComparer(Type comparerType);
}
public class JetBrains.Application.Components.LazyNestedComponentContainerAllByPartAttribute`2 : NestedComponentContainerAllByPartAttribute`3<TPartAttribute, TPartCatalogSet, NestedComponentContainerNoneComponentDescriptorsCreationFilter> {
    internal LazyNestedComponentContainerAllByPartAttribute`2(Lifetime lifetime, string id, IInitializationStrategy strategy, IContainerThreading threading);
}
public class JetBrains.Application.Components.LazyNestedComponentContainerDefaultByPartAttribute`2 : NestedComponentContainer`1<NestedComponentContainerRegisterByPartAttributeStrategy`3<TPartAttribute, TPartCatalogSet, NestedComponentContainerNoneComponentDescriptorsCreationFilter>> {
    internal LazyNestedComponentContainerDefaultByPartAttribute`2(Lifetime lifetime, string id, IInitializationStrategy strategy, IContainerThreading threading);
}
[ObsoleteAttribute]
public class JetBrains.Application.Components.LazyValueResolver : object {
    public static LazyValueResolver Instance;
    private static LazyValueResolver();
    public sealed virtual IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags, IValueResolveContext context);
    [CanBeNullAttribute]
private static Type TryExtractTypeUnderLazy(ResolveRequest request);
    [CanBeNullAttribute]
public static Type TryExtractTypeUnderLazy(Type request);
    private static bool CheckGenericTypeDefinition(Type typeGenericDefinition);
    [NotNullAttribute]
public static IValueDescriptor Create(Type typeUnderLazy, IValueDescriptor descriptorUnderLazy);
}
public class JetBrains.Application.Components.LifecycleInitializationStrategy : AsyncInitializationStrategyBase {
    public LifecycleInitializationStrategy(Lifetime lifetime, ITaskHost taskHost, IAsyncComposeManager asyncComposeManager);
    public LifecycleInitializationStrategy(Lifetime lifetime, IContainerThreading threading, IAsyncComposeManager asyncComposeManager);
    protected virtual void DoSchedule(Lifetime lifetime, ICollection`1<IComponentDescriptor> descriptors, string containerId, IComponentContainer container, LifetimeDefinition laterAsyncLifetimeDef);
    public virtual void Wait(Action whenDone, Lifetime lifetime, string waitReason);
}
public class JetBrains.Application.Components.LifetimeValueResolver : object {
    public static LifetimeValueResolver Instance;
    private static LifetimeValueResolver();
    public sealed virtual IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags, IValueResolveContext context);
}
public class JetBrains.Application.Components.LoggerValueResolver : object {
    public static LoggerValueResolver Instance;
    private static string LoggerForUnknownComponentName;
    private static LoggerValueResolver();
    public sealed virtual IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags, IValueResolveContext context);
}
public class JetBrains.Application.Components.MethodBindigns : SingletonDescriptorBindings`1<MethodInfo> {
    private static ILogger ourLogger;
    [CompilerGeneratedAttribute]
private static MethodBindigns <Empty>k__BackingField;
    public static MethodBindigns Empty { get; }
    public MethodBindigns(MethodInfo method, IReadOnlyList`1<IValueDescriptor> descriptors, IValueDescriptor ownerDescriptor);
    private static MethodBindigns();
    [CompilerGeneratedAttribute]
public static MethodBindigns get_Empty();
    public object Activate(ISingletonDescriptor descriptor, Object[] dependencies);
    private static void EnsureInstanceForVoidMethods(Object& instance, MethodInfo method, IValueDescriptor owningDescriptorForDiag);
}
public class JetBrains.Application.Components.NestedComponentContainerAllByPartAttribute`2 : NestedComponentContainerAllByPartAttribute`3<TPartAttribute, TPartCatalogSet, NestedComponentContainerUnsafeComponentDescriptorsCreationFilter> {
    internal NestedComponentContainerAllByPartAttribute`2(Lifetime lifetime, string id, IInitializationStrategy strategy, IContainerThreading threading);
}
public class JetBrains.Application.Components.NestedComponentContainerAllByPartAttribute`3 : NestedComponentContainer`1<NestedComponentContainerRegisterAllByPartAttributeStrategy<TPartAttribute, TPartCatalogSet, TPreCreatedComponentDescriptorFilter>> {
    internal NestedComponentContainerAllByPartAttribute`3(Lifetime lifetime, string id, IInitializationStrategy strategy, IContainerThreading threading);
}
public class JetBrains.Application.Components.NestedComponentContainerDefaultByPartAttribute`2 : NestedComponentContainer`1<NestedComponentContainerRegisterByPartAttributeStrategy`3<TPartAttribute, TPartCatalogSet, NestedComponentContainerUnsafeComponentDescriptorsCreationFilter>> {
    internal NestedComponentContainerDefaultByPartAttribute`2(Lifetime lifetime, string id, IInitializationStrategy strategy, IContainerThreading threading);
}
public class JetBrains.Application.Components.NestedComponentContainerDefaultByPartAttribute`3 : NestedComponentContainer`1<NestedComponentContainerRegisterByPartAttributeStrategy`3<TPartAttribute, TPartCatalogSet, TPreCreatedComponentDescriptorFilter>> {
    internal NestedComponentContainerDefaultByPartAttribute`3(Lifetime lifetime, string id, IInitializationStrategy strategy, IContainerThreading threading);
}
public class JetBrains.Application.Components.NestedComponentContainerInitializationStrategy : object {
    [CompilerGeneratedAttribute]
private IInitializationStrategy <outerStrategy>P;
    public IContainerThreading ContainerThreading { get; }
    public NestedComponentContainerInitializationStrategy(IInitializationStrategy outerStrategy);
    public sealed virtual IContainerThreading get_ContainerThreading();
    private sealed virtual override void JetBrains.Application.Components.IInitializationStrategy.Schedule(Lifetime lifetime, ICollection`1<IComponentDescriptor> descriptors, string containedId, IComponentContainer container, ContainerComposingProgress progress);
    private sealed virtual override void JetBrains.Application.Components.IInitializationStrategy.Wait(Action whenDone, Lifetime lifetime, string waitReason);
}
public class JetBrains.Application.Components.NestedComponentContainerLeafsAndHidesByPartAttribute`2 : NestedComponentContainerLeafsAndHidesByPartAttribute`3<TPartAttribute, TPartCatalogSet, NestedComponentContainerUnsafeComponentDescriptorsCreationFilter> {
    internal NestedComponentContainerLeafsAndHidesByPartAttribute`2(Lifetime lifetime, string id, IInitializationStrategy strategy, IContainerThreading threading);
}
public class JetBrains.Application.Components.NestedComponentContainerLeafsAndHidesByPartAttribute`3 : NestedComponentContainer`1<NestedComponentContainerRegisterLeafsAndHidesByPartAttributeStrategy<TPartAttribute, TPartCatalogSet, TPreCreatedComponentDescriptorFilter>> {
    internal NestedComponentContainerLeafsAndHidesByPartAttribute`3(Lifetime lifetime, string id, IInitializationStrategy strategy, IContainerThreading threading);
}
public class JetBrains.Application.Components.NestedComponentContainerLeafsByPartAttribute`3 : NestedComponentContainer`1<NestedComponentContainerRegisterLeafsByPartAttributeStrategy<TPartAttribute, TPartCatalogSet, TPreCreatedComponentDescriptorFilter>> {
    internal NestedComponentContainerLeafsByPartAttribute`3(Lifetime lifetime, string id, IInitializationStrategy strategy, IContainerThreading threading);
}
public class JetBrains.Application.Components.NestedComponentContainerNoneComponentDescriptorsCreationFilter : object {
    public sealed virtual bool ShouldForceInitialization(IComponentDescriptor componentDescriptor);
}
public class JetBrains.Application.Components.NestedComponentContainerRegisterByPartAttributeStrategy`1 : object {
    private static TPreCreatedComponentDescriptorFilter ourComponentDescriptorFilter;
    private static NestedComponentContainerRegisterByPartAttributeStrategy`1();
    public sealed virtual bool ShouldForceInitialization(IComponentDescriptor componentDescriptor);
}
public class JetBrains.Application.Components.NestedComponentContainerRegisterByPartAttributeStrategy`3 : NestedComponentContainerRegisterByPartAttributeStrategy`1<TPreCreatedComponentDescriptorFilter> {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PartCatalogSetType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PartCatalogAttributeType>k__BackingField;
    [CompilerGeneratedAttribute]
private IPartSelector <PartSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private IPartCatalogFilter[] <Filter>k__BackingField;
    public string Id { get; }
    public Type PartCatalogSetType { get; }
    public Type PartCatalogAttributeType { get; }
    public IPartSelector PartSelector { get; }
    public IPartCatalogFilter[] Filter { get; }
    protected NestedComponentContainerRegisterByPartAttributeStrategy`3(IPartSelector selector);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_PartCatalogSetType();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_PartCatalogAttributeType();
    [CompilerGeneratedAttribute]
public sealed virtual IPartSelector get_PartSelector();
    [CompilerGeneratedAttribute]
public sealed virtual IPartCatalogFilter[] get_Filter();
}
public class JetBrains.Application.Components.NestedComponentContainerUnsafeComponentDescriptorsCreationFilter : object {
    public sealed virtual bool ShouldForceInitialization(IComponentDescriptor componentDescriptor);
}
public interface JetBrains.Application.Components.NestedContainer.INestedComponentContainerValueDescriptor {
    public IComponentContainer NestedComponentContainer { get; }
    public abstract virtual IComponentContainer get_NestedComponentContainer();
}
public class JetBrains.Application.Components.NestedContainer.NestedComponentContainer : ComponentContainer {
    private Dictionary`2<IComponentDescriptor, ExternalComponentOfNestedContainerDescriptor> myComponents;
    private Dictionary`2<ExternalComponentOfNestedContainerDescriptor, IEnumerable`1<IComponentDescriptor>> myDependencies;
    private HashSet`1<IValueRegistration> myComponentRegistrations;
    [CompilerGeneratedAttribute]
private IContainerThreading <Threading>k__BackingField;
    public IContainerThreading Threading { get; }
    internal NestedComponentContainer(Lifetime lifetime, string id, IInitializationStrategy strategy, IContainerThreading threading);
    [CompilerGeneratedAttribute]
public virtual IContainerThreading get_Threading();
    internal NestedComponentContainer DenyExternalDependency(IReadOnlyList`1<IComponentDescriptor> internalDescriptors, IComponentDescriptor externalDescriptor);
    [ConditionalAttribute("JET_MODE_ASSERT")]
internal void CheckDeniedExternalDependency(Type request, IValueResolveContext context);
    public virtual IContainerComposingProgress ComposeAsync();
    [CompilerGeneratedAttribute]
private bool <CheckDeniedExternalDependency>b__8_0(Type arg);
}
public class JetBrains.Application.Components.NestedContainer.NestedComponentContainer`1 : NestedComponentContainer {
    internal NestedComponentContainer`1(Lifetime lifetime, string id, IInitializationStrategy strategy, IContainerThreading threading);
}
public class JetBrains.Application.Components.NestedContainer.NestedComponentContainerValueResolver : object {
    private static Type ourTypeOfNestedContainer;
    private static Type ourTypeOfNestedContainerDictionary;
    private static Type ourTypeOfNestedContainerValueDescriptorHelper;
    private static Type ourTypeOfNestedContainerDictionaryValueDescriptor;
    private IComponentContainer myComponentContainer;
    private IInitializationStrategy myInitializationStrategy;
    public NestedComponentContainerValueResolver(IComponentContainer componentContainer, IInitializationStrategy initializationStrategy);
    private static NestedComponentContainerValueResolver();
    public sealed virtual IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags, IValueResolveContext context);
    [CanBeNullAttribute]
private static Type TryExtractStrategyType(ResolveRequest request);
    [CanBeNullAttribute]
private static Type[] TryExtractDictionaryStrategyTypes(ResolveRequest request);
}
public class JetBrains.Application.Components.NoInitializationStrategy : object {
    [NotNullAttribute]
public static IInitializationStrategy Default;
    public IContainerThreading ContainerThreading { get; }
    private static NoInitializationStrategy();
    public sealed virtual IContainerThreading get_ContainerThreading();
    private sealed virtual override void JetBrains.Application.Components.IInitializationStrategy.Schedule(Lifetime lifetime, ICollection`1<IComponentDescriptor> descriptors, string containedId, IComponentContainer container, ContainerComposingProgress progress);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private static void AssertDescriptorsInstantiation(IEnumerable`1<IComponentDescriptor> descriptors);
    private sealed virtual override void JetBrains.Application.Components.IInitializationStrategy.Wait(Action whenDone, Lifetime lifetime, string waitReason);
}
public class JetBrains.Application.Components.ObjectComponentDescriptor : object {
    private object myInstance;
    public bool IsInitialized { get; }
    public bool IsAlive { get; }
    public bool IsDeadlockSafe { get; }
    public bool IsAsyncAccessOnly { get; }
    public ComponentProperties Properties { get; }
    private ValueDescriptorIdentifier JetBrains.Application.Components.IValueDescriptor.UsageStatisticsId { get; }
    public ObjectComponentDescriptor(object instance);
    public sealed virtual bool get_IsInitialized();
    public sealed virtual bool get_IsAlive();
    public sealed virtual bool get_IsDeadlockSafe();
    public sealed virtual bool get_IsAsyncAccessOnly();
    public sealed virtual ComponentProperties get_Properties();
    public sealed virtual IEnumerable`1<IValueRegistration> GetRegistrations();
    public sealed virtual IReadOnlyList`1<IValueDescriptor> GetDependencies();
    public sealed virtual object GetValue();
    public sealed virtual ValueTask`1<object> GetValueAsync(TaskPriority priority);
    public sealed virtual object TryGetValueWithoutCreation();
    public sealed virtual object TryGetOrCreateValue();
    public virtual string ToString();
    private sealed virtual override ValueDescriptorIdentifier JetBrains.Application.Components.IValueDescriptor.get_UsageStatisticsId();
}
public class JetBrains.Application.Components.OnDemandDescriptor : AsyncDescriptorBase {
    private ICollection`1<IValueRegistration> myRegistrations;
    [NotNullAttribute]
private Func`1<object> myFactory;
    public ComponentProperties Properties { get; }
    protected ValueDescriptorIdentifier UsageStatisticsId { get; }
    public OnDemandDescriptor(ICollection`1<IValueRegistration> registrations, Func`1<object> factory, IContainerThreading threading);
    private sealed virtual override IEnumerable`1<IValueRegistration> JetBrains.Application.Components.IComponentDescriptor.GetRegistrations();
    public virtual ComponentProperties get_Properties();
    protected virtual object CreateInstance(Object[] dependencies);
    protected virtual string Present();
    protected virtual ValueDescriptorIdentifier get_UsageStatisticsId();
    [CompilerGeneratedAttribute]
private object <CreateInstance>b__6_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JetBrains.Application.Components.Optional`1 : object {
    [NullableAttribute("1")]
public static Optional`1<T> Null;
    private T myValue;
    public T CanBeNull { get; }
    public bool IsNotNull { get; }
    public bool IsNull { get; }
    [NullableAttribute("1")]
public T NotNull { get; }
    private object JetBrains.Application.Components.IOptional.CanBeNull { get; }
    [NullableAttribute("1")]
private object JetBrains.Application.Components.IOptional.NotNull { get; }
    public Optional`1(T value);
    private static Optional`1();
    public sealed virtual T get_CanBeNull();
    public sealed virtual bool get_IsNotNull();
    public sealed virtual bool get_IsNull();
    [NullableContextAttribute("1")]
public sealed virtual T get_NotNull();
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override object JetBrains.Application.Components.IOptional.get_CanBeNull();
    [NullableContextAttribute("1")]
private sealed virtual override object JetBrains.Application.Components.IOptional.get_NotNull();
}
[ExtensionAttribute]
public static class JetBrains.Application.Components.OptionalEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static T ValueNotNull(Optional`1<T> thіs, string message);
}
public class JetBrains.Application.Components.OptionalValueResolver : object {
    public static OptionalValueResolver Instance;
    private static Type TypeOfIOptional;
    private static Type TypeOfIOptional_1;
    private static Type TypeOfOptional_1;
    private static Type TypeOfOptionalDescriptor_1;
    private static OptionalValueResolver();
    [NotNullAttribute]
private static IValueDescriptor Create(Type typeUnderOptional, IValueDescriptor descriptorUnderOptional);
    public sealed virtual IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags, IValueResolveContext context);
    [CanBeNullAttribute]
private static Type TryExtractTypeUnderOptional(ResolveRequest request);
}
public class JetBrains.Application.Components.ParallelLifecycleInitializationStrategy : AsyncInitializationStrategyBase {
    public ParallelLifecycleInitializationStrategy(Lifetime lifetime, ITaskHost taskHost, IAsyncComposeManager asyncComposeManager);
    public ParallelLifecycleInitializationStrategy(Lifetime lifetime, IContainerThreading threading, IAsyncComposeManager asyncComposeManager);
    protected virtual void DoSchedule(Lifetime lifetime, ICollection`1<IComponentDescriptor> descriptors, string containerId, IComponentContainer container, LifetimeDefinition laterAsyncLifetimeDef);
    public virtual void Wait(Action whenDone, Lifetime lifetime, string waitReason);
}
public class JetBrains.Application.Components.ParallelLikeLegacyLifecycleInitializationStrategy : ParallelLifecycleInitializationStrategy {
    public ParallelLikeLegacyLifecycleInitializationStrategy(Lifetime lifetime, ITaskHost taskHost, IAsyncComposeManager asyncComposeManager);
    public ParallelLikeLegacyLifecycleInitializationStrategy(Lifetime lifetime, IContainerThreading threading, IAsyncComposeManager asyncComposeManager);
    protected virtual bool IsComponentForAsyncStage(IComponentDescriptor descriptor);
    protected virtual Task InitLaterAsyncComponentsAsync(Lifetime lifetime, string containerId, IComponentContainer container, ICollection`1<IComponentDescriptor> descriptors, LifetimeDefinition laterAsyncLifetimeDef);
}
public static class JetBrains.Application.Components.PartCatalogueTypeEqualityUtil : object {
    public static int GetHashCode(StringSource assemblyFullName, StringSource typeFullName);
    public static bool TypesEquals(Type type, PartCatalogueType partCatalogueType);
    [ObsoleteAttribute("PCType got Equals for runtime types.")]
public static bool TypesEquals(Type type, PartCatalogType partCatalogueType);
    public static bool GenericTypesTypesEquals(Type type, PartCatalogueType partCatalogueType);
}
public class JetBrains.Application.Components.ReentrantGetValueException : InvalidOperationException {
    public ReentrantGetValueException(IValueDescriptorWithToStringDebug descriptor);
}
[IsReadOnlyAttribute]
public class JetBrains.Application.Components.ResolveRequest : ValueType {
    [CompilerGeneratedAttribute]
private object <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TypeRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <GenericTypeDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <GenericTypeArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SingleOrDefaultGenericTypeArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SingleGenericTypeArgumentErrorMessage>k__BackingField;
    [NotNullAttribute]
public object Request { get; }
    [CanBeNullAttribute]
public Type TypeRequest { get; }
    [CanBeNullAttribute]
public Type GenericTypeDefinition { get; }
    [CanBeNullAttribute]
public Type[] GenericTypeArguments { get; }
    [CanBeNullAttribute]
public Type SingleOrDefaultGenericTypeArgument { get; }
    [CanBeNullAttribute]
private string SingleGenericTypeArgumentErrorMessage { get; }
    [ObsoleteAttribute("Use ResolveRequest.Create()")]
internal ResolveRequest(object request);
    public static ResolveRequest Create(object request);
    [CompilerGeneratedAttribute]
public object get_Request();
    [CompilerGeneratedAttribute]
public Type get_TypeRequest();
    [CompilerGeneratedAttribute]
public Type get_GenericTypeDefinition();
    [CompilerGeneratedAttribute]
public Type[] get_GenericTypeArguments();
    [CompilerGeneratedAttribute]
public Type get_SingleOrDefaultGenericTypeArgument();
    [CompilerGeneratedAttribute]
private string get_SingleGenericTypeArgumentErrorMessage();
    [NotNullAttribute]
public Type SingleGenericTypeArgument();
    public virtual string ToString();
    public sealed virtual bool Equals(ResolveRequest other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Application.Components.RuntimeMemberComponentDescriptor : SingletonDescriptor`1<MethodBindigns> {
    [CanBeNullAttribute]
private object myInstance;
    [NotNullAttribute]
public MemberInfo Member;
    [CompilerGeneratedAttribute]
private ComponentProperties <Properties>k__BackingField;
    public ComponentProperties Properties { get; }
    protected ValueDescriptorIdentifier UsageStatisticsId { get; }
    public RuntimeMemberComponentDescriptor(IComponentContainer container, MemberInfo member, object instance, Instantiation instantiation);
    public RuntimeMemberComponentDescriptor(IComponentContainer container, MemberInfo member, object instance, ComponentProperties properties);
    [CompilerGeneratedAttribute]
public virtual ComponentProperties get_Properties();
    public virtual IEnumerable`1<IValueRegistration> GetRegistrations();
    protected virtual string Present();
    protected virtual ValueDescriptorIdentifier get_UsageStatisticsId();
    protected virtual object DoCreateInstance(MethodBindigns bindings, Object[] dependencies);
    protected virtual MethodBindigns GetEmptyDependencies();
    protected virtual MethodBindigns DoGetDependenciesNoCache();
}
internal static class JetBrains.Application.Components.ServicesValidationHelper : object {
    private static ConcurrentDictionary`2<Type, bool> ourTypeIsLazyChecks;
    private static ServicesValidationHelper();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void CheckDependencies(IComponentDescriptor serviceDescriptor, IEnumerable`1<IValueDescriptor> dependencies);
}
[ExtensionAttribute]
public static class JetBrains.Application.Components.SignatureResolution : object {
    [ExtensionAttribute]
public static T CreateInstance(IComponentContainer container);
    [ExtensionAttribute]
public static object CreateInstance(IComponentContainer container, Type type);
    [ExtensionAttribute]
public static object DynamicInvoke(IComponentContainer container, Delegate function);
    [ExtensionAttribute]
public static void DynamicInvoke(IComponentContainer container, Action action);
    [ExtensionAttribute]
public static void DynamicInvoke(IComponentContainer container, Action`1<T1> action);
    [ExtensionAttribute]
public static void DynamicInvoke(IComponentContainer container, Action`2<T1, T2> action);
    [ExtensionAttribute]
public static TResult DynamicInvoke(IComponentContainer container, Func`1<TResult> action);
    [ExtensionAttribute]
public static TResult DynamicInvoke(IComponentContainer container, Func`2<T1, TResult> action);
    [ExtensionAttribute]
public static TResult DynamicInvoke(IComponentContainer container, Func`3<T1, T2, TResult> action);
    [ExtensionAttribute]
public static TResult DynamicInvoke(IComponentContainer container, Func`4<T1, T2, T3, TResult> action);
    [ExtensionAttribute]
public static TResult DynamicInvoke(IComponentContainer container, Func`5<T1, T2, T3, T4, TResult> action);
    [ExtensionAttribute]
public static object CreateInstance(Binding binding);
    [ExtensionAttribute]
private static object CreateInstance(ConstructorInfo constructor, List`1<IValueDescriptor> argumentDescriptors);
    [ExtensionAttribute]
public static Binding BindToConstructor(Type type, IValueResolveContext context);
    [ExtensionAttribute]
public static Binding BindToMethod(Type type, string name, IValueResolveContext context);
    public static Binding BindToMethod(MethodBase[] candidates, IValueResolveContext context, object origin);
    public static Object[] BindArguments(List`1<IValueDescriptor> argumentDescriptors, object origin);
    [NotNullAttribute]
private static InvalidOperationException MakeDiagnosticException(string descriptor, List`1<Binding> bound, List`1<KeyValuePair`2<MethodBase, List`1<Type>>> rejected);
    private static void AddRejectedConstructorsData(Exception ex, IEnumerable`1<KeyValuePair`2<MethodBase, List`1<Type>>> constructorsRejected);
    [NotNullAttribute]
public static Object[] BindMethodParameters(MethodInfo method, IComponentContainer container);
}
public abstract class JetBrains.Application.Components.SingletonComponentDescriptor`1 : SingletonDescriptor`1<T> {
    [NotNullAttribute]
private Type myType;
    [NotNullAttribute]
public Type Type { get; }
    protected SingletonComponentDescriptor`1(IComponentContainer container, Type type);
    public virtual IEnumerable`1<IValueRegistration> GetRegistrations();
    public sealed virtual Type get_Type();
    protected virtual string Present();
}
public abstract class JetBrains.Application.Components.SingletonDescriptor`1 : AsyncDescriptorBase {
    [CompilerGeneratedAttribute]
private IComponentContainer <Container>k__BackingField;
    [NotNullAttribute]
private Lazy`1<IValueResolveContext> myValueResolveContextCache;
    private object myLocker;
    private T myDependencies;
    public IComponentContainer Container { get; }
    [NotNullAttribute]
public IValueResolveContext ValueResolveContext { get; }
    protected bool IsComponentWithInterruptableActivation { get; }
    protected SingletonDescriptor`1(IComponentContainer container);
    [CompilerGeneratedAttribute]
public sealed virtual IComponentContainer get_Container();
    public sealed virtual IValueResolveContext get_ValueResolveContext();
    protected virtual void RegisterInstance(object instance);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void RegisterInstanceWithLeakWatchdog(object instance);
    protected virtual bool get_IsComponentWithInterruptableActivation();
    protected virtual void InterruptActivation();
    protected virtual void DisposeInternalResources();
    protected sealed virtual object CreateInstance(Object[] dependencies);
    protected abstract virtual object DoCreateInstance(T bindings, Object[] dependencies);
    [CanBeNullAttribute]
private T TryGetCachedDependencies(bool allowGetValueIfNotAlive);
    public abstract virtual IEnumerable`1<IValueRegistration> GetRegistrations();
    public sealed virtual IReadOnlyList`1<IValueDescriptor> DoGetDependencies();
    protected abstract virtual T GetEmptyDependencies();
    protected abstract virtual T DoGetDependenciesNoCache();
    private T DoGetDependenciesNoCacheValidated();
}
[DefaultMemberAttribute("Item")]
public abstract class JetBrains.Application.Components.SingletonDescriptorBindings`1 : object {
    private T myMethodInfo;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IValueDescriptor> <ArgumentDescriptors>k__BackingField;
    [CompilerGeneratedAttribute]
private IValueDescriptor <OwnerDescriptorIfInstanceMethod>k__BackingField;
    [NotNullAttribute]
public IReadOnlyList`1<IValueDescriptor> ArgumentDescriptors { get; }
    public T Method { get; }
    [CanBeNullAttribute]
public IValueDescriptor OwnerDescriptorIfInstanceMethod { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public IValueDescriptor Item { get; }
    protected SingletonDescriptorBindings`1(T method, IReadOnlyList`1<IValueDescriptor> descriptors, IValueDescriptor ownerDescriptor);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IValueDescriptor> get_ArgumentDescriptors();
    public T get_Method();
    [CompilerGeneratedAttribute]
public IValueDescriptor get_OwnerDescriptorIfInstanceMethod();
    public bool get_IsEmpty();
    [IteratorStateMachineAttribute("JetBrains.Application.Components.SingletonDescriptorBindings`1/<GetEnumerator>d__13")]
public sealed virtual IEnumerator`1<IValueDescriptor> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual IValueDescriptor get_Item(int index);
    public sealed virtual void Dispose();
    private static void DisposeDescriptor(IValueDescriptor descriptor);
}
public class JetBrains.Application.Components.SingletonFactoryComponentDescriptor`1 : SingletonComponentDescriptor`1<IReadOnlyList`1<IValueDescriptor>> {
    [NotNullAttribute]
private Func`2<IValueResolveContext, T> myFactory;
    [CompilerGeneratedAttribute]
private ComponentProperties <Properties>k__BackingField;
    public ComponentProperties Properties { get; }
    protected ValueDescriptorIdentifier UsageStatisticsId { get; }
    public SingletonFactoryComponentDescriptor`1(IComponentContainer container, Func`2<IValueResolveContext, T> factory, Instantiation instantiation);
    public SingletonFactoryComponentDescriptor`1(IComponentContainer container, Func`2<IValueResolveContext, T> factory, ComponentProperties properties);
    [CompilerGeneratedAttribute]
public virtual ComponentProperties get_Properties();
    protected virtual object DoCreateInstance(IReadOnlyList`1<IValueDescriptor> bindings, Object[] dependencies);
    protected virtual IReadOnlyList`1<IValueDescriptor> GetEmptyDependencies();
    protected virtual IReadOnlyList`1<IValueDescriptor> DoGetDependenciesNoCache();
    protected virtual ValueDescriptorIdentifier get_UsageStatisticsId();
}
public class JetBrains.Application.Components.SingletonTypeComponentDescriptor : SingletonComponentDescriptor`1<ConstructiorBindigns> {
    [CompilerGeneratedAttribute]
private ComponentProperties <Properties>k__BackingField;
    public ComponentProperties Properties { get; }
    protected ValueDescriptorIdentifier UsageStatisticsId { get; }
    public SingletonTypeComponentDescriptor(IComponentContainer container, Type type, Instantiation instantiation);
    public SingletonTypeComponentDescriptor(IComponentContainer container, Type type, ComponentProperties properties);
    [CompilerGeneratedAttribute]
public virtual ComponentProperties get_Properties();
    protected virtual object DoCreateInstance(ConstructiorBindigns bindings, Object[] dependencies);
    protected virtual ConstructiorBindigns GetEmptyDependencies();
    protected virtual ConstructiorBindigns DoGetDependenciesNoCache();
    protected virtual ValueDescriptorIdentifier get_UsageStatisticsId();
}
public class JetBrains.Application.Components.SplittedComponentContainerServiceResolver : object {
    private static Type ourSplittedComponentContainerServiceProviderType;
    private static MethodInfo ourResolveMethod;
    private IComponentContainer myComponentContainer;
    private static MethodInfo ResolveMethod { get; }
    public SplittedComponentContainerServiceResolver(IComponentContainer componentContainer);
    private static SplittedComponentContainerServiceResolver();
    public sealed virtual IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags, IValueResolveContext context);
    private static MethodInfo get_ResolveMethod();
    private static IValueDescriptor Resolve(IComponentContainer originalComponentContainer, SplittedComponentContainer`2<TDefinition, TDefinitionAttribute> targetComponentContainer);
    private static Type TryGetServiceProviderRequestType(ResolveRequest request);
    private static bool IsServiceProviderRequestType(ResolveRequest request);
    private static bool IsServiceProviderRequestType(Type type);
}
public class JetBrains.Application.Components.TaggedRegistration : object {
    [NotNullAttribute]
private IValueRegistration myRegistration;
    [NotNullAttribute]
private object myTag;
    [NotNullAttribute]
public IValueRegistration Registration { get; }
    [NotNullAttribute]
public object Tag { get; }
    [ObsoleteAttribute("For usage statistics purposes only")]
private string JetBrains.Application.Components.IValueRegistration.TypeAssemblyQualifiedName { get; }
    public TaggedRegistration(IValueRegistration registration, object tag);
    public IValueRegistration get_Registration();
    public object get_Tag();
    public sealed virtual bool Accepts(object request);
    private bool Equals(TaggedRegistration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override string JetBrains.Application.Components.IValueRegistration.get_TypeAssemblyQualifiedName();
}
public class JetBrains.Application.Components.TaggedRequest : object {
    private object myRequest;
    private object myTag;
    public object Request { get; }
    public object Tag { get; }
    public TaggedRequest(object request, object tag);
    public object get_Request();
    public object get_Tag();
}
internal class JetBrains.Application.Components.TaggedResolveContext : object {
    private IValueResolveContext myResolveContext;
    private object myTag;
    private ValueResolveRequester JetBrains.Application.Components.IValueResolveContext.Requester { get; }
    public TaggedResolveContext(IValueResolveContext resolveContext, object tag);
    public sealed virtual IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags);
    private sealed virtual override ValueResolveRequester JetBrains.Application.Components.IValueResolveContext.get_Requester();
}
public class JetBrains.Application.Components.TypeRegistration : object {
    [NotNullAttribute]
private Type myType;
    public Type Type { get; }
    private string JetBrains.Application.Components.IValueRegistration.TypeAssemblyQualifiedName { get; }
    public TypeRegistration(Type type);
    public Type get_Type();
    private bool Equals(TypeRegistration other);
    public virtual int GetHashCode();
    public sealed virtual bool Accepts(object request);
    public virtual string ToString();
    private sealed virtual override string JetBrains.Application.Components.IValueRegistration.get_TypeAssemblyQualifiedName();
    public virtual bool Equals(object obj);
    [NotNullAttribute]
public static ICollection`1<TypeRegistration> CreateWithBases(Type type);
}
public class JetBrains.Application.Components.UnwantedContainerDependenciesChecker : object {
    private IEnumerable`1<IComponentDescriptor> myComponentDescriptors;
    private static ILogger ourLogger;
    private static HashSet`1<UnwantedContainerDependenciesChecker> ourPendingTasks;
    private static HashSet`1<string> ourWarnings;
    private HashSet`1<IValueDescriptor> myVisited;
    private List`1<IValueDescriptor> myPath;
    private int myCurrentCount;
    private static int ThrashHold;
    private TaskCompletionSource`1<Unit> myTcs;
    private static List`1<KeyValuePair`2<Func`2<IComponentDescriptor, bool>, CheckDelegate>> ourChecks;
    private UnwantedContainerDependenciesChecker(IEnumerable`1<IComponentDescriptor> componentDescriptors);
    private static UnwantedContainerDependenciesChecker();
    [AsyncStateMachineAttribute("JetBrains.Application.Components.UnwantedContainerDependenciesChecker/<GetWarningsAsync>d__11")]
public static Task`1<List`1<string>> GetWarningsAsync();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void CheckAsync(IContainerThreading threading, IEnumerable`1<IComponentDescriptor> descriptors);
    [AsyncStateMachineAttribute("JetBrains.Application.Components.UnwantedContainerDependenciesChecker/<DoCheckAsync>d__13")]
private static Task DoCheckAsync(IContainerThreading threading, IEnumerable`1<IComponentDescriptor> descriptors);
    [AsyncStateMachineAttribute("JetBrains.Application.Components.UnwantedContainerDependenciesChecker/<StartAsync>d__14")]
private Task StartAsync();
    [AsyncStateMachineAttribute("JetBrains.Application.Components.UnwantedContainerDependenciesChecker/<DoStartAsync>d__15")]
private Task DoStartAsync();
    private static bool CheckSystemLazyInjections(IValueDescriptor requester, IValueDescriptor request, String& message);
    private static bool CheckLazyPrimaryThreadInjectionInLazyBackgroundComponent(IValueDescriptor requester, IValueDescriptor request, String& message);
    private static bool CheckLazyInjectionInContainerAsyncComponent(IValueDescriptor requester, IValueDescriptor request, String& message);
    private static bool CheckLazyInjectionInContainerSyncComponent(IValueDescriptor requester, IValueDescriptor request, String& message);
    [AsyncStateMachineAttribute("JetBrains.Application.Components.UnwantedContainerDependenciesChecker/<CheckProhibitedDependenciesAsync>d__20")]
private Task CheckProhibitedDependenciesAsync(IValueDescriptor containerDescriptor, CheckDelegate check);
}
public class JetBrains.Application.Components.ValueDescriptorIdentifier : ValueType {
    public static ValueDescriptorIdentifier Other;
    [CanBeNullAttribute]
public string AssemblyQualifiedTypeName;
    public ValueDescriptorKind Kind;
    public ValueDescriptorIdentifier(ValueDescriptorKind kind, string assemblyQualifiedTypeName);
    private static ValueDescriptorIdentifier();
}
public enum JetBrains.Application.Components.ValueDescriptorKind : Enum {
    public int value__;
    public static ValueDescriptorKind AsyncLazy;
    public static ValueDescriptorKind ComponentWithAdditionalInitCtorPartCatalogType;
    public static ValueDescriptorKind ComponentWithAdditionalInitCtorSingletonType;
    public static ValueDescriptorKind ComponentWithAdditionalInitMethod;
    public static ValueDescriptorKind DelegatingComponentContainer;
    public static ValueDescriptorKind Enumerable;
    public static ValueDescriptorKind LazyImmutableList;
    public static ValueDescriptorKind Lifetime;
    public static ValueDescriptorKind Logger;
    public static ValueDescriptorKind NestedComponentContainer;
    public static ValueDescriptorKind NestedComponentContainerDictionary;
    public static ValueDescriptorKind Object;
    public static ValueDescriptorKind OnDemand;
    public static ValueDescriptorKind Optional;
    public static ValueDescriptorKind Other;
    public static ValueDescriptorKind PartCatalogType;
    public static ValueDescriptorKind PartCatalogTypeMember;
    public static ValueDescriptorKind PartMember;
    public static ValueDescriptorKind RemotableReferenceToExternal;
    public static ValueDescriptorKind RemotableReferenceToLocal;
    public static ValueDescriptorKind RuntimeMember;
    public static ValueDescriptorKind Serialized;
    public static ValueDescriptorKind SingletonFactory;
    public static ValueDescriptorKind SingletonType;
    public static ValueDescriptorKind SplittedComponentContainerService;
    public static ValueDescriptorKind Test;
    public static ValueDescriptorKind VsService;
}
[ExtensionAttribute]
public static class JetBrains.Application.Components.ValueDescriptorWithToStringDebugEx : object {
    [ExtensionAttribute]
public static string ToStringDebug(IValueDescriptor descriptor);
}
[ExtensionAttribute]
public static class JetBrains.Application.Components.ValueResolveContextEx : object {
    [ExtensionAttribute]
public static IValueDescriptor Resolve(IValueResolveContext context, Type request, ValueResolveFlags flags);
}
[FlagsAttribute]
public enum JetBrains.Application.Components.ValueResolveFlags : Enum {
    public int value__;
    public static ValueResolveFlags None;
    public static ValueResolveFlags Optional;
    public static ValueResolveFlags Lazy;
}
public class JetBrains.Application.Components.ValueResolveRequester : ValueType {
    private RequestOriginator myOriginator;
    [CanBeNullAttribute]
private IComponentDescriptor myRequestingComponent;
    private RequestRoute myRoute;
    public bool IsComponent { get; }
    public bool IsDynamic { get; }
    public RequestOriginator Originator { get; }
    public RequestRoute Route { get; }
    private ValueResolveRequester(IComponentDescriptor requestingcomponent, RequestOriginator originator, RequestRoute route);
    public bool get_IsComponent();
    public bool get_IsDynamic();
    public RequestOriginator get_Originator();
    public RequestRoute get_Route();
    public static ValueResolveRequester CreateDynamic(RequestRoute route);
    public static ValueResolveRequester CreateOnBehalfOfComponent(IComponentDescriptor component, RequestRoute route);
    public static ValueResolveRequester CreateUnidentified(RequestRoute route);
    [NotNullAttribute]
public IComponentDescriptor GetRequestingComponent();
    public virtual string ToString();
}
public static class JetBrains.Application.Extensibility.AppDomainPartCatalogAssembliesResolver : object {
    public static void Install(Lifetime lifetime, PartCatalog singlecatalog);
    public static void Install(Lifetime lifetime, IPartCatalogSet catalogset);
}
[ExtensionAttribute]
public static class JetBrains.Application.Extensibility.CatalogComponents : object {
    [ExtensionAttribute]
public static ComponentContainer RegisterCatalog(ComponentContainer container, IPartCatalogSet catalogSet, IPartSelector selector, IPartCatalogFilter[] filters);
    [ExtensionAttribute]
public static ComponentContainer RegisterCatalog(ComponentContainer container, IPartCatalogSet catalogSet, IPartSelector selector, Type catalogAttributeType, IPartCatalogFilter[] filters);
    [ExtensionAttribute]
public static IComponentContainer RegisterCatalog(ComponentContainer container, IPartCatalogSet catalogSet);
    [ExtensionAttribute]
public static ComponentContainer RegisterCatalog(ComponentContainer container, IPartCatalogSet catalogSet, IPartCatalogFilter[] filters);
    [ExtensionAttribute]
public static ComponentContainer RegisterCatalog(ComponentContainer container, IPartCatalogSet catalogSet, IPartSelector selector, IPartCatalogFilter[] filters);
}
public static class JetBrains.Application.Extensibility.CatalogComponentSource : object {
    [NotNullAttribute]
public static List`1<IComponentDescriptor> GetDescriptors(IComponentContainer container, IPartCatalogSet catalogset, IPartSelector selector, IEnumerable`1<IPartCatalogFilter> filters, Type catalogAttributeType, Func`5<IComponentContainer, PartCatalogType, Type, Instantiation, PartCatalogTypeComponentDescriptor> createTypeDescriptor, Func`5<IComponentContainer, PartCatalogTypeMember, Type, Instantiation, PartCatalogTypeMemberComponentDescriptor> createTypeMemberDescriptor);
    private static void TraceComponentSourceInitialParts_WhenOn(IComponentContainer container, List`1<IComponentDescriptor> descriptors, ILogger logger);
    private static void TraceComponentSourceParts(IComponentContainer container, List`1<IComponentDescriptor> descriptors);
}
[ExtensionAttribute]
internal static class JetBrains.Application.Extensibility.CatalogWithAdditionalInitOnAnotherThreadComponents : object {
    private static Type ourIComponentWithAdditionalInitOnPrimaryThreadType;
    private static Type ourIComponentWithAdditionalInitOnAnyThreadType;
    private static CatalogWithAdditionalInitOnAnotherThreadComponents();
    [ExtensionAttribute]
private static bool IsTypeOfComponentWithAdditionalInitOnAnotherThread(PartCatalogType part, Boolean& primaryThread, Boolean& anyThread);
    [ExtensionAttribute]
private static bool IsTypeOfComponentWithAdditionalInitOnAnotherThread(Type type, Boolean& primaryThread, Boolean& anyThread);
    [ExtensionAttribute]
public static bool IsTypeOfComponentWithAdditionalInitOnAnotherThread(Type type);
    private static ComponentProperties GetInitComponentProperties(ComponentProperties ctorProperties, bool primaryThread);
    public static bool TryGetDescriptors(PartCatalogType part, IComponentContainer container, Type catalogAttributeType, Instantiation defaultInstantiation, IComponentDescriptor& ctorDescriptor, IComponentDescriptor& initDescriptor1, IComponentDescriptor& initDescriptor2);
    [ExtensionAttribute]
public static ComponentContainer RegisterWithAdditionalInitOnOtherThread(ComponentContainer container, Type type, Instantiation instantiation);
    private static ICtorComponentDescriptor PrepareCtorAndRegistrations(PartCatalogType part, IComponentContainer container, Type catalogAttributeType, Instantiation defaultInstantiation, bool primaryThread, bool anyThread, AdditionalInitValueRegistration& registration1, AdditionalInitValueRegistration& registration2);
    private static ICtorComponentDescriptor PrepareCtorAndRegistrations(Type type, IComponentContainer container, Instantiation defaultInstantiation, bool primaryThread, bool anyThread, AdditionalInitValueRegistration& registration1, AdditionalInitValueRegistration& registration2);
    private static void PrepareInits(IComponentContainer container, ICtorComponentDescriptor ctor, AdditionalInitValueRegistration registration1, AdditionalInitValueRegistration registration2, IComponentDescriptor& init1, IComponentDescriptor& init2);
}
internal class JetBrains.Application.Extensibility.ComponentDescriptorFactory : object {
    [CompilerGeneratedAttribute]
private IComponentContainer <container>P;
    [CompilerGeneratedAttribute]
private Type <catalogAttributeType>P;
    [CompilerGeneratedAttribute]
private Instantiation <defaultInstantiation>P;
    [CompilerGeneratedAttribute]
private Func`5<IComponentContainer, PartCatalogType, Type, Instantiation, PartCatalogTypeComponentDescriptor> <createTypeDescriptor>P;
    public ComponentDescriptorFactory(IComponentContainer container, Type catalogAttributeType, Instantiation defaultInstantiation, Func`5<IComponentContainer, PartCatalogType, Type, Instantiation, PartCatalogTypeComponentDescriptor> createTypeDescriptor);
    [IteratorStateMachineAttribute("JetBrains.Application.Extensibility.ComponentDescriptorFactory/<GetPartCatalogTypeDescriptors>d__5")]
public IEnumerable`1<IComponentDescriptor> GetPartCatalogTypeDescriptors(PartCatalogType part);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Application.Extensibility.FeaturePartsExtensions : object {
    [IteratorStateMachineAttribute("JetBrains.Application.Extensibility.FeaturePartsExtensions/<FilterOverriddenComponents>d__0`1")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<TFeaturePart> FilterOverriddenComponents(IList`1<TFeaturePart> components);
    [IteratorStateMachineAttribute("JetBrains.Application.Extensibility.FeaturePartsExtensions/<FilterOverriddenComponents>d__1`2")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<TObj> FilterOverriddenComponents(IList`1<TObj> components, Func`2<TObj, TFactory> getFactory, Func`3<TObj, TObj, bool> applyFilterCondition);
    [IteratorStateMachineAttribute("JetBrains.Application.Extensibility.FeaturePartsExtensions/<FilterFactoryPattern>d__2`2")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<TResultPart> FilterFactoryPattern(IEnumerable`1<TFeatureFactory> componentsEnumerable, Func`2<TFeatureFactory, TResultPart> creator);
    private static Nullable`1<int> TestInherits(TFeatureFactory f1, TFeatureFactory f2, Dictionary`2<Type, TFeatureFactory> map);
}
public interface JetBrains.Application.Extensibility.IComponentWithAdditionalInitOnAnyThread {
    public abstract virtual void InitOnAnyThread();
}
public interface JetBrains.Application.Extensibility.IComponentWithAdditionalInitOnPrimaryThread {
    public abstract virtual void InitOnPrimaryThread();
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("4")]
public class JetBrains.Application.Extensibility.InterruptableActivationAttribute : PartAttribute {
}
public interface JetBrains.Application.Extensibility.IPartCatalogTypeComponentDescriptor {
    public PartCatalogType Part { get; }
    public abstract virtual PartCatalogType get_Part();
}
public class JetBrains.Application.Extensibility.PartCatalogTypeComponentDescriptor : SingletonDescriptor`1<ConstructiorBindigns> {
    private static StringSource ourAutocreateWithNameNoGenericArgs;
    [CompilerGeneratedAttribute]
private PartCatalogType <Part>k__BackingField;
    [CompilerGeneratedAttribute]
private ComponentProperties <Properties>k__BackingField;
    public PartCatalogType Part { get; }
    public ComponentProperties Properties { get; }
    protected ValueDescriptorIdentifier UsageStatisticsId { get; }
    protected bool IsComponentWithInterruptableActivation { get; }
    [ObsoleteAttribute("Use an overload with instantiation", "True")]
public PartCatalogTypeComponentDescriptor(IComponentContainer container, PartCatalogType part, Type attributeType);
    public PartCatalogTypeComponentDescriptor(IComponentContainer container, PartCatalogType part, Type attributeType, Instantiation defaultInstantiation);
    private static PartCatalogTypeComponentDescriptor();
    [CompilerGeneratedAttribute]
public sealed virtual PartCatalogType get_Part();
    [CompilerGeneratedAttribute]
public virtual ComponentProperties get_Properties();
    [IteratorStateMachineAttribute("JetBrains.Application.Extensibility.PartCatalogTypeComponentDescriptor/<GetRegistrations>d__9")]
public virtual IEnumerable`1<IValueRegistration> GetRegistrations();
    protected virtual IEnumerable`1<KeyValuePair`2<string, Func`1<object>>> GetExceptionData();
    protected virtual ValueDescriptorIdentifier get_UsageStatisticsId();
    protected virtual string Present();
    protected virtual string PresentDebug();
    protected virtual object DoCreateInstance(ConstructiorBindigns bindings, Object[] dependencies);
    protected virtual ConstructiorBindigns GetEmptyDependencies();
    protected virtual ConstructiorBindigns DoGetDependenciesNoCache();
    protected virtual bool get_IsComponentWithInterruptableActivation();
    [PureAttribute]
public ComponentProperties GetComponentProperties(PartCatalogType part, Type typeAttrBase, Instantiation defaultInstantiation);
    [PureAttribute]
internal static ComponentProperties GetComponentProperties(T type, PartCatalogType partCatalogType, Type typeAttrBase, CollectionSource`1<PartCatalogAttribute> partAttributes, Instantiation defaultInstantiation);
    [CompilerGeneratedAttribute]
private object <GetExceptionData>b__10_0();
}
public class JetBrains.Application.Extensibility.PartCatalogTypeComponentDescriptorComparer : object {
    public static PartCatalogTypeComponentDescriptorComparer Instance;
    private static PartCatalogTypeComponentDescriptorComparer();
    public sealed virtual int Compare(IPartCatalogTypeComponentDescriptor x, IPartCatalogTypeComponentDescriptor y);
}
internal class JetBrains.Application.Extensibility.PartCatalogTypeComponentRegistration : object {
    private int myHashCode;
    private PartCatalogType myType;
    public PartCatalogType Type { get; }
    private string JetBrains.Application.Components.IValueRegistration.TypeAssemblyQualifiedName { get; }
    public PartCatalogTypeComponentRegistration(PartCatalogType type);
    public PartCatalogType get_Type();
    public sealed virtual bool Accepts(object request);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private bool Equals(PartCatalogTypeComponentRegistration other);
    public virtual string ToString();
    private sealed virtual override string JetBrains.Application.Components.IValueRegistration.get_TypeAssemblyQualifiedName();
}
public class JetBrains.Application.Extensibility.PartCatalogTypeMemberComponentDescriptor : SingletonDescriptor`1<MethodBindigns> {
    [CompilerGeneratedAttribute]
private PartCatalogTypeMember <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private ComponentProperties <Properties>k__BackingField;
    public PartCatalogTypeMember Member { get; }
    public PartCatalogType Part { get; }
    public ComponentProperties Properties { get; }
    protected ValueDescriptorIdentifier UsageStatisticsId { get; }
    protected bool IsComponentWithInterruptableActivation { get; }
    private PartCatalogTypeMemberComponentDescriptor(IComponentContainer container, PartCatalogTypeMember member, ComponentProperties properties);
    public PartCatalogTypeMemberComponentDescriptor(IComponentContainer container, PartCatalogTypeMember member, Type catalogAttributeType, Instantiation defaultInstantiation);
    [CompilerGeneratedAttribute]
public PartCatalogTypeMember get_Member();
    public sealed virtual PartCatalogType get_Part();
    [CompilerGeneratedAttribute]
public virtual ComponentProperties get_Properties();
    [IteratorStateMachineAttribute("JetBrains.Application.Extensibility.PartCatalogTypeMemberComponentDescriptor/<GetRegistrations>d__10")]
public virtual IEnumerable`1<IValueRegistration> GetRegistrations();
    protected virtual string Present();
    protected virtual ValueDescriptorIdentifier get_UsageStatisticsId();
    protected virtual object DoCreateInstance(MethodBindigns bindings, Object[] dependencies);
    protected virtual MethodBindigns GetEmptyDependencies();
    protected virtual MethodBindigns DoGetDependenciesNoCache();
    protected virtual bool get_IsComponentWithInterruptableActivation();
    [PureAttribute]
private static ComponentProperties GetComponentProperties(PartCatalogTypeMember partMember, Type typeAttrBase, Instantiation defaultInstantiation);
}
internal class JetBrains.Application.Extensibility.PartComponentRegistration : object {
    [NotNullAttribute]
private PartCatalogueType myType;
    private int myHashCode;
    [NotNullAttribute]
public PartCatalogueType Type { get; }
    private string JetBrains.Application.Components.IValueRegistration.TypeAssemblyQualifiedName { get; }
    public PartComponentRegistration(PartCatalogueType type);
    public PartCatalogueType get_Type();
    private bool Equals(PartComponentRegistration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Accepts(object request);
    private sealed virtual override string JetBrains.Application.Components.IValueRegistration.get_TypeAssemblyQualifiedName();
}
public class JetBrains.Application.Extensibility.PartMemberComponentDescriptor : SingletonDescriptor`1<MethodBindigns> {
    [CompilerGeneratedAttribute]
private PartCatalogueType <Part>k__BackingField;
    [CompilerGeneratedAttribute]
private PartCatalogueTypeMember <Member>k__BackingField;
    [NotNullAttribute]
public PartCatalogueType Part { get; }
    [NotNullAttribute]
public PartCatalogueTypeMember Member { get; }
    public ComponentProperties Properties { get; }
    protected ValueDescriptorIdentifier UsageStatisticsId { get; }
    public PartMemberComponentDescriptor(IComponentContainer container, PartCatalogueType part, PartCatalogueTypeMember member);
    [CompilerGeneratedAttribute]
public PartCatalogueType get_Part();
    [CompilerGeneratedAttribute]
public PartCatalogueTypeMember get_Member();
    public virtual ComponentProperties get_Properties();
    [IteratorStateMachineAttribute("JetBrains.Application.Extensibility.PartMemberComponentDescriptor/<GetRegistrations>d__9")]
public virtual IEnumerable`1<IValueRegistration> GetRegistrations();
    protected virtual object DoCreateInstance(MethodBindigns bindings, Object[] dependencies);
    protected virtual MethodBindigns GetEmptyDependencies();
    protected virtual MethodBindigns DoGetDependenciesNoCache();
    protected virtual string Present();
    protected virtual ValueDescriptorIdentifier get_UsageStatisticsId();
}
public static class JetBrains.Application.Extensibility.Reflection.CodeDomCatalogEx : object {
    [NotNullAttribute]
public static CodeTypeReference MakeTypeReference(PartCatalogType type, CodeDomAssemblyReferences refs);
}
public class JetBrains.Application.Extensibility.SplittedComponentContainer`2 : SplittedComponentContainerChecked {
    private string myAttributeArgumentName;
    [CanBeNullAttribute]
private Dictionary`2<TDefinition, Lazy`1<IComponentContainer>> myContainers;
    [CanBeNullAttribute]
private Dictionary`2<Type, Lazy`1<IComponentContainer>> myContainersByType;
    private OneToSetMap`2<TDefinition, PartCatalogType> myDefinitionsToParts;
    public SplittedComponentContainer`2(Lifetime lifetime, IPartCatalogSet catalogSet, IComponentContainer parentContainer, IEnumerable`1<TDefinition> definitions, Expression`1<Func`2<TDefinitionAttribute, Type>> propertyExpression);
    [AsyncStateMachineAttribute("JetBrains.Application.Extensibility.SplittedComponentContainer`2/<WarmUpAsync>d__5")]
private Task WarmUpAsync(Lifetime lifetime, IContainerThreading threading, IPartCatalogSet catalogSet);
    private IComponentContainer InitializeDefinition(Lifetime lifetime, TDefinition definition, IPartCatalogSet catalogSet, IComponentContainer parentContainer);
    private IComponentContainer GetContainer();
    [CanBeNullAttribute]
private IComponentContainer TryGetContainer();
    [NotNullAttribute]
[PureAttribute]
public T GetService();
    [CanBeNullAttribute]
[PureAttribute]
public T TryGetService();
    [CanBeNullAttribute]
[PureAttribute]
internal IValueDescriptor TryGetServiceDescriptor();
    private IComponentContainer GetContainer(TDefinition definition);
    [NotNullAttribute]
[PureAttribute]
public T GetService(TDefinition definition);
    [CanBeNullAttribute]
[PureAttribute]
public T TryGetService(TDefinition definition);
    [IteratorStateMachineAttribute("JetBrains.Application.Extensibility.SplittedComponentContainer`2/<GetServices>d__15`1")]
[NotNullAttribute]
[PureAttribute]
public IEnumerable`1<Pair`2<TDefinition, T>> GetServices();
    [NotNullAttribute]
[PureAttribute]
public IReadyImmutableList`1<T> GetServices(TDefinition definition);
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<T> GetServicesFromAll();
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<Pair`2<TDefinition, IReadyImmutableList`1<T>>> GetMultipleServices();
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<T> GetMultipleServicesFromAll();
    [PureAttribute]
public bool HasService(TDefinition definition);
    private OneToSetMap`2<TDefinition, PartCatalogType> EnsureDefinitionsToParts(IPartCatalogSet catalogSet);
    private void EnsureDefinitionsToPartsNoLock(IPartCatalogSet catalogSet);
    [NotNullAttribute]
public static HashSet`1<StringSource> GetDefinitionAssignableToTypeNames(Type definitionType);
    [NotNullAttribute]
private Dictionary`2<Type, Lazy`1<IComponentContainer>> GetContainersByTypeOrThrow();
    [NotNullAttribute]
private Dictionary`2<TDefinition, Lazy`1<IComponentContainer>> GetContainersOrThrow();
    private ObjectDisposedException DisposedException();
    [NotNullAttribute]
[PureAttribute]
protected T GetServiceChecked();
    [NotNullAttribute]
[PureAttribute]
protected T GetServiceChecked(TDefinition definition);
    [CompilerGeneratedAttribute]
private Pair`2<TDefinition, IReadyImmutableList`1<T>> <GetMultipleServices>b__18_0(TDefinition definition);
}
public abstract class JetBrains.Application.Extensibility.SplittedComponentContainerChecked : object {
    protected static ISet`1<string> Whitelist;
    private static SplittedComponentContainerChecked();
}
[ObsoleteAttribute("This should rather not be used because (a) it uses the viewable concept while the list of types is actually static; (b) it eagerly binds all of the types and loads all of the assemblies.")]
public class JetBrains.Application.Extensibility.TypesInstantiator`2 : object {
    private Dictionary`2<T, Type> myTypeMap;
    private Dictionary`2<T, IEnumerable`1<TAttribute>> myAttrsCache;
    private ISorter`1<T> mySorter;
    private ViewableCollection`1<T> myInstances;
    private ICollection`1<T> mySortedInstances;
    private IEnumerable`1<T> SortedInstances { get; }
    public TypesInstantiator`2(Lifetime lifetime, IPartCatalogSet catalogueSet, ISorter`1<T> sorter);
    public sealed virtual void View(Lifetime lifetime, Action`2<Lifetime, T> viewer);
    public void View(Lifetime lifetime, Action`3<Lifetime, T, TAttribute> viewer);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private void AddParts(Lifetime lifetime, PartCatalog catalogue);
    private IEnumerable`1<T> get_SortedInstances();
    private IEnumerable`1<TAttribute> GetAttributes(T instance);
    [NotNullAttribute]
private TAttribute GetAttribute(T instance);
}
public class JetBrains.Application.Extensibility.TypeView`1 : object {
    [NotNullAttribute]
private Dictionary`2<Type, TAttribute> myAttrsCache;
    [NotNullAttribute]
private IPartCatalogSet myCatalogset;
    private Lifetime myLifetime;
    [CanBeNullAttribute]
private List`1<Type> myTypesCache;
    [NotNullAttribute]
public IReadOnlyCollection`1<Type> AllTypes { get; }
    private int System.Collections.Generic.IReadOnlyCollection<System.Type>.Count { get; }
    public TypeView`1(Lifetime lifetime, IPartCatalogSet catalogset);
    public IReadOnlyCollection`1<Type> get_AllTypes();
    [NotNullAttribute]
public TAttribute GetAttribute(Type type);
    [ObsoleteAttribute("The types collection is static, use the AllTypes collection instead of the viewer.")]
public sealed virtual void View(Lifetime lifetime, Action`2<Lifetime, Type> viewer);
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<System.Type>.get_Count();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<Type> System.Collections.Generic.IEnumerable<System.Type>.GetEnumerator();
    private List`1<Type> CreateTypes();
}
public class JetBrains.Application.Parts.AssemblyBinderOnMaster : object {
    [NotNullAttribute]
public AssemblyNameInfo Assembly;
    [NotNullAttribute]
public IAssemblyMasterBinder Master;
    private AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.AssemblyName { get; }
    public AssemblyBinderOnMaster(AssemblyNameInfo assembly, IAssemblyMasterBinder master);
    private sealed virtual override AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.get_AssemblyName();
    private sealed virtual override IMetadataAssembly JetBrains.Application.Bindings.IAssemblyBinder.BindToMetadataAssembly(Lifetime lifetime, OnError onerror);
    private sealed virtual override Assembly JetBrains.Application.Bindings.IAssemblyBinder.BindToRuntimeAssembly(OnError onerror);
    private sealed virtual override Stream JetBrains.Application.Bindings.IAssemblyBinder.BindToStream(Lifetime lifetime, OnError onerror);
    private sealed virtual override FileSystemPath JetBrains.Application.Bindings.IAssemblyBinder.BindToDiskPath(OnError onerror);
}
public class JetBrains.Application.Parts.ByteAscComparer : object {
    public sealed virtual int Compare(byte x, byte y);
}
public class JetBrains.Application.Parts.ByteDescComparer : object {
    public sealed virtual int Compare(byte x, byte y);
}
public class JetBrains.Application.Parts.ClassOrMemberWithPartAttributePassFilter : object {
    private sealed virtual override bool JetBrains.Application.Parts.IMetadataPartsPassFilter.IsPart(IMetadataTypeInfo typedecl);
}
public class JetBrains.Application.Parts.ClassWithPartAttributePassFilter : object {
    private sealed virtual override bool JetBrains.Application.Parts.IMetadataPartsPassFilter.IsPart(IMetadataTypeInfo typedecl);
}
[AttributeUsageAttribute("68")]
[MeansImplicitUseAttribute("8")]
[ComponentInstantiationAttribute("-32758")]
public class JetBrains.Application.Parts.ComponentAttribute : PartAttribute {
    protected static Instantiation ComponentDefaultUnspecifiedInstantiation;
    public ComponentProperties Properties;
    public ComponentAttribute(Instantiation instantiation);
}
[AttributeUsageAttribute("4")]
[BaseTypeRequiredAttribute("JetBrains.Application.Parts.ComponentAttribute")]
public class JetBrains.Application.Parts.ComponentInstantiationAttribute : PartAttribute {
    [CompilerGeneratedAttribute]
private Instantiation <Instantiation>k__BackingField;
    public Instantiation Instantiation { get; }
    public ComponentInstantiationAttribute(Instantiation instantiation);
    [CompilerGeneratedAttribute]
public Instantiation get_Instantiation();
}
[IsReadOnlyAttribute]
public class JetBrains.Application.Parts.ComponentProperties : ValueType {
    public Instantiation Instantiation;
    [ObsoleteAttribute("Do not use", "True")]
public static ComponentProperties Default { get; }
    public static ComponentProperties FreeAsyncAccessOnlyUnsafe { get; }
    public static ComponentProperties FreeUnsafe { get; }
    public static ComponentProperties FreeSafe { get; }
    public bool IsDeadlockSafe { get; }
    public bool IsAsyncAccessOnly { get; }
    public ComponentProperties(Instantiation instantiation);
    public static ComponentProperties get_Default();
    public static ComponentProperties get_FreeAsyncAccessOnlyUnsafe();
    public static ComponentProperties get_FreeUnsafe();
    public static ComponentProperties get_FreeSafe();
    public bool get_IsDeadlockSafe();
    public bool get_IsAsyncAccessOnly();
    public static ComponentProperties FromAttribute(PartCatalogType sourceType, PartCatalogAttribute pca, Instantiation defaultInstantiation);
    private static ComponentProperties Read(PartCatalogType sourceType, PartCatalogAttribute pca, Instantiation instantiation);
    public virtual string ToString();
    public void AssertValid();
    private static void AssertValue(Instantiation instantiation);
    private static int CountBits(Instantiation value);
    public bool Equals(ComponentProperties other);
}
public class JetBrains.Application.Parts.CompositePartsCatalogue : object {
    private IList`1<IPartsCatalogue> myCatalogues;
    public CompositePartsCatalogue(IEnumerable`1<IPartsCatalogue> catalogues);
    public sealed virtual IEnumerable`1<PartCatalogueAssembly> GetAssemblies();
    public virtual IEnumerable`1<PartCatalogueType> GetParts();
}
[AttributeUsageAttribute("1028")]
public class JetBrains.Application.Parts.DerivedComponentsInstantiationRequirementAttribute : PartAttribute {
    [CompilerGeneratedAttribute]
private InstantiationRequirement <Requirement>k__BackingField;
    public InstantiationRequirement Requirement { get; }
    public DerivedComponentsInstantiationRequirementAttribute(InstantiationRequirement requirement);
    [CompilerGeneratedAttribute]
public InstantiationRequirement get_Requirement();
}
public class JetBrains.Application.Parts.DoubleAscComparer : object {
    public sealed virtual int Compare(double x, double y);
}
public class JetBrains.Application.Parts.DoubleDescComparer : object {
    public sealed virtual int Compare(double x, double y);
}
[ObsoleteAttribute("Use a master binder.")]
public class JetBrains.Application.Parts.FileBasedAssemblyBinder : object {
    [NotNullAttribute]
private IList`1<FileSystemPath> myAdditionalPaths;
    private AssemblyNameInfo myAssemblyName;
    [CanBeNullAttribute]
private Func`2<Lifetime, IAssemblyResolver> myFCreateAdditionalResolvers;
    private RuntimeResolverOption myRuntimeResolverOption;
    [NotNullAttribute]
public FileSystemPath Location;
    private AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.AssemblyName { get; }
    public FileBasedAssemblyBinder(FileSystemPath location, IList`1<FileSystemPath> additionalPaths, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, AssemblyNameInfo assemblynameIfKnown, RuntimeResolverOption runtimeResolverOption);
    private sealed virtual override AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.get_AssemblyName();
    private sealed virtual override FileSystemPath JetBrains.Application.Bindings.IAssemblyBinder.BindToDiskPath(OnError onerror);
    private sealed virtual override IMetadataAssembly JetBrains.Application.Bindings.IAssemblyBinder.BindToMetadataAssembly(Lifetime lifetime, OnError onerror);
    private sealed virtual override Assembly JetBrains.Application.Bindings.IAssemblyBinder.BindToRuntimeAssembly(OnError onerror);
    private sealed virtual override Stream JetBrains.Application.Bindings.IAssemblyBinder.BindToStream(Lifetime lifetime, OnError onerror);
}
public class JetBrains.Application.Parts.FlyweightPartFactory : object {
    private Dictionary`2<Pair`2<string, PartCatalogueAssembly>, PartCatalogueType> myTypes;
    private Dictionary`2<Pair`2<AssemblyNameInfo, FileSystemPath>, PartCatalogueAssembly> myAssemblies;
    private DataIntern`1<string> myStrings;
    private sealed virtual override PartCatalogueAttribute JetBrains.Application.Parts.IPartCatalogueFactory.CreateAttribute(PartCatalogueType type, IEnumerable`1<PartCatalogueAttributeProperty> properties, PartCatalogueType[] ctorparams);
    private sealed virtual override bool JetBrains.Application.Parts.IPartCatalogueFactory.GetOrCreateAssembly(AssemblyNameInfo assemblyName, FileSystemPath location, PartCatalogueAssembly& assembly);
    private sealed virtual override bool JetBrains.Application.Parts.IPartCatalogueFactory.GetOrCreateType(string fullName, PartCatalogTypeKind kind, PartCatalogueAssembly assembly, PartCatalogueType& type);
    [CompilerGeneratedAttribute]
private PartCatalogueAttributeProperty <JetBrains.Application.Parts.IPartCatalogueFactory.CreateAttribute>b__3_0(PartCatalogueAttributeProperty property);
}
public interface JetBrains.Application.Parts.IAttributedPartsCatalogue {
    public abstract virtual IEnumerable`1<PartCatalogueType> GetParts(Type attributeType);
}
public interface JetBrains.Application.Parts.IComponentWithAscDoublePriorityAttribute {
}
public interface JetBrains.Application.Parts.IComponentWithAscIntPriorityAttribute {
}
public interface JetBrains.Application.Parts.IComponentWithDescDoublePriorityAttribute {
}
public interface JetBrains.Application.Parts.IComponentWithDescIntPriorityAttribute {
}
public interface JetBrains.Application.Parts.IComponentWithPriorityAttribute {
}
public interface JetBrains.Application.Parts.IComponentWithPriorityAttribute`2 {
    public TPriority Priority { get; }
    public abstract virtual TPriority get_Priority();
}
public interface JetBrains.Application.Parts.IMetadataPartsPassFilter {
    public abstract virtual bool IsPart(IMetadataTypeInfo typedecl);
}
[FlagsAttribute]
public enum JetBrains.Application.Parts.Instantiation : Enum {
    public short value__;
    public static Instantiation ContainerSyncPrimaryThread;
    public static Instantiation ContainerAsyncPrimaryThread;
    public static Instantiation ContainerAsyncAnyThreadUnsafe;
    [ObsoleteAttribute("Use ContainerAsyncAnyThreadUnsafe")]
public static Instantiation ContainerAsyncAnyThread;
    public static Instantiation PreCreateToBeDeadlockSafeForChainedContainers;
    public static Instantiation ContainerAsyncAnyThreadSafe;
    public static Instantiation LaterAsyncOnlyPrimaryThread;
    public static Instantiation LaterAsyncAnyThreadUnsafe;
    public static Instantiation LaterAsyncAnyThreadSafe;
    public static Instantiation LaterAsyncOnlyAnyThreadUnsafe;
    public static Instantiation DemandAsyncOnlyPrimaryThread;
    public static Instantiation DemandAsyncOnlyAnyThreadUnsafe;
    public static Instantiation DemandAnyThreadUnsafe;
    [ObsoleteAttribute("Use DemandAnyThreadUnsafe")]
public static Instantiation DemandAnyThread;
    public static Instantiation DemandAnyThreadSafe;
    public static Instantiation Service;
}
[ExtensionAttribute]
public static class JetBrains.Application.Parts.InstantiationEx : object {
    public static Instantiation Default;
    public static Instantiation LegacyDefault;
    public static Instantiation TmpDefault;
    public static Instantiation UnspecifiedDefault;
    public static Instantiation UnspecifiedDemandAnyThreadUnsafe;
    public static Instantiation DemandAnyThreadUnsafeBecauseOfRunningAvaloniaWindowsList;
    public static Instantiation LifecycleMask;
    [ExtensionAttribute]
private static bool ContainsAllBits(Instantiation value, Instantiation flag);
    [ExtensionAttribute]
public static bool ContainsAnyBit(Instantiation value, InstantiationRaw flag);
    [ExtensionAttribute]
public static bool ContainsAllBits(Instantiation value, InstantiationRaw flag);
    [ExtensionAttribute]
public static bool IsContainerSync(Instantiation value);
    [ExtensionAttribute]
public static bool IsContainerAsync(Instantiation value);
    [ExtensionAttribute]
public static bool IsContainerSyncOrAsync(Instantiation value);
    [ExtensionAttribute]
public static bool IsDemand(Instantiation value);
    [ExtensionAttribute]
public static bool IsPrimaryThread(Instantiation value);
    [ExtensionAttribute]
public static bool IsAnyThread(Instantiation value);
    [ExtensionAttribute]
public static bool IsLaterAsync(Instantiation value);
    [ExtensionAttribute]
public static bool IsDeadlockSafe(Instantiation value);
    [ExtensionAttribute]
public static bool IsAsyncAccessOnly(Instantiation value);
    [ExtensionAttribute]
public static bool IsService(Instantiation value);
    [ExtensionAttribute]
public static string Present(Instantiation instantiation);
    [CompilerGeneratedAttribute]
internal static string <Present>g__GetName|20_0(Instantiation i);
}
[FlagsAttribute]
public enum JetBrains.Application.Parts.InstantiationRaw : Enum {
    public short value__;
    public static InstantiationRaw None;
    public static InstantiationRaw Sync;
    public static InstantiationRaw Async;
    public static InstantiationRaw LaterAsync;
    public static InstantiationRaw PrimaryThread;
    public static InstantiationRaw AnyThreadDependenciesOnly;
    public static InstantiationRaw AsyncAccessOnly;
    public static InstantiationRaw SuperStar;
    public static InstantiationRaw Service;
    public static InstantiationRaw MegaStar;
    public static InstantiationRaw Unspecified;
}
[FlagsAttribute]
public enum JetBrains.Application.Parts.InstantiationRequirement : Enum {
    public int value__;
    public static InstantiationRequirement None;
    public static InstantiationRequirement DeadlockSafe;
    public static InstantiationRequirement SyncAccessible;
}
[ExtensionAttribute]
public static class JetBrains.Application.Parts.InstantiationRequirementEx : object {
    [ExtensionAttribute]
public static bool IsDeadlockSafe(InstantiationRequirement requirement);
    [ExtensionAttribute]
public static bool IsSyncAccessible(InstantiationRequirement requirement);
}
public class JetBrains.Application.Parts.IntAscComparer : object {
    public sealed virtual int Compare(int x, int y);
}
public class JetBrains.Application.Parts.IntDescComparer : object {
    public sealed virtual int Compare(int x, int y);
}
public interface JetBrains.Application.Parts.IPartCatalogueFactory {
    [NotNullAttribute]
public abstract virtual PartCatalogueAttribute CreateAttribute(PartCatalogueType type, IEnumerable`1<PartCatalogueAttributeProperty> properties, PartCatalogueType[] ctorparams);
    public abstract virtual bool GetOrCreateAssembly(AssemblyNameInfo assemblyName, FileSystemPath location, PartCatalogueAssembly& assembly);
    public abstract virtual bool GetOrCreateType(string fullName, PartCatalogTypeKind kind, PartCatalogueAssembly assembly, PartCatalogueType& type);
}
public interface JetBrains.Application.Parts.IPartsCatalogue {
    public abstract virtual IEnumerable`1<PartCatalogueAssembly> GetAssemblies();
    public abstract virtual IEnumerable`1<PartCatalogueType> GetParts();
}
[AttributeUsageAttribute("32767")]
[MeansImplicitUseAttribute]
public abstract class JetBrains.Application.Parts.PartAttribute : Attribute {
}
[ExtensionAttribute]
public static class JetBrains.Application.Parts.PartCatalogEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<TAttributeType> GetPartAttributeInstancesFromAllAssemblies(PartCatalog thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<TAttributeType> GetPartAttributeInstancesFromAssemblies(PartCatalog thіs, Func`2<PartCatalogAssembly, bool> filter);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<AssemblyAttribute`1<TAttributeType>> GetPartAttributesFromAllAssemblies(PartCatalog thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<TypeAttribute`1<TAttributeType>> GetPartsWithSingleAttribute(IEnumerable`1<PartCatalog> thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<TypeAttribute`1<TAttributeType>> GetPartsWithSingleAttribute(IPartCatalogSet thіs);
    [ExtensionAttribute]
public static IEnumerable`1<TypeAttribute`1<TAttributeType>> GetPartsWithSingleAttribute(PartCatalog thіs);
}
public class JetBrains.Application.Parts.PartCatalogueAssembly : object {
    [NotNullAttribute]
private AssemblyNameInfo myAssemblyName;
    [CanBeNullAttribute]
private FileSystemPath myLocation;
    [CompilerGeneratedAttribute]
private IAssemblyBinder <Binder>k__BackingField;
    private List`1<PartCatalogueAttribute> myAttributes;
    private Assembly myLoadedAssembly;
    [CanBeNullAttribute]
public IAssemblyBinder Binder { get; public set; }
    [NotNullAttribute]
public AssemblyNameInfo AssemblyName { get; }
    [CanBeNullAttribute]
public FileSystemPath Location { get; }
    public PartCatalogueAssembly(AssemblyNameInfo assemblyName, FileSystemPath location);
    [CompilerGeneratedAttribute]
public IAssemblyBinder get_Binder();
    [CompilerGeneratedAttribute]
public void set_Binder(IAssemblyBinder value);
    public AssemblyNameInfo get_AssemblyName();
    public FileSystemPath get_Location();
    [NotNullAttribute]
public Assembly Bind();
    public void AssignAttributes(IEnumerable`1<PartCatalogueAttribute> attributes);
    public IEnumerable`1<PartCatalogueAttribute> GetAttributes(Type attributeType);
    public IEnumerable`1<PartCatalogueAttribute> GetAttributes();
    public IEnumerable`1<PartCatalogueAttribute> GetAttributes();
    public sealed virtual bool Equals(PartCatalogueAssembly other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PartCatalogueAssembly left, PartCatalogueAssembly right);
    public static bool op_Inequality(PartCatalogueAssembly left, PartCatalogueAssembly right);
    public virtual string ToString();
}
public class JetBrains.Application.Parts.PartCatalogueAttribute : object {
    [NotNullAttribute]
public PartCatalogueType Type;
    [CanBeNullAttribute]
public PartCatalogueType[] ConstructorFormalParameterTypes;
    private Dictionary`2<string, PartCatalogueAttributeProperty> myProperties;
    public PartCatalogueAttribute(PartCatalogueType type, IEnumerable`1<PartCatalogueAttributeProperty> properties, PartCatalogueType[] ctorparams);
    private static string GetMemberName(Expression`1<Func`2<TSource, TValue>> expression);
    [CanBeNullAttribute]
public TValue TryGetProperty(string name);
    public bool TryGetProperty(string name, T& value);
    public bool TryGetProperty(Expression`1<Func`2<TSource, TValue>> expression, TConvertedValue& value);
    public bool TryGetProperty(Expression`1<Func`2<TSource, TValue>> expression, TValue& value);
    [CanBeNullAttribute]
public TValue TryGetProperty(Expression`1<Func`2<TSource, TValue>> expression);
    public T GetProperty(string name);
    public TConvertedValue GetProperty(Expression`1<Func`2<TSource, TValue>> expression);
    public TValue GetProperty(Expression`1<Func`2<TSource, TValue>> expression);
    public T GetPropertyOrDefault(string name, T defaultValue);
    public TConvertedValue GetPropertyOrDefault(Expression`1<Func`2<TSource, TValue>> expression, TConvertedValue defaultValue);
    public TValue GetPropertyOrDefault(Expression`1<Func`2<TSource, TValue>> expression, TValue defaultValue);
    public object GetProperty(string name);
    public ICollection`1<PartCatalogueAttributeProperty> GetProperties();
    public object GetInstance(OnError onerror);
    public bool Equals(PartCatalogueAttribute other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public static class JetBrains.Application.Parts.PartCatalogueAttributeInstanceFactory : object {
    private static ConcurrentDictionary`2<AttributeCtorInvocationKey, AttributeCtorInvocation> myCacheInvocations;
    private static PartCatalogueAttributeInstanceFactory();
    public static object CreateInstance(PartCatalogueType typeAttr, PartCatalogueType[] constructorFormalParameterTypes, IDictionary`2<string, PartCatalogueAttributeProperty> properties, OnError onerror);
}
public class JetBrains.Application.Parts.PartCatalogueAttributeProperty : object {
    [CompilerGeneratedAttribute]
private PartCatalogAttributeArgumentDisposition <Disposition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public PartCatalogAttributeArgumentDisposition Disposition { get; }
    [NotNullAttribute]
public string Name { get; private set; }
    [CanBeNullAttribute]
public object Value { get; private set; }
    public PartCatalogueAttributeProperty(string name, object value, PartCatalogAttributeArgumentDisposition disposition);
    [CompilerGeneratedAttribute]
public PartCatalogAttributeArgumentDisposition get_Disposition();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    public bool Equals(PartCatalogueAttributeProperty other);
    public void Intern(DataIntern`1<string> strings);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Application.Parts.PartCatalogueType : object {
    private Pair`2<string, string> myNamePieces;
    private PartCatalogueAssembly myAssembly;
    private PartCatalogueTypesCollection myBaseTypes;
    private PartCatalogueTypesCollection myExtraTypes;
    private PartCatalogueAttribute[] myAttributes;
    private PartCatalogueTypeMember[] myMembers;
    private Type myBoundType;
    private string myCachedLocalName;
    private PartCatalogTypeKind myKind;
    public PartCatalogueTypesCollection BaseTypes { get; }
    public Pair`2<string, string> NamePieces { get; }
    public string FullName { get; }
    public string LocalName { get; }
    public string AssemblyQualifiedName { get; }
    public PartCatalogueAssembly Assembly { get; }
    public bool IsGenericTypeSpecialization { get; }
    public bool IsGenericTypeDeclaraion { get; }
    public bool IsArray { get; }
    public bool IsReference { get; }
    public PartCatalogTypeKind Kind { get; }
    public PartCatalogueTypesCollection ExtraTypes { get; }
    public PartCatalogueType(Pair`2<string, string> pairOfNamePieces, PartCatalogTypeKind kind, PartCatalogueAssembly assembly);
    public PartCatalogueTypesCollection get_BaseTypes();
    public PartCatalogueTypesCollection GetGenericActualParameters();
    public Pair`2<string, string> get_NamePieces();
    public string get_FullName();
    public string get_LocalName();
    public string get_AssemblyQualifiedName();
    public PartCatalogueAssembly get_Assembly();
    public bool get_IsGenericTypeSpecialization();
    public bool get_IsGenericTypeDeclaraion();
    public bool get_IsArray();
    public bool get_IsReference();
    public PartCatalogTypeKind get_Kind();
    public PartCatalogueTypesCollection get_ExtraTypes();
    [NotNullAttribute]
public string GetGenericTypeDeclarationFullName();
    public void AssignRecursiveTypes(RecursiveData data);
    public IEnumerable`1<PartCatalogueAttribute> GetAttributes(Type attributeType);
    public IEnumerable`1<PartCatalogueAttribute> GetAttributes();
    public IList`1<PartCatalogueAttribute> GetAttributes();
    public IList`1<PartCatalogueTypeMember> GetMembers();
    [CanBeNullAttribute]
public Type TryGetBoundType();
    [NotNullAttribute]
public Type Bind();
    internal void BindTo(Type type);
    public sealed virtual bool Equals(PartCatalogueType other);
    public bool Equals();
    public bool Equals(Type typeRuntime);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PartCatalogueType left, PartCatalogueType right);
    public virtual string ToString();
    public static bool op_Inequality(PartCatalogueType left, PartCatalogueType right);
    public void AddExceptionData(Exception obj);
    private sealed virtual override int System.IComparable<JetBrains.Application.Parts.PartCatalogueType>.CompareTo(PartCatalogueType other);
    [NotNullAttribute]
public PartCatalogueType GetArrayItemType();
    [NotNullAttribute]
public PartCatalogueType GetReferenceTargetType();
    [NotNullAttribute]
public PartCatalogueType GenericTypeParameterOwner();
    [CompilerGeneratedAttribute]
private object <Bind>b__43_0();
    [CompilerGeneratedAttribute]
private object <Bind>b__43_1();
    [CompilerGeneratedAttribute]
private object <AddExceptionData>b__53_0();
}
public class JetBrains.Application.Parts.PartCatalogueTypeEqualityComparer : object {
    public static PartCatalogueTypeEqualityComparer Instance;
    private static PartCatalogueTypeEqualityComparer();
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object x, object y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Object>.GetHashCode(object obj);
}
public class JetBrains.Application.Parts.PartCatalogueTypeMember : object {
    private PartCatalogueType myOwner;
    private string myName;
    private PartCatalogTypeMemberKind myKind;
    private IList`1<PartCatalogueType> myParameterTypes;
    private PartCatalogueType myValueType;
    private PartCatalogueAttribute[] myAttributes;
    [CanBeNullAttribute]
private MemberInfo myBoundMember;
    public string Name { get; }
    public string FullName { get; }
    public IList`1<PartCatalogueType> ParameterTypes { get; }
    public PartCatalogueType ValueType { get; }
    public PartCatalogTypeMemberKind Kind { get; }
    [NotNullAttribute]
public PartCatalogueType DeclaringType { get; }
    public PartCatalogueTypeMember(PartCatalogueType owner, string name, PartCatalogTypeMemberKind kind, IList`1<PartCatalogueType> parameterTypes, PartCatalogueType valueType);
    public string get_Name();
    public string get_FullName();
    public IList`1<PartCatalogueType> get_ParameterTypes();
    public PartCatalogueType get_ValueType();
    public PartCatalogTypeMemberKind get_Kind();
    public PartCatalogueType get_DeclaringType();
    public void AssignAttributes(ICollection`1<PartCatalogueAttribute> attributes);
    public IEnumerable`1<PartCatalogueAttribute> GetAttributes(Type attributeType);
    public IEnumerable`1<PartCatalogueAttribute> GetAttributes();
    public PartCatalogueAttribute[] GetAttributes();
    public virtual string ToString();
    [NotNullAttribute]
public MemberInfo Bind();
    [NotNullAttribute]
private MemberInfo BindCore();
    internal void BindTo(MemberInfo member);
}
public static class JetBrains.Application.Parts.PartHelpers : object {
    private static String[] ourIgnoredAttributeNamespacePrefixes;
    private static Type ourPartAttributeType;
    private static MemberFilter ourAllMembersFilter;
    private static string TypeOfPartAttributeFullName;
    private static string TypeOfPartAttributeNamespaceName;
    private static string TypeOfPartAttributeLocalName;
    private static PartHelpers();
    public static bool HasAttributeOrDerivedAttribute(IMetadataEntity entity, string attributeClrName);
    private static bool IsAttributeOrDerivedAttribute(IMetadataCustomAttribute attribute, string attributeClrName);
    private static bool HasAttributeOrDerivedAttribute(ICustomAttributeProvider type, Type attributeType);
    private static bool IsAttributeOrDerivedAttribute(object attribute, Type attributeType);
    public static bool IsPartAttribute(object attributeInstance);
    public static bool IsPartAttribute(IMetadataCustomAttribute attributeMetadata);
    public static bool IsPartAttributeType(IMetadataTypeInfo metype);
    public static bool HasPartAttribute(IMetadataEntity metadata);
    public static bool HasPartAttribute(ICustomAttributeProvider type);
    public static bool HasPartAttributeOnSelfOrMembers(Type type);
    private static object NormalizePropertyValue(object value, IPartCatalogueFactory typeFactory);
    private static object CreateTypeIfNeeded(object value, IPartCatalogueFactory typeFactory);
    public static PartCatalogueAttribute CreatePartAttribute(object attributeInstance, IPartCatalogueFactory typeFactory);
    public static PartCatalogueAttribute CreatePartAttribute(IMetadataCustomAttribute attribute, IPartCatalogueFactory typeFactory);
    private static object ExpandMetadataValue(MetadataAttributeValue metavalue);
    private static ICollection`1<PartCatalogueAttribute> CreateAttributes(IMetadataEntity entity, IPartCatalogueFactory typeFactory);
    private static ICollection`1<PartCatalogueAttribute> CreateAttributes(ICustomAttributeProvider attrowner, IPartCatalogueFactory typeFactory);
    public static bool IsAttributeOfType(PartCatalogueAttribute attribute, Type attributeType);
    public static bool IsAttributeOfType(PartCatalogAttribute attribute, Type attributeType);
    [ObsoleteAttribute("As it has a lifetime, you can always create the resolvers beforehand.")]
public static CombiningAssemblyResolver CreateFileResolver(Lifetime lifetime, IEnumerable`1<FileSystemPath> assembliesCurrent, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, OnError resolveerrors, RuntimeResolverOption rrop);
    public static CombiningAssemblyResolver CreateFileResolver(Lifetime lifetime, IEnumerable`1<FileSystemPath> assembliesCurrent, IAssemblyResolver customresolver, OnError resolveerrors, RuntimeResolverOption rrop);
    public static CombiningAssemblyResolver CreateStreamResolver(Lifetime lifetime, IDictionary`2<AssemblyNameInfo, Func`2<Lifetime, Stream>> assembliesCurrent, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, OnError resolveerrors, RuntimeResolverOption rrop);
}
public class JetBrains.Application.Parts.PartsCatalogue : UserDataHolder {
    private IList`1<PartCatalogueAssembly> myAssemblies;
    private IList`1<PartCatalogueType> myParts;
    public PartsCatalogue(IList`1<PartCatalogueType> parts, IList`1<PartCatalogueAssembly> assemblies);
    public virtual string ToString();
    private sealed virtual override IEnumerable`1<PartCatalogueAssembly> JetBrains.Application.Parts.IPartsCatalogue.GetAssemblies();
    private sealed virtual override IEnumerable`1<PartCatalogueType> JetBrains.Application.Parts.IPartsCatalogue.GetParts();
}
public static class JetBrains.Application.Parts.PartsCatalogues : object {
    private static IMetadataPartsPassFilter DefaultMetadataPartsPassFilter;
    private static ILogger Logger;
    private static PartsCatalogues();
    [NotNullAttribute]
public static IPartsCatalogue Create(IList`1<PartCatalogueType> parts, IList`1<PartCatalogueAssembly> assemblies);
    [NotNullAttribute]
public static IPartsCatalogue CreateFromRuntimeAssemblies(IEnumerable`1<Assembly> assemblies, IPartCatalogueFactory typeFactory, RuntimePartsPassFilter filter);
    [NotNullAttribute]
public static IPartsCatalogue CreateFromRuntimeAssembly(Assembly assembly, IPartCatalogueFactory typeFactory, RuntimePartsPassFilter filter);
    [NotNullAttribute]
public static IPartsCatalogue CreateFromRuntimeTypes(IEnumerable`1<Type> types);
    [NotNullAttribute]
public static IPartsCatalogue CreateFromRuntimeTypes(Type[] types);
    [NotNullAttribute]
public static IPartsCatalogue CreateWithMetadataReader(IEnumerable`1<AssemblyNameInfo> assemblies, IAssemblyMasterBinder masterbinder, IPartCatalogueFactory typeFactory, IMetadataPartsPassFilter filter);
    [NotNullAttribute]
public static IPartsCatalogue CreateWithMetadataReaderFromAssemblyFiles(IList`1<FileSystemPath> assemblyLocations, IPartCatalogueFactory typeFactory, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, IMetadataPartsPassFilter filter);
    [NotNullAttribute]
public static IPartsCatalogue CreateWithMetadataReaderFromAssemblyFiles(IList`1<FileSystemPath> assemblyLocations, IList`1<FileSystemPath> filesAdditionalAssemblyReferences, IPartCatalogueFactory typeFactory, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, IMetadataPartsPassFilter filter);
    [NotNullAttribute]
public static IPartsCatalogue CreateWithMetadataReaderFromAssemblyStreams(ICollection`1<Stream> assemblies, IPartCatalogueFactory typeFactory, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, IMetadataPartsPassFilter filter);
    [NotNullAttribute]
[ObsoleteAttribute("Should use the overload with master binder.")]
public static IPartsCatalogue CreateWithMetadataReaderFromAssemblyStreams(IEnumerable`1<AssemblyNameInfo> assemblies, IDictionary`2<AssemblyNameInfo, Func`2<Lifetime, Stream>> mapResolver, IPartCatalogueFactory typeFactory, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, IMetadataPartsPassFilter filter);
    [NotNullAttribute]
public static IPartsCatalogue CreateWithReflectionFromAssemblyFiles(IList`1<FileSystemPath> assemblyLocations, IPartCatalogueFactory typeFactory);
    private static void CheckLoadedAssemblyName(PartCatalogueAssembly partassembly, AssemblyNameInfo assname);
}
public class JetBrains.Application.Parts.RuntimeBasedAssemblyBinder : object {
    private RuntimeResolverOption myRuntimeResolverOption;
    [NotNullAttribute]
public Assembly Assembly;
    private AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.AssemblyName { get; }
    public RuntimeBasedAssemblyBinder(Assembly assembly, RuntimeResolverOption runtimeResolverOption);
    private sealed virtual override AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.get_AssemblyName();
    private sealed virtual override FileSystemPath JetBrains.Application.Bindings.IAssemblyBinder.BindToDiskPath(OnError onerror);
    private sealed virtual override IMetadataAssembly JetBrains.Application.Bindings.IAssemblyBinder.BindToMetadataAssembly(Lifetime lifetime, OnError onerror);
    private sealed virtual override Assembly JetBrains.Application.Bindings.IAssemblyBinder.BindToRuntimeAssembly(OnError onerror);
    private sealed virtual override Stream JetBrains.Application.Bindings.IAssemblyBinder.BindToStream(Lifetime lifetime, OnError onerror);
}
public class JetBrains.Application.Parts.StreamBasedAssemblyBinder : object {
    [NotNullAttribute]
private AssemblyNameInfo myAssemblyNameInfo;
    [CanBeNullAttribute]
private Func`2<Lifetime, IAssemblyResolver> myFCreateAdditionalResolvers;
    [NotNullAttribute]
private Func`2<Lifetime, Stream> myFStream;
    [NotNullAttribute]
private IDictionary`2<AssemblyNameInfo, Func`2<Lifetime, Stream>> myOtherAssembliesForResolveAssemblies;
    private RuntimeResolverOption myRuntimeResolverOption;
    private AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.AssemblyName { get; }
    public StreamBasedAssemblyBinder(AssemblyNameInfo assemblyNameInfo, Func`2<Lifetime, Stream> FStream, IDictionary`2<AssemblyNameInfo, Func`2<Lifetime, Stream>> otherAssembliesForResolveAssemblies, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, RuntimeResolverOption rrop);
    public IMetadataAssembly BindToMetadataAssemblyOnMyLoader(Lifetime lifetime, MetadataLoader loader);
    public static MetadataLoader CreateMetadataLoader(Lifetime lifetime, IDictionary`2<AssemblyNameInfo, Func`2<Lifetime, Stream>> otherAssembliesForResolveAssemblies, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, RuntimeResolverOption rrop);
    private sealed virtual override AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.get_AssemblyName();
    private sealed virtual override FileSystemPath JetBrains.Application.Bindings.IAssemblyBinder.BindToDiskPath(OnError onerror);
    private sealed virtual override IMetadataAssembly JetBrains.Application.Bindings.IAssemblyBinder.BindToMetadataAssembly(Lifetime lifetime, OnError onerror);
    private sealed virtual override Assembly JetBrains.Application.Bindings.IAssemblyBinder.BindToRuntimeAssembly(OnError onerror);
    private sealed virtual override Stream JetBrains.Application.Bindings.IAssemblyBinder.BindToStream(Lifetime lifetime, OnError onerror);
    [CompilerGeneratedAttribute]
private bool <JetBrains.Application.Bindings.IAssemblyBinder.BindToRuntimeAssembly>b__12_0(Assembly ass);
    [CompilerGeneratedAttribute]
private Assembly <JetBrains.Application.Bindings.IAssemblyBinder.BindToRuntimeAssembly>b__12_1(Lifetime lifetime);
}
public class JetBrains.Application.Table.AssemblyBinderWithMvidValidation : object {
    private IAssemblyBinder myBinderRaw;
    private Guid myMvid;
    private AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.AssemblyName { get; }
    public AssemblyBinderWithMvidValidation(Guid mvid, IAssemblyBinder binderRaw);
    private sealed virtual override AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.get_AssemblyName();
    private sealed virtual override FileSystemPath JetBrains.Application.Bindings.IAssemblyBinder.BindToDiskPath(OnError onerror);
    private sealed virtual override IMetadataAssembly JetBrains.Application.Bindings.IAssemblyBinder.BindToMetadataAssembly(Lifetime lifetime, OnError onerror);
    private void BindToMetadataAssembly_BadMvid(IMetadataAssembly metass);
    private sealed virtual override Assembly JetBrains.Application.Bindings.IAssemblyBinder.BindToRuntimeAssembly(OnError onerror);
    private void BindToRuntimeAssembly_BadMvid(Assembly assembly);
    private sealed virtual override Stream JetBrains.Application.Bindings.IAssemblyBinder.BindToStream(Lifetime lifetime, OnError onerror);
}
public class JetBrains.Application.Table.CatalogTables : object {
    public UInt32 CbFile;
    public CatalogTablesFileHeader* File;
    public TableHeader* HeaderAssembly;
    public TableHeader* HeaderAssemblyList;
    public TableHeader* HeaderBlob;
    public TableHeader* HeaderString;
    public TableHeader* HeaderTraitName;
    public TableHeader* HeaderType;
    public TableHeader* HeaderTypeList;
    public TableHeader* HeaderTypeTraitBank;
    public Lifetime Lifetime;
    public AssemblyRecord* TableAssembly;
    public AssemblyListRecord* TableAssemblyList;
    public AttributeRecord* TableAttribute;
    public AttributeArgumentRecord* TableAttributeArgument;
    public BlobTableHeader* TableBlob;
    public MemberRecord* TableMember;
    public Byte* TableString;
    public TraitNameRecord* TableTraitName;
    public TypeRecord* TableType;
    public TypeListRecord* TableTypeList;
    public TypeTraitBankRecord* TableTypeTraitBank;
    private CatalogTables(Lifetime lifetime, Void* pCatalogTablesFile, UInt32 cbCatalogTablesFile);
    public static CatalogTables Open(Lifetime lifetime, Void* pCatalogTablesFile, UInt32 cbCatalogTablesFile, OnError onerror);
    public static CatalogTables OpenCopiedFromStream(Lifetime lifetime, Stream stream, OnError onerror);
    private void AssertValidFast();
    private void AssertValidFast_TableNotNull(Void* pTable, string tablename);
}
public class JetBrains.Application.Table.Emit.CalculateAttributeTypeTraitsForPartCatalogTables : object {
    public static string TraitNamespace;
    private string JetBrains.Application.Table.Emit.ICalculateTraitsForPartCatalogTables.TraitNamespace { get; }
    private static CalculateAttributeTypeTraitsForPartCatalogTables();
    public static PartCatalogTrait GetAttributeTypeTraitName(Type typeAttr);
    public static PartCatalogTrait GetAttributeTypeTraitName(string sTypeFullName);
    private sealed virtual override void JetBrains.Application.Table.Emit.ICalculateTraitsForPartCatalogTables.CalculateTraits(EmitTimeTables tables, OneToSetMap`2<TypeRef, TraitNameRecord> typetraits);
    private static TraitNameRecord MakeAttributeTypeTrait(TypeRecord typeAttr, EmitTimeTables tables);
    private sealed virtual override string JetBrains.Application.Table.Emit.ICalculateTraitsForPartCatalogTables.get_TraitNamespace();
}
public static class JetBrains.Application.Table.Emit.CatalogTablesMerger : object {
    private static ILogger Logger;
    private static CatalogTablesMerger();
    public static void MergeCatalogTables(CatalogTables[] olds, Stream output);
    private static AttributeArgumentRangeRef CopyArgumentRange(AttributeArgumentRangeRef oldrangeTopLevel, CatalogTables oldtables, EmitTimeTables newtables);
    private static AssemblyListRangeRef CopyAssemblyRangeShallow(AssemblyListRangeRef rangeOldAssemblies, CatalogTables oldtables, EmitTimeTables newtables, IDictionary`2<StringRef, AssemblyRef> cachePreCreatedAssemblies);
    private static AssemblyRef CopyAssemblyShallow(AssemblyRef refOldAssembly, CatalogTables oldtables, EmitTimeTables newtables, IDictionary`2<StringRef, AssemblyRef> cachePreCreatedAssemblies);
    private static AssemblyRef CopyAssemblyShallow(TableAndRef`1<AssemblyRef> refOriginalAssembly, EmitTimeTables newtables, IDictionary`2<StringRef, AssemblyRef> cachePreCreatedAssemblies);
    private static AttributeRangeRef CopyAttributeRange(AttributeRangeRef oldattrrange, CatalogTables oldtables, EmitTimeTables newtables);
    private static MemberRangeRef CopyMembersRange(MemberRangeRef oldrange, CatalogTables oldtables, EmitTimeTables newtables);
    private static StringRef CopyString(StringRef oldref, CatalogTables oldtables, EmitTimeTables newtables);
    private static TypeListRangeRef CopyTypeListShallow(TypeListRangeRef oldrange, CatalogTables oldtables, EmitTimeTables newtables, RecordsOrder order);
    private static TypeRef CopyTypeShallow(TableAndRef`1<TypeRef> refOldType, EmitTimeTables newtables);
    private static TypeRef CopyTypeShallow(TypeRef oldtyperef, CatalogTables oldtables, EmitTimeTables newtables);
    private static void FillPreCreatedShallowAssemblies_AllButPartTypes(IEnumerable`1<AssemblyCataloged> assemblies, EmitTimeTables newtables, IDictionary`2<StringRef, AssemblyRef> cachePreCreatedAssemblies);
    private static void FillPreCreatedShallowAssemblies_FlagMvidParts(IEnumerable`1<AssemblyCataloged> assemblies, EmitTimeTables newtables);
    private static void FillPreCreatedShallowPartAssemblies(List`1<AssemblyCataloged> assemblies, EmitTimeTables newtables, IDictionary`2<StringRef, AssemblyRef> cachePreCreatedAssemblies);
    private static void FillPreCreatedShallowTypes(EmitTimeTables newtables, OneToSetMap`2& mapTypeToTraitNames, IDictionary`2<StringRef, AssemblyRef> cachePreCreatedAssemblies);
    private static void FillPreCreatedShallowTypes_Traits(TypeRef refNewType, TableAndRef`1<TypeRef> refOldType, EmitTimeTables newtables, OneToSetMap`2<TypeRef, TraitNameRecord> mapTypeToTraitNames);
    private static void FillPreCreatedShallowTypes_Type(TypeRef refNewType, TableAndRef`1<TypeRef> refOldType, EmitTimeTables newtables, IDictionary`2<StringRef, AssemblyRef> cachePreCreatedAssemblies);
    private static void MergeTraitNamespaceAvailability(OneToSetMap`2<TypeRef, TraitNameRecord> mapTypeToTraitNames, EmitTimeTables newtables, CatalogTables[] olds);
    private static AssemblyCataloged PreCreateAssemblyForCataloging(TableAndRef`1<AssemblyRef> refOriginalAssembly, EmitTimeTables newtables, IDictionary`2<StringRef, AssemblyRef> cachePreCreatedAssemblies);
}
public static class JetBrains.Application.Table.Emit.EmitCatalogTables : object {
    public static void CreateCatalogTablesWithMetadataReader(IEnumerable`1<AssemblyNameInfo> assemblies, IAssemblyMasterBinder masterbinder, ICollection`1<ICalculateTraitsForPartCatalogTables> traitcalc, Stream output, ILogger logger);
}
public static class JetBrains.Application.Table.Emit.EmitTablesFileWriter : object {
    public static void WriteCatalogTablesFile(EmitTimeTables tables, Stream output);
    public static void WritePodTable(EmitPodTable`1<TRecord> table, CatalogTablesFileWriteSession writesession);
    public static void WritePodTableRecords(IList`1<TRecord> records, CatalogTablesFileWriteSession writesession);
}
public class JetBrains.Application.Table.Emit.EmitTimeTables : object {
    public EmitPodTable`1<AssemblyRecord> TableAssembly;
    public EmitPodTable`1<AssemblyListRecord> TableAssemblyList;
    public EmitAttributeTable TableAttribute;
    public EmitPodTable`1<AttributeArgumentRecord> TableAttributeArgument;
    public EmitBlobTable TableBlob;
    public EmitPodTable`1<MemberRecord> TableMember;
    public EmitStringTable TableStrings;
    public EmitPodTable`1<TraitNameRecord> TableTraitName;
    public EmitTypeTable TableType;
    public EmitPodTable`1<TypeListRecord> TableTypeList;
    public EmitPodTable`1<TypeTraitBankRecord> TableTypeTraitBank;
}
public class JetBrains.Application.Table.Emit.EmitTimeTablesPartCatalogStorageEmulation : object {
    private EmitTimeTables Tables;
    public EmitTimeTablesPartCatalogStorageEmulation(EmitTimeTables tables);
    public sealed virtual StringSource AssemblyGetSimpleName(Int32`1<CatalogAssemblyToken> token);
    public sealed virtual object AttributeArgumentGetBoxedValue(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual ulong AttributeArgumentGetPrimitiveValue(Int32`1<CatalogAttributeArgumentToken> token, Nullable`1<AttributeArgumentValueElementType> typeExpected);
    public sealed virtual StringSource AttributeArgumentGetStringValue(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual PartCatalogType AttributeArgumentGetTypeValue(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual AttributeArgumentValueElementType AttributeArgumentGetValueElementType(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual Nullable`1<PartCatalogAttributeArgument> AttributeTryGetArgumentByName(Int32`1<CatalogAttributeToken> token, string name);
    public TypeRef GetTypeRef(PartCatalogType type);
    private sealed virtual override IPartCatalogStorage JetBrains.Application.Catalogs.IPartCatalogStorage.ApplyFilter(IPartCatalogFilter filter);
    private sealed virtual override IAssemblyBinder JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetBinder(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetFullName(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override int JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetHashCode(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override AssemblyNameInfo JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetNameInfo(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttribute> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetPartAttributes(Int32`1<CatalogAssemblyToken> token, Type typeFilter);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetPartTypes(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAssembly> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetReferencedAssemblies(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override bool JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyIsCataloged(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override PartCatalogAttributeArgumentDisposition JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetDisposition(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetName(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttributeArgument> JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetArguments(Int32`1<CatalogAttributeToken> token);
    private sealed virtual override object JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetInstance(Int32`1<CatalogAttributeToken> token, OnError onerror);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetType(Int32`1<CatalogAttributeToken> token);
    private sealed virtual override Nullable`1<CollectionSource`1<PartCatalogType>> JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeTryGetConstructorFormalParameterTypes(Int32`1<CatalogAttributeToken> token);
    private CollectionSource`1<PartCatalogAttribute> GetAttributesCore(AttributeRangeRef range, Type typeFilter);
    [NotNullAttribute]
private string GetString(StringRef sref);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.GetTypeLocalName(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.GlobalGetAllPartTypes();
    [IteratorStateMachineAttribute("JetBrains.Application.Table.Emit.EmitTimeTablesPartCatalogStorageEmulation/<GlobalGetAllPartTypesEnum>d__29")]
[NotNullAttribute]
private IEnumerable`1<PartCatalogType> GlobalGetAllPartTypesEnum();
    private sealed virtual override CollectionSource`1<PartCatalogAssembly> JetBrains.Application.Catalogs.IPartCatalogStorage.GlobalGetCatalogedAssemblies();
    private sealed virtual override MemberInfo JetBrains.Application.Catalogs.IPartCatalogStorage.MemberBind(Int32`1<CatalogMemberToken> token);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetDeclaringType(Int32`1<CatalogMemberToken> token);
    private sealed virtual override int JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetHashCode(Int32`1<CatalogMemberToken> token);
    private sealed virtual override PartCatalogTypeMemberKind JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetKind(Int32`1<CatalogMemberToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetName(Int32`1<CatalogMemberToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetParameterTypes(Int32`1<CatalogMemberToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttribute> JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetPartAttributes(Int32`1<CatalogMemberToken> token, Type typeFilter);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetValueType(Int32`1<CatalogMemberToken> token);
    [NotNullAttribute]
private static IEnumerable`1<int> RangeToEnumerableSlow(IRecordRangeRef rangeable);
    private sealed virtual override Type JetBrains.Application.Catalogs.IPartCatalogStorage.TypeBind(Int32`1<CatalogTypeToken> token);
    private sealed virtual override bool JetBrains.Application.Catalogs.IPartCatalogStorage.TypeEqualsRuntimeType(Int32`1<CatalogTypeToken> token, Type typeRuntime);
    private sealed virtual override PartCatalogAssembly JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetAssembly(Int32`1<CatalogTypeToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetAssemblyQualifiedName(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetBaseTypes(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetExtraTypes(Int32`1<CatalogTypeToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetFullName(Int32`1<CatalogTypeToken> token);
    private sealed virtual override int JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetHashCode(Int32`1<CatalogTypeToken> token);
    private sealed virtual override PartCatalogTypeKind JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetKind(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttribute> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetPartAttributes(Int32`1<CatalogTypeToken> token, Type typeFilter);
    private sealed virtual override CollectionSource`1<PartCatalogTypeMember> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetPartMembers(Int32`1<CatalogTypeToken> token);
    private sealed virtual override Type JetBrains.Application.Catalogs.IPartCatalogStorage.TypeTryGetBoundType(Int32`1<CatalogTypeToken> token);
    [CompilerGeneratedAttribute]
private PartCatalogType <JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetPartTypes>b__16_0(int index);
    [CompilerGeneratedAttribute]
private PartCatalogAssembly <JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetReferencedAssemblies>b__17_0(int index);
    [CompilerGeneratedAttribute]
private PartCatalogAttributeArgument <JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetArguments>b__21_0(int index);
    [CompilerGeneratedAttribute]
private PartCatalogType <JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeTryGetConstructorFormalParameterTypes>b__24_0(int index);
    [CompilerGeneratedAttribute]
private PartCatalogAssembly <JetBrains.Application.Catalogs.IPartCatalogStorage.GlobalGetCatalogedAssemblies>b__30_0(int index);
    [CompilerGeneratedAttribute]
private PartCatalogType <JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetParameterTypes>b__36_0(int index);
    [CompilerGeneratedAttribute]
private PartCatalogType <JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetBaseTypes>b__44_0(int index);
    [CompilerGeneratedAttribute]
private PartCatalogType <JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetExtraTypes>b__45_0(int index);
    [CompilerGeneratedAttribute]
private PartCatalogTypeMember <JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetPartMembers>b__50_0(int index);
}
public interface JetBrains.Application.Table.Emit.ICalculateTraitsForPartCatalogTables {
    [NotNullAttribute]
public string TraitNamespace { get; }
    public abstract virtual string get_TraitNamespace();
    public abstract virtual void CalculateTraits(EmitTimeTables tables, OneToSetMap`2<TypeRef, TraitNameRecord> typetraits);
}
public enum JetBrains.Application.Table.Emit.RecordsOrder : Enum {
    public int value__;
    public static RecordsOrder Keep;
    public static RecordsOrder CanSort;
}
public static class JetBrains.Application.Table.Emit.TraitsInCatalogTables : object {
    public static string SupportedTraitNamespacesNamespace;
    private static TraitsInCatalogTables();
    public static void CalculateTraits(EmitTimeTables tables, ICollection`1<ICalculateTraitsForPartCatalogTables> calculators);
    public static TraitNameRecord CreateTraitNameRecord(PartCatalogTrait trait, EmitTimeTables tables);
    public static void WriteTraits(EmitTimeTables tables, OneToSetMap`2<TypeRef, TraitNameRecord> typetraits);
    private static void RegisterTraitNamespace(string sTraitNamespace, OneToSetMap`2<TypeRef, TraitNameRecord> typetraits, EmitTimeTables tables);
}
public static class JetBrains.Application.Table.PrintCatalogTables : object {
    public static ILogger Logger;
    private static string StyleHeader;
    private static string StyleHyperlink;
    public static string XmlnsExcel;
    public static string XmlnsSpreadsheet;
    private static PrintCatalogTables();
    public static ImmutableFileItem Render(CatalogTables tables);
    private static void CollectBackreferences(StringTable stringtable, IList`1<PodTable> podtables);
    private static Dictionary`2<string, TableHeader> CreateTablesMap(CatalogTables tables);
    [NotNullAttribute]
private static string FormatHyperlink(string sTableName, TextRange columns, int indexFirst, Nullable`1<int> maybeLastIndex);
    private static StringTable LoadStringTable(CatalogTables tables, Dictionary`2<string, TableHeader> mapTablesByName);
    private static void RenderIncomingReferencesCell(IList`1<PodRecordRef> froms, XmlWriter writer);
    private static void RenderPodTable(PodTable table, XmlWriter writer, StringTable stringtable, IList`1<PodTable> podtables);
    private static void RenderStringTable(StringTable stringtable, XmlWriter writer);
    [CanBeNullAttribute]
private static PodTable TryLoadPodTable(TableHeader tr, CatalogTables tables);
    [CanBeNullAttribute]
private static PodRecord[] TryResolveRecordRangeReference(IRecordRangeRef rrref, StringTable stringtable, IList`1<PodTable> podtables);
    [CanBeNullAttribute]
private static PodRecord TryResolveRecordReference(IRecordRef recordref, StringTable stringtable, IList`1<PodTable> podtables);
    private static void UpdateDisplayNames(StringTable stringtable, IList`1<PodTable> podtables);
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.AssemblyListRecord : ValueType {
    public AssemblyRef Item;
    public static string CatalogedAssembliesListRangeBlobName;
    private ARef JetBrains.Application.Table.Record.Ref.IRecordRef.Ref { get; }
    private Type JetBrains.Application.Table.Record.Ref.IRecordRef.TargetRecordType { get; }
    private static AssemblyListRecord();
    private sealed virtual override ARef JetBrains.Application.Table.Record.Ref.IRecordRef.get_Ref();
    private sealed virtual override Type JetBrains.Application.Table.Record.Ref.IRecordRef.get_TargetRecordType();
    public virtual string ToString();
    public sealed virtual bool Equals(AssemblyListRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyListRecord left, AssemblyListRecord right);
    public static bool op_Inequality(AssemblyListRecord left, AssemblyListRecord right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.AssemblyListRecord>.CompareTo(AssemblyListRecord other);
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.AssemblyRecord : ValueType {
    public StringRef FullName;
    public AttributeRangeRef Attributes;
    public TypeListRangeRef Types;
    public AssemblyListRangeRef ReferencedAssemblies;
    public Guid Mvid;
    public AssemblyRecordFlags Flags;
    public sealed virtual bool Equals(AssemblyRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyRecord left, AssemblyRecord right);
    public static bool op_Inequality(AssemblyRecord left, AssemblyRecord right);
}
[FlagsAttribute]
public enum JetBrains.Application.Table.Record.AssemblyRecordFlags : Enum {
    public UInt32 value__;
    public static AssemblyRecordFlags IsCatalogedAssembly;
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.AttributeArgumentRecord : ValueType {
    public StringRef Name;
    public short Disposition;
    public AttributeArgumentValueElementType ElementType;
    public StringRef StringValue;
    public TypeRef TypeValue;
    public ulong PrimitiveValue;
    public AttributeArgumentRangeRef ArrayItemsValue;
    public sealed virtual bool Equals(AttributeArgumentRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AttributeArgumentRecord left, AttributeArgumentRecord right);
    public static bool op_Inequality(AttributeArgumentRecord left, AttributeArgumentRecord right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.AttributeArgumentRecord>.CompareTo(AttributeArgumentRecord other);
}
public enum JetBrains.Application.Table.Record.AttributeArgumentValueElementType : Enum {
    public ushort value__;
    public static AttributeArgumentValueElementType Null;
    public static AttributeArgumentValueElementType Bool;
    public static AttributeArgumentValueElementType Char;
    public static AttributeArgumentValueElementType I1;
    public static AttributeArgumentValueElementType U1;
    public static AttributeArgumentValueElementType I2;
    public static AttributeArgumentValueElementType U2;
    public static AttributeArgumentValueElementType I4;
    public static AttributeArgumentValueElementType U4;
    public static AttributeArgumentValueElementType I8;
    public static AttributeArgumentValueElementType U8;
    public static AttributeArgumentValueElementType R4;
    public static AttributeArgumentValueElementType R8;
    public static AttributeArgumentValueElementType String;
    public static AttributeArgumentValueElementType Type;
    public static AttributeArgumentValueElementType SzArray;
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.AttributeRecord : ValueType {
    public TypeRef DeclaringType;
    public TypeListRangeRef ConstructorFormalParameterTypes;
    public AttributeArgumentRangeRef Arguments;
    public sealed virtual bool Equals(AttributeRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AttributeRecord left, AttributeRecord right);
    public static bool op_Inequality(AttributeRecord left, AttributeRecord right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.AttributeRecord>.CompareTo(AttributeRecord other);
}
public class JetBrains.Application.Table.Record.Bitmask64 : ValueType {
    public ulong Value;
    public Bitmask64(ulong value);
    public sealed virtual bool Equals(Bitmask64 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Bitmask64 left, Bitmask64 right);
    public static ulong op_Implicit(Bitmask64 value);
    public static Bitmask64 op_Implicit(ulong value);
    public static bool op_Inequality(Bitmask64 left, Bitmask64 right);
    public static bool op_GreaterThan(Bitmask64 left, Bitmask64 right);
    public static bool op_LessThan(Bitmask64 left, Bitmask64 right);
    public virtual string ToString();
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.Bitmask64>.CompareTo(Bitmask64 other);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
}
public class JetBrains.Application.Table.Record.BlobTableHeader : ValueType {
    public ulong IndexRva;
    public byte IndexHashHighestSetBit;
}
public class JetBrains.Application.Table.Record.BlobTableIndexRecord : ValueType {
    public OWORD Identity;
    public BlobTableIndexRecordFlags Flags;
    public StringRef Note;
    public ulong BodyRva;
    public ulong BodyCbSize;
}
[FlagsAttribute]
public enum JetBrains.Application.Table.Record.BlobTableIndexRecordFlags : Enum {
    public int value__;
    public static BlobTableIndexRecordFlags IsDefined;
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.CatalogTablesFileHeader : ValueType {
    public static string CurrentFormatMark;
    public static Guid CurrentFormatRevision;
    public static int cbFormatMark;
    [FixedBufferAttribute("System.Byte", "32")]
public <szFormatMark>e__FixedBuffer szFormatMark;
    public Guid FormatRevision;
    public ushort TableRefsCount;
    public TableHeader FirstTableHeader;
    private static CatalogTablesFileHeader();
    [PureAttribute]
public CatalogTablesFileHeader WithFormat();
    public static bool AssertFormat(CatalogTablesFileHeader* thіs, OnError onerror);
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.MemberRecord : ValueType {
    public StringRef LocalName;
    public TypeRef DeclaringType;
    public AttributeRangeRef Attributes;
    public TypeRef ValueType;
    public TypeListRangeRef ParameterTypes;
    public PartCatalogTypeMemberKind Kind;
    public sealed virtual bool Equals(MemberRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MemberRecord left, MemberRecord right);
    public static bool op_Inequality(MemberRecord left, MemberRecord right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.MemberRecord>.CompareTo(MemberRecord other);
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.RangeRef.ARangeRef : ValueType {
    public UInt32 FirstIndex;
    public ushort Count;
    public ARangeRef(int firstindex, int count);
    public RangeEnumerator GetEnumerator();
    public sealed virtual bool Equals(ARangeRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(ARangeRef left, ARangeRef right);
    public static bool op_Inequality(ARangeRef left, ARangeRef right);
    public static ARangeRef CreateNullIfEmpty(int firstindex, int count);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.RangeRef.ARangeRef>.CompareTo(ARangeRef other);
}
public class JetBrains.Application.Table.Record.RangeRef.AssemblyListRangeRef : ValueType {
    public ARangeRef Range;
    private ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.Range { get; }
    public Type TargetRecordType { get; }
    public AssemblyListRangeRef(ARangeRef range);
    private sealed virtual override ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.get_Range();
    public sealed virtual Type get_TargetRecordType();
    public sealed virtual RangeEnumerator GetEnumerator();
    public virtual string ToString();
    public sealed virtual bool Equals(AssemblyListRangeRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyListRangeRef left, AssemblyListRangeRef right);
    public static bool op_Inequality(AssemblyListRangeRef left, AssemblyListRangeRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.RangeRef.AssemblyListRangeRef>.CompareTo(AssemblyListRangeRef other);
}
public class JetBrains.Application.Table.Record.RangeRef.AttributeArgumentRangeRef : ValueType {
    public ARangeRef Range;
    private ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.Range { get; }
    public Type TargetRecordType { get; }
    public AttributeArgumentRangeRef(ARangeRef range);
    private sealed virtual override ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.get_Range();
    public sealed virtual Type get_TargetRecordType();
    public sealed virtual RangeEnumerator GetEnumerator();
    public virtual string ToString();
    public sealed virtual bool Equals(AttributeArgumentRangeRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AttributeArgumentRangeRef left, AttributeArgumentRangeRef right);
    public static bool op_Inequality(AttributeArgumentRangeRef left, AttributeArgumentRangeRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.RangeRef.AttributeArgumentRangeRef>.CompareTo(AttributeArgumentRangeRef other);
}
public class JetBrains.Application.Table.Record.RangeRef.AttributeRangeRef : ValueType {
    public ARangeRef Range;
    private ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.Range { get; }
    public Type TargetRecordType { get; }
    public AttributeRangeRef(ARangeRef range);
    private sealed virtual override ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.get_Range();
    public sealed virtual Type get_TargetRecordType();
    public sealed virtual RangeEnumerator GetEnumerator();
    public virtual string ToString();
    public sealed virtual bool Equals(AttributeRangeRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AttributeRangeRef left, AttributeRangeRef right);
    public static bool op_Inequality(AttributeRangeRef left, AttributeRangeRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.RangeRef.AttributeRangeRef>.CompareTo(AttributeRangeRef other);
}
public interface JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef {
    public ARangeRef Range { get; }
    public Type TargetRecordType { get; }
    public abstract virtual ARangeRef get_Range();
    public abstract virtual Type get_TargetRecordType();
    public abstract virtual RangeEnumerator GetEnumerator();
}
public class JetBrains.Application.Table.Record.RangeRef.MemberRangeRef : ValueType {
    public ARangeRef Range;
    private ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.Range { get; }
    public Type TargetRecordType { get; }
    public MemberRangeRef(ARangeRef range);
    private sealed virtual override ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.get_Range();
    public sealed virtual Type get_TargetRecordType();
    public sealed virtual RangeEnumerator GetEnumerator();
    public virtual string ToString();
    public sealed virtual bool Equals(MemberRangeRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MemberRangeRef left, MemberRangeRef right);
    public static bool op_Inequality(MemberRangeRef left, MemberRangeRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.RangeRef.MemberRangeRef>.CompareTo(MemberRangeRef other);
}
public class JetBrains.Application.Table.Record.RangeRef.RangeEnumerator : ValueType {
    private UInt32 myCurrent;
    private ARangeRef myRange;
    public int Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public RangeEnumerator(ARangeRef range);
    [PureAttribute]
public sealed virtual int get_Current();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public class JetBrains.Application.Table.Record.RangeRef.TypeListRangeRef : ValueType {
    public ARangeRef Range;
    private ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.Range { get; }
    public Type TargetRecordType { get; }
    public TypeListRangeRef(ARangeRef range);
    private sealed virtual override ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.get_Range();
    public sealed virtual Type get_TargetRecordType();
    public sealed virtual RangeEnumerator GetEnumerator();
    public virtual string ToString();
    public sealed virtual bool Equals(TypeListRangeRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TypeListRangeRef left, TypeListRangeRef right);
    public static bool op_Inequality(TypeListRangeRef left, TypeListRangeRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.RangeRef.TypeListRangeRef>.CompareTo(TypeListRangeRef other);
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.Ref.ARef : ValueType {
    public UInt32 Index;
    public ARef(UInt32 index);
    public sealed virtual bool Equals(ARef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ARef left, ARef right);
    public static bool op_Inequality(ARef left, ARef right);
    public virtual string ToString();
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.Ref.ARef>.CompareTo(ARef other);
}
public class JetBrains.Application.Table.Record.Ref.AssemblyRef : ValueType {
    public ARef Ref;
    private ARef JetBrains.Application.Table.Record.Ref.IRecordRef.Ref { get; }
    private Type JetBrains.Application.Table.Record.Ref.IRecordRef.TargetRecordType { get; }
    public AssemblyRef(UInt32 index);
    public AssemblyRef(ARef aref);
    private sealed virtual override ARef JetBrains.Application.Table.Record.Ref.IRecordRef.get_Ref();
    private sealed virtual override Type JetBrains.Application.Table.Record.Ref.IRecordRef.get_TargetRecordType();
    public virtual string ToString();
    public sealed virtual bool Equals(AssemblyRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyRef left, AssemblyRef right);
    public static bool op_Inequality(AssemblyRef left, AssemblyRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.Ref.AssemblyRef>.CompareTo(AssemblyRef other);
}
public class JetBrains.Application.Table.Record.Ref.AttributeArgumentRef : ValueType {
    public ARef Ref;
    private ARef JetBrains.Application.Table.Record.Ref.IRecordRef.Ref { get; }
    private Type JetBrains.Application.Table.Record.Ref.IRecordRef.TargetRecordType { get; }
    public AttributeArgumentRef(UInt32 index);
    private sealed virtual override ARef JetBrains.Application.Table.Record.Ref.IRecordRef.get_Ref();
    private sealed virtual override Type JetBrains.Application.Table.Record.Ref.IRecordRef.get_TargetRecordType();
    public virtual string ToString();
    public sealed virtual bool Equals(AttributeArgumentRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AttributeArgumentRef left, AttributeArgumentRef right);
    public static bool op_Inequality(AttributeArgumentRef left, AttributeArgumentRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.Ref.AttributeArgumentRef>.CompareTo(AttributeArgumentRef other);
}
public class JetBrains.Application.Table.Record.Ref.AttributeRef : ValueType {
    public ARef Ref;
    private ARef JetBrains.Application.Table.Record.Ref.IRecordRef.Ref { get; }
    private Type JetBrains.Application.Table.Record.Ref.IRecordRef.TargetRecordType { get; }
    public AttributeRef(UInt32 index);
    private sealed virtual override ARef JetBrains.Application.Table.Record.Ref.IRecordRef.get_Ref();
    private sealed virtual override Type JetBrains.Application.Table.Record.Ref.IRecordRef.get_TargetRecordType();
    public virtual string ToString();
    public sealed virtual bool Equals(AttributeRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AttributeRef left, AttributeRef right);
    public static bool op_Inequality(AttributeRef left, AttributeRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.Ref.AttributeRef>.CompareTo(AttributeRef other);
}
public interface JetBrains.Application.Table.Record.Ref.IRecordRef {
    public ARef Ref { get; }
    public Type TargetRecordType { get; }
    public abstract virtual ARef get_Ref();
    public abstract virtual Type get_TargetRecordType();
}
public class JetBrains.Application.Table.Record.Ref.StringRef : ValueType {
    public UInt32 Rva;
    public StringRef(UInt32 rva);
    public virtual string ToString();
    public sealed virtual bool Equals(StringRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(StringRef left, StringRef right);
    public static bool op_Inequality(StringRef left, StringRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.Ref.StringRef>.CompareTo(StringRef other);
}
public class JetBrains.Application.Table.Record.Ref.TypeRef : ValueType {
    public ARef Ref;
    private ARef JetBrains.Application.Table.Record.Ref.IRecordRef.Ref { get; }
    private Type JetBrains.Application.Table.Record.Ref.IRecordRef.TargetRecordType { get; }
    public TypeRef(UInt32 index);
    private sealed virtual override ARef JetBrains.Application.Table.Record.Ref.IRecordRef.get_Ref();
    private sealed virtual override Type JetBrains.Application.Table.Record.Ref.IRecordRef.get_TargetRecordType();
    public virtual string ToString();
    public sealed virtual bool Equals(TypeRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TypeRef left, TypeRef right);
    public static bool op_Inequality(TypeRef left, TypeRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.Ref.TypeRef>.CompareTo(TypeRef other);
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.StringRecordHeader : ValueType {
    public OWORD Hash;
    public UInt32 CchLength;
    public UInt32 MagicBom;
    [FixedBufferAttribute("System.UInt16", "1")]
public <wsz>e__FixedBuffer wsz;
    public static UInt32 MagicBomValue;
    public StringRecordHeader(OWORD hash, UInt32 cchLength);
    public StringRecordHeader(string s);
    private static StringRecordHeader();
    public static OWORD CalculateHash(string text);
    public sealed virtual bool Equals(StringRecordHeader other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(StringRecordHeader left, StringRecordHeader right);
    public static bool op_Inequality(StringRecordHeader left, StringRecordHeader right);
}
public class JetBrains.Application.Table.Record.TableHeader : ValueType {
    public static int cchTableName;
    public static int cchPodTableRecordTypeAqn;
    public UInt32 rva;
    public UInt32 cbSize;
    [FixedBufferAttribute("System.UInt16", "32")]
public <wszTableName>e__FixedBuffer wszTableName;
    [FixedBufferAttribute("System.UInt16", "256")]
public <wszPodTableRecordTypeAqn>e__FixedBuffer wszPodTableRecordTypeAqn;
    public ushort cbPodTableRecordSize;
    public static void SetCustomTable(TableHeader* thіs, long rva, long cbSize, string name);
    public static void SetPodTable(TableHeader* thіs, long rva, long cbSize, string name, string sPodTableRecordTypeAqn, int cbPodTableRecordSize);
    public bool TableNameEquals(string candidate);
    [NotNullAttribute]
public string CreateTableNameString();
    [NotNullAttribute]
public string CreatePodTableRecordTypeAqn();
    [NotNullAttribute]
public static string GetPodTableNameFromRecordType();
    [NotNullAttribute]
public static string GetPodTableNameFromRecordType(Type type);
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.TraitNameRecord : ValueType {
    public StringRef Namespace;
    public StringRef LocalName;
    public sealed virtual bool Equals(TraitNameRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TraitNameRecord left, TraitNameRecord right);
    public static bool op_Inequality(TraitNameRecord left, TraitNameRecord right);
    public virtual string ToString();
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.TypeListRecord : ValueType {
    public TypeRef Item;
    public static string AllPartTypesListRangeBlobName;
    private ARef JetBrains.Application.Table.Record.Ref.IRecordRef.Ref { get; }
    private Type JetBrains.Application.Table.Record.Ref.IRecordRef.TargetRecordType { get; }
    public TypeListRecord(TypeRef item);
    private static TypeListRecord();
    public sealed virtual bool Equals(TypeListRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TypeListRecord left, TypeListRecord right);
    public static bool op_Inequality(TypeListRecord left, TypeListRecord right);
    private sealed virtual override ARef JetBrains.Application.Table.Record.Ref.IRecordRef.get_Ref();
    private sealed virtual override Type JetBrains.Application.Table.Record.Ref.IRecordRef.get_TargetRecordType();
    public virtual string ToString();
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.TypeListRecord>.CompareTo(TypeListRecord other);
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.TypeRecord : ValueType {
    public StringRef FullName;
    public AssemblyRef Assembly;
    public AttributeRangeRef Attributes;
    public TypeListRangeRef BaseTypes;
    public TypeListRangeRef ExtraTypes;
    public UInt32 MetadataToken;
    public MemberRangeRef Members;
    public PartCatalogTypeKind TypeKind;
    public sealed virtual bool Equals(TypeRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TypeRecord left, TypeRecord right);
    public static bool op_Inequality(TypeRecord left, TypeRecord right);
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.TypeTraitBankRecord : ValueType {
    public Bitmask64 Bitmask;
    public sealed virtual bool Equals(TypeTraitBankRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TypeTraitBankRecord left, TypeTraitBankRecord right);
    public static bool op_Inequality(TypeTraitBankRecord left, TypeTraitBankRecord right);
    public virtual string ToString();
}
public class JetBrains.Application.Table.TablePartCatalogCollectionSourceOwner : object {
    private Int32[] myAttributeTypeSkipList;
    [CanBeNullAttribute]
private IPartCatalogFilter myFilter;
    private FilterStatus myFilterStatus;
    [CanBeNullAttribute]
private IPartCatalogFilter myNonTraitFilter;
    private TablePartCatalogStorage myStorage;
    private TraitMaskBanksAndOperations myTraitMasks;
    [NotNullAttribute]
private CatalogTables Tables;
    private static TablePartCatalogCollectionSourceOwner();
    public TablePartCatalogCollectionSourceOwner(TablePartCatalogStorage storage, IPartCatalogFilter filter);
    public CollectionSource`1<PartCatalogAssembly> CreateAssemblies(ARangeRef range);
    public CollectionSource`1<PartCatalogAttributeArgument> CreateAttributeArguments(ARangeRef range);
    public CollectionSource`1<PartCatalogAttribute> CreateAttributes(ARangeRef range, Type typeFilter);
    public CollectionSource`1<PartCatalogTypeMember> CreateTypeMembers(ARangeRef range);
    public CollectionSource`1<PartCatalogType> CreateTypes(TypeListRangeRef range, bool isFiltering, bool isOwnTypesOnly);
    private static FilterStatus AssessFilterStatus(CatalogTables tables, IPartCatalogFilter originalfilter, IPartCatalogFilter& nontraitfilter, TraitMaskBanksAndOperations& traitmasks);
    private sealed virtual override void JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.EnumeratorDispose(Enumerator& instance);
    private sealed virtual override void JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.EnumeratorDispose(Enumerator& instance);
    private sealed virtual override void JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.EnumeratorDispose(Enumerator& instance);
    private sealed virtual override void JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.EnumeratorDispose(Enumerator& instance);
    private sealed virtual override void JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.EnumeratorDispose(Enumerator& instance);
    private sealed virtual override PartCatalogType JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.EnumeratorGetCurrent(Enumerator& instance);
    private sealed virtual override PartCatalogTypeMember JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.EnumeratorGetCurrent(Enumerator& instance);
    private sealed virtual override PartCatalogAttribute JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.EnumeratorGetCurrent(Enumerator& instance);
    private sealed virtual override PartCatalogAssembly JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.EnumeratorGetCurrent(Enumerator& instance);
    private sealed virtual override PartCatalogAttributeArgument JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.EnumeratorGetCurrent(Enumerator& instance);
    private static int EnumeratorGetValidIndex(CollectionSourcePodData& collectionSourcePodData);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.EnumeratorMoveNext(Enumerator& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.EnumeratorMoveNext(Enumerator& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.EnumeratorMoveNext(Enumerator& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.EnumeratorMoveNext(Enumerator& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.EnumeratorMoveNext(Enumerator& instance);
    private static bool EnumeratorMoveNextSimple(CollectionSourcePodData& data);
    [NotNullAttribute]
private Int32[] GetAttributeTypeSkipList(PartCatalogType pctypeSomeAttr);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.GetCount(CollectionSource`1& instance);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.GetCount(CollectionSource`1& instance);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.GetCount(CollectionSource`1& instance);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.GetCount(CollectionSource`1& instance);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.GetCount(CollectionSource`1& instance);
    private static UInt32 GetCountSimple(CollectionSourcePodData& data);
    private sealed virtual override Enumerator<PartCatalogType> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.GetEnumerator(CollectionSource`1& instance);
    private sealed virtual override Enumerator<PartCatalogTypeMember> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.GetEnumerator(CollectionSource`1& instance);
    private sealed virtual override Enumerator<PartCatalogAttribute> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.GetEnumerator(CollectionSource`1& instance);
    private sealed virtual override Enumerator<PartCatalogAssembly> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.GetEnumerator(CollectionSource`1& instance);
    private sealed virtual override Enumerator<PartCatalogAttributeArgument> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.GetEnumerator(CollectionSource`1& instance);
    private static CollectionSourcePodData GetEnumeratorSimple(CollectionSourcePodData& dpColl);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.GetIsFastCount(CollectionSource`1& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.GetIsFastCount(CollectionSource`1& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.GetIsFastCount(CollectionSource`1& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.GetIsFastCount(CollectionSource`1& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.GetIsFastCount(CollectionSource`1& instance);
    private static bool IsFilteringByTypeTraits(CollectionSource`1& instance);
    private sealed virtual override PartCatalogType[] JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.ToArray(CollectionSource`1& instance);
    private sealed virtual override PartCatalogTypeMember[] JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.ToArray(CollectionSource`1& instance);
    private sealed virtual override PartCatalogAttribute[] JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.ToArray(CollectionSource`1& instance);
    private sealed virtual override PartCatalogAssembly[] JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.ToArray(CollectionSource`1& instance);
    private sealed virtual override PartCatalogAttributeArgument[] JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.ToArray(CollectionSource`1& instance);
    private sealed virtual override ICollection`1<PartCatalogType> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.ToCollection(CollectionSource`1& instance);
    private sealed virtual override ICollection`1<PartCatalogTypeMember> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.ToCollection(CollectionSource`1& instance);
    private sealed virtual override ICollection`1<PartCatalogAttribute> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.ToCollection(CollectionSource`1& instance);
    private sealed virtual override ICollection`1<PartCatalogAssembly> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.ToCollection(CollectionSource`1& instance);
    private sealed virtual override ICollection`1<PartCatalogAttributeArgument> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.ToCollection(CollectionSource`1& instance);
    private sealed virtual override IEnumerable`1<PartCatalogType> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.ToEnumerable(CollectionSource`1& instance);
    private sealed virtual override IEnumerable`1<PartCatalogTypeMember> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.ToEnumerable(CollectionSource`1& instance);
    private sealed virtual override IEnumerable`1<PartCatalogAttribute> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.ToEnumerable(CollectionSource`1& instance);
    private sealed virtual override IEnumerable`1<PartCatalogAssembly> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.ToEnumerable(CollectionSource`1& instance);
    private sealed virtual override IEnumerable`1<PartCatalogAttributeArgument> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.ToEnumerable(CollectionSource`1& instance);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.ToString(CollectionSource`1& instance);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.ToString(CollectionSource`1& instance);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.ToString(CollectionSource`1& instance);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.ToString(CollectionSource`1& instance);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.ToString(CollectionSource`1& instance);
}
public class JetBrains.Application.Table.TablePartCatalogGroupStorage : object {
    private static Func`2<Struct1, TablePartCatalogStorage[]> myDelegate1;
    private static Func`2<TablePartCatalogStorage, IDictionary`2<Pair`2<StringSource, StringSource>, Int32`1<CatalogTypeToken>>> myDelegate2;
    [CanBeNullAttribute]
private IDictionary`2<AssemblyNameInfo, Pair`2<PartCatalogAssembly, TablePartCatalogStorage>> myMapPrimaryAssemblyByName;
    private ConcurrentDictionary`2<TablePartCatalogStorage, IDictionary`2<Pair`2<StringSource, StringSource>, Int32`1<CatalogTypeToken>>> myMapStorageTypeNames;
    [CanBeNullAttribute]
public IPartCatalogFilter Filter;
    [NotNullAttribute]
public IAssemblyMasterBinder MasterBinder;
    public LocalLazy`2<TablePartCatalogStorage[], Struct1> Storages;
    [NotNullAttribute]
public CatalogTables[] Tables;
    public TablePartCatalogGroupStorage(CatalogTables[] tables, IPartCatalogFilter filter, IAssemblyMasterBinder masterbinder);
    private static TablePartCatalogGroupStorage();
    public sealed virtual StringSource AssemblyGetSimpleName(Int32`1<CatalogAssemblyToken> token);
    public sealed virtual CollectionSource`1<PartCatalogType> GlobalGetAllPartTypes();
    private sealed virtual override IPartCatalogStorage JetBrains.Application.Catalogs.IPartCatalogStorage.ApplyFilter(IPartCatalogFilter filter);
    private sealed virtual override IAssemblyBinder JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetBinder(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetFullName(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override int JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetHashCode(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override AssemblyNameInfo JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetNameInfo(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttribute> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetPartAttributes(Int32`1<CatalogAssemblyToken> token, Type typeFilter);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetPartTypes(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAssembly> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetReferencedAssemblies(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override bool JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyIsCataloged(Int32`1<CatalogAssemblyToken> int32);
    private sealed virtual override object JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetBoxedValue(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override PartCatalogAttributeArgumentDisposition JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetDisposition(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetName(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override ulong JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetPrimitiveValue(Int32`1<CatalogAttributeArgumentToken> token, Nullable`1<AttributeArgumentValueElementType> typeExpected);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetStringValue(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetTypeValue(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override AttributeArgumentValueElementType JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetValueElementType(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttributeArgument> JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetArguments(Int32`1<CatalogAttributeToken> token);
    private sealed virtual override object JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetInstance(Int32`1<CatalogAttributeToken> token, OnError onerror);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetType(Int32`1<CatalogAttributeToken> token);
    private sealed virtual override Nullable`1<PartCatalogAttributeArgument> JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeTryGetArgumentByName(Int32`1<CatalogAttributeToken> token, string name);
    private sealed virtual override Nullable`1<CollectionSource`1<PartCatalogType>> JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeTryGetConstructorFormalParameterTypes(Int32`1<CatalogAttributeToken> token);
    [NotNullAttribute]
private IDictionary`2<AssemblyNameInfo, Pair`2<PartCatalogAssembly, TablePartCatalogStorage>> GetMapAssemblyToStorage();
    internal PartCatalogAssembly GetPrimaryPartCatalogAssembly(PartCatalogAssembly pcass);
    internal PartCatalogType GetPrimaryPartCatalogType(PartCatalogType pctype);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.GetTypeLocalName(Int32`1<CatalogTypeToken> token);
    [IteratorStateMachineAttribute("JetBrains.Application.Table.TablePartCatalogGroupStorage/<GlobalGetAllPartTypesEnum>d__36")]
[NotNullAttribute]
private IEnumerable`1<PartCatalogType> GlobalGetAllPartTypesEnum();
    private sealed virtual override CollectionSource`1<PartCatalogAssembly> JetBrains.Application.Catalogs.IPartCatalogStorage.GlobalGetCatalogedAssemblies();
    [IteratorStateMachineAttribute("JetBrains.Application.Table.TablePartCatalogGroupStorage/<GlobalGetCatalogedAssembliesEnum>d__38")]
[NotNullAttribute]
private IEnumerable`1<PartCatalogAssembly> GlobalGetCatalogedAssembliesEnum();
    private sealed virtual override MemberInfo JetBrains.Application.Catalogs.IPartCatalogStorage.MemberBind(Int32`1<CatalogMemberToken> token);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetDeclaringType(Int32`1<CatalogMemberToken> token);
    private sealed virtual override int JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetHashCode(Int32`1<CatalogMemberToken> token);
    private sealed virtual override PartCatalogTypeMemberKind JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetKind(Int32`1<CatalogMemberToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetName(Int32`1<CatalogMemberToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetParameterTypes(Int32`1<CatalogMemberToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttribute> JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetPartAttributes(Int32`1<CatalogMemberToken> token, Type typeFilter);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetValueType(Int32`1<CatalogMemberToken> token);
    private sealed virtual override Type JetBrains.Application.Catalogs.IPartCatalogStorage.TypeBind(Int32`1<CatalogTypeToken> token);
    private sealed virtual override bool JetBrains.Application.Catalogs.IPartCatalogStorage.TypeEqualsRuntimeType(Int32`1<CatalogTypeToken> token, Type typeRuntime);
    private sealed virtual override PartCatalogAssembly JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetAssembly(Int32`1<CatalogTypeToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetAssemblyQualifiedName(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetBaseTypes(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetExtraTypes(Int32`1<CatalogTypeToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetFullName(Int32`1<CatalogTypeToken> token);
    private sealed virtual override int JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetHashCode(Int32`1<CatalogTypeToken> token);
    private sealed virtual override PartCatalogTypeKind JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetKind(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttribute> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetPartAttributes(Int32`1<CatalogTypeToken> token, Type typeFilter);
    private sealed virtual override CollectionSource`1<PartCatalogTypeMember> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetPartMembers(Int32`1<CatalogTypeToken> token);
    private sealed virtual override Type JetBrains.Application.Catalogs.IPartCatalogStorage.TypeTryGetBoundType(Int32`1<CatalogTypeToken> token);
}
public class JetBrains.Application.Table.TablePartCatalogStorage : object {
    private static Func`3<Int32`1<CatalogAssemblyToken>, TablePartCatalogStorage, IAssemblyBinder> ourDelegateABs;
    private static Func`3<Int32`1<CatalogTypeToken>, TablePartCatalogStorage, Type> ourDelegateTBs;
    private FrugalLocalLazy`1<ConcurrentDictionary`2<Int32`1<CatalogAssemblyToken>, IAssemblyBinder>> myCacheAssemblyBinders;
    private FrugalLocalLazy`1<ConcurrentDictionary`2<Int32`1<CatalogTypeToken>, Type>> myCacheBoundTypes;
    [CanBeNullAttribute]
private TablePartCatalogCollectionSourceOwner myCollectionSourceOwner;
    [CanBeNullAttribute]
private IPartCatalogFilter myFilter;
    [CanBeNullAttribute]
private TablePartCatalogGroupStorage myGroup;
    [NotNullAttribute]
public IAssemblyMasterBinder MasterBinder;
    [NotNullAttribute]
public CatalogTables Tables;
    [NotNullAttribute]
private TablePartCatalogCollectionSourceOwner CollectionSourceOwner { get; }
    public TablePartCatalogStorage(CatalogTables tables, IPartCatalogFilter filter, IAssemblyMasterBinder masterbinder);
    internal TablePartCatalogStorage(CatalogTables tables, IPartCatalogFilter filter, IAssemblyMasterBinder masterbinder, TablePartCatalogGroupStorage group);
    private static TablePartCatalogStorage();
    public sealed virtual IPartCatalogStorage ApplyFilter(IPartCatalogFilter filter);
    public sealed virtual IAssemblyBinder AssemblyGetBinder(Int32`1<CatalogAssemblyToken> token);
    public sealed virtual StringSource AssemblyGetFullName(Int32`1<CatalogAssemblyToken> token);
    public sealed virtual int AssemblyGetHashCode(Int32`1<CatalogAssemblyToken> token);
    public sealed virtual AssemblyNameInfo AssemblyGetNameInfo(Int32`1<CatalogAssemblyToken> token);
    public sealed virtual CollectionSource`1<PartCatalogAttribute> AssemblyGetPartAttributes(Int32`1<CatalogAssemblyToken> token, Type typeFilter);
    public sealed virtual CollectionSource`1<PartCatalogType> AssemblyGetPartTypes(Int32`1<CatalogAssemblyToken> token);
    public sealed virtual StringSource AssemblyGetSimpleName(Int32`1<CatalogAssemblyToken> token);
    public sealed virtual object AttributeArgumentGetBoxedValue(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual PartCatalogAttributeArgumentDisposition AttributeArgumentGetDisposition(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual StringSource AttributeArgumentGetName(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual ulong AttributeArgumentGetPrimitiveValue(Int32`1<CatalogAttributeArgumentToken> token, Nullable`1<AttributeArgumentValueElementType> typeExpected);
    public sealed virtual StringSource AttributeArgumentGetStringValue(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual PartCatalogType AttributeArgumentGetTypeValue(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual AttributeArgumentValueElementType AttributeArgumentGetValueElementType(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual CollectionSource`1<PartCatalogAttributeArgument> AttributeGetArguments(Int32`1<CatalogAttributeToken> token);
    public sealed virtual object AttributeGetInstance(Int32`1<CatalogAttributeToken> token, OnError onerror);
    public sealed virtual PartCatalogType AttributeGetType(Int32`1<CatalogAttributeToken> token);
    public sealed virtual Nullable`1<PartCatalogAttributeArgument> AttributeTryGetArgumentByName(Int32`1<CatalogAttributeToken> token, string name);
    public sealed virtual Nullable`1<CollectionSource`1<PartCatalogType>> AttributeTryGetConstructorFormalParameterTypes(Int32`1<CatalogAttributeToken> token);
    public sealed virtual StringSource GetTypeLocalName(Int32`1<CatalogTypeToken> token);
    public sealed virtual CollectionSource`1<PartCatalogType> GlobalGetAllPartTypes();
    public sealed virtual CollectionSource`1<PartCatalogAssembly> GlobalGetCatalogedAssemblies();
    public sealed virtual MemberInfo MemberBind(Int32`1<CatalogMemberToken> token);
    public sealed virtual PartCatalogType MemberGetDeclaringType(Int32`1<CatalogMemberToken> token);
    public sealed virtual int MemberGetHashCode(Int32`1<CatalogMemberToken> token);
    public sealed virtual PartCatalogTypeMemberKind MemberGetKind(Int32`1<CatalogMemberToken> token);
    public sealed virtual StringSource MemberGetName(Int32`1<CatalogMemberToken> token);
    public sealed virtual CollectionSource`1<PartCatalogType> MemberGetParameterTypes(Int32`1<CatalogMemberToken> token);
    public sealed virtual CollectionSource`1<PartCatalogAttribute> MemberGetPartAttributes(Int32`1<CatalogMemberToken> token, Type typeFilter);
    public sealed virtual PartCatalogType MemberGetValueType(Int32`1<CatalogMemberToken> token);
    public sealed virtual Type TypeBind(Int32`1<CatalogTypeToken> token);
    public sealed virtual bool TypeEqualsRuntimeType(Int32`1<CatalogTypeToken> token, Type typeRuntime);
    public sealed virtual PartCatalogAssembly TypeGetAssembly(Int32`1<CatalogTypeToken> token);
    public sealed virtual StringSource TypeGetAssemblyQualifiedName(Int32`1<CatalogTypeToken> token);
    public sealed virtual CollectionSource`1<PartCatalogType> TypeGetBaseTypes(Int32`1<CatalogTypeToken> token);
    public sealed virtual CollectionSource`1<PartCatalogType> TypeGetExtraTypes(Int32`1<CatalogTypeToken> token);
    public sealed virtual StringSource TypeGetFullName(Int32`1<CatalogTypeToken> token);
    public sealed virtual int TypeGetHashCode(Int32`1<CatalogTypeToken> token);
    public sealed virtual PartCatalogTypeKind TypeGetKind(Int32`1<CatalogTypeToken> token);
    public sealed virtual CollectionSource`1<PartCatalogAttribute> TypeGetPartAttributes(Int32`1<CatalogTypeToken> token, Type typeFilter);
    public sealed virtual CollectionSource`1<PartCatalogTypeMember> TypeGetPartMembers(Int32`1<CatalogTypeToken> token);
    public sealed virtual Type TypeTryGetBoundType(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAssembly> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetReferencedAssemblies(Int32`1<CatalogAssemblyToken> token);
    private static CollectionSource`1<PartCatalogType> AssemblyGetTypesWithTraits(Int32`1<CatalogAssemblyToken> token, TraitMaskBanksAndOperations traitmasks, CatalogTables tables, IPartCatalogStorage storage);
    private sealed virtual override bool JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyIsCataloged(Int32`1<CatalogAssemblyToken> token);
    private static bool CollectionSourceEquals(CollectionSource`1<TItem> p, CollectionSource`1<TItem> q);
    private TablePartCatalogCollectionSourceOwner get_CollectionSourceOwner();
    private static int EnumerableCompareTo(IEnumerable`1<TItem> p, IEnumerable`1<TItem> q);
    private CollectionSource`1<PartCatalogAttribute> GetAttributesCore(AttributeRangeRef range, Type typeFilter);
    private PartCatalogAssembly GetPartAssembly(Int32`1<CatalogAssemblyToken> token);
    internal PartCatalogType GetPartType(Int32`1<CatalogTypeToken> token);
    private StringSource GetStringSource(StringRef aref);
    private bool TypeEqualsRuntimeType_NamesCheck(Int32`1<CatalogTypeToken> token, Type typeRuntime);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
