[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.AssemblyReference : ValueType {
    [CompilerGeneratedAttribute]
private MetadataToken <AssemblyReferenceToken>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyNameInfo <AssemblyName>k__BackingField;
    public MetadataToken AssemblyReferenceToken { get; }
    [NotNullAttribute]
public AssemblyNameInfo AssemblyName { get; }
    public AssemblyReference(MetadataToken assemblyReferenceToken, AssemblyNameInfo assemblyName);
    [CompilerGeneratedAttribute]
public MetadataToken get_AssemblyReferenceToken();
    [CompilerGeneratedAttribute]
public AssemblyNameInfo get_AssemblyName();
    public bool Equals(AssemblyReference other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.AssemblyRefProperties : ValueType {
    [CompilerGeneratedAttribute]
private ushort <MajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <BuildNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <RevisionNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlob <PublicKeyOrTokenBlob>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlob <HashValueBlob>k__BackingField;
    public ushort MajorVersion { get; }
    public ushort MinorVersion { get; }
    public ushort BuildNumber { get; }
    public ushort RevisionNumber { get; }
    public UInt32 Flags { get; }
    [CanBeNullAttribute]
public IBlob PublicKeyOrTokenBlob { get; }
    [NotNullAttribute]
public string Name { get; }
    [CanBeNullAttribute]
public string Culture { get; }
    [CanBeNullAttribute]
public IBlob HashValueBlob { get; }
    public AssemblyRefProperties(ushort majorVersion, ushort minorVersion, ushort buildNumber, ushort revisionNumber, UInt32 flags, IBlob publicKeyOrTokenBlob, string name, string culture, IBlob hashValueBlob);
    [CompilerGeneratedAttribute]
public ushort get_MajorVersion();
    [CompilerGeneratedAttribute]
public ushort get_MinorVersion();
    [CompilerGeneratedAttribute]
public ushort get_BuildNumber();
    [CompilerGeneratedAttribute]
public ushort get_RevisionNumber();
    [CompilerGeneratedAttribute]
public UInt32 get_Flags();
    [CompilerGeneratedAttribute]
public IBlob get_PublicKeyOrTokenBlob();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Culture();
    [CompilerGeneratedAttribute]
public IBlob get_HashValueBlob();
}
public class JetBrains.Metadata.Access.AttributeFlag : AttributeMask {
    public AttributeFlag(ulong mask, string name, string description);
    public bool IsSet(ulong value);
    public virtual string Present(ulong value);
}
public abstract class JetBrains.Metadata.Access.AttributeMask : AttributeValue {
    protected AttributeMask(ulong mask, string name, string description);
    public abstract virtual string Present(ulong value);
}
public class JetBrains.Metadata.Access.AttributeOption : AttributeValue {
    public AttributeOption(ulong mask, string name, string description);
}
public class JetBrains.Metadata.Access.AttributeOptionsMask : AttributeMask {
    internal static ulong NoMask;
    [CompilerGeneratedAttribute]
private AttributeOption[] <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FlagLikeOptions>k__BackingField;
    public bool IsNoMask { get; }
    public AttributeOption[] Options { get; }
    public bool FlagLikeOptions { get; }
    public AttributeOptionsMask(ulong mask, string name, string description, AttributeOption[] options, bool flagLikeOptions);
    public bool get_IsNoMask();
    [CompilerGeneratedAttribute]
public AttributeOption[] get_Options();
    [CompilerGeneratedAttribute]
public bool get_FlagLikeOptions();
    public ulong GetMaskedValue(ulong value);
    public bool IsChecked(ulong value, AttributeOption option);
    public virtual string Present(ulong value);
    public string PresentCheckedOptions(ulong value);
}
public class JetBrains.Metadata.Access.AttributesStructure : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private AttributeMask[] <Structure>k__BackingField;
    public static string Reserved;
    public static AttributesStructure TypeAttributes;
    public static AttributesStructure FieldAttributes;
    public static AttributesStructure MethodImplAttributes;
    public static AttributesStructure MethodAttributes;
    public static AttributesStructure ParamAttributes;
    public static AttributesStructure EventAttributes;
    public static AttributesStructure PropertyAttributes;
    public static AttributesStructure MethodSemanticsAttributes;
    public static AttributesStructure PInvokeAttributes;
    public static AttributesStructure EncLogFuncCodeAttributes;
    public static AttributesStructure AssemblyHashAlgorithmAttributes;
    public static AttributesStructure AssemblyFlagsAttributes;
    public static AttributesStructure FileAttributes;
    public static AttributesStructure ManifestResourceAttributes;
    public static AttributesStructure GenericParamAttributes;
    public static AttributesStructure LocalVariableAttributes;
    public static AttributesStructure FileHeaderMachineAttributes;
    public static AttributesStructure FileHeaderSizeOfOptionalHeaderAttributes;
    public static AttributesStructure FileHeaderCharacteristicsAttributes;
    public static AttributesStructure OptionalHeaderMagicAttributes;
    public static AttributesStructure OptionalHeaderSubsystemAttributes;
    public static AttributesStructure OptionalHeaderDllCharacteristicsAttributes;
    public static AttributesStructure SectionHeaderCharacteristicsAttributes;
    public static AttributesStructure CliHeaderFlagsAttributes;
    public static AttributesStructure R2RFlagsAttributes;
    public static AttributesStructure R2RInstructionSetAttributes;
    public static AttributesStructure BundleHeaderFlagsAttributes;
    public static AttributesStructure BundleFileTypeAttributes;
    public static AttributesStructure TablesHeaderHeapOffsetSizesAttributes;
    private static AttributeMask[] ourMetadataTableFlags;
    public static AttributesStructure TablesHeaderMaskValidAttributes;
    public static AttributesStructure TablesHeaderMaskSortedAttributes;
    public string Name { get; }
    public AttributeMask[] Structure { get; }
    [CanBeNullAttribute]
public AttributeOptionsMask OptionsWithoutMask { get; }
    private AttributesStructure(string name, AttributeMask[] structure);
    private static AttributesStructure();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public AttributeMask[] get_Structure();
    public AttributeOptionsMask get_OptionsWithoutMask();
    public string Present(ulong value);
    private static IEnumerable`1<AttributeOption> CreateMachineOsNiList();
    private static AttributeOption CreateMachineOsNi(MachineId machineId, MachineIdOsOverride osOverride);
}
public abstract class JetBrains.Metadata.Access.AttributeValue : object {
    [CompilerGeneratedAttribute]
private ulong <Mask>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public ulong Mask { get; }
    public string Name { get; }
    public string Description { get; }
    protected AttributeValue(ulong mask, string name, string description);
    [CompilerGeneratedAttribute]
public ulong get_Mask();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Description();
}
public class JetBrains.Metadata.Access.ClassLayout : object {
    public static ClassLayout Empty;
    [CompilerGeneratedAttribute]
private ReadOnlyDictionary`2<MetadataToken, int> <FieldOffsets>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PackingSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ClassSize>k__BackingField;
    [NotNullAttribute]
public ReadOnlyDictionary`2<MetadataToken, int> FieldOffsets { get; }
    public int PackingSize { get; }
    public int ClassSize { get; }
    public ClassLayout(int packingSize, int classSize, IDictionary`2<MetadataToken, int> fieldOffsets);
    private static ClassLayout();
    [CompilerGeneratedAttribute]
public ReadOnlyDictionary`2<MetadataToken, int> get_FieldOffsets();
    [CompilerGeneratedAttribute]
public int get_PackingSize();
    [CompilerGeneratedAttribute]
public int get_ClassSize();
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorEventAttr : Enum {
    public int value__;
    public static CorEventAttr evSpecialName;
    public static CorEventAttr evReservedMask;
    public static CorEventAttr evRTSpecialName;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorFieldAttr : Enum {
    public int value__;
    public static CorFieldAttr fdFieldAccessMask;
    public static CorFieldAttr fdCompilerControlled;
    public static CorFieldAttr fdPrivate;
    public static CorFieldAttr fdFamANDAssem;
    public static CorFieldAttr fdAssembly;
    public static CorFieldAttr fdFamily;
    public static CorFieldAttr fdFamORAssem;
    public static CorFieldAttr fdPublic;
    public static CorFieldAttr fdStatic;
    public static CorFieldAttr fdInitOnly;
    public static CorFieldAttr fdLiteral;
    public static CorFieldAttr fdNotSerialized;
    public static CorFieldAttr fdSpecialName;
    public static CorFieldAttr fdPInvokeImpl;
    public static CorFieldAttr fdReservedMask;
    public static CorFieldAttr fdRTSpecialName;
    public static CorFieldAttr fdHasFieldMarshal;
    public static CorFieldAttr fdHasDefault;
    public static CorFieldAttr fdHasFieldRVA;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorFileFlags : Enum {
    public int value__;
    public static CorFileFlags ffContainsMetaData;
    public static CorFileFlags ffContainsNoMetaData;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorGenericParamAttr : Enum {
    public int value__;
    public static CorGenericParamAttr gpVarianceMask;
    public static CorGenericParamAttr gpNonVariant;
    public static CorGenericParamAttr gpCovariant;
    public static CorGenericParamAttr gpContravariant;
    public static CorGenericParamAttr gpSpecialConstraintMask;
    public static CorGenericParamAttr gpNoSpecialConstraint;
    public static CorGenericParamAttr gpReferenceTypeConstraint;
    public static CorGenericParamAttr gpValueTypeConstraint;
    public static CorGenericParamAttr gpDefaultConstructorConstraint;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorMethodAttr : Enum {
    public int value__;
    public static CorMethodAttr mdMemberAccessMask;
    public static CorMethodAttr mdCompilerControlled;
    public static CorMethodAttr mdPrivate;
    public static CorMethodAttr mdFamANDAssem;
    public static CorMethodAttr mdAssem;
    public static CorMethodAttr mdFamily;
    public static CorMethodAttr mdFamORAssem;
    public static CorMethodAttr mdPublic;
    public static CorMethodAttr mdStatic;
    public static CorMethodAttr mdFinal;
    public static CorMethodAttr mdVirtual;
    public static CorMethodAttr mdHideBySig;
    public static CorMethodAttr mdVtableLayoutMask;
    public static CorMethodAttr mdReuseSlot;
    public static CorMethodAttr mdNewSlot;
    public static CorMethodAttr mdStrict;
    public static CorMethodAttr mdAbstract;
    public static CorMethodAttr mdSpecialName;
    public static CorMethodAttr mdPInvokeImpl;
    public static CorMethodAttr mdUnmanagedExport;
    public static CorMethodAttr mdReservedMask;
    public static CorMethodAttr mdRTSpecialName;
    public static CorMethodAttr mdHasSecurity;
    public static CorMethodAttr mdRequireSecObject;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorMethodImpl : Enum {
    public int value__;
    public static CorMethodImpl miCodeTypeMask;
    public static CorMethodImpl miIL;
    public static CorMethodImpl miNative;
    public static CorMethodImpl miOPTIL;
    public static CorMethodImpl miRuntime;
    public static CorMethodImpl miManagedMask;
    public static CorMethodImpl miUnmanaged;
    public static CorMethodImpl miManaged;
    public static CorMethodImpl miForwardRef;
    public static CorMethodImpl miPreserveSig;
    public static CorMethodImpl miInternalCall;
    public static CorMethodImpl miSynchronized;
    public static CorMethodImpl miNoOptimization;
    public static CorMethodImpl miNoInlining;
    public static CorMethodImpl miAggressiveInlining;
    public static CorMethodImpl miAggressiveOptimization;
    public static CorMethodImpl miMaxMethodImplVal;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorMethodSemanticsAttr : Enum {
    public int value__;
    public static CorMethodSemanticsAttr msSetter;
    public static CorMethodSemanticsAttr msGetter;
    public static CorMethodSemanticsAttr msOther;
    public static CorMethodSemanticsAttr msAddOn;
    public static CorMethodSemanticsAttr msRemoveOn;
    public static CorMethodSemanticsAttr msFire;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorOpenFlags : Enum {
    public UInt32 value__;
    public static CorOpenFlags ofRead;
    public static CorOpenFlags ofWrite;
    public static CorOpenFlags ofReadWriteMask;
    public static CorOpenFlags ofCopyMemory;
    public static CorOpenFlags ofManifestMetadata;
    public static CorOpenFlags ofReadOnly;
    public static CorOpenFlags ofTakeOwnership;
    public static CorOpenFlags ofCacheImage;
    public static CorOpenFlags ofNoTypeLib;
    public static CorOpenFlags ofNoTransform;
    public static CorOpenFlags ofReserved1;
    public static CorOpenFlags ofReserved2;
    public static CorOpenFlags ofReserved;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorParamAttr : Enum {
    public int value__;
    public static CorParamAttr pdIn;
    public static CorParamAttr pdOut;
    public static CorParamAttr pdOptional;
    public static CorParamAttr pdReservedMask;
    public static CorParamAttr pdHasDefault;
    public static CorParamAttr pdHasFieldMarshal;
    public static CorParamAttr pdUnused;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorPInvokeMap : Enum {
    public int value__;
    public static CorPInvokeMap pmNoMangle;
    public static CorPInvokeMap pmCharSetMask;
    public static CorPInvokeMap pmCharSetNotSpec;
    public static CorPInvokeMap pmCharSetAnsi;
    public static CorPInvokeMap pmCharSetUnicode;
    public static CorPInvokeMap pmCharSetAuto;
    public static CorPInvokeMap pmBestFitUseAssem;
    public static CorPInvokeMap pmBestFitEnabled;
    public static CorPInvokeMap pmBestFitDisabled;
    public static CorPInvokeMap pmBestFitMask;
    public static CorPInvokeMap pmThrowOnUnmappableCharUseAssem;
    public static CorPInvokeMap pmThrowOnUnmappableCharEnabled;
    public static CorPInvokeMap pmThrowOnUnmappableCharDisabled;
    public static CorPInvokeMap pmThrowOnUnmappableCharMask;
    public static CorPInvokeMap pmSupportsLastError;
    public static CorPInvokeMap pmCallConvMask;
    public static CorPInvokeMap pmCallConvWinapi;
    public static CorPInvokeMap pmCallConvCdecl;
    public static CorPInvokeMap pmCallConvStdcall;
    public static CorPInvokeMap pmCallConvThiscall;
    public static CorPInvokeMap pmCallConvFastcall;
    public static CorPInvokeMap pmMaxValue;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorPropertyAttr : Enum {
    public int value__;
    public static CorPropertyAttr prSpecialName;
    public static CorPropertyAttr prReservedMask;
    public static CorPropertyAttr prRTSpecialName;
    public static CorPropertyAttr prHasDefault;
    public static CorPropertyAttr prUnused;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorThreadSafetyOptions : Enum {
    public int value__;
    public static CorThreadSafetyOptions MDThreadSafetyDefault;
    public static CorThreadSafetyOptions MDThreadSafetyOff;
    public static CorThreadSafetyOptions MDThreadSafetyOn;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorTypeAttr : Enum {
    public int value__;
    public static CorTypeAttr tdVisibilityMask;
    public static CorTypeAttr tdNestedMask;
    public static CorTypeAttr tdNotPublic;
    public static CorTypeAttr tdPublic;
    public static CorTypeAttr tdNestedPublic;
    public static CorTypeAttr tdNestedPrivate;
    public static CorTypeAttr tdNestedFamily;
    public static CorTypeAttr tdNestedAssembly;
    public static CorTypeAttr tdNestedFamANDAssem;
    public static CorTypeAttr tdNestedFamORAssem;
    public static CorTypeAttr tdLayoutMask;
    public static CorTypeAttr tdAutoLayout;
    public static CorTypeAttr tdSequentialLayout;
    public static CorTypeAttr tdExplicitLayout;
    public static CorTypeAttr tdClassSemanticsMask;
    public static CorTypeAttr tdClass;
    public static CorTypeAttr tdInterface;
    public static CorTypeAttr tdAbstract;
    public static CorTypeAttr tdSealed;
    public static CorTypeAttr tdSpecialName;
    public static CorTypeAttr tdImport;
    public static CorTypeAttr tdSerializable;
    public static CorTypeAttr tdWindowsRuntime;
    public static CorTypeAttr tdStringFormatMask;
    public static CorTypeAttr tdAnsiClass;
    public static CorTypeAttr tdUnicodeClass;
    public static CorTypeAttr tdAutoClass;
    public static CorTypeAttr tdCustomFormatClass;
    public static CorTypeAttr tdCustomStringFormatMask;
    public static CorTypeAttr tdBeforeFieldInit;
    public static CorTypeAttr tdForwarder;
    public static CorTypeAttr tdReservedMask;
    public static CorTypeAttr tdRTSpecialName;
    public static CorTypeAttr tdHasSecurity;
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.CustomAttributeProperties : ValueType {
    [CompilerGeneratedAttribute]
private MetadataToken <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlob <Value>k__BackingField;
    public MetadataToken Parent { get; }
    public MetadataToken Type { get; }
    public IBlob Value { get; }
    public CustomAttributeProperties(MetadataToken parent, MetadataToken type, IBlob value);
    [CompilerGeneratedAttribute]
public MetadataToken get_Parent();
    [CompilerGeneratedAttribute]
public MetadataToken get_Type();
    [CompilerGeneratedAttribute]
public IBlob get_Value();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.CustomDebugInformationProperties : ValueType {
    [CompilerGeneratedAttribute]
private MetadataToken <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlob <Value>k__BackingField;
    public MetadataToken Parent { get; }
    public Guid Kind { get; }
    public IBlob Value { get; }
    public CustomDebugInformationProperties(MetadataToken parent, Guid kind, IBlob value);
    [CompilerGeneratedAttribute]
public MetadataToken get_Parent();
    [CompilerGeneratedAttribute]
public Guid get_Kind();
    [CompilerGeneratedAttribute]
public IBlob get_Value();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.DeclSecurityProperties : ValueType {
    [CompilerGeneratedAttribute]
private ushort <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlob <PermissionSetBlob>k__BackingField;
    public ushort Action { get; }
    public IBlob PermissionSetBlob { get; }
    public DeclSecurityProperties(ushort action, IBlob permissionSetBlob);
    [CompilerGeneratedAttribute]
public ushort get_Action();
    [CompilerGeneratedAttribute]
public IBlob get_PermissionSetBlob();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.DocumentProperties : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Language>k__BackingField;
    public string Name { get; }
    public Guid HashAlgorithm { get; }
    public Byte[] Hash { get; }
    public Guid Language { get; }
    public DocumentProperties(string name, Guid hashAlgorithm, IBlob hash, Guid language);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Guid get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public Byte[] get_Hash();
    [CompilerGeneratedAttribute]
public Guid get_Language();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.EncLogProperties : ValueType {
    [CompilerGeneratedAttribute]
private MetadataToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private EditAndContinueOperation <FuncCode>k__BackingField;
    public MetadataToken Token { get; }
    public EditAndContinueOperation FuncCode { get; }
    public EncLogProperties(MetadataToken token, EditAndContinueOperation funcCode);
    [CompilerGeneratedAttribute]
public MetadataToken get_Token();
    [CompilerGeneratedAttribute]
public EditAndContinueOperation get_FuncCode();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.EncMapProperties : ValueType {
    [CompilerGeneratedAttribute]
private MetadataToken <Token>k__BackingField;
    public MetadataToken Token { get; }
    public EncMapProperties(MetadataToken token);
    [CompilerGeneratedAttribute]
public MetadataToken get_Token();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.EventProperties : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private CorEventAttr <EventFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <EventType>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <Adder>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <Remover>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <Raiser>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken[] <OtherMethods>k__BackingField;
    public string Name { get; }
    public MetadataToken DeclaringType { get; }
    public CorEventAttr EventFlags { get; }
    public MetadataToken EventType { get; }
    public MetadataToken Adder { get; }
    public MetadataToken Remover { get; }
    public MetadataToken Raiser { get; }
    public MetadataToken[] OtherMethods { get; }
    public EventProperties(string name, MetadataToken declaringType, CorEventAttr eventFlags, MetadataToken eventType, MetadataToken adder, MetadataToken remover, MetadataToken raiser, MetadataToken[] otherMethods);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public MetadataToken get_DeclaringType();
    [CompilerGeneratedAttribute]
public CorEventAttr get_EventFlags();
    [CompilerGeneratedAttribute]
public MetadataToken get_EventType();
    [CompilerGeneratedAttribute]
public MetadataToken get_Adder();
    [CompilerGeneratedAttribute]
public MetadataToken get_Remover();
    [CompilerGeneratedAttribute]
public MetadataToken get_Raiser();
    [CompilerGeneratedAttribute]
public MetadataToken[] get_OtherMethods();
}
public class JetBrains.Metadata.Access.ExportedTypeProperties : ValueType {
    [CompilerGeneratedAttribute]
private MetadataToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <Implementation>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <TypeDef>k__BackingField;
    [CompilerGeneratedAttribute]
private CorTypeAttr <ExportedTypeFlags>k__BackingField;
    public MetadataToken Token { get; }
    public string TypeName { get; }
    public string NamespaceName { get; }
    public MetadataToken Implementation { get; }
    public MetadataToken TypeDef { get; }
    public CorTypeAttr ExportedTypeFlags { get; }
    public ExportedTypeProperties(MetadataToken token, string typeName, string namespaceName, MetadataToken implementation, MetadataToken typeDef, CorTypeAttr exportedTypeFlags);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MetadataToken get_Token();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TypeName();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_NamespaceName();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MetadataToken get_Implementation();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MetadataToken get_TypeDef();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CorTypeAttr get_ExportedTypeFlags();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.FieldProperties : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private CorFieldAttr <FieldFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlob <SignatureBlob>k__BackingField;
    [CompilerGeneratedAttribute]
private ElementType <ConstantValueElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlob <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ValueLength>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Rva>k__BackingField;
    public string Name { get; }
    public MetadataToken DeclaringType { get; }
    public CorFieldAttr FieldFlags { get; }
    public IBlob SignatureBlob { get; }
    public ElementType ConstantValueElementType { get; }
    public IBlob Value { get; }
    public int ValueLength { get; }
    public UInt32 Rva { get; }
    public FieldProperties(string name, MetadataToken declaringType, CorFieldAttr fieldFlags, IBlob signatureBlob, ElementType constantValueElementType, IBlob value, int valueChars, UInt32 rva);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public MetadataToken get_DeclaringType();
    [CompilerGeneratedAttribute]
public CorFieldAttr get_FieldFlags();
    [CompilerGeneratedAttribute]
public IBlob get_SignatureBlob();
    [CompilerGeneratedAttribute]
public ElementType get_ConstantValueElementType();
    [CompilerGeneratedAttribute]
public IBlob get_Value();
    [CompilerGeneratedAttribute]
public int get_ValueLength();
    [CompilerGeneratedAttribute]
public UInt32 get_Rva();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.FileProperties : ValueType {
    [CompilerGeneratedAttribute]
private CorFileFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlob <HashValue>k__BackingField;
    public CorFileFlags Flags { get; }
    public string Name { get; }
    [CanBeNullAttribute]
public IBlob HashValue { get; }
    public FileProperties(CorFileFlags flags, string name, IBlob hashValue);
    [CompilerGeneratedAttribute]
public CorFileFlags get_Flags();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IBlob get_HashValue();
}
public class JetBrains.Metadata.Access.FileReference : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private CorFileFlags <FileFlags>k__BackingField;
    public string Name { get; }
    public MetadataToken Token { get; }
    public CorFileFlags FileFlags { get; }
    public FileReference(string name, MetadataToken token, CorFileFlags fileFlags);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MetadataToken get_Token();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CorFileFlags get_FileFlags();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.GenericParameterConstraintProperties : ValueType {
    [CompilerGeneratedAttribute]
private MetadataToken <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <Constraint>k__BackingField;
    public MetadataToken Owner { get; }
    public MetadataToken Constraint { get; }
    public GenericParameterConstraintProperties(MetadataToken owner, MetadataToken constraint);
    [CompilerGeneratedAttribute]
public MetadataToken get_Owner();
    [CompilerGeneratedAttribute]
public MetadataToken get_Constraint();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.GenericParameterProperties : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ParamIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private CorGenericParamAttr <GenericParameterAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataTokenRange <GenericParameterConstraints>k__BackingField;
    public string Name { get; }
    public UInt32 ParamIndex { get; }
    public MetadataToken Owner { get; }
    public CorGenericParamAttr GenericParameterAttributes { get; }
    public MetadataTokenRange GenericParameterConstraints { get; }
    public GenericParameterProperties(string name, UInt32 paramIndex, MetadataToken owner, CorGenericParamAttr attributes, MetadataTokenRange genericParameterConstraints);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public UInt32 get_ParamIndex();
    [CompilerGeneratedAttribute]
public MetadataToken get_Owner();
    [CompilerGeneratedAttribute]
public CorGenericParamAttr get_GenericParameterAttributes();
    [CompilerGeneratedAttribute]
public MetadataTokenRange get_GenericParameterConstraints();
}
public class JetBrains.Metadata.Access.HiddenAttributeOption : AttributeOption {
    public HiddenAttributeOption(ulong mask, string name, string description);
}
public interface JetBrains.Metadata.Access.ILowLevelMetadataStreamsAccess {
    public abstract virtual IEnumerable`1<byte> GetStringHeapBytes();
    public abstract virtual IEnumerable`1<byte> GetUserStringHeapBytes();
    public abstract virtual IEnumerable`1<byte> GetGuidHeapBytes();
    public abstract virtual IEnumerable`1<byte> GetBlobHeapBytes();
}
public static class JetBrains.Metadata.Access.ILReader.CodedTokenTables : object {
    private static Int32[] ourCodedTokenBits;
    private static MetadataTableId[] ourCustomAttributeType;
    private static MetadataTableId[] ourHasConstant;
    private static MetadataTableId[] ourHasCustomAttribute;
    private static MetadataTableId[] ourHasDeclSecurity;
    private static MetadataTableId[] ourHasFieldMarshal;
    private static MetadataTableId[] ourHasSemantic;
    private static MetadataTableId[] ourImplementation;
    private static MetadataTableId[] ourMemberForwarded;
    private static MetadataTableId[] ourMemberReferenceParent;
    private static MetadataTableId[] ourMethodOrMethodReference;
    private static MetadataTableId[] ourResolutionScope;
    private static MetadataTableId[] ourTypeOrMethodDef;
    private static MetadataTableId[] ourTypeOrTypeReference;
    private static MetadataTableId[] ourHasCustomDebugInformation;
    private static CodedTokenTables();
    public static int GetCodedTableId(EncodedTokenType type, MetadataTableId tableId);
    public static MetadataTableId[] CodedTokenList(EncodedTokenType type);
    public static UInt32 DecodeCodedToken(EncodedTokenType type, int data);
    public static UInt32 TokenToRawToken(MetadataToken token, MetadataTokenType targetFormat);
    public static int GetCodedTokenSize(EncodedTokenType type, Int32[] tableRows);
}
public enum JetBrains.Metadata.Access.ILReader.EncodedTokenType : Enum {
    public int value__;
    public static EncodedTokenType TypeDefOrRef;
    public static EncodedTokenType HasConstant;
    public static EncodedTokenType CustomAttributeType;
    public static EncodedTokenType HasSemantics;
    public static EncodedTokenType ResolutionScope;
    public static EncodedTokenType HasFieldMarshal;
    public static EncodedTokenType HasDeclSecurity;
    public static EncodedTokenType MemberRefParent;
    public static EncodedTokenType MethodDefOrRef;
    public static EncodedTokenType MemberForwarded;
    public static EncodedTokenType Implementation;
    public static EncodedTokenType HasCustomAttribute;
    public static EncodedTokenType TypeOrMethodDef;
    public static EncodedTokenType HasCustomDebugInformation;
    public static EncodedTokenType Max;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Access.ILReader.ExtensionMethods : object {
    [ExtensionAttribute]
[PureAttribute]
public static MetadataToken ToMetadataToken(UInt32 value);
    [ExtensionAttribute]
[PureAttribute]
public static EntityHandle ToEntityHandle(MetadataToken metadataToken);
    [ExtensionAttribute]
[PureAttribute]
public static MethodDefinitionHandle ToMethodDefinitionHandle(MetadataToken methodDefToken);
    [ExtensionAttribute]
[PureAttribute]
public static SymbolToken ToSymbolToken(MetadataToken metadataToken);
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.ILReader.HeapOffsetSizes : Enum {
    public byte value__;
    public static HeapOffsetSizes HeapString4;
    public static HeapOffsetSizes HeapGuid4;
    public static HeapOffsetSizes HeapBlob4;
    public static HeapOffsetSizes Padding;
    public static HeapOffsetSizes DeltaOnly;
    public static HeapOffsetSizes ExtraData;
    public static HeapOffsetSizes HasDelete;
}
public class JetBrains.Metadata.Access.ILReader.ILReaderMetadataAccess : MetadataAccessBase {
    private UnmanagedBlob myImage;
    private StreamsManager myStreams;
    [CanBeNullAttribute]
private IAssemblyLocation myImageLocation;
    private long mySize;
    private long myResourcesDirectoryOffset;
    [CompilerGeneratedAttribute]
private DateTime <ImageFileTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private EncLogAnalyzer <EncLog>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetPlatform <TargetPlatform>k__BackingField;
    [CompilerGeneratedAttribute]
private TableManager <Tables>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PeFileEndOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MetadataStartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private CliImage <CliImage>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataStreamsAccess <Streams>k__BackingField;
    [CanBeNullAttribute]
public IAssemblyLocation ImageLocation { get; }
    internal DateTime ImageFileTimestamp { get; }
    public AssemblyId Id { get; }
    public Guid EncId { get; }
    public Guid EncBaseId { get; }
    public int Generation { get; }
    public EncLogAnalyzer EncLog { get; }
    public string ModuleName { get; }
    public TargetPlatform TargetPlatform { get; }
    public TableManager Tables { get; }
    internal int PeFileEndOffset { get; }
    public IBlob Image { get; }
    public int MetadataStartOffset { get; }
    [CanBeNullAttribute]
public CliImage CliImage { get; }
    internal IMetadataStreamsAccess Streams { get; }
    public ILReaderMetadataAccess(Stream stream, IAssemblyLocation imageLocation, DateTime imageFileTimestamp, Func`1<bool> checkForInterrupt);
    public IAssemblyLocation get_ImageLocation();
    internal void DisposeMemory();
    [CompilerGeneratedAttribute]
internal DateTime get_ImageFileTimestamp();
    private static long GetResourcesDirectoryOffset(CliImage file);
    public virtual AssemblyId get_Id();
    public virtual Guid get_EncId();
    public virtual Guid get_EncBaseId();
    public virtual int get_Generation();
    [CompilerGeneratedAttribute]
public virtual EncLogAnalyzer get_EncLog();
    public virtual IMetadataAccess GetInitialMetadataAccess();
    public virtual string get_ModuleName();
    [CompilerGeneratedAttribute]
public virtual TargetPlatform get_TargetPlatform();
    public virtual TypeDefProperties GetTypeDefProperties(MetadataToken typeDef);
    public virtual TypeRefProperties GetTypeRefProperties(MetadataToken typeRef);
    public virtual IBlob GetTypeSpecBlob(MetadataToken typeSpec);
    public virtual IBlob GetStandaloneSignatureBlob(MetadataToken standAloneSig);
    public virtual MethodSpecProperties GetMethodSpecProperties(MetadataToken methodSpec);
    public virtual MetadataToken[] FindMethodSpecs(MetadataToken methodDefOrRef);
    public virtual string GetMemberName(MetadataToken memberToken);
    protected virtual void ReadFieldRow(MetadataToken fieldToken, CorFieldAttr& flags, String& name, IBlob& signature);
    protected virtual UInt32 ReadFieldRva(MetadataToken fieldRvaToken);
    public int ReadString(int offset);
    private int ReadGuid(int offset);
    private int ReadBlob(int offset);
    public virtual MethodProperties GetMethodProperties(MetadataToken methodToken);
    public virtual MetadataToken GetParameterByIndex(MetadataToken methodToken, UInt32 paramIndex);
    public virtual ParamProperties GetParameterProperties(MetadataToken paramToken);
    public virtual MemberReferenceProperties GetMemberReferenceProperties(MetadataToken memberReferenceToken);
    protected virtual MetadataToken GetCustomAttributeConstructor(MetadataToken customAttributeToken);
    private protected virtual Dictionary`2<MetadataToken, MetadataToken[]> GetMethodBodyToDeclarations(MetadataToken typeToken, MetadataToken methodImplToken);
    protected virtual int ReadFieldMarshalNativeTypeBlob(MetadataToken fieldMarshalToken);
    protected virtual CorTypeAttr ReadTypeFlags(MetadataToken typeDefToken);
    protected virtual int ReadFieldOffset(MetadataToken fieldLayoutToken);
    public virtual DeclSecurityProperties GetDeclSecurityProperties(MetadataToken token);
    public virtual MetadataToken FindTypeRef(MetadataToken resolutionScope, string qualifiedName);
    public virtual MetadataToken[] FindTypeRefs(string qualifiedName);
    public virtual MetadataToken[] FindMemberRefs(MetadataToken typeToken);
    [CompilerGeneratedAttribute]
public TableManager get_Tables();
    [CompilerGeneratedAttribute]
internal int get_PeFileEndOffset();
    public IBlob get_Image();
    [CompilerGeneratedAttribute]
public int get_MetadataStartOffset();
    public int GetAbsoluteStringsTableOffset();
    [CompilerGeneratedAttribute]
public CliImage get_CliImage();
    public virtual JetReadOnlyList`1<UInt32> GetMethodRvaMap();
    public virtual long GetEmbeddedResourceOffset(long resourceOffset);
    protected virtual OneToSetMap`2<MetadataToken, MetadataToken> LoadNestedTypeMap();
    protected virtual ReadOnlyDictionary`2<string, MetadataToken> LoadTypeNamesMap();
    protected virtual MetadataTokenRange ReadTokenInterval(MetadataToken owner, MetadataTableId tokenType, int skipBytes, int skipStrings, int skipBlobs, MetadataTokenType[] skipTokenTypes);
    protected virtual MetadataToken EntityToOwnerIntervalLookup(MetadataToken entityToken, MetadataTableId ownerTable, int skipBytes, int skipStrings, int skipBlobs, MetadataTokenType[] skipTokenTypes);
    protected virtual MetadataToken SearchInTable(MetadataTableId table, MetadataToken targetToken, MetadataTokenType targetStorageFormat, int skipBytes, MetadataTokenType[] skipTokenTypes);
    protected virtual MetadataToken[] ReadTokensFromTable(MetadataTokenRange ownerRows, MetadataTokenType entityTokenType, MetadataTokenType[] skipTokenTypes);
    protected virtual MetadataTokenRange FindTokensClusterInTable(MetadataToken aroundToken, MetadataTokenType tokenType, int skipBytes, MetadataTokenType[] skipTokenTypes);
    private UInt32 ReadRawToken(int index, int tableStart, int tableRowSize, MetadataTokenType tokenType, int tokenOffset);
    private protected virtual MethodSemanticsProperties[] GetSemanticsProperties(MetadataToken methodSemanticsToken);
    protected virtual MetadataToken GetPropertyDeclaringType(MetadataToken propertyToken);
    protected virtual int ReadConstantValueBlob(MetadataToken constantToken, UInt16& type);
    [IteratorStateMachineAttribute("JetBrains.Metadata.Access.ILReader.ILReaderMetadataAccess/<GetAllStringConstantsWithParentTokens>d__83")]
public IEnumerable`1<Pair`2<string, MetadataToken>> GetAllStringConstantsWithParentTokens();
    [IteratorStateMachineAttribute("JetBrains.Metadata.Access.ILReader.ILReaderMetadataAccess/<GetAllPInvokeStringsWithTokens>d__84")]
public IEnumerable`1<Pair`2<string, MetadataToken>> GetAllPInvokeStringsWithTokens();
    [CompilerGeneratedAttribute]
internal virtual IMetadataStreamsAccess get_Streams();
    public TableManager GetTableManager();
    public UInt32 ReadToken(int offset, MetadataTokenType type);
    private UInt32 InternalReadCodedToken(int offset, EncodedTokenType type);
    internal void LoadAllTables();
}
public class JetBrains.Metadata.Access.ILReader.ILReaderMetadataProvider : object {
    private static TimeSpan ourCacheMetadataEntryTtl;
    private static TimeSpan ourCacheMetadataExpirationCheck;
    public static IMetadataProvider Instance;
    private IDictionary`2<string, CacheEntry> myCache;
    [UsedImplicitlyAttribute]
private Timer myExpirationTimer;
    private IDictionary`2<string, object> myPerFileOrIdLock;
    public int CacheEntryCountInUse { get; }
    public int TotalUsageCounter { get; }
    private static ILReaderMetadataProvider();
    [ObsoleteAttribute("Use TryGetFromAssemblyLocation")]
public sealed virtual IMetadataAccess TryGetFromFile(VirtualFileSystemPath fsp);
    public sealed virtual IMetadataAccess TryGetFromAssemblyLocation(IAssemblyLocation assemblyLocation);
    private static string AssemblyLocationToId(IAssemblyLocation assemblyLocation);
    private IMetadataAccess GetMetadataAccess(string id, DateTime currentFileModificationTime, Func`1<CacheEntry> getMetadataAccess);
    [ObsoleteAttribute("Use GetFromAssemblyLocation")]
public sealed virtual IMetadataAccess GetFromFile(VirtualFileSystemPath fsp, Func`1<bool> checkForInterrupt);
    public sealed virtual IMetadataAccess GetFromAssemblyLocation(IAssemblyLocation assemblyLocation, Func`1<bool> checkForInterrupt);
    public sealed virtual IMetadataAccess GetFromStream(string id, DateTime fileModificationTimeUtc, Func`1<Stream> getStream);
    public sealed virtual IMetadataAccess TryGetFromStream(string id, DateTime fileModificationTimeUtc, Func`1<Stream> getData);
    public sealed virtual void DisposeMetadataAccess(IMetadataAccess access);
    private void ExpireCaches();
    public void ClearCaches();
    public int get_CacheEntryCountInUse();
    public int get_TotalUsageCounter();
    public void DumpDebugInfo(TextWriter sw);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0(object _);
}
public interface JetBrains.Metadata.Access.ILReader.ITableReader {
    public abstract virtual byte ReadByte();
    public abstract virtual ushort ReadUInt16();
    public abstract virtual UInt32 ReadUInt32();
    public abstract virtual int ReadString();
    public abstract virtual int ReadGuid();
    public abstract virtual int ReadBlob();
    public abstract virtual UInt32 ReadToken(MetadataTokenType type);
    public abstract virtual UInt32 ReadRawToken(MetadataTokenType type);
    public abstract virtual void Skip(int bytes);
    public abstract virtual void SkipString();
    public abstract virtual void SkipGuid();
    public abstract virtual void SkipBlob();
    public abstract virtual void SkipToken(MetadataTokenType type);
    public abstract virtual void Reset(MetadataToken token);
}
public abstract class JetBrains.Metadata.Access.ILReader.MetadataAccessBase : object {
    [CanBeNullAttribute]
private OneToSetMap`2 modreq(System.Runtime.CompilerServices.IsVolatile) myNestedTypeMap;
    [CanBeNullAttribute]
private ReadOnlyDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) myTypeName2TokenMap;
    private Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) myTypeToMethodBodyToDeclarations;
    [CanBeNullAttribute]
private IMetadataAssemblyInfo myMetadataAssemblyInfo;
    [NotNullAttribute]
private static Byte[] ourCtorNameBytes;
    [NotNullAttribute]
private static Byte[] ourOpPrefixBytes;
    [NotNullAttribute]
private static Byte[] ourOpImplicitBytes;
    [NotNullAttribute]
private static Byte[] ourOpExplicitBytes;
    [NotNullAttribute]
private static Byte[] ourOpCheckedExplicitBytes;
    [NotNullAttribute]
private static Byte[] ourOpEqualityBytes;
    [NotNullAttribute]
private static Byte[] ourOpInequalityBytes;
    [NotNullAttribute]
private static Byte[] ourToStringNameBytes;
    [NotNullAttribute]
private static Byte[] ourEqualsNameBytes;
    [NotNullAttribute]
private static Byte[] ourCloneNameBytes;
    protected static TablesOrderingState SortedByPrimaryKeyTables;
    protected TablesOrderingState TablesOrdering;
    [CanBeNullAttribute]
private AssemblyNameReader myAssemblyNameReader;
    public IMetadataProvider MetadataProvider { get; }
    public AssemblyId Id { get; }
    public Guid EncId { get; }
    public Guid EncBaseId { get; }
    public int Generation { get; }
    public string ModuleName { get; }
    public TargetPlatform TargetPlatform { get; }
    public OneToSetMap`2<MetadataToken, MetadataToken> NestedTypeMap { get; }
    public ReadOnlyDictionary`2<string, MetadataToken> TypeName2TokenMapping { get; }
    private AssemblyNameReader AssemblyNameReader { get; }
    internal IMetadataStreamsAccess Streams { get; }
    public EncLogAnalyzer EncLog { get; }
    public int GuidMaxIndex { get; }
    public int StringHeapSize { get; }
    public int UserStringHeapSize { get; }
    public int BlobHeapSize { get; }
    public PdbStream PdbStream { get; }
    private static MetadataAccessBase();
    public sealed virtual IMetadataProvider get_MetadataProvider();
    public sealed virtual IMetadataAssemblyInfo GetAssemblyInfo();
    public abstract virtual AssemblyId get_Id();
    public abstract virtual Guid get_EncId();
    public abstract virtual Guid get_EncBaseId();
    public abstract virtual int get_Generation();
    public abstract virtual string get_ModuleName();
    public abstract virtual TargetPlatform get_TargetPlatform();
    public virtual TypeDefProperties GetTypeDefProperties(MetadataToken typeDef);
    public virtual TypeRefProperties GetTypeRefProperties(MetadataToken typeRef);
    public sealed virtual MetadataMemberPresenceFlags ComputeMemberPresenceFlags(MetadataToken typeDef);
    public virtual IBlob GetTypeSpecBlob(MetadataToken typeSpec);
    public virtual IBlob GetMethodSpecBlob(MetadataToken methodSpec);
    public virtual IBlob GetStandaloneSignatureBlob(MetadataToken standAloneSig);
    public virtual MethodSpecProperties GetMethodSpecProperties(MetadataToken methodSpec);
    public virtual MetadataToken[] FindMethodSpecs(MetadataToken methodDefOrRef);
    public sealed virtual MetadataTokenRange GetGenericParameters(MetadataToken ownerToken);
    public sealed virtual GenericParameterProperties GetGenericParameterProperties(MetadataToken gpToken);
    public virtual GenericParameterConstraintProperties GetGenericParameterConstraintProperties(MetadataToken gpcToken);
    public virtual MetadataTokenRange GetInterfaceImplementations(MetadataToken typeToken);
    public virtual MetadataTokenRange GetMethodImpls(MetadataToken typeToken);
    public MetadataToken[] GetImplementedInterfaces(MetadataToken typeToken);
    public sealed virtual InterfaceImplementationProperties GetInterfaceImplementationProperties(MetadataToken interfaceImplToken);
    public sealed virtual MethodImplProperties GetMethodImplProperties(MetadataToken methodImplToken);
    public virtual string GetMemberName(MetadataToken memberToken);
    public sealed virtual MetadataTokenRange GetFields(MetadataToken typeToken);
    public sealed virtual FieldProperties GetFieldProperties(MetadataToken fieldToken);
    internal MetadataToken GetFieldRvaToken(MetadataToken fieldToken);
    protected virtual void ReadFieldRow(MetadataToken fieldToken, CorFieldAttr& flags, String& name, IBlob& signature);
    protected virtual UInt32 ReadFieldRva(MetadataToken fieldRvaToken);
    protected virtual MetadataToken GetFieldOwner(MetadataToken fieldToken);
    public sealed virtual MetadataTokenRange GetMethods(MetadataToken typeToken);
    public virtual MethodProperties GetMethodProperties(MetadataToken methodToken);
    protected virtual MetadataToken GetMethodDefDeclaringType(MetadataToken methodToken);
    public virtual MetadataTokenRange GetParameters(MetadataToken methodToken);
    public virtual MetadataToken GetParameterByIndex(MetadataToken methodToken, UInt32 paramIndex);
    public virtual ParamProperties GetParameterProperties(MetadataToken paramToken);
    protected virtual MetadataToken GetParameterOwner(MetadataToken parameterToken);
    public sealed virtual MetadataTokenRange GetProperties(MetadataToken typeToken);
    protected MetadataTokenRange GetPropertiesByPropertyMap(MetadataToken propertyMapToken);
    public sealed virtual PropertyProperties GetPropertyProperties(MetadataToken propertyToken);
    public sealed virtual MetadataTokenRange GetEvents(MetadataToken typeToken);
    protected MetadataTokenRange GetEventsByEventMap(MetadataToken eventMapToken);
    public sealed virtual EventProperties GetEventProperties(MetadataToken eventToken);
    public sealed virtual MetadataToken GetEnclosingType(MetadataToken typeToken);
    public sealed virtual MetadataTokenRange GetCustomAttributes(MetadataToken parentToken);
    public sealed virtual CustomAttributeProperties GetCustomAttributeProperties(MetadataToken customAttributeToken);
    public sealed virtual MetadataTypeReference GetCustomAttributeTypeName(MetadataToken customAttributeToken);
    protected virtual MetadataToken GetCustomAttributeConstructor(MetadataToken customAttributeToken);
    public sealed virtual string GetModuleRefProperties(MetadataToken token);
    public virtual MemberReferenceProperties GetMemberReferenceProperties(MetadataToken memberReferenceToken);
    public sealed virtual ExportedTypeProperties GetExportedTypeProperties(MetadataToken exportedTypeToken);
    public virtual AssemblyRefProperties GetAssemblyRefProperties(MetadataToken assemblyRefToken);
    public sealed virtual FileProperties GetFileProperties(MetadataToken fileToken);
    public sealed virtual ManifestResourceProperties GetManifestResourceProperties(MetadataToken manifestResourceToken);
    public sealed virtual IDictionary`2<MetadataToken, MetadataToken[]> GetMethodBodyToDeclarations(MetadataToken typeToken);
    public sealed virtual MetadataToken[] GetImplementedMethods(MetadataToken typeToken, MetadataToken methodBodyToken);
    [CanBeNullAttribute]
private protected abstract virtual Dictionary`2<MetadataToken, MetadataToken[]> GetMethodBodyToDeclarations(MetadataToken typeToken, MetadataToken methodImplToken);
    public sealed virtual PInvokeProperties GetPInvokeProperties(MetadataToken methodToken);
    public sealed virtual ImplMapProperties GetImplMapProperties(MetadataToken implMapToken);
    public sealed virtual EncLogProperties GetEncLogProperties(MetadataToken encLogToken);
    public sealed virtual EncMapProperties GetEncMapProperties(MetadataToken encMapToken);
    public sealed virtual IBlob GetMarshalSpec(MetadataToken token);
    protected virtual int ReadFieldMarshalNativeTypeBlob(MetadataToken fieldMarshalToken);
    public sealed virtual ClassLayout GetClassLayout(MetadataToken typeToken);
    protected virtual CorTypeAttr ReadTypeFlags(MetadataToken typeDefToken);
    protected virtual int ReadFieldOffset(MetadataToken fieldLayoutToken);
    public sealed virtual MetadataTokenRange GetDeclSecurity(MetadataToken ownerToken);
    public virtual DeclSecurityProperties GetDeclSecurityProperties(MetadataToken token);
    public sealed virtual String[] GetDeclSecurityTypeNames(MetadataToken token);
    public virtual MetadataToken FindTypeRef(MetadataToken resolutionScope, string qualifiedName);
    public virtual MetadataToken[] FindTypeRefs(string qualifiedName);
    private MetadataTokenRange GetTableRange(MetadataTableId tableId);
    public sealed virtual MetadataTokenRange GetTypeRefs();
    public sealed virtual MetadataTokenRange GetInterfaceImpls();
    public sealed virtual MetadataTokenRange GetExportedTypes();
    public sealed virtual MetadataTokenRange GetMethodImpls();
    public sealed virtual MetadataTokenRange GetTypeDefs();
    public sealed virtual MetadataTokenRange GetFields();
    public sealed virtual MetadataTokenRange GetMethods();
    public sealed virtual MetadataTokenRange GetMemberRefs();
    public sealed virtual MetadataTokenRange GetStandAloneSigs();
    public sealed virtual MetadataTokenRange GetEvents();
    public sealed virtual MetadataTokenRange GetProperties();
    public sealed virtual MetadataTokenRange GetModuleRefs();
    public sealed virtual MetadataTokenRange GetTypeSpecs();
    public sealed virtual MetadataTokenRange GetImplMaps();
    public sealed virtual MetadataTokenRange GetEncLogs();
    public sealed virtual MetadataTokenRange GetEncMaps();
    public sealed virtual MetadataTokenRange GetFiles();
    public sealed virtual MetadataTokenRange GetExportedTypesFromOtherModules();
    public sealed virtual MetadataTokenRange GetManifestResources();
    protected MetadataTokenRange GetNestedClasses();
    public sealed virtual MetadataTokenRange GetMethodSpecs();
    public sealed virtual MetadataTokenRange GetDocuments();
    public sealed virtual MetadataTokenRange GetMethodDebugInformations();
    public sealed virtual MetadataTokenRange GetLocalScopes();
    public sealed virtual MetadataTokenRange GetImportScopes();
    public sealed virtual MetadataTokenRange GetStateMachineMethods();
    public sealed virtual MetadataTokenRange GetCustomDebugInformations();
    public sealed virtual string GetDocumentName(MetadataToken documentToken);
    public sealed virtual DocumentProperties GetDocumentProperties(MetadataToken documentToken);
    public sealed virtual DebugDocument GetDocument(MetadataToken documentToken);
    public sealed virtual IReadOnlyList`1<SequencePoint> GetMethodDebugInformation(MetadataToken mdiToken);
    public sealed virtual IReadOnlyList`1<SequencePoint> GetMethodDebugInformation(MetadataToken mdiToken, MetadataToken& localVariablesSignatureToken);
    public sealed virtual LocalScopeProperties GetLocalScopeProperties(MetadataToken localScopeToken);
    public sealed virtual MetadataTokenRange GetScopeVariables(MetadataToken localScopeToken);
    public sealed virtual MetadataTokenRange GetScopeConstants(MetadataToken localScopeToken);
    public sealed virtual LocalVariableProperties GetLocalVariableProperties(MetadataToken localVariableToken);
    public sealed virtual ImportScopeProperties GetImportScopeProperties(MetadataToken importScopeToken);
    public sealed virtual CustomDebugInformationProperties GetCustomDebugInformationProperties(MetadataToken customDebugInformationToken);
    public sealed virtual StateMachineMethodProperties GetStateMachineMethodProperties(MetadataToken stateMachineMethodToken);
    public virtual MetadataToken[] FindMemberRefs(MetadataToken typeToken);
    public sealed virtual OneToSetMap`2<MetadataToken, MetadataToken> get_NestedTypeMap();
    public sealed virtual ReadOnlyDictionary`2<string, MetadataToken> get_TypeName2TokenMapping();
    public virtual JetReadOnlyList`1<UInt32> GetMethodRvaMap();
    public abstract virtual long GetEmbeddedResourceOffset(long resourceOffset);
    protected virtual OneToSetMap`2<MetadataToken, MetadataToken> LoadNestedTypeMap();
    protected string GetTypeFullyQualifiedName(MetadataToken typeToken);
    protected virtual ReadOnlyDictionary`2<string, MetadataToken> LoadTypeNamesMap();
    protected virtual MetadataTokenRange GetGenericParameterConstraints(MetadataToken genericParamToken);
    protected abstract virtual MetadataTokenRange ReadTokenInterval(MetadataToken owner, MetadataTableId tokenType, int skipBytes, int skipStrings, int skipBlobs, MetadataTokenType[] skipTokenTypes);
    protected virtual MetadataToken EntityToOwnerIntervalLookup(MetadataToken entityToken, MetadataTableId ownerTable, int skipBytes, int skipStrings, int skipBlobs, MetadataTokenType[] skipTokenTypes);
    protected UInt32 GetEntityValue(MetadataToken ownerRow, MetadataTokenType entityTokenType, bool rowValue, int skipBytes, int skipStrings, int skipBlobs, MetadataTokenType[] skipTokenTypes);
    protected UInt32 GetInitialEntityValue(MetadataToken ownerRow, MetadataTokenType entityTokenType, bool rowValue, int skipBytes, int skipStrings, int skipBlobs, MetadataTokenType[] skipTokenTypes);
    private static UInt32 GetEntityValue(ITableReader reader, MetadataTokenType entityTokenType, bool rowValue, int skipBytes, int skipStrings, int skipBlobs, MetadataTokenType[] skipTokenTypes);
    protected virtual MetadataToken SearchInTable(MetadataTableId table, MetadataToken targetToken, MetadataTokenType targetStorageFormat, int skipBytes, MetadataTokenType[] skipTokenTypes);
    protected virtual MetadataToken[] ReadTokensFromTable(MetadataTokenRange ownerRows, MetadataTokenType entityTokenType, MetadataTokenType[] skipTokenTypes);
    protected abstract virtual MetadataTokenRange FindTokensClusterInTable(MetadataToken aroundToken, MetadataTokenType tokenType, int skipBytes, MetadataTokenType[] skipTokenTypes);
    private MethodSemanticsProperties[] GetSemantics(MetadataToken associationToken);
    private protected abstract virtual MethodSemanticsProperties[] GetSemanticsProperties(MetadataToken methodSemanticsToken);
    protected virtual MetadataToken GetEventDeclaringType(MetadataToken eventToken);
    protected MetadataToken GetEventMap(MetadataToken eventToken);
    protected virtual MetadataToken GetPropertyDeclaringType(MetadataToken propertyToken);
    protected MetadataToken GetPropertyMap(MetadataToken propertyToken);
    protected void ReadConstant(MetadataToken objectToken, IBlob& value, UInt16& type);
    internal MetadataToken GetConstantToken(MetadataToken objectToken);
    protected virtual int ReadConstantValueBlob(MetadataToken constantToken, UInt16& type);
    private AssemblyNameReader get_AssemblyNameReader();
    internal abstract virtual IMetadataStreamsAccess get_Streams();
    public abstract virtual EncLogAnalyzer get_EncLog();
    public sealed virtual Guid GetGuid(int index);
    public sealed virtual string GetString(int offset);
    public sealed virtual IBlob GetBlob(int offset);
    public sealed virtual string GetUserString(MetadataToken pointer);
    public sealed virtual string GetUtf8String(int blobOffset);
    public sealed virtual Guid[] GetAllGuids();
    public sealed virtual IEnumerable`1<Pair`2<string, int>> GetAllUserStringsWithOffsets();
    public sealed virtual IEnumerable`1<Pair`2<string, int>> GetAllStringsWithOffsets();
    public sealed virtual IEnumerable`1<string> GetAllStrings();
    public sealed virtual bool UserStringEqualToAsciiString(int offset, Byte[] utf8Bytes);
    public sealed virtual bool UserStringStartsWithAsciiString(int offset, Byte[] utf8Prefix);
    public sealed virtual IBinaryReader GetBlobHeapReader();
    public sealed virtual IEnumerable`1<int> GetAllBlobOffsets();
    public sealed virtual ITableReader GetTableRow(MetadataToken token);
    public sealed virtual ITableReader GetTableRow(MetadataTableId table, int rid);
    public virtual ITableReader GetInitialTableRow(MetadataToken token);
    public sealed virtual int GetTableSize(MetadataTableId tableId);
    protected virtual int GetInitialTableSize(MetadataTableId tableId);
    protected virtual int GetTableSize(MetadataTableId tableId, int generation);
    protected static Guid GetGuidOrEmpty(IMetadataStreamsAccess streams, int index);
    public sealed virtual int get_GuidMaxIndex();
    public sealed virtual int get_StringHeapSize();
    public sealed virtual int get_UserStringHeapSize();
    public sealed virtual int get_BlobHeapSize();
    public sealed virtual PdbStream get_PdbStream();
    private sealed virtual override IEnumerable`1<byte> JetBrains.Metadata.Access.ILowLevelMetadataStreamsAccess.GetStringHeapBytes();
    private sealed virtual override IEnumerable`1<byte> JetBrains.Metadata.Access.ILowLevelMetadataStreamsAccess.GetUserStringHeapBytes();
    private sealed virtual override IEnumerable`1<byte> JetBrains.Metadata.Access.ILowLevelMetadataStreamsAccess.GetGuidHeapBytes();
    private sealed virtual override IEnumerable`1<byte> JetBrains.Metadata.Access.ILowLevelMetadataStreamsAccess.GetBlobHeapBytes();
    public virtual IList`1<MetadataToken> GetGenericParametersEnc(MetadataToken ownerToken);
    protected virtual IEnumerable`1<MetadataToken> GetFieldsEnumerable(MetadataToken typeToken);
    public virtual IList`1<MetadataToken> GetFieldsEnc(MetadataToken typeToken);
    public virtual IList`1<MetadataToken> GetMethodsEnc(MetadataToken typeToken);
    public virtual IList`1<MetadataToken> GetPropertiesEnc(MetadataToken typeOrPropertyMapToken);
    public virtual IList`1<MetadataToken> GetEventsEnc(MetadataToken typeOrEventMapToken);
    public virtual IList`1<MetadataToken> GetCustomAttributesEnc(MetadataToken ownerToken);
    public virtual IList`1<MetadataToken> GetDeclSecurityEnc(MetadataToken ownerToken);
    public abstract virtual IMetadataAccess GetInitialMetadataAccess();
    [CompilerGeneratedAttribute]
private Signature <ComputeMemberPresenceFlags>g__DecodeSignature|21_0(int signatureBlobOffset, <>c__DisplayClass21_0& );
    [CompilerGeneratedAttribute]
private bool <ComputeMemberPresenceFlags>g__HasExplicitImplementations|21_1(MetadataToken metadataToken, <>c__DisplayClass21_0& );
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.ILReader.MetadataTableFlags : Enum {
    public ulong value__;
    public static MetadataTableFlags Module;
    public static MetadataTableFlags TypeRef;
    public static MetadataTableFlags TypeDef;
    public static MetadataTableFlags FieldPointer;
    public static MetadataTableFlags Field;
    public static MetadataTableFlags MethodPointer;
    public static MetadataTableFlags MethodDef;
    public static MetadataTableFlags ParamPointer;
    public static MetadataTableFlags Param;
    public static MetadataTableFlags InterfaceImpl;
    public static MetadataTableFlags MemberRef;
    public static MetadataTableFlags Constant;
    public static MetadataTableFlags CustomAttribute;
    public static MetadataTableFlags FieldMarshal;
    public static MetadataTableFlags DeclSecurity;
    public static MetadataTableFlags ClassLayout;
    public static MetadataTableFlags FieldLayout;
    public static MetadataTableFlags StandAloneSig;
    public static MetadataTableFlags EventMap;
    public static MetadataTableFlags EventPointer;
    public static MetadataTableFlags Event;
    public static MetadataTableFlags PropertyMap;
    public static MetadataTableFlags PropertyPointer;
    public static MetadataTableFlags Property;
    public static MetadataTableFlags MethodSemantics;
    public static MetadataTableFlags MethodImpl;
    public static MetadataTableFlags ModuleRef;
    public static MetadataTableFlags TypeSpec;
    public static MetadataTableFlags ImplMap;
    public static MetadataTableFlags FieldRva;
    public static MetadataTableFlags EncLog;
    public static MetadataTableFlags EncMap;
    public static MetadataTableFlags Assembly;
    public static MetadataTableFlags AssemblyProcessor;
    public static MetadataTableFlags AssemblyOS;
    public static MetadataTableFlags AssemblyRef;
    public static MetadataTableFlags AssemblyRefProcessor;
    public static MetadataTableFlags AssemblyRefOS;
    public static MetadataTableFlags File;
    public static MetadataTableFlags ExportedType;
    public static MetadataTableFlags ManifestResource;
    public static MetadataTableFlags NestedClass;
    public static MetadataTableFlags GenericParam;
    public static MetadataTableFlags MethodSpec;
    public static MetadataTableFlags GenericParamConstraint;
    public static MetadataTableFlags Document;
    public static MetadataTableFlags MethodDebugInformation;
    public static MetadataTableFlags LocalScope;
    public static MetadataTableFlags LocalVariable;
    public static MetadataTableFlags LocalConstant;
    public static MetadataTableFlags ImportScope;
    public static MetadataTableFlags StateMachineMethod;
    public static MetadataTableFlags CustomDebugInformation;
}
public enum JetBrains.Metadata.Access.ILReader.MethodSemanticsAttributes : Enum {
    public short value__;
    public static MethodSemanticsAttributes Setter;
    public static MethodSemanticsAttributes Getter;
    public static MethodSemanticsAttributes Other;
    public static MethodSemanticsAttributes AddOn;
    public static MethodSemanticsAttributes RemoveOn;
    public static MethodSemanticsAttributes Fire;
}
public class JetBrains.Metadata.Access.ILReader.PdbStream : object {
    [CompilerGeneratedAttribute]
private Guid <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <TimeDateStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ReferencedTypeSystemTables>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <TypeSystemTableRows>k__BackingField;
    public Guid Signature { get; }
    public UInt32 TimeDateStamp { get; }
    public MetadataToken EntryPoint { get; }
    public ulong ReferencedTypeSystemTables { get; }
    public Int32[] TypeSystemTableRows { get; }
    public PdbStream(IBinaryReader reader);
    [CompilerGeneratedAttribute]
public Guid get_Signature();
    [CompilerGeneratedAttribute]
public UInt32 get_TimeDateStamp();
    [CompilerGeneratedAttribute]
public MetadataToken get_EntryPoint();
    [CompilerGeneratedAttribute]
public ulong get_ReferencedTypeSystemTables();
    [CompilerGeneratedAttribute]
public Int32[] get_TypeSystemTableRows();
}
internal class JetBrains.Metadata.Access.ILReader.StreamsManager : object {
    private StreamHeader myBlobHeapHdr;
    private StreamHeader myGuidHeapHdr;
    private StreamHeader myStringHeapHdr;
    private StreamHeader myUserstringHeapHdr;
    private int myUserstringEndOffset;
    private string myImageMoniker;
    private IBlob myImage;
    private static string InvalidUserStringMessage;
    [CompilerGeneratedAttribute]
private bool <IsMinimalDelta>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GuidMaxIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StringHeapSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UserStringHeapSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BlobHeapSize>k__BackingField;
    [CompilerGeneratedAttribute]
private TableManager <Tables>k__BackingField;
    [CompilerGeneratedAttribute]
private PdbStream <PdbStream>k__BackingField;
    private ConcurrentDictionary`2<int, string> myBlobOffsetToString;
    internal bool IsMinimalDelta { get; }
    public int GuidMaxIndex { get; }
    public int StringHeapSize { get; }
    public int UserStringHeapSize { get; }
    public int BlobHeapSize { get; }
    public TableManager Tables { get; }
    public PdbStream PdbStream { get; }
    public StreamsManager(IBlob metadataBlob, string imageMoniker);
    [CompilerGeneratedAttribute]
internal bool get_IsMinimalDelta();
    public sealed virtual Guid GetGuid(int index);
    public sealed virtual Guid[] GetAllGuids();
    [IteratorStateMachineAttribute("JetBrains.Metadata.Access.ILReader.StreamsManager/<GetAllStringsWithOffsets>d__13")]
[NotNullAttribute]
public sealed virtual IEnumerable`1<Pair`2<string, int>> GetAllStringsWithOffsets();
    [IteratorStateMachineAttribute("JetBrains.Metadata.Access.ILReader.StreamsManager/<GetAllStrings>d__14")]
public sealed virtual IEnumerable`1<string> GetAllStrings();
    public sealed virtual bool UserStringEqualToAsciiString(int offset, Byte[] utf8Bytes);
    public sealed virtual bool UserStringStartsWithAsciiString(int offset, Byte[] utf8Prefix);
    public sealed virtual string GetString(int offset);
    public sealed virtual IBlob GetBlob(int offset);
    public sealed virtual IBinaryReader GetBlobHeapReader();
    [IteratorStateMachineAttribute("JetBrains.Metadata.Access.ILReader.StreamsManager/<GetAllBlobOffsets>d__20")]
public sealed virtual IEnumerable`1<int> GetAllBlobOffsets();
    public sealed virtual ITableReader GetTableRow(MetadataToken token);
    public sealed virtual ITableReader GetTableRow(MetadataTableId table, int rid);
    public sealed virtual int GetTableSize(MetadataTableId tableId);
    [CompilerGeneratedAttribute]
public sealed virtual int get_GuidMaxIndex();
    [CompilerGeneratedAttribute]
public sealed virtual int get_StringHeapSize();
    [CompilerGeneratedAttribute]
public sealed virtual int get_UserStringHeapSize();
    [CompilerGeneratedAttribute]
public sealed virtual int get_BlobHeapSize();
    [CompilerGeneratedAttribute]
public TableManager get_Tables();
    [CompilerGeneratedAttribute]
public sealed virtual PdbStream get_PdbStream();
    [IteratorStateMachineAttribute("JetBrains.Metadata.Access.ILReader.StreamsManager/<GetAllUserStrings>d__42")]
public IEnumerable`1<string> GetAllUserStrings();
    [IteratorStateMachineAttribute("JetBrains.Metadata.Access.ILReader.StreamsManager/<GetAllUserStringsWithOffsets>d__43")]
public sealed virtual IEnumerable`1<Pair`2<string, int>> GetAllUserStringsWithOffsets();
    public sealed virtual string GetUserString(MetadataToken pointer);
    [NotNullAttribute]
private string ReadUserString(int offset, Int32& stringSize);
    public int GetAbsoluteStringsTableOffset(int metadataOffset);
    private int GetRealStringHeapSize();
    public sealed virtual string GetUtf8String(int blobOffset);
    [IteratorStateMachineAttribute("JetBrains.Metadata.Access.ILReader.StreamsManager/<GetHeapBytes>d__51")]
private IEnumerable`1<byte> GetHeapBytes(StreamHeader heapHeader, int heapSize);
    private sealed virtual override IEnumerable`1<byte> JetBrains.Metadata.Access.ILowLevelMetadataStreamsAccess.GetStringHeapBytes();
    private sealed virtual override IEnumerable`1<byte> JetBrains.Metadata.Access.ILowLevelMetadataStreamsAccess.GetUserStringHeapBytes();
    private sealed virtual override IEnumerable`1<byte> JetBrains.Metadata.Access.ILowLevelMetadataStreamsAccess.GetGuidHeapBytes();
    private sealed virtual override IEnumerable`1<byte> JetBrains.Metadata.Access.ILowLevelMetadataStreamsAccess.GetBlobHeapBytes();
}
public class JetBrains.Metadata.Access.ILReader.TableManager : object {
    private string myImageMoniker;
    public int BlobIdxSize;
    public int GuidIdxSize;
    private IBinaryReader myReader;
    public int StringIdxSize;
    public Int32[] TableOffsets;
    public Int32[] TableRows;
    public Int32[] TableRowSize;
    public Int32[] TokenSize;
    public static int TablesCountAligned;
    public static int TokenTypesCountAligned;
    [CompilerGeneratedAttribute]
private TablesHeader <TablesHeader>k__BackingField;
    public TablesHeader TablesHeader { get; }
    public TableManager(IBinaryReader reader, PdbStream pdbStream, string imageMoniker, bool isMinimalDelta);
    [CompilerGeneratedAttribute]
public TablesHeader get_TablesHeader();
    public static int GetTokenSize(int tableRows);
    public static Int32[] GetTableRowSizes(Int32[] tokenSize, int stringOffsetSize, int guidIndexSize, int blobOffsetSize);
    public ITableReader GetTableRow(MetadataTableId table, int rid);
    public ITableReader GetTableRow(MetadataToken token);
    public int GetRowOffset(MetadataToken token);
    public int GetRowOffset(MetadataTableId table, int rid);
}
public enum JetBrains.Metadata.Access.ILReader.TableOrderingState : Enum {
    public int value__;
    public static TableOrderingState UNKNOWN;
    public static TableOrderingState SORTED;
    public static TableOrderingState UNSORTED;
}
public class JetBrains.Metadata.Access.ILReader.TablesHeader : object {
    [CompilerGeneratedAttribute]
private UInt32 <Reserved>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <MajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <MinorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private HeapOffsetSizes <HeapOffsetSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <RowId>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <MaskValid>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <MaskSorted>k__BackingField;
    public UInt32 Reserved { get; }
    public byte MajorVersion { get; }
    public byte MinorVersion { get; }
    public HeapOffsetSizes HeapOffsetSizes { get; }
    public byte RowId { get; }
    public ulong MaskValid { get; }
    public ulong MaskSorted { get; }
    public TablesHeader(IBinaryReader reader);
    [CompilerGeneratedAttribute]
public UInt32 get_Reserved();
    [CompilerGeneratedAttribute]
public byte get_MajorVersion();
    [CompilerGeneratedAttribute]
public byte get_MinorVersion();
    [CompilerGeneratedAttribute]
public HeapOffsetSizes get_HeapOffsetSizes();
    [CompilerGeneratedAttribute]
public byte get_RowId();
    [CompilerGeneratedAttribute]
public ulong get_MaskValid();
    [CompilerGeneratedAttribute]
public ulong get_MaskSorted();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Metadata.Access.ILReader.TablesOrderingState : object {
    private TableOrderingState[] myState;
    public TableOrderingState Item { get; private set; }
    private TablesOrderingState(TablesOrderingState other);
    public TableOrderingState get_Item(MetadataTableId tableId);
    private void set_Item(MetadataTableId tableId, TableOrderingState value);
    public TablesOrderingState SetState(MetadataTableId tableId, TableOrderingState newState);
    public static TablesOrderingState CreateFromSortedTablesList(MetadataTableId[] sortedTables);
}
public interface JetBrains.Metadata.Access.IMetadataAccess {
    public IMetadataProvider MetadataProvider { get; }
    public AssemblyId Id { get; }
    public string ModuleName { get; }
    public TargetPlatform TargetPlatform { get; }
    public OneToSetMap`2<MetadataToken, MetadataToken> NestedTypeMap { get; }
    public ReadOnlyDictionary`2<string, MetadataToken> TypeName2TokenMapping { get; }
    public abstract virtual IMetadataProvider get_MetadataProvider();
    public abstract virtual IMetadataAssemblyInfo GetAssemblyInfo();
    public abstract virtual AssemblyId get_Id();
    public abstract virtual string get_ModuleName();
    public abstract virtual TargetPlatform get_TargetPlatform();
    public abstract virtual MetadataTokenRange GetModuleRefs();
    public abstract virtual MetadataTokenRange GetTypeDefs();
    public abstract virtual TypeDefProperties GetTypeDefProperties(MetadataToken typeDef);
    public abstract virtual TypeRefProperties GetTypeRefProperties(MetadataToken typeRef);
    public abstract virtual ExportedTypeProperties GetExportedTypeProperties(MetadataToken exportedType);
    public abstract virtual MetadataMemberPresenceFlags ComputeMemberPresenceFlags(MetadataToken typeDef);
    [NotNullAttribute]
public abstract virtual IBlob GetTypeSpecBlob(MetadataToken typeSpec);
    [NotNullAttribute]
public abstract virtual IBlob GetStandaloneSignatureBlob(MetadataToken standAloneSig);
    public abstract virtual MethodSpecProperties GetMethodSpecProperties(MetadataToken methodSpec);
    public abstract virtual MetadataToken[] FindMethodSpecs(MetadataToken methodDefOrRef);
    public abstract virtual MetadataTokenRange GetGenericParameters(MetadataToken ownerToken);
    public abstract virtual GenericParameterProperties GetGenericParameterProperties(MetadataToken gpToken);
    public abstract virtual GenericParameterConstraintProperties GetGenericParameterConstraintProperties(MetadataToken gpcToken);
    public abstract virtual MetadataTokenRange GetInterfaceImplementations(MetadataToken typeToken);
    public abstract virtual MetadataTokenRange GetMethodImpls(MetadataToken typeToken);
    public abstract virtual InterfaceImplementationProperties GetInterfaceImplementationProperties(MetadataToken interfaceImplToken);
    public abstract virtual MethodImplProperties GetMethodImplProperties(MetadataToken methodImplToken);
    public abstract virtual string GetMemberName(MetadataToken memberToken);
    public abstract virtual MetadataTokenRange GetFields(MetadataToken typeToken);
    public abstract virtual FieldProperties GetFieldProperties(MetadataToken fieldToken);
    public abstract virtual MetadataTokenRange GetMethods(MetadataToken typeToken);
    public abstract virtual MethodProperties GetMethodProperties(MetadataToken methodToken);
    public abstract virtual MetadataTokenRange GetParameters(MetadataToken methodToken);
    public abstract virtual MetadataToken GetParameterByIndex(MetadataToken methodToken, UInt32 paramIndex);
    public abstract virtual ParamProperties GetParameterProperties(MetadataToken paramToken);
    public abstract virtual MetadataTokenRange GetProperties(MetadataToken typeToken);
    public abstract virtual PropertyProperties GetPropertyProperties(MetadataToken propertyToken);
    public abstract virtual MetadataTokenRange GetEvents(MetadataToken typeToken);
    public abstract virtual EventProperties GetEventProperties(MetadataToken eventToken);
    public abstract virtual MetadataToken GetEnclosingType(MetadataToken typeToken);
    public abstract virtual MetadataTokenRange GetCustomAttributes(MetadataToken ownerToken);
    public abstract virtual CustomAttributeProperties GetCustomAttributeProperties(MetadataToken customAttributeToken);
    public abstract virtual MetadataTypeReference GetCustomAttributeTypeName(MetadataToken customAttributeToken);
    public abstract virtual string GetModuleRefProperties(MetadataToken token);
    public abstract virtual MemberReferenceProperties GetMemberReferenceProperties(MetadataToken memberReferenceToken);
    public abstract virtual AssemblyRefProperties GetAssemblyRefProperties(MetadataToken assemblyRefToken);
    public abstract virtual FileProperties GetFileProperties(MetadataToken fileToken);
    public abstract virtual ManifestResourceProperties GetManifestResourceProperties(MetadataToken manifestResourceToken);
    [CanBeNullAttribute]
public abstract virtual IDictionary`2<MetadataToken, MetadataToken[]> GetMethodBodyToDeclarations(MetadataToken typeToken);
    public abstract virtual MetadataToken[] GetImplementedMethods(MetadataToken typeToken, MetadataToken methodBodyToken);
    [CanBeNullAttribute]
public abstract virtual PInvokeProperties GetPInvokeProperties(MetadataToken methodToken);
    public abstract virtual ImplMapProperties GetImplMapProperties(MetadataToken implMapToken);
    public abstract virtual EncLogProperties GetEncLogProperties(MetadataToken encLogToken);
    public abstract virtual EncMapProperties GetEncMapProperties(MetadataToken encMapToken);
    [CanBeNullAttribute]
public abstract virtual IBlob GetMarshalSpec(MetadataToken token);
    public abstract virtual MetadataTokenRange GetTypeRefs();
    public abstract virtual MetadataTokenRange GetInterfaceImpls();
    public abstract virtual MetadataTokenRange GetExportedTypes();
    public abstract virtual MetadataTokenRange GetMethodImpls();
    [CanBeNullAttribute]
public abstract virtual ClassLayout GetClassLayout(MetadataToken typeToken);
    public abstract virtual MetadataTokenRange GetDeclSecurity(MetadataToken ownerToken);
    public abstract virtual DeclSecurityProperties GetDeclSecurityProperties(MetadataToken token);
    public abstract virtual String[] GetDeclSecurityTypeNames(MetadataToken token);
    public abstract virtual MetadataToken FindTypeRef(MetadataToken resolutionScope, string qualifiedName);
    public abstract virtual MetadataToken[] FindTypeRefs(string qualifiedName);
    public abstract virtual MetadataTokenRange GetTypeSpecs();
    public abstract virtual MetadataTokenRange GetMethodSpecs();
    public abstract virtual MetadataTokenRange GetStandAloneSigs();
    public abstract virtual MetadataTokenRange GetMethods();
    public abstract virtual MetadataTokenRange GetFiles();
    public abstract virtual MetadataTokenRange GetExportedTypesFromOtherModules();
    public abstract virtual MetadataTokenRange GetManifestResources();
    public abstract virtual MetadataTokenRange GetMemberRefs();
    public abstract virtual MetadataToken[] FindMemberRefs(MetadataToken typeToken);
    public abstract virtual OneToSetMap`2<MetadataToken, MetadataToken> get_NestedTypeMap();
    public abstract virtual ReadOnlyDictionary`2<string, MetadataToken> get_TypeName2TokenMapping();
    public abstract virtual JetReadOnlyList`1<UInt32> GetMethodRvaMap();
    public abstract virtual long GetEmbeddedResourceOffset(long resourceOffset);
    public abstract virtual MetadataTokenRange GetFields();
    public abstract virtual MetadataTokenRange GetProperties();
    public abstract virtual MetadataTokenRange GetEvents();
    public abstract virtual MetadataTokenRange GetImplMaps();
    public abstract virtual MetadataTokenRange GetEncLogs();
    public abstract virtual MetadataTokenRange GetEncMaps();
    public abstract virtual MetadataTokenRange GetDocuments();
    public abstract virtual string GetDocumentName(MetadataToken documentToken);
    public abstract virtual DocumentProperties GetDocumentProperties(MetadataToken documentToken);
    public abstract virtual DebugDocument GetDocument(MetadataToken documentToken);
    public abstract virtual MetadataTokenRange GetMethodDebugInformations();
    public abstract virtual IReadOnlyList`1<SequencePoint> GetMethodDebugInformation(MetadataToken mdiToken, MetadataToken& localVariablesSignatureToken);
    public abstract virtual IReadOnlyList`1<SequencePoint> GetMethodDebugInformation(MetadataToken mdiToken);
    public abstract virtual MetadataTokenRange GetLocalScopes();
    public abstract virtual LocalScopeProperties GetLocalScopeProperties(MetadataToken localScopeToken);
    public abstract virtual MetadataTokenRange GetScopeVariables(MetadataToken localScopeToken);
    public abstract virtual MetadataTokenRange GetScopeConstants(MetadataToken localScopeToken);
    public abstract virtual LocalVariableProperties GetLocalVariableProperties(MetadataToken localVariableToken);
    public abstract virtual MetadataTokenRange GetImportScopes();
    public abstract virtual ImportScopeProperties GetImportScopeProperties(MetadataToken importScopeToken);
    public abstract virtual MetadataTokenRange GetCustomDebugInformations();
    public abstract virtual CustomDebugInformationProperties GetCustomDebugInformationProperties(MetadataToken customDebugInformationToken);
    public abstract virtual MetadataTokenRange GetStateMachineMethods();
    public abstract virtual StateMachineMethodProperties GetStateMachineMethodProperties(MetadataToken stateMachineMethodToken);
}
public interface JetBrains.Metadata.Access.IMetadataAssemblyInfo {
    [CanBeNullAttribute]
public abstract virtual AssemblyNameInfo GetAssemblyName();
    public abstract virtual Dictionary`2<MetadataToken, AssemblyReference> GetReferencedAssembliesNames();
    public abstract virtual Dictionary`2<MetadataToken, string> GetReferencedModulesNames();
    public abstract virtual ExportedTypeProperties[] GetExportedTypesFromOtherModules();
    public abstract virtual FileReference[] GetReferencedFiles();
    public abstract virtual MetadataToken GetToken();
}
public interface JetBrains.Metadata.Access.IMetadataProvider {
    [ObsoleteAttribute("Use TryGetFromAssemblyLocation")]
[CanBeNullAttribute]
public abstract virtual IMetadataAccess TryGetFromFile(VirtualFileSystemPath path);
    [ObsoleteAttribute("Use GetFromAssemblyLocation")]
[NotNullAttribute]
public abstract virtual IMetadataAccess GetFromFile(VirtualFileSystemPath path, Func`1<bool> checkForInterrupt);
    [CanBeNullAttribute]
public abstract virtual IMetadataAccess TryGetFromStream(string id, DateTime fileModificationTimeUtc, Func`1<Stream> getData);
    public abstract virtual void DisposeMetadataAccess(IMetadataAccess access);
    [NotNullAttribute]
public abstract virtual IMetadataAccess GetFromStream(string id, DateTime fileModificationTimeUtc, Func`1<Stream> getStream);
    [CanBeNullAttribute]
public abstract virtual IMetadataAccess TryGetFromAssemblyLocation(IAssemblyLocation assemblyLocation);
    [NotNullAttribute]
public abstract virtual IMetadataAccess GetFromAssemblyLocation(IAssemblyLocation assemblyLocation, Func`1<bool> checkForInterrupt);
}
public interface JetBrains.Metadata.Access.IMetadataStreamsAccess {
    public int GuidMaxIndex { get; }
    public int StringHeapSize { get; }
    public int UserStringHeapSize { get; }
    public int BlobHeapSize { get; }
    [CanBeNullAttribute]
public PdbStream PdbStream { get; }
    public abstract virtual Guid GetGuid(int index);
    [NotNullAttribute]
public abstract virtual string GetString(int offset);
    [NotNullAttribute]
public abstract virtual string GetUserString(MetadataToken pointer);
    [NotNullAttribute]
public abstract virtual IBlob GetBlob(int offset);
    [NotNullAttribute]
public abstract virtual string GetUtf8String(int blobOffset);
    [NotNullAttribute]
public abstract virtual Guid[] GetAllGuids();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<Pair`2<string, int>> GetAllUserStringsWithOffsets();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<Pair`2<string, int>> GetAllStringsWithOffsets();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<string> GetAllStrings();
    [PureAttribute]
public abstract virtual bool UserStringEqualToAsciiString(int offset, Byte[] utf8Bytes);
    [PureAttribute]
public abstract virtual bool UserStringStartsWithAsciiString(int offset, Byte[] utf8Prefix);
    [NotNullAttribute]
public abstract virtual IBinaryReader GetBlobHeapReader();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<int> GetAllBlobOffsets();
    [NotNullAttribute]
public abstract virtual ITableReader GetTableRow(MetadataToken token);
    [NotNullAttribute]
public abstract virtual ITableReader GetTableRow(MetadataTableId table, int rid);
    public abstract virtual int GetTableSize(MetadataTableId tableId);
    public abstract virtual int get_GuidMaxIndex();
    public abstract virtual int get_StringHeapSize();
    public abstract virtual int get_UserStringHeapSize();
    public abstract virtual int get_BlobHeapSize();
    public abstract virtual PdbStream get_PdbStream();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.ImplMapProperties : ValueType {
    [CompilerGeneratedAttribute]
private CorPInvokeMap <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <MemberForwarded>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <ImportScope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ImportName>k__BackingField;
    public CorPInvokeMap Flags { get; }
    public MetadataToken MemberForwarded { get; }
    public MetadataToken ImportScope { get; }
    public string ImportName { get; }
    public ImplMapProperties(CorPInvokeMap flags, MetadataToken memberForwarded, string importName, MetadataToken importScope);
    [CompilerGeneratedAttribute]
public CorPInvokeMap get_Flags();
    [CompilerGeneratedAttribute]
public MetadataToken get_MemberForwarded();
    [CompilerGeneratedAttribute]
public MetadataToken get_ImportScope();
    [CompilerGeneratedAttribute]
public string get_ImportName();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.ImportScopeProperties : ValueType {
    [CompilerGeneratedAttribute]
private MetadataToken <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Import> <Imports>k__BackingField;
    public MetadataToken Parent { get; }
    [CanBeNullAttribute]
public IList`1<Import> Imports { get; }
    public ImportScopeProperties(MetadataToken parent, IList`1<Import> imports);
    [CompilerGeneratedAttribute]
public MetadataToken get_Parent();
    [CompilerGeneratedAttribute]
public IList`1<Import> get_Imports();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.InterfaceImplementationProperties : ValueType {
    [CompilerGeneratedAttribute]
private MetadataToken <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <Interface>k__BackingField;
    public MetadataToken Owner { get; }
    public MetadataToken Interface { get; }
    public InterfaceImplementationProperties(MetadataToken owner, MetadataToken interface);
    [CompilerGeneratedAttribute]
public MetadataToken get_Owner();
    [CompilerGeneratedAttribute]
public MetadataToken get_Interface();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.LocalScopeProperties : ValueType {
    [CompilerGeneratedAttribute]
private MetadataToken <MethodDebugInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <ImportScope>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Length>k__BackingField;
    public MetadataToken MethodDebugInformation { get; }
    public MetadataToken ImportScope { get; }
    public UInt32 StartOffset { get; }
    public UInt32 Length { get; }
    public LocalScopeProperties(MetadataToken methodDebugInformation, MetadataToken importScope, UInt32 startOffset, UInt32 length);
    [CompilerGeneratedAttribute]
public MetadataToken get_MethodDebugInformation();
    [CompilerGeneratedAttribute]
public MetadataToken get_ImportScope();
    [CompilerGeneratedAttribute]
public UInt32 get_StartOffset();
    [CompilerGeneratedAttribute]
public UInt32 get_Length();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.LocalVariableProperties : ValueType {
    [CompilerGeneratedAttribute]
private LocalVariableAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public LocalVariableAttributes Attributes { get; }
    public ushort Index { get; }
    public string Name { get; }
    public LocalVariableProperties(LocalVariableAttributes attributes, ushort index, string name);
    [CompilerGeneratedAttribute]
public LocalVariableAttributes get_Attributes();
    [CompilerGeneratedAttribute]
public ushort get_Index();
    [CompilerGeneratedAttribute]
public string get_Name();
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.ManifestResourceAttributes : Enum {
    public UInt32 value__;
    public static ManifestResourceAttributes Public;
    public static ManifestResourceAttributes Private;
    public static ManifestResourceAttributes VisibilityMask;
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.ManifestResourceProperties : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ManifestResourceAttributes <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <Implementation>k__BackingField;
    public UInt32 Offset { get; }
    public string Name { get; }
    public ManifestResourceAttributes Flags { get; }
    public MetadataToken Implementation { get; }
    public ManifestResourceProperties(UInt32 offset, string name, ManifestResourceAttributes flags, MetadataToken implementation);
    [CompilerGeneratedAttribute]
public UInt32 get_Offset();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ManifestResourceAttributes get_Flags();
    [CompilerGeneratedAttribute]
public MetadataToken get_Implementation();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.MemberProperties : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Attributes>k__BackingField;
    [NotNullAttribute]
public string Name { get; }
    public int Attributes { get; }
    public MemberProperties(string name, int attributes);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_Attributes();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.MemberReferenceProperties : ValueType {
    [CompilerGeneratedAttribute]
private MetadataToken <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlob <SignatureBlob>k__BackingField;
    public MetadataToken Owner { get; }
    public string Name { get; }
    public IBlob SignatureBlob { get; }
    public MemberReferenceProperties(MetadataToken owner, string name, IBlob signatureBlob);
    [CompilerGeneratedAttribute]
public MetadataToken get_Owner();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IBlob get_SignatureBlob();
}
public class JetBrains.Metadata.Access.MetadataAccessCookie : object {
    private IMetadataAccess myMetadataAccess;
    [CanBeNullAttribute]
public IMetadataAccess MetadataAccess { get; }
    internal MetadataAccessCookie(IMetadataAccess metadataAccess);
    public IMetadataAccess get_MetadataAccess();
    public sealed virtual void Dispose();
}
public static class JetBrains.Metadata.Access.MetadataHeaps : object {
    public static string PdbHeap;
    public static string JtdHeap;
    public static string StringHeap;
    public static string GuidHeap;
    public static string BlobHeap;
    public static string UserStringHeap;
    public static string TablesHeap;
    public static string TablesHeapNonOptimized;
    public static int GuidSize;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.MetadataMemberPresenceFlags : Enum {
    public ushort value__;
    public static MetadataMemberPresenceFlags None;
    public static MetadataMemberPresenceFlags ImplicitOp;
    public static MetadataMemberPresenceFlags ExplicitOp;
    public static MetadataMemberPresenceFlags SignOp;
    public static MetadataMemberPresenceFlags MayOverrideEquals;
    public static MetadataMemberPresenceFlags RequiredMembers;
    public static MetadataMemberPresenceFlags PublicDefaultCtor;
    public static MetadataMemberPresenceFlags InstanceCtor;
    public static MetadataMemberPresenceFlags AccessibleInstanceCtor;
    public static MetadataMemberPresenceFlags AccessibleInstanceCtorWithParameters;
    public static MetadataMemberPresenceFlags AccessibleNestedTypes;
    public static MetadataMemberPresenceFlags AccessibleConstants;
    public static MetadataMemberPresenceFlags HasRecordCloneMethod;
    public static MetadataMemberPresenceFlags HasStaticAbstractMembers;
    public static MetadataMemberPresenceFlags HasStaticAbstractMembersImplementatations;
    public static MetadataMemberPresenceFlags InterfaceWithOnlyStaticOverrideableMembers;
    public static MetadataMemberPresenceFlags InterfaceWithoutOverrideableMembers;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Access.MetadataProviderEx : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use GetFromLocationDisposable")]
[NotNullAttribute]
public static MetadataAccessCookie GetFromFileDisposable(IMetadataProvider provider, VirtualFileSystemPath path);
    [ExtensionAttribute]
[NotNullAttribute]
public static MetadataAccessCookie GetFromLocationDisposable(IMetadataProvider provider, IAssemblyLocation location);
    [ExtensionAttribute]
public static MetadataAccessCookie GetFromStreamDisposable(IMetadataProvider provider, string id, DateTime fileModificationTimeUtc, Stream stream);
    [ExtensionAttribute]
public static MetadataAccessCookie GetFromStreamDisposable(IMetadataProvider provider, string id, DateTime fileModificationTimeUtc, Func`1<Stream> getData);
}
public static class JetBrains.Metadata.Access.MetadataProviderFactory : object {
    public static IMetadataProvider modreq(System.Runtime.CompilerServices.IsVolatile) DefaultProvider;
    private static MetadataProviderFactory();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Access.MetadataStreamsAccessEx : object {
    [ExtensionAttribute]
public static string GetUtf8String(IMetadataStreamsAccess streams, IBinaryReader reader, IDictionary`2<UInt32, object> blobs);
}
public enum JetBrains.Metadata.Access.MetadataTableId : Enum {
    public int value__;
    public static MetadataTableId Module;
    public static MetadataTableId TypeRef;
    public static MetadataTableId TypeDef;
    public static MetadataTableId FieldPointer;
    public static MetadataTableId Field;
    public static MetadataTableId MethodPointer;
    public static MetadataTableId MethodDef;
    public static MetadataTableId ParamPointer;
    public static MetadataTableId Param;
    public static MetadataTableId InterfaceImpl;
    public static MetadataTableId MemberRef;
    public static MetadataTableId Constant;
    public static MetadataTableId CustomAttribute;
    public static MetadataTableId FieldMarshal;
    public static MetadataTableId DeclSecurity;
    public static MetadataTableId ClassLayout;
    public static MetadataTableId FieldLayout;
    public static MetadataTableId StandAloneSig;
    public static MetadataTableId EventMap;
    public static MetadataTableId EventPointer;
    public static MetadataTableId Event;
    public static MetadataTableId PropertyMap;
    public static MetadataTableId PropertyPointer;
    public static MetadataTableId Property;
    public static MetadataTableId MethodSemantics;
    public static MetadataTableId MethodImpl;
    public static MetadataTableId ModuleRef;
    public static MetadataTableId TypeSpec;
    public static MetadataTableId ImplMap;
    public static MetadataTableId FieldRva;
    public static MetadataTableId EncLog;
    public static MetadataTableId EncMap;
    public static MetadataTableId Assembly;
    public static MetadataTableId AssemblyProcessor;
    public static MetadataTableId AssemblyOS;
    public static MetadataTableId AssemblyRef;
    public static MetadataTableId AssemblyRefProcessor;
    public static MetadataTableId AssemblyRefOS;
    public static MetadataTableId File;
    public static MetadataTableId ExportedType;
    public static MetadataTableId ManifestResource;
    public static MetadataTableId NestedClass;
    public static MetadataTableId GenericParam;
    public static MetadataTableId MethodSpec;
    public static MetadataTableId GenericParamConstraint;
    public static MetadataTableId Document;
    public static MetadataTableId MethodDebugInformation;
    public static MetadataTableId LocalScope;
    public static MetadataTableId LocalVariable;
    public static MetadataTableId LocalConstant;
    public static MetadataTableId ImportScope;
    public static MetadataTableId StateMachineMethod;
    public static MetadataTableId CustomDebugInformation;
    public static MetadataTableId GapStart;
    public static MetadataTableId GapEnd;
    public static MetadataTableId MaxTable;
}
public static class JetBrains.Metadata.Access.MetadataTablesStructure : object {
    private static string ReservedAndShallBeZero;
    public static Column UndefinedColumn;
    private static Dictionary`2<MetadataTableId, Column[]> ourStructure;
    private static MetadataTablesStructure();
    [CanBeNullAttribute]
public static Column[] TryGetTableStructure(MetadataTableId tableId);
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.MetadataToken : ValueType {
    private static UInt32 RidMask;
    private static UInt32 TypeMask;
    private static int TableIdShift;
    private static UInt32 TtAssembly;
    private static UInt32 TtAssemblyRef;
    private static UInt32 TtConstant;
    private static UInt32 TtCustomAttribute;
    private static UInt32 TtEncLog;
    private static UInt32 TtEncMap;
    private static UInt32 TtEventMap;
    private static UInt32 TtEvent;
    private static UInt32 TtExportedType;
    private static UInt32 TtField;
    private static UInt32 TtFile;
    private static UInt32 TtGenericParam;
    private static UInt32 TtGenericParamConstraint;
    private static UInt32 TtInterfaceImpl;
    private static UInt32 TtManifestResource;
    private static UInt32 TtMemberRef;
    private static UInt32 TtMethodDef;
    private static UInt32 TtMethodSpec;
    private static UInt32 TtMethodImpl;
    private static UInt32 TtModule;
    private static UInt32 TtModuleRef;
    private static UInt32 TtParam;
    private static UInt32 TtDeclSecurity;
    private static UInt32 TtPropertyMap;
    private static UInt32 TtProperty;
    private static UInt32 TtStandAloneSig;
    private static UInt32 TtTypeDef;
    private static UInt32 TtTypeRef;
    private static UInt32 TtTypeSpec;
    private static UInt32 TtImplMap;
    private static UInt32 TtDocument;
    private static UInt32 TtMethodDebugInformation;
    private static UInt32 TtLocalVariable;
    private static UInt32 TtLocalConstant;
    private static UInt32 TtImportScope;
    private static UInt32 TtCustomDebugInformation;
    public static MetadataToken Nil;
    private UInt32 myToken;
    public static IEqualityComparer`1<MetadataToken> EqualityComparer;
    public UInt32 Value { get; }
    public bool IsNil { get; }
    public UInt32 RID { get; }
    internal UInt32 Type { get; }
    public MetadataTableId TableId { get; }
    public bool IsAssembly { get; }
    public bool IsAssemblyRef { get; }
    public bool IsConstant { get; }
    public bool IsCustomAttribute { get; }
    public bool IsEncLog { get; }
    public bool IsEncMap { get; }
    public bool IsEventMap { get; }
    public bool IsEvent { get; }
    public bool IsExportedType { get; }
    public bool IsField { get; }
    public bool IsFile { get; }
    public bool IsGenericParam { get; }
    public bool IsGenericParamConstraint { get; }
    public bool IsInterfaceImpl { get; }
    public bool IsManifestResource { get; }
    public bool IsMemberRef { get; }
    public bool IsMethodDef { get; }
    public bool IsMethodSpec { get; }
    public bool IsMethodImpl { get; }
    public bool IsModule { get; }
    public bool IsModuleRef { get; }
    public bool IsParam { get; }
    public bool IsDeclSecurity { get; }
    public bool IsPropertyMap { get; }
    public bool IsProperty { get; }
    public bool IsStandAloneSig { get; }
    public bool IsTypeDef { get; }
    public bool IsTypeRef { get; }
    public bool IsTypeSpec { get; }
    public bool IsImplMap { get; }
    public bool IsDocument { get; }
    public bool IsMethodDebugInformation { get; }
    public bool IsLocalVariable { get; }
    public bool IsLocalConstant { get; }
    public bool IsImportScope { get; }
    public bool IsCustomDebugInformation { get; }
    public MetadataToken(UInt32 token);
    public MetadataToken(MetadataTableId tableId, int rid);
    private static MetadataToken();
    public static UInt32 MakeToken(MetadataTableId tableId, int rid);
    public UInt32 get_Value();
    public bool get_IsNil();
    public UInt32 get_RID();
    public static UInt32 GetRID(UInt32 token);
    [PureAttribute]
public static MetadataToken GetNextToken(MetadataToken token);
    internal UInt32 get_Type();
    public MetadataTableId get_TableId();
    public bool get_IsAssembly();
    public bool get_IsAssemblyRef();
    public bool get_IsConstant();
    public bool get_IsCustomAttribute();
    public bool get_IsEncLog();
    public bool get_IsEncMap();
    public bool get_IsEventMap();
    public bool get_IsEvent();
    public bool get_IsExportedType();
    public bool get_IsField();
    public bool get_IsFile();
    public bool get_IsGenericParam();
    public bool get_IsGenericParamConstraint();
    public bool get_IsInterfaceImpl();
    public bool get_IsManifestResource();
    public bool get_IsMemberRef();
    public bool get_IsMethodDef();
    public bool get_IsMethodSpec();
    public bool get_IsMethodImpl();
    public bool get_IsModule();
    public bool get_IsModuleRef();
    public bool get_IsParam();
    public bool get_IsDeclSecurity();
    public bool get_IsPropertyMap();
    public bool get_IsProperty();
    public bool get_IsStandAloneSig();
    public bool get_IsTypeDef();
    public bool get_IsTypeRef();
    public bool get_IsTypeSpec();
    public bool get_IsImplMap();
    public bool get_IsDocument();
    public bool get_IsMethodDebugInformation();
    public bool get_IsLocalVariable();
    public bool get_IsLocalConstant();
    public bool get_IsImportScope();
    public bool get_IsCustomDebugInformation();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MetadataToken token1, MetadataToken token2);
    public static bool op_Inequality(MetadataToken token1, MetadataToken token2);
    public static MetadataToken MakeTypedNil(MetadataTableId table);
    public bool IsInRange(MetadataTokenRange range);
    public static MetadataToken op_Implicit(UInt32 token);
    public static MetadataToken op_Implicit(int token);
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.MetadataTokenRange : ValueType {
    public static MetadataTokenRange Empty;
    [CompilerGeneratedAttribute]
private int <EndRid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartRid>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataTableId <TableId>k__BackingField;
    public int EndRid { get; }
    public int StartRid { get; }
    public MetadataTableId TableId { get; }
    public int Length { get; }
    public MetadataTokenRange(MetadataTableId tableId, int startRid, int endRid);
    private static MetadataTokenRange();
    [CompilerGeneratedAttribute]
public int get_EndRid();
    [CompilerGeneratedAttribute]
public int get_StartRid();
    [CompilerGeneratedAttribute]
public MetadataTableId get_TableId();
    public int get_Length();
    [PureAttribute]
public bool Contains(MetadataToken token);
    public Enumerator GetEnumerator();
    public static MetadataTokenRange CreateEmptyRange(MetadataTableId tableId);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Access.MetadataTokenRangeEx : object {
    [ExtensionAttribute]
public static IList`1<MetadataToken> ToList(MetadataTokenRange range);
    [IteratorStateMachineAttribute("JetBrains.Metadata.Access.MetadataTokenRangeEx/<ToEnumerable>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<MetadataToken> ToEnumerable(MetadataTokenRange range);
}
public enum JetBrains.Metadata.Access.MetadataTokenType : Enum {
    public int value__;
    public static MetadataTokenType Module;
    public static MetadataTokenType TypeRef;
    public static MetadataTokenType TypeDef;
    public static MetadataTokenType FieldPointer;
    public static MetadataTokenType Field;
    public static MetadataTokenType MethodPointer;
    public static MetadataTokenType MethodDef;
    public static MetadataTokenType ParamPointer;
    public static MetadataTokenType Param;
    public static MetadataTokenType InterfaceImpl;
    public static MetadataTokenType MemberRef;
    public static MetadataTokenType Constant;
    public static MetadataTokenType CustomAttribute;
    public static MetadataTokenType FieldMarshal;
    public static MetadataTokenType DeclSecurity;
    public static MetadataTokenType ClassLayout;
    public static MetadataTokenType FieldLayout;
    public static MetadataTokenType StandAloneSig;
    public static MetadataTokenType EventMap;
    public static MetadataTokenType EventPointer;
    public static MetadataTokenType Event;
    public static MetadataTokenType PropertyMap;
    public static MetadataTokenType PropertyPointer;
    public static MetadataTokenType Property;
    public static MetadataTokenType MethodSemantics;
    public static MetadataTokenType MethodImpl;
    public static MetadataTokenType ModuleRef;
    public static MetadataTokenType TypeSpec;
    public static MetadataTokenType ImplMap;
    public static MetadataTokenType FieldRva;
    public static MetadataTokenType EncLog;
    public static MetadataTokenType EncMap;
    public static MetadataTokenType Assembly;
    public static MetadataTokenType AssemblyProcessor;
    public static MetadataTokenType AssemblyOS;
    public static MetadataTokenType AssemblyRef;
    public static MetadataTokenType AssemblyRefProcessor;
    public static MetadataTokenType AssemblyRefOS;
    public static MetadataTokenType File;
    public static MetadataTokenType ExportedType;
    public static MetadataTokenType ManifestResource;
    public static MetadataTokenType NestedClass;
    public static MetadataTokenType GenericParam;
    public static MetadataTokenType MethodSpec;
    public static MetadataTokenType GenericParamConstraint;
    public static MetadataTokenType Document;
    public static MetadataTokenType MethodDebugInformation;
    public static MetadataTokenType LocalScope;
    public static MetadataTokenType LocalVariable;
    public static MetadataTokenType LocalConstant;
    public static MetadataTokenType ImportScope;
    public static MetadataTokenType StateMachineMethod;
    public static MetadataTokenType CustomDebugInformation;
    public static MetadataTokenType MaxTableTokenType;
    public static MetadataTokenType TypeDefOrRef;
    public static MetadataTokenType HasConstant;
    public static MetadataTokenType CustomAttributeType;
    public static MetadataTokenType HasSemantics;
    public static MetadataTokenType ResolutionScope;
    public static MetadataTokenType HasFieldMarshal;
    public static MetadataTokenType HasDeclSecurity;
    public static MetadataTokenType MemberRefParent;
    public static MetadataTokenType MethodDefOrRef;
    public static MetadataTokenType MemberForwarded;
    public static MetadataTokenType Implementation;
    public static MetadataTokenType HasCustomAttribute;
    public static MetadataTokenType TypeOrMethodDef;
    public static MetadataTokenType HasCustomDebugInformation;
    public static MetadataTokenType MaxCodedTokenType;
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.MethodImplProperties : ValueType {
    [CompilerGeneratedAttribute]
private MetadataToken <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <MethodBody>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <MethodDeclaration>k__BackingField;
    public MetadataToken Owner { get; }
    public MetadataToken MethodBody { get; }
    public MetadataToken MethodDeclaration { get; }
    public MethodImplProperties(MetadataToken owner, MetadataToken methodBody, MetadataToken methodDeclaration);
    [CompilerGeneratedAttribute]
public MetadataToken get_Owner();
    [CompilerGeneratedAttribute]
public MetadataToken get_MethodBody();
    [CompilerGeneratedAttribute]
public MetadataToken get_MethodDeclaration();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.MethodProperties : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlob <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CodeRVA>k__BackingField;
    [CompilerGeneratedAttribute]
private CorMethodAttr <MethodFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private CorMethodImpl <ImplFlags>k__BackingField;
    public string Name { get; }
    public MetadataToken DeclaringType { get; }
    public IBlob Signature { get; }
    public UInt32 CodeRVA { get; }
    public CorMethodAttr MethodFlags { get; }
    public CorMethodImpl ImplFlags { get; }
    public MethodProperties(string name, MetadataToken declaringType, IBlob signature, UInt32 codeRVA, CorMethodAttr methodFlags, CorMethodImpl implFlags);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public MetadataToken get_DeclaringType();
    [CompilerGeneratedAttribute]
public IBlob get_Signature();
    [CompilerGeneratedAttribute]
public UInt32 get_CodeRVA();
    [CompilerGeneratedAttribute]
public CorMethodAttr get_MethodFlags();
    [CompilerGeneratedAttribute]
public CorMethodImpl get_ImplFlags();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.MethodSpecProperties : ValueType {
    [CompilerGeneratedAttribute]
private MetadataToken <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlob <Instantiation>k__BackingField;
    public MetadataToken Method { get; }
    public IBlob Instantiation { get; }
    public MethodSpecProperties(MetadataToken method, IBlob instantiation);
    [CompilerGeneratedAttribute]
public MetadataToken get_Method();
    [CompilerGeneratedAttribute]
public IBlob get_Instantiation();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.ParamProperties : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private CorParamAttr <ParamFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ElementType <ValueElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlob <Value>k__BackingField;
    public string Name { get; }
    public UInt32 Index { get; }
    public MetadataToken Method { get; }
    public CorParamAttr ParamFlags { get; }
    public ElementType ValueElementType { get; }
    public IBlob Value { get; }
    public ParamProperties(string name, UInt32 index, MetadataToken method, CorParamAttr paramFlags, ElementType valueElementType, IBlob value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public UInt32 get_Index();
    [CompilerGeneratedAttribute]
public MetadataToken get_Method();
    [CompilerGeneratedAttribute]
public CorParamAttr get_ParamFlags();
    [CompilerGeneratedAttribute]
public ElementType get_ValueElementType();
    [CompilerGeneratedAttribute]
public IBlob get_Value();
}
public class JetBrains.Metadata.Access.PInvokeProperties : object {
    [CompilerGeneratedAttribute]
private CorPInvokeMap <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <ImportScope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ImportName>k__BackingField;
    public CorPInvokeMap Flags { get; }
    public MetadataToken ImportScope { get; }
    public string ImportName { get; }
    public PInvokeProperties(CorPInvokeMap flags, string importName, MetadataToken importScope);
    [CompilerGeneratedAttribute]
public CorPInvokeMap get_Flags();
    [CompilerGeneratedAttribute]
public MetadataToken get_ImportScope();
    [CompilerGeneratedAttribute]
public string get_ImportName();
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.Prologs : Enum {
    public byte value__;
    public static Prologs Default;
    public static Prologs Cdecl;
    public static Prologs Stdcall;
    public static Prologs Thiscall;
    public static Prologs Fastcall;
    public static Prologs VarArg;
    public static Prologs FieldSig;
    public static Prologs LocalSig;
    public static Prologs PropertySig;
    public static Prologs Unmanaged;
    public static Prologs Generic;
    public static Prologs GenricInst;
    public static Prologs HasThis;
    public static Prologs ExplicitThis;
    public static Prologs PermissionSetBlob20;
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.PropertyProperties : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private CorPropertyAttr <PropertyFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlob <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <Getter>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <Setter>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken[] <OtherMethods>k__BackingField;
    public string Name { get; }
    public MetadataToken DeclaringType { get; }
    public CorPropertyAttr PropertyFlags { get; }
    public IBlob Signature { get; }
    public MetadataToken Getter { get; }
    public MetadataToken Setter { get; }
    public MetadataToken[] OtherMethods { get; }
    public PropertyProperties(string name, MetadataToken declaringType, CorPropertyAttr propertyFlags, IBlob signature, MetadataToken getter, MetadataToken setter, MetadataToken[] otherMethods);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public MetadataToken get_DeclaringType();
    [CompilerGeneratedAttribute]
public CorPropertyAttr get_PropertyFlags();
    [CompilerGeneratedAttribute]
public IBlob get_Signature();
    [CompilerGeneratedAttribute]
public MetadataToken get_Getter();
    [CompilerGeneratedAttribute]
public MetadataToken get_Setter();
    [CompilerGeneratedAttribute]
public MetadataToken[] get_OtherMethods();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.StateMachineMethodProperties : ValueType {
    [CompilerGeneratedAttribute]
private MetadataToken <MoveNextMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <KickoffMethod>k__BackingField;
    public MetadataToken MoveNextMethod { get; }
    public MetadataToken KickoffMethod { get; }
    public StateMachineMethodProperties(MetadataToken moveNextMethod, MetadataToken kickoffMethod);
    [CompilerGeneratedAttribute]
public MetadataToken get_MoveNextMethod();
    [CompilerGeneratedAttribute]
public MetadataToken get_KickoffMethod();
}
public enum JetBrains.Metadata.Access.TargetPlatform : Enum {
    public int value__;
    public static TargetPlatform Unknown;
    public static TargetPlatform AnyCpu;
    public static TargetPlatform X86;
    public static TargetPlatform X64;
    public static TargetPlatform AnyCpuPrefer32Bit;
    public static TargetPlatform Arm;
    public static TargetPlatform Arm64;
    public static TargetPlatform Itanium;
    public static TargetPlatform Wasm;
    public static TargetPlatform S390x;
    public static TargetPlatform LoongArch64;
    public static TargetPlatform Armv6;
    public static TargetPlatform Ppc64le;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Access.TargetPlatformUtil : object {
    private static string targetPlatformAnyCpu;
    private static string targetPlatformAnyCpuPrefer32Bit;
    private static string targetPlatformX86;
    private static string targetPlatformX64;
    private static string targetPlatformArm;
    private static string targetPlatformArm64;
    private static string targetPlatformItanium;
    private static string targetPlatformWasm;
    private static string targetPlatformS390x;
    private static string targetPlatformLoongArch64;
    private static string targetPlatformArmv6;
    private static string targetPlatformPpc64le;
    private static TargetPlatformUtil();
    [ExtensionAttribute]
public static TargetPlatform ToTargetPlatform(JetArchitecture architecture);
    [ExtensionAttribute]
public static JetArchitecture ToArchitecture(TargetPlatform architecture);
    public static TargetPlatform GetTargetPlatform(MachineId machine, CLIFlags cliFlags, PESignature pe);
    public static ProcessorArchitecture GetProcessorArchitecture(AssemblyFlags assemblyFlags);
    public static ProcessorArchitecture GetProcessorArchitecture(AssemblyFlags assemblyFlags, MachineId coffHeaderMachine, PESignature peHeaderSignature, CLIFlags cliHeaderFlags);
    public static ProcessorArchitecture GetProcessorArchitecture(Stream stream, string imageMoniker);
    public static ProcessorArchitecture GetProcessorArchitecture(IAssemblyLocation assemblyLocation);
    public static ProcessorArchitecture GetProcessorArchitecture(VirtualFileSystemPath assemblyLocation);
    [ObsoleteAttribute("Use overload with IAssemblyLocation")]
public static TargetPlatform GetTargetPlatform(VirtualFileSystemPath path, bool detectNative);
    public static TargetPlatform GetTargetPlatform(IAssemblyLocation assemblyLocation, bool detectNative);
    public static TargetPlatform GetTargetPlatform(IAssemblyLocation assemblyLocation, bool detectNative, NativeImageType& nativeImageType);
    [NotNullAttribute]
public static string GetTargetPlatformString(TargetPlatform targetPlatform);
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.TypeDefProperties : ValueType {
    [CompilerGeneratedAttribute]
private MetadataToken <Base>k__BackingField;
    [CompilerGeneratedAttribute]
private CorTypeAttr <TypeDefFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public string FullName { get; }
    public MetadataToken Base { get; }
    public CorTypeAttr TypeDefFlags { get; }
    [NotNullAttribute]
public string NamespaceName { get; }
    [NotNullAttribute]
public string TypeName { get; }
    public TypeDefProperties(MetadataToken base, CorTypeAttr typeDefFlags, string namespaceName, string typeName);
    public string get_FullName();
    [CompilerGeneratedAttribute]
public MetadataToken get_Base();
    [CompilerGeneratedAttribute]
public CorTypeAttr get_TypeDefFlags();
    [CompilerGeneratedAttribute]
public string get_NamespaceName();
    [CompilerGeneratedAttribute]
public string get_TypeName();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Access.TypeRefProperties : ValueType {
    [CompilerGeneratedAttribute]
private MetadataToken <ResolutionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public MetadataToken ResolutionScope { get; }
    public string NamespaceName { get; }
    public string TypeName { get; }
    public string FullName { get; }
    public TypeRefProperties(MetadataToken resolutionScope, string namespaceName, string typeName);
    [CompilerGeneratedAttribute]
public MetadataToken get_ResolutionScope();
    [CompilerGeneratedAttribute]
public string get_NamespaceName();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    public string get_FullName();
}
public class JetBrains.Metadata.ApiVerifier.ApiModelVerifier : object {
    [NotNullAttribute]
private LifetimeDefinition myLifetimeDefinition;
    [NotNullAttribute]
private IReadOnlyList`1<IMetadataAssembly> myApiModel;
    [NotNullAttribute]
private IReadOnlyList`1<IMetadataAssembly> myUsageModel;
    [CanBeNullAttribute]
private IErrorConsumer myErrorConsumer;
    [CanBeNullAttribute]
private Action`1<IMetadataEntity> myUsingConsumer;
    private bool myVerificationResult;
    private Lifetime Lifetime { get; }
    public ApiModelVerifier(Lifetime lifetime, IReadOnlyList`1<IMetadataAssembly> apiModel, IReadOnlyList`1<IMetadataAssembly> usageModel, IErrorConsumer errorConsumer, Action`1<IMetadataEntity> usingConsumer);
    private Lifetime get_Lifetime();
    public bool Verify();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.ApiVerifier.ApiVerifierHelper : object {
    public static IEqualityComparer`1<IMetadataType> TypeComparer;
    private static ApiVerifierHelper();
    [IteratorStateMachineAttribute("JetBrains.Metadata.ApiVerifier.ApiVerifierHelper/<LoadStreamBasedAssemblies>d__2")]
public static IEnumerable`1<IMetadataAssembly> LoadStreamBasedAssemblies(Lifetime lifetime, IEnumerable`1<Func`1<Stream>> assemblies, IAssemblyResolver additionalResolver);
    [IteratorStateMachineAttribute("JetBrains.Metadata.ApiVerifier.ApiVerifierHelper/<LoadAssemblies>d__3")]
public static IEnumerable`1<IMetadataAssembly> LoadAssemblies(Lifetime lifetime, IEnumerable`1<VirtualFileSystemPath> locations, IAssemblyResolver additionalResolver);
    public static IReadOnlyList`1<VirtualFileSystemPath> CollectGac40AssemblyPaths();
    public static bool IsGenericType(IMetadataClassType classType);
    public static bool IsGenericType(IMetadataType metadataType);
    public static MetadataToken GetAssemblyRef(IMetadataAssembly assembly, MetadataToken typeRef);
    [CanBeNullAttribute]
public static MethodSpecification SearchMethodInType(IMetadataClassType type, string name, MethodSignature signature);
    [CanBeNullAttribute]
public static FieldSpecification SearchFieldInType(IMetadataClassType type, string name, FieldSignature signature);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataClassType ResolveMetadataClassTypeWithConsumer(Resolver resolver, IMetadataAssembly currentAssembly, AssemblyNameInfo assemblyNameInfo, IMetadataClassType classTypeRef, LifetimeDefinition lifetimeDefinition, IErrorConsumer errorConsumer);
    public static bool VerificationEnabled(IMetadataAssembly metadataAssembly);
}
public class JetBrains.Metadata.ApiVerifier.AssemblyChecker : object {
    private static ILogger ourLogger;
    [NotNullAttribute]
private LifetimeDefinition myLifetimeDefinition;
    [NotNullAttribute]
private Resolver myResolver;
    [NotNullAttribute]
private IMetadataAssembly myMetadataAssembly;
    private bool myVerificationResult;
    private MethodBodyUsagesFinder myMethodBodyUsagesFinder;
    private static List`1<ValueTuple`3<ErrorKind, Func`2<IMetadataClassType, bool>, bool>> ourTypeInspections;
    private static List`1<ValueTuple`3<ErrorKind, Func`2<FieldSpecification, bool>, bool>> ourFieldInspections;
    private static List`1<ValueTuple`3<ErrorKind, Func`2<MethodSpecification, bool>, bool>> ourMethodInspections;
    private Lifetime Lifetime { get; }
    public AssemblyChecker(Lifetime lifetime, Resolver resolver, IMetadataAssembly metadataAssembly);
    private static AssemblyChecker();
    private Lifetime get_Lifetime();
    public bool Check(IErrorConsumer errorConsumer, Action`1<IMetadataEntity> usingConsumer);
    private void CheckMethodDefs(IErrorConsumer errorConsumer);
    private void CheckTypeRefs(IErrorConsumer errorConsumer, Action`1<IMetadataEntity> usingConsumer);
    private CheckerSurface CreateCheckerSurface(IErrorConsumer errorConsumer);
    private void CheckFieldRefs(IErrorConsumer errorConsumer, Action`1<IMetadataEntity> usingConsumer, IEnumerable`1<FieldInfo> fields);
    private void CheckMethodRefs(IErrorConsumer errorConsumer, Action`1<IMetadataEntity> usingConsumer, IEnumerable`1<MethodInfo> methods);
    [NotNullAttribute]
private static IReadOnlyList`1<ErrorPath> TransformUsages(IEnumerable`1<MethodUsageCount> usages);
    private static bool IsTypeObsolete(IMetadataClassType classTypeDef);
    private static bool IsTypeReducingVisibility(IMetadataClassType classTypeDef);
    private static bool IsMethodNotFound(MethodSpecification methodSpec);
    private static bool IsMethodObsolete(MethodSpecification methodSpec);
    private static bool IsMethodReducingVisibility(MethodSpecification methodSpec);
    private static bool IsFieldNotFound(FieldSpecification fieldSpec);
    private static bool IsFieldObsolete(FieldSpecification fieldSpec);
    private static bool IsFieldReducingVisibility(FieldSpecification fieldSpec);
    [NotNullAttribute]
private MethodBodyUsagesFinder GetFinder();
    [CanBeNullAttribute]
private AssemblyNameInfo GetAssemblyNameInfo(MetadataToken assemblyRefToken);
    [CanBeNullAttribute]
private IMetadataClassType GetMetadataClassTypeByTypeRef(MetadataToken typeRefToken, IErrorConsumer errorConsumer);
    [CanBeNullAttribute]
private IMetadataClassType GetMetadataClassType(MetadataToken typeDefOrRefOrSpec, IErrorConsumer errorConsumer);
}
internal static class JetBrains.Metadata.ApiVerifier.AssemblyNameInfoHelper : object {
    private static UInt32 WindowsRuntime;
    [CanBeNullAttribute]
public static AssemblyNameInfo CreateAssemblyName(AssemblyRefProperties properties, JetAssemblyHashAlgorithm hashAlgID);
}
public enum JetBrains.Metadata.ApiVerifier.ErrorKind : Enum {
    public int value__;
    public static ErrorKind AssemblyNotFound;
    public static ErrorKind TypeNotFound;
    public static ErrorKind MethodNotFound;
    public static ErrorKind FieldNotFound;
    public static ErrorKind TypeReducingVisibility;
    public static ErrorKind MethodReducingVisibility;
    public static ErrorKind FieldReducingVisibility;
    public static ErrorKind ImplementationNotFound;
    public static ErrorKind MethodObsolete;
    public static ErrorKind FieldObsolete;
    public static ErrorKind TypeObsolete;
    public static ErrorKind RefStructBoxing;
}
public class JetBrains.Metadata.ApiVerifier.ErrorPath : object {
    [CompilerGeneratedAttribute]
private AssemblyDescription <Assembly>k__BackingField;
    [NotNullAttribute]
public AssemblyDescription Assembly { get; }
    public ErrorPath(AssemblyDescription assembly);
    [CompilerGeneratedAttribute]
public AssemblyDescription get_Assembly();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.ApiVerifier.ErrorPathHelper : object {
    [NotNullAttribute]
public static ErrorPath GetAssemblyPath(AssemblyNameInfo assemblyNameInfo);
    [NotNullAttribute]
public static ErrorPath GetTypePath(AssemblyNameInfo assemblyNameInfo, IMetadataClassType type);
    [NotNullAttribute]
public static ErrorPath GetMethodPath(AssemblyNameInfo assemblyNameInfo, IMetadataClassType type, string methodName, MethodSignature methodSignature);
    [ExtensionAttribute]
private static string ToPrettyString(MethodSignature methodSignature, string methodName);
    [NotNullAttribute]
public static ErrorPath GetMethodPath(AssemblyNameInfo assemblyNameInfo, IMetadataTypeInfo typeInfo, string methodName, MethodSignature methodSignature);
    [NotNullAttribute]
public static ErrorPath GetMethodPath(AssemblyNameInfo assemblyNameInfo, IMetadataClassType type, IMetadataMethod method);
    public static ErrorPath GetFieldPath(AssemblyNameInfo assemblyNameInfo, IMetadataClassType type, string fieldName, FieldSignature fieldSignature);
    [ExtensionAttribute]
private static string ToPrettyString(FieldSignature fieldSignature, string fieldName);
    [NotNullAttribute]
public static ErrorPath GetFieldPath(AssemblyNameInfo assemblyNameInfo, IMetadataClassType type, IMetadataField field);
}
public class JetBrains.Metadata.ApiVerifier.ErrorReport : object {
    [CompilerGeneratedAttribute]
private ErrorKind <ErrorKind>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorPath <BrokenPart>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ErrorPath> <Usages>k__BackingField;
    public ErrorKind ErrorKind { get; }
    [NotNullAttribute]
public ErrorPath BrokenPart { get; }
    [NotNullAttribute]
public IReadOnlyList`1<ErrorPath> Usages { get; }
    public ErrorReport(ErrorKind errorKind, ErrorPath brokenPart, IReadOnlyList`1<ErrorPath> usages);
    [CompilerGeneratedAttribute]
public ErrorKind get_ErrorKind();
    [CompilerGeneratedAttribute]
public ErrorPath get_BrokenPart();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ErrorPath> get_Usages();
}
public interface JetBrains.Metadata.ApiVerifier.IErrorConsumer {
    public abstract virtual void OnError(ErrorReport report);
}
public class JetBrains.Metadata.ApiVerifier.Resolver : object {
    private IDictionary`2<AssemblyNameInfo, IMetadataAssembly> myAssemblies;
    private IDictionary`2<IMetadataAssembly, IDictionary`2<string, IMetadataClassType>> myTypeDefs;
    private IDictionary`2<IMetadataAssembly, IDictionary`2<string, IMetadataClassType>> myExportedTypes;
    public Resolver(IEnumerable`1<IMetadataAssembly> assemblies, IEqualityComparer`1<AssemblyNameInfo> comparer);
    [CanBeNullAttribute]
public IMetadataAssembly ResolveMetadataAssembly(AssemblyNameInfo assemblyNameInfo);
    public ValueTuple`2<ResolveMetadataClassTypeStatus, IMetadataClassType> ResolveMetadataClassType(AssemblyNameInfo assemblyNameInfo, string fullName);
}
public class JetBrains.Metadata.ApiVerifier.TypeChecker : object {
    private static ILogger ourLogger;
    [NotNullAttribute]
private LifetimeDefinition myLifetimeDefinition;
    [NotNullAttribute]
private Resolver myResolver;
    [NotNullAttribute]
private IMetadataAssembly myMetadataAssembly;
    [NotNullAttribute]
private IMetadataClassType myMetadataClassType;
    [CanBeNullAttribute]
private TypeChecker myBase;
    [CanBeNullAttribute]
private IReadOnlyList`1<TypeChecker> myInterfaces;
    [CanBeNullAttribute]
private IReadOnlyList`1<MethodSpecification> myMethodImpls;
    private bool myVerificationResult;
    private Lifetime Lifetime { get; }
    public TypeChecker(Lifetime lifetime, Resolver resolver, IMetadataAssembly metadataAssembly, IMetadataClassType metadataClassType);
    private static TypeChecker();
    private Lifetime get_Lifetime();
    public bool Check(IErrorConsumer errorConsumer);
    private void CheckAbstractMethods(IErrorConsumer errorConsumer);
    private void CheckInterfaceImplementations(IErrorConsumer errorConsumer);
    [CanBeNullAttribute]
private TypeChecker GetBase(IErrorConsumer errorConsumer);
    [NotNullAttribute]
private IReadOnlyList`1<TypeChecker> GetInterfaces(IErrorConsumer errorConsumer);
    [NotNullAttribute]
private IReadOnlyList`1<IMetadataMethod> GetMethodsRecursive(IErrorConsumer errorConsumer, Predicate`1<IMetadataMethod> predicate);
    [NotNullAttribute]
private IReadOnlyList`1<IMetadataMethod> GetMethods(Predicate`1<IMetadataMethod> predicate);
    [NotNullAttribute]
private IReadOnlyList`1<MethodSpecification> GetMethodImpls(IErrorConsumer errorConsumer);
    [NotNullAttribute]
private IReadOnlyList`1<MethodSpecification> GetMethodImplsRecursive(IErrorConsumer errorConsumer);
    [CanBeNullAttribute]
private IMetadataClassType GetMetadataClassType(MetadataToken typeRefToken, IErrorConsumer errorConsumer);
    [CanBeNullAttribute]
private AssemblyNameInfo GetAssemblyNameInfo(MetadataToken assemblyRefToken);
}
[DebuggerDisplayAttribute("Key(pos={Position,nq}}")]
public class JetBrains.Metadata.Baml.Reader.BamlKeyInfo : ValueType {
    [DebuggerBrowsableAttribute("0")]
private int myPosition;
    [DebuggerBrowsableAttribute("0")]
private bool myShared;
    public int Position { get; }
    public bool Shared { get; }
    public BamlKeyInfo(int position, bool shared);
    public int get_Position();
    public bool get_Shared();
}
public static class JetBrains.Metadata.Baml.Reader.BamlKnownResources : object {
    private static BamlTypeInfo SysColors { get; }
    private static BamlTypeInfo SysFonts { get; }
    private static BamlTypeInfo SysParams { get; }
    private static BamlTypeInfo MenuItem { get; }
    private static BamlTypeInfo GridView { get; }
    private static BamlTypeInfo StatusBar { get; }
    private static BamlTypeInfo ToolBar { get; }
    public static BamlPropertyInfo GetMember(short memberId);
    private static short GetResourceKeyFromBamlId(short bamlId, Boolean& isKey);
    private static BamlTypeInfo GetType(string typeName);
    private static BamlTypeInfo get_SysColors();
    private static BamlTypeInfo get_SysFonts();
    private static BamlTypeInfo get_SysParams();
    private static BamlTypeInfo get_MenuItem();
    private static BamlTypeInfo get_GridView();
    private static BamlTypeInfo get_StatusBar();
    private static BamlTypeInfo get_ToolBar();
    private static BamlPropertyInfo GetStaticResourceKey(short id);
    private static BamlPropertyInfo GetResource(short id);
}
public class JetBrains.Metadata.Baml.Reader.BamlKnownTypes : object {
    public static BamlTypeInfo GetTypeInfo(short knownTypeId);
    public static BamlPropertyInfo GetPropertyInfo(short propertyId);
    private static BamlTypeInfo GetType(short id);
    private static BamlPropertyInfo GetProperty(short id);
}
public static class JetBrains.Metadata.Baml.Reader.BamlMetadataUtils : object {
    public static void ForAllBamlResources(IMetadataAssembly metadataAssembly, Predicate`1<string> bamlResourceFilter, Action`2<string, Stream> processBaml, Action`1<Exception> onResourceReaderException);
}
public abstract class JetBrains.Metadata.Baml.Reader.BamlPredefinedProvider : object {
    public BamlTypeInfo XType { get; }
    public BamlTypeInfo XStatic { get; }
    public BamlTypeInfo TemplateBinding { get; }
    public BamlTypeInfo StaticResource { get; }
    public BamlTypeInfo DynamicResource { get; }
    public BamlTypeInfo Binding { get; }
    public BamlTypeInfo RelativeSource { get; }
    public BamlTypeInfo NullExtension { get; }
    public abstract virtual BamlTypeInfo GetKnownType(short typeId);
    public abstract virtual BamlPropertyInfo GetPropertyInfo(short propertyId);
    public abstract virtual BamlPropertyInfo GetXStaticMember(short memberId);
    public BamlTypeInfo get_XType();
    public BamlTypeInfo get_XStatic();
    public BamlTypeInfo get_TemplateBinding();
    public BamlTypeInfo get_StaticResource();
    public BamlTypeInfo get_DynamicResource();
    public BamlTypeInfo get_Binding();
    public BamlTypeInfo get_RelativeSource();
    public BamlTypeInfo get_NullExtension();
}
[DebuggerDisplayAttribute("{DeclaringType.FullName,nq}.{Name,nq}")]
public class JetBrains.Metadata.Baml.Reader.BamlPropertyInfo : ValueType {
    [DebuggerBrowsableAttribute("0")]
private string myName;
    [DebuggerBrowsableAttribute("0")]
private BamlTypeInfo myDeclaringType;
    public static BamlPropertyInfo Unknown;
    public bool IsUnknown { get; }
    [NotNullAttribute]
public string Name { get; }
    public BamlTypeInfo DeclaringType { get; }
    public BamlPropertyInfo(string name, BamlTypeInfo declaringType);
    private static BamlPropertyInfo();
    public bool get_IsUnknown();
    public string get_Name();
    public BamlTypeInfo get_DeclaringType();
    public sealed virtual bool Equals(BamlPropertyInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public bool IsXamlPredefined(string name);
    public static BamlPropertyInfo XamlPredefined(string name);
    public static bool op_Equality(BamlPropertyInfo left, BamlPropertyInfo right);
    public static bool op_Inequality(BamlPropertyInfo left, BamlPropertyInfo right);
}
public class JetBrains.Metadata.Baml.Reader.BamlReader : object {
    [NotNullAttribute]
private Stream myStream;
    [NotNullAttribute]
private BinaryReaderEx myReader;
    [NotNullAttribute]
private List`1<string> myAssemblies;
    [NotNullAttribute]
private Dictionary`2<short, BamlTypeInfo> myTypeTable;
    [NotNullAttribute]
private Dictionary`2<short, BamlPropertyInfo> myPropertyTable;
    [NotNullAttribute]
private Dictionary`2<short, string> myStringTable;
    [NotNullAttribute]
private BamlPredefinedProvider myPredefined;
    [NotNullAttribute]
private HashSet`1<int> myRuntimeNames;
    [NotNullAttribute]
private IBamlConsumer myConsumer;
    private BamlReader(Stream stream, IBamlConsumer consumer, BamlPredefinedProvider predefinedProvider);
    private void Read();
    public static void Read(Stream stream, IBamlConsumer consumer, BamlPredefinedProvider predefinedProvider);
    [NotNullAttribute]
private string GetAssembly(short id);
    private BamlTypeInfo GetTypeInfo(short id);
    private BamlPropertyInfo GetPropertyInfo(short id);
    private BamlPropertyInfo GetStaticMember(short id);
    [NotNullAttribute]
private string GetString(short id);
    private void ReadAssemblyInfo();
    private void ReadTypeInfo();
    private void ReadAttributeInfo();
    private void ReadStringInfo();
    private void ReadBamlHeader();
    private void ReadDocumentStart();
    private void ReadDocumentEnd();
    private void ReadConnectionId();
    private void ReadDeferableContentStart();
    private void ReadTypeSerializerInfo();
    private void ReadUnsupported(BamlRecordType recordType);
    private void ReadElementStart();
    private void ReadElementEnd();
    private void ReadProperty();
    private void ReadPropertyComplexStart();
    private void ReadPropertyComplexEnd();
    private void ReadPropertyDictionaryStart();
    private void ReadPropertyDictionaryEnd();
    private void ReadPropertyArrayStart();
    private void ReadPropertyArrayEnd();
    private void ReadPropertyListStart();
    private void ReadPropertyListEnd();
    private void ReadPropertyCustom();
    private void ReadContentProperty();
    private void ReadPropertyWithConverter();
    private void ReadPropertyWithExtension();
    private void ReadPropertyTypeReference();
    private void ReadDefAttribute();
    private void ReadPresentationOptionsAttribute();
    [NotNullAttribute]
private string ReadPropertyCustomSolidBrush();
    [NotNullAttribute]
private string ReadPropertyCustomIntCollection();
    [NotNullAttribute]
private string ReadPropertyCustomPoint2D();
    [NotNullAttribute]
private string ReadPropertyCustomPoint3D();
    private void ReadXmlnsProperty();
    private void ReadNamespaceMapping();
    private void ReadText();
    private void ReadTextWithConverter();
    private void ReadTextWithId();
    private void ReadLiteralContent();
    private void ReadConstructorParametersStart();
    private void ReadConstructorParametersEnd();
    private void ReadConstructorParameterType();
    private void ReadDefAttributeKeyString();
    private void ReadDefAttributeKeyType();
    private void ReadKeyElementStart();
    private void ReadKeyElementEnd();
    private void ReadStaticResourceStart();
    private void ReadStaticResourceEnd();
    private void ReadStaticResourceId();
    private void ReadPropertyWithStaticResourceId();
    private void ReadOptimizedStaticResource();
    private void ReadLineNumberAndPosition();
    private void ReadLinePosition();
    [ConditionalAttribute("NEVER_EVER")]
[StringFormatMethodAttribute("format")]
private void TraceEnd(string format, Object[] args);
    [ConditionalAttribute("NEVER_EVER")]
[StringFormatMethodAttribute("format")]
private void TraceDebug(string format, Object[] args);
    [ConditionalAttribute("NEVER_EVER")]
[StringFormatMethodAttribute("format")]
private void Trace(string format, Object[] args);
    private int ReadRecordSize(BamlRecordType recordType);
}
[DebuggerDisplayAttribute("{FullName,nq}")]
public class JetBrains.Metadata.Baml.Reader.BamlTypeInfo : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CanBeNullAttribute]
private string myTypeName;
    [DebuggerBrowsableAttribute("0")]
[CanBeNullAttribute]
private string myAssemblyName;
    private static string UnknownText;
    private static string PredefinedXamlAssemblyName;
    private static string PredefinedXmlAssemblyName;
    public static BamlTypeInfo Unknown;
    public static BamlTypeInfo XmlPredefined;
    public static BamlTypeInfo XamlPredefined;
    public static BamlTypeInfo PresentationOptions;
    [NotNullAttribute]
public string FullName { get; }
    [NotNullAttribute]
public string AssemblyName { get; }
    public bool IsUnknown { get; }
    public bool IsPredefinedOrUnknown { get; }
    [NotNullAttribute]
private string TypeReferenceName { get; }
    [NotNullAttribute]
public string Namespace { get; }
    [NotNullAttribute]
public string ShortName { get; }
    public BamlTypeInfo(string typeName, string assemblyName);
    private static BamlTypeInfo();
    public string get_FullName();
    public string get_AssemblyName();
    public bool get_IsUnknown();
    public bool get_IsPredefinedOrUnknown();
    private string get_TypeReferenceName();
    public string get_Namespace();
    public string get_ShortName();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BamlTypeInfo other);
    public virtual int GetHashCode();
    public static bool op_Equality(BamlTypeInfo left, BamlTypeInfo right);
    public static bool op_Inequality(BamlTypeInfo left, BamlTypeInfo right);
    public virtual string ToString();
}
internal class JetBrains.Metadata.Baml.Reader.BinaryReaderEx : BinaryReader {
    public BinaryReaderEx(Stream input);
    public BinaryReaderEx(Stream input, Encoding encoding);
    public double ReadPackedDouble();
    public int ReadPackedInt();
}
public class JetBrains.Metadata.Baml.Reader.DefaultBamlPredefinedProvider : BamlPredefinedProvider {
    public static BamlPredefinedProvider Instance;
    private static DefaultBamlPredefinedProvider();
    public virtual BamlTypeInfo GetKnownType(short typeId);
    public virtual BamlPropertyInfo GetPropertyInfo(short propertyId);
    public virtual BamlPropertyInfo GetXStaticMember(short memberId);
}
public interface JetBrains.Metadata.Baml.Reader.IBamlConsumer {
    public bool IsProcessingFinished { get; }
    public abstract virtual bool get_IsProcessingFinished();
    public abstract virtual void BeginElement(BamlTypeInfo type, long streamPosition);
    public abstract virtual void EndElement();
    public abstract virtual void NamespaceMapping(string xmlNamespace, string clrNamespace, string assembly);
    public abstract virtual void XmlnsDeclaration(string prefix, string value);
    public abstract virtual void Connection(int connectionId);
    public abstract virtual void Property(BamlPropertyInfo property, string value);
    public abstract virtual void PropertyDeclaration(BamlPropertyInfo property, string value);
    public abstract virtual void PropertyWithConverter(BamlPropertyInfo property, BamlTypeInfo converterType, string value);
    public abstract virtual void PropertyResource(BamlPropertyInfo property, bool isDynamic, string resourceKey);
    public abstract virtual void PropertyResource(BamlPropertyInfo property, bool isDynamic, BamlPropertyInfo member);
    public abstract virtual void PropertyResource(BamlPropertyInfo property, bool isDynamic, BamlTypeInfo keyType);
    public abstract virtual void PropertyXStatic(BamlPropertyInfo property, BamlPropertyInfo member);
    public abstract virtual void PropertyXType(BamlPropertyInfo property, BamlTypeInfo type);
    public abstract virtual void PropertyTemplateBinding(BamlPropertyInfo property, BamlPropertyInfo templateProperty);
    public abstract virtual void PropertyCustom(BamlPropertyInfo property, BamlPropertyInfo propertyValue);
    public abstract virtual void PropertyCustom(BamlPropertyInfo property, string propertyValue);
    public abstract virtual void PropertyStaticResourceId(BamlPropertyInfo property, short staticResourceId);
    public abstract virtual void PropertyContent(BamlPropertyInfo property);
    public abstract virtual void BeginDictionaryProperty(BamlPropertyInfo property);
    public abstract virtual void BeginComplexProperty(BamlPropertyInfo property);
    public abstract virtual void BeginArrayProperty(BamlPropertyInfo property);
    public abstract virtual void BeginListProperty(BamlPropertyInfo property);
    public abstract virtual void EndDictionaryProperty();
    public abstract virtual void EndComplexProperty();
    public abstract virtual void EndArrayProperty();
    public abstract virtual void EndListProperty();
    public abstract virtual void KeyAttributeString(string keyString, BamlKeyInfo key);
    public abstract virtual void KeyAttributeType(BamlTypeInfo type, BamlKeyInfo key);
    public abstract virtual void BeginKeyElement(BamlTypeInfo type, BamlKeyInfo key);
    public abstract virtual void EndKeyElement();
    public abstract virtual void OptimizedStaticResource(BamlTypeInfo type);
    public abstract virtual void OptimizedStaticResource(BamlPropertyInfo property);
    public abstract virtual void OptimizedStaticResource(string resourceKey);
    public abstract virtual void StaticResourceId(short staticResourceId);
    public abstract virtual void BeginStaticResource(BamlTypeInfo type);
    public abstract virtual void EndStaticResource();
    public abstract virtual void BeginConstructorArguments();
    public abstract virtual void ConstructorParameterType(BamlTypeInfo type);
    public abstract virtual void EndConstructorArguments();
    public abstract virtual void Text(string value);
    public abstract virtual void TextWithConverter(string value, BamlTypeInfo converterType);
    public abstract virtual void LiteralContent(string text);
    public abstract virtual void LineAndPosition(int line, int position);
    public abstract virtual void Position(int position);
}
internal class JetBrains.Metadata.Baml.Reader.KnownColors : object {
    [NotNullAttribute]
public static string FromArgb(UInt32 argb);
}
public class JetBrains.Metadata.Baml.Reader.MetadataBamlPredefinedProvider : BamlPredefinedProvider {
    [NotNullAttribute]
private IMetadataAssembly myAssembly;
    [NotNullAttribute]
private Dictionary`2<BamlTypeInfo, BamlTypeInfo> myTypeMap;
    public MetadataBamlPredefinedProvider(IMetadataAssembly assembly);
    private BamlTypeInfo Resolve(BamlTypeInfo predefinedType);
    public virtual BamlTypeInfo GetKnownType(short typeId);
    public virtual BamlPropertyInfo GetPropertyInfo(short propertyId);
    public virtual BamlPropertyInfo GetXStaticMember(short memberId);
}
internal class JetBrains.Metadata.Baml.Reader.PathDataParser : object {
    private BinaryReaderEx myReader;
    private StringBuilder myBuilder;
    private char myLastChar;
    public PathDataParser(BinaryReaderEx reader);
    public string ParseStreamGeometry();
    private void AddArcRecord(bool bit3, bool bit4);
    private void AddPathCommand(char commandChar);
    private void AddPathPoint(bool bit1, bool bit2);
    private void AddPathPoint();
    private static string Invariant(double value);
    private double ReadPathDouble(bool isInt);
}
[DebuggerDisplayAttribute("{Namespace,nq} ({Assembly,nq})")]
public class JetBrains.Metadata.Baml.Reader.ReferencedNamespace : ValueType {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private string myNamespace;
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private string myAssembly;
    [NotNullAttribute]
public string Namespace { get; }
    [NotNullAttribute]
public string Assembly { get; }
    public ReferencedNamespace(string ns, string assembly);
    public string get_Namespace();
    public string get_Assembly();
    public sealed virtual bool Equals(ReferencedNamespace other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Metadata.Debug.CodeTextWriter.BeginTypeMemberMarker : object {
    [CompilerGeneratedAttribute]
private MetadataToken <Token>k__BackingField;
    public MetadataToken Token { get; }
    public BeginTypeMemberMarker(MetadataToken token);
    [CompilerGeneratedAttribute]
public MetadataToken get_Token();
}
public class JetBrains.Metadata.Debug.CodeTextWriter.EndTypeMemberMarker : object {
}
public interface JetBrains.Metadata.Debug.CodeTextWriter.IDebugDataMarker {
}
public interface JetBrains.Metadata.Debug.CodeTextWriter.InstructionReference.IInstructionReference {
    [NotNullAttribute]
public IMethodBody MethodBody { get; }
    [NotNullAttribute]
public Instruction Instruction { get; }
    [NotNullAttribute]
public Instruction SequencePointInstruction { get; }
    public abstract virtual IMethodBody get_MethodBody();
    public abstract virtual Instruction get_Instruction();
    public abstract virtual Instruction get_SequencePointInstruction();
}
internal class JetBrains.Metadata.Debug.CodeTextWriter.InstructionReference.InstructionReference : object {
    [CompilerGeneratedAttribute]
private IMethodBody <MethodBody>k__BackingField;
    [CompilerGeneratedAttribute]
private Instruction <Instruction>k__BackingField;
    [CompilerGeneratedAttribute]
private Instruction <SequencePointInstruction>k__BackingField;
    public IMethodBody MethodBody { get; }
    public Instruction Instruction { get; }
    public Instruction SequencePointInstruction { get; }
    public InstructionReference(Instruction instruction, Instruction sequencePointInstruction, IMethodBody methodBody);
    [CompilerGeneratedAttribute]
public sealed virtual IMethodBody get_MethodBody();
    [CompilerGeneratedAttribute]
public sealed virtual Instruction get_Instruction();
    [CompilerGeneratedAttribute]
public sealed virtual Instruction get_SequencePointInstruction();
    public virtual bool Equals(object obj);
    public bool Equals(InstructionReference other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Debug.CodeTextWriter.InstructionReference.InstructionReferenceUtil : object {
    [ExtensionAttribute]
public static IInstructionReference CreateInstructionReference(Instruction instruction, IMethodBody methodBody, IInstructionRedirector sequencePointInstructionRedirector);
    [CanBeNullAttribute]
public static IInstructionReference ChooseFirstSequencePoint(IInstructionReference ir1, IInstructionReference ir2);
    public static int GetInstructionIndex(IInstructionReference ir);
    [CanBeNullAttribute]
public static Instruction GetPreviousInstruction(IInstructionReference ir, Func`2<Instruction, bool> condition);
    [CanBeNullAttribute]
public static Instruction GetNextInstruction(IInstructionReference ir, Func`2<Instruction, bool> condition);
    [CanBeNullAttribute]
public static Instruction GetNextInstructionExcept(IInstructionReference ir, Func`2<Instruction, bool> skipCondition);
}
public interface JetBrains.Metadata.Debug.CodeTextWriter.ISequencePointMarker {
    [NotNullAttribute]
public IInstructionReference InstructionReference { get; }
    public SequencePointMarkerType MarkerType { get; }
    public abstract virtual IInstructionReference get_InstructionReference();
    public abstract virtual SequencePointMarkerType get_MarkerType();
}
public interface JetBrains.Metadata.Debug.CodeTextWriter.ITextAndDebugDataWriter {
    public bool WriteDebugData { get; }
    [NotNullAttribute]
public IDebugDataCollector DebugDataCollector { get; }
    public abstract virtual bool get_WriteDebugData();
    public abstract virtual void WriteTypeName(IClrTypeName clrTypeName);
    public abstract virtual void WriteAttributeTypeName(IClrTypeName clrTypeName);
    public abstract virtual IDebugDataCollector get_DebugDataCollector();
}
public class JetBrains.Metadata.Debug.CodeTextWriter.MetadataRenderOrchestrationOptions : object {
    [CompilerGeneratedAttribute]
private DebugData <DebugData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowSequencePointInfoInComments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DocumentIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLinesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ImportStart>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ImportEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private IPreRenderOptimizations <PreRenderOptimizations>k__BackingField;
    [CompilerGeneratedAttribute]
private IIdentifierFixer <IdentifierFixer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OwnNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private FormatterOptions <FormatterOptions>k__BackingField;
    [CanBeNullAttribute]
public DebugData DebugData { get; public set; }
    public bool ShowSequencePointInfoInComments { get; public set; }
    public int DocumentIndex { get; public set; }
    public int StartLinesCount { get; public set; }
    [NotNullAttribute]
public string ImportStart { get; }
    [NotNullAttribute]
public string ImportEnd { get; }
    public IPreRenderOptimizations PreRenderOptimizations { get; }
    [NotNullAttribute]
public IIdentifierFixer IdentifierFixer { get; }
    [CanBeNullAttribute]
public string OwnNamespace { get; }
    [NotNullAttribute]
public FormatterOptions FormatterOptions { get; }
    public MetadataRenderOrchestrationOptions(string importStart, string importEnd, IPreRenderOptimizations preRenderOptimizations, IIdentifierFixer identifierFixer, string ownNamespace, FormatterOptions formatterOptions);
    [CompilerGeneratedAttribute]
public DebugData get_DebugData();
    [CompilerGeneratedAttribute]
public void set_DebugData(DebugData value);
    [CompilerGeneratedAttribute]
public bool get_ShowSequencePointInfoInComments();
    [CompilerGeneratedAttribute]
public void set_ShowSequencePointInfoInComments(bool value);
    [CompilerGeneratedAttribute]
public int get_DocumentIndex();
    [CompilerGeneratedAttribute]
public void set_DocumentIndex(int value);
    [CompilerGeneratedAttribute]
public int get_StartLinesCount();
    [CompilerGeneratedAttribute]
public void set_StartLinesCount(int value);
    [CompilerGeneratedAttribute]
public string get_ImportStart();
    [CompilerGeneratedAttribute]
public string get_ImportEnd();
    [CompilerGeneratedAttribute]
public IPreRenderOptimizations get_PreRenderOptimizations();
    [CompilerGeneratedAttribute]
public IIdentifierFixer get_IdentifierFixer();
    [CompilerGeneratedAttribute]
public string get_OwnNamespace();
    [CompilerGeneratedAttribute]
public FormatterOptions get_FormatterOptions();
}
public class JetBrains.Metadata.Debug.CodeTextWriter.MetadataRenderOrchestrator`1 : object {
    private SwitchableTextAndDebugDataWriter<TRenderer> mySwitchableTextAndDebugDataWriter;
    private TRenderer myRenderer;
    private MetadataRenderOrchestrationOptions myOptions;
    private MetadataRenderOrchestrator`1(SwitchableTextAndDebugDataWriter<TRenderer> switchableTextAndDebugDataWriter, TRenderer renderer, MetadataRenderOrchestrationOptions options);
    public static MetadataRenderOrchestrator`1<TRenderer> CreateForMetadataView(MetadataRenderOrchestrationOptions options, Func`2<ITextAndDebugDataWriter, TRenderer> rendererFactory);
    public static MetadataRenderOrchestrator`1<TRenderer> CreateForDecompiler(MetadataRenderOrchestrationOptions options, Func`2<ITextAndDebugDataWriter, TRenderer> rendererFactory);
    private static MetadataRenderOrchestrator`1<TRenderer> Create(MetadataRenderOrchestrationOptions options, Func`2<ITextAndDebugDataWriter, TRenderer> rendererFactory, IDebugDataCollector debugDataCollector);
    public string DoRender(Action`1<TRenderer> render);
    public string DoRender(Action`2<TRenderer, IProgressIndicator> render, IProgressIndicator indicator);
    private ValueTuple`2<HashSet`1<IClrTypeName>, HashSet`1<IClrTypeName>> CollectTypeNames(Action`2<TRenderer, IProgressIndicator> render, IProgressIndicator indicator);
    private ITypesPresentation PreRenderOptimizations(ICollection`1<IClrTypeName> referencedTypeNames, ICollection`1<IClrTypeName> referencedAttributeTypeNames);
    private Tuple`3<string, SequencePointCollection, TypeMemberRangeCollection> RenderOptimized(Action`2<TRenderer, IProgressIndicator> render, ITypesPresentation typesPresentation);
    private void RenderImportedNamespaces(String[] importedNamespaces);
    private void AddToDebugData(SequencePointCollection sequencePoints, TypeMemberRangeCollection typeMemberRanges, String[] importedNamespaces);
}
internal class JetBrains.Metadata.Debug.CodeTextWriter.OptimizingTypeNameTextAndDebugDataWriter : TextAndDebugDataWriterBase {
    private ITypesPresentation myTypesPresentation;
    public OptimizingTypeNameTextAndDebugDataWriter(DebugData debugData, bool showSequencePointInfoInComments, int documentIndex, int startLinesCount, ITypesPresentation typesPresentation, FormatterOptions formatterOptions, IIdentifierFixer identifierFixer);
    public virtual void WriteTypeName(IClrTypeName clrTypeName);
    public virtual void WriteAttributeTypeName(IClrTypeName clrTypeName);
}
public class JetBrains.Metadata.Debug.CodeTextWriter.SequencePointBeginStatementMarker : object {
    [CompilerGeneratedAttribute]
private IInstructionReference <InstructionReference>k__BackingField;
    public IInstructionReference InstructionReference { get; }
    public SequencePointMarkerType MarkerType { get; }
    public SequencePointBeginStatementMarker(IInstructionReference instructionReference);
    [CompilerGeneratedAttribute]
public sealed virtual IInstructionReference get_InstructionReference();
    public sealed virtual SequencePointMarkerType get_MarkerType();
}
internal class JetBrains.Metadata.Debug.CodeTextWriter.SequencePointCollection : object {
    private Dictionary`2<MetadataToken, Dictionary`2<int, CursorPosition>> myStart;
    private Dictionary`2<MetadataToken, List`1<SequencePoint>> mySequencePoints;
    private Dictionary`2<MetadataToken, HashSet`1<int>> mySpIlOffsets;
    private Dictionary`2<MetadataToken, HashSet`1<int>> myDuplicatedSpOffsets;
    private Dictionary`2<MetadataToken, IMethodBody> myMethodBodies;
    private int myDocumentIndex;
    public SequencePointCollection(int documentIndex);
    [IteratorStateMachineAttribute("JetBrains.Metadata.Debug.CodeTextWriter.SequencePointCollection/<GetSequencePointsForMethod>d__7")]
public IEnumerable`1<SequencePoint> GetSequencePointsForMethod(MetadataToken methodToken);
    public IEnumerable`1<MetadataToken> GetMethods();
    public void AddSequencePointStart(IInstructionReference instructionReference, int cursorLine, int cursorColumn);
    public void AddSequencePointEnd(IInstructionReference instructionReference, int cursorLine, int cursorColumn);
    private void AddSequencePoint(IInstructionReference instructionReference, int startLine, int startColumn, int endLine, int endColumn);
}
public class JetBrains.Metadata.Debug.CodeTextWriter.SequencePointEndStatementMarker : object {
    [CompilerGeneratedAttribute]
private IInstructionReference <InstructionReference>k__BackingField;
    public IInstructionReference InstructionReference { get; }
    public SequencePointMarkerType MarkerType { get; }
    public SequencePointEndStatementMarker(IInstructionReference instructionReference);
    [CompilerGeneratedAttribute]
public sealed virtual IInstructionReference get_InstructionReference();
    public sealed virtual SequencePointMarkerType get_MarkerType();
}
public enum JetBrains.Metadata.Debug.CodeTextWriter.SequencePointMarkerType : Enum {
    public int value__;
    public static SequencePointMarkerType BeginStatementMarker;
    public static SequencePointMarkerType EndStatementMarker;
}
internal class JetBrains.Metadata.Debug.CodeTextWriter.SimpleStringBuilder : object {
    private StringBuilder myStringBuilder;
    public sealed virtual void Append(string s);
    public sealed virtual string GetText();
    public sealed virtual int GetCurrentLine();
    public sealed virtual int GetCurrentColumn();
}
internal abstract class JetBrains.Metadata.Debug.CodeTextWriter.TextAndDebugDataWriterBase : CodeTextWriterWithLineLengthEstimationBase {
    private bool myShowSequencePointInfoInComments;
    [CompilerGeneratedAttribute]
private SequencePointCollection <SequencePoints>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeMemberRangeCollection <TypeMemberRanges>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteDebugData>k__BackingField;
    [CompilerGeneratedAttribute]
private IDebugDataCollector <DebugDataCollector>k__BackingField;
    public SequencePointCollection SequencePoints { get; }
    public TypeMemberRangeCollection TypeMemberRanges { get; }
    public bool WriteDebugData { get; }
    public IDebugDataCollector DebugDataCollector { get; }
    protected TextAndDebugDataWriterBase(DebugData debugData, bool showSequencePointInfoInComments, int documentIndex, int startLinesCount, FormatterOptions formatterOptions, IIdentifierFixer identifierFixer);
    private static ICursorPositionStringBuilder CreateCursorPositionStringBuilder(DebugData debugData, int documentIndex, int startLinesCount);
    [CompilerGeneratedAttribute]
public SequencePointCollection get_SequencePoints();
    [CompilerGeneratedAttribute]
public TypeMemberRangeCollection get_TypeMemberRanges();
    protected virtual void WriteTypeNameInternal(string namespaceName, string typeName, bool attribute);
    public virtual void WriteMarker(ICodeMarker marker);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_WriteDebugData();
    public abstract virtual void WriteTypeName(IClrTypeName clrTypeName);
    public abstract virtual void WriteAttributeTypeName(IClrTypeName clrTypeName);
    [CompilerGeneratedAttribute]
public sealed virtual IDebugDataCollector get_DebugDataCollector();
}
internal class JetBrains.Metadata.Debug.CodeTextWriter.TypeMemberRangeCollection : object {
    private int myDocumentIndex;
    private Stack`1<MetadataToken> myCurrentPath;
    private Dictionary`2<UInt32, TypeMemberRange> myRanges;
    private List`1<MetadataToken> myTokens;
    public TypeMemberRangeCollection(int documentIndex);
    public void AddToDebugData(DebugData debugData);
    private TypeMemberRange[] GetTypeMemberRanges();
    public void AddTypeMemberRangeStart(MetadataToken token, int cursorLine, int cursorColumn);
    public void AddTypeMemberRangeEnd(int cursorLine, int cursorColumn);
}
internal class JetBrains.Metadata.Debug.CodeTextWriter.TypeNameCollectingTextWriter : object {
    [CompilerGeneratedAttribute]
private HashSet`1<IClrTypeName> <TypeNames>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<IClrTypeName> <AttributeTypeNames>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Indent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteDebugData>k__BackingField;
    [CompilerGeneratedAttribute]
private IDebugDataCollector <DebugDataCollector>k__BackingField;
    public HashSet`1<IClrTypeName> TypeNames { get; }
    public HashSet`1<IClrTypeName> AttributeTypeNames { get; }
    public int Indent { get; public set; }
    public bool WriteDebugData { get; }
    public IDebugDataCollector DebugDataCollector { get; }
    public bool IsCurrentLineEmpty { get; }
    [CompilerGeneratedAttribute]
public HashSet`1<IClrTypeName> get_TypeNames();
    [CompilerGeneratedAttribute]
public HashSet`1<IClrTypeName> get_AttributeTypeNames();
    public sealed virtual void WriteTypeName(IClrTypeName clrTypeName);
    public sealed virtual void WriteAttributeTypeName(IClrTypeName clrTypeName);
    public sealed virtual void WriteTypeName(string namespaceName, string typeName);
    public sealed virtual void WriteAttributeTypeName(string namespaceName, string typeName);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Indent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Indent(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_WriteDebugData();
    [CompilerGeneratedAttribute]
public sealed virtual IDebugDataCollector get_DebugDataCollector();
    public sealed virtual bool get_IsCurrentLineEmpty();
    public sealed virtual void WriteText(string text);
    public sealed virtual void WriteNewLine();
    public sealed virtual void EnsureNewLine();
    public sealed virtual void WriteIdentifier(string id);
    public sealed virtual void WriteMarker(ICodeMarker marker);
}
public static class JetBrains.Metadata.Debug.CustomDebugInformationKinds : object {
    public static Guid StateMachineHoistedLocalScopes;
    public static Guid DynamicLocalVariables;
    public static Guid DefaultNamespace;
    public static Guid EditAndContinueLocalSlotMap;
    public static Guid EditAndContinueLambdaAndClosureMap;
    public static Guid EditAndContinueStateMachineStateMap;
    public static Guid EmbeddedSource;
    public static Guid SourceLink;
    public static Guid CompilationMetadataReferences;
    public static Guid CompilationOptions;
    public static Guid AsyncMethodSteppingInformation;
    public static Guid TupleElementNames;
    public static Guid TypeDefinitionDocuments;
    public static Guid PrimaryConstructorInformation;
    private static CustomDebugInformationKinds();
}
public class JetBrains.Metadata.Debug.DebugData : object {
    [CompilerGeneratedAttribute]
private Nullable`1<MetadataToken> <UserEntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ImportScope <ModuleImportScope>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemPath <OriginalPdbFilePath>k__BackingField;
    [NotNullAttribute]
public Dictionary`2<int, TypeMemberRange[]> DocumentToMemberRanges;
    private int myMaxDocumentIndex;
    private object myMaxDocumentIndexLockObject;
    private object myDocumentsLockObject;
    private Dictionary`2<int, DebugDocument> myDocumentIndexToDocument;
    private Dictionary`2<Byte[], DebugDocument> myDocumentChecksumToDocument;
    private Dictionary`2<string, DebugDocument> myDocumentUrlToDocument;
    private Dictionary`2<FileSystemPath, DebugDocument> myDocumentPathToDocument;
    private Dictionary`2<MetadataToken, DebugMethod> myMethods;
    private Dictionary`2<RVA, DebugMethod> myNativeMethods;
    private int myMaxImportScopeIndex;
    private Dictionary`2<ImportScope, int> myImportScopeIndices;
    public Nullable`1<MetadataToken> UserEntryPoint { get; }
    public DebugDocument[] Documents { get; }
    public DebugMethod[] Methods { get; }
    [NotNullAttribute]
public ImportScope ModuleImportScope { get; }
    [CanBeNullAttribute]
public FileSystemPath OriginalPdbFilePath { get; }
    public bool IsEmpty { get; }
    public DebugData(IEnumerable`1<DebugDocument> documents, IEnumerable`1<DebugMethod> methods, Nullable`1<MetadataToken> userEntryPoint, ImportScope moduleImportScope, FileSystemPath originalPdbFilePath, bool detachMethods);
    [CompilerGeneratedAttribute]
public Nullable`1<MetadataToken> get_UserEntryPoint();
    public DebugDocument[] get_Documents();
    public DebugMethod[] get_Methods();
    [CompilerGeneratedAttribute]
public ImportScope get_ModuleImportScope();
    [CompilerGeneratedAttribute]
public FileSystemPath get_OriginalPdbFilePath();
    public bool get_IsEmpty();
    [NotNullAttribute]
public DebugDocument CreateDocument(string url);
    [NotNullAttribute]
public DebugDocument CreateDocument(string url, Guid documentType, Guid language, Guid languageVendor, Guid checksumAlgorithmId, Byte[] checksum);
    [NotNullAttribute]
private DebugDocument CreateDocument(DebugDocument baseDocument);
    [NotNullAttribute]
public DebugDocument GetOrCreateDocument(string url);
    internal DebugDocument GetOrCreateDocument(DebugDocument baseDocument);
    [CanBeNullAttribute]
public DebugDocument TryGetDocument(string url);
    [CanBeNullAttribute]
public DebugDocument TryGetDocument(FileSystemPath path);
    [CanBeNullAttribute]
public DebugDocument TryGetBestMatchingDocument(FileSystemPath path);
    private static int CalculateMatchScore(FileSystemPath path1, FileSystemPath path2);
    [CanBeNullAttribute]
public DebugDocument TryGetDocument(int index);
    [CanBeNullAttribute]
public DebugDocument TryGetDocument(Byte[] checksum);
    [CanBeNullAttribute]
public DebugDocument TryGetDocument(PdbDocumentInfo documentInfo);
    [NotNullAttribute]
public DebugMethod CreateMethod(MetadataToken methodToken, MetadataToken localVariablesSignatureToken, int codeLength, ImportScope importScope, IReadOnlyList`1<SequencePoint> sequencePoints, MethodCustomDebugInformation methodCustomDebugInformation);
    [NotNullAttribute]
public DebugMethod CreateNativeMethod(RVA rva, int codeLength, IReadOnlyList`1<SequencePoint> sequencePoints);
    [CanBeNullAttribute]
public DebugMethod TryGetMethod(MetadataToken methodToken);
    [NotNullAttribute]
public DebugMethod GetMethod(MetadataToken methodToken);
    private void AddDocument(DebugDocument document);
    private void AddMethod(DebugMethod method);
    private void AddNativeMethod(DebugMethod method);
    private int GetNextDocumentIndex();
    private void TestDocumentIndex(int index);
    internal void ProcessImportScope(ImportScope importScope);
    internal int GetImportScopeIndex(ImportScope importScope);
    internal ICollection`1<KeyValuePair`2<ImportScope, int>> GetImportScopesSortedByIndex();
    public static DebugData CreateEmptyDebugData();
    public DebugMethod TryGetNativeMethod(RVA methodStartRva);
}
public class JetBrains.Metadata.Debug.DebugDataCollector : object {
    private DebugData myDebugData;
    public DebugDataCollector(DebugData debugData);
    public sealed virtual void AddMethod(IMethodBody methodBody);
    public sealed virtual void AddLocalVariable(IMethodBodyLocalVariable localVariable, string name, LocalVariableAttributes attributes, TupleElementNamesData tupleElementNames);
    public sealed virtual void AddLocalVariable(IMethodBodyLocalVariable localVariable, string name, LocalVariableAttributes attributes, int scopeStartOffset, int scopeEndOffset, TupleElementNamesData tupleElementNames);
    public sealed virtual void AddStateMachineHoistedLocalScopes(MetadataToken method, StateMachineHoistedLocalScopesData stateMachineHoistedLocalScopes);
    public sealed virtual void AddAsyncMethodSteppingInformation(MetadataToken method, AsyncMethodSteppingInformationData asyncMethodSteppingInformation);
    public sealed virtual void AddKickoffMethod(MetadataToken moveNextMethod, MetadataToken kickoffMethod);
    public sealed virtual void AddStateMachineTypeName(string stateMachineTypeName, MetadataToken kickoffMethod);
}
public class JetBrains.Metadata.Debug.DebugDataCollectorStub : object {
    public sealed virtual void AddMethod(IMethodBody methodBody);
    public sealed virtual void AddLocalVariable(IMethodBodyLocalVariable localVariable, string name, LocalVariableAttributes attributes, TupleElementNamesData tupleElementNames);
    public sealed virtual void AddLocalVariable(IMethodBodyLocalVariable localVariable, string name, LocalVariableAttributes attributes, int scopeStartOffset, int scopeEndOffset, TupleElementNamesData tupleElementNames);
    public sealed virtual void AddStateMachineHoistedLocalScopes(MetadataToken method, StateMachineHoistedLocalScopesData stateMachineHoistedLocalScopes);
    public sealed virtual void AddAsyncMethodSteppingInformation(MetadataToken method, AsyncMethodSteppingInformationData asyncMethodSteppingInformation);
    public sealed virtual void AddKickoffMethod(MetadataToken moveNextMethod, MetadataToken kickoffMethod);
    public sealed virtual void AddStateMachineTypeName(string stateMachineTypeName, MetadataToken kickoffMethod);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Debug.DebugDataExtensions : object {
    [ExtensionAttribute]
public static int SingleDocumentIndex(DebugData debugData);
    [ExtensionAttribute]
public static int SingleDocumentIndex(DebugMethod method);
    [ExtensionAttribute]
public static DebugDocument[] SortedDocuments(DebugData debugData);
    [ExtensionAttribute]
public static DebugMethod[] SortedMethods(DebugData debugData);
    [ExtensionAttribute]
[NotNullAttribute]
public static DebugMethod CreateMethod(DebugData debugData, PdbFunction pdbFunction);
    [ExtensionAttribute]
[NotNullAttribute]
public static DebugMethod CreateNativeMethod(DebugData debugData, NativePdbFunction pdbFunction);
    [ExtensionAttribute]
private static void ProcessScopes(DebugMethod method, PdbScope scope, ImportScope importScope, PdbFunction pdbFunction);
    [CanBeNullAttribute]
private static TupleElementNamesData TryGetTupleElementNames(PdbFunction pdbFunction, PdbVariable variable);
    [NotNullAttribute]
private static DebugLocalVariable CreateLocalVariable(int index, string name, LocalVariableAttributes attributes, MetadataToken localSignatureToken, DebugMethod method, TupleElementNamesData tupleElementNames);
    [ExtensionAttribute]
public static void AddLocalVariable(DebugMethod method, int index, string name, LocalVariableAttributes attributes, MetadataToken localSignatureToken, TupleElementNamesData tupleElementNames);
    [ExtensionAttribute]
internal static void AddLocalVariable(DebugMethod method, int index, string name, LocalVariableAttributes attributes, MetadataToken localSignatureToken, TupleElementNamesData tupleElementNames, int scopeStartOffset, int scopeEndOffset, ImportScope importScope);
    [ExtensionAttribute]
internal static void AddLocalVariables(DebugMethod method, DebugLocalVariable[] localVariables, int scopeStartOffset, int scopeEndOffset, ImportScope importScope);
    [CanBeNullAttribute]
private static DebugLocalVariable TryGetLocalVariable(LocalScope localScope, int variableIndex, int offset);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static DebugLocalVariable TryGetLocalVariable(DebugMethod debugMethod, int variableIndex, int offset);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string TryGetLocalVariableName(DebugData debugData, MetadataToken methodToken, int variableIndex, int offset);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static String[] TryGetLocalVariableTupleElementNames(DebugData debugData, MetadataToken methodToken, int variableIndex, int offset);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static String[] TryGetLocalVariableTupleElementNames(DebugData debugData, MetadataToken methodToken, int variableIndex);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICollection`1<LocalVariableInLocalScope> GetLocalVariables(DebugData debugData, MetadataToken methodToken, int variableIndex);
    private static void CollectLocalVariables(LocalScope scope, int variableIndex, List`1<LocalVariableInLocalScope> result);
    [ExtensionAttribute]
internal static void CollectLocalScopes(LocalScope localScope, List`1<LocalScope> localScopes);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICollection`1<DebugLocalVariable> GetLocalVariables(DebugData debugData, MetadataToken methodToken);
    private static void CollectLocalVariables(LocalScope scope, List`1<DebugLocalVariable> result);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static PdbTupleInfo[] CollectTupleElementNamesFromVariables(DebugMethod method);
    private static void CollectTupleElementNamesFromVariables(LocalScope scope, SortedDictionary`2<Pair`2<int, string>, PdbTupleInfo> result);
    [IteratorStateMachineAttribute("JetBrains.Metadata.Debug.DebugDataExtensions/<GetSequencePoints>d__24")]
[ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<SequencePointInMethod> GetSequencePoints(DebugData debugData, int documentIndex, int line, int column);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static Nullable`1<SequencePointInMethod> TryGetInnerSequencePoint(DebugData debugData, int documentIndex, int line, int column);
    [ExtensionAttribute]
public static void GetSequencePointsNearPosition(DebugData debugData, int documentIndex, int line, int column, Nullable`1& before, Nullable`1& after);
    [ExtensionAttribute]
private static bool Contains(SequencePoint& sequencePoint, int line, int column);
    [ExtensionAttribute]
private static bool IsBefore(SequencePoint& sequencePoint, int line, int column);
    [ExtensionAttribute]
private static bool IsAfter(SequencePoint& sequencePoint, int line, int column);
    [ExtensionAttribute]
public static SequencePoint ToSequencePoint(PdbSequencePoint& sequencePoint, int documentIndex);
    [ExtensionAttribute]
[NotNullAttribute]
public static DebugData CreateDocumentSection(DebugData debugData, int documentIndex, string documentNewUrl);
    [ExtensionAttribute]
[NotNullAttribute]
public static DebugData CreateDocumentsSection(DebugData debugData, Int32[] documentIndices, String[] documentNewUrls);
    [ExtensionAttribute]
private static bool HasSequencePointsForSources(DebugMethod method, Int32[] documentIndices);
    [ExtensionAttribute]
[NotNullAttribute]
private static DebugMethod CreateDetachedDocumentSection(DebugMethod method, Int32[] documentIndices, Dictionary`2<int, ImportScope> indexToClonedImportScope);
    [CanBeNullAttribute]
private static ImportScope GetClonedImportScope(ImportScope importScope, DebugData debugData, Dictionary`2<int, ImportScope> indexToClonedImportScope);
    [ExtensionAttribute]
[NotNullAttribute]
private static DebugDocument Clone(DebugDocument debugDocument, string newDocumentUrl);
    [ExtensionAttribute]
private static SequencePoint Clone(SequencePoint& sequencePoint);
    [ExtensionAttribute]
[NotNullAttribute]
private static DebugLocalVariable[] Clone(ICollection`1<DebugLocalVariable> localVariables);
    [ExtensionAttribute]
[NotNullAttribute]
private static DebugLocalVariable Clone(DebugLocalVariable localVariable);
    [ExtensionAttribute]
[CanBeNullAttribute]
private static MethodCustomDebugInformation Clone(MethodCustomDebugInformation methodCustomDebugInformation);
    [ExtensionAttribute]
[CanBeNullAttribute]
private static StateMachineHoistedLocalScopesData Clone(StateMachineHoistedLocalScopesData stateMachineHoistedLocalScopes);
    [ExtensionAttribute]
[CanBeNullAttribute]
private static AsyncMethodSteppingInformationData Clone(AsyncMethodSteppingInformationData asyncMethodSteppingInformation);
}
public static class JetBrains.Metadata.Debug.DebugDataLogger : object {
    [StringFormatMethodAttribute("format")]
public static void LogError(string format, Object[] args);
    public static void LogError(string message);
}
public enum JetBrains.Metadata.Debug.DebugDataOrigin : Enum {
    public int value__;
    public static DebugDataOrigin Internal;
    public static DebugDataOrigin External;
    public static DebugDataOrigin Decompiled;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Debug.DebugDataSerializer : object {
    private static int GuidLength;
    [ExtensionAttribute]
public static void WriteDebugData(DebugData debugData, FileSystemPath serializedDebugDataLocation);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static DebugData ReadDebugData(FileSystemPath serializedDebugDataLocation);
    [NotNullAttribute]
public static Byte[] Serialize(DebugData debugData);
    [NotNullAttribute]
public static DebugData Deserialize(Byte[] bytes);
    public static void WriteDebugData(BinaryWriter writer, DebugData debugData);
    [NotNullAttribute]
public static DebugData ReadDebugData(BinaryReader reader);
    private static void WriteImportScopes(BinaryWriter writer, DebugData debugData);
    private static Dictionary`2<int, ImportScope> ReadImportScopes(BinaryReader reader, ImportScope& moduleImportScope, ICollection`1& orderedImportScopes);
    private static void WriteMethods(BinaryWriter writer, DebugData debugData);
    private static void WriteMethod(BinaryWriter writer, DebugMethod debugMethod);
    private static void ReadMethods(BinaryReader reader, DebugData debugData, Dictionary`2<int, ImportScope> indexToImportScope);
    private static void ReadMethod(BinaryReader reader, DebugData debugData, Dictionary`2<int, ImportScope> indexToImportScope);
    private static LocalScopeProperties ReadLocalScopeProperties(BinaryReader reader);
    private static void WriteDocument(BinaryWriter writer, DebugDocument document);
    [NotNullAttribute]
private static DebugDocument ReadDocument(BinaryReader reader);
    private static void WriteSequencePoint(BinaryWriter writer, SequencePoint& sequencePoint);
    private static SequencePoint ReadSequencePoint(BinaryReader reader);
    private static void WriteImport(BinaryWriter writer, Import import);
    [NotNullAttribute]
private static Import ReadImport(BinaryReader reader);
    private static void WriteLocalVariable(BinaryWriter writer, DebugLocalVariable variable);
    [NotNullAttribute]
private static DebugLocalVariable ReadLocalVariable(BinaryReader reader);
    private static void WriteTupleElementNamesData(BinaryWriter writer, TupleElementNamesData tupleElementNames);
    [NotNullAttribute]
private static TupleElementNamesData ReadTupleElementNamesData(BinaryReader reader);
    private static void WriteAsyncMethodSteppingInformationData(BinaryWriter writer, AsyncMethodSteppingInformationData asyncMethodSteppingInformation);
    [NotNullAttribute]
private static AsyncMethodSteppingInformationData ReadAsyncMethodSteppingInformationData(BinaryReader reader);
    private static void WriteStateMachineHoistedLocalScopesData(BinaryWriter writer, StateMachineHoistedLocalScopesData stateMachineHoistedLocalScopes);
    [NotNullAttribute]
private static StateMachineHoistedLocalScopesData ReadStateMachineHoistedLocalScopesData(BinaryReader reader);
    private static void WriteStateMachineHoistedLocalScope(BinaryWriter writer, StateMachineHoistedLocalScope stateMachineHoistedLocalScope);
    private static StateMachineHoistedLocalScope ReadStateMachineHoistedLocalScope(BinaryReader reader);
    private static void WriteMethodCustomDebugInformation(BinaryWriter writer, MethodCustomDebugInformation methodCustomDebugInformation);
    [NotNullAttribute]
private static MethodCustomDebugInformation ReadMethodCustomDebugInformation(BinaryReader reader);
    private static void WriteTypeMemberRanges(BinaryWriter writer, DebugData debugData);
    private static void ReadTypeMemberRanges(BinaryReader reader, DebugData debugData);
    private static void WriteMemberRange(BinaryWriter writer, TypeMemberRange memberRange);
    private static TypeMemberRange ReadMemberRange(BinaryReader reader);
    private static void WriteMetadataToken(BinaryWriter writer, MetadataToken token);
    private static MetadataToken ReadMetadataToken(BinaryReader reader);
    private static void WriteNMetadataToken(BinaryWriter writer, Nullable`1<MetadataToken> token);
    [CanBeNullAttribute]
private static Nullable`1<MetadataToken> ReadNMetadataToken(BinaryReader reader);
    private static void WriteGuid(BinaryWriter writer, Guid guid);
    private static Guid ReadGuid(BinaryReader reader);
    private static void WriteFileSystemPath(BinaryWriter writer, FileSystemPath path);
    [NotNullAttribute]
private static FileSystemPath ReadFileSystemPath(BinaryReader reader);
    private static void WriteNString(BinaryWriter writer, string s);
    [CanBeNullAttribute]
private static string ReadNString(BinaryReader reader);
    private static void WriteN(BinaryWriter writer, Action`2<BinaryWriter, T> writeT, T data);
    [CanBeNullAttribute]
private static T ReadN(BinaryReader reader, Func`2<BinaryReader, T> readT);
    private static void WriteArray(BinaryWriter writer, Action`2<BinaryWriter, T> writeElement, ICollection`1<T> array);
    private static void WriteArray(BinaryWriter writer, ActionIn2`2<BinaryWriter, T> writeElement, ICollection`1<T> array);
    [NotNullAttribute]
private static T[] ReadArray(BinaryReader reader, Func`2<BinaryReader, T> readElement);
    private static void WriteUint(BinaryWriter writer, int value);
    private static int ReadUint(BinaryReader reader);
    private static void WriteBool(BinaryWriter writer, bool isPrimaryConstructor);
    private static bool ReadBool(BinaryReader reader);
}
public class JetBrains.Metadata.Debug.DebugDocument : object {
    public static int InvalidDocumentIndex;
    public static int NullDocumentIndex;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private string <URL>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <DocumentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <LanguageVendor>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ChecksumAlgorithmId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Checksum>k__BackingField;
    public int Index { get; }
    public string URL { get; private set; }
    public Guid DocumentType { get; private set; }
    public Guid Language { get; private set; }
    public Guid LanguageVendor { get; private set; }
    public Guid ChecksumAlgorithmId { get; private set; }
    [CanBeNullAttribute]
public Byte[] Checksum { get; private set; }
    public DebugDocument(int index, string url, Guid documentType, Guid language, Guid languageVendor, Guid checksumAlgorithmId, Byte[] checksum);
    public DebugDocument(int index, string url);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public string get_URL();
    [CompilerGeneratedAttribute]
private void set_URL(string value);
    [CompilerGeneratedAttribute]
public Guid get_DocumentType();
    [CompilerGeneratedAttribute]
private void set_DocumentType(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_Language();
    [CompilerGeneratedAttribute]
private void set_Language(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_LanguageVendor();
    [CompilerGeneratedAttribute]
private void set_LanguageVendor(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_ChecksumAlgorithmId();
    [CompilerGeneratedAttribute]
private void set_ChecksumAlgorithmId(Guid value);
    [CompilerGeneratedAttribute]
public Byte[] get_Checksum();
    [CompilerGeneratedAttribute]
private void set_Checksum(Byte[] value);
    internal void Update(DebugDocument newDocument);
    public virtual string ToString();
}
public static class JetBrains.Metadata.Debug.DebugDumpUtils : object {
    private static Dictionary`2<Guid, string> ourGuidPresentation;
    private static DebugDumpUtils();
    public static string PresentIlOffsetRange(int startOffset, int endOffset);
    [CanBeNullAttribute]
public static string TryPresentGuid(Guid guid);
    public static string PresentGuid(Guid guid);
}
public class JetBrains.Metadata.Debug.DebugLocalVariable : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <LocalVariablesSignatureToken>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalVariableAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private TupleElementNamesData <TupleElementNames>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IlIndex>k__BackingField;
    public string Name { get; }
    public MetadataToken LocalVariablesSignatureToken { get; }
    public LocalVariableAttributes Attributes { get; }
    [CanBeNullAttribute]
public TupleElementNamesData TupleElementNames { get; }
    public int IlIndex { get; }
    public DebugLocalVariable(int ilIndex, string name, LocalVariableAttributes attributes, MetadataToken localVariablesSignatureToken, TupleElementNamesData tupleElementNames);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public MetadataToken get_LocalVariablesSignatureToken();
    [CompilerGeneratedAttribute]
public LocalVariableAttributes get_Attributes();
    [CompilerGeneratedAttribute]
public TupleElementNamesData get_TupleElementNames();
    [CompilerGeneratedAttribute]
public int get_IlIndex();
    public virtual string ToString();
}
public class JetBrains.Metadata.Debug.DebugMethod : object {
    [CompilerGeneratedAttribute]
private RVA <RVA>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <LocalVariablesSignatureToken>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalScope <RootScope>k__BackingField;
    [CanBeNullAttribute]
private DebugData myDebugData;
    [CompilerGeneratedAttribute]
private MethodCustomDebugInformation <MethodCustomDebugInformation>k__BackingField;
    private SequencePointComparer mySequencePointComparer;
    private List`1<SequencePoint> mySequencePoints;
    private Dictionary`2<int, List`1<SequencePoint>> myDocumentIndexToSequencePoints;
    private HashSet`1<int> myIlOffsets;
    public RVA RVA { get; }
    public MetadataToken Token { get; }
    public MetadataToken LocalVariablesSignatureToken { get; }
    [NotNullAttribute]
public LocalScope RootScope { get; }
    [CanBeNullAttribute]
internal DebugData DebugData { get; internal set; }
    public bool IsEmpty { get; }
    [NotNullAttribute]
public ICollection`1<SequencePoint> SequencePoints { get; }
    public bool IsPrimaryConstructor { get; public set; }
    [CanBeNullAttribute]
public StateMachineHoistedLocalScopesData StateMachineHoistedLocalScopes { get; public set; }
    [CanBeNullAttribute]
public AsyncMethodSteppingInformationData AsyncMethodSteppingInformation { get; public set; }
    [CanBeNullAttribute]
public Nullable`1<MetadataToken> KickoffMethod { get; public set; }
    [CanBeNullAttribute]
public string StateMachineTypeName { get; public set; }
    [CanBeNullAttribute]
internal MethodCustomDebugInformation MethodCustomDebugInformation { get; internal set; }
    [NotNullAttribute]
public ICollection`1<int> SequencePointsDocumentIndices { get; }
    public DebugMethod(RVA rva, MetadataToken token, MetadataToken localVariablesSignatureToken, int codeLength, ImportScope importScope, IReadOnlyList`1<SequencePoint> sequencePoints, MethodCustomDebugInformation methodCustomDebugInformation);
    [CompilerGeneratedAttribute]
public RVA get_RVA();
    [CompilerGeneratedAttribute]
public MetadataToken get_Token();
    [CompilerGeneratedAttribute]
public MetadataToken get_LocalVariablesSignatureToken();
    [CompilerGeneratedAttribute]
public LocalScope get_RootScope();
    internal void SetImportScope(ImportScope importScope);
    private static void SetImportScope(LocalScope localScope, ImportScope importScope);
    internal DebugData get_DebugData();
    internal void set_DebugData(DebugData value);
    internal DebugMethod Detach();
    private void ProcessImportScopes(LocalScope localScope);
    public bool get_IsEmpty();
    public ICollection`1<SequencePoint> get_SequencePoints();
    public bool get_IsPrimaryConstructor();
    public void set_IsPrimaryConstructor(bool value);
    public StateMachineHoistedLocalScopesData get_StateMachineHoistedLocalScopes();
    public void set_StateMachineHoistedLocalScopes(StateMachineHoistedLocalScopesData value);
    public AsyncMethodSteppingInformationData get_AsyncMethodSteppingInformation();
    public void set_AsyncMethodSteppingInformation(AsyncMethodSteppingInformationData value);
    public Nullable`1<MetadataToken> get_KickoffMethod();
    public void set_KickoffMethod(Nullable`1<MetadataToken> value);
    public string get_StateMachineTypeName();
    public void set_StateMachineTypeName(string value);
    [CompilerGeneratedAttribute]
internal MethodCustomDebugInformation get_MethodCustomDebugInformation();
    [CompilerGeneratedAttribute]
internal void set_MethodCustomDebugInformation(MethodCustomDebugInformation value);
    [NotNullAttribute]
public IEnumerable`1<SequencePoint> GetSequencePointsForDocument(int documentIndex);
    public ICollection`1<int> get_SequencePointsDocumentIndices();
    public bool HasSequencePointsForSource(int documentIndex);
    public void AddSequencePoint(SequencePoint& sequencePoint);
    private Nullable`1<SequencePoint> GetSequencePointByIlOffset(int ilOffset);
    public virtual string ToString();
}
public static class JetBrains.Metadata.Debug.DocumentTypes : object {
    public static Guid Text;
    public static Guid MC;
    private static DocumentTypes();
}
public class JetBrains.Metadata.Debug.ExtendedDebugData : object {
    public static IEqualityComparer`1<ExtendedDebugData> EqualityComparer;
    [CompilerGeneratedAttribute]
private DebugData <DebugData>k__BackingField;
    [CompilerGeneratedAttribute]
private DebugDataOrigin <Origin>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyId <AssemblyId>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemPath <AssemblyPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyFullName>k__BackingField;
    [NotNullAttribute]
public DebugData DebugData { get; }
    public DebugDataOrigin Origin { get; }
    public AssemblyId AssemblyId { get; }
    [NotNullAttribute]
public FileSystemPath AssemblyPath { get; }
    [CanBeNullAttribute]
public string AssemblyFullName { get; }
    private ExtendedDebugData(DebugData debugData, AssemblyId assemblyId, FileSystemPath assemblyPath, string assemblyFullName, DebugDataOrigin origin);
    private static ExtendedDebugData();
    [CompilerGeneratedAttribute]
public DebugData get_DebugData();
    [CompilerGeneratedAttribute]
public DebugDataOrigin get_Origin();
    [CompilerGeneratedAttribute]
public AssemblyId get_AssemblyId();
    [CompilerGeneratedAttribute]
public FileSystemPath get_AssemblyPath();
    [CompilerGeneratedAttribute]
public string get_AssemblyFullName();
    public static ExtendedDebugData Create(DebugData debugData, AssemblyId assemblyId, FileSystemPath assemblyPath, string assemblyFullName, DebugDataOrigin origin);
    public static ExtendedDebugData Create(DebugData debugData, string assemblyId, FileSystemPath assemblyPath, string assemblyFullName, DebugDataOrigin origin);
    public static ExtendedDebugData Create(DebugData debugData, AssemblyId assemblyId, string assemblyPath, string assemblyFullName, DebugDataOrigin origin);
    public static ExtendedDebugData Create(DebugData debugData, string assemblyId, string assemblyPath, string assemblyFullName, DebugDataOrigin origin);
}
public static class JetBrains.Metadata.Debug.HashAlgorithms : object {
    public static Guid Sha1;
    public static Guid Sha256;
    public static Guid Md5;
    public static int Md5HashLength;
    public static int Sha1HashLength;
    public static int Sha256HashLength;
    public static int Sha384HashLength;
    public static int Sha512HashLength;
    private static HashAlgorithms();
    public static string GuidToString(Guid algorithmId);
}
public interface JetBrains.Metadata.Debug.IDebugDataCollector {
    public abstract virtual void AddMethod(IMethodBody methodBody);
    public abstract virtual void AddLocalVariable(IMethodBodyLocalVariable localVariable, string name, LocalVariableAttributes attributes, TupleElementNamesData tupleElementNames);
    public abstract virtual void AddLocalVariable(IMethodBodyLocalVariable localVariable, string name, LocalVariableAttributes attributes, int scopeStartOffset, int scopeEndOffset, TupleElementNamesData tupleElementNames);
    public abstract virtual void AddStateMachineHoistedLocalScopes(MetadataToken method, StateMachineHoistedLocalScopesData stateMachineHoistedLocalScopes);
    public abstract virtual void AddAsyncMethodSteppingInformation(MetadataToken method, AsyncMethodSteppingInformationData asyncMethodSteppingInformation);
    public abstract virtual void AddKickoffMethod(MetadataToken moveNextMethod, MetadataToken kickoffMethod);
    public abstract virtual void AddStateMachineTypeName(string stateMachineTypeName, MetadataToken kickoffMethod);
}
public interface JetBrains.Metadata.Debug.IMetadataLocalVariablesNameProvider {
    [CanBeNullAttribute]
public string NamesSource { get; }
    [CanBeNullAttribute]
public abstract virtual string GetVariableName(IMetadataMethod methodBody, int index);
    [CanBeNullAttribute]
public abstract virtual string GetVariableName(IMetadataMethod methodBody, int index, int ilOffset);
    [CanBeNullAttribute]
public abstract virtual String[] GetVariableTupleElementNames(IMetadataMethod methodBody, int index);
    [CanBeNullAttribute]
public abstract virtual String[] GetVariableTupleElementNames(IMetadataMethod methodBody, int index, int ilOffset);
    public abstract virtual string get_NamesSource();
}
public class JetBrains.Metadata.Debug.Import : object {
    [CompilerGeneratedAttribute]
private ImportDefinitionKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <TargetAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <TargetType>k__BackingField;
    public ImportDefinitionKind Kind { get; }
    [CanBeNullAttribute]
public string Alias { get; }
    public MetadataToken TargetAssembly { get; }
    [CanBeNullAttribute]
public string TargetNamespace { get; }
    public MetadataToken TargetType { get; }
    public Import(ImportDefinitionKind kind, string alias, MetadataToken targetAssembly, string targetNamespace, MetadataToken targetType);
    [CompilerGeneratedAttribute]
public ImportDefinitionKind get_Kind();
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
public MetadataToken get_TargetAssembly();
    [CompilerGeneratedAttribute]
public string get_TargetNamespace();
    [CompilerGeneratedAttribute]
public MetadataToken get_TargetType();
    public static Import CreateImportNamespace(string namespace);
    public virtual string ToString();
}
public class JetBrains.Metadata.Debug.ImportScope : object {
    [CanBeNullAttribute]
private ImportScope myParent;
    [CompilerGeneratedAttribute]
private IList`1<Import> <Imports>k__BackingField;
    [CanBeNullAttribute]
public ImportScope Parent { get; internal set; }
    [NotNullAttribute]
public IList`1<Import> Imports { get; }
    public ImportScope(ImportScope parent, IList`1<Import> imports);
    public ImportScope get_Parent();
    internal void set_Parent(ImportScope value);
    [CompilerGeneratedAttribute]
public IList`1<Import> get_Imports();
}
public static class JetBrains.Metadata.Debug.Languages : object {
    public static Guid CSharp;
    public static Guid IL;
    public static Guid VB;
    public static Guid FSharp;
    private static Languages();
    public static bool IsKnownLanguage(Guid language);
}
public static class JetBrains.Metadata.Debug.LanguageVendors : object {
    public static Guid Microsoft;
    private static LanguageVendors();
}
public class JetBrains.Metadata.Debug.LocalScope : object {
    [CompilerGeneratedAttribute]
private DebugMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalScope <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndOffset>k__BackingField;
    private ImportScope myImportScope;
    private LinkedList`1<LocalScope> mySortedChildScopes;
    private Dictionary`2<int, DebugLocalVariable> myLocalVariables;
    private HashSet`1<int> myLocalVariablesForbiddenIndices;
    [NotNullAttribute]
public DebugMethod Method { get; }
    [CanBeNullAttribute]
public LocalScope Parent { get; private set; }
    public int StartOffset { get; }
    public int EndOffset { get; }
    public IEnumerable`1<LocalScope> SortedChildScopes { get; }
    [NotNullAttribute]
public ICollection`1<DebugLocalVariable> LocalVariables { get; }
    [CanBeNullAttribute]
public ImportScope ImportScope { get; internal set; }
    public bool IsRoot { get; }
    protected LocalScope(DebugMethod method, LocalScope parent, ImportScope importScope, int startOffset, int endOffset, IEnumerable`1<LocalScope> sortedChildren);
    [CompilerGeneratedAttribute]
public DebugMethod get_Method();
    [CompilerGeneratedAttribute]
public LocalScope get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(LocalScope value);
    [CompilerGeneratedAttribute]
public int get_StartOffset();
    [CompilerGeneratedAttribute]
public int get_EndOffset();
    public IEnumerable`1<LocalScope> get_SortedChildScopes();
    public ICollection`1<DebugLocalVariable> get_LocalVariables();
    [CanBeNullAttribute]
internal DebugLocalVariable TryGetLocalVariable(int variableIndex);
    [CanBeNullAttribute]
private DebugLocalVariable TryGetLocalVariableFromParentScopes(int variableIndex);
    public ImportScope get_ImportScope();
    internal void set_ImportScope(ImportScope value);
    public bool get_IsRoot();
    public bool TryAddLocalVariable(DebugLocalVariable localVariable);
    public void GetOrCreateInnerScopes(int startOffset, int endOffset, ICollection`1<LocalScope> scopes, ImportScope importScope);
    [NotNullAttribute]
public static LocalScope CreateRootScope(DebugMethod method, int startOffset, int endOffset, ImportScope importScope);
    private bool LocalVariableIndexIsForbidden(int index);
    private void PropagateForbiddenIndicesToParent();
    private void SetNewForbiddenIndexAndPropagateItToParent(int index);
    public virtual string ToString();
}
public class JetBrains.Metadata.Debug.LocalVariableInLocalScope : object {
    [CompilerGeneratedAttribute]
private DebugLocalVariable <LocalVariable>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalScope <Scope>k__BackingField;
    [NotNullAttribute]
public DebugLocalVariable LocalVariable { get; }
    [NotNullAttribute]
public LocalScope Scope { get; }
    public LocalVariableInLocalScope(DebugLocalVariable localVariable, LocalScope scope);
    [CompilerGeneratedAttribute]
public DebugLocalVariable get_LocalVariable();
    [CompilerGeneratedAttribute]
public LocalScope get_Scope();
}
public class JetBrains.Metadata.Debug.MethodCustomDebugInformation : object {
    [CompilerGeneratedAttribute]
private bool <IsPrimaryConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private StateMachineHoistedLocalScopesData <StateMachineHoistedLocalScopes>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncMethodSteppingInformationData <AsyncMethodSteppingInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private PdbTupleInfo[] <TupleElementNames>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<MetadataToken> <KickoffMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StateMachineTypeName>k__BackingField;
    public bool IsPrimaryConstructor { get; public set; }
    [CanBeNullAttribute]
public StateMachineHoistedLocalScopesData StateMachineHoistedLocalScopes { get; public set; }
    [CanBeNullAttribute]
public AsyncMethodSteppingInformationData AsyncMethodSteppingInformation { get; public set; }
    [CanBeNullAttribute]
public PdbTupleInfo[] TupleElementNames { get; public set; }
    [CanBeNullAttribute]
public Nullable`1<MetadataToken> KickoffMethod { get; public set; }
    [CanBeNullAttribute]
public string StateMachineTypeName { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsPrimaryConstructor();
    [CompilerGeneratedAttribute]
public void set_IsPrimaryConstructor(bool value);
    [CompilerGeneratedAttribute]
public StateMachineHoistedLocalScopesData get_StateMachineHoistedLocalScopes();
    [CompilerGeneratedAttribute]
public void set_StateMachineHoistedLocalScopes(StateMachineHoistedLocalScopesData value);
    [CompilerGeneratedAttribute]
public AsyncMethodSteppingInformationData get_AsyncMethodSteppingInformation();
    [CompilerGeneratedAttribute]
public void set_AsyncMethodSteppingInformation(AsyncMethodSteppingInformationData value);
    [CompilerGeneratedAttribute]
public PdbTupleInfo[] get_TupleElementNames();
    [CompilerGeneratedAttribute]
public void set_TupleElementNames(PdbTupleInfo[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<MetadataToken> get_KickoffMethod();
    [CompilerGeneratedAttribute]
public void set_KickoffMethod(Nullable`1<MetadataToken> value);
    [CompilerGeneratedAttribute]
public string get_StateMachineTypeName();
    [CompilerGeneratedAttribute]
public void set_StateMachineTypeName(string value);
}
public class JetBrains.Metadata.Debug.Pdb.Common.PackedBitSet : object {
    private static int MaxDataItems;
    private ChunkArray`1<UInt32> myData;
    private int mySize;
    public PackedBitSet(IBinaryReader reader);
    public PackedBitSet(int num);
    private PackedBitSet(IEnumerable`1<int> indices, int maxIndex);
    public PackedBitSet(IList`1<int> sortedIndices);
    public void Write(BinaryWriter writer);
    private void SetBitAt(int index);
    public bool IsSet(int index);
    private static UInt32 GetBitMask(int index);
    public bool IsEmpty();
}
public class JetBrains.Metadata.Debug.Pdb.Common.PdbException : Exception {
    public PdbException(string message);
}
public class JetBrains.Metadata.Debug.Pdb.Common.PdbStream : ValueType {
    private UInt32[] myBlocks;
    private UInt32 mySize;
    public UInt32 Size { get; }
    public UInt32[] Blocks { get; }
    public PdbStream(UInt32 size, UInt32[] blocks);
    public UInt32 get_Size();
    public UInt32[] get_Blocks();
}
public class JetBrains.Metadata.Debug.Pdb.Common.PdbStreamInfo : ValueType {
    private UInt32 mySize;
    public UInt32 Size { get; }
    public PdbStreamInfo(BinaryReader reader);
    public UInt32 get_Size();
}
internal class JetBrains.Metadata.Debug.Pdb.Common.PdbSubStream : Stream {
    private UInt32[] myBlocks;
    private UInt32 myBlockSize;
    private long mySize;
    private Stream myUnderlayStream;
    private long myPosition;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public PdbSubStream(Stream underlayStream, UInt32[] blocks, UInt32 blockSize, long size);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal enum JetBrains.Metadata.Debug.Pdb.CustomDebugInfoKind : Enum {
    public byte value__;
    public static CustomDebugInfoKind UsingGroups;
    public static CustomDebugInfoKind ForwardMethodInfo;
    public static CustomDebugInfoKind ForwardModuleInfo;
    public static CustomDebugInfoKind StateMachineHoistedLocalScopes;
    public static CustomDebugInfoKind StateMachineTypeName;
    public static CustomDebugInfoKind DynamicLocals;
    public static CustomDebugInfoKind EditAndContinueLocalSlotMap;
    public static CustomDebugInfoKind EditAndContinueLambdaMap;
    public static CustomDebugInfoKind TupleElementNames;
    public static CustomDebugInfoKind EditAndContinueStateMachineStateMap;
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.AttrSlotSym : ValueType {
    public UInt32 SlotIndex;
    public UInt32 Typind;
    public UInt32 OffCod;
    public ushort SegCod;
    public ushort Flags;
    public string Name;
    public static AttrSlotSym ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.BlockSym32 : ValueType {
    public UInt32 Parent;
    public UInt32 End;
    public UInt32 Len;
    public UInt32 Off;
    public ushort Seg;
    public string Name;
    public static BlockSym32 ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.CV_Column : ValueType {
    public ushort OffColumnStart;
    public ushort OffColumnEnd;
    public static CV_Column ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.CV_FileCheckSum : ValueType {
    public int Name;
    public byte Len;
    public HashType Type;
    public static CV_FileCheckSum ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.CV_Line : ValueType {
    public UInt32 Offset;
    public UInt32 Flags;
    public UInt32 LineBegin { get; }
    public UInt32 Delta { get; }
    public UInt32 LineEnd { get; }
    public bool Statement { get; }
    public UInt32 get_LineBegin();
    public UInt32 get_Delta();
    public UInt32 get_LineEnd();
    public bool get_Statement();
    public static CV_Line ReadFromStream(IBinaryReader moduleStream);
}
[FlagsAttribute]
internal enum JetBrains.Metadata.Debug.Pdb.CvStruct.CV_Line_Flags : Enum {
    public UInt32 value__;
    public static CV_Line_Flags LinenumStart;
    public static CV_Line_Flags DeltaLineEnd;
    public static CV_Line_Flags FStatement;
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.CV_LineSection : ValueType {
    public UInt32 Off;
    public ushort Sec;
    public ushort Flags;
    public UInt32 Cod;
    public static CV_LineSection ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.CV_SourceFile : ValueType {
    public UInt32 Index;
    public UInt32 Count;
    public UInt32 Linsiz;
    public static CV_SourceFile ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.DatasSym32 : ValueType {
    internal UInt32 Typind;
    internal UInt32 Off;
    internal ushort Seg;
    internal string Name;
    public static DatasSym32 ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.FrameProcSym : ValueType {
    public UInt32 CbFrame;
    public UInt32 CbPad;
    public UInt32 OffPad;
    public UInt32 CbSaveRegs;
    public UInt32 OffExHdlr;
    public ushort SecExHdlr;
    public UInt32 Flags;
    public static FrameProcSym ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.LabelSym32 : ValueType {
    internal UInt32 Off;
    internal ushort Seg;
    internal byte Flags;
    internal string Name;
    public static LabelSym32 ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.ManProcSym : ValueType {
    public UInt32 Parent;
    public UInt32 End;
    public UInt32 Next;
    public UInt32 Len;
    public UInt32 DbgStart;
    public UInt32 DbgEnd;
    public MetadataToken Token;
    public UInt32 Off;
    public ushort Seg;
    public byte Flags;
    public ushort RetReg;
    public string Name;
    public static ManProcSym ReadFromStream(IBinaryReader moduleStream);
}
public class JetBrains.Metadata.Debug.Pdb.CvStruct.PdbConstant : ValueType {
    public string Name;
    public MetadataToken Token;
    public object Value;
    public static PdbConstant ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.ProcSym32 : ValueType {
    internal UInt32 Parent;
    internal UInt32 End;
    internal UInt32 Next;
    internal UInt32 Len;
    internal UInt32 DbgStart;
    internal UInt32 DbgEnd;
    internal UInt32 Typind;
    internal UInt32 Off;
    internal ushort Seg;
    internal byte Flags;
    internal string Name;
    public static ProcSym32 ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.ThunkSym32 : ValueType {
    public UInt32 Parent;
    public UInt32 End;
    public UInt32 Next;
    public UInt32 Off;
    public ushort Seg;
    public ushort Len;
    public byte Ord;
    public string Name;
    public static ThunkSym32 ReadFromStream(IBinaryReader moduleStream);
}
public class JetBrains.Metadata.Debug.Pdb.Dbi.DbiDbgHeader : object {
    public static int HeaderSize;
    [CompilerGeneratedAttribute]
private ushort <Fpo>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Fixup>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <OmapToSrc>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <OmapFromSrc>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <SectionHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <TokenRidMap>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Xdata>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Pdata>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NewFpo>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <SectionHeaderOrigin>k__BackingField;
    public ushort Fpo { get; }
    public ushort Exception { get; }
    public ushort Fixup { get; }
    public ushort OmapToSrc { get; }
    public ushort OmapFromSrc { get; }
    public ushort SectionHeader { get; }
    public ushort TokenRidMap { get; }
    public ushort Xdata { get; }
    public ushort Pdata { get; }
    public ushort NewFpo { get; }
    public ushort SectionHeaderOrigin { get; }
    public DbiDbgHeader(IBinaryReader reader);
    public DbiDbgHeader(ushort fpo, ushort exception, ushort fixup, ushort omapToSrc, ushort omapFromSrc, ushort sectionHeader, ushort tokenRidMap, ushort xData, ushort pData, ushort newFpo, ushort sectionHeaderOrigin);
    internal void Write(BinaryWriter writer);
    [CompilerGeneratedAttribute]
public ushort get_Fpo();
    [CompilerGeneratedAttribute]
public ushort get_Exception();
    [CompilerGeneratedAttribute]
public ushort get_Fixup();
    [CompilerGeneratedAttribute]
public ushort get_OmapToSrc();
    [CompilerGeneratedAttribute]
public ushort get_OmapFromSrc();
    [CompilerGeneratedAttribute]
public ushort get_SectionHeader();
    [CompilerGeneratedAttribute]
public ushort get_TokenRidMap();
    [CompilerGeneratedAttribute]
public ushort get_Xdata();
    [CompilerGeneratedAttribute]
public ushort get_Pdata();
    [CompilerGeneratedAttribute]
public ushort get_NewFpo();
    [CompilerGeneratedAttribute]
public ushort get_SectionHeaderOrigin();
}
public class JetBrains.Metadata.Debug.Pdb.Dbi.DbiFileInfo : object {
    private OneToListMap`2<DbiModuleInfo, string> myFileNames;
    private JetReadOnlyList`1<DbiModuleInfo> myModules;
    private bool myFileInfoSizeUndefined;
    private int myFileInfoSize;
    private Dictionary`2<string, int> myFileNameToOffset;
    private List`1<string> myNameTable;
    public OneToListMap`2<DbiModuleInfo, string> FileNames { get; }
    public DbiFileInfo(IBinaryReader reader, JetReadOnlyList`1<DbiModuleInfo> modules);
    public DbiFileInfo(JetReadOnlyList`1<DbiModuleInfo> modules, OneToListMap`2<DbiModuleInfo, string> fileNames);
    private void CreateNameTableAndCalculateSize();
    internal void Write(BinaryWriter writer);
    internal int GetFileInfoSize();
    public OneToListMap`2<DbiModuleInfo, string> get_FileNames();
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_0(DbiModuleInfo module);
}
public class JetBrains.Metadata.Debug.Pdb.Dbi.DbiHeader : object {
    public static int HeaderSize;
    private static int DefaultDbiSignature;
    private static int DefaultHeaderVersion;
    private static int DefaultPdbAge;
    private static int DefaultMachine;
    [CompilerGeneratedAttribute]
private int <DbiSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HeaderVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PdbAge>k__BackingField;
    [CompilerGeneratedAttribute]
private short <GlobalSymbolInfoStreamIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private short <PublicSymbolInfoStreamIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private short <SymbolRecordStreamIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <VersionMajorMinor>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <BuildMajor>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <BuildMinor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GpModuleInformationsSectionSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SectionContributionSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SectionMapSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileInfoSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TsMapSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MfcIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DbiDbgHeaderSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EcInfoSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Machine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Reserved>k__BackingField;
    public int DbiSignature { get; }
    public int HeaderVersion { get; }
    public int PdbAge { get; }
    public short GlobalSymbolInfoStreamIndex { get; }
    public short PublicSymbolInfoStreamIndex { get; }
    public short SymbolRecordStreamIndex { get; }
    public ushort VersionMajorMinor { get; }
    public ushort BuildMajor { get; }
    public ushort BuildMinor { get; }
    public int GpModuleInformationsSectionSize { get; }
    public int SectionContributionSize { get; }
    public int SectionMapSize { get; }
    public int FileInfoSize { get; }
    public int TsMapSize { get; }
    public int MfcIndex { get; }
    public int DbiDbgHeaderSize { get; }
    public int EcInfoSize { get; }
    public ushort Flags { get; }
    public ushort Machine { get; }
    public int Reserved { get; }
    public DbiHeader(IBinaryReader reader);
    public DbiHeader(ushort versionMajorMinor, ushort versionBuildNumber, short globalSymbolInfoStreamIndex, short publicSymbolInfoStreamIndex, short symbolRecordStreamIndex, int gpModuleInformationsSectionSize, int sectionContributionSize, int sectionMapSize, int fileInfoSize, int ecInfoSize);
    internal static DbiHeader GetEmptyDbiHeader();
    internal void Write(BinaryWriter writer);
    [CompilerGeneratedAttribute]
public int get_DbiSignature();
    [CompilerGeneratedAttribute]
public int get_HeaderVersion();
    [CompilerGeneratedAttribute]
public int get_PdbAge();
    [CompilerGeneratedAttribute]
public short get_GlobalSymbolInfoStreamIndex();
    [CompilerGeneratedAttribute]
public short get_PublicSymbolInfoStreamIndex();
    [CompilerGeneratedAttribute]
public short get_SymbolRecordStreamIndex();
    [CompilerGeneratedAttribute]
public ushort get_VersionMajorMinor();
    [CompilerGeneratedAttribute]
public ushort get_BuildMajor();
    [CompilerGeneratedAttribute]
public ushort get_BuildMinor();
    [CompilerGeneratedAttribute]
public int get_GpModuleInformationsSectionSize();
    [CompilerGeneratedAttribute]
public int get_SectionContributionSize();
    [CompilerGeneratedAttribute]
public int get_SectionMapSize();
    [CompilerGeneratedAttribute]
public int get_FileInfoSize();
    [CompilerGeneratedAttribute]
public int get_TsMapSize();
    [CompilerGeneratedAttribute]
public int get_MfcIndex();
    [CompilerGeneratedAttribute]
public int get_DbiDbgHeaderSize();
    [CompilerGeneratedAttribute]
public int get_EcInfoSize();
    [CompilerGeneratedAttribute]
public ushort get_Flags();
    [CompilerGeneratedAttribute]
public ushort get_Machine();
    [CompilerGeneratedAttribute]
public int get_Reserved();
}
[DebuggerDisplayAttribute("{ModuleName} {ObjectName}")]
public class JetBrains.Metadata.Debug.Pdb.Dbi.DbiModuleInfo : object {
    private static int mySizeWithoutStringsAndAlign;
    private int mySizeWithoutAlign;
    [CompilerGeneratedAttribute]
private int <Opened>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private short <StreamIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CbSyms>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CbOldLines>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CbLines>k__BackingField;
    [CompilerGeneratedAttribute]
private short <FilesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Offsets>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NiSource>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NiCompiler>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ObjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private DbiSectionContribution <SectionContribution>k__BackingField;
    public int Opened { get; }
    public ushort Flags { get; }
    public short StreamIndex { get; }
    public int CbSyms { get; }
    public int CbOldLines { get; }
    public int CbLines { get; }
    public short FilesCount { get; }
    public UInt32 Offsets { get; }
    public int NiSource { get; }
    public int NiCompiler { get; }
    public string ModuleName { get; private set; }
    public string ObjectName { get; private set; }
    public DbiSectionContribution SectionContribution { get; }
    public DbiModuleInfo(IBinaryReader reader);
    private DbiModuleInfo(DbiSectionContribution sectionContribution, ushort flags, short streamIndex, int cbSyms, int cbOldLines, int cbLines, short filesCount, UInt32 offsets, int niSource, int niCompiler, string moduleName, string objectName);
    private static DbiModuleInfo();
    internal void Write(BinaryWriter writer);
    private int GetModuleInfoSizeWithoutAlign();
    internal int GetModuleInfoSize();
    [CompilerGeneratedAttribute]
public int get_Opened();
    [CompilerGeneratedAttribute]
public ushort get_Flags();
    [CompilerGeneratedAttribute]
public short get_StreamIndex();
    [CompilerGeneratedAttribute]
public int get_CbSyms();
    [CompilerGeneratedAttribute]
public int get_CbOldLines();
    [CompilerGeneratedAttribute]
public int get_CbLines();
    [CompilerGeneratedAttribute]
public short get_FilesCount();
    [CompilerGeneratedAttribute]
public UInt32 get_Offsets();
    [CompilerGeneratedAttribute]
public int get_NiSource();
    [CompilerGeneratedAttribute]
public int get_NiCompiler();
    [CompilerGeneratedAttribute]
public string get_ModuleName();
    [CompilerGeneratedAttribute]
private void set_ModuleName(string value);
    [CompilerGeneratedAttribute]
public string get_ObjectName();
    [CompilerGeneratedAttribute]
private void set_ObjectName(string value);
    [CompilerGeneratedAttribute]
public DbiSectionContribution get_SectionContribution();
}
public class JetBrains.Metadata.Debug.Pdb.Dbi.DbiSectionContribution : object {
    public static int SectionContributionSize;
    [CompilerGeneratedAttribute]
private short <Section>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private short <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <DataCrc>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <RelocCrc>k__BackingField;
    [CompilerGeneratedAttribute]
private static IComparer`1<DbiSectionContribution> <ModuleSectionOffsetComparer>k__BackingField;
    public short Section { get; }
    public int Offset { get; }
    public int Size { get; }
    public UInt32 Flags { get; }
    public short Module { get; }
    public UInt32 DataCrc { get; }
    public UInt32 RelocCrc { get; }
    public static IComparer`1<DbiSectionContribution> ModuleSectionOffsetComparer { get; }
    public DbiSectionContribution(IBinaryReader reader);
    public DbiSectionContribution(short section, int offset, int size, UInt32 flags, short module, UInt32 dataCrc, UInt32 relocCrc);
    private static DbiSectionContribution();
    internal void Write(BinaryWriter writer);
    [CompilerGeneratedAttribute]
public short get_Section();
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public UInt32 get_Flags();
    [CompilerGeneratedAttribute]
public short get_Module();
    [CompilerGeneratedAttribute]
public UInt32 get_DataCrc();
    [CompilerGeneratedAttribute]
public UInt32 get_RelocCrc();
    [CompilerGeneratedAttribute]
public static IComparer`1<DbiSectionContribution> get_ModuleSectionOffsetComparer();
}
public class JetBrains.Metadata.Debug.Pdb.Dbi.DbiStreamInfo : object {
    private static ILogger ourLog;
    private DbiDbgHeader myDbiDbgHeader;
    private DbiHeader myDbiHeader;
    private JetReadOnlyList`1<DbiModuleInfo> myModules;
    private DbiFileInfo myFileInfo;
    public DbiHeader DbiHeader { get; }
    public DbiDbgHeader DbiDbgHeader { get; }
    public JetReadOnlyList`1<DbiModuleInfo> Modules { get; }
    public DbiFileInfo FileInfo { get; }
    public DbiStreamInfo(IBinaryReader reader);
    private static DbiStreamInfo();
    internal static DbiStreamInfo GetEmptyDbiStreamInfo();
    public DbiHeader get_DbiHeader();
    public DbiDbgHeader get_DbiDbgHeader();
    public JetReadOnlyList`1<DbiModuleInfo> get_Modules();
    public ReadOnlyCollection`1<DbiSectionContribution> ReadAndSortSectionContribs(IBinaryReader reader);
    public DbiFileInfo get_FileInfo();
}
public class JetBrains.Metadata.Debug.Pdb.DebugAssemblyInfo : object {
    private FileSystemPath myAssemblyFile;
    private string myPdbSignature;
    private DebugInfo myDebugInfo;
    private string myChecksum;
    public string Checksum { get; }
    public FileSystemPath AssemblyFile { get; }
    public string PdbFile { get; }
    public string PdbSignature { get; }
    public DebugInfoType Type { get; }
    public DebugAssemblyInfo(FileSystemPath assemblyFile, string pdbSignature);
    public DebugAssemblyInfo(FileSystemPath assemblyFile, DebugInfo debugInfo, string checksum);
    public sealed virtual string get_Checksum();
    public sealed virtual FileSystemPath get_AssemblyFile();
    public sealed virtual string get_PdbFile();
    public sealed virtual string get_PdbSignature();
    public sealed virtual DebugInfoType get_Type();
    public sealed virtual bool HasSignature();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Debug.Pdb.DebugAssemblyInfoHelper : object {
    [ExtensionAttribute]
public static IList`1<IDebugAssemblyInfo> GetDebugAssemblyInfos(FileSystemPath assembly);
    [ExtensionAttribute]
public static IList`1<IDebugAssemblyInfo> GetDebugAssemblyInfos(IAssemblyLocation assemblyLocation);
    private static IList`1<IDebugAssemblyInfo> GetDebugAssemblyInfos(FileSystemPath assemblyPath, IAssemblyLocation assemblyLocation);
    [ExtensionAttribute]
public static IDebugAssemblyInfo GetLastAnyStandaloneDebugAssemblyInfo(FileSystemPath assembly);
    [ExtensionAttribute]
public static IDebugAssemblyInfo GetLastDebugAssemblyInfoExceptDeterministic(FileSystemPath assembly);
}
internal class JetBrains.Metadata.Debug.Pdb.DebugSubsection.DocumentInfoVisitor : PdbDebugSubsectionVisitorBase {
    private IPdbStreamBuilder myPdbStreamBuilder;
    private IDictionary`2<int, DebugDocument> myIndexToDocument;
    public DocumentInfoVisitor(IPdbStreamBuilder pdbStreamBuilder, IDictionary`2<int, DebugDocument> indexToDocument);
    public virtual void Visit_FILECHKSMS(IBinaryReader moduleStream, int start, int stop);
}
internal interface JetBrains.Metadata.Debug.Pdb.DebugSubsection.IPdbDebugSubsectionVisitor {
    public abstract virtual void Visit_FILECHKSMS(IBinaryReader moduleStream, int start, int stop);
    public abstract virtual void Visit_LINES(IBinaryReader moduleStream, int start, int stop);
}
internal class JetBrains.Metadata.Debug.Pdb.DebugSubsection.LinesVisitor`1 : PdbDebugSubsectionVisitorBase {
    private List`1<TFunction> myFunctions;
    private IDictionary`2<int, DebugDocument> myIndexToDocument;
    private IComparer`1<TFunction> myByAddressComparer;
    private Func`3<ushort, UInt32, TFunction> myInstanceCreatorForBinarySearch;
    [CanBeNullAttribute]
private CompactOneToListMap`2<TFunction, DebugDocument> myFunctionToDocuments;
    public LinesVisitor`1(List`1<TFunction> functions, IDictionary`2<int, DebugDocument> indexToDocument, IComparer`1<TFunction> byAddressComparer, Func`3<ushort, UInt32, TFunction> instanceCreatorForBinarySearch, CompactOneToListMap`2<TFunction, DebugDocument> functionToDocuments);
    public virtual void Visit_LINES(IBinaryReader moduleStream, int start, int stop);
    [CanBeNullAttribute]
private TFunction FindFirstFunctionWithoutLines(ushort sec, UInt32 off);
}
public class JetBrains.Metadata.Debug.Pdb.DebugSubsection.LocalVariablesNameProvider : object {
    private DebugData myDebugData;
    public string NamesSource { get; }
    public LocalVariablesNameProvider(DebugData debugData);
    public sealed virtual string GetVariableName(IMetadataMethod methodBody, int index);
    public sealed virtual string GetVariableName(IMetadataMethod methodBody, int index, int ilOffset);
    public sealed virtual String[] GetVariableTupleElementNames(IMetadataMethod methodBody, int index);
    public sealed virtual String[] GetVariableTupleElementNames(IMetadataMethod methodBody, int index, int ilOffset);
    public sealed virtual string get_NamesSource();
}
internal enum JetBrains.Metadata.Debug.Pdb.DebugSubsection.PdbDebugSubsection : Enum {
    public UInt32 value__;
    public static PdbDebugSubsection SYMBOLS;
    public static PdbDebugSubsection LINES;
    public static PdbDebugSubsection STRINGTABLE;
    public static PdbDebugSubsection FILECHKSMS;
    public static PdbDebugSubsection FRAMEDATA;
}
internal class JetBrains.Metadata.Debug.Pdb.DebugSubsection.PdbDebugSubsectionVisitorBase : object {
    public virtual void Visit_FILECHKSMS(IBinaryReader moduleStream, int start, int stop);
    public virtual void Visit_LINES(IBinaryReader moduleStream, int start, int stop);
}
[IsReadOnlyAttribute]
internal class JetBrains.Metadata.Debug.Pdb.DebugSubsection.PdbLinesBlock : ValueType {
    public DebugDocument Document;
    public PdbSequencePoint[] SequencePoints;
    public PdbLinesBlock(DebugDocument document, PdbSequencePoint[] sequencePoints);
}
public class JetBrains.Metadata.Debug.Pdb.DebugSubsection.SourceFileInfo : object {
    [NotNullAttribute]
public ReadOnlyDictionary`2<MetadataToken, PdbFunction> Functions;
    [NotNullAttribute]
public ChunkList`1<NativePdbFunction> NativeFunctions;
    private static ILogger ourLog;
    internal SourceFileInfo(ChunkList`1<PdbFunction> functions, ChunkList`1<NativePdbFunction> nativeFunctions);
    private static SourceFileInfo();
}
public class JetBrains.Metadata.Debug.Pdb.Generator.PdbFileBuilder : object {
    private Dictionary`2<int, int> myStreamIndexToStreamStartPageIndex;
    private Dictionary`2<int, int> myStreamIndexToStreamSize;
    private Dictionary`2<int, MemoryStream> myStreams;
    private Dictionary`2<int, string> myStreamIndexToStreamName;
    private Dictionary`2<string, int> myStreamNameToStreamIndex;
    private List`1<int> myStreamOrder;
    private int myNumPages;
    private int myTableOfContentsPointersStartPageIndex;
    private MemoryStream myTableOfContentsPointers;
    private int myMaxStreamIndex;
    private bool myAllStreamsAreBuilt;
    private static int PageSize;
    private static int TableOfContentsStreamIndex;
    private static int ListOfNamedStreamsStreamIndex;
    private static int DbiStreamIndex;
    private int GetNumPagesFor(int numBytes);
    private void AddStream(MemoryStream stream, int streamIndex, string streamName);
    public void AddStream(MemoryStream stream, int streamIndex);
    public void AddStream(MemoryStream stream, string streamName);
    public void AddEmptyStream(int streamIndex);
    private void BuildAllStreamsAndTocPointers();
    private void AddTableOfContentsPointers();
    public void WriteToStream(Stream stream);
    private void AlignToPageSize(Stream stream, int writtenBytesNum);
    private void WritePdbHeader(Stream stream);
    private void WriteAllStreams(Stream stream);
    private void CopyWithAlign(MemoryStream inputStream, Stream outputStream);
    private void WriteTableOfContentsPointers(Stream stream);
    private int GetStreamSize(int streamIndex);
    private int GetStreamStartPageIndex(int streamIndex);
    private void AddTableOfContentsStream();
    private void AddListOfNamedStreamsStream();
    public void WriteToFile(FileSystemPath file);
}
public static class JetBrains.Metadata.Debug.Pdb.Generator.PdbStreamGenerator : object {
    private static int SizeOfInt;
    public static int GetStringSizeInBytes(string s);
    public static MemoryStream GenerateListOfNamedStreamsStream(int version, int timeStamp, int age, Guid symId, IDictionary`2<int, string> streamIndexToStreamName);
    public static MemoryStream GenerateTableOfContentsStream(IDictionary`2<int, int> streamIndexToStreamSize, IDictionary`2<int, int> streamIndexToStreamStartPageIndex, int maxStreamIndex, int tableOfContentsStreamStartPageIndex, int tableOfContentsStreamIndex, Func`2<int, int> getNumPages);
    private static void WriteStreamPages(BinaryWriter writer, int streamStartPageIndex, int streamNumPages);
    public static MemoryStream GenerateTableOfContentsPointers(int tableOfContentsStreamStartPageIndex, int tableOfContentsStreamNumPages);
    public static MemoryStream GenerateModuleStream();
    public static MemoryStream GenerateDbiStream(ushort versionMajorMinor, ushort versionBuildNumber, short globalSymbolInfoStreamIndex, short publicSymbolInfoStreamIndex, short symbolRecordStreamIndex, IList`1<DbiModuleInfo> modules, OneToListMap`2<DbiModuleInfo, string> fileNames);
    public static MemoryStream GenerateNamesStream();
    public static MemoryStream GenerateSrcFilesStream();
    public static MemoryStream GenerateEmptyStream();
}
public interface JetBrains.Metadata.Debug.Pdb.IDebugAssemblyInfo {
    [NotNullAttribute]
public FileSystemPath AssemblyFile { get; }
    [CanBeNullAttribute]
public string PdbFile { get; }
    [CanBeNullAttribute]
public string PdbSignature { get; }
    [CanBeNullAttribute]
public string Checksum { get; }
    public DebugInfoType Type { get; }
    public abstract virtual FileSystemPath get_AssemblyFile();
    public abstract virtual string get_PdbFile();
    public abstract virtual string get_PdbSignature();
    public abstract virtual string get_Checksum();
    public abstract virtual DebugInfoType get_Type();
    public abstract virtual bool HasSignature();
}
public interface JetBrains.Metadata.Debug.Pdb.IPdbFunctionWithLines {
    public bool HasLines { get; }
    public abstract virtual bool get_HasLines();
    public abstract virtual void AddLines(PdbLine[] linesBlock);
}
public interface JetBrains.Metadata.Debug.Pdb.IPdbStreamBuilder {
    [CanBeNullAttribute]
public abstract virtual Stream GetSrcSrvStream();
    [CanBeNullAttribute]
public abstract virtual Stream GetNamesStream();
    [CanBeNullAttribute]
public abstract virtual Stream GetSrcFileStream(string name);
    [NotNullAttribute]
public abstract virtual Stream GetDbiStream();
    public abstract virtual string GetStreamName(int name);
}
public class JetBrains.Metadata.Debug.Pdb.NativePdbFunction : object {
    public static IComparer`1<NativePdbFunction> ByAddress;
    public static IComparer`1<NativePdbFunction> ByAddressAndRVA;
    private ushort mySegment;
    private UInt32 myAddress;
    public RVA RVA;
    [CompilerGeneratedAttribute]
private UInt32 <CodeLength>k__BackingField;
    public string Name;
    [CompilerGeneratedAttribute]
private PdbLine[] <Lines>k__BackingField;
    public UInt32 CodeLength { get; }
    [CanBeNullAttribute]
public PdbLine[] Lines { get; private set; }
    public bool HasLines { get; }
    internal NativePdbFunction(ProcSym32 proc, RVA rva);
    private NativePdbFunction(ushort sec, UInt32 off);
    private static NativePdbFunction();
    [CompilerGeneratedAttribute]
public UInt32 get_CodeLength();
    [CompilerGeneratedAttribute]
public PdbLine[] get_Lines();
    [CompilerGeneratedAttribute]
private void set_Lines(PdbLine[] value);
    public sealed virtual bool get_HasLines();
    public sealed virtual void AddLines(PdbLine[] linesBlock);
    public static void LoadNativeLines(StreamBinaryReader moduleStream, int startManagedLines, int endManagedLines, List`1<NativePdbFunction> functions, IDictionary`2<int, DebugDocument> indexToDocument, CompactOneToListMap`2<NativePdbFunction, DebugDocument> functionToDocuments);
}
public class JetBrains.Metadata.Debug.Pdb.ParsedPdb : object {
    [CompilerGeneratedAttribute]
private SrcSrvInfo <SrcSrvInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceLink <SourceLink>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Defines>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, PdbDocumentInfo> <DocumentNameToInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private DebugData <DebugData>k__BackingField;
    [CompilerGeneratedAttribute]
private DebugInfoType <PdbType>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <PdbTimestamp>k__BackingField;
    [CanBeNullAttribute]
public SrcSrvInfo SrcSrvInfo { get; }
    [CanBeNullAttribute]
public SourceLink SourceLink { get; }
    [CanBeNullAttribute]
public String[] Defines { get; }
    [NotNullAttribute]
public IDictionary`2<string, PdbDocumentInfo> DocumentNameToInfo { get; }
    [CanBeNullAttribute]
public DebugData DebugData { get; }
    public DebugInfoType PdbType { get; }
    public DateTime PdbTimestamp { get; }
    internal ParsedPdb(SrcSrvInfo srcSrvInfo, SourceLink sourceLink, String[] defines, IDictionary`2<string, PdbDocumentInfo> documentNameToInfo, DebugData debugData, DebugInfoType pdbType, DateTime pdbTimestamp);
    [CompilerGeneratedAttribute]
public SrcSrvInfo get_SrcSrvInfo();
    [CompilerGeneratedAttribute]
public SourceLink get_SourceLink();
    [CompilerGeneratedAttribute]
public String[] get_Defines();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, PdbDocumentInfo> get_DocumentNameToInfo();
    [CompilerGeneratedAttribute]
public DebugData get_DebugData();
    [CompilerGeneratedAttribute]
public DebugInfoType get_PdbType();
    [CompilerGeneratedAttribute]
public DateTime get_PdbTimestamp();
    public static ParsedPdb GetEmpty(DebugInfoType pdbType);
    public void WriteTo(UnsafeWriter writer);
    public static ParsedPdb ReadFrom(UnsafeReader reader);
    public void DumpSelf(TextWriter writer);
    public bool ReferencesFile(FileSystemPath fileName);
    public bool ReferencesFile(string fileName);
    [CanBeNullAttribute]
public string TryFindDocumentName(PdbDocumentInfo documentInfo);
    [CanBeNullAttribute]
public string TryFindDocumentName(Byte[] checksum);
    [IteratorStateMachineAttribute("JetBrains.Metadata.Debug.Pdb.ParsedPdb/<GetDocumentInfos>d__30")]
public IEnumerable`1<PdbDocumentInfo> GetDocumentInfos(string fileShortName);
}
internal class JetBrains.Metadata.Debug.Pdb.PdbDefinition.FunctionListVisitor : PdbDefinitionVisitorBase {
    private List`1<PdbFunction> myManagedFunctions;
    private List`1<NativePdbFunction> myNativeFunctions;
    private int myModuleIndex;
    private static ILogger ourLog;
    [CanBeNullAttribute]
private NativeFunctionProcessor myNativeFunctionProcessor;
    public FunctionListVisitor(List`1<PdbFunction> managedFunctions, List`1<NativePdbFunction> nativeFunctions, int moduleIndex, NativeFunctionProcessor nativeFunctionProcessor);
    private static FunctionListVisitor();
    public virtual void Visit_S_MANPROC(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_THUNK(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_PROC32(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_UNAMESPACE(IBinaryReader moduleStream, int stop);
}
internal interface JetBrains.Metadata.Debug.Pdb.PdbDefinition.IPdbDefinitionVisitor {
    public abstract virtual void Visit_S_OEM(IBinaryReader moduleStream, int stop);
    public abstract virtual void Visit_S_BLOCK32(IBinaryReader moduleStream, int stop);
    public abstract virtual void Visit_S_MANSLOT(IBinaryReader moduleStream, int stop);
    public abstract virtual void Visit_S_MANCONSTANT(IBinaryReader moduleStream, int stop);
    public abstract virtual void Visit_S_UNAMESPACE(IBinaryReader moduleStream, int stop);
    public abstract virtual void Visit_S_MANPROC(IBinaryReader moduleStream, int stop);
    public abstract virtual void Visit_S_THUNK(IBinaryReader moduleStream, int stop);
    public abstract virtual void Visit_S_PROC32(IBinaryReader moduleStream, int stop);
}
internal class JetBrains.Metadata.Debug.Pdb.PdbDefinition.NativeFunctionProcessor : object {
    private ReadOnlyCollection`1<DbiSectionContribution> mySortedSectionContribs;
    private SectionHeader[] myDbiSectionHeaders;
    public NativeFunctionProcessor(ReadOnlyCollection`1<DbiSectionContribution> sortedSectionContribs, SectionHeader[] dbiSectionHeaders);
    public bool TryGetRva(short moduleIndex, ProcSym32 proc, RVA& rva);
    private RVA GetRva(ProcSym32 proc);
}
internal class JetBrains.Metadata.Debug.Pdb.PdbDefinition.PdbDefinitionVisitorBase : object {
    private static Stack`1<PdbSymbolDefinitions> myRec;
    private static Stack`1<PdbSymbolDefinitions> myNeedSEndRec;
    private static PdbDefinitionVisitorBase();
    private void DefaultHandler(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_OEM(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_BLOCK32(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_MANSLOT(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_MANCONSTANT(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_UNAMESPACE(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_MANPROC(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_THUNK(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_PROC32(IBinaryReader moduleStream, int stop);
}
internal class JetBrains.Metadata.Debug.Pdb.PdbDefinition.PdbFunctionVisitor : PdbScopeVisitor {
    private WindowsPdbCustomDebugDataReader myReader;
    [CanBeNullAttribute]
public MethodCustomDebugInformation MethodCustomDebugInformation { get; }
    public PdbFunctionVisitor(UInt32 address, PdbScope rootScope, ICollection`1<string> usedNamespaces, ICollection`1<PdbConstant> constants);
    public MethodCustomDebugInformation get_MethodCustomDebugInformation();
    public virtual void Visit_S_OEM(IBinaryReader moduleStream, int stop);
}
internal class JetBrains.Metadata.Debug.Pdb.PdbDefinition.PdbScopeBase : object {
    public PdbConstant[] Constants;
    public String[] UsedNamespaces;
    public UInt32 Address;
    public UInt32 Offset;
    public UInt32 Length;
    public UInt32 TypeIndex;
    public PdbScope RootScope;
    internal PdbScopeBase(UInt32 funcOffset, UInt32 address, UInt32 len, UInt32 end, IBinaryReader stream);
}
internal class JetBrains.Metadata.Debug.Pdb.PdbDefinition.PdbScopeVisitor : PdbDefinitionVisitorBase {
    private UInt32 myAddress;
    private PdbScope myScope;
    private ICollection`1<string> myUsedNamespaces;
    private ICollection`1<PdbConstant> myConstants;
    public PdbScopeVisitor(UInt32 address, PdbScope scope, ICollection`1<string> usedNamespaces, ICollection`1<PdbConstant> constants);
    public virtual void Visit_S_BLOCK32(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_MANSLOT(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_UNAMESPACE(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_MANCONSTANT(IBinaryReader moduleStream, int stop);
}
internal enum JetBrains.Metadata.Debug.Pdb.PdbDefinition.PdbSymbolDefinitions : Enum {
    public UInt32 value__;
    public static PdbSymbolDefinitions S_END;
    public static PdbSymbolDefinitions S_LPROC_V1;
    public static PdbSymbolDefinitions S_GPROC_V1;
    public static PdbSymbolDefinitions S_THUNK_V1;
    public static PdbSymbolDefinitions S_BLOCK_V1;
    public static PdbSymbolDefinitions S_OEM;
    public static PdbSymbolDefinitions S_REGISTER_ST;
    public static PdbSymbolDefinitions S_CONSTANT_ST;
    public static PdbSymbolDefinitions S_UDT_ST;
    public static PdbSymbolDefinitions S_COBOLUDT_ST;
    public static PdbSymbolDefinitions S_MANYREG_ST;
    public static PdbSymbolDefinitions S_BPREL32_ST;
    public static PdbSymbolDefinitions S_LDATA32_ST;
    public static PdbSymbolDefinitions S_GDATA32_ST;
    public static PdbSymbolDefinitions S_PUB32_ST;
    public static PdbSymbolDefinitions S_LPROC32_ST;
    public static PdbSymbolDefinitions S_GPROC32_ST;
    public static PdbSymbolDefinitions S_VFTABLE32;
    public static PdbSymbolDefinitions S_REGREL32_ST;
    public static PdbSymbolDefinitions S_LTHREAD32_ST;
    public static PdbSymbolDefinitions S_GTHREAD32_ST;
    public static PdbSymbolDefinitions S_LPROCMIPS_ST;
    public static PdbSymbolDefinitions S_GPROCMIPS_ST;
    public static PdbSymbolDefinitions S_FRAMEPROC;
    public static PdbSymbolDefinitions S_COMPILE2_ST;
    public static PdbSymbolDefinitions S_MANYREG2_ST;
    public static PdbSymbolDefinitions S_LPROCIA64_ST;
    public static PdbSymbolDefinitions S_GPROCIA64_ST;
    public static PdbSymbolDefinitions S_LOCALSLOT_ST;
    public static PdbSymbolDefinitions S_PARAMSLOT_ST;
    public static PdbSymbolDefinitions S_ANNOTATION;
    public static PdbSymbolDefinitions S_GMANPROC_ST;
    public static PdbSymbolDefinitions S_LMANPROC_ST;
    public static PdbSymbolDefinitions S_RESERVED1;
    public static PdbSymbolDefinitions S_RESERVED2;
    public static PdbSymbolDefinitions S_RESERVED3;
    public static PdbSymbolDefinitions S_RESERVED4;
    public static PdbSymbolDefinitions S_LMANDATA_ST;
    public static PdbSymbolDefinitions S_GMANDATA_ST;
    public static PdbSymbolDefinitions S_MANFRAMEREL_ST;
    public static PdbSymbolDefinitions S_MANREGISTER_ST;
    public static PdbSymbolDefinitions S_MANSLOT_ST;
    public static PdbSymbolDefinitions S_MANMANYREG_ST;
    public static PdbSymbolDefinitions S_MANREGREL_ST;
    public static PdbSymbolDefinitions S_MANMANYREG2_ST;
    public static PdbSymbolDefinitions S_MANTYPREF;
    public static PdbSymbolDefinitions S_UNAMESPACE_ST;
    public static PdbSymbolDefinitions S_ST_MAX;
    public static PdbSymbolDefinitions S_OBJNAME;
    public static PdbSymbolDefinitions S_THUNK32;
    public static PdbSymbolDefinitions S_BLOCK32;
    public static PdbSymbolDefinitions S_WITH32;
    public static PdbSymbolDefinitions S_LABEL32;
    public static PdbSymbolDefinitions S_REGISTER;
    public static PdbSymbolDefinitions S_CONSTANT;
    public static PdbSymbolDefinitions S_UDT;
    public static PdbSymbolDefinitions S_COBOLUDT;
    public static PdbSymbolDefinitions S_MANYREG;
    public static PdbSymbolDefinitions S_BPREL32;
    public static PdbSymbolDefinitions S_LDATA32;
    public static PdbSymbolDefinitions S_GDATA32;
    public static PdbSymbolDefinitions S_PUB32;
    public static PdbSymbolDefinitions S_LPROC32;
    public static PdbSymbolDefinitions S_GPROC32;
    public static PdbSymbolDefinitions S_REGREL32;
    public static PdbSymbolDefinitions S_LTHREAD32;
    public static PdbSymbolDefinitions S_GTHREAD32;
    public static PdbSymbolDefinitions S_LPROCMIPS;
    public static PdbSymbolDefinitions S_GPROCMIPS;
    public static PdbSymbolDefinitions S_COMPILE2;
    public static PdbSymbolDefinitions S_MANYREG2;
    public static PdbSymbolDefinitions S_LPROCIA64;
    public static PdbSymbolDefinitions S_GPROCIA64;
    public static PdbSymbolDefinitions S_LOCALSLOT;
    public static PdbSymbolDefinitions S_SLOT;
    public static PdbSymbolDefinitions S_PARAMSLOT;
    public static PdbSymbolDefinitions S_LMANDATA;
    public static PdbSymbolDefinitions S_GMANDATA;
    public static PdbSymbolDefinitions S_MANFRAMEREL;
    public static PdbSymbolDefinitions S_MANREGISTER;
    public static PdbSymbolDefinitions S_MANSLOT;
    public static PdbSymbolDefinitions S_MANMANYREG;
    public static PdbSymbolDefinitions S_MANREGREL;
    public static PdbSymbolDefinitions S_MANMANYREG2;
    public static PdbSymbolDefinitions S_UNAMESPACE;
    public static PdbSymbolDefinitions S_PROCREF;
    public static PdbSymbolDefinitions S_DATAREF;
    public static PdbSymbolDefinitions S_LPROCREF;
    public static PdbSymbolDefinitions S_ANNOTATIONREF;
    public static PdbSymbolDefinitions S_TOKENREF;
    public static PdbSymbolDefinitions S_GMANPROC;
    public static PdbSymbolDefinitions S_LMANPROC;
    public static PdbSymbolDefinitions S_TRAMPOLINE;
    public static PdbSymbolDefinitions S_MANCONSTANT;
    public static PdbSymbolDefinitions S_ATTR_FRAMEREL;
    public static PdbSymbolDefinitions S_ATTR_REGISTER;
    public static PdbSymbolDefinitions S_ATTR_REGREL;
    public static PdbSymbolDefinitions S_ATTR_MANYREG;
    public static PdbSymbolDefinitions S_SEPCODE;
    public static PdbSymbolDefinitions S_LOCAL;
    public static PdbSymbolDefinitions S_DEFRANGE;
    public static PdbSymbolDefinitions S_DEFRANGE2;
    public static PdbSymbolDefinitions S_SECTION;
    public static PdbSymbolDefinitions S_COFFGROUP;
    public static PdbSymbolDefinitions S_EXPORT;
    public static PdbSymbolDefinitions S_CALLSITEINFO;
    public static PdbSymbolDefinitions S_FRAMECOOKIE;
    public static PdbSymbolDefinitions S_DISCARDED;
    public static PdbSymbolDefinitions S_RECTYPE_MAX;
    public static PdbSymbolDefinitions S_RECTYPE_LAST;
}
internal class JetBrains.Metadata.Debug.Pdb.PdbDefinition.Proc32Scope : PdbScopeBase {
    internal Proc32Scope(UInt32 funcOffset, ProcSym32 block, IBinaryReader stream);
}
internal class JetBrains.Metadata.Debug.Pdb.PdbDefinition.ThunkVisitor : PdbDefinitionVisitorBase {
}
public class JetBrains.Metadata.Debug.Pdb.PdbDefinition.WindowsPdbCustomDebugDataReader : object {
    private static long MD2;
    [CompilerGeneratedAttribute]
private MethodCustomDebugInformation <MethodCustomDebugInformation>k__BackingField;
    [CanBeNullAttribute]
public MethodCustomDebugInformation MethodCustomDebugInformation { get; private set; }
    [CompilerGeneratedAttribute]
public MethodCustomDebugInformation get_MethodCustomDebugInformation();
    [CompilerGeneratedAttribute]
private void set_MethodCustomDebugInformation(MethodCustomDebugInformation value);
    public MethodCustomDebugInformation ReadForModule(IBinaryReader moduleStream, int stop);
    public MethodCustomDebugInformation ReadForMethod(IBinaryReader moduleStream);
    private void ReadCustomMetadata(IBinaryReader moduleStream);
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Debug.Pdb.PdbDocumentInfo : ValueType {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Checksum>k__BackingField;
    public static PdbDocumentInfo Default;
    public static PdbDocumentInfo Invalid;
    public int Index { get; }
    [CanBeNullAttribute]
public Byte[] Checksum { get; }
    public bool IsValid { get; }
    public bool IsValidChecksum { get; }
    public PdbDocumentInfo(int index, Byte[] checksum);
    private static PdbDocumentInfo();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public Byte[] get_Checksum();
    public static PdbDocumentInfo FromIndex(int index);
    public static PdbDocumentInfo FromChecksum(Byte[] checksum);
    public virtual string ToString();
    public bool get_IsValid();
    public bool get_IsValidChecksum();
}
public class JetBrains.Metadata.Debug.Pdb.PdbFunction : object {
    internal static IComparer`1<PdbFunction> ByAddress;
    public static IComparer`1<PdbFunction> ByAddressAndToken;
    internal static Guid MsilMetaData;
    public ushort Segment;
    public UInt32 Address;
    [CompilerGeneratedAttribute]
private UInt32 <CodeLength>k__BackingField;
    public string Name;
    [CompilerGeneratedAttribute]
private MetadataToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private PdbLine[] <Lines>k__BackingField;
    [CompilerGeneratedAttribute]
private PdbConstant[] <Constants>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <UsedNamespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodCustomDebugInformation <MethodCustomDebugInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private PdbScope <RootScope>k__BackingField;
    public UInt32 CodeLength { get; }
    public MetadataToken Token { get; internal set; }
    [CanBeNullAttribute]
public PdbLine[] Lines { get; private set; }
    [CanBeNullAttribute]
public PdbConstant[] Constants { get; }
    [CanBeNullAttribute]
public String[] UsedNamespaces { get; }
    [CanBeNullAttribute]
public MethodCustomDebugInformation MethodCustomDebugInformation { get; }
    public PdbScope RootScope { get; }
    public bool HasLines { get; }
    internal PdbFunction(IBinaryReader moduleStream, ManProcSym proc);
    internal PdbFunction(IBinaryReader moduleStream, DatasSym32 datas);
    public PdbFunction(ushort sec, UInt32 off);
    private static PdbFunction();
    [CompilerGeneratedAttribute]
public UInt32 get_CodeLength();
    [CompilerGeneratedAttribute]
public MetadataToken get_Token();
    [CompilerGeneratedAttribute]
internal void set_Token(MetadataToken value);
    [CompilerGeneratedAttribute]
public PdbLine[] get_Lines();
    [CompilerGeneratedAttribute]
private void set_Lines(PdbLine[] value);
    [CompilerGeneratedAttribute]
public PdbConstant[] get_Constants();
    [CompilerGeneratedAttribute]
public String[] get_UsedNamespaces();
    [CompilerGeneratedAttribute]
public MethodCustomDebugInformation get_MethodCustomDebugInformation();
    [CompilerGeneratedAttribute]
public PdbScope get_RootScope();
    public sealed virtual bool get_HasLines();
    public sealed virtual void AddLines(PdbLine[] linesBlock);
    public static void LoadManagedLines(StreamBinaryReader moduleStream, int startManagedLines, int endManagedLines, List`1<PdbFunction> func, IDictionary`2<int, DebugDocument> indexToDocument, CompactOneToListMap`2<PdbFunction, DebugDocument> functionToDocuments);
    public void MergeFunction(PdbFunction pdbFunction);
}
public class JetBrains.Metadata.Debug.Pdb.PdbHeader : ValueType {
    public static int HeaderSize;
    public static string Pdb7Signature;
    public static int Pdb7SignatureSize;
    private UInt32 myBlockSize;
    private UInt32 myNumPages;
    private string mySignature;
    private UInt32 myStartPage;
    private UInt32 myTocPage;
    private UInt32 myTocSize;
    private UInt32 myUnknown2;
    public string Signature { get; }
    public UInt32 BlockSize { get; }
    public UInt32 NumPages { get; }
    public UInt32 TocSize { get; }
    public UInt32 TocBlocksPage { get; }
    public UInt32 FirstPage { get; }
    internal PdbHeader(BinaryReader reader);
    internal PdbHeader(UInt32 blockSize, UInt32 startPage, UInt32 numPages, UInt32 tocSize, UInt32 tocPage);
    internal void Write(BinaryWriter writer);
    public string get_Signature();
    public UInt32 get_BlockSize();
    public UInt32 get_NumPages();
    public UInt32 get_TocSize();
    public UInt32 get_TocBlocksPage();
    public UInt32 get_FirstPage();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Debug.Pdb.PdbLine : ValueType {
    public DebugDocument Document;
    public PdbSequencePoint SequencePoint;
    private PdbLine(DebugDocument document, PdbSequencePoint& sequencePoint);
    internal static PdbLine[] ExtractLinesFromLinesBlock(IEnumerable`1<PdbLinesBlock> linesBlocks);
    internal static PdbLine[] MergeLines(PdbLine[] lines1, PdbLine[] lines2);
    private static int Comparison(PdbLine line1, PdbLine line2);
}
public class JetBrains.Metadata.Debug.Pdb.PdbNameAndSignature : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Signature>k__BackingField;
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public string Signature { get; }
    public PdbNameAndSignature(string name, string signature);
    public PdbNameAndSignature(DebugInfo debugInfo);
    public PdbNameAndSignature(string pdbPath, Guid signatureGuid, UInt32 signatureAge);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Signature();
    public sealed virtual bool Equals(PdbNameAndSignature other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PdbNameAndSignature left, PdbNameAndSignature right);
    public static bool op_Inequality(PdbNameAndSignature left, PdbNameAndSignature right);
}
[FlagsAttribute]
public enum JetBrains.Metadata.Debug.Pdb.PdbParseLevel : Enum {
    public int value__;
    public static PdbParseLevel None;
    public static PdbParseLevel LoadFunc;
    public static PdbParseLevel LoadFuncAndStatement;
    public static PdbParseLevel LoadNative;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Debug.Pdb.PdbParseLevelEx : object {
    [ExtensionAttribute]
public static bool HasFlag(PdbParseLevel level, PdbParseLevel flag);
}
internal static class JetBrains.Metadata.Debug.Pdb.PdbParser : object {
    private static void Assert_S_END(IBinaryReader moduleStream, PdbSymbolDefinitions needFor);
    public static void ParseSymbolDefinitions(IBinaryReader moduleStream, int initialPosition, int endPosition, IPdbDefinitionVisitor visitor);
    public static void ParseDebugSubsection(IBinaryReader moduleStream, int initialPosition, int endPosition, IPdbDebugSubsectionVisitor visitor);
}
public class JetBrains.Metadata.Debug.Pdb.PdbReader : object {
    [ObsoleteAttribute("Use overload with IAssemblyLocation")]
[CanBeNullAttribute]
public static ParsedPdb ReadPdb(FileSystemPath pdbPath, PdbParseLevel level, FileSystemPath assemblyPath);
    [CanBeNullAttribute]
public static ParsedPdb ReadPdb(FileSystemPath pdbPath, PdbParseLevel level, IAssemblyLocation assemblyLocation);
    [CanBeNullAttribute]
public static ParsedPdb ReadPdbUnguarded(FileSystemPath pdbPath, PdbParseLevel level, IAssemblyLocation assemblyLocation);
    [CanBeNullAttribute]
public static IReadOnlyList`1<string> ReadDocumentNamesFromPdb(FileSystemPath pdbPath);
    public static FileSystemPath TemporarilyExtractEmbeddedPdb(Lifetime lifetime, IAssemblyLocation assemblyWithEmbeddedPdb);
    private static void ExtractEmbeddedPdb(FileStream extractedPdb, IAssemblyLocation assemblyWithEmbeddedPdb);
    private static ParsedPdb ReadPortablePdb(FileSystemPath pdbPath, PdbParseLevel level, DebugInfoType type, IAssemblyLocation assemblyLocation, DateTime timestamp);
    [CanBeNullAttribute]
public static DebugData ReadPdb(FileSystemPath pdbPath, DebugInfoType expectedPdbType);
    [CanBeNullAttribute]
public static DebugData ReadPdb(Stream pdbStream, string pdbId);
    [CanBeNullAttribute]
private static DebugData ReadPdb(Stream pdbStream, string pdbId, DateTime pdbModificationTimeUtc, FileSystemPath originalPdbFilePath, DebugInfoType expectedPdbType, bool ignoreExpectedPdbType);
    [CanBeNullAttribute]
public static DebugData ReadWindowsPdb(FileSystemPath pdbPath);
    [CanBeNullAttribute]
public static DebugData ReadWindowsPdb(Stream pdbStream, FileSystemPath originalPdbPath);
    [CanBeNullAttribute]
private static DebugData ReadPortablePdb(Stream pdbStream, string pdbId, DateTime pdbModificationTimeUtc, FileSystemPath originalPdbPath, DebugInfoType pdbType);
}
public class JetBrains.Metadata.Debug.Pdb.PdbRootRecord : object {
    private Guid myPdbSignature;
    private UInt32 myTimeStamp;
    private UInt32 myVersion;
    private UInt32 myPdbAge;
    public UInt32 Version { get; }
    public UInt32 TimeDateStamp { get; }
    public Guid PdbSignature { get; }
    public UInt32 PdbAge { get; }
    public PdbRootRecord(BinaryReader rdr);
    public UInt32 get_Version();
    public UInt32 get_TimeDateStamp();
    public Guid get_PdbSignature();
    public UInt32 get_PdbAge();
}
public class JetBrains.Metadata.Debug.Pdb.PdbScope : object {
    private List`1<PdbVariable> myVariables;
    private List`1<PdbScope> myChildScopes;
    [CompilerGeneratedAttribute]
private PdbScope <ParentScope>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Length>k__BackingField;
    [CanBeNullAttribute]
public PdbScope ParentScope { get; }
    public UInt32 StartOffset { get; }
    public UInt32 Length { get; }
    public List`1<PdbVariable> Variables { get; }
    public List`1<PdbScope> ChildScopes { get; }
    private PdbScope(UInt32 startOffset, UInt32 length, PdbScope parentScope);
    [CompilerGeneratedAttribute]
public PdbScope get_ParentScope();
    [CompilerGeneratedAttribute]
public UInt32 get_StartOffset();
    [CompilerGeneratedAttribute]
public UInt32 get_Length();
    internal static PdbScope Create(UInt32 startOffset, UInt32 length, PdbScope parentScope);
    internal static PdbScope CreateRoot(UInt32 functionCodeLength);
    public List`1<PdbVariable> get_Variables();
    public List`1<PdbScope> get_ChildScopes();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Debug.Pdb.PdbScopeEx : object {
    [ExtensionAttribute]
public static IList`1<Pair`2<PdbVariable, PdbScope>> FlattenVariables(PdbScope scope);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("PdbSequencePoint: {Offset} {LineBegin} {Statement}")]
public class JetBrains.Metadata.Debug.Pdb.PdbSequencePoint : ValueType {
    private static int NeverStepIntoLineNumber;
    public static int HiddenSequencePointLine;
    private CV_Line myLine;
    private CV_Column myColumn;
    public UInt32 Offset { get; }
    public UInt32 LineBegin { get; }
    public UInt32 LineEnd { get; }
    public bool Statement { get; }
    public ushort ColBegin { get; }
    public ushort ColEnd { get; }
    public bool IsValidLine { get; }
    internal PdbSequencePoint(CV_Line line, CV_Column column);
    public static bool IsValidLineNumber(UInt32 line);
    public UInt32 get_Offset();
    public UInt32 get_LineBegin();
    public UInt32 get_LineEnd();
    public bool get_Statement();
    public ushort get_ColBegin();
    public ushort get_ColEnd();
    public bool get_IsValidLine();
}
internal class JetBrains.Metadata.Debug.Pdb.PdbSignatureComparer : object {
    public static PdbSignatureComparer Instance;
    private static PdbSignatureComparer();
    public sealed virtual bool Equals(string x, string y);
    public sealed virtual int GetHashCode(string s);
}
public class JetBrains.Metadata.Debug.Pdb.PdbToc : object {
    private PdbStream[] myStreams;
    public PdbStream[] Streams { get; }
    internal PdbToc(BinaryReader reader, UInt32 blockSize);
    public PdbStream[] get_Streams();
    private static PdbStream LoadPDBStreamBlocks(BinaryReader reader, UInt32 streamSize, UInt32 blockSize);
}
public class JetBrains.Metadata.Debug.Pdb.PdbTupleInfo : object {
    [CompilerGeneratedAttribute]
private int <LocalSlotIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConstantScopeStart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConstantScopeEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TupleElementNames>k__BackingField;
    public int LocalSlotIndex { get; }
    public int ConstantScopeStart { get; }
    public int ConstantScopeEnd { get; }
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
[ItemCanBeNullAttribute]
public String[] TupleElementNames { get; }
    public PdbTupleInfo(String[] tupleElementNames, int localSlotIndex, int constantScopeStart, int constantScopeEnd, string name);
    [CompilerGeneratedAttribute]
public int get_LocalSlotIndex();
    [CompilerGeneratedAttribute]
public int get_ConstantScopeStart();
    [CompilerGeneratedAttribute]
public int get_ConstantScopeEnd();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public String[] get_TupleElementNames();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Debug.Pdb.PdbUtils : object {
    internal static int PdbSignatureGuidStringLength;
    private static int MaxPdbSignatureStringLength;
    private static string PortablePdbAgeString;
    private static string Age1String;
    public static string GetPdbExtension(bool compressed);
    [ObsoleteAttribute("Use overload with IAssemblyLocation")]
[NotNullAttribute]
public static IList`1<DebugInfo> GetDebugInfos(FileSystemPath path);
    [NotNullAttribute]
public static IList`1<DebugInfo> GetDebugInfos(IAssemblyLocation assemblyLocation);
    [ContractAnnotationAttribute("null => false")]
public static bool IsValid(Byte[] checksum);
    [ObsoleteAttribute("Use overload with IAssemblyLocation")]
public static string GetChecksumString(FileSystemPath path, string preferable);
    public static string GetChecksumString(IAssemblyLocation assemblyLocation, string preferable);
    [ObsoleteAttribute("Use overload with IAssemblyLocation")]
[NotNullAttribute]
public static IList`1<PdbChecksum> GetChecksums(FileSystemPath path);
    [NotNullAttribute]
public static IList`1<PdbChecksum> GetChecksums(IAssemblyLocation assemblyLocation);
    [ObsoleteAttribute("Use overload with IAssemblyLocation")]
[NotNullAttribute]
public static IList`1<DebugInfo> GetDebugInfosThrow(FileSystemPath path);
    [NotNullAttribute]
public static IList`1<DebugInfo> GetDebugInfosThrow(IAssemblyLocation assemblyLocation);
    [NotNullAttribute]
[ObsoleteAttribute("Use PdbUtils.GetDebugInfos instead")]
public static IList`1<DebugInfo7> GetDebugInfos7(FileSystemPath path);
    [ObsoleteAttribute("Use overload with IAssemblyLocation")]
[CanBeNullAttribute]
public static Byte[] TryGetDecompressedEmbeddedPortablePdb(FileSystemPath path);
    [CanBeNullAttribute]
public static Byte[] TryGetDecompressedEmbeddedPortablePdb(IAssemblyLocation assemblyLocation);
    [CanBeNullAttribute]
public static Stream TryGetDecompressedEmbeddedPortablePdbStream(Stream assemblyStream);
    [ExtensionAttribute]
public static IEnumerable`1<DebugInfo> OfDebugInfoType(IEnumerable`1<DebugInfo> debugInfos, DebugInfoType type);
    [ExtensionAttribute]
public static IEnumerable`1<DebugInfo> OfAnyStandaloneType(IEnumerable`1<DebugInfo> debugInfos);
    [ObsoleteAttribute("Use overload with IAssemblyLocation")]
[CanBeNullAttribute]
public static string TryGetLastAnyStandalonePdbSignature(FileSystemPath path);
    [CanBeNullAttribute]
public static string TryGetLastAnyStandalonePdbSignature(IAssemblyLocation assemblyLocation);
    public static bool TryGetSignatureAndTimestampForAnyPdbType(VirtualFileSystemPath path, Guid& signature, UInt32& timestamp);
    public static bool TryGetSignatureAndTimestampForAnyPdbType(Stream stream, Guid& signature, UInt32& timestamp);
    public static void GetSignatureAndAge(FileSystemPath windowsPdbPath, Guid& signature, UInt32& ageFromDbi);
    public static void GetSignatureAndAge(Stream pdbStream, Guid& signature, UInt32& ageFromDbi);
    private static void GetSignatureAndAge(WindowsPdbFile pdbFile, Guid& signature, UInt32& ageFromDbi, UInt32& ageFromRoot);
    public static void GetSignatureAndTimestamp(FileSystemPath portablePdbPath, Guid& signature, UInt32& timeDateStamp);
    public static void GetSignatureAndTimestamp(Stream portablePdbStream, string pdbId, Guid& signature, UInt32& timeDateStamp);
    private static bool GetSignatureAndTimestamp(MetadataAccessCookie cookie, Guid& signature, UInt32& timeDateStamp);
    [ObsoleteAttribute("Use overload with IAssemblyLocation")]
public static bool VerifySignature(FileSystemPath assemblyPath, FileSystemPath pdbPath);
    public static bool VerifySignature(IAssemblyLocation assemblyLocation, FileSystemPath pdbPath);
    public static bool VerifySignature(IAssemblyLocation assemblyLocation, Stream pdbStream, string pdbId);
    internal static bool VerifySignature(IAssemblyLocation assemblyLocation, FileSystemPath pdbPath, DebugInfoType pdbTypeFromPdb);
    internal static bool VerifySignature(IAssemblyLocation assemblyLocation, Stream pdbStream, string pdbId, DebugInfoType pdbTypeFromPdb);
    private static bool VerifySignature(IEnumerable`1<DebugInfo> debugInfos, Guid signatureFromPdb, UInt32 ageOrTimestampFromPdb, DebugInfoType pdbTypeFromPdb);
    private static bool VerifySignature(IAssemblyLocation assemblyLocation, WindowsPdbFile windowsPdbFile);
    public static DebugInfoType GetPdbType(FileSystemPath pdbPath);
    public static DebugInfoType GetPdbType(Stream pdbStream);
    public static DebugInfoType GetPdbType(IAssemblyLocation pdbLocation);
    public static bool TryGetPdbType(FileSystemPath pdbPath, DebugInfoType& debugInfoType);
    public static bool TryGetPdbType(IAssemblyLocation pdbLocation, DebugInfoType& debugInfoType);
    public static bool TryGetPdbType(Stream pdbStream, DebugInfoType& debugInfoType);
    [CanBeNullAttribute]
public static DebugInfo TryGetPdbDebugInfo(FileSystemPath pdbPath);
    [ExtensionAttribute]
[NotNullAttribute]
public static ParsedPdb ToParsedPdb(PortablePdbFile portablePdbFile, PdbParseLevel level, DateTime pdbTimestamp);
    [ExtensionAttribute]
[NotNullAttribute]
public static ParsedPdb ToParsedPdb(WindowsPdbFile windowsPdbFile, PdbParseLevel level, DateTime pdbTimestamp);
    [CanBeNullAttribute]
public static CompactOneToListMap`2<string, string> GetTypeToFilesMapping(FileSystemPath pdbPath, IAssemblyLocation assemblyLocation, DebugInfoType pdbType, HashSet`1& typesWithInferredMapping);
    [NotNullAttribute]
public static CompactOneToListMap`2<string, string> GetTypeToFilesMapping(WindowsPdbFile windowsPdbFile, IAssemblyLocation assemblyLocation, HashSet`1& typesWithInferredMapping);
    [NotNullAttribute]
private static CompactOneToListMap`2<string, string> GetTypeToFilesFromSequencePoints(WindowsPdbFile windowsPdbFile, IMetadataAssembly metadataAssembly, IMetadataAccess metadataAccess, HashSet`1& typesWithInferredMapping);
    private static void ProcessNestedTypes(MetadataToken typeToken, OneToSetMap`2<MetadataToken, MetadataToken> nestedTypeMap, CompactOneToListMap`2<string, string> typeToFiles, String[] typeFqns, Boolean[] processed);
    public static void InferTypeToFiles(CompactOneToListMap`2<string, string> typeToFiles, IMetadataAssembly metadataAssembly, IMetadataAccess metadataAccess, String[] typeFqns, IEnumerable`1<string> allFileNames, HashSet`1& typesWithInferredMapping);
    private static string GetFullPath(FileSystemPath path, bool altDirectorySeparator);
    private static string GetMostPopularExtension(Dictionary`2<string, int> extensions);
    [CanBeNullAttribute]
private static string GetFileName(IMetadataTypeInfo type);
    [NotNullAttribute]
private static CompactOneToListMap`2<string, string> GetTypeToFilesFromModules(WindowsPdbFile windowsPdbFile);
    [NotNullAttribute]
public static string GeneratePdbSignatureString(DebugInfo debugInfo);
    public static bool IsPortablePdbSignature(string signature);
    public static bool IsAge1PdbSignature(string signature);
    [NotNullAttribute]
public static string ToAge1PdbSignature(string portablePdbSignature);
    [NotNullAttribute]
public static string ToPortablePdbSignature(string age1PdbSignature);
    [NotNullAttribute]
public static string GeneratePdbSignatureString(DebugInfo7 debugInfo7);
    [NotNullAttribute]
public static string GeneratePdbSignatureString(Guid pdbSignature, UInt32 pdbAge);
    [NotNullAttribute]
public static string GeneratePdbEmptySignatureString();
    [NotNullAttribute]
public static string GetPdbFileName(DebugInfo debugInfo);
    [NotNullAttribute]
public static string GetPdbFileNameWithoutExtension(DebugInfo debugInfo);
    [NotNullAttribute]
public static string GetPdbFileNameWithoutExtension(string pdbFile);
    [CanBeNullAttribute]
public static DebugInfo TryGetLastWindowsDebugInfo(FileSystemPath path);
    [CanBeNullAttribute]
public static DebugInfo TryGetLastWindowsDebugInfo(IList`1<DebugInfo> debugInfos);
    [ObsoleteAttribute("Use overload with IAssemblyLocation")]
[CanBeNullAttribute]
public static DebugInfo TryGetLastAnyStandaloneDebugInfo(FileSystemPath path);
    [CanBeNullAttribute]
public static DebugInfo TryGetLastAnyStandaloneDebugInfo(IAssemblyLocation assemblyLocation);
    [CanBeNullAttribute]
public static DebugInfo TryGetLastAnyStandaloneDebugInfo(IList`1<DebugInfo> debugInfos);
    [CanBeNullAttribute]
public static DebugInfo TryGetLastDebugInfoExceptDeterministic(IList`1<DebugInfo> debugInfos);
    [CanBeNullAttribute]
[ObsoleteAttribute("Use PdbUtils.TryGetLastStandaloneDebugInfo instead")]
public static DebugInfo7 TryGetLastDebugInfo7(FileSystemPath path);
    [ExtensionAttribute]
public static bool IsAnyStandaloneType(DebugInfo debugInfo);
    [ExtensionAttribute]
[ObsoleteAttribute("Use overload with IAssemblyLocation")]
public static void WritePdb(DebugData debugData, FileSystemPath pdbPath, FileSystemPath assemblyPath, DebugInfo debugInfo);
    [ExtensionAttribute]
public static void WritePdb(DebugData debugData, FileSystemPath pdbPath, IAssemblyLocation assemblyLocation, DebugInfo debugInfo);
    private static void LongPathWriteFileAction(FileSystemPath filePath, Action`1<FileSystemPath> writeFileAction);
    private static bool FilePathIsLong(FileSystemPath filePath);
    internal static string GetPdbId(FileSystemPath pdbPath);
    public static DebugInfoType GetPdbTypeAndRewind(Stream pdbStream);
    private static void ThrowIfCantSeek(Stream pdbStream);
    private static void ThrowIfNotInBeginning(Stream pdbStream);
    [CompilerGeneratedAttribute]
internal static string <GetChecksumString>g__FormatHash|9_0(string algo, Byte[] sum);
}
public class JetBrains.Metadata.Debug.Pdb.PdbVariable : object {
    private string myName;
    private UInt32 mySlotIndex;
    private UInt32 myLocalSignatureToken;
    public UInt32 SlotIndex { get; }
    public string Name { get; }
    public UInt32 LocalSignatureToken { get; }
    internal PdbVariable(AttrSlotSym attrSlotSym);
    public UInt32 get_SlotIndex();
    public string get_Name();
    public UInt32 get_LocalSignatureToken();
}
public class JetBrains.Metadata.Debug.Pdb.PdbXml : object {
    [NotNullAttribute]
private DebugData myDebugData;
    [CanBeNullAttribute]
private ParsedPdb myParsedPdb;
    [CanBeNullAttribute]
private CompactOneToListMap`2<string, string> myType2Files;
    [CanBeNullAttribute]
private HashSet`1<string> myTypesWithInferredMapping;
    [CanBeNullAttribute]
private FileSystemPath myPdbPath;
    [CanBeNullAttribute]
private FileSystemPath myAssemblyPath;
    public PdbXml(DebugData debugData, ParsedPdb parsedPdb, CompactOneToListMap`2<string, string> type2Files, HashSet`1<string> typesWithInferredMapping, FileSystemPath pdbPath, FileSystemPath assemblyPath);
    private void DumpType2Files(XmlWriter writer);
    private void DumpSourceLink(XmlWriter writer);
    private void DumpSrcSrvInfo(XmlWriter writer);
    private void WritePdbAttributes(XmlWriter writer, bool includePathInfos);
    public void Dump(XmlWriter writer, bool includePathInfos, string rootElement);
    public static void Dump(DebugData debugData, XmlWriter writer);
    public void DumpToFile(FileSystemPath filePath);
}
public class JetBrains.Metadata.Debug.Pdb.PortablePdbFile : object {
    private PdbStream myPdbStream;
    [CanBeNullAttribute]
private IMetadataAssembly myAssembly;
    [CanBeNullAttribute]
private IMetadataAccess myAssemblyMetadataAccess;
    [CanBeNullAttribute]
private CompactOneToListMap`2<string, string> myTypeToFiles;
    [CanBeNullAttribute]
private HashSet`1<string> myTypesWithInferredMapping;
    [CanBeNullAttribute]
private SourceLink mySourceLink;
    [CanBeNullAttribute]
private String[] myDefines;
    private bool mySourceLinkAlreadyRead;
    private bool myDefinesAlreadyRead;
    private bool myMethodTablesAreConsistent;
    private int myMdiEndRid;
    internal static int ModuleImportScopeRid;
    [CompilerGeneratedAttribute]
private IMetadataAccess <PdbMetadataAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEmbedded>k__BackingField;
    [NotNullAttribute]
public IMetadataAccess PdbMetadataAccess { get; }
    public bool IsEmbedded { get; }
    [CanBeNullAttribute]
public CompactOneToListMap`2<string, string> TypeToFiles { get; }
    [CanBeNullAttribute]
public HashSet`1<string> TypesWithInferredMapping { get; }
    [CanBeNullAttribute]
public SourceLink SourceLink { get; }
    [CanBeNullAttribute]
public String[] Defines { get; }
    public PortablePdbFile(IMetadataAccess portablePdbMetadataAccess, IMetadataAssembly assembly, bool isEmbedded);
    [CompilerGeneratedAttribute]
public IMetadataAccess get_PdbMetadataAccess();
    [CompilerGeneratedAttribute]
public bool get_IsEmbedded();
    public CompactOneToListMap`2<string, string> get_TypeToFiles();
    public HashSet`1<string> get_TypesWithInferredMapping();
    private void CalculateTypeToFiles();
    public SourceLink get_SourceLink();
    public String[] get_Defines();
    public DebugData GetDebugData(FileSystemPath originalPdbFilePath);
    private ImportScope[] GetImportScopes();
    private IDictionary`2<Pair`2<MetadataToken, Guid>, ICustomDebugInformationData> GetCustomDebugInformations();
    private IDictionary`2<MetadataToken, MetadataToken> GetMoveNextToKickoff();
    public int TryGetDocumentIndex(string documentName);
    public IEnumerable`1<DebugDocument> GetDocuments();
    public IReadOnlyList`1<string> GetDocumentNames();
    [NotNullAttribute]
public IReadOnlyList`1<string> GetDocumentNames(MetadataToken methodToken);
    [NotNullAttribute]
internal IDictionary`2<string, PdbDocumentInfo> GetDocumentNameToInfoDictionary();
    [CanBeNullAttribute]
public Byte[] TryGetEmbeddedSource(int documentIndex);
    [CompilerGeneratedAttribute]
private string <GetDocumentNames>b__35_0(int documentIndex);
}
public class JetBrains.Metadata.Debug.Pdb.PortablePdbFileCookie : SafeDisposable {
    [CompilerGeneratedAttribute]
private PortablePdbFile <Pdb>k__BackingField;
    private LifetimeDefinition myDefinition;
    [CanBeNullAttribute]
public PortablePdbFile Pdb { get; }
    private PortablePdbFileCookie(string pdbId, DateTime pdbModificationTimeUtc, Func`1<Stream> getPdbStream, DebugInfoType pdbType, IAssemblyLocation assemblyLocation);
    [CompilerGeneratedAttribute]
public PortablePdbFile get_Pdb();
    public static PortablePdbFileCookie Create(FileSystemPath pdbPath, DebugInfoType pdbType, IAssemblyLocation assemblyLocation);
    public static PortablePdbFileCookie Create(Stream pdbStream, string pdbId, DateTime pdbModificationTimeUtc, DebugInfoType pdbType, IAssemblyLocation assemblyLocation);
    protected virtual void DisposeUnmanagedResources();
}
public enum JetBrains.Metadata.Debug.Pdb.RVA : Enum {
    public UInt32 value__;
    public static RVA Nil;
}
public class JetBrains.Metadata.Debug.Pdb.SrcSrv.SourceLink : object {
    private SortedDictionary`2<string, string> mySortedConversionRules;
    private SourceLinkPatternComparer myPatternComparer;
    private static char Wildcard;
    private static string WildcardString;
    private bool myInvalidRules;
    public static string SourceLinkJsonFileName;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<ValueTuple`2<string, string>> SortedConversionRules { get; }
    public SourceLink(string sourceLinkJson);
    private SourceLink(IDictionary`2<string, string> conversionRules);
    public string GetUri(string filePath);
    [CanBeNullAttribute]
private static string TryGetUnixPath(string filePath);
    [CanBeNullAttribute]
public SourceLocation GetFileLocation(string filePathFromPdb, string cacheItemRelativePath);
    public void WriteTo(UnsafeWriter writer);
    [NotNullAttribute]
public static SourceLink ReadFrom(UnsafeReader reader);
    public void DumpSelf(TextWriter writer, int indent);
    public void DumpToXml(XmlWriter writer);
    [IteratorStateMachineAttribute("JetBrains.Metadata.Debug.Pdb.SrcSrv.SourceLink/<get_SortedConversionRules>d__16")]
public IEnumerable`1<ValueTuple`2<string, string>> get_SortedConversionRules();
}
public class JetBrains.Metadata.Debug.Pdb.SrcSrv.SourceLocation : object {
    [CompilerGeneratedAttribute]
private SourceLocationOrigin <Origin>k__BackingField;
    private Func`2<string, string> myLocalPathGenerator;
    private string myLocalPath;
    private SourceLocationKind myLocationKind;
    private Func`2<string, string> myLocationGenerator;
    [CanBeNullAttribute]
private Func`2<string, string> myPatternGenerator;
    private string myLocation;
    public SourceLocationOrigin Origin { get; }
    public SourceLocationKind LocationKind { get; }
    public SourceLocation(string localPath, SourceLocationKind locationKind, string location, SourceLocationOrigin origin);
    public SourceLocation(Func`2<string, string> localPathGenerator, SourceLocationKind locationKind, Func`2<string, string> locationGenerator, Func`2<string, string> patternGenerator, SourceLocationOrigin origin);
    [CompilerGeneratedAttribute]
public SourceLocationOrigin get_Origin();
    public string GetLocalPath(string cacheDirectory);
    public SourceLocationKind get_LocationKind();
    public string GetLocation(string cacheDirectory);
    [CanBeNullAttribute]
public string GetPattern(string cacheDirectory);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Debug.Pdb.SrcSrv.SourceLocationHelper : object {
    [ExtensionAttribute]
public static FileSystemPath GetLocalPath(SourceLocation sourceLocation, FileSystemPath cacheDirectory);
}
public enum JetBrains.Metadata.Debug.Pdb.SrcSrv.SourceLocationKind : Enum {
    public int value__;
    public static SourceLocationKind PATH;
    public static SourceLocationKind CMD;
    public static SourceLocationKind HTTP;
}
public enum JetBrains.Metadata.Debug.Pdb.SrcSrv.SourceLocationOrigin : Enum {
    public int value__;
    public static SourceLocationOrigin SrcSrv;
    public static SourceLocationOrigin SourceLink;
}
public class JetBrains.Metadata.Debug.Pdb.SrcSrv.SrcSrvInfo : object {
    private static HashSet`1<char> ourInvalidPathChars;
    private String[] myFileComponents;
    private IDictionary`2<string, Int32[]> myFileNameToFileComponentsMapping;
    private IDictionary`2<string, string> myIni;
    private IDictionary`2<string, string> myVariables;
    private IDictionary`2<string, string> myInitialContext;
    public String[] FileComponents { get; }
    public IDictionary`2<string, string> Ini { get; }
    public IDictionary`2<string, string> Variables { get; }
    public SrcSrvInfo(IEnumerable`1<KeyValuePair`2<string, string>> ini, IEnumerable`1<KeyValuePair`2<string, string>> variables, String[] fileComponents);
    private static SrcSrvInfo();
    public String[] get_FileComponents();
    private static IDictionary`2<string, Int32[]> BuildFileNameToFileComponentsMapping(String[] components);
    public IDictionary`2<string, string> get_Ini();
    public IDictionary`2<string, string> get_Variables();
    private static string GetFileNameFunc(string name);
    private static string ParseString(string val, IDictionary`2<string, string> context, string targ, bool isTfHack);
    private static string ProcessEscapes(string val);
    [CanBeNullAttribute]
private static string GetVariableValue(string var, IDictionary`2<string, string> context, string targ, bool isTFHack);
    private static String[] SplitComponents(string components);
    [NotNullAttribute]
private static FileSystemPath GetFileNameFromComponents(string components);
    private Int32[] GetPossibleMappingForFileName(string fileName);
    public bool MayHaveMappingFor(string shortFileName);
    public bool IsOurLocalPath(FileSystemPath localPath, string cacheDirectory);
    [CanBeNullAttribute]
public FileSystemPath TryGetOriginalSourcePath(FileSystemPath sourcePathInCache, FileSystemPath cacheDirectory);
    private static string NormalizeLocalPath(string localPath);
    private static IDictionary`2<string, string> GetEnvironmentContext();
    [CanBeNullAttribute]
public SourceLocation GetFileLocation(FileSystemPath srcPath);
    private static string EscapePath(string srcsrvtrg);
    public void WriteTo(UnsafeWriter writer);
    [NotNullAttribute]
public static SrcSrvInfo ReadFrom(UnsafeReader reader);
    private int GetIndexBySourceName(FileSystemPath srcPath);
    private static IDictionary`2<string, string> ContextCombine(IDictionary`2<string, string> context, IEnumerable`1<KeyValuePair`2<string, string>> secondContext);
    private static IDictionary`2<string, string> CreateContext(IEnumerable`1<KeyValuePair`2<string, string>> contextSource);
    private IDictionary`2<string, string> CreateContextFromSourceName(FileSystemPath srcPath, bool forPattern);
    public void DumpSelf(TextWriter writer, int indent, int maxComponentsToDump);
    public void DumpToXml(XmlWriter writer);
    public int GetByteCount(Encoding encoding);
}
public class JetBrains.Metadata.Debug.Pdb.SrcSrv.SrcSrvInfoParser : object {
    private static void ReadKeyValue(string line, IDictionary`2<string, string> dictionary);
    public static SrcSrvInfo ParsePdbStream(TextReader stream);
}
internal static class JetBrains.Metadata.Debug.Pdb.SymbolWriter.CustomDebugInformationBlobEncoder : object {
    public static BlobBuilder EncodeAsyncMethodSteppingInformation(AsyncMethodSteppingInformationData asyncMethodSteppingInformation);
    public static BlobBuilder EncodeStateMachineHoistedLocalScopes(StateMachineHoistedLocalScopesData methodStateMachineHoistedLocalScopes);
    public static BlobBuilder EncodeTupleElementNames(TupleElementNamesData tupleElementNames);
}
internal class JetBrains.Metadata.Debug.Pdb.SymbolWriter.MethodCustomDebugInformationEncoder : object {
    private BlobBuilder myBlobBuilder;
    private Blob myRecordCountBlob;
    private int myRecordCount;
    public MethodCustomDebugInformationEncoder(BlobBuilder blobBuilder);
    public void AddStateMachineTypeName(string stateMachineTypeName);
    public void AddStateMachineHoistedLocalScopes(StateMachineHoistedLocalScopesData stateMachineHoistedLocalScopes);
    public void AddTupleElementNames(PdbTupleInfo[] tupleElementNames);
    [CanBeNullAttribute]
public Byte[] ToArray();
    private void SerializeCustomDebugInformation(CustomDebugInfoKind kind, Action`1<BlobBuilder> serialize);
}
public class JetBrains.Metadata.Debug.Pdb.SymbolWriter.PortablePdbModifier : object {
    public static bool AddSourceLink(FileSystemPath originalPdb, FileSystemPath sourceLinkJson, FileSystemPath modifiedPdb);
    private static bool Modify(FileSystemPath originalPdb, FileSystemPath modifiedPdb, Action`1<MetadataBuilder> modify);
    private static void CopyBlobs(IMetadataStreamsAccess pdb, MetadataBuilder tablesAndHeaps);
    private static void CopyTables(IMetadataStreamsAccess pdb, MetadataBuilder tablesAndHeaps);
    private static void AddSourceLink(MetadataBuilder tablesAndHeaps, FileSystemPath sourceLinkJson);
    [CompilerGeneratedAttribute]
internal static BlobHandle <CopyTables>g__ReadBlob|3_8(ITableReader row);
}
public class JetBrains.Metadata.Debug.Pdb.SymbolWriter.PortablePdbWriter : object {
    private DebugData myDebugData;
    private ILReaderMetadataAccess myAssembly;
    private MetadataBuilder myTablesAndHeaps;
    private MethodDefinitionHandle myEntryPoint;
    private Dictionary`2<int, DocumentHandle> myDocuments;
    private Dictionary`2<ImportScope, ImportScopeHandle> myImportScopes;
    private LocalVariableHandle myLastLocalVariableHandle;
    private LocalConstantHandle myLastLocalConstantHandle;
    private PortablePdbWriter(DebugData debugData, ILReaderMetadataAccess assembly);
    private void BuildPortablePdbTablesAndHeaps();
    private void AddMethodCustomDebugInformation(DebugMethod method);
    private void BuildDocumentTable();
    private void AddDefaultMethodDebugInformation();
    private void AddMethodDebugInformation(DebugMethod method);
    private void AddLocalScopes(MethodDefinitionHandle methodHandle, LocalScope scope);
    private void AddLocalVariable(DebugLocalVariable localVariable);
    private LocalVariableHandle NextLocalVariableHandle();
    private LocalConstantHandle NextLocalConstantHandle();
    private void DefineModuleImportScope();
    private ImportScopeHandle GetImportScopeHandle(ImportScope importScope);
    private BlobHandle SerializeImportsBlob(ImportScope importScope);
    private void SerializeImport(BlobBuilder writer, Import import);
    private void WriteContentTo(Stream pdbStream, Guid signature, UInt32 timestamp);
    public static void Write(DebugData debugData, FileSystemPath pdbPath, IAssemblyLocation assemblyLocation);
    public static void Write(DebugData debugData, FileSystemPath pdbPath, IAssemblyLocation assemblyLocation, Guid signature, UInt32 timestamp);
}
internal class JetBrains.Metadata.Debug.Pdb.SymbolWriter.UnmanagedSymbolWriterOwner : object {
    [CompilerGeneratedAttribute]
private ISymUnmanagedWriter <Writer>k__BackingField;
    public ISymUnmanagedWriter Writer { get; private set; }
    public UnmanagedSymbolWriterOwner(FileSystemPath pdbPath, FileSystemPath assemblyPath);
    [CompilerGeneratedAttribute]
public ISymUnmanagedWriter get_Writer();
    [CompilerGeneratedAttribute]
private void set_Writer(ISymUnmanagedWriter value);
    [CanBeNullAttribute]
private static IMetaDataEmit CreateEmitter(FileSystemPath assemblyPath);
    private static bool IsWinMd(FileSystemPath assemblyPath);
    public sealed virtual void Dispose();
}
public static class JetBrains.Metadata.Debug.Pdb.SymbolWriter.WindowsPdbWriter : object {
    public static void Write(DebugData debugData, FileSystemPath pdbPath, FileSystemPath assemblyPath);
    public static void Write(DebugData debugData, FileSystemPath pdbPath, FileSystemPath assemblyPath, Guid signature, UInt32 age);
    private static void UnguardedWrite(DebugData debugData, FileSystemPath pdbPath, FileSystemPath assemblyPath, Guid signature, UInt32 age);
    public static void PatchPdb(FileSystemPath pdbPath, Guid newSignature, UInt32 newAge);
    private static ISymUnmanagedDocumentWriter WriteSourceFile(DebugDocument sourceFile, ISymUnmanagedWriter writer);
    private static void WriteMethod(DebugMethod method, ISymUnmanagedWriter writer, Dictionary`2<int, ISymUnmanagedDocumentWriter> documentIndexToDocumentWriter);
    private static void OpenMethod(DebugMethod method, ISymUnmanagedWriter writer);
    private static void CloseMethod(DebugMethod method, ISymUnmanagedWriter writer);
    private static void WriteImports(ImportScope methodImportScope, ISymUnmanagedWriter writer);
    private static void WriteSequencePoints(DebugMethod method, ISymUnmanagedWriter writer, Dictionary`2<int, ISymUnmanagedDocumentWriter> documentIndexToDocumentWriter);
    private static void WriteMethodCustomDebugInformation(DebugMethod method, ISymUnmanagedWriter writer);
    private static void WriteCustomMetadata(Byte[] customMetadata, MetadataToken parent, ISymUnmanagedWriter writer);
    private static void WriteScope(LocalScope scope, ISymUnmanagedWriter writer);
    private static void WriteLocalVariable(DebugLocalVariable localVariable, ISymUnmanagedWriter writer);
}
internal static class JetBrains.Metadata.Debug.Pdb.WindowsPdbCustomDebugInfo : object {
    public static byte Version;
    public static void WriteStateMachineTypeName(BlobBuilder writer, string stateMachineTypeName);
    [NotNullAttribute]
public static string ReadStateMachineTypeName(IBinaryReader reader);
    public static void WriteStateMachineHoistedLocalScopes(BlobBuilder writer, StateMachineHoistedLocalScopesData stateMachineHoistedLocalScopes);
    [NotNullAttribute]
public static StateMachineHoistedLocalScopesData ReadStateMachineHoistedLocalScopes(IBinaryReader reader);
    public static void WriteKickoffMethod(ISymUnmanagedAsyncMethodPropertiesWriter writer, MetadataToken kickoffMethod);
    public static MetadataToken ReadKickoffMethod(IBinaryReader reader);
    public static void WriteAsyncMethodSteppingInformation(ISymUnmanagedAsyncMethodPropertiesWriter writer, AsyncMethodSteppingInformationData asyncMethodSteppingInformation);
    [NotNullAttribute]
public static AsyncMethodSteppingInformationData ReadAsyncMethodSteppingInformation(IBinaryReader reader);
    public static UInt16[] ReadUsingGroups(IBinaryReader reader);
    public static MetadataToken ReadForwardMethodInfo(IBinaryReader reader);
    public static PdbTupleInfo[] ReadTupleElementNames(IBinaryReader reader);
    public static void WriteTupleElementNames(BlobBuilder writer, PdbTupleInfo[] tupleElementNames);
    private static PdbTupleInfo ReadTupleInfo(IBinaryReader reader);
    private static void WriteTupleInfo(BlobBuilder writer, PdbTupleInfo tupleInfo);
    private static void WriteZeroTerminatedUtf8String(BlobBuilder writer, string s);
    public static void WriteString(BlobBuilder writer, string s);
    [NotNullAttribute]
public static string ReadString(IBinaryReader reader);
    private static MetadataToken ReadToken(IBinaryReader reader);
}
public class JetBrains.Metadata.Debug.Pdb.WindowsPdbFile : object {
    private static string SrcsrvStreamName;
    private static string NamesStreamName;
    private static string SrcFilesStreamPrefix;
    private static string SrcFilesStreamName;
    private static string SourcelinkStreamName;
    private static string SourcelinkStreams;
    private static int ourSrcFilesStreamPrefixLength;
    private PdbHeader myHeader;
    private Stream myPdbStream;
    private PdbToc myTableOfContents;
    private ReadOnlyDictionary`2<string, int> myNameIndex;
    private ReadOnlyDictionary`2<int, string> myNameStream;
    private SourceFileInfo mySourceFileInfo;
    private bool mySourceFileInfoLoadStatements;
    private bool mySourceFileInfoLoadNative;
    private DebugData myCachedDebugData;
    private PdbParseLevel myCachedDebugDataParseLevel;
    private FileSystemPath myCachedDebugDataPath;
    private List`1<string> myCachedDocuments;
    private DbiStreamInfo myDbi;
    private SectionHeader[] myDbiSectionHeaders;
    private static ILogger ourLog;
    private ReadOnlyCollection`1<DbiSectionContribution> mySectionContributions;
    public PdbHeader Header { get; }
    [ObsoleteAttribute("Use IPdbStreamBuilder member for get pdb stream")]
[NotNullAttribute]
public ReadOnlyDictionary`2<string, int> NameIndex { get; }
    [ObsoleteAttribute("Use IPdbStreamBuilder member for get pdb stream")]
[NotNullAttribute]
public ReadOnlyDictionary`2<int, string> NameStream { get; }
    [NotNullAttribute]
public DbiStreamInfo Dbi { get; }
    private ReadOnlyCollection`1<DbiSectionContribution> SortedSectionContribs { get; }
    private SectionHeader[] DbiSectionHeaders { get; }
    public WindowsPdbFile(Stream pdbStream);
    private static WindowsPdbFile();
    public PdbHeader get_Header();
    public ReadOnlyDictionary`2<string, int> get_NameIndex();
    public ReadOnlyDictionary`2<int, string> get_NameStream();
    [NotNullAttribute]
private ReadOnlyDictionary`2<string, int> GetNameIndexDictionary();
    private void ReadStreamNames(ChunkHashMap`2<string, int> streamNameToIndex, List`1<string> sourceFiles);
    [NotNullAttribute]
private ReadOnlyDictionary`2<int, string> GetNamesStreamDictionary();
    [NotNullAttribute]
internal static string NormalizePath(string path);
    [CanBeNullAttribute]
private Stream GetNamedPdbStream(string streamName);
    public sealed virtual Stream GetSrcSrvStream();
    public sealed virtual Stream GetNamesStream();
    public sealed virtual Stream GetSrcFileStream(string name);
    [IteratorStateMachineAttribute("JetBrains.Metadata.Debug.Pdb.WindowsPdbFile/<GetSourcelinkStreams>d__37")]
[NotNullAttribute]
private IEnumerable`1<Stream> GetSourcelinkStreams();
    public sealed virtual Stream GetDbiStream();
    public sealed virtual string GetStreamName(int name);
    public DbiStreamInfo get_Dbi();
    private ReadOnlyCollection`1<DbiSectionContribution> get_SortedSectionContribs();
    private SectionHeader[] get_DbiSectionHeaders();
    [NotNullAttribute]
public PdbRootRecord GetRoot();
    [NotNullAttribute]
public Stream GetRootStream();
    [NotNullAttribute]
private Stream GetIndexPdbStream(int streamIndex);
    [CanBeNullAttribute]
public DebugData GetDebugData(PdbParseLevel level, FileSystemPath originalPdbFilePath);
    internal static ValueTuple`5<Guid, Guid, Guid, Guid, Byte[]> GetDocumentInfo(IPdbStreamBuilder pdb, string document);
    public IReadOnlyList`1<string> GetDocumentNames();
    [CanBeNullAttribute]
public SrcSrvInfo GetSrcSrvInfo();
    [CanBeNullAttribute]
public SourceLink GetSourceLink();
    [NotNullAttribute]
public SourceFileInfo GetSourceFileInfo(bool loadStatements, bool loadNative, CompactOneToListMap`2<PdbFunction, DebugDocument> functionToDocuments, CompactOneToListMap`2<NativePdbFunction, DebugDocument> nativeFunctionToDocuments);
    private void LoadFunctionsFromDbiModule(ICollection`1<PdbFunction> functionsCollector, ICollection`1<NativePdbFunction> nativeFunctionsCollector, CompactOneToListMap`2<PdbFunction, DebugDocument> functionToDocuments, CompactOneToListMap`2<NativePdbFunction, DebugDocument> nativeFunctionToDocuments, int moduleIndex, DbiModuleInfo module, bool loadStatements, bool loadNative);
    public IDictionary`2<string, PdbDocumentInfo> GetDocumentNameToInfoDictionary();
    private List`1<string> GetDocuments();
    private static void SkipDebugSubsection(StreamBinaryReader moduleStream, int initialPosition, int endPosition);
    private static ValueTuple`2<List`1<PdbFunction>, List`1<NativePdbFunction>> LoadFunctions(IBinaryReader moduleStream, int moduleIndex, int initialPosition, int endPosition, NativeFunctionProcessor nativeFunctionProcessor);
    [NotNullAttribute]
private static ReadOnlyDictionary`2<int, DebugDocument> LoadDocumentInfos(StreamBinaryReader moduleStream, int startManagedLines, int endManagedLines, IPdbStreamBuilder pdbStreamBuilder);
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Debug.SequencePoint : ValueType {
    [CompilerGeneratedAttribute]
private int <IlOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHidden>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DocumentIndex>k__BackingField;
    public int IlOffset { get; }
    public int StartLine { get; }
    public int StartColumn { get; }
    public int EndLine { get; }
    public int EndColumn { get; }
    public bool IsHidden { get; }
    public int DocumentIndex { get; }
    public SequencePoint(int documentIndex, int ilOffset, int startLine, int startColumn, int endLine, int endColumn);
    [CompilerGeneratedAttribute]
public int get_IlOffset();
    [CompilerGeneratedAttribute]
public int get_StartLine();
    [CompilerGeneratedAttribute]
public int get_StartColumn();
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    [CompilerGeneratedAttribute]
public bool get_IsHidden();
    [CompilerGeneratedAttribute]
public int get_DocumentIndex();
    public static SequencePoint CreateHiddenSequencePoint(int documentIndex, int ilOffset);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class JetBrains.Metadata.Debug.SequencePointInMethod : ValueType {
    [CompilerGeneratedAttribute]
private SequencePoint <SequencePoint>k__BackingField;
    [CompilerGeneratedAttribute]
private DebugMethod <Method>k__BackingField;
    public SequencePoint SequencePoint { get; }
    [NotNullAttribute]
public DebugMethod Method { get; }
    public SequencePointInMethod(SequencePoint& sequencePoint, DebugMethod method);
    [CompilerGeneratedAttribute]
public SequencePoint get_SequencePoint();
    [CompilerGeneratedAttribute]
public DebugMethod get_Method();
}
public interface JetBrains.Metadata.Debug.SequencePoints.ISequencePointInstructionRedirector {
    public abstract virtual int ToSequencePointInstructionIndex(int instructionIndex);
}
public class JetBrains.Metadata.Debug.SequencePoints.SequencePointInstructionRedirector : object {
    [CompilerGeneratedAttribute]
private IMetadataMethod <Method>k__BackingField;
    private Dictionary`2<int, Instruction> myOffsetToSequencePointInstruction;
    private Int32[] myIndexToSpIndex;
    [NotNullAttribute]
public IMetadataMethod Method { get; }
    public SequencePointInstructionRedirector(Instruction[] instructions, IMetadataMethod method, bool ignoreDup);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataMethod get_Method();
    public sealed virtual Instruction Redirect(Instruction instruction);
    public sealed virtual int ToSequencePointInstructionIndex(int instructionIndex);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Debug.SequencePoints.SequencePointUtils : object {
    [ExtensionAttribute]
private static bool CheckBranchTarget(Instruction[] instructions, int instructionIndex, ICollection`1<int> regularSpOffsets);
    [IteratorStateMachineAttribute("JetBrains.Metadata.Debug.SequencePoints.SequencePointUtils/<GetHiddenSequencePointsOffsets>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<int> GetHiddenSequencePointsOffsets(Instruction[] instructions, ICollection`1<int> regularSpOffsets, ISequencePointInstructionRedirector sequencePointInstructionRedirector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Metadata.Debug.TypeMemberRange : object {
    [CompilerGeneratedAttribute]
private MetadataToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <ParentToken>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public MetadataToken Token { get; public set; }
    public MetadataToken ParentToken { get; public set; }
    public int StartLine { get; public set; }
    public int StartColumn { get; public set; }
    public int EndLine { get; public set; }
    public int EndColumn { get; public set; }
    public TypeMemberRange(MetadataToken Token, MetadataToken ParentToken, int StartLine, int StartColumn, int EndLine, int EndColumn);
    [CompilerGeneratedAttribute]
protected TypeMemberRange(TypeMemberRange original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public MetadataToken get_Token();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Token(MetadataToken value);
    [CompilerGeneratedAttribute]
public MetadataToken get_ParentToken();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ParentToken(MetadataToken value);
    [CompilerGeneratedAttribute]
public int get_StartLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StartLine(int value);
    [CompilerGeneratedAttribute]
public int get_StartColumn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StartColumn(int value);
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EndLine(int value);
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EndColumn(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(TypeMemberRange left, TypeMemberRange right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(TypeMemberRange left, TypeMemberRange right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(TypeMemberRange other);
    [CompilerGeneratedAttribute]
public virtual TypeMemberRange <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(MetadataToken& Token, MetadataToken& ParentToken, Int32& StartLine, Int32& StartColumn, Int32& EndLine, Int32& EndColumn);
}
internal class JetBrains.Metadata.EditAndContinue.AggregatedMetadataAccess : MetadataAccessBase {
    [NotNullAttribute]
private IEncMetadataAccess myBaseline;
    [NotNullAttribute]
private AggregatedStreamsAccess myStreams;
    [CanBeNullAttribute]
private OneToListMap`2<MetadataToken, MetadataToken> myOwnerToGenericParameters;
    [CanBeNullAttribute]
private OneToListMap`2<MetadataToken, MetadataToken> myOwnerToCustomAttributes;
    [CanBeNullAttribute]
private OneToListMap`2<MetadataToken, MetadataToken> myOwnerToDeclSecurityAttributes;
    [CanBeNullAttribute]
private Dictionary`2<MetadataToken, MetadataTokenRange> myTypeToInterfaceImplementations;
    [CanBeNullAttribute]
private Dictionary`2<MetadataToken, MetadataTokenRange> myGenericParameterToConstraints;
    [CompilerGeneratedAttribute]
private AssemblyId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <EncId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <EncBaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Generation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetPlatform <TargetPlatform>k__BackingField;
    [CompilerGeneratedAttribute]
private EncLogAnalyzer <EncLog>k__BackingField;
    public AssemblyId Id { get; }
    public Guid EncId { get; }
    public Guid EncBaseId { get; }
    public int Generation { get; }
    public string ModuleName { get; }
    public TargetPlatform TargetPlatform { get; }
    public EncLogAnalyzer EncLog { get; }
    internal IMetadataStreamsAccess Streams { get; }
    public AggregatedMetadataAccess(IEncMetadataAccess baseline, IMetadataStreamsAccess delta);
    [CompilerGeneratedAttribute]
public virtual AssemblyId get_Id();
    [CompilerGeneratedAttribute]
public virtual Guid get_EncId();
    [CompilerGeneratedAttribute]
public virtual Guid get_EncBaseId();
    private sealed virtual override int JetBrains.Metadata.EditAndContinue.IAggregatedStreamsAccess.GetInitialTableSize(MetadataTableId tableId);
    private sealed virtual override int JetBrains.Metadata.EditAndContinue.IAggregatedStreamsAccess.GetTableSize(MetadataTableId tableId, int generation);
    private sealed virtual override int JetBrains.Metadata.EditAndContinue.IAggregatedStreamsAccess.GetLastModificationGeneration(MetadataToken token);
    private sealed virtual override int JetBrains.Metadata.EditAndContinue.IAggregatedStreamsAccess.GetGuidGeneration(int index);
    private sealed virtual override int JetBrains.Metadata.EditAndContinue.IAggregatedStreamsAccess.GetStringGeneration(int offset);
    private sealed virtual override int JetBrains.Metadata.EditAndContinue.IAggregatedStreamsAccess.GetUserStringGeneration(MetadataToken pointer);
    private sealed virtual override int JetBrains.Metadata.EditAndContinue.IAggregatedStreamsAccess.GetBlobGeneration(int offset);
    [CompilerGeneratedAttribute]
public virtual int get_Generation();
    [CompilerGeneratedAttribute]
public virtual string get_ModuleName();
    [CompilerGeneratedAttribute]
public virtual TargetPlatform get_TargetPlatform();
    [CompilerGeneratedAttribute]
public virtual EncLogAnalyzer get_EncLog();
    public virtual long GetEmbeddedResourceOffset(long resourceOffset);
    internal virtual IMetadataStreamsAccess get_Streams();
    public virtual ITableReader GetInitialTableRow(MetadataToken token);
    protected virtual int GetInitialTableSize(MetadataTableId tableId);
    protected virtual int GetTableSize(MetadataTableId tableId, int generation);
    public virtual IList`1<MetadataToken> GetGenericParametersEnc(MetadataToken ownerToken);
    public virtual GenericParameterConstraintProperties GetGenericParameterConstraintProperties(MetadataToken gpcToken);
    protected virtual MetadataTokenRange GetGenericParameterConstraints(MetadataToken genericParamToken);
    protected virtual IEnumerable`1<MetadataToken> GetFieldsEnumerable(MetadataToken typeToken);
    public virtual IList`1<MetadataToken> GetFieldsEnc(MetadataToken typeToken);
    public virtual IList`1<MetadataToken> GetMethodsEnc(MetadataToken typeToken);
    public virtual IList`1<MetadataToken> GetPropertiesEnc(MetadataToken typeOrPropertyMapToken);
    public virtual IList`1<MetadataToken> GetEventsEnc(MetadataToken typeOrEventMapToken);
    public virtual IList`1<MetadataToken> GetCustomAttributesEnc(MetadataToken ownerToken);
    public virtual IList`1<MetadataToken> GetDeclSecurityEnc(MetadataToken ownerToken);
    public virtual IMetadataAccess GetInitialMetadataAccess();
    public virtual MetadataTokenRange GetInterfaceImplementations(MetadataToken typeToken);
    public virtual MetadataTokenRange GetParameters(MetadataToken methodToken);
    protected virtual MetadataTokenRange FindTokensClusterInTable(MetadataToken aroundToken, MetadataTokenType tokenType, int skipBytes, MetadataTokenType[] skipTokenTypes);
    private IList`1<MetadataToken> FindTokensClusterInTableEnc(MetadataToken aroundToken, MetadataTokenType tokenType, int skipBytes, MetadataTokenType[] skipTokenTypes);
    private MetadataToken[] ReadTokensFromTableEnc(IList`1<MetadataToken> ownerRows, MetadataTokenType entityTokenType, MetadataTokenType[] skipTokenTypes);
    protected virtual MetadataTokenRange ReadTokenInterval(MetadataToken owner, MetadataTableId tokenType, int skipBytes, int skipStrings, int skipBlobs, MetadataTokenType[] skipTokenTypes);
    protected virtual MetadataToken SearchInTable(MetadataTableId table, MetadataToken targetToken, MetadataTokenType targetStorageFormat, int skipBytes, MetadataTokenType[] skipTokenTypes);
    private MetadataTokenRange GetTableRangeExcludeInitial(MetadataTableId tableId);
    private bool IsInitialToken(MetadataToken token);
    private protected virtual Dictionary`2<MetadataToken, MetadataToken[]> GetMethodBodyToDeclarations(MetadataToken typeToken, MetadataToken methodImplToken);
    private protected virtual MethodSemanticsProperties[] GetSemanticsProperties(MetadataToken methodSemanticsToken);
    protected virtual MetadataToken GetMethodDefDeclaringType(MetadataToken methodToken);
    protected virtual MetadataToken GetFieldOwner(MetadataToken fieldToken);
    protected virtual MetadataToken GetParameterOwner(MetadataToken parameterToken);
    protected virtual MetadataToken GetPropertyDeclaringType(MetadataToken propertyToken);
    protected virtual MetadataToken GetEventDeclaringType(MetadataToken eventToken);
}
internal class JetBrains.Metadata.EditAndContinue.AggregatedStreamsAccess : object {
    private IMetadataStreamsAccess myBaseline;
    private IMetadataStreamsAccess myDelta;
    private int myBaselineGuidMaxIndex;
    private int myBaselineStringHeapSize;
    private int myBaselineUserStringHeapSize;
    private int myBaselineBlobHeapSize;
    private Int32[] myTableSizes;
    private Int32[] myBaselineTableSizes;
    private Int32[] myInitialTableSizes;
    [NotNullAttribute]
private Dictionary`2<MetadataToken, MetadataToken> myTokenRedirects;
    [CompilerGeneratedAttribute]
private int <Generation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GuidMaxIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StringHeapSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UserStringHeapSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BlobHeapSize>k__BackingField;
    [CompilerGeneratedAttribute]
private PdbStream <PdbStream>k__BackingField;
    public int Generation { get; }
    public int GuidMaxIndex { get; }
    public int StringHeapSize { get; }
    public int UserStringHeapSize { get; }
    public int BlobHeapSize { get; }
    public PdbStream PdbStream { get; }
    public AggregatedStreamsAccess(IMetadataStreamsAccess baseline, IMetadataStreamsAccess delta, int generation);
    private void CalculateTableSizesAndTokenRedirects();
    public sealed virtual Guid GetGuid(int index);
    public sealed virtual int GetGuidGeneration(int index);
    public sealed virtual string GetString(int offset);
    public sealed virtual int GetStringGeneration(int offset);
    public sealed virtual string GetUserString(MetadataToken pointer);
    public sealed virtual int GetUserStringGeneration(MetadataToken pointer);
    public sealed virtual IBlob GetBlob(int offset);
    public sealed virtual int GetBlobGeneration(int offset);
    public sealed virtual string GetUtf8String(int blobOffset);
    public sealed virtual Guid[] GetAllGuids();
    [IteratorStateMachineAttribute("JetBrains.Metadata.EditAndContinue.AggregatedStreamsAccess/<GetAllUserStringsWithOffsets>d__22")]
public sealed virtual IEnumerable`1<Pair`2<string, int>> GetAllUserStringsWithOffsets();
    [IteratorStateMachineAttribute("JetBrains.Metadata.EditAndContinue.AggregatedStreamsAccess/<GetAllStringsWithOffsets>d__23")]
public sealed virtual IEnumerable`1<Pair`2<string, int>> GetAllStringsWithOffsets();
    [IteratorStateMachineAttribute("JetBrains.Metadata.EditAndContinue.AggregatedStreamsAccess/<GetAllStrings>d__24")]
public sealed virtual IEnumerable`1<string> GetAllStrings();
    public sealed virtual bool UserStringEqualToAsciiString(int offset, Byte[] utf8Bytes);
    public sealed virtual bool UserStringStartsWithAsciiString(int offset, Byte[] utf8Prefix);
    public sealed virtual IBinaryReader GetBlobHeapReader();
    [IteratorStateMachineAttribute("JetBrains.Metadata.EditAndContinue.AggregatedStreamsAccess/<GetAllBlobOffsets>d__28")]
public sealed virtual IEnumerable`1<int> GetAllBlobOffsets();
    public sealed virtual ITableReader GetTableRow(MetadataToken token);
    public sealed virtual ITableReader GetInitialTableRow(MetadataToken token);
    public sealed virtual ITableReader GetTableRow(MetadataTableId table, int rid);
    public sealed virtual int GetTableSize(MetadataTableId tableId);
    public sealed virtual int GetInitialTableSize(MetadataTableId tableId);
    public sealed virtual int GetTableSize(MetadataTableId tableId, int generation);
    public sealed virtual int GetLastModificationGeneration(MetadataToken token);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Generation();
    [CompilerGeneratedAttribute]
public sealed virtual int get_GuidMaxIndex();
    [CompilerGeneratedAttribute]
public sealed virtual int get_StringHeapSize();
    [CompilerGeneratedAttribute]
public sealed virtual int get_UserStringHeapSize();
    [CompilerGeneratedAttribute]
public sealed virtual int get_BlobHeapSize();
    [CompilerGeneratedAttribute]
public sealed virtual PdbStream get_PdbStream();
    [IteratorStateMachineAttribute("JetBrains.Metadata.EditAndContinue.AggregatedStreamsAccess/<JetBrains-Metadata-Access-ILowLevelMetadataStreamsAccess-GetStringHeapBytes>d__54")]
private sealed virtual override IEnumerable`1<byte> JetBrains.Metadata.Access.ILowLevelMetadataStreamsAccess.GetStringHeapBytes();
    [IteratorStateMachineAttribute("JetBrains.Metadata.EditAndContinue.AggregatedStreamsAccess/<JetBrains-Metadata-Access-ILowLevelMetadataStreamsAccess-GetUserStringHeapBytes>d__55")]
private sealed virtual override IEnumerable`1<byte> JetBrains.Metadata.Access.ILowLevelMetadataStreamsAccess.GetUserStringHeapBytes();
    [IteratorStateMachineAttribute("JetBrains.Metadata.EditAndContinue.AggregatedStreamsAccess/<JetBrains-Metadata-Access-ILowLevelMetadataStreamsAccess-GetGuidHeapBytes>d__56")]
private sealed virtual override IEnumerable`1<byte> JetBrains.Metadata.Access.ILowLevelMetadataStreamsAccess.GetGuidHeapBytes();
    [IteratorStateMachineAttribute("JetBrains.Metadata.EditAndContinue.AggregatedStreamsAccess/<JetBrains-Metadata-Access-ILowLevelMetadataStreamsAccess-GetBlobHeapBytes>d__57")]
private sealed virtual override IEnumerable`1<byte> JetBrains.Metadata.Access.ILowLevelMetadataStreamsAccess.GetBlobHeapBytes();
    [CompilerGeneratedAttribute]
private void <CalculateTableSizesAndTokenRedirects>g__ExpandTable|11_0(MetadataTableId tableId);
}
public class JetBrains.Metadata.EditAndContinue.EncLogAnalyzer : object {
    [CompilerGeneratedAttribute]
private OneToListMap`2<MetadataToken, MetadataToken> <TypeToMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private OneToListMap`2<MetadataToken, MetadataToken> <TypeToFields>k__BackingField;
    [CompilerGeneratedAttribute]
private OneToListMap`2<MetadataToken, MetadataToken> <TypeToProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private OneToListMap`2<MetadataToken, MetadataToken> <TypeToEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private OneToListMap`2<MetadataToken, MetadataToken> <MethodToParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<MetadataToken, MetadataToken> <ChildToParent>k__BackingField;
    [CompilerGeneratedAttribute]
private OneToListMap`2<MetadataToken, MetadataToken> <PropertyMapToProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private OneToListMap`2<MetadataToken, MetadataToken> <EventMapToEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private static EncLogAnalyzer <Empty>k__BackingField;
    [NotNullAttribute]
public OneToListMap`2<MetadataToken, MetadataToken> TypeToMethods { get; }
    [NotNullAttribute]
public OneToListMap`2<MetadataToken, MetadataToken> TypeToFields { get; }
    [NotNullAttribute]
public OneToListMap`2<MetadataToken, MetadataToken> TypeToProperties { get; }
    [NotNullAttribute]
public OneToListMap`2<MetadataToken, MetadataToken> TypeToEvents { get; }
    [NotNullAttribute]
public OneToListMap`2<MetadataToken, MetadataToken> MethodToParameters { get; }
    [NotNullAttribute]
public Dictionary`2<MetadataToken, MetadataToken> ChildToParent { get; }
    [NotNullAttribute]
public OneToListMap`2<MetadataToken, MetadataToken> PropertyMapToProperties { get; }
    [NotNullAttribute]
public OneToListMap`2<MetadataToken, MetadataToken> EventMapToEvents { get; }
    public static EncLogAnalyzer Empty { get; }
    public EncLogAnalyzer(IMetadataStreamsAccess streams);
    private static EncLogAnalyzer();
    [CompilerGeneratedAttribute]
public OneToListMap`2<MetadataToken, MetadataToken> get_TypeToMethods();
    [CompilerGeneratedAttribute]
public OneToListMap`2<MetadataToken, MetadataToken> get_TypeToFields();
    [CompilerGeneratedAttribute]
public OneToListMap`2<MetadataToken, MetadataToken> get_TypeToProperties();
    [CompilerGeneratedAttribute]
public OneToListMap`2<MetadataToken, MetadataToken> get_TypeToEvents();
    [CompilerGeneratedAttribute]
public OneToListMap`2<MetadataToken, MetadataToken> get_MethodToParameters();
    [CompilerGeneratedAttribute]
public Dictionary`2<MetadataToken, MetadataToken> get_ChildToParent();
    [CompilerGeneratedAttribute]
public OneToListMap`2<MetadataToken, MetadataToken> get_PropertyMapToProperties();
    [CompilerGeneratedAttribute]
public OneToListMap`2<MetadataToken, MetadataToken> get_EventMapToEvents();
    [CompilerGeneratedAttribute]
public static EncLogAnalyzer get_Empty();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.EditAndContinue.EncMetadataAccessEx : object {
    [ExtensionAttribute]
public static bool IsEnC(IMetadataAccess metadataAccess);
    [ExtensionAttribute]
public static bool IsEnC(IMetadataAssembly metadataAssembly);
    [ExtensionAttribute]
[NotNullAttribute]
internal static IMetadataMethod[] GetMethods(IMetadataAssembly metadataAssembly, MetadataToken typeToken);
    [ExtensionAttribute]
[NotNullAttribute]
internal static IMetadataField[] GetFields(IMetadataAssembly metadataAssembly, MetadataToken typeToken);
    [ExtensionAttribute]
[NotNullAttribute]
internal static IMetadataProperty[] GetProperties(IMetadataAssembly metadataAssembly, MetadataToken typeToken);
    [ExtensionAttribute]
[NotNullAttribute]
internal static IMetadataEvent[] GetEvents(IMetadataAssembly metadataAssembly, MetadataToken typeToken);
    [IteratorStateMachineAttribute("JetBrains.Metadata.EditAndContinue.EncMetadataAccessEx/<GetMemberInfos>d__6")]
[ExtensionAttribute]
internal static IEnumerable`1<MemberInfo> GetMemberInfos(IMetadataAccess metadataAccess, MetadataToken typeToken);
    [ExtensionAttribute]
[NotNullAttribute]
internal static IMetadataTypeParameter[] GetTypeParameters(IMetadataAssembly metadataAssembly, MetadataToken ownerToken);
    [ExtensionAttribute]
[NotNullAttribute]
internal static IMetadataSecurityRow[] GetSecurityAttributes(IMetadataAssembly metadataAssembly, MetadataToken ownerToken);
    [ExtensionAttribute]
[NotNullAttribute]
internal static String[] GetSecurityAttributesTypeNames(IMetadataAccess metadataAccess, MetadataToken ownerToken);
    private static void AddDeclSecurityTypeNames(List`1<string> names, MetadataToken declSecurityToken, IMetadataAccess metadataAccess);
    [ExtensionAttribute]
[NotNullAttribute]
public static IMetadataCustomAttribute[] GetCustomAttributes(IMetadataAssembly metadataAssembly, MetadataToken ownerToken);
    [ExtensionAttribute]
[NotNullAttribute]
internal static MetadataTypeReference[] GetCustomAttributesTypeNames(IMetadataAssembly metadataAssembly, MetadataToken ownerToken);
    [ExtensionAttribute]
internal static bool HasMethodWithExtensionAttribute(IMetadataAccess metadataAccess, MetadataToken typeToken);
    [ExtensionAttribute]
internal static bool IsInitialToken(IAggregatedStreamsAccess streams, MetadataToken token);
    [ExtensionAttribute]
internal static void GetGenericParamConstraintsRow(IAggregatedStreamsAccess streams, MetadataToken gpcToken, bool raw, UInt32& genericParam, UInt32& constraint);
    [ExtensionAttribute]
internal static EncLogProperties GetEncLogProperties(IMetadataStreamsAccess streams, MetadataToken encLogToken);
    [ExtensionAttribute]
internal static MetadataTokenRange GetEncLogs(IMetadataStreamsAccess streams);
}
public interface JetBrains.Metadata.EditAndContinue.IAggregatedStreamsAccess {
    public int Generation { get; }
    public abstract virtual int GetInitialTableSize(MetadataTableId tableId);
    public abstract virtual ITableReader GetInitialTableRow(MetadataToken token);
    public abstract virtual int GetTableSize(MetadataTableId tableId, int generation);
    public abstract virtual int get_Generation();
    public abstract virtual int GetLastModificationGeneration(MetadataToken token);
    public abstract virtual int GetGuidGeneration(int index);
    public abstract virtual int GetStringGeneration(int offset);
    public abstract virtual int GetUserStringGeneration(MetadataToken pointer);
    public abstract virtual int GetBlobGeneration(int offset);
}
public interface JetBrains.Metadata.EditAndContinue.IEncMetadataAccess {
    public Guid EncId { get; }
    public Guid EncBaseId { get; }
    public int Generation { get; }
    [NotNullAttribute]
public EncLogAnalyzer EncLog { get; }
    public abstract virtual Guid get_EncId();
    public abstract virtual Guid get_EncBaseId();
    public abstract virtual int get_Generation();
    public abstract virtual EncLogAnalyzer get_EncLog();
    public abstract virtual IList`1<MetadataToken> GetGenericParametersEnc(MetadataToken ownerToken);
    public abstract virtual IList`1<MetadataToken> GetFieldsEnc(MetadataToken typeToken);
    public abstract virtual IList`1<MetadataToken> GetMethodsEnc(MetadataToken typeToken);
    public abstract virtual IList`1<MetadataToken> GetPropertiesEnc(MetadataToken typeOrPropertyMapToken);
    public abstract virtual IList`1<MetadataToken> GetEventsEnc(MetadataToken typeOrEventMapToken);
    public abstract virtual IList`1<MetadataToken> GetCustomAttributesEnc(MetadataToken ownerToken);
    public abstract virtual IList`1<MetadataToken> GetDeclSecurityEnc(MetadataToken ownerToken);
    public abstract virtual IMetadataAccess GetInitialMetadataAccess();
}
internal class JetBrains.Metadata.EditAndContinue.Writer.EncMetadataStreamsAccess : object {
    [NotNullAttribute]
private IAggregatedStreamsAccess myStreams;
    [NotNullAttribute]
private IEncMetadataAccess myAccess;
    [NotNullAttribute]
private ILowLevelMetadataStreamsAccess myLowLevelStreams;
    [CanBeNullAttribute]
private Int32[] myMethodPointerTable;
    [CanBeNullAttribute]
private Int32[] myFieldPointerTable;
    [CanBeNullAttribute]
private Int32[] myParamPointerTable;
    [CanBeNullAttribute]
private Int32[] myEventPointerTable;
    [CanBeNullAttribute]
private Int32[] myPropertyPointerTable;
    [CanBeNullAttribute]
private Int32[] myTypeToMethodPointerIntervalStart;
    [CanBeNullAttribute]
private Int32[] myTypeToFieldPointerIntervalStart;
    [CanBeNullAttribute]
private Int32[] myMethodToParamPointerIntervalStart;
    [CanBeNullAttribute]
private Int32[] myEventMapToEventPointerIntervalStart;
    [CanBeNullAttribute]
private Int32[] myPropertyMapToPropertyPointerIntervalStart;
    private Dictionary`2<MetadataToken, MetadataToken> myRedirects;
    public int GuidMaxIndex { get; }
    public int StringHeapSize { get; }
    public int UserStringHeapSize { get; }
    public int BlobHeapSize { get; }
    public PdbStream PdbStream { get; }
    public EncMetadataStreamsAccess(IAggregatedStreamsAccess streams, IEncMetadataAccess access);
    private void BuildPointerTables();
    private void BuildPointerTable(Int32[]& pointerTable, Int32[]& parentToPointerIntervalStart, MetadataTableId tableId, MetadataTableId parentTableId, Func`2<MetadataToken, IList`1<MetadataToken>> getChildrenEnc);
    private static bool IsTrivialPointerTable(Int32[] pointerTable);
    private void SortTables();
    private void AssertSorted(MetadataTableId tableId, int keyColumnIndex);
    private void SortTable(MetadataTableId tableId, int keyColumnIndex);
    private void SortOrAssertSorted(MetadataTableId tableId, int keyColumnIndex, bool sort);
    private int GetKey(MetadataToken token, Column[] columns, int keyColumnIndex);
    private IList`1<MetadataToken> GetParametersEnc(MetadataToken methodToken);
    public sealed virtual Guid GetGuid(int index);
    public sealed virtual string GetString(int offset);
    public sealed virtual string GetUserString(MetadataToken pointer);
    public sealed virtual IBlob GetBlob(int offset);
    public sealed virtual string GetUtf8String(int blobOffset);
    public sealed virtual Guid[] GetAllGuids();
    public sealed virtual IEnumerable`1<Pair`2<string, int>> GetAllUserStringsWithOffsets();
    public sealed virtual IEnumerable`1<Pair`2<string, int>> GetAllStringsWithOffsets();
    public sealed virtual IEnumerable`1<string> GetAllStrings();
    public sealed virtual bool UserStringEqualToAsciiString(int offset, Byte[] utf8Bytes);
    public sealed virtual bool UserStringStartsWithAsciiString(int offset, Byte[] utf8Prefix);
    public sealed virtual IBinaryReader GetBlobHeapReader();
    public sealed virtual IEnumerable`1<int> GetAllBlobOffsets();
    public sealed virtual ITableReader GetTableRow(MetadataTableId table, int rid);
    public sealed virtual ITableReader GetTableRow(MetadataToken token);
    private ITableReader GetPointerTableRow(Int32[] pointerTable, MetadataToken token);
    public sealed virtual int GetTableSize(MetadataTableId tableId);
    private static int GetPointerTableSize(Int32[] pointerTable);
    public sealed virtual int get_GuidMaxIndex();
    public sealed virtual int get_StringHeapSize();
    public sealed virtual int get_UserStringHeapSize();
    public sealed virtual int get_BlobHeapSize();
    public sealed virtual PdbStream get_PdbStream();
    public sealed virtual IEnumerable`1<byte> GetStringHeapBytes();
    public sealed virtual IEnumerable`1<byte> GetUserStringHeapBytes();
    public sealed virtual IEnumerable`1<byte> GetGuidHeapBytes();
    public sealed virtual IEnumerable`1<byte> GetBlobHeapBytes();
}
public class JetBrains.Metadata.EditAndContinue.Writer.MetadataWriter : object {
    private MetadataHeader myOriginalHeader;
    private ILowLevelMetadataStreamsAccess myStreams;
    private BinaryWriter myWriter;
    private int myPosition;
    private static ulong SortedMask;
    private Int32[] myTokenSize;
    private Int32[] myTableRows;
    private Int32[] myTableRowSize;
    private int myStringOffsetSize;
    private int myGuidIndexSize;
    private int myBlobOffsetSize;
    private int myTablesHeaderOffset;
    private int myStringHeapOffset;
    private int myUsHeapOffset;
    private int myGuidHeapOffset;
    private int myBlobHeapOffset;
    private int Position { get; }
    private MetadataWriter(MetadataHeader originalHeader, ILowLevelMetadataStreamsAccess streams, BinaryWriter writer);
    public static void WriteMetadata(MetadataHeader originalHeader, IMetadataAccess access, BinaryWriter writer);
    private static void WriteMetadata(MetadataHeader originalHeader, IMetadataStreamsAccess streams, IMetadataAccess access, BinaryWriter writer);
    private int get_Position();
    private void WriteMetadata();
    private void WriteMetadataHeader();
    private int Align4(int i);
    private int GetStreamHeaderSize(string heapName);
    private void WriteStreamHeader(string heapName, int offset, int heapSize);
    private int UpdateOffsets(string heapName, int heapSize, Int32& offset, Int32& heapOffset, Int32& pos);
    private int GetTablesHeaderSize();
    private void WriteTablesHeader();
    private int GetTablesSize();
    private void WriteTables();
    private void WriteStringHeap();
    private void WriteUserStringHeap();
    private void WriteGuidHeap();
    private void WriteBlobHeap();
    private void Write(ulong ul);
    private void Write(UInt32 ui);
    private void Write(int i);
    private void Write(ushort us);
    private void Write(byte b);
    private void Write(Byte[] buffer);
    private void WriteStringOffset(int stringOffset);
    private void WriteGuidIndex(int guidIndex);
    private void WriteBlobOffset(int blobOffset);
    private void WriteRawToken(UInt32 rawToken, MetadataTokenType tokenType);
    private void WriteAsciiString(string s, int alignedLength);
    private int WriteUtf8Aligned(string s, bool estimateLengthOnly);
    private void WriteAligningZeros();
    private void AssertAligned();
}
internal class JetBrains.Metadata.EditAndContinue.Writer.VirtualTableRow : object {
    private Int32[] myRowData;
    private Column[] myStructure;
    private int myPosition;
    public VirtualTableRow(Int32[] rowData, MetadataTableId tableId);
    public sealed virtual void Reset(MetadataToken token);
    public sealed virtual byte ReadByte();
    public sealed virtual ushort ReadUInt16();
    public sealed virtual UInt32 ReadUInt32();
    public sealed virtual int ReadString();
    public sealed virtual int ReadGuid();
    public sealed virtual int ReadBlob();
    public sealed virtual UInt32 ReadToken(MetadataTokenType type);
    public sealed virtual UInt32 ReadRawToken(MetadataTokenType type);
    public sealed virtual void Skip(int bytes);
    public sealed virtual void SkipString();
    public sealed virtual void SkipGuid();
    public sealed virtual void SkipBlob();
    public sealed virtual void SkipToken(MetadataTokenType type);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertCorrectDataType(ColumnDataType dataType);
}
public class JetBrains.Metadata.IL.AssemblyIlCode : IlCodeBase {
    private Dictionary`2<MetadataToken, IMetadataTypeInfo> myMethodTokenToType;
    [CompilerGeneratedAttribute]
private IMetadataAssembly <Assembly>k__BackingField;
    public IMetadataAssembly Assembly { get; }
    public AssemblyIlCode(IMetadataAssembly metadataAssembly);
    [NotNullAttribute]
public IMetadataTypeInfo GetType(MetadataToken methodToken);
    [CompilerGeneratedAttribute]
public IMetadataAssembly get_Assembly();
}
internal class JetBrains.Metadata.IL.CodeBlocks.CatchIlCodeBlock : IlCodeBlock {
    [CompilerGeneratedAttribute]
private IMetadataType <CatchType>k__BackingField;
    public IMetadataType CatchType { get; }
    public CatchIlCodeBlock(int startOffset, int endOffset, IMetadataType catchType);
    [CompilerGeneratedAttribute]
public IMetadataType get_CatchType();
    protected virtual void RenderStartText(IlMetadataFormatter formatter);
    protected virtual string GetEndComment();
}
internal class JetBrains.Metadata.IL.CodeBlocks.CatchWithFilterIlCodeBlock : IlCodeBlock {
    public CatchWithFilterIlCodeBlock(int startOffset, int endOffset);
    protected virtual string GetStartComment();
    protected virtual string GetEndComment();
}
internal class JetBrains.Metadata.IL.CodeBlocks.FaultIlCodeBlock : IlCodeBlock {
    public FaultIlCodeBlock(int startOffset, int endOffset);
    protected virtual void RenderStartText(IlMetadataFormatter formatter);
    protected virtual string GetEndComment();
}
internal class JetBrains.Metadata.IL.CodeBlocks.FilterIlCodeBlock : IlCodeBlock {
    public FilterIlCodeBlock(int startOffset, int endOffset);
    protected virtual void RenderStartText(IlMetadataFormatter formatter);
    protected virtual string GetEndComment();
}
internal class JetBrains.Metadata.IL.CodeBlocks.FinallyIlCodeBlock : IlCodeBlock {
    public FinallyIlCodeBlock(int startOffset, int endOffset);
    protected virtual void RenderStartText(IlMetadataFormatter formatter);
    protected virtual string GetEndComment();
}
internal abstract class JetBrains.Metadata.IL.CodeBlocks.IlCodeBlock : object {
    protected static string StartOf;
    protected static string EndOf;
    [CompilerGeneratedAttribute]
private int <StartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private IlCodeBlockType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IlCodeBlock <Parent>k__BackingField;
    private LinkedList`1<IlCodeBlock> mySortedChildren;
    public int StartOffset { get; }
    public int EndOffset { get; }
    public IlCodeBlockType Type { get; }
    [CanBeNullAttribute]
public IlCodeBlock Parent { get; public set; }
    protected bool WithBraces { get; }
    protected IlCodeBlock(IlCodeBlockType type, int startOffset, int endOffset);
    [CompilerGeneratedAttribute]
public int get_StartOffset();
    [CompilerGeneratedAttribute]
public int get_EndOffset();
    [CompilerGeneratedAttribute]
public IlCodeBlockType get_Type();
    [CompilerGeneratedAttribute]
public IlCodeBlock get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(IlCodeBlock value);
    public void AddChild(IlCodeBlock child);
    protected virtual bool AllowAdding(IlCodeBlock child);
    private bool ContainsBlockRange(IlCodeBlock block);
    private void MoveChildrenToNewParent(IlCodeBlock newParent, List`1<LinkedListNode`1<IlCodeBlock>> children);
    public virtual bool IsValid();
    protected virtual void MarkInvalid();
    public void RemoveInvalid();
    private void Remove();
    protected void RenderIndented(IlMetadataFormatter formatter, bool increase, IMethodBody methodBody, Int32& currentInstructionIndex);
    private void RenderBraceAndComment(IlMetadataFormatter formatter, bool start, string comment);
    private static void RenderInstructionRange(IlMetadataFormatter formatter, int rangeStartOffset, int rangeEndOffset, IMethodBody methodBody, Int32& currentInstructionIndex);
    protected virtual void RenderStartText(IlMetadataFormatter formatter);
    [CanBeNullAttribute]
protected virtual string GetStartComment();
    [CanBeNullAttribute]
protected virtual string GetEndComment();
    protected virtual bool get_WithBraces();
}
public enum JetBrains.Metadata.IL.CodeBlocks.IlCodeBlockType : Enum {
    public int value__;
    public static IlCodeBlockType MethodBody;
    public static IlCodeBlockType Try;
    public static IlCodeBlockType Catch;
    public static IlCodeBlockType Finally;
    public static IlCodeBlockType Fault;
    public static IlCodeBlockType Filter;
    public static IlCodeBlockType CatchWithFilter;
    public static IlCodeBlockType Loop;
}
internal class JetBrains.Metadata.IL.CodeBlocks.IlLoopDetector : object {
    private Instruction[] myInstructions;
    private Dictionary`2<int, int> myOffsetToIndex;
    private List`1<Jump> myJumps;
    private List`1<Loop> myLoops;
    public IlLoopDetector(Instruction[] instructions);
    public int GetIndent(int instructionOffset);
    private void FindLoops();
    public void AddLoopsToBody(MethodBodyIlCodeBlock body);
}
internal class JetBrains.Metadata.IL.CodeBlocks.LoopIlCodeBlock : IlCodeBlock {
    [CompilerGeneratedAttribute]
private int <EntryPointOffset>k__BackingField;
    private bool myIsValid;
    public int EntryPointOffset { get; }
    protected bool WithBraces { get; }
    public LoopIlCodeBlock(int startOffset, int endOffset, int entryPointOffset);
    [CompilerGeneratedAttribute]
public int get_EntryPointOffset();
    protected virtual bool AllowAdding(IlCodeBlock child);
    public virtual bool IsValid();
    protected virtual void MarkInvalid();
    protected virtual bool get_WithBraces();
    protected virtual string GetStartComment();
    protected virtual string GetEndComment();
}
internal class JetBrains.Metadata.IL.CodeBlocks.MethodBodyIlCodeBlock : IlCodeBlock {
    protected bool WithBraces { get; }
    private MethodBodyIlCodeBlock(int startOffset, int endOffset);
    public static MethodBodyIlCodeBlock Create(IMethodBody methodBody);
    public void RenderIndented(IMethodBody methodBody, IlMetadataFormatter formatter);
    protected virtual bool get_WithBraces();
}
internal static class JetBrains.Metadata.IL.CodeBlocks.MethodBodyStructureBuilder : object {
    public static MethodBodyIlCodeBlock Build(IMethodBody methodBody, bool detectLoops);
}
internal class JetBrains.Metadata.IL.CodeBlocks.TryIlCodeBlock : IlCodeBlock {
    public TryIlCodeBlock(int startOffset, int endOffset);
    protected virtual bool AllowAdding(IlCodeBlock child);
    protected virtual void RenderStartText(IlMetadataFormatter formatter);
    protected virtual string GetEndComment();
}
public class JetBrains.Metadata.IL.ExceptionHandler : object {
    private int myCatchBlockLen;
    private int myCatchOffset;
    private MetadataToken myCatchTypeToken;
    private int myFilterOffset;
    private int myTryBlockLen;
    private int myTryOffset;
    private ExceptionHandlerType myType;
    public ExceptionHandlerType Type { get; }
    public int TryOffset { get; }
    public int TryLength { get; }
    public int HandlerOffset { get; }
    public int HandlerLength { get; }
    public int FilterOffset { get; }
    public MetadataToken CatchTypeToken { get; }
    internal ExceptionHandler(ExceptionHandlerType type, int tryOffset, int tryLength, int handlerOffset, int handlerLength);
    internal ExceptionHandler(ExceptionHandlerType type, int tryOffset, int tryLength, int handlerOffset, int handlerLength, int filterOffset);
    internal ExceptionHandler(ExceptionHandlerType type, int tryOffset, int tryLength, int handlerOffset, int handlerLength, MetadataToken catchType);
    public ExceptionHandlerType get_Type();
    public int get_TryOffset();
    public int get_TryLength();
    public int get_HandlerOffset();
    public int get_HandlerLength();
    public int get_FilterOffset();
    public MetadataToken get_CatchTypeToken();
}
public class JetBrains.Metadata.IL.ExceptionHandlersComparer : object {
    public static IComparer`1<IMethodBodyExceptionHandler> Instance;
    private static ExceptionHandlersComparer();
    public sealed virtual int Compare(IMethodBodyExceptionHandler x, IMethodBodyExceptionHandler y);
    private static bool ContainedIn(IMethodBodyExceptionHandler what, IMethodBodyExceptionHandler where);
    private static bool ContainedIn(IMethodBodyExceptionHandler what, int startOffset, int endOffset);
}
public enum JetBrains.Metadata.IL.ExceptionHandlerType : Enum {
    public int value__;
    public static ExceptionHandlerType Fault;
    public static ExceptionHandlerType Catch;
    public static ExceptionHandlerType Finally;
    public static ExceptionHandlerType CatchWithFilter;
}
public enum JetBrains.Metadata.IL.FlowControl : Enum {
    public int value__;
    public static FlowControl ConditionalBranch;
    public static FlowControl Next;
    public static FlowControl Return;
    public static FlowControl Throw;
    public static FlowControl Break;
    public static FlowControl Branch;
    public static FlowControl Call;
    public static FlowControl Meta;
    public static FlowControl Switch;
}
public interface JetBrains.Metadata.IL.IILMethodBodyBuilder`4 {
    public abstract virtual TInstructionList CreateInstructionList();
    public abstract virtual TInstructionList AddInstruction(TInstructionList instructions, TInstruction newInstruction);
    public abstract virtual TInstruction BuildInstruction_NoOperand(int offset, int size, Opcode opcode);
    public abstract virtual TInstruction BuildInstruction_Int32Operand(int offset, int size, Opcode opcode, int operand);
    public abstract virtual TInstruction BuildInstruction_Int64Operand(int offset, int size, Opcode opcode, long operand);
    public abstract virtual TInstruction BuildInstruction_DoubleOperand(int offset, int size, Opcode opcode, double operand);
    public abstract virtual TInstruction BuildInstruction_SByteOperand(int offset, int size, Opcode opcode, sbyte operand);
    public abstract virtual TInstruction BuildInstruction_SingleOperand(int offset, int size, Opcode opcode, float operand);
    public abstract virtual TInstruction BuildInstruction_SwitchTargetsOperand(int offset, int size, Opcode opcode, Int32[] operand);
    public abstract virtual TInstruction BuildInstruction_VariableIndexOperand(int offset, int size, Opcode opcode, ushort operand);
    public abstract virtual TInstruction BuildInstruction_ShortVariableIndexOperand(int offset, int size, Opcode opcode, byte operand);
    public abstract virtual TInstruction BuildInstruction_TokenOperand(IMetadataAccess metadataAccess, int offset, int size, Opcode opcode, MetadataToken operand);
    public abstract virtual TExHandlerList CreateExceptionHandlerList();
    public abstract virtual TExHandlerList AddExceptionHandler(TExHandlerList handlers, ExceptionHandlerType type, int tryOffset, int tryLength, int handlerOffset, int handlerLength);
    public abstract virtual TExHandlerList AddExceptionHandler(TExHandlerList handlers, ExceptionHandlerType type, int tryOffset, int tryLength, int handlerOffset, int handlerLength, int filterOffset);
    public abstract virtual TExHandlerList AddExceptionHandler(TExHandlerList handlers, ExceptionHandlerType type, int tryOffset, int tryLength, int handlerOffset, int handlerLength, MetadataToken catchType);
    public abstract virtual TBody CreateMethodBody(int codeSize, int maxStack, MetadataToken localVarsToken, TExHandlerList exceptionHandlers, TInstructionList instructions, ILMethodFlags flags);
}
public interface JetBrains.Metadata.IL.IInstructionRedirector {
    [NotNullAttribute]
public IMetadataMethod Method { get; }
    [NotNullAttribute]
public abstract virtual Instruction Redirect(Instruction instruction);
    public abstract virtual IMetadataMethod get_Method();
}
public class JetBrains.Metadata.IL.IlCodeBase : object {
    private Dictionary`2<MetadataToken, IMethodBody> myMethodTokenToMethodBody;
    protected void AddMethod(MetadataToken methodToken, IMethodBody methodBody);
    [NotNullAttribute]
public IMethodBody GetMethodBody(MetadataToken methodToken);
    public IEnumerable`1<MetadataToken> Methods();
    [NotNullAttribute]
public Instruction[] GetInstructions(MetadataToken methodToken);
    [NotNullAttribute]
public Instruction GetInstruction(MetadataToken methodToken, int instructionIndex);
    [NotNullAttribute]
public Instruction GetInstructionAndIndex(MetadataToken methodToken, int ilOffset, Int32& instructionIndex);
    public int GetMethodInstructionsCount(MetadataToken methodToken);
}
public class JetBrains.Metadata.IL.IlCodeOffsetMarker : object {
    public int Offset;
    public IlCodeOffsetMarker(int offset);
}
public class JetBrains.Metadata.IL.IlImageBodyAccess : object {
    private IBinaryReader myImageReader;
    private IMetadataAccess myMetadata;
    private CliImage myCliImage;
    public IlImageBodyAccess(IBinaryReader imageReader, IMetadataAccess metadata);
    [CanBeNullAttribute]
public ILMethodBody GetMethodBody(IMetadataMethod metadataMethod);
    [CanBeNullAttribute]
public Byte[] GetFieldInitialValue(MetadataToken fieldToken, int valueSize);
}
public static class JetBrains.Metadata.IL.IlKeywords : object {
    public static string DotAddon;
    public static string DotAssembly;
    public static string DotBase;
    public static string DotCctor;
    public static string DotClass;
    public static string DotCorflags;
    public static string DotCtor;
    public static string DotCulture;
    public static string DotCustom;
    public static string DotData;
    public static string DotEmitbyte;
    public static string DotEntrypoint;
    public static string DotEvent;
    public static string DotExport;
    public static string DotField;
    public static string DotFile;
    public static string DotFire;
    public static string DotGet;
    public static string DotHash;
    public static string DotImagebase;
    public static string DotImport;
    public static string DotInterfaceimpl;
    public static string DotLanguage;
    public static string DotLine;
    public static string DotLocale;
    public static string DotLocals;
    public static string DotManifestres;
    public static string DotMaxstack;
    public static string DotMethod;
    public static string DotModule;
    public static string DotMresource;
    public static string DotMscorlib;
    public static string DotNamespace;
    public static string DotNester;
    public static string DotOther;
    public static string DotOverride;
    public static string DotPack;
    public static string DotParam;
    public static string DotPdirect;
    public static string DotPermission;
    public static string DotPermissionset;
    public static string DotProperty;
    public static string DotPublickey;
    public static string DotPublickeytoken;
    public static string DotRemoveon;
    public static string DotSet;
    public static string DotSize;
    public static string DotStackreserve;
    public static string DotSubsystem;
    public static string DotThis;
    public static string DotTry;
    public static string DotTypedef;
    public static string DotTypelist;
    public static string DotVer;
    public static string DotVtable;
    public static string DotVtentry;
    public static string DotVtfixup;
    public static string DotZeroinit;
    public static string Abstract;
    public static string Aggressiveinlining;
    public static string Aggressiveoptimization;
    public static string Algorithm;
    public static string Alignment;
    public static string Ansi;
    public static string Any;
    public static string Array;
    public static string As;
    public static string Assembly;
    public static string At;
    public static string Auto;
    public static string Autochar;
    public static string Beforefieldinit;
    public static string Blob;
    public static string BlobObject;
    public static string Bool;
    public static string Bstr;
    public static string Bytearray;
    public static string Byvalstr;
    public static string Callmostderived;
    public static string Carray;
    public static string Catch;
    public static string Cdecl;
    public static string Cf;
    public static string Char;
    public static string Cil;
    public static string Class;
    public static string Clsid;
    public static string Compilercontrolled;
    public static string Const;
    public static string Constraint;
    public static string Currency;
    public static string Custom;
    public static string Date;
    public static string Decimal;
    public static string Default;
    public static string Enum;
    public static string Error;
    public static string Explicit;
    public static string Extends;
    public static string Extern;
    public static string False;
    public static string Famandassem;
    public static string Family;
    public static string Famorassem;
    public static string Fastcall;
    public static string Fault;
    public static string Field;
    public static string Filetime;
    public static string Filter;
    public static string Final;
    public static string Finally;
    public static string Fixed;
    public static string Float;
    public static string Float32;
    public static string Float64;
    public static string Forwarder;
    public static string Forwardref;
    public static string Fromunmanaged;
    public static string Handler;
    public static string Hassecurity;
    public static string Hidebysig;
    public static string Hresult;
    public static string Hstring;
    public static string Idispatch;
    public static string Iinspectable;
    public static string Il;
    public static string Illegal;
    public static string Implements;
    public static string Implicitcom;
    public static string Implicitres;
    public static string Import;
    public static string In;
    public static string Init;
    public static string Initonly;
    public static string Instance;
    public static string Int;
    public static string Int16;
    public static string Int32;
    public static string Int64;
    public static string Int8;
    public static string Interface;
    public static string Internalcall;
    public static string Iunknown;
    public static string Lasterr;
    public static string Lcid;
    public static string Literal;
    public static string Lpstr;
    public static string Lpstruct;
    public static string Lptstr;
    public static string Lpvoid;
    public static string Lpwstr;
    public static string Managed;
    public static string Marshal;
    public static string Mdtoken;
    public static string Method;
    public static string Modopt;
    public static string Modreq;
    public static string Native;
    public static string Nested;
    public static string Newslot;
    public static string Noappdomain;
    public static string Noinlining;
    public static string Nomachine;
    public static string Nomangle;
    public static string Nometadata;
    public static string Noncasdemand;
    public static string Noncasinheritance;
    public static string Noncaslinkdemand;
    public static string Nooptimization;
    public static string Noprocess;
    public static string NotInGcHeap;
    public static string Notremotable;
    public static string Notserialized;
    public static string Null;
    public static string Nullref;
    public static string Object;
    public static string Objectref;
    public static string Opt;
    public static string Optil;
    public static string Out;
    public static string Pinned;
    public static string Pinvokeimpl;
    public static string Prefix1;
    public static string Prefix2;
    public static string Prefix3;
    public static string Prefix4;
    public static string Prefix5;
    public static string Prefix6;
    public static string Prefix7;
    public static string Prefixref;
    public static string Preservesig;
    public static string Private;
    public static string Privatescope;
    public static string Property;
    public static string Protected;
    public static string Public;
    public static string Record;
    public static string Refany;
    public static string Retainappdomain;
    public static string Retval;
    public static string Rtspecialname;
    public static string Runtime;
    public static string Safearray;
    public static string Sealed;
    public static string Sequential;
    public static string Serializable;
    public static string Special;
    public static string Specialname;
    public static string Static;
    public static string Stdcall;
    public static string Storage;
    public static string StoredObject;
    public static string Stream;
    public static string StreamedObject;
    public static string Strict;
    public static string String;
    public static string Struct;
    public static string Synchronized;
    public static string Syschar;
    public static string Sysstring;
    public static string Tbstr;
    public static string Thiscall;
    public static string Tls;
    public static string To;
    public static string True;
    public static string Type;
    public static string Typedref;
    public static string Unicode;
    public static string Unmanaged;
    public static string Unmanagedexp;
    public static string Unsigned;
    public static string Userdefined;
    public static string Value;
    public static string Valuetype;
    public static string Vararg;
    public static string Variant;
    public static string Vector;
    public static string Virtual;
    public static string Void;
    public static string Wchar;
    public static string Winapi;
    public static string With;
    public static string Wrapper;
    public static string Assert;
    public static string Demand;
    public static string Deny;
    public static string Inheritcheck;
    public static string Linkcheck;
    public static string Permitonly;
    public static string Reqmin;
    public static string Reqopt;
    public static string Reqrefuse;
    public static string Reqsecobj;
    public static string Request;
    public static string Prejitdeny;
    public static string Prejitgrant;
    public static string Uint16;
    public static string Uint32;
    public static string Uint64;
    public static string Uint8;
    public static HashSet`1<string> Keywords;
    private static IlKeywords();
}
public class JetBrains.Metadata.IL.IlMetadataFormatter : object {
    private Dictionary`2<Pair`2<string, AssemblyNameInfo>, MetadataToken> myTypeRefs;
    private static string ContravariantAttribute;
    private static string CovariantAttribute;
    private static string DefaultConstructorConstraint;
    private static string Params;
    private static string This;
    protected CodeTextWithLineCommentsWriter myWriter;
    [CanBeNullAttribute]
private IMetadataLocalVariablesNameProvider myLocalVariablesNameProvider;
    protected IMetadataAssembly myContainingAssembly;
    protected bool myShowMetadataTokenValues;
    private bool myShowLoops;
    private bool myDecompileProtectedAssemblies;
    private Dictionary`2<AssemblyNameInfo, MetadataToken> myAssemblyReferenceToToken;
    public static string AssemblyIsProtectedFromDecompilationMessage;
    private static string Unresolved;
    private int myMultilineCommentLevel;
    protected bool HideParameterNames { get; }
    public IlMetadataFormatter(ICodeTextWriter writer, IMetadataAssembly containingAssembly, IMetadataLocalVariablesNameProvider localVariablesNameProvider, bool showMetadataTokenValues, bool showLoops, bool decompileProtectedAssemblies);
    internal void RenderType(IMetadataType type, IMetadataType[] methodGenericArguments, IMetadataType[] ownerTypeGenericArguments, MetadataToken hintTypeToken);
    protected virtual IlMetadataTypeNameFormatter CreateTypeNameFormatter(IMetadataType[] methodGenericArguments, IMetadataType[] ownerTypeGenericArguments);
    internal void RenderTypeReference(IMetadataTypeInfo type, MetadataToken typeToken);
    private void RenderResolutionScope(AssemblyNameInfo assemblyName);
    private void RenderTypeSpec(IMetadataType type, IMetadataType[] methodGenericArguments, IMetadataType[] ownerTypeGenericArguments, MetadataToken hintTypeToken);
    private void RenderTypeMemberName(IMetadataTypeMember typeMember, bool fqn);
    internal void RenderDottedName(string s);
    internal void RenderFileName(string s);
    internal void RenderId(string s);
    private static bool IsKeyword(string s);
    private static bool IsID(string s, bool dotSeparatedIDs);
    private void RenderQString(string s);
    private void RenderSqString(string s);
    private void RenderString(string value, bool useSingleQuote);
    private void RenderGenericParameters(IMetadataTypeParameter[] genericParameters);
    private void RenderGenPar(IMetadataTypeParameter genericParameter);
    private void RenderTypeParametersCustomAttributes(IMetadataTypeParameter[] genericParameters);
    private void RenderCommentedGenericParameterName(IMetadataTypeParameter genericParameter);
    private string GetGenericParameterName(IMetadataTypeParameter genericParameter);
    private void RenderSecurityDecl(IMetadataSecurityOwner securityOwner);
    private void RenderSecAction(SecurityAction securityAction);
    private void RenderAttributeNamedArgument(IMetadataAttributeNamedArgument namedArgument, bool standardValueTypes);
    private void RenderCustomAttributesIndented(IMetadataEntity entity);
    private void RenderCustomAttributes(IMetadataEntity entity);
    private void RenderCustomAttributes(IMetadataCustomAttribute[] customAttributes);
    protected virtual IMetadataCustomAttribute[] Reorder(IMetadataCustomAttribute[] attributes);
    protected virtual IEnumerable`1<IMetadataCustomAttribute> Filter(IMetadataCustomAttribute[] attributes);
    protected virtual int FilteredCustomAttributesCount(IMetadataEntity entity);
    private void RenderMetadataAttributeValue(MetadataAttributeValue metadataAttributeValue, bool standardValueTypes);
    private void RenderInitValue(MetadataToken ownerObjectToken, object value);
    private void RenderCommentedConstantTokenIfNeeded(MetadataToken ownerObjectToken);
    private void RenderFieldInit(object value, bool standardValueTypes);
    private void RenderChar(char ch);
    private void RenderDouble(double operand, LiteralRenderStyle renderStyle);
    private void RenderFloat(float operand, LiteralRenderStyle renderStyle);
    private static string GetHexRepresentation(double operand, LiteralRenderStyle renderStyle);
    private static string GetHexRepresentation(float operand, LiteralRenderStyle renderStyle);
    private void RenderStringAsArray(string value);
    private void RenderBytearray(Byte[] bytes);
    private void RenderBytes(Byte[] bytes);
    private static string GetBytesString(Byte[] bytes);
    private static string ToTwoDigitHex(byte b);
    private char ToPresentableChar(byte b);
    private char ToPresentableChar(char ch);
    private void RenderSpecialnameAttributes(IMetadataTypeMember typeMember);
    private void RenderAccessor(IMetadataMethod accessor, string directive);
    protected virtual bool NeedToRender(IMetadataTypeMember member);
    private void RenderCommentedTokenIfNeeded(MetadataToken token, bool withSpace);
    private void RenderCommentedTokenIfNeeded(IMetadataEntity tokenOwner, bool withSpace, MetadataToken hintToken);
    private MetadataToken GetTypeRefToken(IMetadataTypeInfo type);
    public void RenderType(IMetadataTypeInfo type, IImageBodyReader bodyReader);
    protected virtual T[] Reorder(T[] members);
    public void RenderTypeAssociatedAttributes(IMetadataTypeInfo type);
    public void RenderLayoutControl(IMetadataTypeInfo type);
    protected virtual void StartTypeRendering(IMetadataTypeInfo type);
    protected virtual void EndTypeRendering(IMetadataTypeInfo type);
    public void RenderClassHeader(IMetadataTypeInfo type);
    private void RenderClassAttributes(IMetadataTypeInfo type);
    protected virtual bool IgnoreBeforefieldinitFlag(IMetadataTypeInfo type);
    private void RenderInterfaceImplementationsCustomAttributes(IMetadataInterfaceImplementation[] interfaceImplementations);
    public void RenderMethodBody(IMethodBody methodBody);
    protected virtual void StartMethodBodyRendering(IMethodBody methodBody);
    protected virtual void EndMethodBodyRendering(IMethodBody methodBody);
    public void RenderLocalVariables(IMethodBody methodBody);
    private string GetLocalVariableName(IMethodBodyLocalVariable variable, int ilOffset);
    private string GetLocalVariableName(IMethodBody methodBody, int index, int ilOffset);
    private void RenderLocal(IMethodBodyLocalVariable variable);
    private void RenderCommentedTupleElementNames(IMethodBodyLocalVariable variable);
    public void RenderMaxStack(IMethodBody methodBody);
    protected virtual void StartInstructionRendering(IMethodBody methodBody, Instruction instruction);
    internal void TryRenderInstruction(IMethodBody methodBody, Instruction instruction);
    private static void LogInstructionRenderingException(Exception ex, IMetadataMethod method, Instruction instruction);
    private void RenderInstruction(IMethodBody methodBody, Instruction instruction);
    private void RenderInstructionAligned(Instruction instruction);
    private void RenderInstruction(Instruction instruction);
    private static string GetLabelName(int absOffset);
    private static string GetDataLabelName(UInt32 initialValueRva);
    private bool RenderTokenReference(object operand, bool isLdtokenInstructionOperand, MetadataToken operandToken);
    private void RenderFieldSpecification(FieldSpecification fieldSpecification, MetadataToken operandToken);
    private void RenderMethodInstantiation(MethodInstantiation methodInstantiation, MetadataToken operandToken);
    private void RenderMethodInstantiation(MethodSpecification methodSpecification, IMetadataType[] methodGenericArguments, MetadataToken operandToken);
    private void RenderMethodSignature(MethodSignature methodSignature, MetadataToken operandToken);
    private void RenderLocalVariableName(IMethodBody methodBody, Instruction instruction);
    private void RenderArgName(IMethodBody methodBody, int index);
    private static string GetArgName(IMethodBody methodBody, int index);
    public void RenderEvent(IMetadataEvent event);
    protected virtual void StartEventRendering(IMetadataEvent event);
    protected virtual void EndEventRendering(IMetadataEvent event);
    public void RenderEventHeader(IMetadataEvent event);
    public void RenderField(IMetadataField field, IImageBodyReader bodyReader);
    public void RenderFieldHeader(IMetadataField field);
    protected virtual void StartFieldRendering(IMetadataField field);
    protected virtual void EndFieldRendering(IMetadataField field);
    private void RenderFieldDecl(IMetadataField field);
    private void RenderFieldAttributes(IMetadataField field);
    private void RenderData(IMetadataField field, IImageBodyReader bodyReader);
    public void RenderAssemblyAndModuleInfo(IImageBodyReader bodyReader);
    private void RenderReferencedAssemblies();
    private void RenderAssemblyInfo();
    private void RenderModuleInfo();
    private void RenderExternModules();
    private void RenderFiles();
    private void RenderManifestResources();
    private void RenderImplementation(MetadataToken implementation, UInt32 offset, bool renderOffset);
    private void RenderExportedTypes();
    private void RenderClassExtern(ExportedTypeProperties exportedTypeProperties, bool detailed);
    private void RenderHashAlgorithm(JetAssemblyHashAlgorithm hashAlgorithm);
    private void RenderHash(Byte[] hash);
    private void RenderCulture(string culture);
    private void RenderPublicKey(Byte[] publicKey);
    private void RenderPublicKeyToken(PublicKeyToken publicKeyToken);
    private void RenderVersion(Version version);
    private void RenderModuleParameters();
    private void RenderMarshallingInformation(IBlob marshalSpecBlob, bool spaceBefore);
    private void RenderNativeType(NativeType nativeType, IMarshalSpec marshalSpec);
    private void RenderVariantType(VariantType variantType);
    public void RenderMethod(IMetadataMethod method, IImageBodyReader bodyReader);
    public void RenderMethodAssociatedInfo(IMetadataMethod method);
    protected virtual void StartMethodRendering(IMetadataMethod method);
    protected virtual void EndMethodRendering(IMetadataMethod method);
    private static bool IsEntryPointMethod(IMetadataMethod method);
    public void RenderMethodHeader(IMetadataMethod method);
    private void RenderMethodName(string name);
    private void RenderMethodAttributes(IMetadataMethod method);
    private void RenderPlatformInvoke(IMetadataMethod method);
    private void RenderCallConv(IMetadataMethod method);
    internal void RenderCallConv(MethodSignature methodSignature);
    private void RenderMethodReturnType(IMetadataMethod method, bool renderMarshallingInformation);
    private void RenderMethodParameters(IMetadataMethod method, bool renderNames, bool oneParameterPerLine, int paramCount);
    protected virtual bool get_HideParameterNames();
    protected virtual void RenderMethodImplementationAttributes(IMetadataMethod method);
    private void RenderParametersDefaultValuesAndAttributes(IMetadataMethod method);
    private void RenderDefaultValueAndAttributes(int paramIndex, IMetadataEntity entity);
    private void RenderImplementedMethods(IMetadataMethod method);
    public void RenderProperty(IMetadataProperty property);
    protected virtual void StartPropertyRendering(IMetadataProperty property);
    protected virtual void EndPropertyRendering(IMetadataProperty property);
    public void RenderPropertyHeader(IMetadataProperty property);
    internal IDisposable WithMultiLineComment(bool spaceAfterComment);
    private IDisposable WithLineComment(bool writeNewLineAfterComment);
    protected internal void RenderLineComment(string comment, bool writeNewLineAfterComment);
    internal void WriteWithSpace(string text);
    [StringFormatMethodAttribute("format")]
internal void Write(string format, Object[] args);
    [StringFormatMethodAttribute("format")]
internal void WriteWithSpace(string format, Object[] args);
    internal void Write(string text);
    [StringFormatMethodAttribute("format")]
internal void WriteTextWithLineComment(string format, Object[] args);
    internal void WriteNewLine();
    internal IDisposable WithIncreaseIndent(bool increase);
    private IDisposable WithBraces();
    private void RenderSeparated(T[] elements, Action`1<T> renderElement, bool newLine, int paramCount);
    [CompilerGeneratedAttribute]
private void <RenderGenPar>b__15_0(IMetadataTypeParameterConstraint typeConstraint);
    [CompilerGeneratedAttribute]
private void <RenderSecurityDecl>b__19_0(IMetadataSecurityAttribute securityAttribute);
    [CompilerGeneratedAttribute]
private void <RenderClassHeader>b__58_0(IMetadataInterfaceImplementation interfaceImplementation);
    [CompilerGeneratedAttribute]
private void <RenderMethodSignature>b__98_0(IMetadataType parameterType);
}
public class JetBrains.Metadata.IL.IlMetadataTypeNameFormatter : object {
    private IlMetadataFormatter myIlFormatter;
    private IMetadataType[] myMethodGenericArguments;
    private IMetadataType[] myOwnerTypeGenericArguments;
    private bool myTypeParameterReferenceTypeStop;
    public static string TypeParameterInType;
    public static string TypeParameterInMethod;
    public IlMetadataTypeNameFormatter(IlMetadataFormatter ilFormatter, IMetadataType[] methodGenericArguments, IMetadataType[] ownerTypeGenericArguments);
    private void RenderModifiers(IMetadataType metadataType);
    public sealed virtual void VisitUnknownType(IMetadataType unknownType);
    public sealed virtual void VisitArrayType(IMetadataArrayType arrayType);
    public sealed virtual void VisitClassType(IMetadataClassType classType);
    public sealed virtual void VisitTupleType(IMetadataTupleType tupleType);
    public sealed virtual void VisitPointerType(IMetadataPointerType pointerType);
    public sealed virtual void VisitReferenceType(IMetadataReferenceType referenceType);
    public sealed virtual void VisitTypeParameterReferenceType(IMetadataTypeParameterReferenceType typeParameterReferenceType);
    protected virtual void RenderSubstitutedTypeInComment(IMetadataType substitutedType, IMetadataTypeParameter typeParameter);
    public sealed virtual void VisitFunctionPointer(IMetadataFunctionPointerType functionPointerType);
    public sealed virtual void VisitBoxedType(IMetadataBoxedType boxedType);
}
public class JetBrains.Metadata.IL.ILMethodBody : object {
    [CompilerGeneratedAttribute]
private int <MaxStack>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodeSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ILMethodFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private ExceptionHandler[] <Exceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Instruction[] <Instructions>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <LocalVarsToken>k__BackingField;
    public int MaxStack { get; }
    public int CodeSize { get; }
    public ILMethodFlags Flags { get; }
    public ExceptionHandler[] Exceptions { get; }
    public Instruction[] Instructions { get; }
    public MetadataToken LocalVarsToken { get; }
    public bool LocalVariablesInitialized { get; }
    public ILMethodBody(int codeSize, int maxStack, MetadataToken localVarsToken, ExceptionHandler[] arExceptions, Instruction[] arInstructions, ILMethodFlags flags);
    [CompilerGeneratedAttribute]
public int get_MaxStack();
    [CompilerGeneratedAttribute]
public int get_CodeSize();
    [CompilerGeneratedAttribute]
public ILMethodFlags get_Flags();
    [CompilerGeneratedAttribute]
public ExceptionHandler[] get_Exceptions();
    [CompilerGeneratedAttribute]
public Instruction[] get_Instructions();
    [CompilerGeneratedAttribute]
public MetadataToken get_LocalVarsToken();
    public bool get_LocalVariablesInitialized();
    public static ILMethodBody DecodeMethodBody(IMetadataAccess metadataAccess, IBinaryReader reader);
    public static Instruction DecodeInstruction(IMetadataAccess metadataAccess, BinaryReader reader);
}
public static class JetBrains.Metadata.IL.ILMethodBodyDecoder : object {
    public static TBody DecodeMethodBody(IBinaryReader reader, IMetadataAccess metadataAccess, IILMethodBodyBuilder`4<TBody, TInstruction, TInstructionList, TExHandlerList> methodBodyBuilder);
    public static TInstruction DecodeInstruction(BinaryReader reader, IMetadataAccess metadataAccess, IILMethodBodyBuilder`4<TBody, TInstruction, TInstructionList, TExHandlerList> methodBodyBuilder);
}
internal class JetBrains.Metadata.IL.ILMethodBodyReader : object {
    private Byte[] myCode;
    private ILMethodFlags myFlags;
    private UInt32 myLocalsToken;
    private ushort myStackMax;
    private CodeSection myStartCodeSection;
    public ushort MaxStack { get; }
    public UInt32 LocalVarSigToken { get; }
    public Byte[] Code { get; }
    public ILMethodFlags Flags { get; }
    public Clause[] Clauses { get; }
    public ILMethodBodyReader(IBinaryReader reader);
    public ushort get_MaxStack();
    public UInt32 get_LocalVarSigToken();
    public Byte[] get_Code();
    public ILMethodFlags get_Flags();
    public Clause[] get_Clauses();
}
[FlagsAttribute]
public enum JetBrains.Metadata.IL.ILMethodFlags : Enum {
    public int value__;
    public static ILMethodFlags SmallCode;
    public static ILMethodFlags TinyCode;
    public static ILMethodFlags FatCode;
    public static ILMethodFlags CodeMask;
    public static ILMethodFlags InitLocals;
    public static ILMethodFlags MoreSects;
}
public static class JetBrains.Metadata.IL.IlPreprocessorDirectives : object {
    public static string Sharp;
    public static string SharpDefine;
    public static string SharpElse;
    public static string SharpEndif;
    public static string SharpIfdef;
    public static string SharpIfndef;
    public static string SharpInclude;
    public static string SharpUndef;
    public static string SharpLine;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.IL.IlRenderer : object {
    [ExtensionAttribute]
public static string GetOperandString(Instruction instruction);
    [ExtensionAttribute]
public static string GetInstructionString(Instruction instruction);
    [ExtensionAttribute]
public static string GetInstructionShortString(Instruction instruction);
    public static string PresentIlOffset(int ilOffset);
    [ExtensionAttribute]
public static ICodeTextWriter RenderIlInstruction(ICodeTextWriter writer, Instruction instruction);
}
public class JetBrains.Metadata.IL.Instruction : object {
    [NotNullAttribute]
private Opcode myCode;
    private int myOffset;
    private int mySize;
    private object myOperand;
    private MetadataToken myOperandToken;
    public int Offset { get; }
    public int Size { get; }
    public Opcode Code { get; }
    public object Operand { get; }
    public MetadataToken OperandToken { get; }
    public Instruction(int offset, int size, Opcode code, object operand, MetadataToken operandToken);
    public Instruction(Instruction instruction, object operand, MetadataToken operandToken);
    public int get_Offset();
    public int get_Size();
    public Opcode get_Code();
    public object get_Operand();
    public MetadataToken get_OperandToken();
    public sealed virtual Instruction Clone();
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.IL.InstructionEx : object {
    [ExtensionAttribute]
public static int GetInt32Operand(Instruction instruction);
    [ExtensionAttribute]
public static long GetInt64Operand(Instruction instruction);
    [ExtensionAttribute]
public static string GetStringOperand(Instruction instruction);
    [ExtensionAttribute]
public static float GetSingleOperand(Instruction instruction);
    [ExtensionAttribute]
public static double GetDoubleOperand(Instruction instruction);
    [ExtensionAttribute]
public static sbyte GetSByteOperand(Instruction instruction);
    [ExtensionAttribute]
public static MetadataToken GetTokenOperand(Instruction instruction);
    [ExtensionAttribute]
public static IMetadataType GetMetadataTypeOperand(Instruction instruction);
    [ExtensionAttribute]
public static FieldSpecification GetFieldSpecificationOperand(Instruction instruction);
    [ExtensionAttribute]
public static MethodSpecification GetMethodSpecificationOperand(Instruction instruction);
    [ExtensionAttribute]
public static MethodInstantiation GetMethodInstantiationOperand(Instruction instruction);
    [ExtensionAttribute]
public static Int32[] GetSwitchTargetsOperand(Instruction instruction);
    [ExtensionAttribute]
public static int GetBranchTargetOperand(Instruction instruction);
    [ExtensionAttribute]
public static int GetVariableIndexOperand(Instruction instruction);
    [ExtensionAttribute]
public static MethodSignature GetMethodSignatureOperand(Instruction instruction);
    [ExtensionAttribute]
public static int GetInstructionIndex(Instruction[] instructions, Instruction instruction);
    [ExtensionAttribute]
public static int GetInstructionIndexByOffset(Instruction[] instructions, int offset);
    [ExtensionAttribute]
public static int GetNextInstructionOffset(Instruction instruction);
    [ExtensionAttribute]
public static int GetBranchTargetInstructionOffset(Instruction instruction);
    [ExtensionAttribute]
public static int GetBranchTargetInstructionIndex(Instruction instruction, Instruction[] instructions);
    [ExtensionAttribute]
public static Int32[] GetSwitchTargetInstructionsOffsets(Instruction switchInstruction);
    [ExtensionAttribute]
public static MethodSpecification TryGetMethodSpecificationOperand(Instruction instruction);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.IL.InstructionStackEx : object {
    [ExtensionAttribute]
public static int GetMinimumStackHeightForCallAndCallvirt(Instruction instruction);
    [ExtensionAttribute]
public static int GetMinimumStackHeightForNewobj(Instruction instruction);
    [ExtensionAttribute]
public static int GetMinimumStackHeightForCalli(Instruction instruction);
    private static int GetMinimumStackHeightForRet(IMetadataMethod method);
    [ExtensionAttribute]
private static int GetRequiredStackItemsForVarpop(Instruction instruction, IMetadataMethod method);
    [ExtensionAttribute]
public static int GetMinimumStackHeight(Instruction instruction, IMetadataMethod method);
    [ExtensionAttribute]
public static int GetStackPushItemsCount(Instruction instruction);
    [ExtensionAttribute]
private static int GetStackPushItemsForVarpush(Instruction instruction);
    [ExtensionAttribute]
public static int GetRequiredPrefixPushCount(Instruction instruction, IMetadataMethod method);
}
public class JetBrains.Metadata.IL.Opcode : object {
    public static byte MultiByteOpCodePrefix;
    private string myName;
    private OpcodeType myType;
    private OpcodeValue myValue;
    private OperandType myOperandType;
    private StackBehavior myPopBehavior;
    private StackBehavior myPushBehavior;
    private FlowControl myFlowControl;
    private int mySize;
    private bool myEndsUnconditionalJumpBlock;
    private int myStackChange;
    public int StackChange { get; }
    public bool IsEndsUnconditionalJumpBlock { get; }
    public OperandType OperandType { get; }
    public FlowControl FlowControl { get; }
    public OpcodeType OpcodeType { get; }
    public StackBehavior StackBehaviorPop { get; }
    public StackBehavior StackBehaviorPush { get; }
    public int Size { get; }
    public OpcodeValue Value { get; }
    public string Name { get; }
    internal Opcode(string name, StackBehavior popBehavior, StackBehavior pushBehavior, OperandType operandType, OpcodeType type, int size, OpcodeValue value, FlowControl flowControl, bool endsUnconditionalJumpBlock, int stackChange);
    public int get_StackChange();
    public bool get_IsEndsUnconditionalJumpBlock();
    public OperandType get_OperandType();
    public FlowControl get_FlowControl();
    public OpcodeType get_OpcodeType();
    public StackBehavior get_StackBehaviorPop();
    public StackBehavior get_StackBehaviorPush();
    public int get_Size();
    public OpcodeValue get_Value();
    public string get_Name();
    public static bool op_Equality(Opcode left, Opcode right);
    public static bool op_Inequality(Opcode left, Opcode right);
    public bool Equals(Opcode other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.IL.OpcodeEx : object {
    [ExtensionAttribute]
public static OpCode ToEmitOpcode(Opcode opcode);
    [ExtensionAttribute]
public static Opcode ResolveNativeInt(Opcode opcode, bool is64Bit);
}
public static class JetBrains.Metadata.IL.OpcodeNames : object {
    public static string Add;
    public static string AddOvf;
    public static string AddOvfUn;
    public static string And;
    public static string Arglist;
    public static string Beq;
    public static string BeqS;
    public static string Bge;
    public static string BgeS;
    public static string BgeUn;
    public static string BgeUnS;
    public static string Bgt;
    public static string BgtS;
    public static string BgtUn;
    public static string BgtUnS;
    public static string Ble;
    public static string BleS;
    public static string BleUn;
    public static string BleUnS;
    public static string Blt;
    public static string BltS;
    public static string BltUn;
    public static string BltUnS;
    public static string BneUn;
    public static string BneUnS;
    public static string Box;
    public static string Br;
    public static string BrS;
    public static string Break;
    public static string Brfalse;
    public static string BrfalseS;
    public static string Brtrue;
    public static string BrtrueS;
    public static string Call;
    public static string Calli;
    public static string Callvirt;
    public static string Castclass;
    public static string Ceq;
    public static string Cgt;
    public static string CgtUn;
    public static string Ckfinite;
    public static string Clt;
    public static string CltUn;
    public static string Constrained;
    public static string ConvI;
    public static string ConvI1;
    public static string ConvI2;
    public static string ConvI4;
    public static string ConvI8;
    public static string ConvOvfI;
    public static string ConvOvfIUn;
    public static string ConvOvfI1;
    public static string ConvOvfI1Un;
    public static string ConvOvfI2;
    public static string ConvOvfI2Un;
    public static string ConvOvfI4;
    public static string ConvOvfI4Un;
    public static string ConvOvfI8;
    public static string ConvOvfI8Un;
    public static string ConvOvfU;
    public static string ConvOvfUUn;
    public static string ConvOvfU1;
    public static string ConvOvfU1Un;
    public static string ConvOvfU2;
    public static string ConvOvfU2Un;
    public static string ConvOvfU4;
    public static string ConvOvfU4Un;
    public static string ConvOvfU8;
    public static string ConvOvfU8Un;
    public static string ConvRUn;
    public static string ConvR4;
    public static string ConvR8;
    public static string ConvU;
    public static string ConvU1;
    public static string ConvU2;
    public static string ConvU4;
    public static string ConvU8;
    public static string Cpblk;
    public static string Cpobj;
    public static string Div;
    public static string DivUn;
    public static string Dup;
    public static string Endfilter;
    public static string Endfinally;
    public static string Initblk;
    public static string No;
    public static string Initobj;
    public static string Isinst;
    public static string Jmp;
    public static string Ldarg;
    public static string Ldarg0;
    public static string Ldarg1;
    public static string Ldarg2;
    public static string Ldarg3;
    public static string LdargS;
    public static string Ldarga;
    public static string LdargaS;
    public static string LdcI4;
    public static string LdcI40;
    public static string LdcI41;
    public static string LdcI42;
    public static string LdcI43;
    public static string LdcI44;
    public static string LdcI45;
    public static string LdcI46;
    public static string LdcI47;
    public static string LdcI48;
    public static string LdcI4M1;
    public static string LdcI4S;
    public static string LdcI8;
    public static string LdcR4;
    public static string LdcR8;
    public static string Ldelem;
    public static string LdelemI;
    public static string LdelemI1;
    public static string LdelemI2;
    public static string LdelemI4;
    public static string LdelemI8;
    public static string LdelemR4;
    public static string LdelemR8;
    public static string LdelemRef;
    public static string LdelemU1;
    public static string LdelemU2;
    public static string LdelemU4;
    public static string Ldelema;
    public static string Ldfld;
    public static string Ldflda;
    public static string Ldftn;
    public static string LdindI;
    public static string LdindI1;
    public static string LdindI2;
    public static string LdindI4;
    public static string LdindI8;
    public static string LdindR4;
    public static string LdindR8;
    public static string LdindRef;
    public static string LdindU1;
    public static string LdindU2;
    public static string LdindU4;
    public static string Ldlen;
    public static string Ldloc;
    public static string Ldloc0;
    public static string Ldloc1;
    public static string Ldloc2;
    public static string Ldloc3;
    public static string LdlocS;
    public static string Ldloca;
    public static string LdlocaS;
    public static string Ldnull;
    public static string Ldobj;
    public static string Ldsfld;
    public static string Ldsflda;
    public static string Ldstr;
    public static string Ldtoken;
    public static string Ldvirtftn;
    public static string Leave;
    public static string LeaveS;
    public static string Localloc;
    public static string Mkrefany;
    public static string Mul;
    public static string MulOvf;
    public static string MulOvfUn;
    public static string Neg;
    public static string Newarr;
    public static string Newobj;
    public static string Nop;
    public static string Not;
    public static string Or;
    public static string Pop;
    public static string Readonly;
    public static string Refanytype;
    public static string Refanyval;
    public static string Rem;
    public static string RemUn;
    public static string Ret;
    public static string Rethrow;
    public static string Shl;
    public static string Shr;
    public static string ShrUn;
    public static string Sizeof;
    public static string Starg;
    public static string StargS;
    public static string Stelem;
    public static string StelemI;
    public static string StelemI1;
    public static string StelemI2;
    public static string StelemI4;
    public static string StelemI8;
    public static string StelemR4;
    public static string StelemR8;
    public static string StelemRef;
    public static string Stfld;
    public static string StindI;
    public static string StindI1;
    public static string StindI2;
    public static string StindI4;
    public static string StindI8;
    public static string StindR4;
    public static string StindR8;
    public static string StindRef;
    public static string Stloc;
    public static string Stloc0;
    public static string Stloc1;
    public static string Stloc2;
    public static string Stloc3;
    public static string StlocS;
    public static string Stobj;
    public static string Stsfld;
    public static string Sub;
    public static string SubOvf;
    public static string SubOvfUn;
    public static string Switch;
    public static string Tail;
    public static string Throw;
    public static string Unaligned;
    public static string Unbox;
    public static string UnboxAny;
    public static string Unused;
    public static string Volatile;
    public static string Xor;
    public static string BrnullOpAlias;
    public static string BrnullSOpAlias;
    public static string BrzeroOpAlias;
    public static string BrzeroSOpAlias;
    public static string BrinstOpAlias;
    public static string BrinstSOpAlias;
    public static string LdindU8OpAlias;
    public static string LdelemU8OpAlias;
    public static string LdcI4M1XOpAlias;
    public static string EndfaultOpAlias;
    public static string LdelemAnyOpAlias;
    public static string StelemAnyOpAlias;
    public static HashSet`1<string> Names;
    private static OpcodeNames();
}
public static class JetBrains.Metadata.IL.Opcodes : object {
    public static Opcode Add;
    public static Opcode Add_ovf;
    public static Opcode Add_ovf_un;
    public static Opcode And;
    public static Opcode Arglist;
    public static Opcode Beq;
    public static Opcode Beq_s;
    public static Opcode Bge;
    public static Opcode Bge_s;
    public static Opcode Bge_un;
    public static Opcode Bge_un_s;
    public static Opcode Bgt;
    public static Opcode Bgt_s;
    public static Opcode Bgt_un;
    public static Opcode Bgt_un_s;
    public static Opcode Ble;
    public static Opcode Ble_s;
    public static Opcode Ble_un;
    public static Opcode Ble_un_s;
    public static Opcode Blt;
    public static Opcode Blt_s;
    public static Opcode Blt_un;
    public static Opcode Blt_un_s;
    public static Opcode Bne_un;
    public static Opcode Bne_un_s;
    public static Opcode Box;
    public static Opcode Br;
    public static Opcode Br_s;
    public static Opcode Break;
    public static Opcode Brfalse;
    public static Opcode Brfalse_s;
    public static Opcode Brtrue;
    public static Opcode Brtrue_s;
    public static Opcode Call;
    public static Opcode Calli;
    public static Opcode Callvirt;
    public static Opcode Castclass;
    public static Opcode Ceq;
    public static Opcode Cgt;
    public static Opcode Cgt_un;
    public static Opcode Ckfinite;
    public static Opcode Clt;
    public static Opcode Clt_un;
    public static Opcode Constrained;
    public static Opcode Conv_i;
    public static Opcode Conv_i1;
    public static Opcode Conv_i2;
    public static Opcode Conv_i4;
    public static Opcode Conv_i8;
    public static Opcode Conv_ovf_i;
    public static Opcode Conv_ovf_i_un;
    public static Opcode Conv_ovf_i1;
    public static Opcode Conv_ovf_i1_un;
    public static Opcode Conv_ovf_i2;
    public static Opcode Conv_ovf_i2_un;
    public static Opcode Conv_ovf_i4;
    public static Opcode Conv_ovf_i4_un;
    public static Opcode Conv_ovf_i8;
    public static Opcode Conv_ovf_i8_un;
    public static Opcode Conv_ovf_u;
    public static Opcode Conv_ovf_u_un;
    public static Opcode Conv_ovf_u1;
    public static Opcode Conv_ovf_u1_un;
    public static Opcode Conv_ovf_u2;
    public static Opcode Conv_ovf_u2_un;
    public static Opcode Conv_ovf_u4;
    public static Opcode Conv_ovf_u4_un;
    public static Opcode Conv_ovf_u8;
    public static Opcode Conv_ovf_u8_un;
    public static Opcode Conv_r_un;
    public static Opcode Conv_r4;
    public static Opcode Conv_r8;
    public static Opcode Conv_u;
    public static Opcode Conv_u1;
    public static Opcode Conv_u2;
    public static Opcode Conv_u4;
    public static Opcode Conv_u8;
    public static Opcode Cpblk;
    public static Opcode Cpobj;
    public static Opcode Div;
    public static Opcode Div_un;
    public static Opcode Dup;
    public static Opcode Endfilter;
    public static Opcode Endfinally;
    public static Opcode Initblk;
    public static Opcode No;
    public static Opcode Initobj;
    public static Opcode Isinst;
    public static Opcode Jmp;
    public static Opcode Ldarg;
    public static Opcode Ldarg_0;
    public static Opcode Ldarg_1;
    public static Opcode Ldarg_2;
    public static Opcode Ldarg_3;
    public static Opcode Ldarg_s;
    public static Opcode Ldarga;
    public static Opcode Ldarga_s;
    public static Opcode Ldc_i4;
    public static Opcode Ldc_i4_0;
    public static Opcode Ldc_i4_1;
    public static Opcode Ldc_i4_2;
    public static Opcode Ldc_i4_3;
    public static Opcode Ldc_i4_4;
    public static Opcode Ldc_i4_5;
    public static Opcode Ldc_i4_6;
    public static Opcode Ldc_i4_7;
    public static Opcode Ldc_i4_8;
    public static Opcode Ldc_i4_m1;
    public static Opcode Ldc_i4_s;
    public static Opcode Ldc_i8;
    public static Opcode Ldc_r4;
    public static Opcode Ldc_r8;
    public static Opcode Ldelem;
    public static Opcode Ldelem_i;
    public static Opcode Ldelem_i1;
    public static Opcode Ldelem_i2;
    public static Opcode Ldelem_i4;
    public static Opcode Ldelem_i8;
    public static Opcode Ldelem_r4;
    public static Opcode Ldelem_r8;
    public static Opcode Ldelem_ref;
    public static Opcode Ldelem_u1;
    public static Opcode Ldelem_u2;
    public static Opcode Ldelem_u4;
    public static Opcode Ldelema;
    public static Opcode Ldfld;
    public static Opcode Ldflda;
    public static Opcode Ldftn;
    public static Opcode Ldind_i;
    public static Opcode Ldind_i1;
    public static Opcode Ldind_i2;
    public static Opcode Ldind_i4;
    public static Opcode Ldind_i8;
    public static Opcode Ldind_r4;
    public static Opcode Ldind_r8;
    public static Opcode Ldind_ref;
    public static Opcode Ldind_u1;
    public static Opcode Ldind_u2;
    public static Opcode Ldind_u4;
    public static Opcode Ldlen;
    public static Opcode Ldloc;
    public static Opcode Ldloc_0;
    public static Opcode Ldloc_1;
    public static Opcode Ldloc_2;
    public static Opcode Ldloc_3;
    public static Opcode Ldloc_s;
    public static Opcode Ldloca;
    public static Opcode Ldloca_s;
    public static Opcode Ldnull;
    public static Opcode Ldobj;
    public static Opcode Ldsfld;
    public static Opcode Ldsflda;
    public static Opcode Ldstr;
    public static Opcode Ldtoken;
    public static Opcode Ldvirtftn;
    public static Opcode Leave;
    public static Opcode Leave_s;
    public static Opcode Localloc;
    public static Opcode Mkrefany;
    public static Opcode Mul;
    public static Opcode Mul_ovf;
    public static Opcode Mul_ovf_un;
    public static Opcode Neg;
    public static Opcode Newarr;
    public static Opcode Newobj;
    public static Opcode Nop;
    public static Opcode Not;
    public static Opcode Or;
    public static Opcode Pop;
    public static Opcode Readonly;
    public static Opcode Refanytype;
    public static Opcode Refanyval;
    public static Opcode Rem;
    public static Opcode Rem_un;
    public static Opcode Ret;
    public static Opcode Rethrow;
    private static Opcode[] OurMultiByteOpcodes;
    private static Opcode[] OurSingleByteOpcodes;
    public static Opcode Shl;
    public static Opcode Shr;
    public static Opcode Shr_un;
    public static Opcode Sizeof;
    public static Opcode Starg;
    public static Opcode Starg_s;
    public static Opcode Stelem;
    public static Opcode Stelem_i;
    public static Opcode Stelem_i1;
    public static Opcode Stelem_i2;
    public static Opcode Stelem_i4;
    public static Opcode Stelem_i8;
    public static Opcode Stelem_r4;
    public static Opcode Stelem_r8;
    public static Opcode Stelem_ref;
    public static Opcode Stfld;
    public static Opcode Stind_i;
    public static Opcode Stind_i1;
    public static Opcode Stind_i2;
    public static Opcode Stind_i4;
    public static Opcode Stind_i8;
    public static Opcode Stind_r4;
    public static Opcode Stind_r8;
    public static Opcode Stind_ref;
    public static Opcode Stloc;
    public static Opcode Stloc_0;
    public static Opcode Stloc_1;
    public static Opcode Stloc_2;
    public static Opcode Stloc_3;
    public static Opcode Stloc_s;
    public static Opcode Stobj;
    public static Opcode Stsfld;
    public static Opcode Sub;
    public static Opcode Sub_ovf;
    public static Opcode Sub_ovf_un;
    public static Opcode Switch;
    public static Opcode Tail;
    public static Opcode Throw;
    public static Opcode Unaligned;
    public static Opcode Unbox;
    public static Opcode Unbox_any;
    public static Opcode Unused;
    public static Opcode Volatile;
    public static Opcode Xor;
    public static Opcode[] SingleByteOpcodes { get; }
    public static Opcode[] MultiByteOpcodes { get; }
    private static Opcodes();
    public static Opcode[] get_SingleByteOpcodes();
    public static Opcode[] get_MultiByteOpcodes();
}
public enum JetBrains.Metadata.IL.OpcodeType : Enum {
    public int value__;
    public static OpcodeType Prefix;
    public static OpcodeType ObjectModel;
    public static OpcodeType Primitive;
    public static OpcodeType Macro;
    public static OpcodeType Internal;
}
public enum JetBrains.Metadata.IL.OpcodeValue : Enum {
    public ushort value__;
    public static OpcodeValue Nop;
    public static OpcodeValue Break;
    public static OpcodeValue Ldarg_0;
    public static OpcodeValue Ldarg_1;
    public static OpcodeValue Ldarg_2;
    public static OpcodeValue Ldarg_3;
    public static OpcodeValue Ldloc_0;
    public static OpcodeValue Ldloc_1;
    public static OpcodeValue Ldloc_2;
    public static OpcodeValue Ldloc_3;
    public static OpcodeValue Stloc_0;
    public static OpcodeValue Stloc_1;
    public static OpcodeValue Stloc_2;
    public static OpcodeValue Stloc_3;
    public static OpcodeValue Ldarg_s;
    public static OpcodeValue Ldarga_s;
    public static OpcodeValue Starg_s;
    public static OpcodeValue Ldloc_s;
    public static OpcodeValue Ldloca_s;
    public static OpcodeValue Stloc_s;
    public static OpcodeValue Ldnull;
    public static OpcodeValue Ldc_i4_m1;
    public static OpcodeValue Ldc_i4_0;
    public static OpcodeValue Ldc_i4_1;
    public static OpcodeValue Ldc_i4_2;
    public static OpcodeValue Ldc_i4_3;
    public static OpcodeValue Ldc_i4_4;
    public static OpcodeValue Ldc_i4_5;
    public static OpcodeValue Ldc_i4_6;
    public static OpcodeValue Ldc_i4_7;
    public static OpcodeValue Ldc_i4_8;
    public static OpcodeValue Ldc_i4_s;
    public static OpcodeValue Ldc_i4;
    public static OpcodeValue Ldc_i8;
    public static OpcodeValue Ldc_r4;
    public static OpcodeValue Ldc_r8;
    public static OpcodeValue Dup;
    public static OpcodeValue Pop;
    public static OpcodeValue Jmp;
    public static OpcodeValue Call;
    public static OpcodeValue Calli;
    public static OpcodeValue Ret;
    public static OpcodeValue Br_s;
    public static OpcodeValue Brfalse_s;
    public static OpcodeValue Brtrue_s;
    public static OpcodeValue Beq_s;
    public static OpcodeValue Bge_s;
    public static OpcodeValue Bgt_s;
    public static OpcodeValue Ble_s;
    public static OpcodeValue Blt_s;
    public static OpcodeValue Bne_un_s;
    public static OpcodeValue Bge_un_s;
    public static OpcodeValue Bgt_un_s;
    public static OpcodeValue Ble_un_s;
    public static OpcodeValue Blt_un_s;
    public static OpcodeValue Br;
    public static OpcodeValue Brfalse;
    public static OpcodeValue Brtrue;
    public static OpcodeValue Beq;
    public static OpcodeValue Bge;
    public static OpcodeValue Bgt;
    public static OpcodeValue Ble;
    public static OpcodeValue Blt;
    public static OpcodeValue Bne_un;
    public static OpcodeValue Bge_un;
    public static OpcodeValue Bgt_un;
    public static OpcodeValue Ble_un;
    public static OpcodeValue Blt_un;
    public static OpcodeValue Switch;
    public static OpcodeValue Ldind_i1;
    public static OpcodeValue Ldind_u1;
    public static OpcodeValue Ldind_i2;
    public static OpcodeValue Ldind_u2;
    public static OpcodeValue Ldind_i4;
    public static OpcodeValue Ldind_u4;
    public static OpcodeValue Ldind_i8;
    public static OpcodeValue Ldind_i;
    public static OpcodeValue Ldind_r4;
    public static OpcodeValue Ldind_r8;
    public static OpcodeValue Ldind_ref;
    public static OpcodeValue Stind_ref;
    public static OpcodeValue Stind_i1;
    public static OpcodeValue Stind_i2;
    public static OpcodeValue Stind_i4;
    public static OpcodeValue Stind_i8;
    public static OpcodeValue Stind_r4;
    public static OpcodeValue Stind_r8;
    public static OpcodeValue Add;
    public static OpcodeValue Sub;
    public static OpcodeValue Mul;
    public static OpcodeValue Div;
    public static OpcodeValue Div_un;
    public static OpcodeValue Rem;
    public static OpcodeValue Rem_un;
    public static OpcodeValue And;
    public static OpcodeValue Or;
    public static OpcodeValue Xor;
    public static OpcodeValue Shl;
    public static OpcodeValue Shr;
    public static OpcodeValue Shr_un;
    public static OpcodeValue Neg;
    public static OpcodeValue Not;
    public static OpcodeValue Conv_i1;
    public static OpcodeValue Conv_i2;
    public static OpcodeValue Conv_i4;
    public static OpcodeValue Conv_i8;
    public static OpcodeValue Conv_r4;
    public static OpcodeValue Conv_r8;
    public static OpcodeValue Conv_u4;
    public static OpcodeValue Conv_u8;
    public static OpcodeValue Callvirt;
    public static OpcodeValue Cpobj;
    public static OpcodeValue Ldobj;
    public static OpcodeValue Ldstr;
    public static OpcodeValue Newobj;
    public static OpcodeValue Castclass;
    public static OpcodeValue Isinst;
    public static OpcodeValue Conv_r_un;
    public static OpcodeValue Unbox;
    public static OpcodeValue Throw;
    public static OpcodeValue Ldfld;
    public static OpcodeValue Ldflda;
    public static OpcodeValue Stfld;
    public static OpcodeValue Ldsfld;
    public static OpcodeValue Ldsflda;
    public static OpcodeValue Stsfld;
    public static OpcodeValue Stobj;
    public static OpcodeValue Conv_ovf_i1_un;
    public static OpcodeValue Conv_ovf_i2_un;
    public static OpcodeValue Conv_ovf_i4_un;
    public static OpcodeValue Conv_ovf_i8_un;
    public static OpcodeValue Conv_ovf_u1_un;
    public static OpcodeValue Conv_ovf_u2_un;
    public static OpcodeValue Conv_ovf_u4_un;
    public static OpcodeValue Conv_ovf_u8_un;
    public static OpcodeValue Conv_ovf_i_un;
    public static OpcodeValue Conv_ovf_u_un;
    public static OpcodeValue Box;
    public static OpcodeValue Newarr;
    public static OpcodeValue Ldlen;
    public static OpcodeValue Ldelema;
    public static OpcodeValue Ldelem_i1;
    public static OpcodeValue Ldelem_u1;
    public static OpcodeValue Ldelem_i2;
    public static OpcodeValue Ldelem_u2;
    public static OpcodeValue Ldelem_i4;
    public static OpcodeValue Ldelem_u4;
    public static OpcodeValue Ldelem_i8;
    public static OpcodeValue Ldelem_i;
    public static OpcodeValue Ldelem_r4;
    public static OpcodeValue Ldelem_r8;
    public static OpcodeValue Ldelem_ref;
    public static OpcodeValue Stelem_i;
    public static OpcodeValue Stelem_i1;
    public static OpcodeValue Stelem_i2;
    public static OpcodeValue Stelem_i4;
    public static OpcodeValue Stelem_i8;
    public static OpcodeValue Stelem_r4;
    public static OpcodeValue Stelem_r8;
    public static OpcodeValue Stelem_ref;
    public static OpcodeValue Ldelem;
    public static OpcodeValue Stelem;
    public static OpcodeValue Unbox_any;
    public static OpcodeValue Conv_ovf_i1;
    public static OpcodeValue Conv_ovf_u1;
    public static OpcodeValue Conv_ovf_i2;
    public static OpcodeValue Conv_ovf_u2;
    public static OpcodeValue Conv_ovf_i4;
    public static OpcodeValue Conv_ovf_u4;
    public static OpcodeValue Conv_ovf_i8;
    public static OpcodeValue Conv_ovf_u8;
    public static OpcodeValue Refanyval;
    public static OpcodeValue Ckfinite;
    public static OpcodeValue Mkrefany;
    public static OpcodeValue Ldtoken;
    public static OpcodeValue Conv_u2;
    public static OpcodeValue Conv_u1;
    public static OpcodeValue Conv_i;
    public static OpcodeValue Conv_ovf_i;
    public static OpcodeValue Conv_ovf_u;
    public static OpcodeValue Add_ovf;
    public static OpcodeValue Add_ovf_un;
    public static OpcodeValue Mul_ovf;
    public static OpcodeValue Mul_ovf_un;
    public static OpcodeValue Sub_ovf;
    public static OpcodeValue Sub_ovf_un;
    public static OpcodeValue Endfinally;
    public static OpcodeValue Leave;
    public static OpcodeValue Leave_s;
    public static OpcodeValue Stind_i;
    public static OpcodeValue Conv_u;
    public static OpcodeValue Arglist;
    public static OpcodeValue Ceq;
    public static OpcodeValue Cgt;
    public static OpcodeValue Cgt_un;
    public static OpcodeValue Clt;
    public static OpcodeValue Clt_un;
    public static OpcodeValue Ldftn;
    public static OpcodeValue Ldvirtftn;
    public static OpcodeValue Ldarg;
    public static OpcodeValue Ldarga;
    public static OpcodeValue Starg;
    public static OpcodeValue Ldloc;
    public static OpcodeValue Ldloca;
    public static OpcodeValue Stloc;
    public static OpcodeValue Localloc;
    public static OpcodeValue Endfilter;
    public static OpcodeValue Unaligned;
    public static OpcodeValue Volatile;
    public static OpcodeValue Tailcall;
    public static OpcodeValue Initobj;
    public static OpcodeValue Constrained;
    public static OpcodeValue Cpblk;
    public static OpcodeValue Initblk;
    public static OpcodeValue No;
    public static OpcodeValue Rethrow;
    public static OpcodeValue Sizeof;
    public static OpcodeValue Refanytype;
    public static OpcodeValue Readonly;
    public static OpcodeValue Unused;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.IL.OpcodeValueEx : object {
    [ExtensionAttribute]
public static bool IsUnsigned(OpcodeValue opcodeValue);
    [ExtensionAttribute]
public static OpcodeValue ToFullForm(OpcodeValue opcodeValue);
    [ExtensionAttribute]
public static ElementType ToConversionElementType(OpcodeValue opcodeValue);
}
public enum JetBrains.Metadata.IL.OperandType : Enum {
    public int value__;
    public static OperandType Int32;
    public static OperandType Int64;
    public static OperandType None;
    public static OperandType TypeToken;
    public static OperandType SwitchTargets;
    public static OperandType ShortVariableIndex;
    public static OperandType SByte;
    public static OperandType Double;
    public static OperandType SignatureToken;
    public static OperandType Single;
    public static OperandType ShortBranchTarget;
    public static OperandType FieldToken;
    public static OperandType String;
    public static OperandType MethodToken;
    public static OperandType BranchTarget;
    public static OperandType Token;
    public static OperandType VariableIndex;
}
public enum JetBrains.Metadata.IL.StackBehavior : Enum {
    public int value__;
    public static StackBehavior Popref_popi_popi;
    public static StackBehavior Popref_popi_popr4;
    public static StackBehavior Popref_popi_pop1;
    public static StackBehavior Popref_popi_popref;
    public static StackBehavior Popi;
    public static StackBehavior Popi_popi_popi;
    public static StackBehavior Varpop;
    public static StackBehavior Push1_push1;
    public static StackBehavior Popi_popi8;
    public static StackBehavior Popi_popr8;
    public static StackBehavior Pushref;
    public static StackBehavior Popi_popr4;
    public static StackBehavior Popi_popi;
    public static StackBehavior Pushi8;
    public static StackBehavior Pushr4;
    public static StackBehavior Pop1_pop1;
    public static StackBehavior Popref_pop1;
    public static StackBehavior Popi_pop1;
    public static StackBehavior Popref_popi_popi8;
    public static StackBehavior Pop1;
    public static StackBehavior Pop0;
    public static StackBehavior Pushr8;
    public static StackBehavior Popref_popi;
    public static StackBehavior Pushi;
    public static StackBehavior Varpush;
    public static StackBehavior Popref_popi_popr8;
    public static StackBehavior Push0;
    public static StackBehavior Push1;
    public static StackBehavior Popref;
}
public class JetBrains.Metadata.IL.TypeIlCode : IlCodeBase {
    [CompilerGeneratedAttribute]
private IMetadataTypeInfo <Type>k__BackingField;
    public IMetadataTypeInfo Type { get; }
    public TypeIlCode(IMetadataTypeInfo metadataType, IImageBodyReader imageBodyReader);
    [CompilerGeneratedAttribute]
public IMetadataTypeInfo get_Type();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.AccessibilityEx : object {
    [ExtensionAttribute]
public static MemberAccessibility GetOwnAccessibility(IMetadataTypeMember typeMember);
    [ExtensionAttribute]
public static MemberAccessibility GetActualAccessibility(IMetadataTypeMember typeMember);
    [ExtensionAttribute]
private static bool HasExplicitAccessibilityInMetadata(IMetadataTypeMember typeMember);
    [ExtensionAttribute]
private static int GetWeight(MemberAccessibility accessibility);
    [ExtensionAttribute]
private static MemberAccessibility Combine(MemberAccessibility accessibility1, MemberAccessibility accessibility2);
    [ExtensionAttribute]
private static bool IsAccessibleOutsideAssembly(MemberAccessibility actualAccessibility, bool internalsVisible);
    [ExtensionAttribute]
public static bool IsAccessibleOutsideAssembly(IMetadataTypeMember typeMember, bool internalsVisible);
    [ExtensionAttribute]
public static bool IsNullableContextInherited(IMetadataTypeMember typeMember);
}
public class JetBrains.Metadata.Reader.API.AnonymousDelegateType : SentinelTypeBase {
    public static IMetadataType Instance;
    public string FullName { get; }
    public bool IsResolved { get; }
    private static AnonymousDelegateType();
    public virtual string get_FullName();
    public virtual bool get_IsResolved();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Mvid}-{Size}")]
public class JetBrains.Metadata.Reader.API.AssemblyId : ValueType {
    [CompilerGeneratedAttribute]
private Guid <Mvid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    public static AssemblyId Empty;
    public static IUnsafeMarshaller`1<AssemblyId> AssemblyIdMarshaller;
    public Guid Mvid { get; }
    public int Size { get; }
    public AssemblyId(Guid mvid, int size);
    public AssemblyId(Guid mvid, long size);
    private static AssemblyId();
    [CompilerGeneratedAttribute]
public Guid get_Mvid();
    [CompilerGeneratedAttribute]
public int get_Size();
    public bool Equals(AssemblyId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyId left, AssemblyId right);
    public static bool op_Inequality(AssemblyId left, AssemblyId right);
    public static AssemblyId TryParse(string s);
    public virtual string ToString();
    public static AssemblyId Read(UnsafeReader reader);
    public static void Write(UnsafeWriter writer, AssemblyId id);
}
public class JetBrains.Metadata.Reader.API.AssemblyLocation : object {
    private static Key`1<AssemblyLocation> ourEmptyAssemblyLocation;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <Location>k__BackingField;
    [NotNullAttribute]
public VirtualFileSystemPath Location { get; }
    public VirtualFileSystemPath AssemblyPhysicalPath { get; }
    public VirtualFileSystemPath ContainerPhysicalPath { get; }
    public bool IsEmpty { get; }
    public IInteractionContext Context { get; }
    public string Name { get; }
    public string NameWithoutExtension { get; }
    public string ExtensionWithDot { get; }
    public string ShortPresentation { get; }
    public AssemblyLocation(VirtualFileSystemPath location);
    private static AssemblyLocation();
    public static AssemblyLocation GetEmpty(IInteractionContext context);
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_Location();
    public sealed virtual VirtualFileSystemPath get_AssemblyPhysicalPath();
    public sealed virtual VirtualFileSystemPath get_ContainerPhysicalPath();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual Stream OpenForReading();
    public sealed virtual T Visit(IAssemblyLocationVisitor`1<T> visitor);
    public sealed virtual IInteractionContext get_Context();
    [ContractAnnotationAttribute("null => null; notnull => notnull")]
public static AssemblyLocation op_Explicit(VirtualFileSystemPath assemblyLocation);
    private bool Equals(AssemblyLocation other);
    public sealed virtual bool Equals(IAssemblyLocation other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(AssemblyLocation left, AssemblyLocation right);
    public static bool op_Inequality(AssemblyLocation left, AssemblyLocation right);
    public virtual int GetHashCode();
    public sealed virtual string get_Name();
    public sealed virtual string get_NameWithoutExtension();
    public sealed virtual string get_ExtensionWithDot();
    public sealed virtual IAssemblyLocation GetNeighbor(string neighborName);
    public sealed virtual string get_ShortPresentation();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.AssemblyLocationEx : object {
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => true")]
public static bool IsNullOrEmpty(IAssemblyLocation assemblyLocation);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool Exists(IAssemblyLocation assemblyLocation);
    [ExtensionAttribute]
public static DateTime GetModificationTimeUtc(IAssemblyLocation assemblyLocation);
    [ExtensionAttribute]
public static DateTime GetCreationTimeUtc(IAssemblyLocation assemblyLocation);
    [ExtensionAttribute]
public static void ReadStream(IAssemblyLocation assemblyLocation, Action`1<Stream> Read);
    [ExtensionAttribute]
public static T ReadStream(IAssemblyLocation assemblyLocation, Func`2<Stream, T> Read);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
[CanBeNullAttribute]
public static IAssemblyLocation ToAssemblyLocation(FileSystemPath assemblyPath);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
[CanBeNullAttribute]
public static IAssemblyLocation ToAssemblyLocation(VirtualFileSystemPath assemblyPath);
    [ExtensionAttribute]
[NotNullAttribute]
public static VirtualFileSystemPath GetTemporaryPhysicalPath(IAssemblyLocation assemblyLocation, Lifetime lifetime);
    [ExtensionAttribute]
[ContractAnnotationAttribute("assemblyLocation: null => null; assemblyLocation: notnull => notnull")]
[CanBeNullAttribute]
public static IAssemblyLocation Intern(IAssemblyLocation assemblyLocation, DataIntern`1<VirtualFileSystemPath> fileSystemPathIntern);
    [ExtensionAttribute]
public static void DoWithAssemblyPhysicalPath(IAssemblyLocation assemblyLocation, Action`1<VirtualFileSystemPath> assemblyPhysicalPathAction);
    [ExtensionAttribute]
public static void Copy(IAssemblyLocation from, VirtualFileSystemPath to);
    [ExtensionAttribute]
public static bool InTheSameFolderOrSubfolder(IAssemblyLocation file, IAssemblyLocation anchorFile);
    [IteratorStateMachineAttribute("JetBrains.Metadata.Reader.API.AssemblyLocationEx/<EnumerateBundleFiles>d__13")]
[ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<BundleFileEntryLocation> EnumerateBundleFiles(BundleManifest bundleHeader, VirtualFileSystemPath bundleLocation);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<BundleFileEntryLocation> EnumerateBundleFiles(BundleFileEntryLocation bundleElement);
    [ExtensionAttribute]
public static Byte[] ReadAllBytes(IAssemblyLocation assemblyLocation);
    [ExtensionAttribute]
public static bool IsInsideBundle(IAssemblyLocation assemblyLocation);
    [ExtensionAttribute]
public static bool IsBclAssemblyInsideBundle(IAssemblyLocation assemblyLocation);
}
public class JetBrains.Metadata.Reader.API.AssemblyReferenceWithSource : object {
    private VirtualFileSystemPath mySourcePath;
    private AssemblyNameInfo myAssemblyNameInfo;
    [NotNullAttribute]
public AssemblyNameInfo AssemblyNameInfo { get; }
    [NotNullAttribute]
public VirtualFileSystemPath SourcePath { get; }
    public AssemblyReferenceWithSource(VirtualFileSystemPath sourcePath, AssemblyNameInfo assemblyNameInfo);
    protected bool Equals(AssemblyReferenceWithSource other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public AssemblyNameInfo get_AssemblyNameInfo();
    public VirtualFileSystemPath get_SourcePath();
}
public class JetBrains.Metadata.Reader.API.AssemblyResolverAppDomainAssemblyResolver : object {
    public AssemblyResolverAppDomainAssemblyResolver(Lifetime lifetime, IFolderBasedAssemblyResolver metaresolver);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.AssemblyResolverEx : object {
    [ExtensionAttribute]
public static string DumpDebugInformation(IAssemblyResolver resolver);
}
public class JetBrains.Metadata.Reader.API.AssemblyResolverOnFolders : object {
    private static ILogger Logger;
    private IMetadataProvider myMetadataProvider;
    private JetHashSet`1<VirtualFileSystemPath> myPaths;
    private ConcurrentDictionary`2<AssemblyNameInfo, VirtualFileSystemPath> myPathCache;
    [CanBeNullAttribute]
private Func`2<VirtualFileSystemPath, bool> myFileExists;
    public AssemblyResolverOnFolders(VirtualFileSystemPath[] folders);
    public AssemblyResolverOnFolders(IEnumerable`1<VirtualFileSystemPath> folders);
    public AssemblyResolverOnFolders(IMetadataProvider metadataProvider, VirtualFileSystemPath[] folders);
    public AssemblyResolverOnFolders(IMetadataProvider metadataProvider, IEnumerable`1<VirtualFileSystemPath> folders, Func`2<VirtualFileSystemPath, bool> filesExists);
    private static AssemblyResolverOnFolders();
    public void AddPath(VirtualFileSystemPath folder);
    public sealed virtual IMetadataAccess ResolveAssembly(AssemblyNameInfo nameToResolve, IAssemblyLocation& assemblyLocation, IModuleReferenceResolveContext moduleReferenceResolveContext);
    [CanBeNullAttribute]
public sealed virtual VirtualFileSystemPath TryResolveAssemblyPath(AssemblyNameInfo nameToResolve);
    public sealed virtual void DumpDebugInformation(IndentedTextWriter textWriter);
    public sealed virtual bool IsUnderResolvePaths(VirtualFileSystemPath path);
}
public enum JetBrains.Metadata.Reader.API.ClassLayoutType : Enum {
    public int value__;
    public static ClassLayoutType Auto;
    public static ClassLayoutType Sequential;
    public static ClassLayoutType Explicit;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.ClrTypeNameExtensions : object {
    [ExtensionAttribute]
public static bool IsEmpty(IClrTypeName name);
    [ExtensionAttribute]
public static string GetNamespaceName(IClrTypeName name);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IClrTypeName GetParent(IClrTypeName name);
    [ExtensionAttribute]
public static bool GetIsInnerType(IClrTypeName name);
    [ExtensionAttribute]
public static string TypeParametersCountStrippedFullName(IClrTypeName name);
    [NotNullAttribute]
[PureAttribute]
public static string StripTypeParametersCount(string typeName);
}
public enum JetBrains.Metadata.Reader.API.CodeType : Enum {
    public int value__;
    public static CodeType IL;
    public static CodeType NATIVE;
    public static CodeType OPTIL;
    public static CodeType RUNTIME;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.CompilerSpecificAttributesExtensions : object {
    public static ClassLayoutType DefaultLayoutTypeForStruct;
    public static ClassLayoutType DefaultLayoutTypeForNonStruct;
    [CanBeNullAttribute]
private static ICompilerSpecificAttribute CreateMarshalAsAttribute(IBlob blob, IMetadataAssembly context);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ICompilerSpecificAttribute[] GetCompilerSpecificAttributes(IMetadataEntity entity);
    [NotNullAttribute]
public static IEnumerable`1<ICompilerSpecificAttribute> CreateTypeForwardedToAttributes(IMetadataAssembly assembly);
    [NotNullAttribute]
private static ICompilerSpecificAttribute[] GetAssemblyAttributes(IMetadataAssembly assembly);
    [NotNullAttribute]
private static ICompilerSpecificAttribute[] GetReturnValueAttributes(IMetadataReturnValue returnValue);
    [ExtensionAttribute]
[NotNullAttribute]
private static ICompilerSpecificAttribute[] GetParameterAttributes(IMetadataParameter parameter);
    [ExtensionAttribute]
[NotNullAttribute]
private static ICompilerSpecificAttribute[] GetFieldAttributes(IMetadataField field);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICompilerSpecificAttribute[] GetMethodCompilerSpecificAttributes(IMetadataMethod method, string methodName);
    [ExtensionAttribute]
[PureAttribute]
private static bool HasNamedParameter(IMetadataTypeInfo customAttributeType, string parameterName);
    [PureAttribute]
public static ClassLayoutType GetDefaultLayoutType(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
[NotNullAttribute]
private static ICompilerSpecificAttribute[] GetTypeInfoAttributes(IMetadataTypeInfo typeInfo);
    [CanBeNullAttribute]
public static ICompilerSpecificAttribute GetStructLayoutAttribute(IMetadataTypeInfo typeInfo);
    [IteratorStateMachineAttribute("JetBrains.Metadata.Reader.API.CompilerSpecificAttributesExtensions/<MakeStructLayoutAttributeNamedArguments>d__14")]
private static IEnumerable`1<Pair`2<string, MetadataAttributeValue>> MakeStructLayoutAttributeNamedArguments(IMetadataAssembly corlib, IMetadataTypeInfo typeInfo);
    [IteratorStateMachineAttribute("JetBrains.Metadata.Reader.API.CompilerSpecificAttributesExtensions/<MakeDllImportNamedArguments>d__15")]
private static IEnumerable`1<Pair`2<string, MetadataAttributeValue>> MakeDllImportNamedArguments(IMetadataAssembly corlib, IMetadataMethod method, string methodName);
}
public class JetBrains.Metadata.Reader.API.CopyingMetadataTypeTransformer : object {
    public virtual IMetadataType TransformArrayType(IMetadataArrayType arrayType);
    public virtual IMetadataType TransformClassType(IMetadataClassType classType);
    public virtual IMetadataType TransformTupleType(IMetadataTupleType tupleType);
    public virtual IMetadataType TransformPointerType(IMetadataPointerType pointerType);
    public virtual IMetadataType TransformReferenceType(IMetadataReferenceType referenceType);
    public virtual IMetadataType TransformTypeParameterReferenceType(IMetadataTypeParameterReferenceType typeParameterReferenceType);
    public sealed virtual IMetadataType TransformFunctionPointerType(IMetadataFunctionPointerType functionPointerType);
    public sealed virtual IMetadataType TransformBoxedType(IMetadataBoxedType boxedType);
}
public static class JetBrains.Metadata.Reader.API.CurrentRuntimeAssemblyResolvers : object {
    public static IFolderBasedAssemblyResolver CreateInstance(Nullable`1<GacResolvePreferences> gacResolvePreferences, RuntimeAssemblySources sources);
}
public class JetBrains.Metadata.Reader.API.DiagnosticResolveContext : ConcurrentUserDataHolder {
    private static IModuleReferenceResolveContext myInstance;
    private string myUniqueName;
    private AssemblyNameAndLocation myOriginator;
    public string UniqueName { get; }
    public AssemblyNameAndLocation Originator { get; }
    public TargetFrameworkId TargetFramework { get; }
    public static IModuleReferenceResolveContext Instance { get; }
    public DiagnosticResolveContext(string sUniqueName, AssemblyNameAndLocation originator);
    private static DiagnosticResolveContext();
    public sealed virtual string get_UniqueName();
    public sealed virtual bool IsValid();
    public sealed virtual AssemblyNameAndLocation get_Originator();
    public sealed virtual TargetFrameworkId get_TargetFramework();
    public sealed virtual void Write(BinaryWriter writer);
    public static IModuleReferenceResolveContext get_Instance();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.API.DotNetFrameworkCurrentRuntimeAssemblyResolver : object {
    private LocalLazy`2<AssemblyResolverOnFolders, RuntimeAssemblySources> myAdditionalFolders;
    [CanBeNullAttribute]
private DotNetFrameworkGacAssemblyResolver myGac;
    public DotNetFrameworkCurrentRuntimeAssemblyResolver(Nullable`1<GacResolvePreferences> gacResolvePreferences, RuntimeAssemblySources sources);
    public sealed virtual void DumpDebugInformation(IndentedTextWriter textWriter);
    public sealed virtual bool IsUnderResolvePaths(VirtualFileSystemPath path);
    public sealed virtual IMetadataAccess ResolveAssembly(AssemblyNameInfo name, IAssemblyLocation& assemblyLocation, IModuleReferenceResolveContext moduleReferenceResolveContext);
    public sealed virtual VirtualFileSystemPath TryResolveAssemblyPath(AssemblyNameInfo name);
    private static AssemblyResolverOnFolders CreateAdditionalFoldersResolver(RuntimeAssemblySources runtimeAssemblySources);
}
public class JetBrains.Metadata.Reader.API.DotNetFrameworkGacAssemblyResolver : object {
    private ILogger Logger;
    private GacResolvePreferences myPreferences;
    private DotNetFrameworkGacAssemblyResolver(GacResolvePreferences preferences);
    [NotNullAttribute]
public static DotNetFrameworkGacAssemblyResolver CreateOnCurrentRuntimeGac(GacResolvePreferences preferences);
    public virtual VirtualFileSystemPath TryResolveAssemblyPath(AssemblyNameInfo name);
    public sealed virtual IMetadataAccess ResolveAssembly(AssemblyNameInfo name, IAssemblyLocation& assemblyLocation, IModuleReferenceResolveContext moduleReferenceResolveContext);
    public sealed virtual bool IsUnderResolvePaths(VirtualFileSystemPath path);
    public sealed virtual void DumpDebugInformation(IndentedTextWriter textWriter);
}
public class JetBrains.Metadata.Reader.API.DotNetRuntimeAssemblyResolver : object {
    private DotNetRuntime myDotNetRuntime;
    public DotNetRuntimeAssemblyResolver(DotNetRuntime dotNetRuntime);
    public static IFolderBasedAssemblyResolver FromPlatformId(TargetFrameworkId targetFrameworkId);
    public static IFolderBasedAssemblyResolver FromDotNetRuntime(DotNetRuntime dotNetRuntime);
    public sealed virtual void DumpDebugInformation(IndentedTextWriter textWriter);
    public sealed virtual bool IsUnderResolvePaths(VirtualFileSystemPath path);
    public sealed virtual IMetadataAccess ResolveAssembly(AssemblyNameInfo name, IAssemblyLocation& assemblyLocation, IModuleReferenceResolveContext moduleReferenceResolveContext);
    public sealed virtual VirtualFileSystemPath TryResolveAssemblyPath(AssemblyNameInfo name);
}
public enum JetBrains.Metadata.Reader.API.ElementType : Enum {
    public byte value__;
    public static ElementType End;
    public static ElementType Void;
    public static ElementType Bool;
    public static ElementType Char;
    public static ElementType I1;
    public static ElementType U1;
    public static ElementType I2;
    public static ElementType U2;
    public static ElementType I4;
    public static ElementType U4;
    public static ElementType I8;
    public static ElementType U8;
    public static ElementType R4;
    public static ElementType R8;
    public static ElementType String;
    public static ElementType Ptr;
    public static ElementType ByRef;
    public static ElementType ValueType;
    public static ElementType Class;
    public static ElementType Var;
    public static ElementType Array;
    public static ElementType GenericInst;
    public static ElementType TypedByRef;
    public static ElementType I;
    public static ElementType U;
    public static ElementType FnPtr;
    public static ElementType Object;
    public static ElementType SzArray;
    public static ElementType MVar;
    public static ElementType CmodReqd;
    public static ElementType CmodOpt;
    public static ElementType Internal;
    public static ElementType Modifier;
    public static ElementType Sentinel;
    public static ElementType Pinned;
    public static ElementType Type;
    public static ElementType Boxed;
    public static ElementType Field;
    public static ElementType Property;
    public static ElementType Enum;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.ElementTypeEx : object {
    [ExtensionAttribute]
public static ElementType ToSigned(ElementType type);
    [ExtensionAttribute]
public static ElementType ToUnsigned(ElementType type);
    [ExtensionAttribute]
public static TypeCode ToTypeCode(ElementType type);
    [ExtensionAttribute]
public static bool IsAnyOf(ElementType lhs, ElementType rhs1);
    [ExtensionAttribute]
public static bool IsAnyOf(ElementType lhs, ElementType rhs1, ElementType rhs2);
    [ExtensionAttribute]
public static bool IsAnyOf(ElementType lhs, ElementType rhs1, ElementType rhs2, ElementType rhs3);
    [ExtensionAttribute]
public static bool IsAnyOf(ElementType lhs, ElementType rhs1, ElementType rhs2, ElementType rhs3, ElementType rhs4);
    [ExtensionAttribute]
public static bool IsAnyOf(ElementType lhs, ElementType[] rhs);
    [ExtensionAttribute]
public static bool IsNumeric(ElementType type);
    [ExtensionAttribute]
public static bool IsNumericOrChar(ElementType type);
    [ExtensionAttribute]
public static bool IsIntegral(ElementType type);
    [ExtensionAttribute]
public static bool IsIntegralOrChar(ElementType type);
    [ExtensionAttribute]
public static bool IsIntegralOrCharOrFloat(ElementType type);
    [ExtensionAttribute]
public static bool IsFloat(ElementType type);
    [ExtensionAttribute]
public static bool IsPointerOrReference(ElementType type);
    [ExtensionAttribute]
public static bool IsSigned(ElementType type);
    [ExtensionAttribute]
public static bool IsUnsigned(ElementType type);
    [ExtensionAttribute]
public static bool IsBinaryEquivalentTo(ElementType type1, ElementType type2);
    [ExtensionAttribute]
private static ElementType ToCanonical(ElementType type);
    [ExtensionAttribute]
public static bool IsImplicitNumericConvertibleTo(ElementType from, ElementType to);
    [ExtensionAttribute]
private static int Weight(ElementType type);
    [ExtensionAttribute]
public static int Size(ElementType argType);
    [ExtensionAttribute]
public static ElementType GetArithmeticOperationResultType(ElementType argType, bool signed);
    [ExtensionAttribute]
public static ElementType ResolveNativeInt(ElementType elementType, bool is64BitProcess);
    [ExtensionAttribute]
public static bool IsSimplePrimitive(ElementType elementType);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.ElementTypeExtensions : object {
    [ExtensionAttribute]
public static int GetSize(ElementType elementType);
}
public class JetBrains.Metadata.Reader.API.EmptyResolveContext : UserDataHolder {
    public static EmptyResolveContext Instance;
    public string UniqueName { get; }
    public AssemblyNameAndLocation Originator { get; }
    public TargetFrameworkId TargetFramework { get; }
    private static EmptyResolveContext();
    public VirtualFileSystemPath GetResolveResult(AssemblyReferenceWithSource assemblyReferenceWithSource);
    public void SetResolveResult(AssemblyReferenceWithSource assemblyReferenceWithSource, VirtualFileSystemPath resolveResult);
    public sealed virtual string get_UniqueName();
    public sealed virtual bool IsValid();
    public sealed virtual AssemblyNameAndLocation get_Originator();
    public sealed virtual TargetFrameworkId get_TargetFramework();
    public sealed virtual void Write(BinaryWriter writer);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.API.FieldSignature : object {
    private IMetadataType myType;
    public IMetadataType Type { get; }
    public FieldSignature(IMetadataType type);
    public IMetadataType get_Type();
    public static FieldSignature FromBlob(IBlob blob, IMetadataAssembly assembly, TypeDecodeContext context);
    public bool IsEqualTo(FieldSignature other, IEqualityComparer`1<IMetadataType> comparer);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.API.FieldSpecification : object {
    public static FieldSpecification Null;
    public static FieldSpecification Unresolved;
    private IMetadataClassType myOwnerType;
    private IMetadataField myField;
    public IMetadataClassType OwnerType { get; }
    public IMetadataField Field { get; }
    public FieldSpecification(IMetadataField field);
    public FieldSpecification(IMetadataField field, IMetadataClassType ownerType);
    private static FieldSpecification();
    public IMetadataClassType get_OwnerType();
    public IMetadataField get_Field();
    public sealed virtual bool Equals(FieldSpecification other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[FlagsAttribute]
public enum JetBrains.Metadata.Reader.API.GacResolvePreferences : Enum {
    public int value__;
    public static GacResolvePreferences None;
    public static GacResolvePreferences MatchSameOrNewer;
    public static GacResolvePreferences RedirectGac20ToGac40;
}
public class JetBrains.Metadata.Reader.API.GacResolverUtil : object {
    public static VirtualFileSystemPath BestCandidate(IEnumerable`1<VirtualFileSystemPath> candidates, AssemblyNameInfo name, GacResolvePreferences preferences);
}
public interface JetBrains.Metadata.Reader.API.IAssemblyLocation {
    [CanBeNullAttribute]
public VirtualFileSystemPath AssemblyPhysicalPath { get; }
    [CanBeNullAttribute]
public VirtualFileSystemPath ContainerPhysicalPath { get; }
    public bool IsEmpty { get; }
    [NotNullAttribute]
public string ShortPresentation { get; }
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public string NameWithoutExtension { get; }
    [NotNullAttribute]
public string ExtensionWithDot { get; }
    public IInteractionContext Context { get; }
    public abstract virtual VirtualFileSystemPath get_AssemblyPhysicalPath();
    public abstract virtual VirtualFileSystemPath get_ContainerPhysicalPath();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual string get_ShortPresentation();
    public abstract virtual string get_Name();
    public abstract virtual string get_NameWithoutExtension();
    public abstract virtual string get_ExtensionWithDot();
    [CanBeNullAttribute]
public abstract virtual IAssemblyLocation GetNeighbor(string neighborName);
    [NotNullAttribute]
public abstract virtual Stream OpenForReading();
    public abstract virtual T Visit(IAssemblyLocationVisitor`1<T> visitor);
    public abstract virtual IInteractionContext get_Context();
}
public interface JetBrains.Metadata.Reader.API.IAssemblyLocationVisitor`1 {
    public abstract virtual T Visit(StreamAssemblyLocation assemblyLocation);
    public abstract virtual T Visit(AssemblyLocation assemblyLocation);
    public abstract virtual T Visit(BundleFileEntryLocation assemblyLocation);
}
public interface JetBrains.Metadata.Reader.API.IAssemblyResolver {
    [CanBeNullAttribute]
public abstract virtual IMetadataAccess ResolveAssembly(AssemblyNameInfo name, IAssemblyLocation& assemblyLocation, IModuleReferenceResolveContext moduleReferenceResolveContext);
    public abstract virtual void DumpDebugInformation(IndentedTextWriter textWriter);
}
[CannotApplyEqualityOperatorAttribute]
public interface JetBrains.Metadata.Reader.API.IClrTypeName {
    [NotNullAttribute]
public string ShortName { get; }
    [NotNullAttribute]
public string FullName { get; }
    [NotNullAttribute]
public IEnumerable`1<string> NamespaceNames { get; }
    [NotNullAttribute]
public IEnumerable`1<TypeNameAndTypeParameterNumber> TypeNames { get; }
    public int TypeParametersCount { get; }
    public abstract virtual string get_ShortName();
    public abstract virtual string get_FullName();
    public abstract virtual IEnumerable`1<string> get_NamespaceNames();
    public abstract virtual IEnumerable`1<TypeNameAndTypeParameterNumber> get_TypeNames();
    public abstract virtual int get_TypeParametersCount();
    [PureAttribute]
public abstract virtual IClrTypeName GetPersistent();
    [PureAttribute]
public abstract virtual int GetPartsCount();
    [PureAttribute]
[CanBeNullAttribute]
public abstract virtual IClrTypeNamePartIterator GetPartIterator();
    [PureAttribute]
[CanBeNullAttribute]
public abstract virtual string GetFullNameFast();
}
public interface JetBrains.Metadata.Reader.API.IClrTypeNamePartIterator {
    public abstract virtual bool GetNextPart(TypeNameAndTypeParameterNumber& info);
}
public interface JetBrains.Metadata.Reader.API.ICompilerSpecificAttribute {
    [NotNullAttribute]
public string AttributeType { get; }
    [NotNullAttribute]
public MetadataAttributeValue[] PositionalArguments { get; }
    [NotNullAttribute]
public Pair`2[] NamedArguments { get; }
    public abstract virtual string get_AttributeType();
    public abstract virtual MetadataAttributeValue[] get_PositionalArguments();
    public abstract virtual Pair`2[] get_NamedArguments();
}
public interface JetBrains.Metadata.Reader.API.IEntityPresentations {
    public abstract virtual MetadataToken[] GetFieldPresentations(IMetadataField field);
    public abstract virtual MetadataToken[] GetTypePresentations(IMetadataTypeInfo typeInfo);
    public abstract virtual MetadataToken[] GetMethodPresentations(IMetadataMethod method);
    public abstract virtual MetadataToken GetTokenFromTypeInfo(IMetadataTypeInfo typeInfo);
    public abstract virtual MetadataToken[] GetFieldPresentations(MetadataToken token);
    public abstract virtual MetadataToken[] GetTypePresentations(MetadataToken token);
    public abstract virtual MetadataToken[] GetMethodPresentations(MetadataToken token);
}
public interface JetBrains.Metadata.Reader.API.IFolderBasedAssemblyResolver {
    [CanBeNullAttribute]
public abstract virtual VirtualFileSystemPath TryResolveAssemblyPath(AssemblyNameInfo name);
    public abstract virtual bool IsUnderResolvePaths(VirtualFileSystemPath path);
}
public interface JetBrains.Metadata.Reader.API.IImageBodyReader {
    [CanBeNullAttribute]
public abstract virtual IMethodBody GetMethodBody(IMetadataMethod method);
    [CanBeNullAttribute]
public abstract virtual ILMethodBody GetIlMethodBody(IMetadataMethod method);
    [CanBeNullAttribute]
public abstract virtual Byte[] GetFieldInitialValue(IMetadataField field);
}
public interface JetBrains.Metadata.Reader.API.IManifestResourceDisposition {
    [NotNullAttribute]
public string ResourceName { get; }
    public abstract virtual string get_ResourceName();
    [NotNullAttribute]
public abstract virtual Stream CreateResourceReader();
}
public interface JetBrains.Metadata.Reader.API.IMetadataArrayMethod {
}
public interface JetBrains.Metadata.Reader.API.IMetadataArrayType {
    public IMetadataType ElementType { get; }
    public bool IsVector { get; }
    public UInt32 Rank { get; }
    public UInt32[] Sizes { get; }
    public Int32[] LBounds { get; }
    public IMetadataArrayTypeInfo TypeInfo { get; }
    public abstract virtual IMetadataType get_ElementType();
    public abstract virtual bool get_IsVector();
    public abstract virtual UInt32 get_Rank();
    public abstract virtual UInt32[] get_Sizes();
    public abstract virtual Int32[] get_LBounds();
    public abstract virtual IMetadataArrayTypeInfo get_TypeInfo();
}
public interface JetBrains.Metadata.Reader.API.IMetadataArrayTypeInfo {
    public IMetadataArrayType ArrayType { get; }
    public abstract virtual IMetadataArrayType get_ArrayType();
}
public interface JetBrains.Metadata.Reader.API.IMetadataAssembly {
    public IMetadataAccess MetadataAccess { get; }
    [CanBeNullAttribute]
public AssemblyNameInfo AssemblyName { get; }
    public AssemblyId Id { get; }
    public IEnumerable`1<AssemblyNameInfo> ReferencedAssembliesNames { get; }
    [CanBeNullAttribute]
public IAssemblyLocation Location { get; }
    public IMetadataAssemblyInternals Internals { get; }
    public IMetadataCustomAttribute[] ModuleAttributes { get; }
    public abstract virtual IMetadataAccess get_MetadataAccess();
    public abstract virtual AssemblyNameInfo get_AssemblyName();
    public abstract virtual AssemblyId get_Id();
    public abstract virtual IEnumerable`1<AssemblyNameInfo> get_ReferencedAssembliesNames();
    public abstract virtual IAssemblyLocation get_Location();
    [NotNullAttribute]
public abstract virtual IMetadataTypeInfo GetTypeInfoFromQualifiedName(string assemblyQualifiedName, bool searchReferencedAssemblies);
    [NotNullAttribute]
public abstract virtual IMetadataTypeInfo GetTypeInfoFromToken(MetadataToken token);
    [NotNullAttribute]
public abstract virtual IMetadataType GetTypeFromQualifiedName(string qualifiedName, bool searchReferencedAssemblies);
    public abstract virtual IMetadataTypeInfo[] GetTypes();
    public abstract virtual IMetadataTypeInfo[] GetExportedTypesFromOtherModules();
    [NotNullAttribute]
public abstract virtual IReadOnlyCollection`1<IMetadataForwardedTypeInfo> GetForwardedTypes();
    public abstract virtual IMetadataManifestResource[] GetManifestResources();
    public abstract virtual IImageBodyReader CreateImageBodyReader();
    public abstract virtual IMethodBodyUsagesFinder CreateUsagesFinder();
    public abstract virtual IMetadataAssemblyInternals get_Internals();
    public abstract virtual IMetadataCustomAttribute[] get_ModuleAttributes();
}
public interface JetBrains.Metadata.Reader.API.IMetadataAssemblyInternals {
    public MetadataLoader Loader { get; }
    public IEnumerable`1<AssemblyReference> ReferencedAssemblies { get; }
    public IEnumerable`1<KeyValuePair`2<MetadataToken, string>> ReferencedModules { get; }
    public FileReference[] ReferencedFiles { get; }
    public IEntityPresentations EntityPresentations { get; }
    public abstract virtual MetadataLoader get_Loader();
    public abstract virtual IEnumerable`1<AssemblyReference> get_ReferencedAssemblies();
    public abstract virtual IEnumerable`1<KeyValuePair`2<MetadataToken, string>> get_ReferencedModules();
    public abstract virtual FileReference[] get_ReferencedFiles();
    [CanBeNullAttribute]
public abstract virtual AssemblyNameInfo GetReferencedAssemblyName(MetadataToken assemblyToken);
    [CanBeNullAttribute]
public abstract virtual Byte[] GetReferencedAssemblyHash(MetadataToken assemblyToken);
    [CanBeNullAttribute]
public abstract virtual IMetadataAssembly GetReferencedAssembly(MetadataToken assemblyToken);
    [CanBeNullAttribute]
public abstract virtual IMetadataAssembly GetReferencedAssembly(AssemblyReference assemblyReference);
    [CanBeNullAttribute]
public abstract virtual IAssemblyLocation GetReferencedFile(MetadataToken token);
    [CanBeNullAttribute]
public abstract virtual IMetadataAssembly GetAssemblyFromReferencedFile(MetadataToken token);
    public abstract virtual void ResetReferencedAssembliesCache();
    [CanBeNullAttribute]
public abstract virtual IMetadataType GetTypeFromToken(MetadataToken token);
    [CanBeNullAttribute]
public abstract virtual IMetadataType GetTypeFromToken(MetadataToken token, TypeDecodeContext context);
    [CanBeNullAttribute]
public abstract virtual MethodSpecification GetMethodFromToken(MetadataToken methodToken);
    [CanBeNullAttribute]
public abstract virtual MethodSpecification GetMethodFromToken(MetadataToken methodToken, TypeDecodeContext context);
    public abstract virtual FieldSpecification GetFieldFromToken(MetadataToken fieldToken, TypeDecodeContext typeContext);
    public abstract virtual IEntityPresentations get_EntityPresentations();
    public abstract virtual IMetadataType DecodeType(IBinaryReader reader, TypeDecodeContext context);
    public abstract virtual IEnumerable`1<Pair`2<string, MetadataToken>> GetAllCustomAttributeStringsWithTokens();
    public abstract virtual bool IsProtectedFromDisassembly();
}
public interface JetBrains.Metadata.Reader.API.IMetadataAttributeFieldInitialization {
    public IMetadataField Field { get; }
    public abstract virtual IMetadataField get_Field();
}
public interface JetBrains.Metadata.Reader.API.IMetadataAttributeNamedArgument {
    public IMetadataTypeMember Member { get; }
    public IMetadataType MemberType { get; }
    public string MemberName { get; }
    public MetadataAttributeValue Value { get; }
    public abstract virtual IMetadataTypeMember get_Member();
    public abstract virtual IMetadataType get_MemberType();
    public abstract virtual string get_MemberName();
    public abstract virtual MetadataAttributeValue get_Value();
}
public interface JetBrains.Metadata.Reader.API.IMetadataAttributePropertyInitialization {
    public IMetadataProperty Property { get; }
    public abstract virtual IMetadataProperty get_Property();
}
public interface JetBrains.Metadata.Reader.API.IMetadataBoxedType {
    public IMetadataType UnderlyingType { get; }
    public abstract virtual IMetadataType get_UnderlyingType();
}
public interface JetBrains.Metadata.Reader.API.IMetadataClassType {
    [NotNullAttribute]
public IMetadataTypeInfo Type { get; }
    [NotNullAttribute]
public IMetadataType[] Arguments { get; }
    public abstract virtual IMetadataTypeInfo get_Type();
    public abstract virtual IMetadataType[] get_Arguments();
}
public interface JetBrains.Metadata.Reader.API.IMetadataCustomAttribute {
    [CanBeNullAttribute]
public MethodSpecification UsedConstructorSpecification { get; }
    [CanBeNullAttribute]
public IMetadataMethod UsedConstructor { get; }
    public MetadataToken Type { get; }
    public MetadataAttributeValue[] ConstructorArguments { get; }
    public IMetadataAttributeNamedArgument[] NamedArguments { get; }
    public abstract virtual MethodSpecification get_UsedConstructorSpecification();
    public abstract virtual IMetadataMethod get_UsedConstructor();
    public abstract virtual MetadataToken get_Type();
    public abstract virtual MetadataAttributeValue[] get_ConstructorArguments();
    public abstract virtual IMetadataAttributeNamedArgument[] get_NamedArguments();
    [CanBeNullAttribute]
public abstract virtual Byte[] GetBytes();
    public abstract virtual bool TryGetSingleIntCtorArgument(Int32& intArgument);
}
public interface JetBrains.Metadata.Reader.API.IMetadataEntity {
    [CanBeNullAttribute]
public IMetadataAssembly Assembly { get; }
    public MetadataToken Token { get; }
    [NotNullAttribute]
public IMetadataCustomAttribute[] CustomAttributes { get; }
    public MetadataTypeReference[] CustomAttributesTypeNames { get; }
    public bool IsResolved { get; }
    public abstract virtual IMetadataAssembly get_Assembly();
    public abstract virtual MetadataToken get_Token();
    public abstract virtual IMetadataCustomAttribute[] get_CustomAttributes();
    public abstract virtual MetadataTypeReference[] get_CustomAttributesTypeNames();
    public abstract virtual IList`1<IMetadataCustomAttribute> GetCustomAttributes(string attributeClassFullyQualifiedName);
    public abstract virtual bool HasCustomAttribute(string attributeClassFullyQualifiedName);
    public abstract virtual bool get_IsResolved();
}
public interface JetBrains.Metadata.Reader.API.IMetadataEvent {
    public IMetadataType Type { get; }
    public IMetadataMethod Adder { get; }
    public IMetadataMethod Remover { get; }
    public IMetadataMethod Raiser { get; }
    public IMetadataMethod[] OtherMethods { get; }
    public abstract virtual IMetadataType get_Type();
    public abstract virtual IMetadataMethod get_Adder();
    public abstract virtual IMetadataMethod get_Remover();
    public abstract virtual IMetadataMethod get_Raiser();
    public abstract virtual IMetadataMethod[] get_OtherMethods();
}
[CannotApplyEqualityOperatorAttribute]
public interface JetBrains.Metadata.Reader.API.IMetadataField {
    [CanBeNullAttribute]
public IMetadataType Type { get; }
    [CanBeNullAttribute]
public IBlob MarshalSpec { get; }
    public int Offset { get; }
    [CanBeNullAttribute]
public FieldSignature Signature { get; }
    public UInt32 InitialValueRva { get; }
    public bool IsAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsStatic { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool HasMarshalSpec { get; }
    public bool NotSerialized { get; }
    public abstract virtual IMetadataType get_Type();
    public abstract virtual IBlob get_MarshalSpec();
    [CanBeNullAttribute]
public abstract virtual object GetLiteralValue();
    [CanBeNullAttribute]
public abstract virtual IBlob GetLiteralValueBlob();
    public abstract virtual int get_Offset();
    public abstract virtual FieldSignature get_Signature();
    public abstract virtual UInt32 get_InitialValueRva();
    public abstract virtual bool get_IsAssembly();
    public abstract virtual bool get_IsPrivate();
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsFamily();
    public abstract virtual bool get_IsFamilyAndAssembly();
    public abstract virtual bool get_IsFamilyOrAssembly();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsInitOnly();
    public abstract virtual bool get_IsLiteral();
    public abstract virtual bool get_HasMarshalSpec();
    public abstract virtual bool get_NotSerialized();
}
public interface JetBrains.Metadata.Reader.API.IMetadataForwardedTypeInfo {
    [NotNullAttribute]
public AssemblyNameInfo AssemblyName { get; }
    [NotNullAttribute]
[ObsoleteAttribute("Use TypeReference.FullName (or TypeReference.NamespaceName / TypeReference.TypeName) instead to reduce memory allocations")]
public string FullName { get; }
    public MetadataTypeReference TypeReference { get; }
    public abstract virtual AssemblyNameInfo get_AssemblyName();
    public abstract virtual string get_FullName();
    public abstract virtual MetadataTypeReference get_TypeReference();
}
public interface JetBrains.Metadata.Reader.API.IMetadataFunctionPointerType {
    public MethodSignature MethodSignature { get; }
    public abstract virtual MethodSignature get_MethodSignature();
}
public interface JetBrains.Metadata.Reader.API.IMetadataInterfaceImplementation {
    public IMetadataTypeInfo Owner { get; }
    public IMetadataClassType Interface { get; }
    public abstract virtual IMetadataTypeInfo get_Owner();
    public abstract virtual IMetadataClassType get_Interface();
}
public interface JetBrains.Metadata.Reader.API.IMetadataManifestResource {
    public UInt32 Offset { get; }
    public ManifestResourceAttributes Flags { get; }
    public string Name { get; }
    public MetadataToken Implementation { get; }
    public abstract virtual UInt32 get_Offset();
    public abstract virtual ManifestResourceAttributes get_Flags();
    public abstract virtual string get_Name();
    public abstract virtual MetadataToken get_Implementation();
    [CanBeNullAttribute]
public abstract virtual IManifestResourceDisposition GetDisposition();
}
[CannotApplyEqualityOperatorAttribute]
public interface JetBrains.Metadata.Reader.API.IMetadataMethod {
    public IMetadataReturnValue ReturnValue { get; }
    public IMetadataParameter[] Parameters { get; }
    public IMetadataTypeParameter[] TypeParameters { get; }
    public IList`1<MethodSpecification> ImplementedMethods { get; }
    public MethodSignature Signature { get; }
    [CanBeNullAttribute]
public PInvokeInfo PInvokeInfo { get; }
    public CorMethodImpl MethodImplFlags { get; }
    public bool IsPInvokeImpl { get; }
    public CodeType CodeType { get; }
    public UInt32 CodeRva { get; }
    public bool IsForwardRef { get; }
    public bool IsPreserveSig { get; }
    public bool IsInternalCall { get; }
    public bool IsSynchronized { get; }
    public bool NoInlining { get; }
    public bool AggressiveInlining { get; }
    public bool AggressiveOptimization { get; }
    public bool NoOptimization { get; }
    public bool IsAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsExtern { get; }
    public bool IsVirtual { get; }
    public bool IsFinal { get; }
    public bool IsHideBySig { get; }
    public bool IsNewSlot { get; }
    public bool IsExplicitClassOverride { get; }
    public bool IsStrict { get; }
    public bool IsVarArg { get; }
    public bool IsUnmanaged { get; }
    public abstract virtual IMetadataReturnValue get_ReturnValue();
    public abstract virtual IMetadataParameter[] get_Parameters();
    public abstract virtual IMetadataTypeParameter[] get_TypeParameters();
    public abstract virtual IList`1<MethodSpecification> get_ImplementedMethods();
    public abstract virtual MethodSignature get_Signature();
    public abstract virtual PInvokeInfo get_PInvokeInfo();
    public abstract virtual CorMethodImpl get_MethodImplFlags();
    public abstract virtual bool get_IsPInvokeImpl();
    public abstract virtual CodeType get_CodeType();
    public abstract virtual UInt32 get_CodeRva();
    public abstract virtual bool get_IsForwardRef();
    public abstract virtual bool get_IsPreserveSig();
    public abstract virtual bool get_IsInternalCall();
    public abstract virtual bool get_IsSynchronized();
    public abstract virtual bool get_NoInlining();
    public abstract virtual bool get_AggressiveInlining();
    public abstract virtual bool get_AggressiveOptimization();
    public abstract virtual bool get_NoOptimization();
    public abstract virtual bool get_IsAssembly();
    public abstract virtual bool get_IsPrivate();
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsFamily();
    public abstract virtual bool get_IsFamilyAndAssembly();
    public abstract virtual bool get_IsFamilyOrAssembly();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsExtern();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual bool get_IsFinal();
    public abstract virtual bool get_IsHideBySig();
    public abstract virtual bool get_IsNewSlot();
    public abstract virtual bool get_IsExplicitClassOverride();
    public abstract virtual bool get_IsStrict();
    public abstract virtual bool get_IsVarArg();
    public abstract virtual bool get_IsUnmanaged();
}
public interface JetBrains.Metadata.Reader.API.IMetadataParameter {
    public string Name { get; }
    public IMetadataType Type { get; }
    public IMetadataMethod DeclaringMethod { get; }
    [CanBeNullAttribute]
public IBlob MarshalSpec { get; }
    public bool IsIn { get; }
    public bool IsOut { get; }
    public bool IsParamArray { get; }
    public bool IsOptional { get; }
    public bool HasMarshalSpec { get; }
    public bool HasDefaultValue { get; }
    public abstract virtual string get_Name();
    public abstract virtual IMetadataType get_Type();
    public abstract virtual IMetadataMethod get_DeclaringMethod();
    public abstract virtual IBlob get_MarshalSpec();
    public abstract virtual bool get_IsIn();
    public abstract virtual bool get_IsOut();
    public abstract virtual bool get_IsParamArray();
    public abstract virtual bool get_IsOptional();
    public abstract virtual bool get_HasMarshalSpec();
    public abstract virtual bool get_HasDefaultValue();
    public abstract virtual object GetDefaultValue();
    public abstract virtual IBlob GetDefaultValueBlob();
}
public interface JetBrains.Metadata.Reader.API.IMetadataPointerType {
    public IMetadataType Type { get; }
    public abstract virtual IMetadataType get_Type();
}
public interface JetBrains.Metadata.Reader.API.IMetadataProperty {
    public IMetadataType Type { get; }
    public IMetadataMethod Getter { get; }
    public IMetadataMethod Setter { get; }
    public IMetadataMethod[] OtherAccessors { get; }
    public abstract virtual IMetadataType get_Type();
    public abstract virtual IMetadataMethod get_Getter();
    public abstract virtual IMetadataMethod get_Setter();
    public abstract virtual IMetadataMethod[] get_OtherAccessors();
}
public interface JetBrains.Metadata.Reader.API.IMetadataReferenceType {
    public IMetadataType Type { get; }
    public abstract virtual IMetadataType get_Type();
}
public interface JetBrains.Metadata.Reader.API.IMetadataReturnValue {
    public IMetadataMethod DeclaringMethod { get; }
    public IMetadataType Type { get; }
    [CanBeNullAttribute]
public IBlob MarshalSpec { get; }
    public bool HasMarshalSpec { get; }
    public abstract virtual IMetadataMethod get_DeclaringMethod();
    public abstract virtual IMetadataType get_Type();
    public abstract virtual IBlob get_MarshalSpec();
    public abstract virtual bool get_HasMarshalSpec();
}
public interface JetBrains.Metadata.Reader.API.IMetadataSecurityAttribute {
    [NotNullAttribute]
public IMetadataSecurityRow DeclaringSecurityRow { get; }
    [NotNullAttribute]
public IMetadataTypeInfo Type { get; }
    public IMetadataAttributeNamedArgument[] NamedArguments { get; }
    [CanBeNullAttribute]
public Byte[] ConstructorArgumentsBlob { get; }
    public SecurityAction Action { get; }
    public abstract virtual IMetadataSecurityRow get_DeclaringSecurityRow();
    public abstract virtual IMetadataTypeInfo get_Type();
    public abstract virtual IMetadataAttributeNamedArgument[] get_NamedArguments();
    public abstract virtual Byte[] get_ConstructorArgumentsBlob();
    public abstract virtual SecurityAction get_Action();
}
public interface JetBrains.Metadata.Reader.API.IMetadataSecurityOwner {
    [NotNullAttribute]
public IMetadataSecurityRow[] Security { get; }
    [NotNullAttribute]
public String[] SecurityAttributesTypeName { get; }
    public bool HasSecurity { get; }
    public abstract virtual IMetadataSecurityRow[] get_Security();
    public abstract virtual String[] get_SecurityAttributesTypeName();
    public abstract virtual bool get_HasSecurity();
}
public interface JetBrains.Metadata.Reader.API.IMetadataSecurityRow {
    public SecurityAction Action { get; }
    public IMetadataSecurityAttribute[] Attributes { get; }
    public abstract virtual SecurityAction get_Action();
    public abstract virtual IMetadataSecurityAttribute[] get_Attributes();
}
public interface JetBrains.Metadata.Reader.API.IMetadataTupleType {
    [NotNullAttribute]
public MetadataTupleTypeComponent[] Components { get; }
    [NotNullAttribute]
public IMetadataClassType UnderlyingType { get; }
    public abstract virtual MetadataTupleTypeComponent[] get_Components();
    public abstract virtual IMetadataClassType get_UnderlyingType();
}
[CannotApplyEqualityOperatorAttribute]
public interface JetBrains.Metadata.Reader.API.IMetadataType {
    public string AssemblyQualifiedName { get; }
    public string FullName { get; }
    public string AssemblyQualification { get; }
    public IMetadataTypeModifier[] TypeModifiers { get; }
    public bool Pinned { get; }
    public bool IsResolved { get; }
    public abstract virtual string get_AssemblyQualifiedName();
    public abstract virtual string get_FullName();
    public abstract virtual string get_AssemblyQualification();
    public abstract virtual IMetadataTypeModifier[] get_TypeModifiers();
    public abstract virtual bool get_Pinned();
    public abstract virtual bool get_IsResolved();
    public abstract virtual void Accept(IMetadataTypeVisitor visitor);
    public abstract virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
}
public interface JetBrains.Metadata.Reader.API.IMetadataTypeInfo {
    public string FullyQualifiedName { get; }
    public string AssemblyQualifiedName { get; }
    public string NamespaceName { get; }
    public string TypeName { get; }
    [CanBeNullAttribute]
public AssemblyNameInfo DeclaringAssemblyName { get; }
    [CanBeNullAttribute]
public IMetadataClassType Base { get; }
    public IMetadataInterfaceImplementation[] InterfaceImplementations { get; }
    public IMetadataTypeParameter[] TypeParameters { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsImported { get; }
    public ClassLayoutType Layout { get; }
    [NotNullAttribute]
public ClassLayout ClassLayout { get; }
    public CharSetSpec InteropStringFormat { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsClass { get; }
    public bool IsInterface { get; }
    public bool IsSerializable { get; }
    public bool IsWindowsRuntime { get; }
    public bool IsPublic { get; }
    public bool IsNotPublic { get; }
    public bool IsNested { get; }
    public bool IsNestedPublic { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamilyAndAssembly { get; }
    public bool IsNestedFamilyOrAssembly { get; }
    public int PackingSize { get; }
    public int ClassSize { get; }
    public abstract virtual string get_FullyQualifiedName();
    public abstract virtual string get_AssemblyQualifiedName();
    public abstract virtual string get_NamespaceName();
    public abstract virtual string get_TypeName();
    public abstract virtual AssemblyNameInfo get_DeclaringAssemblyName();
    public abstract virtual IMetadataClassType get_Base();
    public abstract virtual IMetadataInterfaceImplementation[] get_InterfaceImplementations();
    public abstract virtual IMetadataTypeParameter[] get_TypeParameters();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsSealed();
    public abstract virtual bool get_IsImported();
    public abstract virtual ClassLayoutType get_Layout();
    public abstract virtual ClassLayout get_ClassLayout();
    public abstract virtual CharSetSpec get_InteropStringFormat();
    public abstract virtual bool get_IsBeforeFieldInit();
    public abstract virtual bool get_IsClass();
    public abstract virtual bool get_IsInterface();
    public abstract virtual bool get_IsSerializable();
    public abstract virtual bool get_IsWindowsRuntime();
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsNotPublic();
    public abstract virtual bool get_IsNested();
    public abstract virtual bool get_IsNestedPublic();
    public abstract virtual bool get_IsNestedPrivate();
    public abstract virtual bool get_IsNestedFamily();
    public abstract virtual bool get_IsNestedAssembly();
    public abstract virtual bool get_IsNestedFamilyAndAssembly();
    public abstract virtual bool get_IsNestedFamilyOrAssembly();
    public abstract virtual int get_PackingSize();
    public abstract virtual int get_ClassSize();
    public abstract virtual IEnumerable`1<MemberInfo> GetMemberInfos();
    public abstract virtual IMetadataMethod[] GetMethods();
    public abstract virtual IMetadataField[] GetFields();
    public abstract virtual IMetadataProperty[] GetProperties();
    public abstract virtual IMetadataEvent[] GetEvents();
    public abstract virtual IMetadataTypeInfo[] GetNestedTypes();
    public abstract virtual bool HasExtensionMethods();
    public abstract virtual MetadataMemberPresenceFlags ComputeMemberPresenceFlag();
    [CanBeNullAttribute]
public abstract virtual IMetadataProperty GetPropertyFromAccessor(IMetadataMethod accessor);
}
public interface JetBrains.Metadata.Reader.API.IMetadataTypeMember {
    [NotNullAttribute]
public string Name { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public abstract virtual string get_Name();
    public abstract virtual IMetadataTypeInfo get_DeclaringType();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsRuntimeSpecialName();
}
public interface JetBrains.Metadata.Reader.API.IMetadataTypeModifier {
    public MetadataModifierKind Kind { get; }
    public IMetadataType Type { get; }
    public abstract virtual MetadataModifierKind get_Kind();
    public abstract virtual IMetadataType get_Type();
}
public interface JetBrains.Metadata.Reader.API.IMetadataTypeParameter {
    public TypeParameterKind Kind { get; }
    public string Name { get; }
    public UInt32 Index { get; }
    public IMetadataTypeInfo TypeOwner { get; }
    public IMetadataMethod MethodOwner { get; }
    public IMetadataTypeParameterConstraint[] TypeConstraints { get; }
    public TypeParameterAttributes Attributes { get; }
    public abstract virtual TypeParameterKind get_Kind();
    public abstract virtual string get_Name();
    public abstract virtual UInt32 get_Index();
    public abstract virtual IMetadataTypeInfo get_TypeOwner();
    public abstract virtual IMetadataMethod get_MethodOwner();
    public abstract virtual IMetadataTypeParameterConstraint[] get_TypeConstraints();
    public abstract virtual TypeParameterAttributes get_Attributes();
}
public interface JetBrains.Metadata.Reader.API.IMetadataTypeParameterConstraint {
    public IMetadataTypeParameter Owner { get; }
    public IMetadataType Constraint { get; }
    public abstract virtual IMetadataTypeParameter get_Owner();
    public abstract virtual IMetadataType get_Constraint();
}
public interface JetBrains.Metadata.Reader.API.IMetadataTypeParameterReferenceType {
    public IMetadataTypeParameter TypeParameter { get; }
    public abstract virtual IMetadataTypeParameter get_TypeParameter();
}
public interface JetBrains.Metadata.Reader.API.IMetadataTypeTransformer {
    public abstract virtual IMetadataType TransformArrayType(IMetadataArrayType arrayType);
    public abstract virtual IMetadataType TransformClassType(IMetadataClassType classType);
    public abstract virtual IMetadataType TransformTupleType(IMetadataTupleType tupleType);
    public abstract virtual IMetadataType TransformPointerType(IMetadataPointerType pointerType);
    public abstract virtual IMetadataType TransformReferenceType(IMetadataReferenceType referenceType);
    public abstract virtual IMetadataType TransformTypeParameterReferenceType(IMetadataTypeParameterReferenceType typeParameterReferenceType);
    public abstract virtual IMetadataType TransformFunctionPointerType(IMetadataFunctionPointerType functionPointerType);
    public abstract virtual IMetadataType TransformBoxedType(IMetadataBoxedType boxedType);
}
public interface JetBrains.Metadata.Reader.API.IMetadataTypeVisitor {
    public abstract virtual void VisitUnknownType(IMetadataType unknownType);
    public abstract virtual void VisitArrayType(IMetadataArrayType arrayType);
    public abstract virtual void VisitClassType(IMetadataClassType classType);
    public abstract virtual void VisitTupleType(IMetadataTupleType tupleType);
    public abstract virtual void VisitPointerType(IMetadataPointerType pointerType);
    public abstract virtual void VisitReferenceType(IMetadataReferenceType referenceType);
    public abstract virtual void VisitTypeParameterReferenceType(IMetadataTypeParameterReferenceType typeParameterReferenceType);
    public abstract virtual void VisitFunctionPointer(IMetadataFunctionPointerType functionPointerType);
    public abstract virtual void VisitBoxedType(IMetadataBoxedType boxedType);
}
public interface JetBrains.Metadata.Reader.API.IMethodBody {
    [NotNullAttribute]
public IMetadataMethod Method { get; }
    [NotNullAttribute]
public IMethodBodyLocalVariable[] LocalVariables { get; }
    [NotNullAttribute]
public Instruction[] Instructions { get; }
    [NotNullAttribute]
public IMethodBodyExceptionHandler[] ExceptionHandlers { get; }
    public int MaxStack { get; }
    public MetadataToken LocalVariablesSignatureToken { get; }
    public bool LocalVariablesInitialized { get; }
    public abstract virtual IMetadataMethod get_Method();
    public abstract virtual IMethodBodyLocalVariable[] get_LocalVariables();
    public abstract virtual Instruction[] get_Instructions();
    public abstract virtual IMethodBodyExceptionHandler[] get_ExceptionHandlers();
    public abstract virtual int get_MaxStack();
    public abstract virtual MetadataToken get_LocalVariablesSignatureToken();
    public abstract virtual bool get_LocalVariablesInitialized();
}
public interface JetBrains.Metadata.Reader.API.IMethodBodyExceptionHandler {
    public ExceptionHandlerType Type { get; }
    public int HandlerLength { get; }
    public int HandlerOffset { get; }
    [CanBeNullAttribute]
public IMetadataType CatchType { get; }
    public int FilterOffset { get; }
    public int TryLength { get; }
    public int TryOffset { get; }
    public abstract virtual ExceptionHandlerType get_Type();
    public abstract virtual int get_HandlerLength();
    public abstract virtual int get_HandlerOffset();
    public abstract virtual IMetadataType get_CatchType();
    public abstract virtual int get_FilterOffset();
    public abstract virtual int get_TryLength();
    public abstract virtual int get_TryOffset();
}
public interface JetBrains.Metadata.Reader.API.IMethodBodyLocalVariable {
    public IMetadataMethod Method { get; }
    public int Index { get; }
    public IMetadataType Type { get; }
    public bool Pinned { get; }
    public abstract virtual IMetadataMethod get_Method();
    public abstract virtual int get_Index();
    public abstract virtual IMetadataType get_Type();
    public abstract virtual bool get_Pinned();
}
public interface JetBrains.Metadata.Reader.API.IMethodBodyUsagesFinder {
    public abstract virtual IReadOnlyList`1<MethodUsageCount> FindUsagesOf(IMetadataMethod method);
    public abstract virtual IReadOnlyList`1<MethodUsageCount> FindUsagesOf(IMetadataField field);
    public abstract virtual IReadOnlyList`1<MethodUsageCount> FindUsagesOf(IMetadataTypeInfo typeInfo);
    public abstract virtual IReadOnlyList`1<MethodUsageCount> FindUsagesOf(MetadataToken userStringToken, string userString);
    public abstract virtual IReadOnlyList`1<MethodUsageCount> FindDefaultConstructorUsagesOfValueType(IMetadataTypeInfo typeInfo);
}
public interface JetBrains.Metadata.Reader.API.IModuleReferenceResolveContext {
    [NotNullAttribute]
public string UniqueName { get; }
    public AssemblyNameAndLocation Originator { get; }
    [NotNullAttribute]
public TargetFrameworkId TargetFramework { get; }
    public abstract virtual string get_UniqueName();
    public abstract virtual bool IsValid();
    public abstract virtual AssemblyNameAndLocation get_Originator();
    public abstract virtual TargetFrameworkId get_TargetFramework();
    public abstract virtual void Write(BinaryWriter writer);
}
public interface JetBrains.Metadata.Reader.API.ITypeInfoByNameProvider {
    public abstract virtual IMetadataTypeInfo GetTypeInfoFromQualifiedName(string name, AssemblyNameInfo assemblyName, bool searchReferencedAssemblies);
}
public class JetBrains.Metadata.Reader.API.MarshalSpec.ArrayMarshalSpec : MarshalSpecBase {
    private NativeType myElementType;
    private int myNumElem;
    private int myParamNum;
    public NativeType ElementType { get; }
    public int ParamNum { get; }
    public int NumElem { get; }
    public ArrayMarshalSpec(NativeType elementType, int paramNum, int numElem);
    public NativeType get_ElementType();
    public int get_ParamNum();
    public int get_NumElem();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.API.MarshalSpec.CustomMarshalerMarshalSpec : MarshalSpecBase {
    private string myCookie;
    private Guid myGuid;
    private string myManagedType;
    private string myUnmanagedType;
    public string Cookie { get; }
    public string ManagedType { get; }
    public string UnmanagedType { get; }
    public Guid Guid { get; }
    public CustomMarshalerMarshalSpec(Guid guid, string unmanagedType, string managedType, string cookie);
    public string get_Cookie();
    public string get_ManagedType();
    public string get_UnmanagedType();
    public Guid get_Guid();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.API.MarshalSpec.FixedArrayMarshalSpec : MarshalSpecBase {
    private NativeType myElementType;
    private int myNumElem;
    public NativeType ElementType { get; }
    public int NumElem { get; }
    public FixedArrayMarshalSpec(NativeType elementType, int numElem);
    public NativeType get_ElementType();
    public int get_NumElem();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.API.MarshalSpec.FixedSysStringMarshalSpec : MarshalSpecBase {
    private int mySize;
    public int Size { get; }
    public FixedSysStringMarshalSpec(int size);
    public int get_Size();
    public virtual string ToString();
}
public interface JetBrains.Metadata.Reader.API.MarshalSpec.IMarshalSpec {
    public NativeType Type { get; }
    public abstract virtual NativeType get_Type();
}
public class JetBrains.Metadata.Reader.API.MarshalSpec.IntrinsicMarshalSpec : MarshalSpecBase {
    public IntrinsicMarshalSpec(NativeType type);
    public virtual string ToString();
}
public abstract class JetBrains.Metadata.Reader.API.MarshalSpec.MarshalSpecBase : object {
    private NativeType myType;
    public NativeType Type { get; }
    protected MarshalSpecBase(NativeType type);
    public sealed virtual NativeType get_Type();
}
public enum JetBrains.Metadata.Reader.API.MarshalSpec.NativeType : Enum {
    public int value__;
    public static NativeType NONE;
    public static NativeType BOOLEAN;
    public static NativeType I1;
    public static NativeType U1;
    public static NativeType I2;
    public static NativeType U2;
    public static NativeType I4;
    public static NativeType U4;
    public static NativeType I8;
    public static NativeType U8;
    public static NativeType R4;
    public static NativeType R8;
    public static NativeType LPSTR;
    public static NativeType INT;
    public static NativeType UINT;
    public static NativeType FUNC;
    public static NativeType ARRAY;
    public static NativeType CURRENCY;
    public static NativeType BSTR;
    public static NativeType LPWSTR;
    public static NativeType LPTSTR;
    public static NativeType FIXEDSYSSTRING;
    public static NativeType IUNKNOWN;
    public static NativeType IDISPATCH;
    public static NativeType STRUCT;
    public static NativeType INTF;
    public static NativeType SAFEARRAY;
    public static NativeType FIXEDARRAY;
    public static NativeType BYVALSTR;
    public static NativeType ANSIBSTR;
    public static NativeType TBSTR;
    public static NativeType VARIANTBOOL;
    public static NativeType ASANY;
    public static NativeType LPSTRUCT;
    public static NativeType CUSTOMMARSHALER;
    public static NativeType ERROR;
    public static NativeType IINSPECTABLE;
    public static NativeType HSTRING;
    public static NativeType MAX;
}
public class JetBrains.Metadata.Reader.API.MarshalSpec.SafeArrayMarshalSpec : MarshalSpecBase {
    private VariantType myElementType;
    public VariantType ElementType { get; }
    public SafeArrayMarshalSpec(VariantType elementType);
    public VariantType get_ElementType();
    public virtual string ToString();
}
public enum JetBrains.Metadata.Reader.API.MarshalSpec.VariantType : Enum {
    public int value__;
    public static VariantType NONE;
    public static VariantType NULL;
    public static VariantType I2;
    public static VariantType I4;
    public static VariantType R4;
    public static VariantType R8;
    public static VariantType CY;
    public static VariantType DATE;
    public static VariantType BSTR;
    public static VariantType DISPATCH;
    public static VariantType ERROR;
    public static VariantType BOOL;
    public static VariantType VARIANT;
    public static VariantType UNKNOWN;
    public static VariantType DECIMAL;
    public static VariantType I1;
    public static VariantType UI1;
    public static VariantType UI2;
    public static VariantType UI4;
    public static VariantType I8;
    public static VariantType UI8;
    public static VariantType INT;
    public static VariantType UINT;
    public static VariantType VOID;
    public static VariantType HRESULT;
    public static VariantType PTR;
    public static VariantType SAFEARRAY;
    public static VariantType CARRAY;
    public static VariantType USERDEFINED;
    public static VariantType LPSTR;
    public static VariantType LPWSTR;
    public static VariantType RECORD;
    public static VariantType FILETIME;
    public static VariantType BLOB;
    public static VariantType STREAM;
    public static VariantType STORAGE;
    public static VariantType STREAMED_OBJECT;
    public static VariantType STORED_OBJECT;
    public static VariantType BLOB_OBJECT;
    public static VariantType CF;
    public static VariantType CLSID;
    public static VariantType VECTOR;
    public static VariantType ARRAY;
    public static VariantType BYREF;
}
public enum JetBrains.Metadata.Reader.API.MemberAccessibility : Enum {
    public int value__;
    public static MemberAccessibility None;
    public static MemberAccessibility Public;
    public static MemberAccessibility Internal;
    public static MemberAccessibility Protected;
    public static MemberAccessibility ProtectedOrInternal;
    public static MemberAccessibility ProtectedAndInternal;
    public static MemberAccessibility Private;
}
public class JetBrains.Metadata.Reader.API.MemberInfo : ValueType {
    public string Name;
    public MetadataToken Token;
    public MemberInfo(string name, MetadataToken token);
}
public class JetBrains.Metadata.Reader.API.MetadataAttributeValue : ValueType {
    public static MetadataAttributeValue BadValue;
    private IMetadataType myType;
    private object myValue;
    public IMetadataType Type { get; }
    public object Value { get; }
    public MetadataAttributeValue[] ValuesArray { get; }
    private MetadataAttributeValue(IMetadataType type, object value);
    private static MetadataAttributeValue();
    public IMetadataType get_Type();
    public object get_Value();
    public MetadataAttributeValue[] get_ValuesArray();
    public static MetadataAttributeValue MakeArray(IMetadataArrayType arrayType, MetadataAttributeValue[] valuesArray);
    public static MetadataAttributeValue MakeScalar(IMetadataType type, object value);
    public static MetadataAttributeValue MakeScalar(IMetadataAssembly assembly, string type, object value);
    public static MetadataAttributeValue MakeScalar_Unresolved(IMetadataAssembly assembly, string type, object value);
    private static MetadataAttributeValue MakeUnresolvedScalar(string typeFQN, object value);
    public bool IsBadValue();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.MetadataEx : object {
    private static BidirectionalMapOnDictionary`2<Type, ElementType> TypeToElementType;
    private static string CSharpClosureTypeNamePrefix;
    private static string VBClosureTypeNamePrefix;
    private static string Uniti3DClosureTypeNameMiddle;
    private static string CSharpAnonymousTypeNamePrefix;
    private static string CSharpAnonymousDelegateNamePrefix;
    private static string VBAnonymousTypeNamePrefix;
    private static MetadataEx();
    [ExtensionAttribute]
public static ElementType ToElementType(Type type);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static Type ToPrimitiveType(ElementType elementType);
    [ExtensionAttribute]
public static ElementType ToElementType(IMetadataType type);
    [ExtensionAttribute]
[NotNullAttribute]
public static IMetadataClassType ToClassType(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
[NotNullAttribute]
public static IMetadataReferenceType ToReferenceType(IMetadataType type);
    [ExtensionAttribute]
[NotNullAttribute]
public static IMetadataPointerType ToPointerType(IMetadataType type);
    [ExtensionAttribute]
public static bool IsProtectedFromDisassembly(IMetadataAssembly assembly);
    [ExtensionAttribute]
public static int GetPointerSize(IMetadataAssembly assembly);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataMethod GetMethodFromFullyQualifiedName(IMetadataAssembly assembly, string fqn);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataMethod GetMethodFromName(IMetadataAssembly assembly, string classFqn, string methodName);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICollection`1<IMetadataMethod> GetMatchingMethods(IMetadataAssembly assembly, string classFqn, string methodName);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataMethod GetMethodFromFullyQualifiedNameAndSignature(IMetadataAssembly assembly, string fqn, IMetadataType[] signature);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataProperty GetPropertyFromFullyQualifiedName(IMetadataAssembly assembly, string fqn);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataProperty GetPropertyFromFullyQualifiedNameAndSignature(IMetadataAssembly assembly, string fqn, IMetadataType[] signature);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataField GetFieldFromFullyQualifiedName(IMetadataAssembly assembly, string fqn);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataProperty GetPropertyFromAccessor(IMetadataMethod accessor);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataEvent GetEventFromAccessor(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsInterface(IMetadataType type);
    [ExtensionAttribute]
public static bool IsArray(IMetadataTypeInfo info);
    [ExtensionAttribute]
public static bool IsList(IMetadataTypeInfo info);
    [ExtensionAttribute]
public static bool IsVector(IMetadataArrayType type);
    [ExtensionAttribute]
public static bool IsIndexer(IMetadataProperty property);
    [ExtensionAttribute]
public static bool IsExplicitInterfaceIndexer(IMetadataProperty property);
    [ExtensionAttribute]
public static int GetParametersCount(IMetadataProperty property);
    [ExtensionAttribute]
public static IMetadataParameter[] GetParameters(IMetadataProperty property);
    [ExtensionAttribute]
public static string GetShortName(IMetadataProperty property);
    private static string GetShortName(string fullName);
    [ExtensionAttribute]
public static bool DefaultMemberIsIndexer(IMetadataTypeInfo type);
    [ExtensionAttribute]
public static string GetUniversalName(IMetadataTypeParameter typeParameter);
    [ExtensionAttribute]
public static bool IsConstructor(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsOperator(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsClassConstructor(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsFinalizer(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsMain(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsAsyncMain(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsCompilerGeneratedMain(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsTopLevelEntryPoint(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsTopLevelProgram(IMetadataTypeInfo type);
    private static bool IsValidMainMethodParameters(IMetadataParameter[] parameters);
    private static bool IsValidAsyncMainReturnValue(IMetadataReturnValue returnValue);
    private static bool IsValidSyncMainReturnValue(IMetadataReturnValue returnValue);
    [ExtensionAttribute]
public static bool IsExtensionMethod(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsDeconstructMethod(IMetadataMethod method, bool singleParameterAllowed);
    [ExtensionAttribute]
public static bool IsPropertyGetter(IMetadataMethod method);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, property: notnull; => false")]
public static bool IsPropertyGetter(IMetadataMethod method, IMetadataProperty& property);
    [ExtensionAttribute]
public static bool IsPropertySetter(IMetadataMethod method);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, property: notnull; => false")]
public static bool IsPropertySetter(IMetadataMethod method, IMetadataProperty& property);
    [ExtensionAttribute]
public static bool IsInitOnly(IMetadataMethod setter);
    [ExtensionAttribute]
public static bool IsEventAdder(IMetadataMethod method);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, event: notnull; => false")]
public static bool IsEventAdder(IMetadataMethod method, IMetadataEvent& event);
    [ExtensionAttribute]
public static bool IsEventRemover(IMetadataMethod method);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, event: notnull; => false")]
public static bool IsEventRemover(IMetadataMethod method, IMetadataEvent& event);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true; => false, methodSpecification: notnull")]
public static bool IsNull(MethodSpecification methodSpecification);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(IMetadataType type);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(IMetadataEntity entity);
    [ExtensionAttribute]
public static bool IsHereditaryCompilerGenerated(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsHereditaryCompilerGenerated(IMetadataField field);
    [ExtensionAttribute]
public static bool IsBadCompilerGenerated(IMetadataField field);
    [ExtensionAttribute]
public static bool IsBadCompilerGenerated(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsHereditaryCompilerGenerated(IMetadataType type);
    [ExtensionAttribute]
public static bool IsHereditaryCompilerGenerated(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static String[] GetTupleElementNames(IMetadataEntity metadataEntity);
    [ExtensionAttribute]
public static bool IsFixedArrayField(IMetadataField field, IMetadataType& elementType, Int32& length);
    [ExtensionAttribute]
public static bool IsFixedArrayField(IMetadataField field);
    [ExtensionAttribute]
[NotNullAttribute]
public static IMetadataType UnwrapFromReferenceType(IMetadataType type, Boolean& isByRef);
    [ExtensionAttribute]
public static IMetadataType UnwrapFromReferenceAndPointer(IMetadataType type);
    [ExtensionAttribute]
public static IMetadataType UnwrapFromReferenceAndPointerSafe(IMetadataType type);
    [ExtensionAttribute]
public static bool IsRefReadonly(IMetadataReturnValue returnValue);
    [ExtensionAttribute]
public static bool IsRefReadonly(IMetadataProperty property);
    [ExtensionAttribute]
public static bool IsRefReadonly(IMetadataField field);
    [ExtensionAttribute]
public static bool IsInput(IMetadataParameter parameter);
    [ExtensionAttribute]
public static bool IsRefReadonly(IMetadataParameter parameter);
    [ExtensionAttribute]
public static bool IsParameterCollection(IMetadataParameter parameter);
    [ExtensionAttribute]
public static bool IsOutput(IMetadataParameter parameter);
    [ExtensionAttribute]
public static bool IsClosureFrameType(IMetadataType type);
    [ExtensionAttribute]
public static bool IsAnonymousType(IMetadataType type);
    [ExtensionAttribute]
public static bool IsAnonymousDelegateType(IMetadataType type);
    [ExtensionAttribute]
public static bool IsRecursivelyAnonymousType(IMetadataType type);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataInterfaceImplementation GetPresentableExplicitInterface(IMetadataProperty property);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataInterfaceImplementation GetPresentableExplicitInterface(IMetadataEvent evt);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataInterfaceImplementation GetPresentableExplicitInterface(IMetadataMethod method);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataAssembly ApplyDelta(IMetadataAssembly baseline, IMetadataStreamsAccess delta, Func`2<AssemblyNameInfo, bool> loadReferencedAssembly);
    [ExtensionAttribute]
public static TypeAnnotationsEnumerator`1<NullableAnnotation> GetNullableAnnotationsEnumerator(IMetadataEntity metadataEntity);
    [ExtensionAttribute]
private static bool TryGetNullableAttributeValue(IMetadataEntity metadataEntity, NullableAnnotation& annotation, NullableAnnotation[]& annotations);
    [ExtensionAttribute]
private static Nullable`1<NullableAnnotation> TryGetNullableContextValue(IMetadataEntity metadataEntity);
    [ExtensionAttribute]
private static Nullable`1<NullableAnnotation> TryGetNullableContextAttributeValue(IMetadataEntity metadataEntity);
    [ExtensionAttribute]
public static bool HasAnyNullableAnnotation(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
private static bool HasAnyNullableAnnotation(IMetadataMethod method);
    private static bool HasNullableAttributeOnTypeParameter(IMetadataTypeParameter[] typeParameters);
    [ExtensionAttribute]
private static bool HasNullableAttribute(IMetadataEntity entity);
    [ExtensionAttribute]
private static bool HasNullableContextAttribute(IMetadataEntity entity);
    [ExtensionAttribute]
public static bool ContainsNullablePublicOnlyAttribute(IMetadataCustomAttribute[] moduleAttributes, Boolean& includesInternals);
    [ExtensionAttribute]
[NotNullAttribute]
public static IMetadataTypeInfo GetTopLevelType(IMetadataMethod method);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.MetadataFieldEx : object {
    [ExtensionAttribute]
public static bool IsVolatile(IMetadataField field);
    [ExtensionAttribute]
public static bool Is(IMetadataField field, string typeFqn, string fieldName);
}
public class JetBrains.Metadata.Reader.API.MetadataLoader : SafeDisposable {
    private static Dictionary`2<string, ElementType> ElementTypes;
    private static ElementTypeName[] ElementTypeNames;
    private List`1<IMetadataAssembly> myLoadedAssemblies;
    private List`1<IMetadataAccess> myMetadataAccessToDispose;
    private IAssemblyResolver myResolver;
    private bool myGuardMultiThreading;
    private bool myAlwaysMatchVersion;
    private Dictionary`2<string, IMetadataTypeInfo> myWellKnownTypesByName;
    private IMetadataProvider myMetadataProvider;
    private Thread myOwningThread;
    private bool myDisposed;
    private bool myWellKnownTypesResolved;
    [CompilerGeneratedAttribute]
private MetadataLoaderErrors <ErrorNotifications>k__BackingField;
    [NotNullAttribute]
public MetadataLoaderErrors ErrorNotifications { get; }
    private static MetadataLoader();
    public MetadataLoader(VirtualFileSystemPath[] folders);
    public MetadataLoader(IEnumerable`1<VirtualFileSystemPath> folders, Func`2<VirtualFileSystemPath, bool> filesExists);
    public MetadataLoader(IMetadataProvider metadataProvider, VirtualFileSystemPath[] folders);
    public MetadataLoader(IMetadataProvider metadataProvider, IEnumerable`1<VirtualFileSystemPath> folders, Func`2<VirtualFileSystemPath, bool> filesExists);
    public MetadataLoader(IAssemblyResolver resolver);
    public MetadataLoader(IMetadataProvider metadataProvider, IAssemblyResolver resolver, bool guardMultiThreading, bool alwaysMatchVersion);
    public static ElementTypeName GetElementTypeMapping(ElementType elementType);
    private static void SetElementTypeMapping(ElementType elementType, string typeName);
    [ObsoleteAttribute("Use overload with IAssemblyLocation")]
[CanBeNullAttribute]
public IMetadataAssembly TryLoadFrom(VirtualFileSystemPath file, Func`2<AssemblyNameInfo, bool> loadReferencedAssembly, bool loadElementTypes, Func`1<bool> checkForInterrupt);
    [CanBeNullAttribute]
public IMetadataAssembly TryLoadFrom(IAssemblyLocation assemblyLocation, Func`2<AssemblyNameInfo, bool> loadReferencedAssembly, bool loadElementTypes, Func`1<bool> checkForInterrupt);
    [NotNullAttribute]
public IMetadataAssembly LoadFrom(IAssemblyLocation assemblyLocation, Func`2<AssemblyNameInfo, bool> loadReferencedAssembly, bool loadElementTypes);
    [ObsoleteAttribute("Use overload with IAssemblyLocation")]
[NotNullAttribute]
public IMetadataAssembly LoadFrom(VirtualFileSystemPath file, Func`2<AssemblyNameInfo, bool> loadReferencedAssembly, bool loadElementTypes);
    public void RemoveAssemblyById(AssemblyId id);
    [NotNullAttribute]
public IMetadataAssembly LoadAssemblyModule(IAssemblyLocation assemblyLocation, IMetadataAccess access, MetadataToken moduleToken, Func`2<AssemblyNameInfo, bool> loadReferencedAssembly, bool loadElementTypes, Func`1<bool> checkForInterrupt);
    [CanBeNullAttribute]
public IMetadataAssembly TryLoad(AssemblyNameInfo assemblyName, Func`2<AssemblyNameInfo, bool> loadReferencedAssembly, bool loadElementTypes, IMetadataAssembly originator, Func`1<bool> checkForInterrupt);
    private IMetadataAssembly GetLoadedAssemblyById(AssemblyId id);
    private IMetadataAssembly GetLoadedAssemblyByNameAndVersion(AssemblyNameInfo name);
    private IMetadataAssembly GetLoadedAssemblyByName(AssemblyNameInfo name);
    private IMetadataAssembly GetLoadedAssemblyByLocation(IAssemblyLocation assemblyLocation);
    private void RegisterAssembly(IMetadataAssembly assembly, bool loadElementTypes);
    public IMetadataTypeInfo GetWellKnownType(string fqn);
    public IMetadataTypeInfo GetWellKnownType(ElementType elementType);
    internal static ElementType FindElementType(IMetadataTypeInfo metadataTypeInfo);
    public static ElementType ElementTypeByFQN(string fqn);
    public static ElementType FindElementType(IMetadataType metadataType);
    [CompilerGeneratedAttribute]
public MetadataLoaderErrors get_ErrorNotifications();
    protected virtual void DisposeUnmanagedResources();
    internal void AssertCorrectThread();
    public string DumpResolversInformation();
}
public class JetBrains.Metadata.Reader.API.MetadataLoaderErrors : object {
    [NotNullAttribute]
public ISignalOptionalFiring`1<IncompleteAttributeArgs> IncompleteAttribute;
    [NotNullAttribute]
public ISignalOptionalFiring`1<UndeclaredAssemblyReferenceArgs> UndeclaredAssemblyReference;
    [NotNullAttribute]
public ISignalOptionalFiring`1<UnresolvedTypeArgs> UnresolvedType;
}
public enum JetBrains.Metadata.Reader.API.MetadataModifierKind : Enum {
    public int value__;
    public static MetadataModifierKind Optional;
    public static MetadataModifierKind Required;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.MetadataParameterEx : object {
    [ExtensionAttribute]
public static int Index(IMetadataParameter parameter);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetNonEmptyName(IMetadataParameter parameter);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetIndexedName(IMetadataParameter parameter);
    [NotNullAttribute]
public static string GetParameterIndexedName(int index, bool parametersOwnerIsStatic);
}
public class JetBrains.Metadata.Reader.API.MetadataTupleTypeComparer : MetadataTypeComparer {
    public static IEqualityComparer`1<IMetadataType> TupleComparerInstance;
    private static MetadataTupleTypeComparer();
    protected virtual bool TupleEquals(IMetadataTupleType tuple1, IMetadataType type2);
    protected virtual int GetTupleHashCode(IMetadataTupleType tuple);
}
public class JetBrains.Metadata.Reader.API.MetadataTupleTypeComponent : object {
    [CompilerGeneratedAttribute]
private IMetadataType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExplicitName>k__BackingField;
    public IMetadataType Type { get; }
    [CanBeNullAttribute]
public string ExplicitName { get; }
    public MetadataTupleTypeComponent(IMetadataType type, string explicitName);
    [CompilerGeneratedAttribute]
public IMetadataType get_Type();
    [CompilerGeneratedAttribute]
public string get_ExplicitName();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.API.MetadataTypeComparer : object {
    public static IEqualityComparer`1<IMetadataType> Instance;
    [CanBeNullAttribute]
private IEqualityComparer`1<IMetadataTypeInfo> myTypeInfoComparer;
    public MetadataTypeComparer(IEqualityComparer`1<IMetadataTypeInfo> typeInfoComparer);
    private static MetadataTypeComparer();
    public sealed virtual bool Equals(IMetadataType type1, IMetadataType type2);
    public sealed virtual int GetHashCode(IMetadataType type);
    protected virtual bool TupleEquals(IMetadataTupleType tuple1, IMetadataType type2);
    protected virtual int GetTupleHashCode(IMetadataTupleType tuple);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.MetadataTypeEx : object {
    [ExtensionAttribute]
public static JetHashSet`1<IMetadataClassType> GetBaseTypesAndInterfacesRecursive(IMetadataClassType type);
    [ExtensionAttribute]
internal static JetHashSet`1<IMetadataClassType> GetBaseTypesAndInterfacesRecursive(IMetadataClassType type, IEqualityComparer`1<IMetadataType> comparer);
    [ExtensionAttribute]
public static JetHashSet`1<IMetadataClassType> GetBaseTypesAndInterfacesRecursive(IMetadataTypeParameterReferenceType typeParameterReferenceType);
    [IteratorStateMachineAttribute("JetBrains.Metadata.Reader.API.MetadataTypeEx/<GetBaseTypes>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<IMetadataType> GetBaseTypes(IMetadataType type);
    [ExtensionAttribute]
public static bool IsSubtypeOf(IMetadataType subType, IMetadataType superType);
    [ExtensionAttribute]
public static bool IsBaseOf(IMetadataType baseType, IMetadataType derivedType);
    [ExtensionAttribute]
public static bool IsImplementedBy(IMetadataType interfaceType, IMetadataType implementationType);
    [ExtensionAttribute]
public static bool IsBinaryEquivalentTo(IMetadataType type1, IMetadataType type2);
    [ExtensionAttribute]
public static bool IsAssignmentCompatibleWith(IMetadataType weakerType, IMetadataType strongerType);
    [ExtensionAttribute]
public static bool IsImplicitNumericConvertibleTo(IMetadataType from, IMetadataType to);
    [ExtensionAttribute]
public static bool IsEqualTo(IMetadataType type1, IMetadataType type2);
    [ExtensionAttribute]
public static bool IsTupleEqualTo(IMetadataType type1, IMetadataType type2);
    [ExtensionAttribute]
public static IMetadataType UnwrapArrayType(IMetadataType type);
    [ExtensionAttribute]
public static IMetadataType UnwrapEnumType(IMetadataType type);
    [ExtensionAttribute]
public static IMetadataType UnwrapBoxedType(IMetadataType type);
    [ExtensionAttribute]
public static T LookupMember(IMetadataClassType type, Func`2<IMetadataTypeInfo, IEnumerable`1<T>> membersSelector, Predicate`1<T> memberChecker);
    private static LookupResult LookupMember(IMetadataClassType type, Func`2<IMetadataTypeInfo, IEnumerable`1<T>> membersSelector, Predicate`1<T> memberChecker, T& member);
    private static LookupResult LookupInterfaceMember(IMetadataClassType type, JetHashSet`1<IMetadataClassType> visitedTypes, Func`2<IMetadataTypeInfo, IEnumerable`1<T>> membersSelector, Predicate`1<T> memberChecker, T& member);
    private static LookupResult LookupMemberNonRecursive(IMetadataClassType type, Func`2<IMetadataTypeInfo, IEnumerable`1<T>> membersSelector, Predicate`1<T> memberChecker, T& member);
    [ExtensionAttribute]
public static IMetadataType ToBoxedType(IMetadataType type);
    private static string StripTypeParametersCount(IMetadataTypeInfo type, string name);
    [ExtensionAttribute]
public static string TypeParametersCountStrippedShortName(IMetadataTypeInfo type);
    [ExtensionAttribute]
public static string TypeParametersCountStrippedFullName(IMetadataTypeInfo type);
    [ExtensionAttribute]
public static string ShortNameWithTypeParameters(IMetadataTypeInfo type);
    [ExtensionAttribute]
public static IMetadataTypeParameter[] GetTypeOwnTypeParameters(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
public static IList`1<int> GetTypeParameterNumberDistribution(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
public static bool IsReferenceType(IMetadataType type);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataReferenceType AsReferenceType(IMetadataType type);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ItemCanBeNullAttribute]
public static String[] GetTupleElementNames(IMetadataType type);
    [ExtensionAttribute]
public static bool IsGenericType(IMetadataType type);
}
public static class JetBrains.Metadata.Reader.API.MetadataTypeFactory : object {
    public static IMetadataTypeModifier CreateModifier(MetadataModifierKind kind, IMetadataType type);
    [NotNullAttribute]
public static IMetadataClassType CreateClassType(IMetadataTypeInfo typeInfo, IMetadataType[] genericArguments, IMetadataTypeModifier[] typeModifiers, bool pinned);
    [NotNullAttribute]
public static IMetadataTupleType CreateTupleType(IMetadataClassType underlyingType, MetadataTupleTypeComponent[] components);
    [NotNullAttribute]
public static IMetadataType ApplyTupleElementNames(IMetadataType type, String[] tupleElementNames);
    [NotNullAttribute]
public static IMetadataArrayType CreateArrayType(IMetadataType elementType, IMetadataTypeModifier[] typeModifiers, bool pinned);
    [NotNullAttribute]
public static IMetadataArrayType CreateArrayType(IMetadataType elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds, IMetadataTypeModifier[] typeModifiers, bool pinned);
    [NotNullAttribute]
public static IMetadataPointerType CreatePointerType(IMetadataType elementType, IMetadataTypeModifier[] typeModifiers, bool pinned);
    [NotNullAttribute]
public static IMetadataFunctionPointerType CreateFunctionPointerType(MethodSignature methodSignature, IMetadataTypeModifier[] typeModifiers, bool pinned);
    [NotNullAttribute]
public static IMetadataReferenceType CreateReferenceType(IMetadataType elementType, IMetadataTypeModifier[] typeModifiers, bool pinned);
    [NotNullAttribute]
public static IMetadataTypeParameterReferenceType CreateTypeParameterReferenceType(IMetadataTypeParameter typeParameter, IMetadataTypeModifier[] typeModifiers, bool pinned);
    [NotNullAttribute]
public static IMetadataClassType CreateUndecodedType();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.MetadataTypeParameterExtensions : object {
    [ExtensionAttribute]
public static bool IsCovariant(IMetadataTypeParameter metadataTypeParameter);
    [ExtensionAttribute]
public static bool IsContravariant(IMetadataTypeParameter metadataTypeParameter);
    [ExtensionAttribute]
public static bool HasClassConstraint(IMetadataTypeParameter metadataTypeParameter);
    [ExtensionAttribute]
public static bool HasStructConstraint(IMetadataTypeParameter metadataTypeParameter);
    [ExtensionAttribute]
public static bool HasDefaultConstructorConstraint(IMetadataTypeParameter metadataTypeParameter);
    [ExtensionAttribute]
public static bool HasUnmanagedConstraint(IMetadataTypeParameter typeParameter);
    [ExtensionAttribute]
private static bool HasValueTypeTypeConstraint(IMetadataTypeParameter typeParameter, bool modreqUnmanagedType);
}
public class JetBrains.Metadata.Reader.API.MetadataTypeReference : ValueType {
    public static MetadataTypeReference Nil;
    [CanBeNullAttribute]
public AssemblyNameInfo AssemblyName;
    [NotNullAttribute]
public string NamespaceName;
    [NotNullAttribute]
public string TypeName;
    public StringDotConcat FullName { get; }
    public MetadataTypeReference(AssemblyNameInfo assemblyName, string namespaceName, string typeName);
    private static MetadataTypeReference();
    public StringDotConcat get_FullName();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.MetadataTypeUtil : object {
    public static int GetTypeSize(IMetadataTypeInfo type);
    [ExtensionAttribute]
public static IMetadataClassType GetBaseType(IMetadataType type);
    [ExtensionAttribute]
public static IMetadataClassType[] GetInterfaces(IMetadataClassType classType);
    [ExtensionAttribute]
public static T SubstituteGenericArguments(T inputType, IMetadataClassType substitutionsProvider);
    [ExtensionAttribute]
public static T SubstituteGenericArguments(T inputType, MethodInstantiation substitutionsProvider);
    [ExtensionAttribute]
public static T SubstituteGenericArguments(T inputType, MethodSpecification methodSpecification, IMetadataType[] methodInstantiationGenericArguments);
    [ExtensionAttribute]
public static T SubstituteGenericArguments(T inputType, IMetadataMethod metadataMethod, IMetadataClassType ownerType, IMetadataType[] methodInstantiationGenericArguments);
    [ExtensionAttribute]
public static T SubstituteGenericArguments(T inputType, IDictionary`2<IMetadataTypeParameter, IMetadataType> substitutions);
    [ExtensionAttribute]
public static IMetadataType MakeGenericType(IMetadataType inputType, IMetadataType[] genericArguments);
    [ExtensionAttribute]
[NotNullAttribute]
public static IMetadataType GetGenericTypeDefinition(IMetadataType type);
    [ExtensionAttribute]
[NotNullAttribute]
public static IMetadataType GetGenericArrayDefinition(IMetadataArrayType type);
    private static bool IsGenericSubstitutionNeeded(IMetadataType type);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static MetadataLoader GetLoader(IMetadataType type);
    [ExtensionAttribute]
public static bool IsMscorlibClassType(IMetadataType type, string fullyQualifiedName);
    [ExtensionAttribute]
public static bool IsFlagsEnumType(IMetadataType enumType);
    [ExtensionAttribute]
public static bool IsEnumValueField(IMetadataField field);
}
public class JetBrains.Metadata.Reader.API.MethodInstantiation : object {
    [CompilerGeneratedAttribute]
private MethodSpecification <MethodSpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType[] <GenericArguments>k__BackingField;
    [NotNullAttribute]
public MethodSpecification MethodSpecification { get; }
    [NotNullAttribute]
public IMetadataType[] GenericArguments { get; }
    public MethodInstantiation(MethodSpecification methodSpecification, IMetadataType[] genericArguments);
    public MethodInstantiation(MethodSpecification methodSpecification);
    [CompilerGeneratedAttribute]
public MethodSpecification get_MethodSpecification();
    [CompilerGeneratedAttribute]
public IMetadataType[] get_GenericArguments();
    private static MethodInstantiation FromBlob(IBlob blob, IMetadataAssembly assembly, MethodSpecification methodSpecification, TypeDecodeContext context);
    internal static MethodInstantiation FromSpecification(MethodSpecification methodSpecification);
    internal static MethodInstantiation FromToken(MetadataToken methodSpecToken, IMetadataAssembly assembly, TypeDecodeContext context);
    public sealed virtual bool Equals(MethodInstantiation other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.API.MethodSignature : object {
    [CompilerGeneratedAttribute]
private Prologs <SignatureFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MethodTypeParametersCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType[] <ParameterTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType[] <VarargParameterTypes>k__BackingField;
    public Prologs SignatureFlags { get; }
    public bool IsVararg { get; }
    public bool HasThis { get; }
    public UInt32 MethodTypeParametersCount { get; }
    [NotNullAttribute]
public IMetadataType ReturnType { get; }
    [NotNullAttribute]
public IMetadataType[] ParameterTypes { get; }
    [NotNullAttribute]
public IMetadataType[] VarargParameterTypes { get; }
    public int ParamCount { get; }
    public MethodSignature(Prologs signatureFlags, UInt32 methodTypeParametersCount, IMetadataType returnType, IMetadataType[] parameterTypes, IMetadataType[] varargParameterTypes);
    [CompilerGeneratedAttribute]
public Prologs get_SignatureFlags();
    public bool get_IsVararg();
    public bool get_HasThis();
    [CompilerGeneratedAttribute]
public UInt32 get_MethodTypeParametersCount();
    [CompilerGeneratedAttribute]
public IMetadataType get_ReturnType();
    [CompilerGeneratedAttribute]
public IMetadataType[] get_ParameterTypes();
    [CompilerGeneratedAttribute]
public IMetadataType[] get_VarargParameterTypes();
    public int get_ParamCount();
    public sealed virtual bool Equals(MethodSignature other);
    public bool Equals(MethodSignature other, IEqualityComparer`1<IMetadataType> comparer);
    private static bool Compare(MethodSignature a, MethodSignature b, bool compareVararg, bool compareReturnType, IEqualityComparer`1<IMetadataType> comparer);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public MethodSignature TransformTypes(Func`2<IMetadataType, IMetadataType> transformer);
    public bool CanBeCalledBy(MethodSignature by, IEqualityComparer`1<IMetadataType> comparer);
    public bool CompareWithoutReturnType(MethodSignature other, IEqualityComparer`1<IMetadataType> comparer);
    public static bool AreSimplifiedEqual(MethodSignature a, MethodSignature b);
    private static bool AreSimplifiedEqual(IMetadataType type1, IMetadataType type2);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.MethodSignatureUtil : object {
    [ExtensionAttribute]
public static MethodSignature SubstituteGenericArguments(MethodSignature signature, IMetadataClassType substitutionsProvider);
}
public class JetBrains.Metadata.Reader.API.MethodSpecification : object {
    public static MethodSpecification Null;
    [CompilerGeneratedAttribute]
private IMetadataClassType <OwnerType>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType[] <VarargParameters>k__BackingField;
    [CanBeNullAttribute]
public IMetadataClassType OwnerType { get; }
    [CanBeNullAttribute]
public IMetadataMethod Method { get; }
    [CanBeNullAttribute]
public IMetadataType[] VarargParameters { get; }
    public MethodSpecification(IMetadataMethod method, IMetadataType[] varargParameters);
    public MethodSpecification(IMetadataMethod method, IMetadataClassType ownerType, IMetadataType[] varargParameters);
    private static MethodSpecification();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_OwnerType();
    [CompilerGeneratedAttribute]
public IMetadataMethod get_Method();
    [CompilerGeneratedAttribute]
public IMetadataType[] get_VarargParameters();
    public sealed virtual bool Equals(MethodSpecification other);
    public static bool op_Equality(MethodSpecification s1, MethodSpecification s2);
    public static bool op_Inequality(MethodSpecification s1, MethodSpecification s2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.API.MethodUsageCount : object {
    [CompilerGeneratedAttribute]
private IMetadataMethod <Usage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [NotNullAttribute]
public IMetadataMethod Usage { get; }
    public int Count { get; }
    public MethodUsageCount(IMetadataMethod usage, int count);
    public MethodUsageCount(IMetadataMethod usage);
    [CompilerGeneratedAttribute]
public IMetadataMethod get_Usage();
    [CompilerGeneratedAttribute]
public int get_Count();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.MethodUsageCountExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<int> GetIndices(MethodUsageCount usageCount);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.ModuleReferenceResolveContextEx : object {
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertIsValid(IModuleReferenceResolveContext resolveContext);
}
internal class JetBrains.Metadata.Reader.API.MonoCurrentRuntimeAssemblyResolver : object {
    private MonoGacAssemblyResolver myGac;
    private AssemblyResolverOnFolders myRuntimeFolderResolver;
    private MonoRuntime myMonoRuntime;
    public sealed virtual void DumpDebugInformation(IndentedTextWriter textWriter);
    public sealed virtual bool IsUnderResolvePaths(VirtualFileSystemPath path);
    public sealed virtual IMetadataAccess ResolveAssembly(AssemblyNameInfo name, IAssemblyLocation& assemblyLocation, IModuleReferenceResolveContext moduleReferenceResolveContext);
    public sealed virtual VirtualFileSystemPath TryResolveAssemblyPath(AssemblyNameInfo name);
    private static AssemblyResolverOnFolders CreateAdditionalFoldersResolver(MonoRuntime monoRuntime);
}
public class JetBrains.Metadata.Reader.API.MonoGacAssemblyResolver : object {
    private ILogger Logger;
    private MonoRuntime myMonoRuntime;
    private GacResolvePreferences myPreferences;
    public MonoGacAssemblyResolver(MonoRuntime monoRuntime, GacResolvePreferences preferences);
    public virtual VirtualFileSystemPath TryResolveAssemblyPath(AssemblyNameInfo name);
    [NotNullAttribute]
private IList`1<VirtualFileSystemPath> GetCandidatesFromGac(AssemblyNameInfo name);
    [NotNullAttribute]
private VirtualFileSystemPath ResolveInGac(AssemblyNameInfo assemblyName);
    public sealed virtual IMetadataAccess ResolveAssembly(AssemblyNameInfo name, IAssemblyLocation& assemblyLocation, IModuleReferenceResolveContext moduleReferenceResolveContext);
    public sealed virtual bool IsUnderResolvePaths(VirtualFileSystemPath path);
    public sealed virtual void DumpDebugInformation(IndentedTextWriter textWriter);
}
public enum JetBrains.Metadata.Reader.API.NullableAnnotation : Enum {
    public byte value__;
    public static NullableAnnotation Unknown;
    public static NullableAnnotation NotAnnotated;
    public static NullableAnnotation NotAnnotatedFlowUnknown;
    public static NullableAnnotation Annotated;
    public static NullableAnnotation NotNullable;
    public static NullableAnnotation RuntimeNotNullable;
    public static NullableAnnotation Nullable;
    public static NullableAnnotation UnknownJetBrainsCanBeNull;
    public static NullableAnnotation UnknownJetBrainsNotNull;
    public static NullableAnnotation UnknownFlowUnknown;
    public static NullableAnnotation NullableJetBrainsNotNull;
}
public static class JetBrains.Metadata.Reader.API.NullableAnnotationUtil : object {
    [PureAttribute]
public static NullableAnnotation DecodeNullableAnnotation(byte value);
    [PureAttribute]
public static Nullable`1<NullableAnnotation> TryDecodeNullableAnnotation(byte value);
    [PureAttribute]
public static byte EncodeNullableAnnotation(NullableAnnotation nullableAnnotation);
}
public class JetBrains.Metadata.Reader.API.NullType : SentinelTypeBase {
    public static IMetadataType Instance;
    public string FullName { get; }
    public bool IsResolved { get; }
    private static NullType();
    public virtual string get_FullName();
    public virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
}
public class JetBrains.Metadata.Reader.API.PInvokeInfo : object {
    private CorPInvokeMap myFlags;
    private string myImportName;
    private string myModuleName;
    public string ModuleName { get; }
    public string ImportName { get; }
    public CallConvSpec CallConv { get; }
    public CharSetSpec CharSet { get; }
    public BestFitFlag BestFit { get; }
    public ThrowOnUnmappableFlag ThrowOnUnmappable { get; }
    public bool SupportsLastError { get; }
    public bool NoMangle { get; }
    public PInvokeInfo(CorPInvokeMap flags, string moduleName, string importName);
    public PInvokeInfo(BinaryReader reader);
    public void Save(BinaryWriter writer);
    public string get_ModuleName();
    public string get_ImportName();
    public CallConvSpec get_CallConv();
    public CharSetSpec get_CharSet();
    public BestFitFlag get_BestFit();
    public ThrowOnUnmappableFlag get_ThrowOnUnmappable();
    public bool get_SupportsLastError();
    public bool get_NoMangle();
}
public abstract class JetBrains.Metadata.Reader.API.RecursiveMetadataTypeVisitor : object {
    public sealed virtual void VisitUnknownType(IMetadataType unknownType);
    public sealed virtual void VisitArrayType(IMetadataArrayType arrayType);
    public abstract virtual void VisitClassType(IMetadataClassType classType);
    public sealed virtual void VisitTupleType(IMetadataTupleType tupleType);
    public sealed virtual void VisitPointerType(IMetadataPointerType pointerType);
    public sealed virtual void VisitReferenceType(IMetadataReferenceType referenceType);
    public virtual void VisitTypeParameterReferenceType(IMetadataTypeParameterReferenceType typeParameterReferenceType);
    public virtual void VisitFunctionPointer(IMetadataFunctionPointerType functionPointerType);
    public sealed virtual void VisitBoxedType(IMetadataBoxedType boxedType);
}
public enum JetBrains.Metadata.Reader.API.SecurityAction : Enum {
    public int value__;
    public static SecurityAction ActionNil;
    public static SecurityAction Request;
    public static SecurityAction Demand;
    public static SecurityAction Assert;
    public static SecurityAction Deny;
    public static SecurityAction PermitOnly;
    public static SecurityAction LinkDemand;
    public static SecurityAction InheritanceDemand;
    public static SecurityAction RequestMinimum;
    public static SecurityAction RequestOptional;
    public static SecurityAction RequestRefuse;
    public static SecurityAction PrejitGrant;
    public static SecurityAction PrejitDenied;
    public static SecurityAction NonCasDemand;
    public static SecurityAction NonCasLinkDemand;
    public static SecurityAction NonCasInheritance;
}
public abstract class JetBrains.Metadata.Reader.API.SentinelTypeBase : object {
    public string AssemblyQualifiedName { get; }
    public string FullName { get; }
    public string AssemblyQualification { get; }
    public IMetadataTypeModifier[] TypeModifiers { get; }
    public bool Pinned { get; }
    public bool IsResolved { get; }
    public sealed virtual string get_AssemblyQualifiedName();
    public abstract virtual string get_FullName();
    public sealed virtual string get_AssemblyQualification();
    public sealed virtual IMetadataTypeModifier[] get_TypeModifiers();
    public sealed virtual bool get_Pinned();
    public abstract virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public sealed virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public virtual string ToString();
}
public static class JetBrains.Metadata.Reader.API.StandardMemberNames : object {
    public static string PropertyGetterPrefix;
    public static string PropertySetterPrefix;
    public static string EventAdderPrefix;
    public static string EventRemoverPrefix;
    public static string EventRaiserPrefix;
    public static string Constructor;
    public static string ClassConstructor;
    public static string Main;
    public static string CompilerGeneratedMain;
    public static string TopLevelEntryPoint;
    public static string ObsoleteTopLevelEntryPoint;
    public static string ObjectToString;
    public static string ObjectFinalize;
    public static string ObjectGetType;
    public static string ObjectEquals;
    public static string ObjectGetHashCode;
    public static string ArraySet;
    public static string ArrayGet;
    public static string ArrayAddress;
    public static string ArrayLength;
    public static string ArrayEmpty;
    public static string ArrayInternalGetReference;
    public static string StringLength;
    public static string StringEquals;
    public static string StringChars;
    public static string StringConcat;
    public static string IsInterned;
    public static string RuntimeHelpersInitializeArray;
    public static string RuntimeHelpersOffsetToStringData;
    public static string TypeGetTypeFromHandle;
    public static string InitializeArrayMethod;
    public static string MethodBaseGetMethodFromHandle;
    public static string FieldInfoGetFieldFromHandle;
    public static string EnumerableGetEnumerator;
    public static string EnumerableGetAsyncEnumerator;
    public static string EnumeratorMoveNext;
    public static string EnumeratorMoveNextAsync;
    public static string EnumeratorCurrent;
    public static string EnumeratorGetCurrent;
    public static string AsyncStateMachineMoveNext;
    public static string TaskExecuteWithThreadLocal;
    public static string TaskWaitAllBlockingCore;
    public static string TaskInternalWait;
    public static string TaskInternalWaitCore;
    public static string TaskInternalRunSynchronously;
    public static string TaskSpinThenBlockingWait;
    public static string ManualResetEventSlimWait;
    public static string AsyncIteratorMethodBuilderCreate;
    public static string MethodBuilderTask;
    public static string SetNotificationForWaitCompletion;
    public static string NotifyDebuggerOfWaitCompletionIfNecessary;
    public static string NotifyDebuggerOfWaitCompletion;
    public static string CompilerGeneratedBuilder;
    public static string TaskConfigureAwait;
    public static string TaskFromResult;
    public static string TaskResult;
    public static string TaskWait;
    public static string ValueTaskAsTask;
    public static string AwaitableGetAwaiter;
    public static string AwaiterIsCompleted;
    public static string AwaiterGetResult;
    public static string AwaiterOnCompleted;
    public static string FixedArrayFixedElementField;
    public static string IDisposableDispose;
    public static string IAsyncDisposableDisposeAsync;
    public static string IntPtrZero;
    public static string IntPtrToInt64;
    public static string UIntPtrZero;
    public static string MonitorEnter;
    public static string MonitorExit;
    public static string CharMinValue;
    public static string CharMaxValue;
    public static string SByteMinValue;
    public static string SByteMaxValue;
    public static string ByteMinValue;
    public static string ByteMaxValue;
    public static string Int16MinValue;
    public static string Int16MaxValue;
    public static string UInt16MinValue;
    public static string UInt16MaxValue;
    public static string Int32MinValue;
    public static string Int32MaxValue;
    public static string UInt32MinValue;
    public static string UInt32MaxValue;
    public static string Int64MinValue;
    public static string Int64MaxValue;
    public static string UInt64MinValue;
    public static string UInt64MaxValue;
    public static string SingleMinValue;
    public static string SingleMaxValue;
    public static string DoubleMinValue;
    public static string DoubleMaxValue;
    public static string SingleEpsilon;
    public static string DoubleEpsilon;
    public static string SingleNaN;
    public static string DoubleNaN;
    public static string SinglePositiveInfinity;
    public static string DoublePositiveInfinity;
    public static string SingleNegativeInfinity;
    public static string DoubleNegativeInfinity;
    public static string SingleIsNaN;
    public static string DoubleIsNaN;
    public static string DecimalZero;
    public static string DecimalOne;
    public static string DecimalMinusOne;
    public static string DecimalMinValue;
    public static string DecimalMaxValue;
    public static string ActivatorCreateInstance;
    public static string ArrayCreateInstance;
    public static string DebuggerBreak;
    public static string HashtableAdd;
    public static string DictionaryAdd;
    public static string DictionaryTryGetValue;
    public static string DelegateCombine;
    public static string DelegateRemove;
    public static string DelegateInvoke;
    public static string DelegateMethod;
    public static string DelegateTarget;
    public static string MsDelegateMethodBaseField;
    public static string MsDelegateInvocationCountField;
    public static string MsDelegateMethodPtrAuxField;
    public static string MsDelegateMethodPtrField;
    public static string MsDelegateInvocationListField;
    public static string MsDelegateTargetField;
    public static string MonoDelegateMethodInfoField;
    public static string MonoDelegateDelegatesField;
    public static string MonoDelegateTargetField;
    public static string MonoDelegateOriginalMethodInfoField;
    public static string NullableValue;
    public static string NullableHasValue;
    public static string NullableGetValueOrDefault;
    public static string NullableHasValueField;
    public static string NullableHasValueFieldOldMono;
    public static string ValueTupleItemPrefix;
    public static string ValueTupleItem1;
    public static string ValueTupleItem2;
    public static string ValueTupleItem3;
    public static string ValueTupleItem4;
    public static string ValueTupleItem5;
    public static string ValueTupleItem6;
    public static string ValueTupleItem7;
    public static string ValueTupleRest;
    public static string Deconstruct;
    public static string RecordEqualityContract;
    public static string RecordPrintMembers;
    public static string RecordClone;
    public static string StringBuilderAppend;
    public static string DefaultIndexerName;
    public static string MathPi;
    public static string MathE;
    public static string MethodCodeTypeOfMethodImplAttribute;
    public static string AssemblyLoadFrom;
    public static string AssemblyLoad;
    public static string ExceptionDispatchInfoThrow;
    public static string ExceptionDispatchInfoCapture;
    public static char BackingFieldPrefix;
    public static string BackingFieldSuffix;
    public static string PrimaryCtorBackingFieldSuffix;
    public static string RuntimeHelpers;
    public static string RuntimeHelpersEnsureSufficientExecutionStack;
    public static string MemberInfoMetadataToken;
    public static string TypeFullName;
    public static string TypeDeclaringType;
    public static string TypeAssembly;
    public static string TypeOpEquality;
    public static string TypeOpInEquality;
    public static string M_value;
    public static string _value;
    public static string Array_GetLength;
    public static string String_FastAllocateString;
    public static string StringM_firstChar;
    public static string StringFirstChar;
    public static string StringM_lengthField;
    public static string StringLengthField;
    public static string OffsetToStringData;
    public static string Format;
    public static string Get_IsGenericType;
    public static string ArraySize;
    public static string ArrayItems;
    public static string DataColumnName;
    public static string DataTableDataTypeNetCore;
    public static string DataTableDataTypeFramework;
    public static string DataTableRowsNetCore;
    public static string DataTableRowsFramework;
    public static string DataTableColumnCollectionsNetCore;
    public static string DataTableColumnCollectionsFramework;
    public static string DataTableGetItem;
    public static string DataTableCount;
    public static string DataTableList;
    public static string DataTableItemArray;
    public static string Where;
    public static string Cast;
    public static string AssemblyQualifiedName;
}
public static class JetBrains.Metadata.Reader.API.StandardOperatorNames : object {
    public static string OperatorPrefix;
    public static string Decrement;
    public static string CheckedDecrement;
    public static string Increment;
    public static string CheckedIncrement;
    public static string UnaryNegation;
    public static string CheckedUnaryNegation;
    public static string UnaryPlus;
    public static string LogicalNot;
    public static string True;
    public static string False;
    public static string AddressOf;
    public static string OnesComplement;
    public static string PointerDereference;
    public static string Addition;
    public static string CheckedAddition;
    public static string Subtraction;
    public static string CheckedSubtraction;
    public static string Multiply;
    public static string CheckedMultiply;
    public static string Division;
    public static string CheckedDivision;
    public static string Modulus;
    public static string ExclusiveOr;
    public static string BitwiseAnd;
    public static string BitwiseOr;
    public static string LogicalAnd;
    public static string LogicalOr;
    public static string Assign;
    public static string LeftShift;
    public static string RightShift;
    public static string SignedRightShift;
    public static string UnsignedRightShift;
    public static string Equality;
    public static string GreaterThan;
    public static string LessThan;
    public static string Inequality;
    public static string GreaterThanOrEqual;
    public static string LessThanOrEqual;
    public static string UnsignedRightShiftAssignment;
    public static string MemberSelection;
    public static string RightShiftAssignment;
    public static string MultiplicationAssignment;
    public static string PointerToMemberSelection;
    public static string SubtractionAssignment;
    public static string ExclusiveOrAssignment;
    public static string LeftShiftAssignment;
    public static string ModulusAssignment;
    public static string AdditionAssignment;
    public static string BitwiseAndAssignment;
    public static string BitwiseOrAssignment;
    public static string Comma;
    public static string DivisionAssignment;
    public static string Implicit;
    public static string Explicit;
    public static string CheckedExplicit;
}
public static class JetBrains.Metadata.Reader.API.StandardTypeNames : object {
    public static string ModuleType;
    public static string TopLevelProgram;
    public static string TopLevelProgramNew;
    public static string ObsoleteTopLevelProgram;
    public static string Array;
    public static string Boolean;
    public static string Char;
    public static string IntPtr;
    public static string SByte;
    public static string Int16;
    public static string Int32;
    public static string Int64;
    public static string Object;
    public static string Single;
    public static string Double;
    public static string String;
    public static string UIntPtr;
    public static string Byte;
    public static string UInt16;
    public static string UInt32;
    public static string UInt64;
    public static string Void;
    public static string Decimal;
    public static string Guid;
    public static string TypedReference;
    public static string Type;
    public static string ValueType;
    public static string Enum;
    public static string Delegate;
    public static string MulticastDelegate;
    public static string Exception;
    public static string Activator;
    public static string Nullable;
    public static string Index;
    public static string Range;
    public static string Span1;
    public static string ReadOnlySpan1;
    public static string FlagsAttribute;
    public static string NonSerializedAttribute;
    public static string SerializableAttribute;
    public static string ObsoleteAttribute;
    public static string IDisposable;
    public static string IAsyncDisposable;
    public static string ParamArrayAttribute;
    public static string ParamCollectionAttribute;
    public static string DateTime;
    public static string TimeSpan;
    public static string Math;
    public static string StringBuilder;
    public static string Task;
    public static string Task1;
    public static string ValueTask;
    public static string ValueTask1;
    public static string ConfiguredTaskAwaitable;
    public static string ConfiguredTaskAwaitable1;
    public static string ConfiguredValueTaskAwaitable;
    public static string ConfiguredValueTaskAwaitable1;
    public static string ConfiguredCancelableAsyncEnumerable1;
    public static string ConfiguredCancelableAsyncEnumerable1Enumerator;
    public static string CancellationToken;
    public static string TupleElementNamesAttribute;
    public static string ITuple;
    public static string ValueTuple;
    public static string ValueTuple1;
    public static string ValueTuple2;
    public static string ValueTuple3;
    public static string ValueTuple4;
    public static string ValueTuple5;
    public static string ValueTuple6;
    public static string ValueTuple7;
    public static string ValueTuple8;
    public static int ValueTupleMaxTypeParametersCount;
    public static string GenericValueTuplePrefix;
    public static string ActionPrefix;
    public static int ActionMaxTypeParametersCount;
    public static string FuncPrefix;
    public static int FuncMaxTypeParametersCount;
    public static string EventHandlerSuffix;
    public static string EventHandler1Suffix;
    public static string CallbackSuffix;
    public static string FieldInfo;
    public static string RuntimeMethodHandle;
    public static string RuntimeTypeHandle;
    public static string RuntimeFieldHandle;
    public static string RuntimeArgumentHandle;
    public static string Monitor;
    public static string Attribute;
    public static string AttributeSuffix;
    public static int AttributeSuffixLength;
    public static string DynamicAttribute;
    public static string FixedBufferAttribute;
    public static string DecimalConstantAttribute;
    public static string IsVolatile;
    public static string CompilationRelaxationsAttribute;
    public static string CompilerGeneratedAttribute;
    public static string IndexerNameAttribute;
    public static string MethodImplAttribute;
    public static string MethodImplOptions;
    public static string MethodCodeType;
    public static string NullableAttribute;
    public static string NullableContextAttribute;
    public static string NullablePublicOnlyAttribute;
    public static string SpecialNameAttribute;
    public static string SuppressIldasmAttribute;
    public static string ExtensionAttribute;
    public static string RuntimeCompatibilityAttribute;
    public static string RuntimeHelpers;
    public static string ReferenceAssemblyAttribute;
    public static string AsyncStateMachineAttribute;
    public static string IAsyncStateMachine;
    public static string IteratorStateMachineAttribute;
    public static string AsyncIteratorStateMachineAttribute;
    public static string TypeForwardedToAttribute;
    public static string IsReadOnlyAttribute;
    public static string IsByRefLikeAttribute;
    public static string IsUnmanagedAttribute;
    public static string UnsafeValueTypeAttribute;
    public static string EmbeddedAttribute;
    public static string AsyncTaskMethodBuilder;
    public static string AsyncIteratorMethodBuilder;
    public static string AsyncVoidMethodBuilder;
    public static string AsyncTaskMethodBuilder1;
    public static string AsyncValueTaskMethodBuilder;
    public static string AsyncValueTaskMethodBuilder1;
    public static string PoolingAsyncValueTaskMethodBuilder;
    public static string PoolingAsyncValueTaskMethodBuilder1;
    public static string AsyncMethodBuilderCore;
    public static string TaskAwaiter;
    public static string TaskAwaiter1;
    public static string EnumeratorCancellationAttribute;
    public static string ScopedRefAttribute;
    public static string IsExplicitlyDereferenced;
    public static string IsExternalInit;
    public static string RequiredMemberAttribute;
    public static string UnmanagedType;
    public static string VarEnum;
    public static string InAttribute;
    public static string OutAttribute;
    public static string OptionalAttribute;
    public static string FieldOffsetAttribute;
    public static string DllImportAttribute;
    public static string MarshalAsAttribute;
    public static string CallingConvention;
    public static string ComImportAttribute;
    public static string StructLayoutAttribute;
    public static string LayoutKind;
    public static string CharSet;
    public static string DefaultParameterValueAttribute;
    public static string TargetFrameworkAttribute;
    public static string TargetPlatformAttribute;
    public static string ExceptionDispatchInfo;
    public static string Assembly;
    public static string AssemblyCompanyAttribute;
    public static string AssemblyConfigurationAttribute;
    public static string AssemblyFileVersionAttribute;
    public static string AssemblyVersionAttribute;
    public static string DefaultMemberAttribute;
    public static string ConfigAssemblyHashAlgorithm;
    public static string PermissionSetAttribute;
    public static string SecurityAction;
    public static string DebuggableAttribute;
    public static string Debugger;
    public static string DebuggerCrossThreadDependencyNotification;
    public static string DebuggerStepThroughAttribute;
    public static string DebuggerHiddenAttribute;
    public static string DebuggerNonUserCodeAttribute;
    public static string DebuggerBrowsableAttribute;
    public static string IEnumerable;
    public static string IEnumerator;
    public static string Hashtable;
    public static string ICollection;
    public static string IList;
    public static string ICollection1;
    public static string Dictionary;
    public static string IList1;
    public static string IEnumerable1;
    public static string IEnumerator1;
    public static string IAsyncEnumerable1;
    public static string IAsyncEnumerator1;
    public static string EnumerableDebugView;
    public static string EnumerableDebugView1;
    public static string EnumerableDebugViewEmptyException;
    public static string ISet1;
    public static string IReadOnlyCollection1;
    public static string IReadOnlyList1;
    public static string HashSet1;
    public static string List1;
    public static string Queue1;
    public static string Stack1;
    public static string IStructuralComparable;
    public static string IStructuralEquatable;
    public static string ICloneable;
    public static string IEquatable1;
    public static string ThreadAbortException;
    public static string Thread;
    public static string OutOfMemoryException;
    public static string StackOverflowException;
    public static string SZArrayHelper;
    public static string TypeIdentifierAttribute;
    public static string SystemComObject;
    public static string SystemEnvironment;
    public static string SystemDiagnosticsStackTraceHiddenAttribute;
    public static string SystemNullReferenceException;
    public static string SystemIndexOutOfRangeException;
    public static string SystemRuntimeCompilerServicesIntrinsicAttribute;
    public static string SystemPlatformNotSupportedException;
    public static string RequiresLocationAttribute;
    public static string SystemDataTable;
    public static string SystemLinqEnumerable;
    public static string AsyncStateMachineBox;
    public static string IAsyncStateMachineBox;
    public static string AwaitTaskContinuation;
    public static string TaskFactory;
    public static string CompleteOnCountdownPromise;
    public static string CompleteOnCountdownPromise1;
    public static string StandardTaskContinuation;
    public static string ContinueWithTaskContinuation;
    public static string ContinuationWrapper;
    public static string MoveNextRunner;
    public static string DelayPromise;
    public static string DelayPromiseWithCancellation;
    public static string WhenAllPromise;
    public static string UnwrapPromise1;
    public static string CancellationPromise;
    public static string CompleteOnInvokePromise;
    public static string CompleteOnInvokePromise1;
    public static string TwoTaskWhenAnyPromise1;
    public static string SetOnInvokeMres;
    public static string SetOnCountdownMres;
    public static string ContinuationTaskFromTask;
    public static string ContinuationResultTaskFromTask1;
    public static string ValueTask1ValueTaskSourceAsTask;
    public static string ValueTaskValueTaskSourceAsTask;
    public static string ManualResetEventSlim;
    public static string ManualResetValueTaskSourceCore;
}
public class JetBrains.Metadata.Reader.API.StreamAssemblyLocation : object {
    [NotNullAttribute]
private Func`1<Stream> myProducer;
    public VirtualFileSystemPath AssemblyPhysicalPath { get; }
    public VirtualFileSystemPath ContainerPhysicalPath { get; }
    public bool IsEmpty { get; }
    public string ShortPresentation { get; }
    public string Name { get; }
    public string NameWithoutExtension { get; }
    public string ExtensionWithDot { get; }
    public IInteractionContext Context { get; }
    public StreamAssemblyLocation(Func`1<Stream> producer);
    public sealed virtual VirtualFileSystemPath get_AssemblyPhysicalPath();
    public sealed virtual VirtualFileSystemPath get_ContainerPhysicalPath();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual string get_ShortPresentation();
    public sealed virtual string get_Name();
    public sealed virtual string get_NameWithoutExtension();
    public sealed virtual string get_ExtensionWithDot();
    public sealed virtual IAssemblyLocation GetNeighbor(string neighborName);
    public sealed virtual bool Equals(IAssemblyLocation other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual Stream OpenForReading();
    public sealed virtual T Visit(IAssemblyLocationVisitor`1<T> visitor);
    public sealed virtual IInteractionContext get_Context();
}
public class JetBrains.Metadata.Reader.API.StreamAssemblyResolver : object {
    private static ILogger ourLogger;
    private IMetadataProvider myMetadataProvider;
    private IOneToManyMap`3<AssemblyNameInfo, ProducerInfo, ISet`1<ProducerInfo>> myProducers;
    public IEnumerable`1<AssemblyNameInfo> Keys { get; }
    public StreamAssemblyResolver(IMetadataProvider metadataProvider, IEnumerable`1<Func`1<Stream>> producers);
    public StreamAssemblyResolver(IEnumerable`1<Func`1<Stream>> producers);
    private static StreamAssemblyResolver();
    public IEnumerable`1<AssemblyNameInfo> get_Keys();
    public sealed virtual IMetadataAccess ResolveAssembly(AssemblyNameInfo name, IAssemblyLocation& location, IModuleReferenceResolveContext context);
    public sealed virtual void DumpDebugInformation(IndentedTextWriter writer);
}
internal class JetBrains.Metadata.Reader.API.TupleElementNamesCollectorVisitor : object {
    private List`1<string> myTupleElementNames;
    [NotNullAttribute]
[ItemCanBeNullAttribute]
public String[] TupleElementNames { get; }
    public String[] get_TupleElementNames();
    public sealed virtual void VisitUnknownType(IMetadataType unknownType);
    public sealed virtual void VisitArrayType(IMetadataArrayType arrayType);
    public sealed virtual void VisitClassType(IMetadataClassType classType);
    public sealed virtual void VisitTupleType(IMetadataTupleType tupleType);
    public sealed virtual void VisitPointerType(IMetadataPointerType pointerType);
    public sealed virtual void VisitReferenceType(IMetadataReferenceType referenceType);
    public sealed virtual void VisitTypeParameterReferenceType(IMetadataTypeParameterReferenceType typeParameterReferenceType);
    public sealed virtual void VisitFunctionPointer(IMetadataFunctionPointerType functionPointerType);
    public sealed virtual void VisitBoxedType(IMetadataBoxedType boxedType);
}
internal class JetBrains.Metadata.Reader.API.TupleTransformer : object {
    [CanBeNullAttribute]
private String[] myTupleElementNames;
    private int myNextTupleElementNameIndex;
    public TupleTransformer(String[] tupleElementNames);
    public sealed virtual IMetadataType TransformArrayType(IMetadataArrayType arrayType);
    public sealed virtual IMetadataType TransformClassType(IMetadataClassType classType);
    public sealed virtual IMetadataType TransformTupleType(IMetadataTupleType tupleType);
    public sealed virtual IMetadataType TransformPointerType(IMetadataPointerType pointerType);
    public sealed virtual IMetadataType TransformReferenceType(IMetadataReferenceType referenceType);
    public sealed virtual IMetadataType TransformTypeParameterReferenceType(IMetadataTypeParameterReferenceType typeParameterReferenceType);
    public sealed virtual IMetadataType TransformFunctionPointerType(IMetadataFunctionPointerType functionPointerType);
    public sealed virtual IMetadataType TransformBoxedType(IMetadataBoxedType boxedType);
}
public class JetBrains.Metadata.Reader.API.TypeDecodeContext : object {
    [CompilerGeneratedAttribute]
private IMetadataTypeParameter[] <TypeTypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataTypeParameter[] <MethodTypeParameters>k__BackingField;
    public IMetadataTypeParameter[] TypeTypeParameters { get; }
    public IMetadataTypeParameter[] MethodTypeParameters { get; }
    public TypeDecodeContext(IMetadataTypeParameter[] typeTypeParameters);
    public TypeDecodeContext(IMetadataTypeParameter[] typeTypeParameters, IMetadataTypeParameter[] methodTypeParameters);
    [CompilerGeneratedAttribute]
public IMetadataTypeParameter[] get_TypeTypeParameters();
    [CompilerGeneratedAttribute]
public IMetadataTypeParameter[] get_MethodTypeParameters();
    public static TypeDecodeContext CreateContextFromType(IMetadataTypeInfo type);
    public static TypeDecodeContext CreateContextFromMethod(IMetadataMethod method);
}
public class JetBrains.Metadata.Reader.API.TypeNameAndTypeParameterNumber : ValueType {
    public string TypeName;
    public int TypeParametersNumber;
    public TypeNameAndTypeParameterNumber(string typeName, int typeParametersNumber);
    public bool Equals(TypeNameAndTypeParameterNumber other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[FlagsAttribute]
public enum JetBrains.Metadata.Reader.API.TypeParameterAttributes : Enum {
    public int value__;
    public static TypeParameterAttributes VarianceMask;
    public static TypeParameterAttributes NonVariant;
    public static TypeParameterAttributes Covariant;
    public static TypeParameterAttributes Contravariant;
    public static TypeParameterAttributes SpecialConstraintMask;
    public static TypeParameterAttributes NoSpecialConstraint;
    public static TypeParameterAttributes ReferenceTypeConstraint;
    public static TypeParameterAttributes ValueTypeConstraint;
    public static TypeParameterAttributes DefaultConstructorConstraint;
    public static TypeParameterAttributes AllowByRefLike;
}
public enum JetBrains.Metadata.Reader.API.TypeParameterKind : Enum {
    public int value__;
    public static TypeParameterKind Type;
    public static TypeParameterKind Method;
}
public class JetBrains.Metadata.Reader.API.UniversalModuleReferenceContext : ConcurrentUserDataHolder {
    [NotNullAttribute]
public static UniversalModuleReferenceContext Instance;
    public string UniqueName { get; }
    public AssemblyNameAndLocation Originator { get; }
    public TargetFrameworkId TargetFramework { get; }
    private static UniversalModuleReferenceContext();
    public VirtualFileSystemPath GetResolveResult(AssemblyReferenceWithSource assemblyReferenceWithSource);
    public void SetResolveResult(AssemblyReferenceWithSource assemblyReferenceWithSource, VirtualFileSystemPath resolveResult);
    public sealed virtual string get_UniqueName();
    public sealed virtual bool IsValid();
    public sealed virtual AssemblyNameAndLocation get_Originator();
    public sealed virtual TargetFrameworkId get_TargetFramework();
    public sealed virtual void Write(BinaryWriter writer);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.UnresolvedMetadataEx : object {
    [ExtensionAttribute]
public static bool IsEqualTo_Unresolved(IMetadataType type1, IMetadataType type2);
    [ExtensionAttribute]
public static bool IsEqualTo_Unresolved(IMetadataTypeInfo type1, IMetadataTypeInfo type2);
    [ExtensionAttribute]
public static bool IsEqualTo_Unresolved(IMetadataMethod method1, IMetadataMethod method2);
    [ExtensionAttribute]
private static bool IsEqualTo_Unresolved(IMetadataType[] parameterTypes1, IMetadataType[] parameterTypes2);
    [ExtensionAttribute]
public static bool IsEqualTo_Unresolved(MethodSpecification method1, MethodSpecification method2);
    [ExtensionAttribute]
public static bool IsEqualTo_Unresolved(IMetadataProperty property1, IMetadataProperty property2);
    public static bool IsEqualTo_Unresolved(IMetadataField field1, IMetadataField field2);
    [ExtensionAttribute]
private static bool IsSpecialNameOrUnresolved(IMetadataTypeMember typeMember);
    [ExtensionAttribute]
public static bool IsConstructor_Unresolved(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsOperator_Unresolved(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsClassConstructor_Unresolved(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsMethod_Unresolved(IMetadataMethod method, string typeFqn, int typeParametersCount, string methodName, int methodTypeParametersCount, int methodParametersCount);
    [ExtensionAttribute]
public static bool IsMethod_Unresolved(IMetadataMethod method, string typeFqn, string methodName, String[] parameterFqns);
    [ExtensionAttribute]
[ContractAnnotationAttribute("type: null => false")]
public static bool IsType_Unresolved(IMetadataType type, string typeFqn, String[] typeArgumentFqns);
    [ExtensionAttribute]
public static bool IsSubtypeOf_Unresolved(IMetadataType subType, IMetadataType superType);
    [ExtensionAttribute]
public static bool IsBaseOf_Unresolved(IMetadataType baseType, IMetadataType derivedType);
    [ExtensionAttribute]
public static JetHashSet`1<IMetadataClassType> GetBaseTypesAndInterfacesRecursive_Unresolved(IMetadataClassType type);
    [ExtensionAttribute]
public static bool IsImplementedBy_Unresolved(IMetadataType interfaceType, IMetadataType implementationType);
    [ExtensionAttribute]
public static bool IsImplementedBy_Unresolved(MethodSpecification interfaceMethod, MethodSpecification implementationMethod);
    [ExtensionAttribute]
public static bool IsAssignmentCompatibleWith_Unresolved(IMetadataType weakerType, IMetadataType strongerType);
    private static AccessorKind GetAccessorType(UnresolvedMethod accessor);
    [NotNullAttribute]
private static string GetMemberOwnerName(string accessorName, AccessorKind accessorKind);
    [CanBeNullAttribute]
private static string GetMemberOwnerName(UnresolvedMethod accessor, AccessorKind accessorKind);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, property: notnull; => false")]
public static bool IsPropertyGetter_Unresolved(IMetadataMethod method, IMetadataProperty& property);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, property: notnull; => false")]
public static bool IsPropertySetter_Unresolved(IMetadataMethod method, IMetadataProperty& property);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, event: notnull; => false")]
public static bool IsEventAdder_Unresolved(IMetadataMethod method, IMetadataEvent& event);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, event: notnull; => false")]
public static bool IsEventRemover_Unresolved(IMetadataMethod method, IMetadataEvent& event);
    [ExtensionAttribute]
public static bool IsIndexer_Unresolved(IMetadataProperty property);
    [ExtensionAttribute]
public static bool IsCompatibleWith_Unresolved(IMetadataType type1, IMetadataType type2);
}
public class JetBrains.Metadata.Reader.API.UnresolvedMetadataTypeComparer : object {
    public static IEqualityComparer`1<IMetadataType> Instance;
    private static UnresolvedMetadataTypeComparer();
    public sealed virtual bool Equals(IMetadataType type1, IMetadataType type2);
    public sealed virtual int GetHashCode(IMetadataType obj);
    public static bool AreEqual(IMetadataTypeInfo type1, IMetadataTypeInfo type2);
}
public static class JetBrains.Metadata.Reader.Impl.BuilderFactory : object {
    public static ITypeBuilder`2<IMetadataType, MethodSignature> CreateTypeBuilder(IMetadataAssembly assembly, TypeDecodeContext typeDecodeContext);
    public static IMethodSignatureBuilder`2<IMetadataType, MethodSignature> CreateMethodSignatureBuilder(IMetadataAssembly assembly, int typeTypeParametersCount);
}
[LocalizableAttribute("False")]
public class JetBrains.Metadata.Reader.Impl.ClrTypeName : ClrTypeNameBase {
    private string myFullName;
    private String[] myNamespaces;
    private TypeNameAndTypeParameterNumber[] myTypes;
    public string ShortName { get; }
    public int TypeParametersCount { get; }
    public string FullName { get; }
    public IEnumerable`1<string> NamespaceNames { get; }
    public IEnumerable`1<TypeNameAndTypeParameterNumber> TypeNames { get; }
    public ClrTypeName(string fullName, Func`2<string, string> intern, IList`1<int> typeParameterNumberFromReflection);
    public ClrTypeName(string fullName, IList`1<int> typeParameterNumberFromReflection);
    [NotNullAttribute]
public static TypeNameAndTypeParameterNumber[] ParseTypeName(Func`2<string, string> intern, string typeNameString, IList`1<int> typeParameterNumberFromReflection, IMetadataTypeInfo typeHint);
    [NotNullAttribute]
private static String[] GetTypes(string typeNameString, IMetadataTypeInfo typeHint, int count);
    public static TypeNameAndTypeParameterNumber ParseSingleTypeName(Func`2<string, string> intern, string typeNameString, int typeParameterNumberFromReflection);
    public virtual IClrTypeName GetPersistent();
    public virtual string get_ShortName();
    public virtual int get_TypeParametersCount();
    public virtual string get_FullName();
    public virtual IEnumerable`1<string> get_NamespaceNames();
    public virtual IEnumerable`1<TypeNameAndTypeParameterNumber> get_TypeNames();
    public virtual int GetPartsCount();
    protected virtual bool CompareParts(IClrTypeName name);
    [NotNullAttribute]
public virtual IClrTypeNamePartIterator GetPartIterator();
    private ClrTypePartArrayIterator GetPartIteratorInternal();
    public virtual string GetFullNameFast();
}
public abstract class JetBrains.Metadata.Reader.Impl.ClrTypeNameBase : object {
    public static string UNRESOLVED_PRESENTATION;
    public string ShortName { get; }
    public string FullName { get; }
    public IEnumerable`1<string> NamespaceNames { get; }
    public IEnumerable`1<TypeNameAndTypeParameterNumber> TypeNames { get; }
    public int TypeParametersCount { get; }
    public abstract virtual string get_ShortName();
    public abstract virtual string get_FullName();
    public abstract virtual IEnumerable`1<string> get_NamespaceNames();
    public abstract virtual IEnumerable`1<TypeNameAndTypeParameterNumber> get_TypeNames();
    public abstract virtual int get_TypeParametersCount();
    public sealed virtual bool Equals(object obj);
    protected virtual bool CompareParts(IClrTypeName name);
    public sealed virtual int GetHashCode();
    public virtual string ToString();
    [NotNullAttribute]
public virtual IClrTypeName GetPersistent();
    public abstract virtual int GetPartsCount();
    public abstract virtual IClrTypeNamePartIterator GetPartIterator();
    public abstract virtual string GetFullNameFast();
}
public class JetBrains.Metadata.Reader.Impl.ClrTypePartArrayIterator : ValueType {
    private TypeNameAndTypeParameterNumber[] myTypes;
    private String[] myNamespaces;
    private int myTypeIndex;
    private int myNamespaceIndex;
    public ClrTypePartArrayIterator(TypeNameAndTypeParameterNumber[] types, String[] namespaces);
    public sealed virtual bool GetNextPart(TypeNameAndTypeParameterNumber& info);
}
public class JetBrains.Metadata.Reader.Impl.CombiningAssemblyResolver : object {
    private IAssemblyResolver[] myResolvers;
    public CombiningAssemblyResolver(IAssemblyResolver[] resolvers);
    private sealed virtual override IMetadataAccess JetBrains.Metadata.Reader.API.IAssemblyResolver.ResolveAssembly(AssemblyNameInfo name, IAssemblyLocation& assemblyLocation, IModuleReferenceResolveContext moduleReferenceResolveContext);
    public sealed virtual void DumpDebugInformation(IndentedTextWriter textWriter);
    public virtual string ToString();
}
internal class JetBrains.Metadata.Reader.Impl.CompilerSpecificAttribute : object {
    private string myAttributeType;
    private MetadataAttributeValue[] myPositionalArguments;
    private Pair`2[] myNamedArguments;
    public string AttributeType { get; }
    public MetadataAttributeValue[] PositionalArguments { get; }
    public Pair`2[] NamedArguments { get; }
    public CompilerSpecificAttribute(string attributeType, MetadataAttributeValue[] positionalArguments, Pair`2[] namedArguments);
    public sealed virtual string get_AttributeType();
    public sealed virtual MetadataAttributeValue[] get_PositionalArguments();
    public sealed virtual Pair`2[] get_NamedArguments();
}
internal class JetBrains.Metadata.Reader.Impl.CustomAttributeBlobDecoder : object {
    private IMetadataAssembly myAssembly;
    private IMetadataTypeInfo myAttributeType;
    private IMetadataParameter[] myConstructorFormalParameters;
    private IMetadataType[] myConstructorFormalParametersTypes;
    private static byte Prolog1;
    private static byte Prolog2;
    public CustomAttributeBlobDecoder(IMetadataAssembly assembly, IMetadataTypeInfo attributeType, IMetadataParameter[] constructorFormalParameters, IMetadataType[] constructorFormalParametersTypes);
    public DecodeResult ReadBlob(IBlob blob);
    public static bool TryReadSingleIntArgument(IBlob blob, Int32& intArgument);
    public NamedArgInitializationData ReadNamedArg(IBinaryReader reader, UInt32 nArg);
    private IMetadataType ReadFieldOrPropType(IBinaryReader reader);
    private MetadataAttributeValue ReadFixedArg(IBinaryReader reader, IMetadataType type);
    private MetadataAttributeValue ReadArray(IBinaryReader blob, IMetadataArrayType arrayType);
    private static IMetadataProperty GetProperty(IMetadataTypeInfo type, string name);
    private static IMetadataField GetField(IMetadataTypeInfo type, string name);
    private MetadataAttributeValue ReadScalarValue(IMetadataType type, IBinaryReader reader);
    private object ReadScalarValueRaw(ElementType elementType, IBinaryReader blob);
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.AsyncMethodSteppingInformationData : object {
    [CompilerGeneratedAttribute]
private int <CatchHandlerOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <YieldOffsets>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <ResumeOffsets>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken[] <ResumeMethods>k__BackingField;
    public int CatchHandlerOffset { get; }
    public Int32[] YieldOffsets { get; }
    public Int32[] ResumeOffsets { get; }
    public MetadataToken[] ResumeMethods { get; }
    public AsyncMethodSteppingInformationData(int catchHandlerOffset, Int32[] yieldOffsets, Int32[] resumeOffsets, MetadataToken[] resumeMethods);
    [CompilerGeneratedAttribute]
public int get_CatchHandlerOffset();
    [CompilerGeneratedAttribute]
public Int32[] get_YieldOffsets();
    [CompilerGeneratedAttribute]
public Int32[] get_ResumeOffsets();
    [CompilerGeneratedAttribute]
public MetadataToken[] get_ResumeMethods();
    public sealed virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.ClosureDebugInfo : ValueType {
    public int SyntaxOffset;
    public DebugId ClosureId;
    internal ClosureDebugInfo(int syntaxOffset, DebugId closureId);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.CompilationMetadataReferencesData : object {
    [CompilerGeneratedAttribute]
private MetadataReferenceInfo[] <MetadataReferenceInfos>k__BackingField;
    public MetadataReferenceInfo[] MetadataReferenceInfos { get; }
    public CompilationMetadataReferencesData(MetadataReferenceInfo[] metadataReferenceInfos);
    [CompilerGeneratedAttribute]
public MetadataReferenceInfo[] get_MetadataReferenceInfos();
    public sealed virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.CompilationOptionsData : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2[] <Options>k__BackingField;
    public static string Version;
    public static string CompilerVersion;
    public static string Define;
    public static string Language;
    public static string LanguageVersion;
    public static string Nullable;
    public static string Optimization;
    public static string OutputKind;
    public static string Platform;
    public static string RuntimeVersion;
    public static string SourceFileCount;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
public ValueTuple`2[] Options { get; }
    public CompilationOptionsData(ValueTuple`2[] options);
    [CompilerGeneratedAttribute]
public ValueTuple`2[] get_Options();
    [CanBeNullAttribute]
public string TryFindValue(string name);
    public sealed virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.DebugId : ValueType {
    internal static int UndefinedOrdinal;
    public int Ordinal;
    public int Generation;
    internal DebugId(int ordinal, int generation);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.DefaultNamespaceData : object {
    [CompilerGeneratedAttribute]
private string <DefaultNamespace>k__BackingField;
    public string DefaultNamespace { get; }
    internal DefaultNamespaceData(string defaultNamespace);
    [CompilerGeneratedAttribute]
public string get_DefaultNamespace();
    public sealed virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.DynamicLocalVariablesData : object {
    [CompilerGeneratedAttribute]
private Boolean[] <DynamicFlags>k__BackingField;
    public Boolean[] DynamicFlags { get; }
    internal DynamicLocalVariablesData(Boolean[] dynamicFlags);
    [CompilerGeneratedAttribute]
public Boolean[] get_DynamicFlags();
    public sealed virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.EditAndContinueLambdaAndClosureMapData : object {
    [CompilerGeneratedAttribute]
private int <MethodOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private ClosureDebugInfo[] <Closures>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaDebugInfo[] <Lambdas>k__BackingField;
    public int MethodOrdinal { get; }
    public ClosureDebugInfo[] Closures { get; }
    public LambdaDebugInfo[] Lambdas { get; }
    internal EditAndContinueLambdaAndClosureMapData(int methodOrdinal, ClosureDebugInfo[] closures, LambdaDebugInfo[] lambdas);
    [CompilerGeneratedAttribute]
public int get_MethodOrdinal();
    [CompilerGeneratedAttribute]
public ClosureDebugInfo[] get_Closures();
    [CompilerGeneratedAttribute]
public LambdaDebugInfo[] get_Lambdas();
    public sealed virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.EditAndContinueLocalSlotMapData : object {
    [CompilerGeneratedAttribute]
private LocalSlotDebugInfo[] <LocalSlotDebugInfos>k__BackingField;
    public LocalSlotDebugInfo[] LocalSlotDebugInfos { get; }
    internal EditAndContinueLocalSlotMapData(LocalSlotDebugInfo[] localSlotDebugInfos);
    [CompilerGeneratedAttribute]
public LocalSlotDebugInfo[] get_LocalSlotDebugInfos();
    public sealed virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.EditAndContinueStateMachineStateMapData : object {
    [CompilerGeneratedAttribute]
private StateMachineStateDebugInfo[] <StateMachineStates>k__BackingField;
    public StateMachineStateDebugInfo[] StateMachineStates { get; }
    internal EditAndContinueStateMachineStateMapData(StateMachineStateDebugInfo[] stateMachineStates);
    [CompilerGeneratedAttribute]
public StateMachineStateDebugInfo[] get_StateMachineStates();
    public sealed virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.EmbeddedSourceData : object {
    [CompilerGeneratedAttribute]
private string <EmbeddedSource>k__BackingField;
    public string EmbeddedSource { get; }
    internal EmbeddedSourceData(string embeddedSource);
    [CompilerGeneratedAttribute]
public string get_EmbeddedSource();
    public sealed virtual string Present();
}
public interface JetBrains.Metadata.Reader.Impl.CustomDebugInformation.ICustomDebugInformationData {
    public abstract virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.LambdaDebugInfo : ValueType {
    public int SyntaxOffset;
    public int ClosureOrdinal;
    public DebugId LambdaId;
    public static int StaticClosureOrdinal;
    public static int ThisOnlyClosureOrdinal;
    public static int MinClosureOrdinal;
    internal LambdaDebugInfo(int syntaxOffset, DebugId lambdaId, int closureOrdinal);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.LocalDebugId : ValueType {
    public int SyntaxOffset;
    public int Ordinal;
    internal LocalDebugId(int syntaxOffset, int ordinal);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.LocalSlotDebugInfo : ValueType {
    public SynthesizedLocalKind SynthesizedKind;
    public LocalDebugId Id;
    internal LocalSlotDebugInfo(SynthesizedLocalKind synthesizedKind, LocalDebugId id);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.MetadataReferenceInfo : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Aliases>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <TimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <FileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Mvid>k__BackingField;
    [NotNullAttribute]
public string FileName { get; }
    [NotNullAttribute]
public string Aliases { get; }
    public byte Flags { get; }
    public UInt32 TimeStamp { get; }
    public UInt32 FileSize { get; }
    public Guid Mvid { get; }
    public MetadataReferenceInfo(string fileName, string aliases, byte flags, UInt32 timeStamp, UInt32 fileSize, Guid mvid);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public string get_Aliases();
    [CompilerGeneratedAttribute]
public byte get_Flags();
    [CompilerGeneratedAttribute]
public UInt32 get_TimeStamp();
    [CompilerGeneratedAttribute]
public UInt32 get_FileSize();
    [CompilerGeneratedAttribute]
public Guid get_Mvid();
    internal void AppendTo(StringBuilder sb);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.PrimaryConstructorInformationData : object {
    public sealed virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SourceLinkData : object {
    [CompilerGeneratedAttribute]
private string <SourceLink>k__BackingField;
    public string SourceLink { get; }
    internal SourceLinkData(string sourceLink);
    [CompilerGeneratedAttribute]
public string get_SourceLink();
    public sealed virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.StateMachineHoistedLocalScope : ValueType {
    public int StartOffset;
    public int Length;
    public int EndOffset { get; }
    public bool IsDefault { get; }
    public StateMachineHoistedLocalScope(int startOffset, int length);
    public int get_EndOffset();
    public bool get_IsDefault();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.StateMachineHoistedLocalScopesData : object {
    [CompilerGeneratedAttribute]
private StateMachineHoistedLocalScope[] <Scopes>k__BackingField;
    public StateMachineHoistedLocalScope[] Scopes { get; }
    public StateMachineHoistedLocalScopesData(StateMachineHoistedLocalScope[] scopes);
    [CompilerGeneratedAttribute]
public StateMachineHoistedLocalScope[] get_Scopes();
    public sealed virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.StateMachineStateDebugInfo : ValueType {
    public int SyntaxOffset;
    public int StateNumber;
    internal StateMachineStateDebugInfo(int syntaxOffset, int stateNumber);
    public virtual string ToString();
}
public enum JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind : Enum {
    public int value__;
    public static SynthesizedLocalKind FrameCache;
    public static SynthesizedLocalKind PatternMatchingTemp;
    public static SynthesizedLocalKind OptimizerTemp;
    public static SynthesizedLocalKind LoweringTemp;
    public static SynthesizedLocalKind EmitterTemp;
    public static SynthesizedLocalKind UserDefined;
    public static SynthesizedLocalKind ConditionalBranchDiscriminator;
    public static SynthesizedLocalKind LockTaken;
    public static SynthesizedLocalKind Lock;
    public static SynthesizedLocalKind Using;
    public static SynthesizedLocalKind ForEachEnumerator;
    public static SynthesizedLocalKind ForEachArray;
    public static SynthesizedLocalKind ForEachArrayLimit;
    public static SynthesizedLocalKind ForEachArrayIndex;
    public static SynthesizedLocalKind FixedString;
    public static SynthesizedLocalKind With;
    public static SynthesizedLocalKind ForLimit;
    public static SynthesizedLocalKind ForStep;
    public static SynthesizedLocalKind ForInitialValue;
    public static SynthesizedLocalKind ForDirection;
    public static SynthesizedLocalKind SelectCaseValue;
    public static SynthesizedLocalKind OnErrorActiveHandler;
    public static SynthesizedLocalKind OnErrorResumeTarget;
    public static SynthesizedLocalKind OnErrorCurrentStatement;
    public static SynthesizedLocalKind OnErrorCurrentLine;
    public static SynthesizedLocalKind AsyncMethodReturnValue;
    public static SynthesizedLocalKind StateMachineReturnValue;
    public static SynthesizedLocalKind FunctionReturnValue;
    public static SynthesizedLocalKind TryAwaitPendingException;
    public static SynthesizedLocalKind TryAwaitPendingBranch;
    public static SynthesizedLocalKind TryAwaitPendingCatch;
    public static SynthesizedLocalKind TryAwaitPendingCaughtException;
    public static SynthesizedLocalKind ExceptionFilterAwaitHoistedExceptionLocal;
    public static SynthesizedLocalKind StateMachineCachedState;
    public static SynthesizedLocalKind AwaitSpill;
    public static SynthesizedLocalKind AwaitByRefSpill;
    public static SynthesizedLocalKind LambdaDisplayClass;
    public static SynthesizedLocalKind CachedAnonymousMethodDelegate;
    public static SynthesizedLocalKind XmlInExpressionLambda;
    public static SynthesizedLocalKind Awaiter;
    public static SynthesizedLocalKind InstrumentationPayload;
    public static SynthesizedLocalKind MaxValidValueForLocalVariableSerializedToDebugInformation;
    public static SynthesizedLocalKind AwaiterField;
    public static SynthesizedLocalKind DelegateRelaxationReceiver;
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.TupleElementNamesData : object {
    [CompilerGeneratedAttribute]
private String[] <Names>k__BackingField;
    [NotNullAttribute]
[ItemCanBeNullAttribute]
public String[] Names { get; }
    public TupleElementNamesData(String[] names);
    [CompilerGeneratedAttribute]
public String[] get_Names();
    public sealed virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.TypeDefinitionDocumentsData : object {
    [CompilerGeneratedAttribute]
private MetadataToken[] <Documents>k__BackingField;
    public MetadataToken[] Documents { get; }
    public TypeDefinitionDocumentsData(MetadataToken[] documents);
    [CompilerGeneratedAttribute]
public MetadataToken[] get_Documents();
    public sealed virtual string Present();
}
public static class JetBrains.Metadata.Reader.Impl.CustomDebugInformationBlobDecoder : object {
    private static byte SyntaxOffsetBaseline;
    [CanBeNullAttribute]
public static ICustomDebugInformationData Decode(MetadataToken parent, Guid kind, IBlob value, bool decodeEmptyBlob);
    public static StateMachineHoistedLocalScopesData DecodeStateMachineHoistedLocalScopes(IBlob blob);
    public static string DecodeDefaultNamespace(IBlob blob);
    public static string DecodeEmbeddedSource(IBlob blob);
    public static Byte[] DecodeEmbeddedSourceBytes(IBlob blob);
    public static string DecodeSourceLink(IBlob blob);
    public static Byte[] DecodeSourceLinkBytes(IBlob blob);
    private static string GetUtf8StringWithoutBom(Byte[] bytes);
    public static MetadataToken[] DecodeTypeDefinitionDocuments(IBlob blob);
    private static CompilationMetadataReferencesData DecodeCompilationMetadataReferences(IBlob blob);
    private static CompilationOptionsData DecodeCompilationOptions(IBlob blob);
    public static AsyncMethodSteppingInformationData DecodeAsyncMethodSteppingInformation(IBlob blob);
    public static TupleElementNamesData DecodeTupleElementNames(IBlob blob);
    public static EditAndContinueLocalSlotMapData DecodeEditAndContinueLocalSlotMap(IBlob blob);
    public static EditAndContinueLambdaAndClosureMapData DecodeEditAndContinueLambdaAndClosureMap(IBlob blob);
    public static EditAndContinueStateMachineStateMapData DecodeEditAndContinueStateMachineStateMap(IBlob blob);
    public static DynamicLocalVariablesData DecodeDynamicLocalVariables(IBlob blob);
}
public static class JetBrains.Metadata.Reader.Impl.DecimalConstantUtil : object {
    private static void WriteIntOrUint(BinaryWriter sw, object o);
    public static IBlob ExtractDecimalConstantBlob(IMetadataEntity owner);
    public static Nullable`1<decimal> ExtractDecimalConstant(IBlob blob);
}
public static class JetBrains.Metadata.Reader.Impl.DocumentBlobDecoder : object {
    private static Decoder ourUtf8Decoder;
    public static string DecodeName(int nameBlobOffset, IMetadataStreamsAccess streams);
    public static bool ReadUtf8Char(IBlob blob, Char& c, Int32& bytesUsed);
}
public class JetBrains.Metadata.Reader.Impl.EmbeddedManifestResourceDisposition : object {
    private string myResourceName;
    private IAssemblyLocation myAssemblyLocation;
    private long myOffset;
    public string ResourceName { get; }
    public EmbeddedManifestResourceDisposition(string resourceName, IAssemblyLocation assemblyLocation, long offset);
    public sealed virtual string get_ResourceName();
    public sealed virtual Stream CreateResourceReader();
    private bool Equals(EmbeddedManifestResourceDisposition other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Metadata.Reader.Impl.EmptyClrTypeName : ClrTypeNameBase {
    [NotNullAttribute]
public static IClrTypeName Instance;
    public string ShortName { get; }
    public int TypeParametersCount { get; }
    public string FullName { get; }
    public IEnumerable`1<string> NamespaceNames { get; }
    public IEnumerable`1<TypeNameAndTypeParameterNumber> TypeNames { get; }
    private static EmptyClrTypeName();
    public virtual string get_ShortName();
    public virtual int get_TypeParametersCount();
    public virtual string get_FullName();
    public virtual IEnumerable`1<string> get_NamespaceNames();
    public virtual IEnumerable`1<TypeNameAndTypeParameterNumber> get_TypeNames();
    public virtual string ToString();
    public virtual IClrTypeNamePartIterator GetPartIterator();
    public virtual string GetFullNameFast();
    public virtual int GetPartsCount();
}
public class JetBrains.Metadata.Reader.Impl.EntityPresentations : object {
    private IMetadataAssembly myAssembly;
    public EntityPresentations(IMetadataAssembly assembly);
    public sealed virtual MetadataToken[] GetFieldPresentations(IMetadataField field);
    public sealed virtual MetadataToken[] GetTypePresentations(IMetadataTypeInfo typeInfo);
    public sealed virtual MetadataToken GetTokenFromTypeInfo(IMetadataTypeInfo typeInfo);
    public sealed virtual MetadataToken[] GetFieldPresentations(MetadataToken token);
    public sealed virtual MetadataToken[] GetTypePresentations(MetadataToken token);
    public sealed virtual MetadataToken[] GetMethodPresentations(MetadataToken token);
    public sealed virtual MetadataToken[] GetMethodPresentations(IMetadataMethod method);
    [IteratorStateMachineAttribute("JetBrains.Metadata.Reader.Impl.EntityPresentations/<FindTypeSpec>d__9")]
private IEnumerable`1<MetadataToken> FindTypeSpec(MetadataToken typeToken);
    private MetadataToken FindAssemblyRef(IMetadataAssembly assembly);
}
public class JetBrains.Metadata.Reader.Impl.FailAssemblyResolver : object {
    [CanBeNullAttribute]
private string myExceptionMessagePrefix;
    private JetHashSet`1<AssemblyNameInfo> myHashReportedErrors;
    [NotNullAttribute]
private OnError myOnError;
    public FailAssemblyResolver(OnError onerror, string prefixExceptionMessage);
    public void ReportDistinctError(AssemblyNameInfo name, IModuleReferenceResolveContext ctx);
    private sealed virtual override IMetadataAccess JetBrains.Metadata.Reader.API.IAssemblyResolver.ResolveAssembly(AssemblyNameInfo name, IAssemblyLocation& assemblyLocation, IModuleReferenceResolveContext ctx);
    public sealed virtual void DumpDebugInformation(IndentedTextWriter textWriter);
}
public static class JetBrains.Metadata.Reader.Impl.FieldSignatureBlobDecoder : object {
    public static TFieldType DecodeFieldSig(IBlob signature, ITypeBuilder`2<TFieldType, TMethodSig> builder);
}
public class JetBrains.Metadata.Reader.Impl.FileManifestResourceDisposition : object {
    private string myResourceName;
    private IAssemblyLocation myPath;
    public string ResourceName { get; }
    public FileManifestResourceDisposition(string resourceName, IAssemblyLocation path);
    public sealed virtual string get_ResourceName();
    public sealed virtual Stream CreateResourceReader();
    private bool Equals(FileManifestResourceDisposition other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Metadata.Reader.Impl.HashingSignatureBuilder : object {
    private Func`2<MetadataToken, Hash> myTypeTokenPresenter;
    public IMethodSignatureBuilder`2<Hash, Hash> MethodSignatureBuilder { get; }
    public bool IsLightweight { get; }
    public HashingSignatureBuilder(Func`2<MetadataToken, Hash> typeTokenPresenter);
    public sealed virtual ITypeBuilder`2<Hash, Hash> GetTypeBuilder(UInt32 methodTypeParametersCount);
    public sealed virtual Hash BuildMethodSignature(Prologs signatureFlags, UInt32 methodTypeParametersCount, Hash returnType, Hash[] parameterTypes, Hash[] varargParameterTypes);
    public sealed virtual IMethodSignatureBuilder`2<Hash, Hash> get_MethodSignatureBuilder();
    public sealed virtual Hash BuildWellKnownType(ElementType type);
    public sealed virtual Hash BuildPointerType(Hash type);
    public sealed virtual Hash BuildReferenceType(Hash type);
    public sealed virtual Hash BuildClassType(MetadataToken typeDefOrRefOrSpecToken);
    public sealed virtual Hash BuildGenericInst(Hash type, Hash[] args);
    public sealed virtual Hash BuildTypeTypeParameter(UInt32 index);
    public sealed virtual Hash BuildMethodTypeParameter(UInt32 index);
    public sealed virtual Hash BuildFunctionPointer(Hash functionSignature);
    public sealed virtual Hash BuildArrayType(Hash elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    public sealed virtual Hash BuildArrayType(Hash elementType);
    public sealed virtual Hash AddRequiredModifier(Hash type, Hash modifier);
    public sealed virtual Hash AddOptionalModifier(Hash type, Hash modifier);
    public sealed virtual Hash AddPinnedConstraint(Hash type);
    public sealed virtual Hash BuildUndecodedType();
    public sealed virtual bool get_IsLightweight();
}
public class JetBrains.Metadata.Reader.Impl.ImageBodyReader : object {
    private IMetadataAssembly myAssembly;
    private IlImageBodyAccess myBodyAccess;
    private LifetimeDefinition myLifetimeDefinition;
    private ImageBodyReader(IMetadataAssembly assembly, UnmanagedBlock block);
    public ImageBodyReader(IMetadataAssembly assembly);
    public ImageBodyReader(IMetadataAssembly assembly, Stream stream);
    public ImageBodyReader(IMetadataAssembly assembly, UnmanagedBlob blob);
    public sealed virtual void Dispose();
    public sealed virtual IMethodBody GetMethodBody(IMetadataMethod method);
    public sealed virtual ILMethodBody GetIlMethodBody(IMetadataMethod method);
    public sealed virtual Byte[] GetFieldInitialValue(IMetadataField field);
    private static IAssemblyLocation CheckedGetAssemblyLocation(IMetadataAssembly assembly);
    private static UnmanagedBlock CreateFromAssemblyLocation(IAssemblyLocation assemblyLocation);
}
public interface JetBrains.Metadata.Reader.Impl.IMethodSignatureBuilder`2 {
    [NotNullAttribute]
public abstract virtual ITypeBuilder`2<TType, TSignature> GetTypeBuilder(UInt32 methodTypeParametersCount);
    public abstract virtual TSignature BuildMethodSignature(Prologs signatureFlags, UInt32 methodTypeParametersCount, TType returnType, TType[] parameterTypes, TType[] varargParameterTypes);
}
public static class JetBrains.Metadata.Reader.Impl.ImportScopeBlobDecoder : object {
    public static IList`1<Import> DecodeImports(IBlob blob, IMetadataStreamsAccess streams, IDictionary`2<UInt32, object> blobs);
}
public interface JetBrains.Metadata.Reader.Impl.ITypeBuilder`2 {
    [NotNullAttribute]
public IMethodSignatureBuilder`2<TType, TMethodSig> MethodSignatureBuilder { get; }
    public bool IsLightweight { get; }
    public abstract virtual IMethodSignatureBuilder`2<TType, TMethodSig> get_MethodSignatureBuilder();
    public abstract virtual TType BuildWellKnownType(ElementType type);
    public abstract virtual TType BuildPointerType(TType type);
    public abstract virtual TType BuildReferenceType(TType type);
    public abstract virtual TType BuildClassType(MetadataToken typeDefOrRefOrSpecToken);
    public abstract virtual TType BuildTypeTypeParameter(UInt32 index);
    public abstract virtual TType BuildGenericInst(TType type, TType[] args);
    public abstract virtual TType BuildMethodTypeParameter(UInt32 index);
    public abstract virtual TType BuildFunctionPointer(TMethodSig functionSignature);
    public abstract virtual TType BuildArrayType(TType elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    public abstract virtual TType BuildArrayType(TType elementType);
    public abstract virtual TType AddRequiredModifier(TType type, TType modifier);
    public abstract virtual TType AddOptionalModifier(TType type, TType modifier);
    public abstract virtual TType AddPinnedConstraint(TType type);
    public abstract virtual TType BuildUndecodedType();
    public abstract virtual bool get_IsLightweight();
}
public class JetBrains.Metadata.Reader.Impl.LightweightTypeBuilder : object {
    [NotNullAttribute]
public static LightweightTypeBuilder Instance;
    public bool IsLightweight { get; }
    public IMethodSignatureBuilder`2<ElementType, Signature> MethodSignatureBuilder { get; }
    private static LightweightTypeBuilder();
    public sealed virtual bool get_IsLightweight();
    public sealed virtual IMethodSignatureBuilder`2<ElementType, Signature> get_MethodSignatureBuilder();
    public sealed virtual ITypeBuilder`2<ElementType, Signature> GetTypeBuilder(UInt32 methodTypeParametersCount);
    public sealed virtual ElementType BuildWellKnownType(ElementType type);
    public sealed virtual ElementType BuildPointerType(ElementType _);
    public sealed virtual ElementType BuildReferenceType(ElementType _);
    public sealed virtual ElementType BuildClassType(MetadataToken typeDefOrRefOrSpecToken);
    public sealed virtual ElementType BuildTypeTypeParameter(UInt32 index);
    public sealed virtual ElementType BuildGenericInst(ElementType type, ElementType[] args);
    public sealed virtual ElementType BuildMethodTypeParameter(UInt32 index);
    public sealed virtual ElementType BuildFunctionPointer(Signature functionSignature);
    public sealed virtual ElementType BuildArrayType(ElementType elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    public sealed virtual ElementType BuildArrayType(ElementType elementType);
    public sealed virtual ElementType AddRequiredModifier(ElementType type, ElementType modifier);
    public sealed virtual ElementType AddOptionalModifier(ElementType type, ElementType modifier);
    public sealed virtual ElementType AddPinnedConstraint(ElementType type);
    public sealed virtual ElementType BuildUndecodedType();
    public sealed virtual Signature BuildMethodSignature(Prologs signatureFlags, UInt32 methodTypeParametersCount, ElementType returnType, ElementType[] parameterTypes, ElementType[] varargParameterTypes);
    [MustUseReturnValueAttribute]
public static Signature DecodeMethodBlobFast(IBinaryReader reader);
}
public static class JetBrains.Metadata.Reader.Impl.LiteralValueDecoder : object {
    internal static object GetLiteralValue(ElementType elementType, IBinaryReader rdr, int len);
    public static object GetLiteralValue(ElementType elementType, IBlob blob);
}
public class JetBrains.Metadata.Reader.Impl.LoadedAssembliesResolver : object {
    private Lifetime myLifetime;
    private Dictionary`2<string, Lazy`1<IAssemblyLocation>> myMapIdentityToLocation;
    public LoadedAssembliesResolver(Lifetime lifetime, bool isCheckingShortNameOnly);
    private void LazyInitMap();
    private sealed virtual override IMetadataAccess JetBrains.Metadata.Reader.API.IAssemblyResolver.ResolveAssembly(AssemblyNameInfo name, IAssemblyLocation& assemblyLocation, IModuleReferenceResolveContext moduleReferenceResolveContext);
    public sealed virtual void DumpDebugInformation(IndentedTextWriter textWriter);
}
public static class JetBrains.Metadata.Reader.Impl.MarshalSpecConverter : object {
    [CanBeNullAttribute]
public static ICompilerSpecificAttribute CreateMarshalAsAttribute(IMarshalSpec marshalSpec, IMetadataAssembly context);
    private static Pair`2[] MakeMarshalAsAttributeNamedArguments(IMarshalSpec marshalSpec, IMetadataAssembly context, IMetadataAssembly corlib);
}
public static class JetBrains.Metadata.Reader.Impl.MemberRefBlobDecoder : object {
    public static MemberRefType GetReferenceType(IBlob memberRefSignature);
    public static TFieldType DecodeFieldSig(IBlob memberRefSignature, ITypeBuilder`2<TFieldType, TMethodSig> builder);
    public static TSig DecodeMethodSig(IBlob memberRefSignature, IMethodSignatureBuilder`2<TType, TSig> builder);
}
internal class JetBrains.Metadata.Reader.Impl.MetadataArrayMethod : object {
    private static MetadataToken TOKEN;
    private IMetadataTypeInfo myDeclaringType;
    private string myName;
    private MetadataArrayMethodReturnValue myReturnValue;
    private MethodSignature mySignature;
    private IMetadataParameter[] myParameters;
    public IMetadataAssembly Assembly { get; }
    public MetadataToken Token { get; }
    public IMetadataCustomAttribute[] CustomAttributes { get; }
    public MetadataTypeReference[] CustomAttributesTypeNames { get; }
    public bool IsResolved { get; }
    public string Name { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IMetadataReturnValue ReturnValue { get; }
    public IMetadataParameter[] Parameters { get; }
    public IMetadataTypeParameter[] TypeParameters { get; }
    public IList`1<MethodSpecification> ImplementedMethods { get; }
    public MethodSignature Signature { get; }
    public PInvokeInfo PInvokeInfo { get; }
    public CorMethodImpl MethodImplFlags { get; }
    public IMetadataSecurityRow[] Security { get; }
    public String[] SecurityAttributesTypeName { get; }
    public bool IsPInvokeImpl { get; }
    public bool HasSecurity { get; }
    public CodeType CodeType { get; }
    public UInt32 CodeRva { get; }
    public bool IsForwardRef { get; }
    public bool IsPreserveSig { get; }
    public bool IsInternalCall { get; }
    public bool IsSynchronized { get; }
    public bool NoInlining { get; }
    public bool AggressiveInlining { get; }
    public bool AggressiveOptimization { get; }
    public bool NoOptimization { get; }
    public bool IsAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsExtern { get; }
    public bool IsVirtual { get; }
    public bool IsFinal { get; }
    public bool IsHideBySig { get; }
    public bool IsNewSlot { get; }
    public bool IsExplicitClassOverride { get; }
    public bool IsStrict { get; }
    public bool IsVarArg { get; }
    public bool IsUnmanaged { get; }
    public MetadataArrayMethod(IMetadataTypeInfo declaringType, string name, MethodSignature signature);
    private static MetadataArrayMethod();
    public sealed virtual bool Equals(IMetadataEntity other);
    public sealed virtual IMetadataAssembly get_Assembly();
    public sealed virtual MetadataToken get_Token();
    public sealed virtual IMetadataCustomAttribute[] get_CustomAttributes();
    public sealed virtual MetadataTypeReference[] get_CustomAttributesTypeNames();
    public sealed virtual IList`1<IMetadataCustomAttribute> GetCustomAttributes(string attributeClassFullyQualifiedName);
    public sealed virtual bool HasCustomAttribute(string attributeClassFullyQualifiedName);
    public sealed virtual bool get_IsResolved();
    public sealed virtual string get_Name();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IMetadataReturnValue get_ReturnValue();
    public sealed virtual IMetadataParameter[] get_Parameters();
    public sealed virtual IMetadataTypeParameter[] get_TypeParameters();
    public sealed virtual IList`1<MethodSpecification> get_ImplementedMethods();
    public sealed virtual MethodSignature get_Signature();
    public sealed virtual PInvokeInfo get_PInvokeInfo();
    public sealed virtual CorMethodImpl get_MethodImplFlags();
    public sealed virtual IMetadataSecurityRow[] get_Security();
    public sealed virtual String[] get_SecurityAttributesTypeName();
    public sealed virtual bool get_IsPInvokeImpl();
    public sealed virtual bool get_HasSecurity();
    public sealed virtual CodeType get_CodeType();
    public sealed virtual UInt32 get_CodeRva();
    public sealed virtual bool get_IsForwardRef();
    public sealed virtual bool get_IsPreserveSig();
    public sealed virtual bool get_IsInternalCall();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_NoInlining();
    public sealed virtual bool get_AggressiveInlining();
    public sealed virtual bool get_AggressiveOptimization();
    public sealed virtual bool get_NoOptimization();
    public sealed virtual bool get_IsAssembly();
    public sealed virtual bool get_IsPrivate();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsFamily();
    public sealed virtual bool get_IsFamilyAndAssembly();
    public sealed virtual bool get_IsFamilyOrAssembly();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsFinal();
    public sealed virtual bool get_IsHideBySig();
    public sealed virtual bool get_IsNewSlot();
    public sealed virtual bool get_IsExplicitClassOverride();
    public sealed virtual bool get_IsStrict();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual bool get_IsUnmanaged();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataArrayMethodParameter : object {
    private static MetadataToken TOKEN;
    private int myIndex;
    private IMetadataMethod myMethod;
    private IMetadataType myType;
    public IMetadataAssembly Assembly { get; }
    public MetadataToken Token { get; }
    public IMetadataCustomAttribute[] CustomAttributes { get; }
    public MetadataTypeReference[] CustomAttributesTypeNames { get; }
    public bool IsResolved { get; }
    public string Name { get; }
    public IMetadataType Type { get; }
    public IMetadataMethod DeclaringMethod { get; }
    public IBlob MarshalSpec { get; }
    public bool IsIn { get; }
    public bool IsOut { get; }
    public bool IsParamArray { get; }
    public bool IsOptional { get; }
    public bool HasMarshalSpec { get; }
    public bool HasDefaultValue { get; }
    public MetadataArrayMethodParameter(IMetadataMethod method, IMetadataType type, int index);
    private static MetadataArrayMethodParameter();
    public sealed virtual bool Equals(IMetadataEntity other);
    public sealed virtual IMetadataAssembly get_Assembly();
    public sealed virtual MetadataToken get_Token();
    public sealed virtual IMetadataCustomAttribute[] get_CustomAttributes();
    public sealed virtual MetadataTypeReference[] get_CustomAttributesTypeNames();
    public sealed virtual IList`1<IMetadataCustomAttribute> GetCustomAttributes(string attributeClassFullyQualifiedName);
    public sealed virtual bool HasCustomAttribute(string attributeClassFullyQualifiedName);
    public sealed virtual bool get_IsResolved();
    public sealed virtual string get_Name();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IMetadataMethod get_DeclaringMethod();
    public sealed virtual IBlob get_MarshalSpec();
    public sealed virtual bool get_IsIn();
    public sealed virtual bool get_IsOut();
    public sealed virtual bool get_IsParamArray();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_HasMarshalSpec();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual object GetDefaultValue();
    public sealed virtual IBlob GetDefaultValueBlob();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataArrayMethodReturnValue : object {
    private static MetadataToken TOKEN;
    private IMetadataMethod myMethod;
    private IMetadataType myType;
    public IMetadataAssembly Assembly { get; }
    public MetadataToken Token { get; }
    public IMetadataCustomAttribute[] CustomAttributes { get; }
    public MetadataTypeReference[] CustomAttributesTypeNames { get; }
    public bool IsResolved { get; }
    public IMetadataMethod DeclaringMethod { get; }
    public IMetadataType Type { get; }
    public IBlob MarshalSpec { get; }
    public bool HasMarshalSpec { get; }
    public MetadataArrayMethodReturnValue(IMetadataMethod method, IMetadataType type);
    private static MetadataArrayMethodReturnValue();
    public sealed virtual bool Equals(IMetadataEntity other);
    public sealed virtual IMetadataAssembly get_Assembly();
    public sealed virtual MetadataToken get_Token();
    public sealed virtual IMetadataCustomAttribute[] get_CustomAttributes();
    public sealed virtual MetadataTypeReference[] get_CustomAttributesTypeNames();
    public sealed virtual IList`1<IMetadataCustomAttribute> GetCustomAttributes(string attributeClassFullyQualifiedName);
    public sealed virtual bool HasCustomAttribute(string attributeClassFullyQualifiedName);
    public sealed virtual bool get_IsResolved();
    public sealed virtual IMetadataMethod get_DeclaringMethod();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IBlob get_MarshalSpec();
    public sealed virtual bool get_HasMarshalSpec();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.MetadataArrayType : MetadataTypeBase {
    private IMetadataType myElementType;
    private UInt32 myRank;
    private UInt32[] mySizes;
    private Int32[] myLBounds;
    private IMetadataArrayTypeInfo myTypeInfo;
    private string myFullName;
    private bool myIsVector;
    public IMetadataType ElementType { get; }
    public bool IsVector { get; }
    public UInt32 Rank { get; }
    public UInt32[] Sizes { get; }
    public Int32[] LBounds { get; }
    public IMetadataArrayTypeInfo TypeInfo { get; }
    public bool IsResolved { get; }
    public string FullName { get; }
    private string RankText { get; }
    public string AssemblyQualification { get; }
    public MetadataArrayType(IMetadataType elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds, IMetadataTypeModifier[] typeModifiers, bool pinned);
    public MetadataArrayType(IMetadataType elementType, IMetadataTypeModifier[] typeModifiers, bool pinned);
    public sealed virtual IMetadataType get_ElementType();
    public sealed virtual bool get_IsVector();
    public sealed virtual UInt32 get_Rank();
    public sealed virtual UInt32[] get_Sizes();
    public sealed virtual Int32[] get_LBounds();
    public sealed virtual IMetadataArrayTypeInfo get_TypeInfo();
    public virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public virtual string get_FullName();
    private string get_RankText();
    public static string GetRankText(UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    public virtual string get_AssemblyQualification();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataArrayTypeInfo : object {
    private static MetadataToken TOKEN;
    [NotNullAttribute]
private IMetadataArrayType myArrayType;
    private IMetadataClassType myBaseType;
    private IMetadataMethod[] myMethods;
    public IMetadataAssembly Assembly { get; }
    public MetadataToken Token { get; }
    public IMetadataCustomAttribute[] CustomAttributes { get; }
    public MetadataTypeReference[] CustomAttributesTypeNames { get; }
    public bool IsResolved { get; }
    public string FullyQualifiedName { get; }
    public string AssemblyQualifiedName { get; }
    public string NamespaceName { get; }
    public string TypeName { get; }
    public string Name { get; }
    public AssemblyNameInfo DeclaringAssemblyName { get; }
    public IMetadataClassType Base { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IMetadataInterfaceImplementation[] InterfaceImplementations { get; }
    public IMetadataTypeParameter[] TypeParameters { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsImported { get; }
    public ClassLayoutType Layout { get; }
    public ClassLayout ClassLayout { get; }
    public CharSetSpec InteropStringFormat { get; }
    public bool IsClass { get; }
    public bool IsInterface { get; }
    public bool IsSerializable { get; }
    public bool IsWindowsRuntime { get; }
    public bool IsPublic { get; }
    public bool IsNotPublic { get; }
    public bool IsNested { get; }
    public bool IsNestedPublic { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamilyAndAssembly { get; }
    public bool IsNestedFamilyOrAssembly { get; }
    public int PackingSize { get; }
    public int ClassSize { get; }
    public String[] SecurityAttributesTypeName { get; }
    public bool HasSecurity { get; }
    public IMetadataSecurityRow[] Security { get; }
    public IMetadataArrayType ArrayType { get; }
    public MetadataArrayTypeInfo(IMetadataArrayType arrayType);
    private static MetadataArrayTypeInfo();
    public sealed virtual bool Equals(IMetadataEntity other);
    public sealed virtual IMetadataAssembly get_Assembly();
    public sealed virtual MetadataToken get_Token();
    public sealed virtual IMetadataCustomAttribute[] get_CustomAttributes();
    public sealed virtual MetadataTypeReference[] get_CustomAttributesTypeNames();
    public sealed virtual IList`1<IMetadataCustomAttribute> GetCustomAttributes(string attributeClassFullyQualifiedName);
    public sealed virtual bool HasCustomAttribute(string attributeClassFullyQualifiedName);
    public sealed virtual bool get_IsResolved();
    public sealed virtual string get_FullyQualifiedName();
    public sealed virtual string get_AssemblyQualifiedName();
    public sealed virtual string get_NamespaceName();
    public sealed virtual string get_TypeName();
    public sealed virtual string get_Name();
    public sealed virtual AssemblyNameInfo get_DeclaringAssemblyName();
    public sealed virtual IMetadataClassType get_Base();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IMetadataInterfaceImplementation[] get_InterfaceImplementations();
    public sealed virtual IMetadataTypeParameter[] get_TypeParameters();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsImported();
    public sealed virtual ClassLayoutType get_Layout();
    public sealed virtual ClassLayout get_ClassLayout();
    public sealed virtual CharSetSpec get_InteropStringFormat();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsWindowsRuntime();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsNotPublic();
    public sealed virtual bool get_IsNested();
    public sealed virtual bool get_IsNestedPublic();
    public sealed virtual bool get_IsNestedPrivate();
    public sealed virtual bool get_IsNestedFamily();
    public sealed virtual bool get_IsNestedAssembly();
    public sealed virtual bool get_IsNestedFamilyAndAssembly();
    public sealed virtual bool get_IsNestedFamilyOrAssembly();
    public sealed virtual int get_PackingSize();
    public sealed virtual int get_ClassSize();
    public sealed virtual IEnumerable`1<MemberInfo> GetMemberInfos();
    public sealed virtual String[] get_SecurityAttributesTypeName();
    public sealed virtual bool get_HasSecurity();
    public sealed virtual IMetadataSecurityRow[] get_Security();
    public sealed virtual IMetadataMethod[] GetMethods();
    public sealed virtual bool HasExtensionMethods();
    public sealed virtual MetadataMemberPresenceFlags ComputeMemberPresenceFlag();
    public sealed virtual IMetadataField[] GetFields();
    public sealed virtual IMetadataProperty[] GetProperties();
    public sealed virtual IMetadataProperty GetPropertyFromAccessor(IMetadataMethod accessor);
    public sealed virtual IMetadataEvent[] GetEvents();
    public sealed virtual IMetadataTypeInfo[] GetNestedTypes();
    public sealed virtual IMetadataArrayType get_ArrayType();
    [CompilerGeneratedAttribute]
private UnresolvedMethod <GetMethods>b__93_0(Pair`2<string, MethodSignature> x);
    [CompilerGeneratedAttribute]
private MetadataArrayMethod <GetMethods>b__93_1(Pair`2<string, MethodSignature> x);
}
internal class JetBrains.Metadata.Reader.Impl.MetadataAssembly : MetadataEntity {
    [CanBeNullAttribute]
private IAssemblyLocation myLocation;
    private IMetadataAccess myMetadataAccess;
    private IMetadataAssemblyInfo myAssemblyInfo;
    private Lazy`1<AssemblyNameInfo> myAssemblyName;
    private IMetadataTypeInfo[] myTypes;
    private IMetadataManifestResource[] myManifestResources;
    private MetadataTokenRange myTypesRange;
    private MetadataTokenRange myMethodsRange;
    private IMetadataTypeInfo[] myExportedTypes;
    private IMetadataCustomAttribute[] myModuleAttributes;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<string, string>, MetadataForwardedTypeInfo> myForwardedTypes;
    private MetadataLoader myLoader;
    private Dictionary`2<MetadataToken, IMetadataTypeInfo> myTypeInfoCache;
    private Dictionary`2<MetadataToken, MethodSpecification> myMethodCache;
    private Dictionary`2<MetadataToken, IMetadataAssembly> myAssemblyReferences;
    private Dictionary`2<MetadataToken, AssemblyReference> myReferencedAssemblies;
    private Func`2<AssemblyNameInfo, bool> myLoadReferencedAssembly;
    private IMetadataSecurityRow[] mySecurity;
    private String[] mySecurityAttributesTypeName;
    private FileReference[] myReferencedFiles;
    private AssemblyId myId;
    private Nullable`1<bool> myHasSuppressIldasmAttribute;
    [ThreadStaticAttribute]
private static List`1<AssemblyNameInfo> ourForwardedTypesResolutionInProgress;
    protected static ILogger Logger;
    public AssemblyNameInfo AssemblyName { get; }
    public AssemblyId Id { get; }
    [CanBeNullAttribute]
public IAssemblyLocation Location { get; }
    public IMetadataAssemblyInternals Internals { get; }
    public IMetadataCustomAttribute[] ModuleAttributes { get; }
    public IMetadataSecurityRow[] Security { get; }
    public String[] SecurityAttributesTypeName { get; }
    public bool HasSecurity { get; }
    public IMetadataAccess MetadataAccess { get; }
    public IEnumerable`1<AssemblyNameInfo> ReferencedAssembliesNames { get; }
    public IEnumerable`1<AssemblyReference> ReferencedAssemblies { get; }
    public IEnumerable`1<KeyValuePair`2<MetadataToken, string>> ReferencedModules { get; }
    public FileReference[] ReferencedFiles { get; }
    public MetadataLoader Loader { get; }
    public IEntityPresentations EntityPresentations { get; }
    internal MetadataAssembly(MetadataToken assemblyToken, IAssemblyLocation location, IMetadataAccess metadataAccess, MetadataLoader loader, Func`2<AssemblyNameInfo, bool> loadReferencedAssembly);
    private static MetadataAssembly();
    public sealed virtual AssemblyNameInfo get_AssemblyName();
    public sealed virtual AssemblyId get_Id();
    public sealed virtual IAssemblyLocation get_Location();
    public sealed virtual IMetadataTypeInfo GetTypeInfoFromQualifiedName(string assemblyQualifiedName, bool searchReferencedAssemblies);
    public sealed virtual IMetadataTypeInfo GetTypeInfoFromQualifiedName(string name, AssemblyNameInfo assemblyName, bool searchReferencedAssemblies);
    [CanBeNullAttribute]
private IMetadataTypeInfo GetTypeInfoFromQualifiedName_ThisAssemblyOrForwardedType(string name, bool searchReferencedAssemblies, ValueTuple`4& forwarderImplementationAssemblyRef);
    public sealed virtual IMetadataType GetTypeFromQualifiedName(string qualifiedName, bool searchReferencedAssemblies);
    public sealed virtual IMetadataTypeInfo GetTypeInfoFromToken(MetadataToken token);
    public sealed virtual MethodSpecification GetMethodFromToken(MetadataToken methodToken);
    public sealed virtual IMetadataTypeInfo[] GetTypes();
    private void LoadTypes();
    private ValueTuple`2<IMetadataTypeInfo[], Dictionary`2<ValueTuple`2<string, string>, MetadataForwardedTypeInfo>> BuildExportedTypes();
    private ValueTuple`2<IMetadataTypeInfo[], Dictionary`2<ValueTuple`2<string, string>, MetadataForwardedTypeInfo>> BuildExportedTypesCore();
    public sealed virtual IMetadataTypeInfo[] GetExportedTypesFromOtherModules();
    public sealed virtual IReadOnlyCollection`1<IMetadataForwardedTypeInfo> GetForwardedTypes();
    public sealed virtual IMetadataManifestResource[] GetManifestResources();
    public sealed virtual IImageBodyReader CreateImageBodyReader();
    public sealed virtual IMethodBodyUsagesFinder CreateUsagesFinder();
    public sealed virtual IMetadataAssemblyInternals get_Internals();
    public sealed virtual IMetadataCustomAttribute[] get_ModuleAttributes();
    public sealed virtual IMetadataSecurityRow[] get_Security();
    public sealed virtual String[] get_SecurityAttributesTypeName();
    public sealed virtual bool get_HasSecurity();
    public sealed virtual IMetadataAccess get_MetadataAccess();
    public sealed virtual IEnumerable`1<AssemblyNameInfo> get_ReferencedAssembliesNames();
    public sealed virtual IEnumerable`1<AssemblyReference> get_ReferencedAssemblies();
    public sealed virtual IEnumerable`1<KeyValuePair`2<MetadataToken, string>> get_ReferencedModules();
    public sealed virtual FileReference[] get_ReferencedFiles();
    public sealed virtual MetadataLoader get_Loader();
    public sealed virtual IMetadataType DecodeType(IBinaryReader reader, TypeDecodeContext context);
    public sealed virtual void ResetReferencedAssembliesCache();
    public sealed virtual IMetadataType GetTypeFromToken(MetadataToken token);
    public sealed virtual IMetadataType GetTypeFromToken(MetadataToken token, TypeDecodeContext context);
    public sealed virtual MethodSpecification GetMethodFromToken(MetadataToken methodToken, TypeDecodeContext context);
    private static MethodSpecification SearchMethodInType(IMetadataClassType type, string name, MethodSignature signature);
    public sealed virtual AssemblyNameInfo GetReferencedAssemblyName(MetadataToken assemblyToken);
    public sealed virtual Byte[] GetReferencedAssemblyHash(MetadataToken assemblyToken);
    public sealed virtual IMetadataAssembly GetReferencedAssembly(MetadataToken assemblyToken);
    public sealed virtual IMetadataAssembly GetReferencedAssembly(AssemblyReference assemblyReference);
    public sealed virtual IMetadataAssembly GetAssemblyFromReferencedFile(MetadataToken token);
    public sealed virtual IAssemblyLocation GetReferencedFile(MetadataToken token);
    public sealed virtual FieldSpecification GetFieldFromToken(MetadataToken fieldToken, TypeDecodeContext typeContext);
    public sealed virtual IEntityPresentations get_EntityPresentations();
    public sealed virtual bool IsProtectedFromDisassembly();
    [IteratorStateMachineAttribute("JetBrains.Metadata.Reader.Impl.MetadataAssembly/<GetAllCustomAttributeStringsWithTokens>d__84")]
public sealed virtual IEnumerable`1<Pair`2<string, MetadataToken>> GetAllCustomAttributeStringsWithTokens();
    private static IList`1<string> ExtractStrings(MetadataAttributeValue[] values);
    private static IList`1<string> ExtractStrings(MetadataAttributeValue value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(IMetadataEntity other);
    [CompilerGeneratedAttribute]
private AssemblyNameInfo <.ctor>b__24_0();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataBoxedType : MetadataTypeBase {
    [CompilerGeneratedAttribute]
private IMetadataType <UnderlyingType>k__BackingField;
    public bool IsResolved { get; }
    public string FullName { get; }
    public string AssemblyQualification { get; }
    public IMetadataType UnderlyingType { get; }
    public MetadataBoxedType(IMetadataType underlyingType, bool pinned);
    public virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public virtual string get_FullName();
    public virtual string get_AssemblyQualification();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_UnderlyingType();
    public virtual string ToString();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataClassType : MetadataTypeBase {
    private IMetadataTypeInfo myType;
    private IMetadataType[] myArguments;
    private string myFullName;
    public IMetadataTypeInfo Type { get; }
    public IMetadataType[] Arguments { get; }
    public bool IsResolved { get; }
    public string FullName { get; }
    public string AssemblyQualification { get; }
    public MetadataClassType(IMetadataTypeInfo type, IMetadataType[] genericArguments, IMetadataTypeModifier[] typeModifiers, bool pinned);
    public sealed virtual IMetadataTypeInfo get_Type();
    public sealed virtual IMetadataType[] get_Arguments();
    public virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public virtual string get_FullName();
    public virtual string get_AssemblyQualification();
}
public class JetBrains.Metadata.Reader.Impl.MetadataCustomAttribute : MetadataEntity {
    private MethodSpecification myConstructor;
    private MetadataAttributeValue[] myConstructorArguments;
    private IMetadataAttributeNamedArgument[] myNamedArguments;
    public MethodSpecification UsedConstructorSpecification { get; }
    public IMetadataMethod UsedConstructor { get; }
    public MetadataToken Type { get; }
    public MetadataAttributeValue[] ConstructorArguments { get; }
    public IMetadataAttributeNamedArgument[] NamedArguments { get; }
    public MetadataCustomAttribute(MetadataToken token, IMetadataAssembly assembly);
    public sealed virtual MethodSpecification get_UsedConstructorSpecification();
    public sealed virtual IMetadataMethod get_UsedConstructor();
    public sealed virtual MetadataToken get_Type();
    public sealed virtual MetadataAttributeValue[] get_ConstructorArguments();
    public sealed virtual IMetadataAttributeNamedArgument[] get_NamedArguments();
    public sealed virtual Byte[] GetBytes();
    public sealed virtual bool TryGetSingleIntCtorArgument(Int32& intArgument);
    private void ReadBlobIfNeeded();
    public virtual string ToString();
}
public abstract class JetBrains.Metadata.Reader.Impl.MetadataEntity : object {
    protected MetadataToken myToken;
    protected IMetadataAssembly myAssembly;
    private IMetadataCustomAttribute[] myMetadataCustomAttributes;
    private MetadataTypeReference[] myCustomAttributesTypeNames;
    [NotNullAttribute]
public IMetadataAssembly Assembly { get; }
    public MetadataToken Token { get; }
    public IMetadataCustomAttribute[] CustomAttributes { get; }
    public MetadataTypeReference[] CustomAttributesTypeNames { get; }
    public bool IsResolved { get; }
    protected MetadataEntity(MetadataToken token, IMetadataAssembly assembly);
    protected void SetAssembly(IMetadataAssembly assembly);
    public sealed virtual IMetadataAssembly get_Assembly();
    public sealed virtual MetadataToken get_Token();
    public sealed virtual IMetadataCustomAttribute[] get_CustomAttributes();
    public sealed virtual MetadataTypeReference[] get_CustomAttributesTypeNames();
    public sealed virtual IList`1<IMetadataCustomAttribute> GetCustomAttributes(string attributeClassFullyQualifiedName);
    public sealed virtual bool HasCustomAttribute(string attributeClassFullyQualifiedName);
    public sealed virtual bool get_IsResolved();
    public abstract virtual string ToString();
    public virtual bool Equals(IMetadataEntity other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class JetBrains.Metadata.Reader.Impl.MetadataEvent : MetadataEntity {
    private EventProperties myProperties;
    private IMetadataMethod myAdder;
    private IMetadataMethod myRemover;
    private IMetadataMethod myRaiser;
    private IMetadataMethod[] myOther;
    private IMetadataType myType;
    public string Name { get; }
    public IMetadataType Type { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IMetadataMethod Adder { get; }
    public IMetadataMethod Remover { get; }
    public IMetadataMethod Raiser { get; }
    public IMetadataMethod[] OtherMethods { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public MetadataEvent(MetadataToken token, IMetadataAssembly assembly);
    public sealed virtual string get_Name();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IMetadataMethod get_Adder();
    public sealed virtual IMetadataMethod get_Remover();
    public sealed virtual IMetadataMethod get_Raiser();
    public sealed virtual IMetadataMethod[] get_OtherMethods();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.MetadataField : MetadataEntity {
    private object myLiteralValue;
    private FieldSignature mySignature;
    private IMetadataTypeInfo myDeclaringType;
    private bool myIsLiteral;
    private CorFieldAttr myFlags;
    private string myName;
    private UInt32 myInitialValueRva;
    private IBlob myLiteralValueBlob;
    private IBlob myMarshalSpec;
    public string Name { get; }
    public IMetadataType Type { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IBlob MarshalSpec { get; }
    public int Offset { get; }
    public FieldSignature Signature { get; }
    public UInt32 InitialValueRva { get; }
    public bool IsAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool HasMarshalSpec { get; }
    public bool NotSerialized { get; }
    public MetadataField(MetadataToken token, IMetadataAssembly assembly);
    public sealed virtual string get_Name();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IBlob get_MarshalSpec();
    public sealed virtual object GetLiteralValue();
    public sealed virtual IBlob GetLiteralValueBlob();
    public sealed virtual int get_Offset();
    public sealed virtual FieldSignature get_Signature();
    public sealed virtual UInt32 get_InitialValueRva();
    public sealed virtual bool get_IsAssembly();
    public sealed virtual bool get_IsPrivate();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsFamily();
    public sealed virtual bool get_IsFamilyAndAssembly();
    public sealed virtual bool get_IsFamilyOrAssembly();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsInitOnly();
    public sealed virtual bool get_IsLiteral();
    public sealed virtual bool get_HasMarshalSpec();
    public sealed virtual bool get_NotSerialized();
    private void ImportLiteralValue(FieldProperties fieldProperties);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.MetadataForwardedTypeInfo : MetadataEntity {
    public AssemblyReference AssemblyReference;
    private string myFullName;
    [CompilerGeneratedAttribute]
private MetadataTypeReference <TypeReference>k__BackingField;
    public string FullName { get; }
    public MetadataTypeReference TypeReference { get; }
    private AssemblyNameInfo JetBrains.Metadata.Reader.API.IMetadataForwardedTypeInfo.AssemblyName { get; }
    public MetadataForwardedTypeInfo(string namespaceName, string typeName, AssemblyReference assemblyReference, MetadataToken token, IMetadataAssembly assembly);
    public sealed virtual string get_FullName();
    [CompilerGeneratedAttribute]
public sealed virtual MetadataTypeReference get_TypeReference();
    private sealed virtual override AssemblyNameInfo JetBrains.Metadata.Reader.API.IMetadataForwardedTypeInfo.get_AssemblyName();
    public virtual string ToString();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataFunctionPointerType : MetadataTypeBase {
    [CompilerGeneratedAttribute]
private MethodSignature <MethodSignature>k__BackingField;
    public string AssemblyQualification { get; }
    public bool IsResolved { get; }
    public MethodSignature MethodSignature { get; }
    public string FullName { get; }
    public MetadataFunctionPointerType(MethodSignature methodSignature, IMetadataTypeModifier[] typeModifiers, bool pinned);
    public virtual string get_AssemblyQualification();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public virtual bool get_IsResolved();
    public virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    [CompilerGeneratedAttribute]
public sealed virtual MethodSignature get_MethodSignature();
    public virtual string get_FullName();
}
public class JetBrains.Metadata.Reader.Impl.MetadataInterfaceImplementation : MetadataEntity {
    [CompilerGeneratedAttribute]
private IMetadataTypeInfo <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Interface>k__BackingField;
    public IMetadataTypeInfo Owner { get; }
    public IMetadataClassType Interface { get; }
    public MetadataInterfaceImplementation(IMetadataTypeInfo owner, TypeDecodeContext context, MetadataToken token);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataTypeInfo get_Owner();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataClassType get_Interface();
}
public class JetBrains.Metadata.Reader.Impl.MetadataManifestResource : MetadataEntity {
    private ManifestResourceAttributes myFlags;
    private MetadataToken myImplementation;
    private string myName;
    private UInt32 myOffset;
    public UInt32 Offset { get; }
    public ManifestResourceAttributes Flags { get; }
    public string Name { get; }
    public MetadataToken Implementation { get; }
    public MetadataManifestResource(MetadataToken manifestResourceToken, IMetadataAssembly assembly);
    public sealed virtual UInt32 get_Offset();
    public sealed virtual ManifestResourceAttributes get_Flags();
    public sealed virtual string get_Name();
    public sealed virtual MetadataToken get_Implementation();
    public sealed virtual IManifestResourceDisposition GetDisposition();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.MetadataMethod : MetadataEntity {
    private MetadataToken myDeclaringTypeToken;
    private CorMethodAttr myFlags;
    private CorMethodImpl myImplFlags;
    private UInt32 myCodeRva;
    private IMetadataTypeParameter[] myArguments;
    private IList`1<MethodSpecification> myImplementations;
    private IMetadataTypeInfo myDeclaringType;
    private IMetadataParameter[] myParameters;
    private IMetadataReturnValue myReturnValue;
    private MethodSignature mySignature;
    private IBlob mySignatureBlob;
    private IMetadataSecurityRow[] mySecurity;
    private String[] mySecurityAttributesTypeName;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private PInvokeInfo <PInvokeInfo>k__BackingField;
    public string Name { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IMetadataParameter[] Parameters { get; }
    public IMetadataReturnValue ReturnValue { get; }
    public IMetadataTypeParameter[] TypeParameters { get; }
    public IList`1<MethodSpecification> ImplementedMethods { get; }
    public MethodSignature Signature { get; }
    public PInvokeInfo PInvokeInfo { get; }
    public CorMethodImpl MethodImplFlags { get; }
    public IMetadataSecurityRow[] Security { get; }
    public String[] SecurityAttributesTypeName { get; }
    public bool IsPInvokeImpl { get; }
    public bool HasSecurity { get; }
    public CodeType CodeType { get; }
    public UInt32 CodeRva { get; }
    public bool IsForwardRef { get; }
    public bool IsPreserveSig { get; }
    public bool IsInternalCall { get; }
    public bool IsSynchronized { get; }
    public bool NoInlining { get; }
    public bool AggressiveInlining { get; }
    public bool AggressiveOptimization { get; }
    public bool NoOptimization { get; }
    public bool IsAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsExtern { get; }
    public bool IsVirtual { get; }
    public bool IsFinal { get; }
    public bool IsHideBySig { get; }
    public bool IsNewSlot { get; }
    public bool IsExplicitClassOverride { get; }
    public bool IsStrict { get; }
    public bool IsVarArg { get; }
    public bool IsUnmanaged { get; }
    public MetadataMethod(MetadataToken token, IMetadataAssembly assembly);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IMetadataParameter[] get_Parameters();
    public sealed virtual IMetadataReturnValue get_ReturnValue();
    public sealed virtual IMetadataTypeParameter[] get_TypeParameters();
    public sealed virtual IList`1<MethodSpecification> get_ImplementedMethods();
    public sealed virtual MethodSignature get_Signature();
    [CompilerGeneratedAttribute]
public sealed virtual PInvokeInfo get_PInvokeInfo();
    public sealed virtual CorMethodImpl get_MethodImplFlags();
    public sealed virtual IMetadataSecurityRow[] get_Security();
    public sealed virtual String[] get_SecurityAttributesTypeName();
    public sealed virtual bool get_IsPInvokeImpl();
    public sealed virtual bool get_HasSecurity();
    public sealed virtual CodeType get_CodeType();
    public sealed virtual UInt32 get_CodeRva();
    public sealed virtual bool get_IsForwardRef();
    public sealed virtual bool get_IsPreserveSig();
    public sealed virtual bool get_IsInternalCall();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_NoInlining();
    public sealed virtual bool get_AggressiveInlining();
    public sealed virtual bool get_AggressiveOptimization();
    public sealed virtual bool get_NoOptimization();
    public sealed virtual bool get_IsAssembly();
    public sealed virtual bool get_IsPrivate();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsFamily();
    public sealed virtual bool get_IsFamilyAndAssembly();
    public sealed virtual bool get_IsFamilyOrAssembly();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsFinal();
    public sealed virtual bool get_IsHideBySig();
    public sealed virtual bool get_IsNewSlot();
    public sealed virtual bool get_IsExplicitClassOverride();
    public sealed virtual bool get_IsStrict();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual bool get_IsUnmanaged();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.MetadataMethodSignatureBuilder : object {
    [NotNullAttribute]
private IMetadataAssembly myAssembly;
    private IMetadataTypeParameter[] myTypeTypeParameters;
    private TypeDecodeContext myContext;
    public MetadataMethodSignatureBuilder(IMetadataAssembly assembly, IMetadataTypeParameter[] typeTypeParameters);
    public MetadataMethodSignatureBuilder(IMetadataAssembly assembly, TypeDecodeContext context);
    public sealed virtual ITypeBuilder`2<IMetadataType, MethodSignature> GetTypeBuilder(UInt32 methodTypeParametersCount);
    public sealed virtual MethodSignature BuildMethodSignature(Prologs signatureFlags, UInt32 methodTypeParametersCount, IMetadataType returnType, IMetadataType[] parameterTypes, IMetadataType[] varargParameterTypes);
}
public class JetBrains.Metadata.Reader.Impl.MetadataParameter : MetadataEntity {
    [NotNullAttribute]
private IMetadataType myType;
    private ParamProperties myProperties;
    [NotNullAttribute]
private IMetadataMethod myMethod;
    private bool myIsParamArray;
    private bool myHasDefaultValue;
    [CanBeNullAttribute]
private IBlob myMarshalSpec;
    [CanBeNullAttribute]
private IBlob myDefaultValueBlob;
    private object myDefaultValue;
    public string Name { get; }
    public IMetadataType Type { get; }
    public IMetadataMethod DeclaringMethod { get; }
    public IBlob MarshalSpec { get; }
    public bool IsIn { get; }
    public bool IsOut { get; }
    public bool IsParamArray { get; }
    public bool IsOptional { get; }
    public bool HasMarshalSpec { get; }
    public bool HasDefaultValue { get; }
    public MetadataParameter(MetadataToken token, IMetadataType type, IMetadataMethod method, IMetadataAssembly assembly);
    public sealed virtual string get_Name();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IMetadataMethod get_DeclaringMethod();
    public sealed virtual IBlob get_MarshalSpec();
    public sealed virtual bool get_IsIn();
    public sealed virtual bool get_IsOut();
    public sealed virtual bool get_IsParamArray();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_HasMarshalSpec();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual object GetDefaultValue();
    public sealed virtual IBlob GetDefaultValueBlob();
    public virtual string ToString();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataPointerType : MetadataTypeBase {
    private IMetadataType myType;
    public IMetadataType Type { get; }
    public string AssemblyQualification { get; }
    public bool IsResolved { get; }
    public string FullName { get; }
    public MetadataPointerType(IMetadataType type, IMetadataTypeModifier[] typeModifiers, bool pinned);
    public sealed virtual IMetadataType get_Type();
    public virtual string get_AssemblyQualification();
    public virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public virtual string get_FullName();
}
public class JetBrains.Metadata.Reader.Impl.MetadataProperty : MetadataEntity {
    private IMetadataMethod[] myOtherAccessors;
    private IMetadataType myType;
    private MetadataToken myDeclaringTypeToken;
    private MetadataToken myGetter;
    private MetadataToken mySetter;
    private MetadataToken[] myOtherMethods;
    private string myName;
    private CorPropertyAttr myPropertyFlags;
    public string Name { get; }
    public IMetadataType Type { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IMetadataMethod Getter { get; }
    public IMetadataMethod Setter { get; }
    public IMetadataMethod[] OtherAccessors { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public MetadataProperty(MetadataToken token, IMetadataAssembly assembly);
    public sealed virtual string get_Name();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IMetadataMethod get_Getter();
    public sealed virtual IMetadataMethod get_Setter();
    public sealed virtual IMetadataMethod[] get_OtherAccessors();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    private void ReadSignature(IBlob signatureBlob);
    public virtual string ToString();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataReferenceType : MetadataTypeBase {
    private IMetadataType myType;
    public IMetadataType Type { get; }
    public string AssemblyQualification { get; }
    public bool IsResolved { get; }
    public string FullName { get; }
    public MetadataReferenceType(IMetadataType type, IMetadataTypeModifier[] typeModifiers, bool pinned);
    public sealed virtual IMetadataType get_Type();
    public virtual string get_AssemblyQualification();
    public virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public virtual string get_FullName();
}
public class JetBrains.Metadata.Reader.Impl.MetadataReturnValue : MetadataEntity {
    private ParamProperties myProperties;
    [CompilerGeneratedAttribute]
private IMetadataMethod <DeclaringMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlob <MarshalSpec>k__BackingField;
    public IMetadataMethod DeclaringMethod { get; }
    public IMetadataType Type { get; }
    public IBlob MarshalSpec { get; }
    public bool HasMarshalSpec { get; }
    public MetadataReturnValue(MetadataToken token, IMetadataType type, IMetadataMethod method, IMetadataAssembly assembly);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataMethod get_DeclaringMethod();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual IBlob get_MarshalSpec();
    public sealed virtual bool get_HasMarshalSpec();
    public virtual string ToString();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataSecurityAttribute : object {
    [CompilerGeneratedAttribute]
private IMetadataSecurityRow <DeclaringSecurityRow>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataTypeInfo <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataAttributeNamedArgument[] <NamedArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ConstructorArgumentsBlob>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityAction <Action>k__BackingField;
    public IMetadataSecurityRow DeclaringSecurityRow { get; }
    public IMetadataTypeInfo Type { get; }
    public IMetadataAttributeNamedArgument[] NamedArguments { get; }
    public Byte[] ConstructorArgumentsBlob { get; }
    public SecurityAction Action { get; }
    public MetadataSecurityAttribute(IMetadataTypeInfo type, IMetadataAttributeNamedArgument[] namedArguments, Byte[] constructorArgumentsBlob, SecurityAction action, IMetadataSecurityRow declaringSecurityRow);
    public MetadataSecurityAttribute(IMetadataTypeInfo type, IMetadataAttributeNamedArgument[] namedArguments, Byte[] constructorArgumentsBlob, IMetadataSecurityRow declaringSecurityRow);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataSecurityRow get_DeclaringSecurityRow();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataTypeInfo get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataAttributeNamedArgument[] get_NamedArguments();
    [CompilerGeneratedAttribute]
public sealed virtual Byte[] get_ConstructorArgumentsBlob();
    [CompilerGeneratedAttribute]
public sealed virtual SecurityAction get_Action();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.MetadataSecurityRow : MetadataEntity {
    private SecurityAction myAction;
    private IBlob myPermissionSetBlob;
    private IMetadataSecurityAttribute[] myAttributes;
    public SecurityAction Action { get; }
    public IMetadataSecurityAttribute[] Attributes { get; }
    public MetadataSecurityRow(MetadataToken declSecurityToken, IMetadataAssembly assembly);
    public sealed virtual SecurityAction get_Action();
    public sealed virtual IMetadataSecurityAttribute[] get_Attributes();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.MetadataSpecificTypeNameParser : AbstractTypeNameParser`1<IMetadataType> {
    private bool mySearchReferencedAssemblies;
    private ITypeInfoByNameProvider myTypeInfoByNameProvider;
    public MetadataSpecificTypeNameParser(string typeName, ITypeInfoByNameProvider typeInfoByNameProvider, bool searchReferencedAssemblies);
    protected virtual IMetadataType CreateUnresolvedType(string typeName, TextRange typeNameRange);
    protected virtual IMetadataType CreateTypeByNameAndAssembly(string typeName, TextRange typeNameRange, string assemblyName, TextRange assemblyNameRange, TextRange assemblyFullNameRange, IMetadataType[] genericParameters);
    protected virtual IMetadataType CreatePointerType(IMetadataType elementType);
    protected virtual IMetadataType CreateArrayType(IMetadataType elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    protected virtual IMetadataType CreateArrayType(IMetadataType elementType);
    protected virtual IMetadataType CreateReferenceType(IMetadataType elementType);
}
internal class JetBrains.Metadata.Reader.Impl.MetadataTupleType : MetadataTypeBase {
    [CompilerGeneratedAttribute]
private MetadataTupleTypeComponent[] <Components>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <UnderlyingType>k__BackingField;
    public bool IsResolved { get; }
    public string FullName { get; }
    public string AssemblyQualification { get; }
    public MetadataTupleTypeComponent[] Components { get; }
    public IMetadataClassType UnderlyingType { get; }
    public MetadataTupleType(IMetadataClassType underlyingType, MetadataTupleTypeComponent[] components);
    public virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public virtual string get_FullName();
    public virtual string get_AssemblyQualification();
    [CompilerGeneratedAttribute]
public sealed virtual MetadataTupleTypeComponent[] get_Components();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataClassType get_UnderlyingType();
    public virtual string ToString();
}
public abstract class JetBrains.Metadata.Reader.Impl.MetadataTypeBase : object {
    private IMetadataTypeModifier[] myTypeModifiers;
    private bool myPinned;
    public IMetadataTypeModifier[] TypeModifiers { get; }
    public bool Pinned { get; }
    public bool IsResolved { get; }
    public string FullName { get; }
    public string AssemblyQualification { get; }
    public string AssemblyQualifiedName { get; }
    protected MetadataTypeBase(IMetadataTypeModifier[] typeModifiers, bool pinned);
    public sealed virtual IMetadataTypeModifier[] get_TypeModifiers();
    public sealed virtual bool get_Pinned();
    public virtual bool get_IsResolved();
    public abstract virtual void Accept(IMetadataTypeVisitor visitor);
    public abstract virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public abstract virtual string get_FullName();
    public abstract virtual string get_AssemblyQualification();
    public virtual string get_AssemblyQualifiedName();
    public virtual string ToString();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataTypeBuilder : object {
    [NotNullAttribute]
private IMetadataAssembly myAssembly;
    [CanBeNullAttribute]
private TypeDecodeContext myTypeDecodeContext;
    public IMethodSignatureBuilder`2<IMetadataType, MethodSignature> MethodSignatureBuilder { get; }
    public bool IsLightweight { get; }
    public MetadataTypeBuilder(IMetadataAssembly assembly, TypeDecodeContext typeDecodeContext);
    public sealed virtual IMethodSignatureBuilder`2<IMetadataType, MethodSignature> get_MethodSignatureBuilder();
    public sealed virtual IMetadataType BuildWellKnownType(ElementType type);
    public sealed virtual IMetadataType BuildPointerType(IMetadataType type);
    public sealed virtual IMetadataType BuildReferenceType(IMetadataType type);
    public sealed virtual IMetadataType BuildClassType(MetadataToken typeDefOrRefOrSpecToken);
    public sealed virtual IMetadataType BuildGenericInst(IMetadataType type, IMetadataType[] args);
    public sealed virtual IMetadataType BuildTypeTypeParameter(UInt32 index);
    public sealed virtual IMetadataType BuildMethodTypeParameter(UInt32 index);
    public sealed virtual IMetadataType BuildFunctionPointer(MethodSignature functionSignature);
    public sealed virtual IMetadataType BuildArrayType(IMetadataType elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    public sealed virtual IMetadataType BuildArrayType(IMetadataType elementType);
    public sealed virtual IMetadataType AddRequiredModifier(IMetadataType type, IMetadataType modifier);
    public sealed virtual IMetadataType AddOptionalModifier(IMetadataType type, IMetadataType modifier);
    public sealed virtual IMetadataType AddPinnedConstraint(IMetadataType type);
    public sealed virtual IMetadataType BuildUndecodedType();
    public sealed virtual bool get_IsLightweight();
    private static IMetadataType AddModifier(IMetadataType type, IMetadataTypeModifier modifier);
}
public class JetBrains.Metadata.Reader.Impl.MetadataTypeInfo : MetadataEntity {
    private IMetadataClassType myBase;
    private IMetadataTypeParameter[] myTypeParameters;
    private ClassLayout myClassLayout;
    private IMetadataTypeInfo myDeclaringType;
    [CanBeNullAttribute]
private IMetadataEvent[] myEvents;
    [CanBeNullAttribute]
private IMetadataField[] myFields;
    private string myFullName;
    private IMetadataInterfaceImplementation[] myInterfaceImplementations;
    [CanBeNullAttribute]
private IMetadataMethod[] myMethods;
    [CanBeNullAttribute]
private IMetadataTypeInfo[] myNestedTypes;
    private TypeDefProperties myProperties;
    private IMetadataProperty[] myTypeProperties;
    private IMetadataSecurityRow[] mySecurity;
    private String[] mySecurityAttributesTypeName;
    private Dictionary`2<IMetadataMethod, IMetadataProperty> myAccessorToProperty;
    public string FullyQualifiedName { get; }
    public string AssemblyQualifiedName { get; }
    public string Name { get; }
    public string NamespaceName { get; }
    public string TypeName { get; }
    public AssemblyNameInfo DeclaringAssemblyName { get; }
    public IMetadataClassType Base { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IMetadataInterfaceImplementation[] InterfaceImplementations { get; }
    public IMetadataTypeParameter[] TypeParameters { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsImported { get; }
    public ClassLayoutType Layout { get; }
    public CharSetSpec InteropStringFormat { get; }
    public bool IsClass { get; }
    public bool IsInterface { get; }
    public bool IsSerializable { get; }
    public bool IsWindowsRuntime { get; }
    public bool IsPublic { get; }
    public bool IsNotPublic { get; }
    public bool IsNested { get; }
    public bool IsNestedPublic { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamilyAndAssembly { get; }
    public bool IsNestedFamilyOrAssembly { get; }
    public int PackingSize { get; }
    public int ClassSize { get; }
    public ClassLayout ClassLayout { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public bool IsBeforeFieldInit { get; }
    public bool HasSecurity { get; }
    public IMetadataSecurityRow[] Security { get; }
    public String[] SecurityAttributesTypeName { get; }
    public MetadataTypeInfo(MetadataToken token, IMetadataAssembly assembly);
    public sealed virtual string get_FullyQualifiedName();
    public sealed virtual string get_AssemblyQualifiedName();
    public sealed virtual string get_Name();
    public sealed virtual string get_NamespaceName();
    public sealed virtual string get_TypeName();
    public sealed virtual AssemblyNameInfo get_DeclaringAssemblyName();
    public sealed virtual IMetadataClassType get_Base();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IMetadataInterfaceImplementation[] get_InterfaceImplementations();
    public sealed virtual IMetadataTypeParameter[] get_TypeParameters();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsImported();
    public sealed virtual ClassLayoutType get_Layout();
    public sealed virtual CharSetSpec get_InteropStringFormat();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsWindowsRuntime();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsNotPublic();
    public sealed virtual bool get_IsNested();
    public sealed virtual bool get_IsNestedPublic();
    public sealed virtual bool get_IsNestedPrivate();
    public sealed virtual bool get_IsNestedFamily();
    public sealed virtual bool get_IsNestedAssembly();
    public sealed virtual bool get_IsNestedFamilyAndAssembly();
    public sealed virtual bool get_IsNestedFamilyOrAssembly();
    public sealed virtual int get_PackingSize();
    public sealed virtual int get_ClassSize();
    public sealed virtual ClassLayout get_ClassLayout();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual IEnumerable`1<MemberInfo> GetMemberInfos();
    public sealed virtual bool get_HasSecurity();
    public sealed virtual IMetadataSecurityRow[] get_Security();
    public sealed virtual String[] get_SecurityAttributesTypeName();
    public sealed virtual IMetadataMethod[] GetMethods();
    public sealed virtual bool HasExtensionMethods();
    public sealed virtual IMetadataField[] GetFields();
    public sealed virtual IMetadataProperty[] GetProperties();
    public sealed virtual IMetadataEvent[] GetEvents();
    public sealed virtual IMetadataProperty GetPropertyFromAccessor(IMetadataMethod accessor);
    public sealed virtual IMetadataTypeInfo[] GetNestedTypes();
    private IMetadataClassType GetBase();
    public virtual string ToString();
    public sealed virtual MetadataMemberPresenceFlags ComputeMemberPresenceFlag();
}
public class JetBrains.Metadata.Reader.Impl.MetadataTypeModifier : object {
    private MetadataModifierKind myKind;
    private IMetadataType myType;
    public MetadataModifierKind Kind { get; }
    public IMetadataType Type { get; }
    public MetadataTypeModifier(MetadataModifierKind kind, IMetadataType type);
    public sealed virtual MetadataModifierKind get_Kind();
    public sealed virtual IMetadataType get_Type();
}
public class JetBrains.Metadata.Reader.Impl.MetadataTypeParameter : MetadataEntity {
    private GenericParameterProperties myProperties;
    private IMetadataTypeParameterConstraint[] myConstraints;
    private IMetadataTypeInfo myOwnerType;
    private IMetadataMethod myOwnerMethod;
    public TypeParameterKind Kind { get; }
    public string Name { get; }
    public UInt32 Index { get; }
    public IMetadataTypeInfo TypeOwner { get; }
    public IMetadataMethod MethodOwner { get; }
    public IMetadataTypeParameterConstraint[] TypeConstraints { get; }
    public TypeParameterAttributes Attributes { get; }
    public MetadataTypeParameter(MetadataToken token, IMetadataAssembly assembly);
    public sealed virtual TypeParameterKind get_Kind();
    public sealed virtual string get_Name();
    public sealed virtual UInt32 get_Index();
    public sealed virtual IMetadataTypeInfo get_TypeOwner();
    public sealed virtual IMetadataMethod get_MethodOwner();
    public sealed virtual IMetadataTypeParameterConstraint[] get_TypeConstraints();
    public sealed virtual TypeParameterAttributes get_Attributes();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.MetadataTypeParameterConstraint : MetadataEntity {
    [CompilerGeneratedAttribute]
private IMetadataTypeParameter <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType <Constraint>k__BackingField;
    public IMetadataTypeParameter Owner { get; }
    public IMetadataType Constraint { get; }
    public MetadataTypeParameterConstraint(IMetadataTypeParameter owner, TypeDecodeContext context, MetadataToken token);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataTypeParameter get_Owner();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_Constraint();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataTypeParameterReferenceType : MetadataTypeBase {
    private IMetadataTypeParameter myArgument;
    public IMetadataTypeParameter TypeParameter { get; }
    public string AssemblyQualification { get; }
    public string AssemblyQualifiedName { get; }
    public bool IsResolved { get; }
    public string FullName { get; }
    public MetadataTypeParameterReferenceType(IMetadataTypeParameter argument, IMetadataTypeModifier[] typeModifiers, bool pinned);
    public sealed virtual IMetadataTypeParameter get_TypeParameter();
    public virtual string get_AssemblyQualification();
    public virtual string get_AssemblyQualifiedName();
    public virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public virtual string get_FullName();
}
public class JetBrains.Metadata.Reader.Impl.MethodBody : object {
    private IMetadataAssembly myAssembly;
    [CompilerGeneratedAttribute]
private IMetadataMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private Instruction[] <Instructions>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodBodyExceptionHandler[] <ExceptionHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodBodyLocalVariable[] <LocalVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxStack>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <LocalVariablesSignatureToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LocalVariablesInitialized>k__BackingField;
    public IMetadataMethod Method { get; }
    public Instruction[] Instructions { get; }
    public IMethodBodyExceptionHandler[] ExceptionHandlers { get; }
    public IMethodBodyLocalVariable[] LocalVariables { get; }
    public int MaxStack { get; }
    public MetadataToken LocalVariablesSignatureToken { get; }
    public bool LocalVariablesInitialized { get; }
    public MethodBody(ILMethodBody body, IMetadataMethod context, IMetadataAssembly assembly);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataMethod get_Method();
    [CompilerGeneratedAttribute]
public sealed virtual Instruction[] get_Instructions();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodBodyExceptionHandler[] get_ExceptionHandlers();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodBodyLocalVariable[] get_LocalVariables();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxStack();
    [CompilerGeneratedAttribute]
public sealed virtual MetadataToken get_LocalVariablesSignatureToken();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_LocalVariablesInitialized();
    private IMethodBodyExceptionHandler[] DecodeExceptionHandlers(ExceptionHandler[] handlers);
    private Instruction[] DecodeInstructions(ILMethodBody methodBody);
    private static object WrapMethodSpecification(Instruction instruction, MethodSpecification methodSpecification);
    private TypeDecodeContext GetTypeDecodeContext();
    public virtual string ToString();
}
[DebuggerDisplayAttribute("{myType} {myTryOffset}:{myTryLength} {myHandlerOffset}:{myHandlerLength}")]
internal class JetBrains.Metadata.Reader.Impl.MethodBodyExceptionHandler : object {
    private int myHandlerLength;
    private int myHandlerOffset;
    private IMetadataType myCatchType;
    private int myFilterOffset;
    private int myTryLength;
    private int myTryOffset;
    private ExceptionHandlerType myType;
    public ExceptionHandlerType Type { get; }
    public int HandlerLength { get; }
    public int HandlerOffset { get; }
    public IMetadataType CatchType { get; }
    public int FilterOffset { get; }
    public int TryLength { get; }
    public int TryOffset { get; }
    public MethodBodyExceptionHandler(ExceptionHandlerType type, int tryOffset, int tryLength, int filterOffset, IMetadataType catchType, int handlerOffset, int handlerLength);
    public sealed virtual ExceptionHandlerType get_Type();
    public sealed virtual int get_HandlerLength();
    public sealed virtual int get_HandlerOffset();
    public sealed virtual IMetadataType get_CatchType();
    public sealed virtual int get_FilterOffset();
    public sealed virtual int get_TryLength();
    public sealed virtual int get_TryOffset();
}
internal class JetBrains.Metadata.Reader.Impl.MethodBodyLocalVariable : object {
    private int myIndex;
    private IMetadataMethod myMethod;
    private IMetadataType myType;
    public IMetadataMethod Method { get; }
    public int Index { get; }
    public IMetadataType Type { get; }
    public bool Pinned { get; }
    public MethodBodyLocalVariable(IMetadataMethod method, int index, IMetadataType type);
    public virtual string ToString();
    public sealed virtual IMetadataMethod get_Method();
    public sealed virtual int get_Index();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual bool get_Pinned();
}
public class JetBrains.Metadata.Reader.Impl.MethodBodyUsagesFinder : object {
    private IMetadataAssembly myAssembly;
    private ImageBodyReader myBodyReader;
    private CliImage myCliImage;
    private ChunkHashMap`2<int, MetadataToken> myMethodsOffsets;
    private UnmanagedBlock myUnmanagedBlock;
    private LifetimeDefinition myLifetimeDefinition;
    public MethodBodyUsagesFinder(IMetadataAssembly assembly);
    public sealed virtual IReadOnlyList`1<MethodUsageCount> FindUsagesOf(IMetadataMethod method);
    public sealed virtual IReadOnlyList`1<MethodUsageCount> FindUsagesOf(IMetadataField field);
    public sealed virtual IReadOnlyList`1<MethodUsageCount> FindUsagesOf(IMetadataTypeInfo typeInfo);
    public sealed virtual IReadOnlyList`1<MethodUsageCount> FindUsagesOf(MetadataToken userStringToken, string userString);
    public IReadOnlyList`1<MethodUsageCount> FindMethodUsages(MetadataToken token);
    public IReadOnlyList`1<MethodUsageCount> FindFieldUsages(MetadataToken token);
    public sealed virtual IReadOnlyList`1<MethodUsageCount> FindDefaultConstructorUsagesOfValueType(IMetadataTypeInfo typeInfo);
    public sealed virtual void Dispose();
    private IEnumerable`1<MetadataToken> GetMethodsPossiblyContains(IEnumerable`1<MetadataToken> tokens);
    private int GetMethodReferencesCount(IMetadataMethod method, IMetadataMethod searchFor);
    private int GetMethodReferencesCount(IMetadataMethod method, MetadataToken searchFor);
    private bool IsMethodReferencesType(IMetadataMethod method, IMetadataTypeInfo searchFor);
    private static bool IsStaticOrConstructor(IMetadataMethod method);
    private static bool IsMethodInstantiationReferencesType(MethodInstantiation methodInstantiation, IMetadataTypeInfo searchFor);
    private static bool IsMethodSpecificationReferencesType(MethodSpecification methodSpecification, IMetadataTypeInfo searchFor);
    private static int IndexOf(UnmanagedBlock array, UInt32 value, int startOffset);
    private int GetFieldReferencesCount(IMetadataMethod method, IMetadataField searchFor);
    private int GetFieldReferencesCount(IMetadataMethod method, MetadataToken searchFor);
    private int GetStringReferencesCount(IMetadataMethod method, string searchFor);
    private int GetDefaultConstructorOfValueTypeReferencesCount(IMetadataMethod method, IMetadataTypeInfo searchFor);
    private ChunkHashMap`2<int, MetadataToken> GetMethodsOffsets();
    private static bool TypeHasTypeInfo(IMetadataType type, IMetadataTypeInfo searchFor);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private IMetadataMethod <FindUsagesOf>b__8_0(MetadataToken x);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private IMetadataMethod <FindUsagesOf>b__10_0(MetadataToken x);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private IMetadataMethod <FindDefaultConstructorUsagesOfValueType>b__13_0(MetadataToken x);
}
public static class JetBrains.Metadata.Reader.Impl.MethodBodyUtil : object {
    public static IMethodBodyLocalVariable[] DecodeLocalVariables(MetadataToken localVarsToken, IMetadataMethod method, IMetadataAssembly assembly, TypeDecodeContext typeDecodeContext);
}
public static class JetBrains.Metadata.Reader.Impl.MethodDebugInformationBlobDecoder : object {
    public static IReadOnlyList`1<SequencePoint> DecodeSequencePoints(UInt32 documentIndex, IBlob blob);
    public static MetadataToken DecodeLocalSignature(IBlob blob);
}
public static class JetBrains.Metadata.Reader.Impl.MethodSignatureBlobDecoder : object {
    public static TSignature DecodeBlob(IBinaryReader reader, IMethodSignatureBuilder`2<TType, TSignature> builder);
}
public class JetBrains.Metadata.Reader.Impl.ParsedClrTypeName : ClrTypeNameBase {
    private static String[] ourTypeParametersStrings;
    private static int ourTypeParametersStringsCount;
    private String[] myNamespaces;
    private TypeNameAndTypeParameterNumber[] myTypes;
    public string ShortName { get; }
    public int TypeParametersCount { get; }
    public string FullName { get; }
    public IEnumerable`1<string> NamespaceNames { get; }
    public IEnumerable`1<TypeNameAndTypeParameterNumber> TypeNames { get; }
    public ParsedClrTypeName(String[] namespaces, TypeNameAndTypeParameterNumber[] types);
    private static ParsedClrTypeName();
    public static string BuildFullName(String[] namespaces, TypeNameAndTypeParameterNumber[] types);
    public virtual IClrTypeName GetPersistent();
    public virtual string get_ShortName();
    public virtual int get_TypeParametersCount();
    public virtual string get_FullName();
    public virtual IEnumerable`1<string> get_NamespaceNames();
    public virtual IEnumerable`1<TypeNameAndTypeParameterNumber> get_TypeNames();
    [NotNullAttribute]
public virtual IClrTypeNamePartIterator GetPartIterator();
    public virtual string GetFullNameFast();
    public virtual int GetPartsCount();
}
internal static class JetBrains.Metadata.Reader.Impl.PermissionSetBlobDecoder : object {
    public static IMetadataSecurityAttribute[] DecodeBlob(IBlob blob, IMetadataSecurityRow context);
    [CanBeNullAttribute]
private static Byte[] ReadArguments(IBinaryReader reader, int attributeBlobStartPosition, int attributeBlobEndPosition, bool altFormat, CustomAttributeBlobDecoder customAttributeBlobDecoder, List`1<IMetadataAttributeNamedArgument> namedArguments);
    [CanBeNullAttribute]
private static Byte[] GetConstructorArgumentsBlob(IBinaryReader reader, int fromPosition, int toPosition);
    private static IMetadataSecurityAttribute[] DecodeBlob10(IBlob blob, IMetadataSecurityRow context);
}
public class JetBrains.Metadata.Reader.Impl.PresentingMethodSignatureBuilder : object {
    private Func`2<MetadataToken, string> myTypeTokenPresenter;
    public PresentingMethodSignatureBuilder(Func`2<MetadataToken, string> typeTokenPresenter);
    public sealed virtual ITypeBuilder`2<string, string> GetTypeBuilder(UInt32 methodTypeParametersCount);
    public sealed virtual string BuildMethodSignature(Prologs signatureFlags, UInt32 methodTypeParametersCount, string returnType, String[] parameterTypes, String[] varargParameterTypes);
}
public class JetBrains.Metadata.Reader.Impl.PresentingTypeBuilder : object {
    private Func`2<MetadataToken, string> myTypeTokenPresenter;
    public IMethodSignatureBuilder`2<string, string> MethodSignatureBuilder { get; }
    public bool IsLightweight { get; }
    public PresentingTypeBuilder(Func`2<MetadataToken, string> typeTokenPresenter);
    public sealed virtual IMethodSignatureBuilder`2<string, string> get_MethodSignatureBuilder();
    public sealed virtual string BuildWellKnownType(ElementType type);
    public sealed virtual string BuildPointerType(string type);
    public sealed virtual string BuildReferenceType(string type);
    public sealed virtual string BuildClassType(MetadataToken typeDefOrRefOrSpecToken);
    public sealed virtual string BuildGenericInst(string type, String[] args);
    public sealed virtual string BuildTypeTypeParameter(UInt32 index);
    public sealed virtual string BuildMethodTypeParameter(UInt32 index);
    public sealed virtual string BuildFunctionPointer(string functionSignature);
    public sealed virtual string BuildArrayType(string elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    public sealed virtual string BuildArrayType(string elementType);
    public sealed virtual string AddRequiredModifier(string type, string modifier);
    public sealed virtual string AddOptionalModifier(string type, string modifier);
    public sealed virtual string AddPinnedConstraint(string type);
    public sealed virtual string BuildUndecodedType();
    public sealed virtual bool get_IsLightweight();
}
public static class JetBrains.Metadata.Reader.Impl.PropertySignatureBlobDecoder : object {
    public static TPropertySignature DecodePropertySignature(IBlob signature, IMethodSignatureBuilder`2<TType, TPropertySignature> builder);
}
internal class JetBrains.Metadata.Reader.Impl.SecurityUtil : object {
    public static String[] GetSecurityAttributesTypeNames(IMetadataEntity entity);
}
public static class JetBrains.Metadata.Reader.Impl.TypeBlobDecoder : object {
    public static TType DecodeType(IBinaryReader reader, ITypeBuilder`2<TType, TMethodSig> typeBuilder);
    private static TType DecodeTypeDefOrRef(IBinaryReader reader, ITypeBuilder`2<TType, TMethodSig> typeBuilder);
    private static TType DecodeModOpt(IBinaryReader reader, ITypeBuilder`2<TType, TMethodSig> typeBuilder);
    private static TType DecodeModReq(IBinaryReader reader, ITypeBuilder`2<TType, TMethodSig> typeBuilder);
    private static TType DecodeGenericInstance(IBinaryReader reader, ITypeBuilder`2<TType, TMethodSig> typeBuilder);
    private static TType DecodeArrayType(IBinaryReader reader, ITypeBuilder`2<TType, TMethodSig> typeBuilder);
}
internal class JetBrains.Metadata.Reader.Impl.UnknownMetadataType : MetadataTypeBase {
    public static UnknownMetadataType UndecodedType;
    private string myComment;
    public bool IsResolved { get; }
    public string FullName { get; }
    public string AssemblyQualification { get; }
    public IMetadataTypeInfo Type { get; }
    public IMetadataType[] Arguments { get; }
    private UnknownMetadataType(string comment);
    private static UnknownMetadataType();
    public virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public virtual string get_FullName();
    public virtual string get_AssemblyQualification();
    public sealed virtual IMetadataTypeInfo get_Type();
    public sealed virtual IMetadataType[] get_Arguments();
}
public class JetBrains.Metadata.Reader.Impl.UnresolvedEvent : UnresolvedMetadataEntity {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataTypeInfo <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <Adder>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <Remover>k__BackingField;
    public string Name { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public IMetadataType Type { get; }
    public IMetadataMethod Adder { get; }
    public IMetadataMethod Remover { get; }
    public IMetadataMethod Raiser { get; }
    public IMetadataMethod[] OtherMethods { get; }
    public UnresolvedEvent(IMetadataTypeInfo declaringType, string name, IMetadataMethod adder, IMetadataMethod remover);
    public virtual bool Equals(IMetadataEntity other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual IMetadataType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataMethod get_Adder();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataMethod get_Remover();
    public sealed virtual IMetadataMethod get_Raiser();
    public sealed virtual IMetadataMethod[] get_OtherMethods();
}
public class JetBrains.Metadata.Reader.Impl.UnresolvedField : UnresolvedMetadataEntity {
    private IMetadataTypeInfo myDeclaringType;
    private string myName;
    private IMetadataType myType;
    public string Name { get; }
    public IMetadataType Type { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IBlob MarshalSpec { get; }
    public int Offset { get; }
    public FieldSignature Signature { get; }
    public UInt32 InitialValueRva { get; }
    public bool IsAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool HasMarshalSpec { get; }
    public bool NotSerialized { get; }
    public UnresolvedField(IMetadataTypeInfo declaringType, string name, IMetadataType type);
    public UnresolvedField(IMetadataTypeInfo declaringType, string name);
    public sealed virtual string get_Name();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IBlob get_MarshalSpec();
    public sealed virtual object GetLiteralValue();
    public sealed virtual IBlob GetLiteralValueBlob();
    public sealed virtual int get_Offset();
    public sealed virtual FieldSignature get_Signature();
    public sealed virtual UInt32 get_InitialValueRva();
    public sealed virtual bool get_IsAssembly();
    public sealed virtual bool get_IsPrivate();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsFamily();
    public sealed virtual bool get_IsFamilyAndAssembly();
    public sealed virtual bool get_IsFamilyOrAssembly();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsInitOnly();
    public sealed virtual bool get_IsLiteral();
    public sealed virtual bool get_HasMarshalSpec();
    public sealed virtual bool get_NotSerialized();
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool Equals(IMetadataEntity other);
}
public class JetBrains.Metadata.Reader.Impl.UnresolvedInterfaceImplementation : UnresolvedMetadataEntity {
    [CompilerGeneratedAttribute]
private IMetadataTypeInfo <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataClassType <Interface>k__BackingField;
    public IMetadataTypeInfo Owner { get; }
    public IMetadataClassType Interface { get; }
    public UnresolvedInterfaceImplementation(IMetadataTypeInfo owner, IMetadataClassType interface);
    public virtual bool Equals(IMetadataEntity other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataTypeInfo get_Owner();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataClassType get_Interface();
}
public abstract class JetBrains.Metadata.Reader.Impl.UnresolvedMetadataEntity : object {
    private IMetadataAssembly myAssembly;
    public IMetadataAssembly Assembly { get; }
    public MetadataToken Token { get; }
    public IMetadataCustomAttribute[] CustomAttributes { get; }
    public MetadataTypeReference[] CustomAttributesTypeNames { get; }
    public bool IsResolved { get; }
    protected UnresolvedMetadataEntity(IMetadataAssembly assembly);
    public sealed virtual IMetadataAssembly get_Assembly();
    public sealed virtual MetadataToken get_Token();
    public sealed virtual IMetadataCustomAttribute[] get_CustomAttributes();
    public sealed virtual MetadataTypeReference[] get_CustomAttributesTypeNames();
    public sealed virtual IList`1<IMetadataCustomAttribute> GetCustomAttributes(string attributeClassFullyQualifiedName);
    public sealed virtual bool HasCustomAttribute(string attributeClassFullyQualifiedName);
    public sealed virtual bool get_IsResolved();
    public abstract virtual bool Equals(IMetadataEntity other);
    public abstract virtual int GetHashCode();
    public abstract virtual string ToString();
    public virtual bool Equals(object obj);
}
public class JetBrains.Metadata.Reader.Impl.UnresolvedMethod : UnresolvedMetadataEntity {
    private IMetadataParameter[] myParameters;
    private IMetadataReturnValue myReturnValue;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataTypeInfo <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataTypeParameter[] <TypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSignature <Signature>k__BackingField;
    public string Name { get; }
    [NotNullAttribute]
public IMetadataTypeInfo DeclaringType { get; }
    public IMetadataReturnValue ReturnValue { get; }
    public IMetadataParameter[] Parameters { get; }
    [NotNullAttribute]
public IMetadataTypeParameter[] TypeParameters { get; }
    public IList`1<MethodSpecification> ImplementedMethods { get; }
    [NotNullAttribute]
public MethodSignature Signature { get; }
    public PInvokeInfo PInvokeInfo { get; }
    public CorMethodImpl MethodImplFlags { get; }
    public IMetadataSecurityRow[] Security { get; }
    public String[] SecurityAttributesTypeName { get; }
    public bool IsPInvokeImpl { get; }
    public bool HasSecurity { get; }
    public CodeType CodeType { get; }
    public UInt32 CodeRva { get; }
    public bool IsForwardRef { get; }
    public bool IsPreserveSig { get; }
    public bool IsInternalCall { get; }
    public bool IsSynchronized { get; }
    public bool NoInlining { get; }
    public bool AggressiveInlining { get; }
    public bool AggressiveOptimization { get; }
    public bool NoOptimization { get; }
    public bool IsAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsExtern { get; }
    public bool IsVirtual { get; }
    public bool IsFinal { get; }
    public bool IsHideBySig { get; }
    public bool IsNewSlot { get; }
    public bool IsExplicitClassOverride { get; }
    public bool IsStrict { get; }
    public bool IsVarArg { get; }
    public bool IsUnmanaged { get; }
    public UnresolvedMethod(IMetadataTypeInfo declaringType, string name, MethodSignature signature);
    public UnresolvedMethod(IMetadataTypeInfo declaringType, MemberReferenceProperties methodReferenceProperties, IMetadataAssembly referencingAssembly);
    public UnresolvedMethod(IMetadataTypeInfo declaringType, MemberReferenceProperties methodReferenceProperties, MethodSignature initialSignature, IMetadataAssembly referencingAssembly);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IMetadataReturnValue get_ReturnValue();
    public sealed virtual IMetadataParameter[] get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataTypeParameter[] get_TypeParameters();
    public sealed virtual IList`1<MethodSpecification> get_ImplementedMethods();
    [CompilerGeneratedAttribute]
public sealed virtual MethodSignature get_Signature();
    public sealed virtual PInvokeInfo get_PInvokeInfo();
    public sealed virtual CorMethodImpl get_MethodImplFlags();
    public sealed virtual IMetadataSecurityRow[] get_Security();
    public sealed virtual String[] get_SecurityAttributesTypeName();
    public sealed virtual bool get_IsPInvokeImpl();
    public sealed virtual bool get_HasSecurity();
    public sealed virtual CodeType get_CodeType();
    public sealed virtual UInt32 get_CodeRva();
    public sealed virtual bool get_IsForwardRef();
    public sealed virtual bool get_IsPreserveSig();
    public sealed virtual bool get_IsInternalCall();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_NoInlining();
    public sealed virtual bool get_AggressiveInlining();
    public sealed virtual bool get_AggressiveOptimization();
    public sealed virtual bool get_NoOptimization();
    public sealed virtual bool get_IsAssembly();
    public sealed virtual bool get_IsPrivate();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsFamily();
    public sealed virtual bool get_IsFamilyAndAssembly();
    public sealed virtual bool get_IsFamilyOrAssembly();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsFinal();
    public sealed virtual bool get_IsHideBySig();
    public sealed virtual bool get_IsNewSlot();
    public sealed virtual bool get_IsExplicitClassOverride();
    public sealed virtual bool get_IsStrict();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual bool get_IsUnmanaged();
    public virtual bool Equals(IMetadataEntity other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.UnresolvedParameter : UnresolvedMetadataEntity {
    private IMetadataMethod myDeclaringMethod;
    private IMetadataType myType;
    private string myName;
    public string Name { get; }
    public IMetadataType Type { get; }
    public IMetadataMethod DeclaringMethod { get; }
    public IBlob MarshalSpec { get; }
    public bool IsIn { get; }
    public bool IsOut { get; }
    public bool IsParamArray { get; }
    public bool IsOptional { get; }
    public bool HasMarshalSpec { get; }
    public bool HasDefaultValue { get; }
    public UnresolvedParameter(IMetadataType type, IMetadataMethod declaringMethod, int index);
    public sealed virtual string get_Name();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IMetadataMethod get_DeclaringMethod();
    public sealed virtual IBlob get_MarshalSpec();
    public sealed virtual bool get_IsIn();
    public sealed virtual bool get_IsOut();
    public sealed virtual bool get_IsParamArray();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_HasMarshalSpec();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual object GetDefaultValue();
    public sealed virtual IBlob GetDefaultValueBlob();
    public virtual bool Equals(IMetadataEntity other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.UnresolvedProperty : UnresolvedMetadataEntity {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataTypeInfo <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <Getter>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <Setter>k__BackingField;
    public string Name { get; }
    public IMetadataType Type { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IMetadataMethod Getter { get; }
    public IMetadataMethod Setter { get; }
    public IMetadataMethod[] OtherAccessors { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public UnresolvedProperty(IMetadataTypeInfo declaringType, string name, IMetadataMethod getter, IMetadataMethod setter);
    public virtual bool Equals(IMetadataEntity other);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual IMetadataType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataTypeInfo get_DeclaringType();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataMethod get_Getter();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataMethod get_Setter();
    public sealed virtual IMetadataMethod[] get_OtherAccessors();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.UnresolvedReturnValue : UnresolvedMetadataEntity {
    private IMetadataMethod myDeclaringMethod;
    private IMetadataType myType;
    public IMetadataMethod DeclaringMethod { get; }
    public IMetadataType Type { get; }
    public IBlob MarshalSpec { get; }
    public bool HasMarshalSpec { get; }
    public UnresolvedReturnValue(IMetadataMethod declaringMethod, IMetadataType type);
    public sealed virtual IMetadataMethod get_DeclaringMethod();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IBlob get_MarshalSpec();
    public sealed virtual bool get_HasMarshalSpec();
    public virtual bool Equals(IMetadataEntity other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.UnresolvedTypeInfo : UnresolvedMetadataEntity {
    private string myFullyQualifiedName;
    private AssemblyNameInfo myAssemblyName;
    private IMetadataTypeParameter[] myTypeParameters;
    private static HashSet`1<string> ourKnownValueTypes;
    private static HashSet`1<string> ourKnownInterfaces;
    [CompilerGeneratedAttribute]
private bool <IsValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInterface>k__BackingField;
    public string FullyQualifiedName { get; }
    public string AssemblyQualifiedName { get; }
    public string NamespaceName { get; }
    public string TypeName { get; }
    public string Name { get; }
    public AssemblyNameInfo DeclaringAssemblyName { get; }
    public IMetadataClassType Base { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IMetadataInterfaceImplementation[] InterfaceImplementations { get; }
    public IMetadataTypeParameter[] TypeParameters { get; }
    public bool IsValueType { get; internal set; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsImported { get; }
    public ClassLayoutType Layout { get; }
    public ClassLayout ClassLayout { get; }
    public CharSetSpec InteropStringFormat { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsClass { get; }
    public bool IsInterface { get; }
    public bool IsSerializable { get; }
    public bool IsWindowsRuntime { get; }
    public bool IsPublic { get; }
    public bool IsNotPublic { get; }
    public bool IsNested { get; }
    public bool IsNestedPublic { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamilyAndAssembly { get; }
    public bool IsNestedFamilyOrAssembly { get; }
    public int PackingSize { get; }
    public int ClassSize { get; }
    public String[] SecurityAttributesTypeName { get; }
    public bool HasSecurity { get; }
    public IMetadataSecurityRow[] Security { get; }
    public UnresolvedTypeInfo(string fullyQualifiedName);
    public UnresolvedTypeInfo(string fullyQualifiedName, AssemblyNameInfo assemblyName);
    private static UnresolvedTypeInfo();
    public sealed virtual string get_FullyQualifiedName();
    public sealed virtual string get_AssemblyQualifiedName();
    public sealed virtual string get_NamespaceName();
    public sealed virtual string get_TypeName();
    public sealed virtual string get_Name();
    public sealed virtual AssemblyNameInfo get_DeclaringAssemblyName();
    public sealed virtual IMetadataClassType get_Base();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IMetadataInterfaceImplementation[] get_InterfaceImplementations();
    public sealed virtual IMetadataTypeParameter[] get_TypeParameters();
    [CompilerGeneratedAttribute]
public bool get_IsValueType();
    [CompilerGeneratedAttribute]
internal void set_IsValueType(bool value);
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    private static bool IsKnownSealedClass(string fullyQualifiedName);
    public sealed virtual bool get_IsImported();
    public sealed virtual ClassLayoutType get_Layout();
    public sealed virtual ClassLayout get_ClassLayout();
    public sealed virtual CharSetSpec get_InteropStringFormat();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsClass();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsWindowsRuntime();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsNotPublic();
    public sealed virtual bool get_IsNested();
    public sealed virtual bool get_IsNestedPublic();
    public sealed virtual bool get_IsNestedPrivate();
    public sealed virtual bool get_IsNestedFamily();
    public sealed virtual bool get_IsNestedAssembly();
    public sealed virtual bool get_IsNestedFamilyAndAssembly();
    public sealed virtual bool get_IsNestedFamilyOrAssembly();
    public sealed virtual int get_PackingSize();
    public sealed virtual int get_ClassSize();
    public sealed virtual IEnumerable`1<MemberInfo> GetMemberInfos();
    public sealed virtual String[] get_SecurityAttributesTypeName();
    public sealed virtual bool get_HasSecurity();
    public sealed virtual IMetadataSecurityRow[] get_Security();
    public sealed virtual bool HasExtensionMethods();
    public sealed virtual MetadataMemberPresenceFlags ComputeMemberPresenceFlag();
    public sealed virtual IMetadataMethod[] GetMethods();
    public sealed virtual IMetadataField[] GetFields();
    public sealed virtual IMetadataProperty[] GetProperties();
    public sealed virtual IMetadataEvent[] GetEvents();
    public sealed virtual IMetadataTypeInfo[] GetNestedTypes();
    public sealed virtual IMetadataProperty GetPropertyFromAccessor(IMetadataMethod accessor);
    public virtual bool Equals(IMetadataEntity other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.UnresolvedTypeParameter : UnresolvedMetadataEntity {
    private UInt32 myIndex;
    private TypeParameterKind myKind;
    private IMetadataTypeInfo myTypeOwner;
    private IMetadataMethod myMethodOwner;
    public TypeParameterKind Kind { get; }
    public string Name { get; }
    public UInt32 Index { get; }
    public IMetadataTypeInfo TypeOwner { get; }
    public IMetadataMethod MethodOwner { get; }
    public IMetadataTypeParameterConstraint[] TypeConstraints { get; }
    public TypeParameterAttributes Attributes { get; }
    public UnresolvedTypeParameter(UInt32 index, TypeParameterKind kind);
    public UnresolvedTypeParameter(UInt32 index, IMetadataTypeInfo typeOwner);
    public UnresolvedTypeParameter(UInt32 index, IMetadataMethod method);
    public sealed virtual TypeParameterKind get_Kind();
    public sealed virtual string get_Name();
    public sealed virtual UInt32 get_Index();
    public sealed virtual IMetadataTypeInfo get_TypeOwner();
    public sealed virtual IMetadataMethod get_MethodOwner();
    public sealed virtual IMetadataTypeParameterConstraint[] get_TypeConstraints();
    public sealed virtual TypeParameterAttributes get_Attributes();
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool Equals(IMetadataEntity other);
}
public static class JetBrains.Metadata.Resources.AssemblyResourcesUtil : object {
    [ObsoleteAttribute("Use overload with IAssemblyLocation")]
[NotNullAttribute]
public static IManifestResourceDisposition[] GetAssemblyResources(FileSystemPath assemblyLocation);
    [NotNullAttribute]
public static IManifestResourceDisposition[] GetAssemblyResources(IAssemblyLocation assemblyLocation);
    [NotNullAttribute]
public static ValueTuple`3[] GetAssemblyResourcesWithTokens(IAssemblyLocation assemblyLocation);
    [CanBeNullAttribute]
public static Stream ReadResourceEntry(string entryName, IManifestResourceDisposition resource, Lifetime lifetime);
    [ObsoleteAttribute("Use overload with IAssemblyLocation")]
[NotNullAttribute]
public static ResourceDirectoryEntry[] GetWin32Resources(FileSystemPath assemblyPath);
    [NotNullAttribute]
public static ResourceDirectoryEntry[] GetWin32Resources(IAssemblyLocation assemblyLocation);
    [NotNullAttribute]
public static ResourceDirectoryEntry[] GetWin32DirectoryChildren(ResourceDirectory root);
    private static List`1<int> CollectLanguages(ResourceDirectoryEntry level1Directory);
    public static string ReadStringTable(ResourceDirectoryEntry stringTableDirectory, PEFile peFile);
    public static string ReadStringTableBlock(IBlob blockBlob, int blockId, int localeId);
    private static void ReadStringTableBlock(StringBuilder sb, IBlob blockBlob, int blockId);
    private static void AddLanguageInfo(StringBuilder sb, int localeId);
    private static string GetLanguagePresentation(int localeId);
    public static string GetLanguage(LocaleId localeId);
}
internal class JetBrains.Metadata.Resources.FastResourceComparer : object {
    internal static FastResourceComparer Default;
    private static FastResourceComparer();
    public sealed virtual int GetHashCode(object key);
    public sealed virtual int GetHashCode(string key);
    internal static int HashFunction(string key);
    public sealed virtual int Compare(object a, object b);
    public sealed virtual int Compare(string a, string b);
    public sealed virtual bool Equals(string a, string b);
    public sealed virtual bool Equals(object a, object b);
    public static int CompareOrdinal(string a, Byte[] bytes, int bCharLength);
    public static int CompareOrdinal(Byte[] bytes, int aCharLength, string b);
    internal static int CompareOrdinal(Byte* a, int byteLen, string b);
}
internal class JetBrains.Metadata.Resources.ResourceLocator : ValueType {
    internal object _value;
    internal int _dataPos;
    internal int DataPosition { get; }
    internal object Value { get; internal set; }
    internal ResourceLocator(int dataPos, object value);
    internal int get_DataPosition();
    internal object get_Value();
    internal void set_Value(object value);
    internal static bool CanCache(ResourceTypeCode value);
}
public class JetBrains.Metadata.Resources.ResourceReader : object {
    private static int DefaultFileStreamBufferSize;
    private BinaryReaderEx _store;
    internal Dictionary`2<string, ResourceLocator> _resCache;
    private long _nameSectionOffset;
    private long _dataSectionOffset;
    private Int32[] _nameHashes;
    private Int32* _nameHashesPtr;
    private Int32[] _namePositions;
    private Int32* _namePositionsPtr;
    private String[] _typeTable;
    private Int32[] _typeNamePositions;
    private int _numResources;
    private static int RuntimeResourceSetVersion;
    private UnmanagedMemoryStream _ums;
    private int _version;
    public ResourceReader(string fileName);
    public ResourceReader(Stream stream);
    internal ResourceReader(Stream stream, Dictionary`2<string, ResourceLocator> resCache);
    public void Close();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    internal static int ReadUnalignedI4(Int32* p);
    private void SkipString();
    private int GetNameHash(int index);
    private int GetNamePosition(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public IDictionaryEnumerator GetEnumerator();
    internal ResourceEnumerator GetEnumeratorInternal();
    internal int FindPosForResource(string name);
    private bool CompareStringEqualsName(string name);
    private string AllocateStringForNameIndex(int index, Int32& dataOffset);
    private object GetValueForNameIndex(int index);
    internal string LoadString(int pos);
    internal object LoadObject(int pos);
    internal object LoadObject(int pos, ResourceTypeCode& typeCode);
    internal object LoadObjectV1(int pos);
    private object _LoadObjectV1(int pos);
    internal object LoadObjectV2(int pos, ResourceTypeCode& typeCode);
    private object _LoadObjectV2(int pos, ResourceTypeCode& typeCode);
    private object DeserializeObject(int typeIndex);
    private void ReadResources();
    private void _ReadResources();
    private string FindType(int typeIndex);
    public void GetResourceData(string resourceName, String& resourceType, Byte[]& resourceData);
    private string TypeNameFromTypeCode(ResourceTypeCode typeCode);
}
internal enum JetBrains.Metadata.Resources.ResourceTypeCode : Enum {
    public int value__;
    public static ResourceTypeCode Null;
    public static ResourceTypeCode String;
    public static ResourceTypeCode Boolean;
    public static ResourceTypeCode Char;
    public static ResourceTypeCode Byte;
    public static ResourceTypeCode SByte;
    public static ResourceTypeCode Int16;
    public static ResourceTypeCode UInt16;
    public static ResourceTypeCode Int32;
    public static ResourceTypeCode UInt32;
    public static ResourceTypeCode Int64;
    public static ResourceTypeCode UInt64;
    public static ResourceTypeCode Single;
    public static ResourceTypeCode Double;
    public static ResourceTypeCode Decimal;
    public static ResourceTypeCode DateTime;
    public static ResourceTypeCode TimeSpan;
    public static ResourceTypeCode LastPrimitive;
    public static ResourceTypeCode ByteArray;
    public static ResourceTypeCode Stream;
    public static ResourceTypeCode StartOfUserTypes;
}
public class JetBrains.Metadata.Resources.SerializedObjectData : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    public string Type { get; }
    public SerializedObjectData(string type, BinaryReader reader);
    [CompilerGeneratedAttribute]
public string get_Type();
}
public static class JetBrains.Metadata.Utils.AlignmentHelper : object {
    public static int Align(int position, int alignment);
}
public class JetBrains.Metadata.Utils.AssemblyItem : object {
    [NotNullAttribute]
public AssemblyNameInfo AssemblyName;
    [NotNullAttribute]
public ImmutableFileItem File;
    [CanBeNullAttribute]
public ImmutableFileItem ProgramDatabase;
    [CanBeNullAttribute]
public ImmutableFileItem XmlDocumentation;
    private AssemblyNameInfo JetBrains.Metadata.Utils.IAssemblyItem.AssemblyName { get; }
    private ImmutableFileItem JetBrains.Metadata.Utils.IAssemblyItem.File { get; }
    private ImmutableFileItem JetBrains.Metadata.Utils.IAssemblyItem2.ProgramDatabase { get; }
    private ImmutableFileItem JetBrains.Metadata.Utils.IAssemblyItem2.XmlDocumentation { get; }
    public AssemblyItem(AssemblyNameInfo assemblyName, ImmutableFileItem file, ImmutableFileItem programDatabase, ImmutableFileItem xmlDocumentation);
    public AssemblyItem(IStructuredStorage storage);
    [NotNullAttribute]
public static AssemblyItem CreateAndReadAssemblyName(ImmutableFileItem file);
    public virtual string ToString();
    [CanBeNullAttribute]
public static AssemblyItem TryCreateAndReadAssemblyName(ImmutableFileItem file);
    private sealed virtual override AssemblyNameInfo JetBrains.Metadata.Utils.IAssemblyItem.get_AssemblyName();
    private sealed virtual override ImmutableFileItem JetBrains.Metadata.Utils.IAssemblyItem.get_File();
    private sealed virtual override void JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData(IStructuredStorage storage);
    private sealed virtual override ImmutableFileItem JetBrains.Metadata.Utils.IAssemblyItem2.get_ProgramDatabase();
    private sealed virtual override ImmutableFileItem JetBrains.Metadata.Utils.IAssemblyItem2.get_XmlDocumentation();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.AssemblyNameMetadataExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("failIfNotFound:true=>notnull")]
public static FileSystemPath FindAssemblyFile(FileSystemPath pathFolder, AssemblyNameInfo shortAssemblyName, bool failIfNotFound);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("failIfNotFound:true=>notnull")]
public static VirtualFileSystemPath FindAssemblyFile(VirtualFileSystemPath pathFolder, AssemblyNameInfo shortAssemblyName, bool failIfNotFound);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("failIfNotFound:true=>notnull")]
public static VirtualFileSystemPath FindAssemblyFile(VirtualFileSystemPath pathFolder, string shortAssemblyName, bool failIfNotFound);
}
public class JetBrains.Metadata.Utils.AssemblyNameReader : object {
    private IMetadataStreamsAccess myStreamsManager;
    public bool HasValidTables { get; }
    internal AssemblyNameReader(IMetadataStreamsAccess streamsManager);
    public Guid GetMvid();
    public void GetModuleNameAndMvid(Guid& mvid, String& moduleName);
    [CanBeNullAttribute]
public AssemblyNameInfo GetAssemblyName();
    internal Dictionary`2<MetadataToken, string> GetModuleRefs();
    internal IEnumerable`1<KeyValuePair`2<MetadataToken, AssemblyNameInfo>> GetReferences();
    private AssemblyNameInfo CreateAssemblyName(int name, Version version, int pubKeyTokenToken, int culture, AssemblyFlags flags, JetAssemblyHashAlgorithm hashAlgID);
    [CanBeNullAttribute]
public static AssemblyNameReader CreateReader(IBinaryReader reader, string imageMoniker);
    [CanBeNullAttribute]
public static AssemblyNameInfo GetAssemblyNameRaw(VirtualFileSystemPath path);
    [CanBeNullAttribute]
private static AssemblyInfo ReadAssemblyInfo(Stream stream, string moniker);
    [ObsoleteAttribute("Use overload with IAssemblyLocation")]
[CanBeNullAttribute]
public static AssemblyInfo GetAssemblyInfoRaw(VirtualFileSystemPath path);
    [CanBeNullAttribute]
public static AssemblyInfo GetAssemblyInfoRaw(IAssemblyLocation assemblyLocation);
    [CanBeNullAttribute]
public static AssemblyInfo GetAssemblyInfoIgnoreExceptions(VirtualFileSystemPath path);
    [CanBeNullAttribute]
public static AssemblyInfo GetAssemblyInfo(Stream stream);
    public bool get_HasValidTables();
}
public class JetBrains.Metadata.Utils.AssemblyResolver : object {
    protected Func`2<AssemblyNameInfo, bool> myPredicate;
    protected List`1<VirtualFileSystemPath> myBaseDirs;
    protected JetHashSet`1<AppDomain> myInstalledOn;
    public AssemblyResolver(IEnumerable`1<VirtualFileSystemPath> basedirs);
    public AssemblyResolver(IEnumerable`1<VirtualFileSystemPath> basedirs, Func`2<AssemblyNameInfo, bool> predicate);
    public static AssemblyResolver FromAssembly(Assembly assembly, Func`2<AssemblyNameInfo, bool> predicate);
    public static AssemblyResolver FromFolder(VirtualFileSystemPath folder, Func`2<AssemblyNameInfo, bool> predicate);
    public void Install(AppDomain appDomain);
    public void Uninstall(AppDomain appDomain);
    [CanBeNullAttribute]
private Assembly Resolve(object sender, ResolveEventArgs args);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.AssemblyScanner : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static AssemblyNameAndLocation[] GetAssembliesFromDirectory(VirtualFileSystemPath basePath);
    [ExtensionAttribute]
[NotNullAttribute]
public static AssemblyNameAndLocation[] ToAssembliesList(IEnumerable`1<VirtualFileSystemPath> assemblyFiles);
    [NotNullAttribute]
public static JetHashSet`1<AssemblyNameAndLocation> TransitivelyCloseAssemblyReferencesWithinTheirFolders(IReadOnlyCollection`1<VirtualFileSystemPath> assemblies);
}
public static class JetBrains.Metadata.Utils.AttributeUtil : object {
    [PureAttribute]
[NotNullAttribute]
public static string TrimAttributeSuffix(string attributeTypeShortName);
    [PureAttribute]
[NotNullAttribute]
public static string TrimAttributeSuffix(IClrTypeName attributeTypeName);
    [PureAttribute]
public static int GetAttributeNameLength(string attributeTypeShortName);
    [PureAttribute]
public static bool HasAttributeSuffix(string typeShortName);
    [PureAttribute]
public static bool HasAttributeSuffix(string typeShortName, String& nameWithoutAttributeSuffix);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.BinaryBlobExtensions : object {
    [ExtensionAttribute]
public static bool IsEmpty(IBlob blob);
    [ExtensionAttribute]
public static Byte[] ReadBytes(IBlob blob, int offset, int count);
    [ExtensionAttribute]
public static Byte[] ToArray(IBlob blob);
    [ExtensionAttribute]
public static bool CanReadBytes(IBlob blob, int offset, int count);
    [ExtensionAttribute]
public static string ReadStringUtf8(IBlob blob, int offset);
    [ExtensionAttribute]
public static sbyte ReadSByte(IBlob blob, int offset);
    [ExtensionAttribute]
public static byte ReadUInt8(IBlob blob, int offset);
    [ExtensionAttribute]
public static short ReadInt16(IBlob blob, int offset);
    [ExtensionAttribute]
public static int ReadInt32(IBlob blob, int offset);
    [ExtensionAttribute]
public static long ReadInt64(IBlob blob, int offset);
    [ExtensionAttribute]
public static UInt32 ReadCompressedInteger(IBlob blob, int offset);
    [ExtensionAttribute]
public static MetadataToken ReadTypeDefOrTypeRefEncoded(IBlob blob, int offset);
}
public class JetBrains.Metadata.Utils.BinaryBlobReader : object {
    [NotNullAttribute]
private IBlob myBlob;
    private int myLength;
    private int myPosition;
    public int Position { get; public set; }
    public int Length { get; }
    public BinaryBlobReader(IBlob blob);
    private BinaryBlobReader(BinaryBlobReader reader);
    public BinaryBlobReader(IBlob blob, int initialPosition);
    public sealed virtual int get_Position();
    public sealed virtual void set_Position(int value);
    public sealed virtual int get_Length();
    private sealed virtual override IBinaryReader JetBrains.Metadata.Utils.IBinaryReader.Clone();
    public sealed virtual char ReadChar();
    public sealed virtual float ReadSingle();
    public sealed virtual double ReadDouble();
    public sealed virtual short ReadInt16();
    public sealed virtual sbyte ReadSByte();
    public sealed virtual byte ReadUInt8();
    public sealed virtual ushort ReadUInt16();
    public sealed virtual int ReadInt32();
    public sealed virtual UInt32 ReadUInt32();
    public sealed virtual long ReadInt64();
    public sealed virtual ulong ReadUInt64();
    public sealed virtual string ReadStringUtf8();
    public sealed virtual string ReadStringUtf16le(int cbLength);
    public sealed virtual void Read(Byte[] buffer, int offset, int count);
    public sealed virtual byte ReadByte();
    public sealed virtual UInt32 ReadCompressedInteger();
    public sealed virtual string ReadUtf8Constant();
    public sealed virtual void Skip(int bytes);
}
public class JetBrains.Metadata.Utils.BinaryBlobStream : Stream {
    private IBlob myBlob;
    private int myPosition;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BinaryBlobStream(IBlob blob);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    private static void ThrowReadOnlyException();
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.BinaryReaderExtensions : object {
    [ExtensionAttribute]
public static bool Eof(IBinaryReader reader);
    [ExtensionAttribute]
public static void Align(IBinaryReader reader, int alignment);
    [ExtensionAttribute]
public static IDisposable Mark(IBinaryReader reader);
    [ExtensionAttribute]
public static Byte[] ReadBytes(IBinaryReader reader, int count);
    [ExtensionAttribute]
public static bool CanReadBytes(IBinaryReader reader, int count);
    [ExtensionAttribute]
public static MetadataToken ReadTypeDefOrTypeRefEncoded(IBinaryReader reader);
    [ExtensionAttribute]
public static int ReadCompressedSignedInteger(IBinaryReader reader);
    [ExtensionAttribute]
public static UInt32 ReadULEB128(IBinaryReader reader);
    [ExtensionAttribute]
public static decimal ReadDecimal(IBinaryReader reader);
    [ExtensionAttribute]
public static string ReadBString(IBinaryReader reader);
    [ExtensionAttribute]
public static string ReadCString(IBinaryReader reader);
    [ExtensionAttribute]
public static Guid ReadGuid(IBinaryReader reader);
}
public class JetBrains.Metadata.Utils.BlobOnReader : object {
    [NotNullAttribute]
private IBinaryReader myReader;
    private int myStartOffset;
    private int myLength;
    public int Length { get; }
    public BlobOnReader(IBinaryReader reader);
    private BlobOnReader(IBinaryReader reader, int startOffset, int length);
    public sealed virtual int get_Length();
    public sealed virtual IBlob Clone();
    public sealed virtual IBinaryReader CreateReader(int position);
    public sealed virtual IBlob Slice(int position, int length);
    public sbyte ReadSByte(int offset);
    public sealed virtual byte ReadByte(int offset);
    public byte ReadUInt8(int offset);
    public short ReadInt16(int offset);
    public sealed virtual ushort ReadUInt16(int offset);
    public sealed virtual UInt32 ReadUInt32(int offset);
    public sealed virtual ulong ReadUInt64(int offset);
    public sealed virtual void Read(int sourceOffset, Byte[] buffer, int bufferOffset, int count);
    public sealed virtual string ReadStringUtf8(int offset, Int32& bytesLenIncludingTerminatingZero);
    public sealed virtual UInt32 ReadCompressedInteger(int offset, Int32& size);
    public sealed virtual string ReadUtf8Constant(int offset, Int32& bytesLen);
    public sealed virtual bool EqualBytes(int offset, Byte[] bytes);
}
public enum JetBrains.Metadata.Utils.Bundle.AppHostType : Enum {
    public int value__;
    public static AppHostType None;
    public static AppHostType SingleFileBundle;
    public static AppHostType NativeHost;
}
[DebuggerDisplayAttribute("BundleFEL({BundleHeader.BundleID}, {FileEntryIndex}, {FileEntryRelativePath} in {BundleLocation})")]
public class JetBrains.Metadata.Utils.Bundle.BundleFileEntryLocation : object {
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <BundleLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private BundleManifest <BundleHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileEntryIndex>k__BackingField;
    [NotNullAttribute]
public VirtualFileSystemPath BundleLocation { get; }
    [NotNullAttribute]
public BundleManifest BundleHeader { get; }
    public int FileEntryIndex { get; }
    private FileEntry FileEntry { get; }
    public long FileEntrySize { get; }
    public long FileEntryCompressedSize { get; }
    public string FileEntryRelativePath { get; }
    [NotNullAttribute]
public RelativePath RelativePath { get; }
    public VirtualFileSystemPath AssemblyPhysicalPath { get; }
    public VirtualFileSystemPath ContainerPhysicalPath { get; }
    public bool IsEmpty { get; }
    public IInteractionContext Context { get; }
    public string Name { get; }
    public string NameWithoutExtension { get; }
    public string ExtensionWithDot { get; }
    public string ShortPresentation { get; }
    private BundleFileEntryLocation(VirtualFileSystemPath bundleLocation, BundleManifest bundleHeader, int fileEntryIndex);
    public static BundleFileEntryLocation Create(VirtualFileSystemPath bundleLocation, BundleManifest bundleHeader, int fileEntryIndex);
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_BundleLocation();
    [CompilerGeneratedAttribute]
public BundleManifest get_BundleHeader();
    [CompilerGeneratedAttribute]
public int get_FileEntryIndex();
    private FileEntry get_FileEntry();
    public long get_FileEntrySize();
    public long get_FileEntryCompressedSize();
    public string get_FileEntryRelativePath();
    public RelativePath get_RelativePath();
    public sealed virtual VirtualFileSystemPath get_AssemblyPhysicalPath();
    public sealed virtual VirtualFileSystemPath get_ContainerPhysicalPath();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual Stream OpenForReading();
    public sealed virtual T Visit(IAssemblyLocationVisitor`1<T> visitor);
    public sealed virtual IInteractionContext get_Context();
    public static BundleFileEntryLocation CreateKey(VirtualFileSystemPath bundleLocation, string bundleId, int fileEntryIndex);
    private bool Equals(BundleFileEntryLocation other);
    public sealed virtual bool Equals(IAssemblyLocation other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(BundleFileEntryLocation left, BundleFileEntryLocation right);
    public static bool op_Inequality(BundleFileEntryLocation left, BundleFileEntryLocation right);
    public virtual int GetHashCode();
    public sealed virtual string get_Name();
    public sealed virtual string get_NameWithoutExtension();
    public sealed virtual string get_ExtensionWithDot();
    public sealed virtual IAssemblyLocation GetNeighbor(string neighborName);
    public sealed virtual string get_ShortPresentation();
    public virtual string ToString();
}
public class JetBrains.Metadata.Utils.Bundle.BundleManifest : object {
    [CompilerGeneratedAttribute]
private string <BundleID>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BundleIDStringLength>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BundleMajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BundleMinorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private FileEntry <DepsJsonEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private FileEntry <RuntimeConfigJsonEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DepsJsonEntryOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DepsJsonEntrySize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RuntimeConfigJsonEntryOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RuntimeConfigJsonEntrySize>k__BackingField;
    [CompilerGeneratedAttribute]
private HeaderFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<FileEntry> <Files>k__BackingField;
    [NotNullAttribute]
public string BundleID { get; }
    public int BundleIDStringLength { get; }
    public UInt32 BundleMajorVersion { get; }
    public UInt32 BundleMinorVersion { get; }
    [CanBeNullAttribute]
public FileEntry DepsJsonEntry { get; }
    [CanBeNullAttribute]
public FileEntry RuntimeConfigJsonEntry { get; }
    public long DepsJsonEntryOffset { get; }
    public long DepsJsonEntrySize { get; }
    public long RuntimeConfigJsonEntryOffset { get; }
    public long RuntimeConfigJsonEntrySize { get; }
    public HeaderFlags Flags { get; }
    [NotNullAttribute]
public List`1<FileEntry> Files { get; }
    public string BundleVersion { get; }
    public BundleManifest(UInt32 bundleMajorVersion, UInt32 bundleMinorVersion, string bundleID, int bundleIDStringLength, long depsJsonEntryOffset, long depsJsonEntrySize, long runtimeConfigJsonEntryOffset, long runtimeConfigJsonEntrySize, HeaderFlags flags, List`1<FileEntry> files);
    [CompilerGeneratedAttribute]
public string get_BundleID();
    [CompilerGeneratedAttribute]
public int get_BundleIDStringLength();
    [CompilerGeneratedAttribute]
public UInt32 get_BundleMajorVersion();
    [CompilerGeneratedAttribute]
public UInt32 get_BundleMinorVersion();
    [CompilerGeneratedAttribute]
public FileEntry get_DepsJsonEntry();
    [CompilerGeneratedAttribute]
public FileEntry get_RuntimeConfigJsonEntry();
    [CompilerGeneratedAttribute]
public long get_DepsJsonEntryOffset();
    [CompilerGeneratedAttribute]
public long get_DepsJsonEntrySize();
    [CompilerGeneratedAttribute]
public long get_RuntimeConfigJsonEntryOffset();
    [CompilerGeneratedAttribute]
public long get_RuntimeConfigJsonEntrySize();
    [CompilerGeneratedAttribute]
public HeaderFlags get_Flags();
    [CompilerGeneratedAttribute]
public List`1<FileEntry> get_Files();
    public string get_BundleVersion();
    public static BundleManifest Read(IBinaryReader reader);
    internal static BundleManifest CreateKey(string bundleId);
    public bool Contains(string relativePath);
}
public static class JetBrains.Metadata.Utils.Bundle.BundleUtil : object {
    private static Byte[] ourBundleSignature;
    private static byte BundleSignatureFirstByte;
    private static BundleUtil();
    public static AppHostType GetAppHostType(VirtualFileSystemPath appHostFilePath, Int64& bundleHeaderOffset, BundleManifest& bundleHeader, ILogger logger);
    private static long SearchBundleSignature(Byte* start, long size);
    [NotNullAttribute]
public static FileSystemPath GetManagedAssemblyPath(FileSystemPath nativeAppHostPath);
}
public class JetBrains.Metadata.Utils.Bundle.FileEntry : object {
    [CompilerGeneratedAttribute]
private long <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private FileType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RelativePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RelativePathStringLength>k__BackingField;
    public long Offset { get; }
    public long Size { get; }
    public long CompressedSize { get; }
    public FileType Type { get; }
    public string RelativePath { get; }
    public int RelativePathStringLength { get; }
    public FileEntry(long offset, long size, long compressedSize, FileType type, string relativePath, int relativePathStringLength);
    [CompilerGeneratedAttribute]
public long get_Offset();
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
public long get_CompressedSize();
    [CompilerGeneratedAttribute]
public FileType get_Type();
    [CompilerGeneratedAttribute]
public string get_RelativePath();
    [CompilerGeneratedAttribute]
public int get_RelativePathStringLength();
    public static FileEntry Read(IBinaryReader reader, UInt32 bundleMajorVersion);
    public virtual string ToString();
}
public enum JetBrains.Metadata.Utils.Bundle.FileType : Enum {
    public byte value__;
    public static FileType Unknown;
    public static FileType Assembly;
    public static FileType NativeBinary;
    public static FileType DepsJson;
    public static FileType RuntimeConfigJson;
    public static FileType Symbols;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Utils.Bundle.HeaderFlags : Enum {
    public ulong value__;
    public static HeaderFlags None;
    public static HeaderFlags NetcoreApp3CompatMode;
}
public class JetBrains.Metadata.Utils.CodeTextWriter.CodeTextWriterAdapter : CodeTextWriterBase {
    private IndentedTextWriter myWriter;
    public int Indent { get; public set; }
    public CodeTextWriterAdapter(TextWriter writer, int indentSize, IIdentifierFixer identifierFixer);
    public virtual int get_Indent();
    public virtual void set_Indent(int value);
    protected virtual void WriteTextInternal(string text);
    protected virtual void WriteNewLineInternal();
}
public abstract class JetBrains.Metadata.Utils.CodeTextWriter.CodeTextWriterBase : object {
    private char myIndentSymbol;
    private int myIndentSize;
    [NotNullAttribute]
private IIdentifierFixer myIdentifierFixer;
    private bool myAtLineStart;
    [CompilerGeneratedAttribute]
private int <CurrentLineEstimatedLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Indent>k__BackingField;
    private IIdentifierFixer JetBrains.Metadata.Utils.CodeTextWriter.ICodeTextWriterWithIdentifierFixer.IdentifierFixer { get; }
    public int CurrentLineEstimatedLength { get; protected set; }
    public int Indent { get; public set; }
    public bool IsCurrentLineEmpty { get; }
    protected CodeTextWriterBase(char indentSymbol, int indentSize, IIdentifierFixer identifierFixer);
    private sealed virtual override IIdentifierFixer JetBrains.Metadata.Utils.CodeTextWriter.ICodeTextWriterWithIdentifierFixer.get_IdentifierFixer();
    [CompilerGeneratedAttribute]
public sealed virtual int get_CurrentLineEstimatedLength();
    [CompilerGeneratedAttribute]
protected void set_CurrentLineEstimatedLength(int value);
    [CompilerGeneratedAttribute]
public virtual int get_Indent();
    [CompilerGeneratedAttribute]
public virtual void set_Indent(int value);
    public sealed virtual bool get_IsCurrentLineEmpty();
    public sealed virtual void WriteTypeName(string namespaceName, string typeName);
    public sealed virtual void WriteAttributeTypeName(string namespaceName, string typeName);
    protected virtual void WriteTypeNameInternal(string namespaceName, string typeName, bool attribute);
    public virtual void WriteMarker(ICodeMarker marker);
    public sealed virtual void WriteText(string text);
    public sealed virtual void WriteIdentifier(string id);
    protected abstract virtual void WriteTextInternal(string text);
    public sealed virtual void WriteNewLine();
    protected abstract virtual void WriteNewLineInternal();
    public sealed virtual void EnsureNewLine();
    protected void IndentAtLineStart();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.CodeTextWriter.CodeTextWriterEx : object {
    [ExtensionAttribute]
public static ICodeTextWriter AppendText(ICodeTextWriter writer, string text);
    [ExtensionAttribute]
public static ICodeTextWriter AppendTextIf(ICodeTextWriter writer, string text, bool condition);
    [ExtensionAttribute]
public static ICodeTextWriter AppendDelimited(ICodeTextWriter writer, string delimiter, IEnumerable`1<T> items, Action`1<T> action, bool multiline);
    [ExtensionAttribute]
public static ICodeTextWriter AppendDelimited(ICodeTextWriter writer, IEnumerable`1<T> items, Action`1<T> action, bool multiline);
    [ExtensionAttribute]
public static ICodeTextWriter AppendDelimited(TCodeTextWriter writer, string delimiter, IEnumerable`1<T> items, Action`2<T, TCodeTextWriter> action, bool multiline);
    [ExtensionAttribute]
public static ICodeTextWriter AppendDelimited(TCodeTextWriter writer, IEnumerable`1<T> items, Action`2<T, TCodeTextWriter> action, bool multiline);
    [ExtensionAttribute]
[StringFormatMethodAttribute("format")]
public static ICodeTextWriter AppendText(ICodeTextWriter writer, string format, Object[] args);
    [ExtensionAttribute]
public static ICodeTextWriter AppendIdentifier(ICodeTextWriter writer, string id);
    [ExtensionAttribute]
public static ICodeTextWriter AppendQualifiedName(ICodeTextWriter writer, string qualifiedName);
    [ExtensionAttribute]
public static ICodeTextWriter AppendNewLine(ICodeTextWriter writer);
    [ExtensionAttribute]
public static ICodeTextWriter AppendNewLineIf(ICodeTextWriter writer, bool condition);
    [ExtensionAttribute]
public static IDisposable WithIncreaseIndent(ICodeTextWriter writer);
    [ExtensionAttribute]
public static IDisposable WithSetIndent(ICodeTextWriter writer, int indent);
    [ExtensionAttribute]
public static IDisposable WithBraces(ICodeTextWriter writer, bool outerNewLines, bool innerNewLinesAndIndents, bool innerSpaces);
    [ExtensionAttribute]
public static IDisposable WithBracesBlock(ICodeTextWriter writer, bool placeOpenBraceOnNewLine);
    [ExtensionAttribute]
public static IDisposable WithParentheses(ICodeTextWriter writer);
    [ExtensionAttribute]
public static IDisposable WithBrackets(ICodeTextWriter writer);
    [ExtensionAttribute]
public static IDisposable WithAngleBrackets(ICodeTextWriter writer);
    [ExtensionAttribute]
public static IDisposable WithBlockComment(ICodeTextWriter writer, bool writeNewLines);
    [ExtensionAttribute]
public static void AppendComment(ICodeTextWriter writer, string comment);
    [ExtensionAttribute]
[StringFormatMethodAttribute("format")]
public static void AppendComment(ICodeTextWriter writer, string format, Object[] args);
    [ExtensionAttribute]
public static ICodeTextWriter AppendTypeName(ICodeTextWriter writer, IMetadataType type, TypeRenderingParameters typeRenderingParameters);
    [ExtensionAttribute]
public static int GetCurrentLineEstimatedLength(ICodeTextWriter writer);
    [ExtensionAttribute]
public static int EstimateLength(ICodeTextWriter writer, Action`1<ITextAndDebugDataWriter> renderAction);
    [ExtensionAttribute]
public static ValueTuple`2<int, bool> EstimateLengthAndMultiline(ICodeTextWriter writer, Action`1<ITextAndDebugDataWriter> renderAction);
}
public class JetBrains.Metadata.Utils.CodeTextWriter.CodeTextWriterShortNameAdapter : CodeTextWriterAdapter {
    public CodeTextWriterShortNameAdapter(TextWriter writer, int indentSize, IIdentifierFixer identifierFixer);
    protected virtual void WriteTypeNameInternal(string namespaceName, string typeName, bool attribute);
}
internal abstract class JetBrains.Metadata.Utils.CodeTextWriter.CodeTextWriterWithLineLengthEstimationBase : CodeTextWriterBase {
    protected ICursorPositionStringBuilder Buffer;
    private bool myIndentEmptyLines;
    protected CodeTextWriterWithLineLengthEstimationBase(ICursorPositionStringBuilder buffer, FormatterOptions formatterOptions, IIdentifierFixer identifierFixer);
    private CodeTextWriterWithLineLengthEstimationBase(ICursorPositionStringBuilder buffer, char indentSymbol, int indentSize, bool indentEmptyLines, IIdentifierFixer identifierFixer);
    protected virtual void WriteTextInternal(string text);
    protected virtual void WriteNewLineInternal();
    public string GetText();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.CodeTextWriter.ConflictingNamesHelper : object {
    [ExtensionAttribute]
public static HashSet`1<string> GetConflictingNames(IMetadataTypeInfo metadataTypeInfo);
    private static void CollectConflictingNames(HashSet`1<string> conflictingNames, IMetadataTypeInfo metadataTypeInfo, bool includePrivateMemberNames, bool includeTypeParameterNames);
}
internal class JetBrains.Metadata.Utils.CodeTextWriter.CursorPositionStringBuilder : object {
    private StringBuilder myStringBuilder;
    private static char NewLineChar;
    private int myCurrentLine;
    private int myCurrentColumn;
    public CursorPositionStringBuilder(int startLinesCount);
    public sealed virtual void Append(string s);
    public sealed virtual string GetText();
    public sealed virtual int GetCurrentLine();
    public sealed virtual int GetCurrentColumn();
}
public class JetBrains.Metadata.Utils.CodeTextWriter.DefaultIdentifierFixer : object {
    public bool TreatEscapedNamesAsVerbatim { get; }
    public sealed virtual string FixIdentifier(string name);
    public sealed virtual bool IsKeyword(string name);
    public sealed virtual bool get_TreatEscapedNamesAsVerbatim();
    public sealed virtual string ToVerbatim(string name);
}
public class JetBrains.Metadata.Utils.CodeTextWriter.DoNotRenderNullableAnnotations : object {
    public static INullableRenderer Instance { get; }
    private bool JetBrains.Metadata.Utils.CodeTextWriter.INullableRenderer.RenderNullableAnnotations { get; }
    public static INullableRenderer get_Instance();
    private sealed virtual override bool JetBrains.Metadata.Utils.CodeTextWriter.INullableRenderer.get_RenderNullableAnnotations();
    private sealed virtual override void JetBrains.Metadata.Utils.CodeTextWriter.INullableRenderer.SetNullableAnnotationContext(bool nullableEnabled, bool forceWriteDirective);
    private sealed virtual override IDisposable JetBrains.Metadata.Utils.CodeTextWriter.INullableRenderer.SkipNullableAnnotations();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Metadata.Utils.CodeTextWriter.FormatterOptions : object {
    [CompilerGeneratedAttribute]
private bool <UseTabs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndentSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentEmptyLines>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PlaceOpenBraceOnNewLine>k__BackingField;
    [NullableAttribute("0")]
public static FormatterOptions Default;
    public static bool UseTabsDefault;
    public static int IndentSizeDefault;
    public static bool IndentEmptyLinesDefault;
    public static bool PlaceOpenBraceOnNewLineDefault;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public bool UseTabs { get; public set; }
    public int IndentSize { get; public set; }
    public bool IndentEmptyLines { get; public set; }
    public bool PlaceOpenBraceOnNewLine { get; public set; }
    public FormatterOptions(bool UseTabs, int IndentSize, bool IndentEmptyLines, bool PlaceOpenBraceOnNewLine);
    [CompilerGeneratedAttribute]
private FormatterOptions(FormatterOptions original);
    private static FormatterOptions();
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_UseTabs();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseTabs(bool value);
    [CompilerGeneratedAttribute]
public int get_IndentSize();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IndentSize(int value);
    [CompilerGeneratedAttribute]
public bool get_IndentEmptyLines();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IndentEmptyLines(bool value);
    [CompilerGeneratedAttribute]
public bool get_PlaceOpenBraceOnNewLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PlaceOpenBraceOnNewLine(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(FormatterOptions left, FormatterOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(FormatterOptions left, FormatterOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(FormatterOptions other);
    [CompilerGeneratedAttribute]
public FormatterOptions <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Boolean& UseTabs, Int32& IndentSize, Boolean& IndentEmptyLines, Boolean& PlaceOpenBraceOnNewLine);
}
public interface JetBrains.Metadata.Utils.CodeTextWriter.ICodeMarker {
}
public interface JetBrains.Metadata.Utils.CodeTextWriter.ICodeTextWriter {
    public int Indent { get; public set; }
    public bool IsCurrentLineEmpty { get; }
    public abstract virtual int get_Indent();
    public abstract virtual void set_Indent(int value);
    public abstract virtual bool get_IsCurrentLineEmpty();
    public abstract virtual void WriteText(string text);
    public abstract virtual void WriteNewLine();
    public abstract virtual void EnsureNewLine();
    public abstract virtual void WriteIdentifier(string id);
    public abstract virtual void WriteTypeName(string namespaceName, string typeName);
    public abstract virtual void WriteAttributeTypeName(string namespaceName, string typeName);
    public abstract virtual void WriteMarker(ICodeMarker marker);
}
public interface JetBrains.Metadata.Utils.CodeTextWriter.ICodeTextWriterWithIdentifierFixer {
    [NotNullAttribute]
public IIdentifierFixer IdentifierFixer { get; }
    public abstract virtual IIdentifierFixer get_IdentifierFixer();
}
public interface JetBrains.Metadata.Utils.CodeTextWriter.ICodeTextWriterWithLineLengthEstimation {
    public int CurrentLineEstimatedLength { get; }
    public abstract virtual int get_CurrentLineEstimatedLength();
}
internal interface JetBrains.Metadata.Utils.CodeTextWriter.ICursorPositionStringBuilder {
    public abstract virtual void Append(string s);
    public abstract virtual string GetText();
    public abstract virtual int GetCurrentLine();
    public abstract virtual int GetCurrentColumn();
}
public interface JetBrains.Metadata.Utils.CodeTextWriter.IIdentifierFixer {
    public bool TreatEscapedNamesAsVerbatim { get; }
    public abstract virtual string FixIdentifier(string name);
    public abstract virtual bool IsKeyword(string name);
    public abstract virtual bool get_TreatEscapedNamesAsVerbatim();
    public abstract virtual string ToVerbatim(string name);
}
public interface JetBrains.Metadata.Utils.CodeTextWriter.INullableRenderer {
    public bool RenderNullableAnnotations { get; }
    public abstract virtual bool get_RenderNullableAnnotations();
    public abstract virtual void SetNullableAnnotationContext(bool nullableEnabled, bool forceWriteDirective);
    public abstract virtual IDisposable SkipNullableAnnotations();
}
public interface JetBrains.Metadata.Utils.CodeTextWriter.IPreRenderOptimizations {
    public abstract virtual ITypesPresentation Optimize(ICollection`1<IClrTypeName> referencedTypeNames, ICollection`1<IClrTypeName> referencedAttributeTypeNames, IIdentifierFixer identifierFixer);
}
public interface JetBrains.Metadata.Utils.CodeTextWriter.ITypesCache {
    public abstract virtual IEnumerable`1<string> GetNamespacesContainingTypeShortName(string typeShortName, int typeParametersCount);
    public abstract virtual IEnumerable`1<string> GetNamespacesContainingAttributeShortName(string attributeTypeShortName, int typeParametersCount);
}
public interface JetBrains.Metadata.Utils.CodeTextWriter.ITypesPresentation {
    [NotNullAttribute]
[ItemNotNullAttribute]
public String[] ImportedNamespaces { get; }
    [NotNullAttribute]
public abstract virtual string GetTypePresentation(IClrTypeName typeName);
    [NotNullAttribute]
public abstract virtual string GetAttributeTypePresentation(IClrTypeName attributeTypeName);
    public abstract virtual String[] get_ImportedNamespaces();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.CodeTextWriter.NameFixerEx : object {
    [ExtensionAttribute]
public static string FixQualifiedName(IIdentifierFixer identifierFixer, string name);
}
public class JetBrains.Metadata.Utils.CodeTextWriter.NonOptimizedTypesPresentation : object {
    private IIdentifierFixer myIdentifierFixer;
    private Dictionary`2<IClrTypeName, string> myAttributeQualifiedTypeNameToPresentation;
    private Dictionary`2<IClrTypeName, string> myQualifiedTypeNameToPresentation;
    public String[] ImportedNamespaces { get; }
    public NonOptimizedTypesPresentation(IIdentifierFixer identifierFixer);
    public sealed virtual string GetTypePresentation(IClrTypeName typeName);
    public sealed virtual string GetAttributeTypePresentation(IClrTypeName attributeTypeName);
    public sealed virtual String[] get_ImportedNamespaces();
}
public class JetBrains.Metadata.Utils.CodeTextWriter.NoPreRenderOptimizations : object {
    public sealed virtual ITypesPresentation Optimize(ICollection`1<IClrTypeName> referencedTypeNames, ICollection`1<IClrTypeName> referencedAttributeTypeNames, IIdentifierFixer identifierFixer);
}
public class JetBrains.Metadata.Utils.CodeTextWriter.OptimizedTypesPresentation : object {
    [CompilerGeneratedAttribute]
private String[] <ImportedNamespaces>k__BackingField;
    private IDictionary`2<IClrTypeName, string> myTypesPresentation;
    private IDictionary`2<IClrTypeName, string> myAttributesPresentation;
    public String[] ImportedNamespaces { get; }
    public OptimizedTypesPresentation(ITypesCache typesCache, IIdentifierFixer identifierFixer, string ownNamespace, ICollection`1<string> conflictingNames, ICollection`1<IClrTypeName> types, ICollection`1<IClrTypeName> attributes, bool projectionIsUsed);
    public sealed virtual string GetTypePresentation(IClrTypeName typeName);
    public sealed virtual string GetAttributeTypePresentation(IClrTypeName attributeTypeName);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ImportedNamespaces();
    private static void CollectAllShortNames(HashSet`1<string> shortNames, IEnumerable`1<string> namespaces);
    private static HashSet`1<string> GetParentNamespaces(string namespace);
}
public class JetBrains.Metadata.Utils.CodeTextWriter.PreRenderImportsOptimizations : object {
    [CanBeNullAttribute]
private ITypesCache myTypesCache;
    private string myOwnNamespace;
    private ICollection`1<string> myConflictingNames;
    private bool myProjectionIsUsed;
    public PreRenderImportsOptimizations(bool projectionIsUsed);
    public PreRenderImportsOptimizations(ITypesCache typesCache, IMetadataTypeInfo typeInfo, bool projectionIsUsed);
    public PreRenderImportsOptimizations(ITypesCache typesCache, string ownNamespace, ICollection`1<string> conflictingNames, bool projectionIsUsed);
    public sealed virtual ITypesPresentation Optimize(ICollection`1<IClrTypeName> referencedTypeNames, ICollection`1<IClrTypeName> referencedAttributeTypeNames, IIdentifierFixer identifierFixer);
    private ITypesPresentation OptimizeImports(ICollection`1<IClrTypeName> referencedTypeNames, ICollection`1<IClrTypeName> referencedAttributeTypeNames, IIdentifierFixer identifierFixer);
    protected virtual void PostOptimizeImports(ITypesPresentation imports);
    private static HashSet`1<string> GetConflictingNames(IMetadataTypeInfo typeInfo);
    private static string GetOwnNamespace(IMetadataTypeInfo typeInfo);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.CodeTextWriter.RenderEx : object {
    private static Dictionary`2<ElementType, string> ourTypeAliases;
    private static RenderEx();
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string TryGetTypeAlias(IMetadataType type);
    [ExtensionAttribute]
public static string FixQualifiedName(string name, Func`2<string, string> identifierTransformer);
    [ExtensionAttribute]
public static string RenderToCSharp(IMetadataType type, bool typeShortName);
    [ExtensionAttribute]
public static string GetMethodIdentifierForSmartStepInto(IMetadataMethod method);
}
internal class JetBrains.Metadata.Utils.CodeTextWriter.RenderingLength : object {
    public static ValueTuple`2<int, bool> EstimateLength(Action`1<ITextAndDebugDataWriter> renderAction, IIdentifierFixer identifierFixer, int currentLineEstimatedLength);
}
public class JetBrains.Metadata.Utils.CodeTextWriter.StringBuilderCodeTextWriter : CodeTextWriterBase {
    public static char DefaultIndentSymbol;
    public static int DefaultIndentSize;
    private StringBuilder myStringBuilder;
    public StringBuilderCodeTextWriter(StringBuilder stringBuilder, char indentSymbol, int indentSize, IIdentifierFixer identifierFixer);
    protected virtual void WriteTextInternal(string text);
    protected virtual void WriteNewLineInternal();
    public virtual string ToString();
}
internal class JetBrains.Metadata.Utils.CodeTextWriter.TypeNameFormatter : object {
    private ICodeTextWriter myWriter;
    [NotNullAttribute]
private TypeRenderingParameters myTypeRenderingParameters;
    public TypeNameFormatter(ICodeTextWriter writer, TypeRenderingParameters typeRenderingParameters);
    public sealed virtual void VisitUnknownType(IMetadataType unknownType);
    public sealed virtual void VisitArrayType(IMetadataArrayType arrayType);
    private IDisposable WithNullableAnnotationIfNeeded();
    private void VisitArrayTypeInternal(IMetadataArrayType arrayType);
    private void WriteArrayRank(IMetadataArrayType arrayType);
    public sealed virtual void VisitClassType(IMetadataClassType classType);
    private IDisposable WithNullableAnnotationIfNeeded(IMetadataClassType classType);
    private void SkipGenericValueTypeNullableAnnotation();
    private void VisitClassTypeInternal(IMetadataClassType classType);
    public sealed virtual void VisitTupleType(IMetadataTupleType tupleType);
    public sealed virtual void VisitPointerType(IMetadataPointerType pointerType);
    public sealed virtual void VisitReferenceType(IMetadataReferenceType referenceType);
    public sealed virtual void VisitTypeParameterReferenceType(IMetadataTypeParameterReferenceType typeParameterReferenceType);
    private IDisposable WithNullableAnnotationIfNeeded(IMetadataTypeParameterReferenceType typeParameterReferenceType);
    public sealed virtual void VisitFunctionPointer(IMetadataFunctionPointerType functionPointerType);
    public sealed virtual void VisitBoxedType(IMetadataBoxedType boxedType);
    private void WriteSpace();
    [CompilerGeneratedAttribute]
private void <WithNullableAnnotationIfNeeded>b__5_0();
    [CompilerGeneratedAttribute]
private void <VisitFunctionPointer>b__17_0(IMetadataType parameterType);
    [CompilerGeneratedAttribute]
private void <VisitFunctionPointer>b__17_1(IMetadataType parameterType);
}
public class JetBrains.Metadata.Utils.CodeTextWriter.TypeRenderingParameters : object {
    [CompilerGeneratedAttribute]
private ValueTupleRenderingParameters <ValueTupleRenderingParameters>k__BackingField;
    public TypeAnnotationsEnumerator`1<NullableAnnotation> NullableAnnotationsEnumerator;
    [CompilerGeneratedAttribute]
private INullableRenderer <NullableRenderer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExplicitInterfaceImplementation>k__BackingField;
    private bool mySkipFirstNullableAnnotation;
    private bool myTreatTypeAsAttribute;
    private int myDoNotTreatTypeAsAttribute;
    [NotNullAttribute]
public ValueTupleRenderingParameters ValueTupleRenderingParameters { get; }
    [NotNullAttribute]
public INullableRenderer NullableRenderer { get; }
    public bool ExplicitInterfaceImplementation { get; }
    public TypeRenderingParameters(IMetadataEntity metadataEntity, bool renderTuples, INullableRenderer nullableRenderer, bool skipFirstNullableAnnotation, bool treatTypeAsAttribute);
    public TypeRenderingParameters(IMetadataEntity metadataEntity, bool renderTuples, INullableRenderer nullableRenderer, bool skipFirstNullableAnnotation, TypeAnnotationsEnumerator`1<NullableAnnotation> nullableAnnotationsEnumerator, bool treatTypeAsAttribute);
    public TypeRenderingParameters(ValueTupleRenderingParameters valueTupleRenderingParameters, bool explicitInterfaceImplementation, bool treatTypeAsAttribute);
    private TypeRenderingParameters(ValueTupleRenderingParameters valueTupleRenderingParameters, INullableRenderer nullableRenderer, bool skipFirstNullableAnnotation, TypeAnnotationsEnumerator`1<NullableAnnotation> nullableAnnotationsEnumerator, bool explicitInterfaceImplementation, bool treatTypeAsAttribute);
    [CompilerGeneratedAttribute]
public ValueTupleRenderingParameters get_ValueTupleRenderingParameters();
    [CompilerGeneratedAttribute]
public INullableRenderer get_NullableRenderer();
    [CompilerGeneratedAttribute]
public bool get_ExplicitInterfaceImplementation();
    public bool GetAndResetSkipFirstNullableAnnotation();
    public bool GetAndResetTreatTypeAsAttribute();
    public IDisposable DoNotTreatTypeAsAttribute();
    [CompilerGeneratedAttribute]
private void <DoNotTreatTypeAsAttribute>b__18_0();
    [CompilerGeneratedAttribute]
private void <DoNotTreatTypeAsAttribute>b__18_1();
}
public class JetBrains.Metadata.Utils.CodeTextWriter.TypeUsageCodeMarker : object {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public string TypeName { get; }
    public TypeUsageCodeMarker(string typeName);
    [CompilerGeneratedAttribute]
public string get_TypeName();
}
public class JetBrains.Metadata.Utils.CodeTextWriter.ValueTupleRenderingParameters : object {
    public static ValueTupleRenderingParameters DoNotRenderAsTuple;
    public static ValueTupleRenderingParameters RenderAsTupleWithoutNames;
    [CompilerGeneratedAttribute]
private bool <RenderAsTuple>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TupleElementNames>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NextTupleElementNameIndex>k__BackingField;
    public bool RenderAsTuple { get; }
    [CanBeNullAttribute]
public String[] TupleElementNames { get; }
    internal int NextTupleElementNameIndex { get; private set; }
    private ValueTupleRenderingParameters(bool renderAsTuple, String[] tupleElementNames);
    private static ValueTupleRenderingParameters();
    public static ValueTupleRenderingParameters Create(bool renderAsTuple, String[] tupleElementNames);
    [CompilerGeneratedAttribute]
public bool get_RenderAsTuple();
    [CompilerGeneratedAttribute]
public String[] get_TupleElementNames();
    [CompilerGeneratedAttribute]
internal int get_NextTupleElementNameIndex();
    [CompilerGeneratedAttribute]
private void set_NextTupleElementNameIndex(int value);
    internal void AdvanceIndex(int count);
}
public class JetBrains.Metadata.Utils.ComStreamWrapper : object {
    private static int STG_E_INVALIDFUNCTION;
    private Stream myBaseStream;
    private long myPosition;
    public ComStreamWrapper(Stream stream);
    private void SetSizeToPosition();
    public sealed virtual void Read(Byte[] pv, int cb, IntPtr pcbRead);
    public sealed virtual void Write(Byte[] pv, int cb, IntPtr pcbWritten);
    public sealed virtual void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
    public sealed virtual void SetSize(long libNewSize);
    public sealed virtual void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    public sealed virtual void Commit(int grfCommitFlags);
    public sealed virtual void Revert();
    public sealed virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public sealed virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public sealed virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    public sealed virtual void Clone(IStream& ppstm);
}
public class JetBrains.Metadata.Utils.CurrentDomainAssemblyResolver : object {
    [CompilerGeneratedAttribute]
private IAssemblyLoader <AssemblyLoader>k__BackingField;
    [NotNullAttribute]
public IAssemblyLoader AssemblyLoader { get; }
    public CurrentDomainAssemblyResolver(IAssemblyLoader assemblyLoader);
    [CompilerGeneratedAttribute]
public IAssemblyLoader get_AssemblyLoader();
    private Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEventArgs args);
    private sealed virtual override void System.IDisposable.Dispose();
    [NotNullAttribute]
public static CurrentDomainAssemblyResolver WithBasePath(VirtualFileSystemPath basePath);
    public static CurrentDomainAssemblyResolver WithKnownAssemblies(AssemblyNameAndLocation[] referencedAssembliesPaths);
    public static CurrentDomainAssemblyResolver WithKnownAssemblies(IAssemblyLoader assemblyLoader);
}
public class JetBrains.Metadata.Utils.DirectoryAssemblyLoader : object {
    [NotNullAttribute]
private VirtualFileSystemPath myBasePath;
    internal DirectoryAssemblyLoader(VirtualFileSystemPath basePath);
    public sealed virtual Assembly GetAssemblyByName(string fullAssemblyName);
    private VirtualFileSystemPath GetAssemblyPathByName(string assemblyName);
}
public enum JetBrains.Metadata.Utils.DotNetLegacy.AssemblyContentType : Enum {
    public int value__;
    public static AssemblyContentType Default;
    public static AssemblyContentType WindowsRuntime;
}
public class JetBrains.Metadata.Utils.DotNetLegacy.AssemblyNameInfoComparer : object {
    public static AssemblyNameInfoComparer Default;
    private static AssemblyNameInfoComparer();
    public bool ReferenceMatchesDefinition(string referenceDisplayName, AssemblyNameInfo definition);
    public bool ReferenceMatchesDefinition(AssemblyNameInfo reference, AssemblyNameInfo definition);
    public ComparisonResult Compare(AssemblyNameInfo reference, AssemblyNameInfo definition);
    public ComparisonResult Compare(AssemblyNameInfo reference, string referenceDisplayName, AssemblyNameInfo definition, Boolean& unificationApplied, bool ignoreVersion);
    private static Nullable`1<bool> TriviallyEquivalent(AssemblyNameInfo x, AssemblyNameInfo y);
    internal virtual bool ApplyUnificationPolicies(AssemblyNameInfo& reference, AssemblyNameInfo& definition, AssemblyNameInfoParts referenceParts, Boolean& isFxAssembly);
}
[FlagsAttribute]
public enum JetBrains.Metadata.Utils.DotNetLegacy.AssemblyNameInfoParts : Enum {
    public int value__;
    public static AssemblyNameInfoParts Name;
    public static AssemblyNameInfoParts Version;
    public static AssemblyNameInfoParts VersionMajor;
    public static AssemblyNameInfoParts VersionMinor;
    public static AssemblyNameInfoParts VersionBuild;
    public static AssemblyNameInfoParts VersionRevision;
    public static AssemblyNameInfoParts Culture;
    public static AssemblyNameInfoParts PublicKey;
    public static AssemblyNameInfoParts PublicKeyToken;
    public static AssemblyNameInfoParts PublicKeyOrToken;
    public static AssemblyNameInfoParts Retargetability;
    public static AssemblyNameInfoParts ContentType;
    public static AssemblyNameInfoParts Unknown;
}
internal class JetBrains.Metadata.Utils.DotNetLegacy.AssemblyVersion : ValueType {
    private ushort myMajor;
    private ushort myMinor;
    private ushort myBuild;
    private ushort myRevision;
    public int Major { get; }
    public int Minor { get; }
    public int Build { get; }
    public int Revision { get; }
    public AssemblyVersion(ushort major, ushort minor, ushort build, ushort revision);
    public int get_Major();
    public int get_Minor();
    public int get_Build();
    public int get_Revision();
    private ulong ToInteger();
    public sealed virtual int CompareTo(AssemblyVersion other);
    public sealed virtual bool Equals(AssemblyVersion other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyVersion left, AssemblyVersion right);
    public static bool op_Inequality(AssemblyVersion left, AssemblyVersion right);
    public static bool op_LessThan(AssemblyVersion left, AssemblyVersion right);
    public static bool op_LessThanOrEqual(AssemblyVersion left, AssemblyVersion right);
    public static bool op_GreaterThan(AssemblyVersion left, AssemblyVersion right);
    public static bool op_GreaterThanOrEqual(AssemblyVersion left, AssemblyVersion right);
    public static AssemblyVersion op_Explicit(Version version);
    public static Version op_Explicit(AssemblyVersion version);
}
public class JetBrains.Metadata.Utils.DotNetLegacy.DesktopAssemblyNameComparer : AssemblyNameInfoComparer {
    public static DesktopAssemblyNameComparer Default;
    internal static string NeutralCulture;
    private static IReadOnlyList`1<byte> NETCF_PUBLIC_KEY_TOKEN_1;
    private static IReadOnlyList`1<byte> NETCF_PUBLIC_KEY_TOKEN_2;
    private static IReadOnlyList`1<byte> NETCF_PUBLIC_KEY_TOKEN_3;
    private static IReadOnlyList`1<byte> SQL_PUBLIC_KEY_TOKEN;
    private static IReadOnlyList`1<byte> SQL_MOBILE_PUBLIC_KEY_TOKEN;
    private static IReadOnlyList`1<byte> ECMA_PUBLICKEY_STR_L;
    private static IReadOnlyList`1<byte> SHAREDLIB_PUBLICKEY_STR_L;
    private static IReadOnlyList`1<byte> MICROSOFT_PUBLICKEY_STR_L;
    private static IReadOnlyList`1<byte> SILVERLIGHT_PLATFORM_PUBLICKEY_STR_L;
    private static IReadOnlyList`1<byte> SILVERLIGHT_PUBLICKEY_STR_L;
    private static IReadOnlyList`1<byte> RIA_SERVICES_KEY_TOKEN;
    private static AssemblyVersion VER_VS_COMPATIBILITY_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion VER_VS_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion VER_SQL_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion VER_LINQ_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion VER_LINQ_ASSEMBLYVERSION_STR_2_L;
    private static AssemblyVersion VER_SQL_ORCAS_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion VER_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion VER_VC_STLCLR_ASSEMBLYVERSION_STR_L;
    private static string NULL;
    private static bool TRUE;
    private static FrameworkRetargetingDictionary ourGArRetargetPolicy;
    private static FrameworkAssemblyDictionary ourGArFxPolicy;
    private static DesktopAssemblyNameComparer();
    internal virtual bool ApplyUnificationPolicies(AssemblyNameInfo& reference, AssemblyNameInfo& definition, AssemblyNameInfoParts referenceParts, Boolean& isFxAssembly);
    public static bool IsFrameworkAssembly(AssemblyNameInfo identity);
    private static bool IsRetargetableAssembly(AssemblyNameInfo identity);
    private static bool IsOptionallyRetargetableAssembly(AssemblyNameInfo identity);
    private static bool IsTriviallyNonRetargetable(AssemblyNameInfo identity);
    private static void IsRetargetableAssembly(AssemblyNameInfo identity, Boolean& retargetable, Boolean& portable);
    private static AssemblyNameInfo Retarget(AssemblyNameInfo identity);
    private AssemblyNameInfo Port(AssemblyNameInfo identity);
}
internal class JetBrains.Metadata.Utils.DotNetLegacy.EqualityComparerCovariantAdapter`2 : object {
    private IEqualityComparer`1<TBase> myComparer;
    public EqualityComparerCovariantAdapter`2(IEqualityComparer`1<TBase> comparer);
    public sealed virtual bool Equals(TDervied x, TDervied y);
    public sealed virtual int GetHashCode(TDervied obj);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.DotNetLegacy.Utils : object {
    [ExtensionAttribute]
public static bool IsFullName(AssemblyNameInfoParts parts);
    public static AssemblyNameInfoParts GetParts(AssemblyNameInfo parsedInfo);
}
public class JetBrains.Metadata.Utils.EmptyBlob : object {
    [NotNullAttribute]
public static IBlob Instance;
    public int Length { get; }
    private static EmptyBlob();
    public sealed virtual int get_Length();
    public sealed virtual IBlob Clone();
    public sealed virtual IBinaryReader CreateReader(int position);
    public sealed virtual IBlob Slice(int position, int length);
    public sealed virtual byte ReadByte(int offset);
    public sealed virtual ushort ReadUInt16(int offset);
    public sealed virtual UInt32 ReadUInt32(int offset);
    public sealed virtual ulong ReadUInt64(int offset);
    public sealed virtual void Read(int sourceOffset, Byte[] buffer, int bufferOffset, int count);
    public sealed virtual string ReadStringUtf8(int offset, Int32& bytesLenIncludingTerminatingZero);
    public sealed virtual UInt32 ReadCompressedInteger(int offset, Int32& size);
    public sealed virtual string ReadUtf8Constant(int offset, Int32& bytesLen);
    public sealed virtual bool EqualBytes(int offset, Byte[] bytes);
}
public interface JetBrains.Metadata.Utils.IAssemblyItem {
    [NotNullAttribute]
public AssemblyNameInfo AssemblyName { get; }
    [NotNullAttribute]
public ImmutableFileItem File { get; }
    public abstract virtual AssemblyNameInfo get_AssemblyName();
    public abstract virtual ImmutableFileItem get_File();
}
public interface JetBrains.Metadata.Utils.IAssemblyItem2 {
    [CanBeNullAttribute]
public ImmutableFileItem ProgramDatabase { get; }
    [CanBeNullAttribute]
public ImmutableFileItem XmlDocumentation { get; }
    public abstract virtual ImmutableFileItem get_ProgramDatabase();
    public abstract virtual ImmutableFileItem get_XmlDocumentation();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.IAssemblyItemEx : object {
    [ExtensionAttribute]
public static Guid ModuleVersionIdentifier(IAssemblyItem ths);
}
public interface JetBrains.Metadata.Utils.IAssemblyLoader {
    [CanBeNullAttribute]
public abstract virtual Assembly GetAssemblyByName(string fullAssemblyName);
}
public interface JetBrains.Metadata.Utils.IBinaryReader {
    public int Position { get; public set; }
    public int Length { get; }
    public abstract virtual int get_Position();
    public abstract virtual void set_Position(int value);
    public abstract virtual int get_Length();
    [NotNullAttribute]
public abstract virtual IBinaryReader Clone();
    public abstract virtual char ReadChar();
    public abstract virtual float ReadSingle();
    public abstract virtual double ReadDouble();
    public abstract virtual short ReadInt16();
    public abstract virtual sbyte ReadSByte();
    public abstract virtual byte ReadUInt8();
    public abstract virtual ushort ReadUInt16();
    public abstract virtual int ReadInt32();
    public abstract virtual UInt32 ReadUInt32();
    public abstract virtual long ReadInt64();
    public abstract virtual ulong ReadUInt64();
    public abstract virtual void Read(Byte[] buffer, int offset, int count);
    public abstract virtual byte ReadByte();
    public abstract virtual string ReadStringUtf8();
    public abstract virtual string ReadStringUtf16le(int cbLength);
    public abstract virtual UInt32 ReadCompressedInteger();
    public abstract virtual string ReadUtf8Constant();
    public abstract virtual void Skip(int bytes);
}
public interface JetBrains.Metadata.Utils.IBlob {
    public int Length { get; }
    public abstract virtual int get_Length();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IBlob Clone();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IBinaryReader CreateReader(int position);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IBlob Slice(int position, int length);
    [PureAttribute]
public abstract virtual byte ReadByte(int offset);
    [PureAttribute]
public abstract virtual ushort ReadUInt16(int offset);
    [PureAttribute]
public abstract virtual UInt32 ReadUInt32(int offset);
    [PureAttribute]
public abstract virtual ulong ReadUInt64(int offset);
    public abstract virtual void Read(int sourceOffset, Byte[] buffer, int bufferOffset, int count);
    [PureAttribute]
public abstract virtual string ReadStringUtf8(int offset, Int32& bytesLenIncludingTerminatingZero);
    [PureAttribute]
public abstract virtual UInt32 ReadCompressedInteger(int offset, Int32& size);
    [PureAttribute]
public abstract virtual string ReadUtf8Constant(int offset, Int32& bytesLen);
    [PureAttribute]
public abstract virtual bool EqualBytes(int offset, Byte[] bytes);
}
internal class JetBrains.Metadata.Utils.IntInterval : ValueType {
    public int From;
    public int To;
    public int Length { get; }
    public IntInterval(int from, int to);
    public int get_Length();
}
internal class JetBrains.Metadata.Utils.KeyToValuesArrayDictionary`2 : object {
    private Dictionary`2<TKey, TValue[]> myResult;
    private Dictionary`2<TKey, List`1<TValue>> myMultipleValues;
    public KeyToValuesArrayDictionary`2(int capacity);
    public void Add(TKey key, TValue value);
    public Dictionary`2<TKey, TValue[]> GetResult();
}
public static class JetBrains.Metadata.Utils.LocalFunctionMetadataUtil : object {
    private static char Prefix;
    private static string OwnerAndLocalNameSplitter;
    private static char LocalNameEndMarker;
    private static int GetOwnerAndLocalNameSplitterIndex(string methodName);
    public static bool IsLocalFunction(IMetadataMethod method);
    private static bool IsLocalFunctionName(string methodName);
    public static string ExtractLocalFunctionName(string methodName);
    public static string ExtractOwnerMethodName(string methodName);
    public static bool IsStatic(IMetadataMethod localFunction);
    public static int GetLocalFunctionOwnParametersCount(IMetadataMethod localFunction);
    [CanBeNullAttribute]
public static IMetadataTypeInfo GetContextParameterType(IMetadataParameter parameter);
    public static bool IsContextParameter(IMetadataParameter parameter);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.ManifestResourceUtil : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static Stream TryGetManifestResourceStream(IMetadataAssembly metadataAssembly, string resourceName);
    [ExtensionAttribute]
[NotNullAttribute]
public static Stream GetManifestResourceStream(IMetadataAssembly metadataAssembly, string resourceName);
    [ExtensionAttribute]
[NotNullAttribute]
public static IManifestResourceDisposition GetManifestResourceDisposition(IMetadataAssembly metadataAssembly, string resourceName);
    [ExtensionAttribute]
[NotNullAttribute]
public static IMetadataManifestResource GetManifestResource(IMetadataAssembly metadataAssembly, string resourceName);
    [CanBeNullAttribute]
public static Stream TryGetManifestResourceStream(VirtualFileSystemPath assemblyLocation, string resourceName);
    [NotNullAttribute]
public static Stream GetManifestResourceStream(VirtualFileSystemPath assemblyLocation, string resourceName);
}
public static class JetBrains.Metadata.Utils.MarshalSpecParser : object {
    public static IMarshalSpec Parse(IBlob blob);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.MetadataHelpers : object {
    private static Dictionary`2<NativeType, UnmanagedType> ourNativeType2UnmanagedType;
    private static Dictionary`2<VariantType, VarEnum> ourVariantType2VarEnum;
    private static MetadataHelpers();
    [ExtensionAttribute]
public static LayoutKind ToLayoutKind(ClassLayoutType layoutType);
    [ExtensionAttribute]
public static CallingConvention ToCallingConvention(CallConvSpec spec);
    [ExtensionAttribute]
public static CharSet ToCharSet(CharSetSpec spec);
    [ExtensionAttribute]
public static bool IsValueType(IMetadataTypeInfo info);
    [ExtensionAttribute]
public static bool IsValueType(IMetadataType type);
    [ExtensionAttribute]
public static bool IsSealed(IMetadataType type);
    [ExtensionAttribute]
public static bool IsDelegate(IMetadataTypeInfo info);
    [ExtensionAttribute]
public static bool IsDelegate(IMetadataType type);
    [ExtensionAttribute]
private static bool IsProbablyDelegate(IMetadataTypeInfo info);
    [ExtensionAttribute]
public static bool IsRuntimeType(IMetadataType type);
    [ExtensionAttribute]
public static bool IsModuleType(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
public static bool IsAttribute(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
public static bool IsEnum(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
public static bool IsEnum(IMetadataType type);
    [ExtensionAttribute]
public static bool IsStruct(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
public static bool IsRefStruct(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
public static bool IsReadonlyStruct(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
public static bool IsString(IMetadataType type);
    [ExtensionAttribute]
public static bool IsDouble(IMetadataType type);
    [ExtensionAttribute]
public static bool IsFloat(IMetadataType type);
    [ExtensionAttribute]
public static bool IsDecimal(IMetadataType type);
    [ExtensionAttribute]
public static bool IsLong(IMetadataType type);
    [ExtensionAttribute]
public static bool IsULong(IMetadataType type);
    [ExtensionAttribute]
public static bool IsChar(IMetadataType type);
    [ExtensionAttribute]
public static bool IsInt(IMetadataType type);
    [ExtensionAttribute]
public static bool IsUInt(IMetadataType type);
    [ExtensionAttribute]
public static bool IsByte(IMetadataType type);
    [ExtensionAttribute]
public static bool IsSByte(IMetadataType type);
    [ExtensionAttribute]
public static bool IsShort(IMetadataType type);
    [ExtensionAttribute]
public static bool IsUShort(IMetadataType type);
    [ExtensionAttribute]
public static bool IsDateTime(IMetadataType type);
    [ExtensionAttribute]
public static bool IsTimeSpan(IMetadataType type);
    [ExtensionAttribute]
public static bool IsObject(IMetadataType type);
    [ExtensionAttribute]
public static bool IsVoid(IMetadataType type);
    [ExtensionAttribute]
internal static bool IsTask(IMetadataType type);
    [ExtensionAttribute]
public static bool IsBool(IMetadataType type);
    [ExtensionAttribute]
public static bool IsPtr(IMetadataType type);
    [ExtensionAttribute]
public static bool IsUPtr(IMetadataType type);
    [ExtensionAttribute]
public static bool IsPrimitive(IMetadataType type);
    [ExtensionAttribute]
public static bool IsPrimitiveOrEnum(IMetadataType type);
    [ExtensionAttribute]
internal static bool IsIntTask(IMetadataType type);
    [ExtensionAttribute]
public static IMetadataClassType GetUnderlyingEnumType(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
public static IMetadataClassType GetUnderlyingEnumType(IMetadataType type);
    [ExtensionAttribute]
public static bool IsNullable(IMetadataType type);
    [ExtensionAttribute]
internal static bool IsFunc(IMetadataTypeInfo info);
    [ExtensionAttribute]
internal static bool IsAction(IMetadataTypeInfo info);
    [ExtensionAttribute]
public static bool IsGenericValueTuple(IMetadataType type);
    [ExtensionAttribute]
public static bool ContainsGenericValueTuple(IMetadataType type);
    [ExtensionAttribute]
public static int GetTupleComponentsCount(IMetadataClassType valueTupleType);
    [ExtensionAttribute]
public static int GetTupleComponentsCount(IMetadataType valueTupleType);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataType GetTupleComponentType(IMetadataClassType valueTupleType, int componentIndex);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataType GetTupleComponentType(IMetadataType valueTupleType, int componentIndex);
    [PureAttribute]
public static int GetValueTupleItemIndex(string itemFieldName);
    [ExtensionAttribute]
[PureAttribute]
public static IMetadataType GetUnderlyingNullableType(IMetadataType type);
    [ExtensionAttribute]
[PureAttribute]
public static MethodCodeType ToMethodCodeType(CodeType codeType);
    [ExtensionAttribute]
[PureAttribute]
public static UnmanagedType ToUnmanagedType(NativeType type);
    [ExtensionAttribute]
[PureAttribute]
public static VarEnum ToVarEnum(VariantType type);
    [ExtensionAttribute]
[PureAttribute]
public static VariantType ToSimple(VariantType type);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsVector(VariantType type);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsArray(VariantType type);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsByref(VariantType type);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasModifier(IMetadataType type, string modifierFqn);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasTypeModifier(IMetadataType type, MetadataModifierKind kind, string fullName);
    [ExtensionAttribute]
[PureAttribute]
public static bool TypeSpecIsInstantiationOf(IMetadataAssembly assembly, MetadataToken typeSpec, MetadataToken type);
    [PureAttribute]
public static List`1<IMetadataTypeInfo> BuildTypeInfoList(IMetadataClassType classType);
    [PureAttribute]
[NotNullAttribute]
public static string MakeTypeFqn(string namespaceName, string typeName);
    [ExtensionAttribute]
public static MetadataTypeReference GetTypeInfoFullName(IMetadataAccess metadataAccess, MetadataToken type);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataAssembly GetCorlib(IMetadataAssembly assembly);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static MethodSpecification GetEntryPointMethod(IMetadataAssembly assembly);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string GetCustomAttributeValue(IMetadataEntity entity, string attributeName);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TargetFrameworkId GetTargetFramework(IMetadataAssembly assembly);
    [CanBeNullAttribute]
public static string TryGetAutoPropertyName(string backingFieldName);
    [ExtensionAttribute]
[CanBeNullAttribute]
internal static Byte[] Inflate(Stream compressedStream, int uncompressedSize);
    [CanBeNullAttribute]
internal static IMetadataStreamsAccess GetStreamsManager(IBinaryReader reader, string imageMoniker, CliImage& cliImage);
    internal static ValueTuple`8<JetAssemblyHashAlgorithm, ushort, ushort, ushort, ushort, AssemblyFlags, int, ValueTuple`2<int, int>> GetAssemblyProperties(IMetadataStreamsAccess streamsManager);
}
public static class JetBrains.Metadata.Utils.ModuleQualificationUtil : object {
    public static string TYPE_GROUP;
    public static string ASSEMBLY_GROUP;
    public static string VERSION_GROUP;
    public static string CULTURE_GROUP;
    public static string PUBLIC_KEY_TOKEN_GROUP;
    public static string TYPE_PATTERN;
    public static string ASSEMBLY_PATTERN;
    public static string ASSEMBLY_PATTERN_NO_COMMA;
    public static string VERSION_PATTERN;
    public static string CULTURE_PATTERN;
    public static string PUBLIC_KEY_TOKEN_PATTERN;
    public static string FULL_TYPE_NAME_PATTERN;
    public static string MODULE_QUALIFICATION_PATTERN;
    public static string MODULE_QUALIFICATION_PATTERN_NO_COMMA;
    public static Regex FULL_TYPE_NAME_REGEX;
    public static Regex MODULE_QUALIFICATION_REGEX;
    public static Regex MODULE_QUALIFICATION_REGEX_NO_COMMA;
    private static ModuleQualificationUtil();
    public static string Optional(string pattern);
    [CanBeNullAttribute]
public static AssemblyNameInfo GetAssemblyName(string moduleQualification, String& error, bool hasLeadingComma);
    internal static int GetIndexOfCommaAfterTypeName(string qualifiedTypeString);
    public static string GetTypeName(string qualifiedTypeString, AssemblyNameInfo& assemblyName);
}
[ExtensionAttribute]
internal static class JetBrains.Metadata.Utils.Pdb.PdbContent.DebugDataXmlSerializer : object {
    [ExtensionAttribute]
public static void DumpToXml(DebugData debugData, XmlWriter writer);
    [ExtensionAttribute]
private static void DumpToXml(DebugDocument document, XmlWriter writer);
    private static string PresentBytes(Byte[] bytes);
    [ExtensionAttribute]
private static void DumpToXml(ImportScope importScope, XmlWriter writer, DebugData debugData);
    [ExtensionAttribute]
private static void DumpToXml(DebugMethod method, XmlWriter writer);
    [ExtensionAttribute]
private static void DumpToXml(SequencePoint& sequencePoint, XmlWriter writer);
    [ExtensionAttribute]
private static void DumpToXml(LocalScope localScope, XmlWriter writer);
    [ExtensionAttribute]
private static void DumpToXml(DebugLocalVariable localVariable, XmlWriter writer);
    private static void DumpToXml(int documentIndex, TypeMemberRange[] typeMemberRanges, XmlWriter writer);
    [ExtensionAttribute]
private static void DumpToXml(TypeMemberRange typeMemberRange, XmlWriter writer);
}
[FlagsAttribute]
public enum JetBrains.Metadata.Utils.PE.Characteristics : Enum {
    public ushort value__;
    public static Characteristics RELOCS_STRIPPED;
    public static Characteristics EXECUTABLE_IMAGE;
    public static Characteristics LINE_NUMS_STRIPPED;
    public static Characteristics LOCAL_SYMS_STRIPPED;
    public static Characteristics AGGRESSIVE_WS_TRIM;
    public static Characteristics LARGE_ADDRESS_AWARE;
    public static Characteristics MACHINE_16BIT;
    public static Characteristics BYTES_REVERSED_LO;
    public static Characteristics MACHINE_32BIT;
    public static Characteristics DEBUG_STRIPPED;
    public static Characteristics REMOVABLE_RUN_FROM_SWAP;
    public static Characteristics NET_RUN_FROM_SWAP;
    public static Characteristics SYSTEM;
    public static Characteristics DLL;
    public static Characteristics UP_SYSTEM_ONLY;
    public static Characteristics BYTES_REVERSED_HI;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Utils.PE.CLIFlags : Enum {
    public UInt32 value__;
    public static CLIFlags IlOnly;
    public static CLIFlags Required32Bit;
    public static CLIFlags IlLibrary;
    public static CLIFlags StrongNameSigned;
    public static CLIFlags NativeEntryPoint;
    public static CLIFlags TrackDebugData;
    public static CLIFlags Preferred32Bit;
}
public class JetBrains.Metadata.Utils.PE.CLIHeader : object {
    private DataDirectory myCodeManagerTable;
    private DataDirectory myExportAddressTableJumps;
    private UInt32 myEntryPointToken;
    private CLIFlags myFlags;
    private DataDirectory myManagedNativeHeader;
    private DataDirectory myMetadata;
    private int myMetadataStartOffset;
    private DataDirectory myResources;
    private ushort myMajorRuntimeVersion;
    private ushort myMinorRuntimeVersion;
    private UInt32 mySize;
    private DataDirectory myStrongNameSignature;
    private DataDirectory myVTableFixups;
    public UInt32 Size { get; }
    public ushort MajorRuntimeVersion { get; }
    public ushort MinorRuntimeVersion { get; }
    public DataDirectory MetaData { get; }
    public CLIFlags Flags { get; }
    public UInt32 EntryPointToken { get; }
    public DataDirectory Resources { get; }
    public DataDirectory StrongNameSignature { get; }
    public DataDirectory CodeManagerTable { get; }
    public DataDirectory VTableFixups { get; }
    public DataDirectory ExportAddressTableJumps { get; }
    public DataDirectory ManagedNativeHeader { get; }
    public int MetadataStartOffset { get; }
    public CLIHeader(IBinaryReader reader, CliImage file);
    public UInt32 get_Size();
    public ushort get_MajorRuntimeVersion();
    public ushort get_MinorRuntimeVersion();
    public DataDirectory get_MetaData();
    public CLIFlags get_Flags();
    public UInt32 get_EntryPointToken();
    public DataDirectory get_Resources();
    public DataDirectory get_StrongNameSignature();
    public DataDirectory get_CodeManagerTable();
    public DataDirectory get_VTableFixups();
    public DataDirectory get_ExportAddressTableJumps();
    public DataDirectory get_ManagedNativeHeader();
    public int get_MetadataStartOffset();
}
public abstract class JetBrains.Metadata.Utils.PE.CliImage : object {
    [CompilerGeneratedAttribute]
private IBinaryReader <Reader>k__BackingField;
    [CompilerGeneratedAttribute]
private CLIHeader <CLIHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataHeader <MetadataHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private SectionHeaderBase[] <Sections>k__BackingField;
    public IBinaryReader Reader { get; protected set; }
    [CanBeNullAttribute]
public CLIHeader CLIHeader { get; protected set; }
    public int Offset { get; }
    [CanBeNullAttribute]
public MetadataHeader MetadataHeader { get; protected set; }
    public SectionHeaderBase[] Sections { get; protected set; }
    public bool IsValidCliImage { get; }
    [CompilerGeneratedAttribute]
public IBinaryReader get_Reader();
    [CompilerGeneratedAttribute]
protected void set_Reader(IBinaryReader value);
    [CompilerGeneratedAttribute]
public CLIHeader get_CLIHeader();
    [CompilerGeneratedAttribute]
protected void set_CLIHeader(CLIHeader value);
    public abstract virtual int get_Offset();
    [CompilerGeneratedAttribute]
public MetadataHeader get_MetadataHeader();
    [CompilerGeneratedAttribute]
protected void set_MetadataHeader(MetadataHeader value);
    [CompilerGeneratedAttribute]
public SectionHeaderBase[] get_Sections();
    [CompilerGeneratedAttribute]
protected void set_Sections(SectionHeaderBase[] value);
    public bool get_IsValidCliImage();
    public int RvaToVa(UInt32 rva);
    [CanBeNullAttribute]
public SectionHeaderBase RvaToSection(UInt32 rva);
    public abstract virtual DataDirectory GetDataDirectoryEntry(PeDirectoryEntry directoryId);
    [CanBeNullAttribute]
public PEDirectoryBase GetDirectory(PeDirectoryEntry directoryId);
    private static PEDirectoryBase CreateDirectory(PeDirectoryEntry directoryId, int dirSize);
}
public class JetBrains.Metadata.Utils.PE.CoffHeader : object {
    private Characteristics myCharacteristics;
    private MachineId myMachine;
    private OptHeaderSize mySizeOfOptionalHeader;
    private ushort mySectionsNo;
    private UInt32 mySignature;
    private UInt32 mySymbolsNo;
    private UInt32 mySymTablePtr;
    private UInt32 myTimeDateStamp;
    public UInt32 Signature { get; }
    public MachineId Machine { get; }
    public ushort NumberOfSections { get; }
    public UInt32 TimeDateStamp { get; }
    public UInt32 PointerToSymbolTable { get; }
    public UInt32 NumberOfSymbols { get; }
    public OptHeaderSize SizeOfOptionalHeader { get; }
    public Characteristics Characteristics { get; }
    public CoffHeader(IBinaryReader reader);
    public UInt32 get_Signature();
    public MachineId get_Machine();
    public ushort get_NumberOfSections();
    public UInt32 get_TimeDateStamp();
    public UInt32 get_PointerToSymbolTable();
    public UInt32 get_NumberOfSymbols();
    public OptHeaderSize get_SizeOfOptionalHeader();
    public Characteristics get_Characteristics();
}
[DebuggerDisplayAttribute("RVA={myRva} Size={mySize}")]
public class JetBrains.Metadata.Utils.PE.DataDirectory : object {
    private UInt32 myRva;
    private int mySize;
    public UInt32 RVA { get; }
    public int Size { get; }
    public DataDirectory(IBinaryReader reader);
    public DataDirectory(UInt32 rva, int size);
    public UInt32 get_RVA();
    public int get_Size();
}
public class JetBrains.Metadata.Utils.PE.Directories.DebugDataInfo : object {
    protected UInt32 myAge;
    protected int myOffset;
    protected string myPdbFile;
    protected UInt32 myCodeViewSignature;
    public UInt32 CodeViewSignature { get; }
    public int Offset { get; }
    public UInt32 Age { get; }
    public string PdbFile { get; }
    public UInt32 get_CodeViewSignature();
    public int get_Offset();
    public UInt32 get_Age();
    public string get_PdbFile();
    protected string ReadNullTerminatedString(IBinaryReader reader);
}
public class JetBrains.Metadata.Utils.PE.Directories.DebugDirectory : PEDirectoryBase {
    private static UInt32 CodeViewSignaturePdb2;
    private static UInt32 CodeViewSignaturePdb7;
    private static UInt32 EmbeddedPortablePdbDebugDirectoryEntrySignature;
    private Entry[] myEntries;
    public Entry[] Entries { get; }
    public Entry[] get_Entries();
    public virtual void Read(IBinaryReader rdr, int size, CliImage cliImage);
    public static Entry[] ReadEntries(IBinaryReader rdr, int size, int cliImageOffset);
    [CanBeNullAttribute]
public static DebugDataInfo ReadDebugDataInfo(IBinaryReader reader);
}
public class JetBrains.Metadata.Utils.PE.Directories.DebugInfo : object {
    private static ushort PortableMinorVersion;
    private static ushort EmbeddedPortableMinorVersion;
    internal static DebugInfo EmbeddedPortable;
    internal static DebugInfo Deterministic;
    [CompilerGeneratedAttribute]
private DebugInfoType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <AgeOrTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PdbFile>k__BackingField;
    public DebugInfoType Type { get; }
    public Guid Signature { get; }
    public UInt32 AgeOrTimestamp { get; }
    [CanBeNullAttribute]
public string PdbFile { get; }
    private DebugInfo(DebugInfoType type, Guid signature, UInt32 ageOrTimestamp, string pdbFile);
    private static DebugInfo();
    protected bool Equals(DebugInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public DebugInfoType get_Type();
    [CompilerGeneratedAttribute]
public Guid get_Signature();
    [CompilerGeneratedAttribute]
public UInt32 get_AgeOrTimestamp();
    [CompilerGeneratedAttribute]
public string get_PdbFile();
    [NotNullAttribute]
internal static DebugInfo CreateWindows(Guid signature, UInt32 age, string pdbFile);
    [NotNullAttribute]
internal static DebugInfo CreatePortable(Guid signature, UInt32 timeDateStamp, string pdbFile);
    [CanBeNullAttribute]
public static DebugInfo Create(ImageDebugDirectory imageDebugDirectory, DebugInfo7 debugInfo7);
    public static DebugInfo Read(UnsafeReader reader);
    public static void Write(UnsafeWriter writer, DebugInfo debugInfo);
    public virtual string ToString();
}
public class JetBrains.Metadata.Utils.PE.Directories.DebugInfo2 : DebugDataInfo {
    private UInt32 myTimestamp;
    public DateTime Timestamp { get; }
    public DebugInfo2(IBinaryReader stm);
    public DateTime get_Timestamp();
}
public class JetBrains.Metadata.Utils.PE.Directories.DebugInfo7 : DebugDataInfo {
    private Guid mySignature;
    public Guid Signature { get; }
    public DebugInfo7(IBinaryReader stm);
    public Guid get_Signature();
}
public enum JetBrains.Metadata.Utils.PE.Directories.DebugInfoType : Enum {
    public int value__;
    public static DebugInfoType Windows;
    public static DebugInfoType Portable;
    public static DebugInfoType EmbeddedPortable;
    public static DebugInfoType Deterministic;
}
public enum JetBrains.Metadata.Utils.PE.Directories.DebugType : Enum {
    public UInt32 value__;
    public static DebugType Unknown;
    public static DebugType COFF;
    public static DebugType CodeView;
    public static DebugType FPO;
    public static DebugType Misc;
    public static DebugType Exception;
    public static DebugType Fixup;
    public static DebugType OMAPtoSRC;
    public static DebugType OMAPfromSRC;
    public static DebugType Borland;
    public static DebugType Reserved10;
    public static DebugType CLSID;
    public static DebugType VCFeature;
    public static DebugType POGO;
    public static DebugType ILTCG;
    public static DebugType MPX;
    public static DebugType Deterministic;
    public static DebugType EmbeddedPortablePdb;
    public static DebugType PdbChecksum;
    public static DebugType R2RPerfMap;
}
public class JetBrains.Metadata.Utils.PE.Directories.EntireResourceDirectory : PEDirectoryBase {
    private ResourceDirectory myRoot;
    public ResourceDirectory Root { get; }
    public virtual void Read(IBinaryReader rdr, int size, CliImage peFile);
    public ResourceDirectory get_Root();
    public void Dump(TextWriter result);
}
public class JetBrains.Metadata.Utils.PE.Directories.ExportDirectory : PEDirectoryBase {
    [CompilerGeneratedAttribute]
private UInt32 <Characteristics>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <TimeDateStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NameString>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Base>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <NumberOfFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <NumberOfNames>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <AddressOfFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <AddressOfNames>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <AddressOfNameOrdinals>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32[] <FunctionRVAs>k__BackingField;
    [CompilerGeneratedAttribute]
private NameEntry[] <Names>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt16[] <NameOrdinals>k__BackingField;
    public UInt32 Characteristics { get; private set; }
    public UInt32 TimeDateStamp { get; private set; }
    public ushort MajorVersion { get; private set; }
    public ushort MinorVersion { get; private set; }
    public UInt32 Name { get; private set; }
    public string NameString { get; private set; }
    public UInt32 Base { get; private set; }
    public UInt32 NumberOfFunctions { get; private set; }
    public UInt32 NumberOfNames { get; private set; }
    public UInt32 AddressOfFunctions { get; private set; }
    public UInt32 AddressOfNames { get; private set; }
    public UInt32 AddressOfNameOrdinals { get; private set; }
    [NotNullAttribute]
public UInt32[] FunctionRVAs { get; private set; }
    [NotNullAttribute]
public NameEntry[] Names { get; private set; }
    [NotNullAttribute]
public UInt16[] NameOrdinals { get; private set; }
    [CompilerGeneratedAttribute]
public UInt32 get_Characteristics();
    [CompilerGeneratedAttribute]
private void set_Characteristics(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_TimeDateStamp();
    [CompilerGeneratedAttribute]
private void set_TimeDateStamp(UInt32 value);
    [CompilerGeneratedAttribute]
public ushort get_MajorVersion();
    [CompilerGeneratedAttribute]
private void set_MajorVersion(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_MinorVersion();
    [CompilerGeneratedAttribute]
private void set_MinorVersion(ushort value);
    [CompilerGeneratedAttribute]
public UInt32 get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(UInt32 value);
    [CompilerGeneratedAttribute]
public string get_NameString();
    [CompilerGeneratedAttribute]
private void set_NameString(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_Base();
    [CompilerGeneratedAttribute]
private void set_Base(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_NumberOfFunctions();
    [CompilerGeneratedAttribute]
private void set_NumberOfFunctions(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_NumberOfNames();
    [CompilerGeneratedAttribute]
private void set_NumberOfNames(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_AddressOfFunctions();
    [CompilerGeneratedAttribute]
private void set_AddressOfFunctions(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_AddressOfNames();
    [CompilerGeneratedAttribute]
private void set_AddressOfNames(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_AddressOfNameOrdinals();
    [CompilerGeneratedAttribute]
private void set_AddressOfNameOrdinals(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32[] get_FunctionRVAs();
    [CompilerGeneratedAttribute]
private void set_FunctionRVAs(UInt32[] value);
    [CompilerGeneratedAttribute]
public NameEntry[] get_Names();
    [CompilerGeneratedAttribute]
private void set_Names(NameEntry[] value);
    [CompilerGeneratedAttribute]
public UInt16[] get_NameOrdinals();
    [CompilerGeneratedAttribute]
private void set_NameOrdinals(UInt16[] value);
    public virtual void Read(IBinaryReader rdr, int size, CliImage peFile);
}
public enum JetBrains.Metadata.Utils.PE.Directories.LocaleId : Enum {
    public int value__;
    public static LocaleId Neutral;
    public static LocaleId UserDefault;
    public static LocaleId SystemDefault;
    public static LocaleId Afrikaans;
    public static LocaleId Albanian;
    public static LocaleId Amharic;
    public static LocaleId ArabicAlgeria;
    public static LocaleId ArabicBahrain;
    public static LocaleId ArabicEgypt;
    public static LocaleId ArabicIraq;
    public static LocaleId ArabicJordan;
    public static LocaleId ArabicKuwait;
    public static LocaleId ArabicLebanon;
    public static LocaleId ArabicLibya;
    public static LocaleId ArabicMorocco;
    public static LocaleId ArabicOman;
    public static LocaleId ArabicQatar;
    public static LocaleId ArabicSaudiArabia;
    public static LocaleId ArabicSyria;
    public static LocaleId ArabicTunisia;
    public static LocaleId ArabicUnitedArabEmirates;
    public static LocaleId ArabicYemen;
    public static LocaleId Armenian;
    public static LocaleId Assamese;
    public static LocaleId AzeriCyrillic;
    public static LocaleId AzeriLatin;
    public static LocaleId Basque;
    public static LocaleId Belarusian;
    public static LocaleId BengaliBangladesh;
    public static LocaleId BengaliIndia;
    public static LocaleId Bosnian;
    public static LocaleId Bulgarian;
    public static LocaleId Burmese;
    public static LocaleId Catalan;
    public static LocaleId Chinese;
    public static LocaleId ChineseHongKongSAR;
    public static LocaleId ChineseMacauSAR;
    public static LocaleId ChineseSingapore;
    public static LocaleId ChineseTaiwan;
    public static LocaleId Croatian;
    public static LocaleId Czech;
    public static LocaleId Danish;
    public static LocaleId DivehiMaldives;
    public static LocaleId Dutch;
    public static LocaleId DutchBelgium;
    public static LocaleId Edo;
    public static LocaleId English;
    public static LocaleId EnglishAustralia;
    public static LocaleId EnglishBelize;
    public static LocaleId EnglishCanada;
    public static LocaleId EnglishCaribbean;
    public static LocaleId EnglishGreatBritain;
    public static LocaleId EnglishIndia;
    public static LocaleId EnglishIreland;
    public static LocaleId EnglishJamaica;
    public static LocaleId EnglishNewZealand;
    public static LocaleId EnglishPhilippines;
    public static LocaleId EnglishSouthAfrica;
    public static LocaleId EnglishTrinidadAndTobago;
    public static LocaleId EnglishZimbabwe;
    public static LocaleId Estonian;
    public static LocaleId Faroese;
    public static LocaleId Farsi;
    public static LocaleId Filipino;
    public static LocaleId Finnish;
    public static LocaleId French;
    public static LocaleId FrenchBelgium;
    public static LocaleId FrenchCameroon;
    public static LocaleId FrenchCanada;
    public static LocaleId FrenchCongo;
    public static LocaleId FrenchCoteDIvoire;
    public static LocaleId FrenchLuxembourg;
    public static LocaleId FrenchMali;
    public static LocaleId FrenchMonaco;
    public static LocaleId FrenchMorocco;
    public static LocaleId FrenchSenegal;
    public static LocaleId FrenchSwitzerland;
    public static LocaleId FrenchWestIndies;
    public static LocaleId FrisianNetherlands;
    public static LocaleId FulfuldeNigeria;
    public static LocaleId FYROMacedonian;
    public static LocaleId GaelicIreland;
    public static LocaleId GaelicScotland;
    public static LocaleId Galician;
    public static LocaleId Georgian;
    public static LocaleId German;
    public static LocaleId GermanAustria;
    public static LocaleId GermanLiechtenstein;
    public static LocaleId GermanLuxembourg;
    public static LocaleId GermanSwitzerland;
    public static LocaleId Greek;
    public static LocaleId GuaraniParaguay;
    public static LocaleId Gujarati;
    public static LocaleId HumanInterfaceDevice;
    public static LocaleId Hebrew;
    public static LocaleId Hindi;
    public static LocaleId Hungarian;
    public static LocaleId IbibioNigeria;
    public static LocaleId Icelandic;
    public static LocaleId IgboNigeria;
    public static LocaleId Indonesian;
    public static LocaleId Italian;
    public static LocaleId ItalianSwitzerland;
    public static LocaleId Japanese;
    public static LocaleId Kannada;
    public static LocaleId Kashmiri;
    public static LocaleId Kazakh;
    public static LocaleId Khmer;
    public static LocaleId Konkani;
    public static LocaleId Korean;
    public static LocaleId KyrgyzCyrillic;
    public static LocaleId Lao;
    public static LocaleId Latin;
    public static LocaleId Latvian;
    public static LocaleId Lithuanian;
    public static LocaleId Malay;
    public static LocaleId MalayBruneiDarussalam;
    public static LocaleId Malayalam;
    public static LocaleId Maltese;
    public static LocaleId Manipuri;
    public static LocaleId Maori;
    public static LocaleId Marathi;
    public static LocaleId Mongolian;
    public static LocaleId MongolianCyrillic;
    public static LocaleId Nepali;
    public static LocaleId NepaliIndia;
    public static LocaleId NorwegianBokmal;
    public static LocaleId NorwegianNynorsk;
    public static LocaleId Oriya;
    public static LocaleId Oromo;
    public static LocaleId Papiamentu;
    public static LocaleId Pashto;
    public static LocaleId Polish;
    public static LocaleId Portuguese;
    public static LocaleId PortugueseBrazil;
    public static LocaleId Punjabi;
    public static LocaleId PunjabiPakistan;
    public static LocaleId QuechaBolivia;
    public static LocaleId QuechaEcuador;
    public static LocaleId QuechaPeru;
    public static LocaleId RaetoRomanic;
    public static LocaleId Romanian;
    public static LocaleId RomanianMoldova;
    public static LocaleId Russian;
    public static LocaleId RussianMoldova;
    public static LocaleId SamiLappish;
    public static LocaleId Sanskrit;
    public static LocaleId Sepedi;
    public static LocaleId SerbianCyrillic;
    public static LocaleId SerbianLatin;
    public static LocaleId SesothoSutu;
    public static LocaleId SindhiIndia;
    public static LocaleId SindhiPakistan;
    public static LocaleId SinhalaSinhalese;
    public static LocaleId Slovak;
    public static LocaleId Slovenian;
    public static LocaleId Somali;
    public static LocaleId Sorbian;
    public static LocaleId SpanishArgentina;
    public static LocaleId Spanish;
    public static LocaleId SpanishBolivia;
    public static LocaleId SpanishChile;
    public static LocaleId SpanishColombia;
    public static LocaleId SpanishCostaRica;
    public static LocaleId SpanishDominicanRepublic;
    public static LocaleId SpanishEcuador;
    public static LocaleId SpanishElSalvador;
    public static LocaleId SpanishGuatemala;
    public static LocaleId SpanishHonduras;
    public static LocaleId SpanishLatinAmerica;
    public static LocaleId SpanishMexico;
    public static LocaleId SpanishNicaragua;
    public static LocaleId SpanishPanama;
    public static LocaleId SpanishParaguay;
    public static LocaleId SpanishPeru;
    public static LocaleId SpanishPuertoRico;
    public static LocaleId SpanishUnitedStates;
    public static LocaleId SpanishSpainModernSort;
    public static LocaleId SpanishUruguay;
    public static LocaleId SpanishVenezuela;
    public static LocaleId Swahili;
    public static LocaleId Swedish;
    public static LocaleId SwedishFinland;
    public static LocaleId Syriac;
    public static LocaleId Tajik;
    public static LocaleId TamazightArabic;
    public static LocaleId TamazightLatin;
    public static LocaleId Tamil;
    public static LocaleId Tatar;
    public static LocaleId Telugu;
    public static LocaleId Thai;
    public static LocaleId Tibetan;
    public static LocaleId TibetanBhutan;
    public static LocaleId Tsonga;
    public static LocaleId Tswana;
    public static LocaleId Turkish;
    public static LocaleId Turkmen;
    public static LocaleId UighurChina;
    public static LocaleId Ukrainian;
    public static LocaleId Urdu;
    public static LocaleId UzbekCyrillic;
    public static LocaleId UzbekLatin;
    public static LocaleId Venda;
    public static LocaleId Vietnamese;
    public static LocaleId Welsh;
    public static LocaleId Xhosa;
    public static LocaleId Yi;
    public static LocaleId Yiddish;
    public static LocaleId Zulu;
}
public class JetBrains.Metadata.Utils.PE.Directories.MiscDebugInfo : DebugDataInfo {
    public MiscDebugInfo(IBinaryReader stm);
}
public abstract class JetBrains.Metadata.Utils.PE.Directories.PEDirectoryBase : object {
    public abstract virtual void Read(IBinaryReader rdr, int size, CliImage cliImage);
}
public class JetBrains.Metadata.Utils.PE.Directories.ResourceDataEntry : object {
    private int myBaseOffset;
    private int myOffsetToData;
    private int mySize;
    private int myCodepage;
    private int myReserved;
    public int OffsetToData { get; }
    public int Size { get; }
    public int Codepage { get; }
    public int Reserved { get; }
    public ResourceDataEntry(IBinaryReader reader, int baseOffset);
    [NotNullAttribute]
public IBinaryReader GetData(PEFile peFile);
    [NotNullAttribute]
public IBlob GetDataBlob(PEFile peFile);
    public int get_OffsetToData();
    public int get_Size();
    public int get_Codepage();
    public int get_Reserved();
    public void Dump(TextWriter result);
}
public class JetBrains.Metadata.Utils.PE.Directories.ResourceDirectory : object {
    public static int StructureSize;
    private int myCharacteristics;
    private ResourceDirectoryEntry[] myEntries;
    private int myMajorVersion;
    private int myMinorVersion;
    private int myNumberOfIdEntries;
    private int myNumberOfNamedEntries;
    private int myTimestamp;
    public int Characteristics { get; }
    public int Timestamp { get; }
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public int NumberOfNamedEntries { get; }
    public int NumberOfIdEntries { get; }
    [NotNullAttribute]
public ResourceDirectoryEntry[] Entries { get; }
    public ResourceDirectory(IBinaryReader reader, int baseOffset);
    public int get_Characteristics();
    public int get_Timestamp();
    public int get_MajorVersion();
    public int get_MinorVersion();
    public int get_NumberOfNamedEntries();
    public int get_NumberOfIdEntries();
    public ResourceDirectoryEntry[] get_Entries();
    public void Dump(TextWriter result);
}
public class JetBrains.Metadata.Utils.PE.Directories.ResourceDirectoryEntry : object {
    public static int StructureSize;
    private int myId;
    private string myName;
    private int myOffset;
    private ResourceDirectory myDirectory;
    private ResourceDataEntry myDataEntry;
    private UInt32 myRawName;
    private UInt32 myRawOffset;
    private ResourceDirectoryEntryNameType myNameType;
    public int Id { get; }
    [CanBeNullAttribute]
public string Name { get; }
    public int Offset { get; }
    public UInt32 RawName { get; }
    public UInt32 RawOffset { get; }
    public ResourceDirectoryEntryNameType NameType { get; }
    public ResourceDirectory Directory { get; }
    public ResourceDataEntry DataEntry { get; }
    public ResourceDirectoryEntry(IBinaryReader reader, int baseOffset);
    private static ResourceDirectoryEntry();
    public int get_Id();
    public string get_Name();
    public int get_Offset();
    public UInt32 get_RawName();
    public UInt32 get_RawOffset();
    public ResourceDirectoryEntryNameType get_NameType();
    public ResourceDirectory get_Directory();
    public ResourceDataEntry get_DataEntry();
    public void Dump(TextWriter result, bool isTopLevel, int indent);
}
public enum JetBrains.Metadata.Utils.PE.Directories.ResourceDirectoryEntryNameType : Enum {
    public int value__;
    public static ResourceDirectoryEntryNameType Id;
    public static ResourceDirectoryEntryNameType String;
}
public enum JetBrains.Metadata.Utils.PE.Directories.ResourceType : Enum {
    public int value__;
    public static ResourceType None;
    public static ResourceType Cursor;
    public static ResourceType Bitmap;
    public static ResourceType Icon;
    public static ResourceType Menu;
    public static ResourceType Dialog;
    public static ResourceType String;
    public static ResourceType FontDir;
    public static ResourceType Font;
    public static ResourceType Accelerator;
    public static ResourceType RcData;
    public static ResourceType MessageTable;
    public static ResourceType GroupCursor;
    public static ResourceType GroupIcon;
    public static ResourceType Version;
    public static ResourceType DlgInclude;
    public static ResourceType PlugPlay;
    public static ResourceType VxD;
    public static ResourceType AniCursor;
    public static ResourceType AniIcon;
    public static ResourceType Html;
    public static ResourceType Manifest;
    public static ResourceType DlgInit;
    public static ResourceType Toolbar;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Utils.PE.DllCharacteristics : Enum {
    public ushort value__;
    public static DllCharacteristics HighEntropyVa;
    public static DllCharacteristics DynamicBase;
    public static DllCharacteristics ForceIntegrity;
    public static DllCharacteristics NxCompat;
    public static DllCharacteristics NoIsolation;
    public static DllCharacteristics NoSeh;
    public static DllCharacteristics NoBind;
    public static DllCharacteristics Appcontainer;
    public static DllCharacteristics WdmDriver;
    public static DllCharacteristics GuardCf;
    public static DllCharacteristics TerminalServerAware;
}
public class JetBrains.Metadata.Utils.PE.DosHeader : object {
    public static ushort MarkZbikowskiSignature;
    private ushort myMagic;
    private ushort myCblp;
    private ushort myCp;
    private ushort myCrlc;
    private ushort myCparHdr;
    private ushort myMinAlloc;
    private ushort myMaxAlloc;
    private ushort mySs;
    private ushort mySp;
    private ushort myCSum;
    private ushort myIp;
    private ushort myCs;
    private ushort myLfaRlc;
    private ushort myOvNo;
    private UInt16[] myRes;
    private ushort myOemId;
    private ushort myOemInfo;
    private UInt16[] myRes2;
    private UInt32 myLfaNew;
    public ushort Magic { get; }
    public bool IsMagicValid { get; }
    public ushort Cblp { get; }
    public ushort Cp { get; }
    public ushort Crlc { get; }
    public ushort CparHdr { get; }
    public ushort MinAlloc { get; }
    public ushort MaxAlloc { get; }
    public ushort Ss { get; }
    public ushort Sp { get; }
    public ushort CSum { get; }
    public ushort Ip { get; }
    public ushort Cs { get; }
    public ushort LfaRlc { get; }
    public ushort OvNo { get; }
    public UInt16[] Res { get; }
    public ushort OemId { get; }
    public ushort OemInfo { get; }
    public UInt16[] Res2 { get; }
    public UInt32 LfaNew { get; }
    public DosHeader(IBinaryReader reader);
    private static DosHeader();
    public ushort get_Magic();
    public bool get_IsMagicValid();
    public ushort get_Cblp();
    public ushort get_Cp();
    public ushort get_Crlc();
    public ushort get_CparHdr();
    public ushort get_MinAlloc();
    public ushort get_MaxAlloc();
    public ushort get_Ss();
    public ushort get_Sp();
    public ushort get_CSum();
    public ushort get_Ip();
    public ushort get_Cs();
    public ushort get_LfaRlc();
    public ushort get_OvNo();
    public UInt16[] get_Res();
    public ushort get_OemId();
    public ushort get_OemInfo();
    public UInt16[] get_Res2();
    public UInt32 get_LfaNew();
}
public enum JetBrains.Metadata.Utils.PE.EditAndContinueOperation : Enum {
    public int value__;
    public static EditAndContinueOperation Default;
    public static EditAndContinueOperation AddMethod;
    public static EditAndContinueOperation AddField;
    public static EditAndContinueOperation AddParameter;
    public static EditAndContinueOperation AddProperty;
    public static EditAndContinueOperation AddEvent;
}
public enum JetBrains.Metadata.Utils.PE.ExeSignature : Enum {
    public ushort value__;
    public static ExeSignature UNKNOWN;
    public static ExeSignature DOS;
    public static ExeSignature OS2;
    public static ExeSignature OS2_LE;
    public static ExeSignature VXD;
    public static ExeSignature NT;
    public static ExeSignature NT2;
}
public class JetBrains.Metadata.Utils.PE.ImageId : ValueType {
    [CompilerGeneratedAttribute]
private int <ImageChecksum>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeDateStamp>k__BackingField;
    public int ImageChecksum { get; public set; }
    public int TimeDateStamp { get; public set; }
    public ImageId(int ImageChecksum, int TimeDateStamp);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ImageChecksum();
    [CompilerGeneratedAttribute]
public void set_ImageChecksum(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_TimeDateStamp();
    [CompilerGeneratedAttribute]
public void set_TimeDateStamp(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ImageId left, ImageId right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ImageId left, ImageId right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ImageId other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Int32& ImageChecksum, Int32& TimeDateStamp);
}
public class JetBrains.Metadata.Utils.PE.MetadataHeader : object {
    public static int SIGNATURE;
    public static int SignatureSize;
    private ushort myFlags;
    private UInt32 myReserved;
    private UInt32 mySignature;
    private StreamHeader[] myStreams;
    private ushort myVersionMajor;
    private ushort myVersionMinor;
    private int myVersionStringLength;
    private string myVersionString;
    public UInt32 Signature { get; }
    public ushort MajorVersion { get; }
    public ushort MinorVersion { get; }
    public UInt32 Reserved { get; }
    public string VersionString { get; }
    public int VersionStringLength { get; }
    public ushort Flags { get; }
    public ushort NumberOfStreams { get; }
    public StreamHeader[] StreamHeaders { get; }
    public MetadataHeader(IBinaryReader reader);
    public UInt32 get_Signature();
    public ushort get_MajorVersion();
    public ushort get_MinorVersion();
    public UInt32 get_Reserved();
    public string get_VersionString();
    public int get_VersionStringLength();
    public ushort get_Flags();
    public ushort get_NumberOfStreams();
    public StreamHeader[] get_StreamHeaders();
}
public class JetBrains.Metadata.Utils.PE.MetadataReaderException : Exception {
    public MetadataReaderException(string message);
    public MetadataReaderException(string message, Exception innerException);
    protected MetadataReaderException(SerializationInfo info, StreamingContext context);
}
public enum JetBrains.Metadata.Utils.PE.NativeImageType : Enum {
    public int value__;
    public static NativeImageType None;
    public static NativeImageType NGen;
    public static NativeImageType ReadyToRun;
}
public enum JetBrains.Metadata.Utils.PE.OptHeaderSize : Enum {
    public ushort value__;
    public static OptHeaderSize IMAGE_SIZEOF_ROM_OPTIONAL_HEADER;
    public static OptHeaderSize IMAGE_SIZEOF_STD_OPTIONAL_HEADER;
    public static OptHeaderSize IMAGE_SIZEOF_NT_OPTIONAL32_HEADER;
    public static OptHeaderSize IMAGE_SIZEOF_NT_OPTIONAL64_HEADER;
}
public class JetBrains.Metadata.Utils.PE.OptionalNtHeader32 : OptionalNtHeaderBase {
    private UInt32 mySizeOfHeapCommit;
    private UInt32 mySizeOfHeapReserve;
    private UInt32 mySizeOfStackCommit;
    private UInt32 mySizeOfStackReserve;
    private UInt32 myBaseOfData;
    private UInt32 myImageBase;
    public UInt32 BaseOfData { get; }
    public UInt32 ImageBase { get; }
    public UInt32 SizeOfStackReserve { get; }
    public UInt32 SizeOfStackCommit { get; }
    public UInt32 SizeOfHeapReserve { get; }
    public UInt32 SizeOfHeapCommit { get; }
    public OptionalNtHeader32(IBinaryReader reader);
    public UInt32 get_BaseOfData();
    public UInt32 get_ImageBase();
    public UInt32 get_SizeOfStackReserve();
    public UInt32 get_SizeOfStackCommit();
    public UInt32 get_SizeOfHeapReserve();
    public UInt32 get_SizeOfHeapCommit();
    protected virtual void ReadImageBase(IBinaryReader reader);
    protected virtual void ReadStackHeapSizes(IBinaryReader reader);
}
public class JetBrains.Metadata.Utils.PE.OptionalNtHeader64 : OptionalNtHeaderBase {
    private ulong mySizeOfHeapCommit;
    private ulong mySizeOfHeapReserve;
    private ulong mySizeOfStackCommit;
    private ulong mySizeOfStackReserve;
    private ulong myImageBase;
    public ulong ImageBase { get; }
    public ulong SizeOfStackReserve { get; }
    public ulong SizeOfStackCommit { get; }
    public ulong SizeOfHeapReserve { get; }
    public ulong SizeOfHeapCommit { get; }
    public OptionalNtHeader64(IBinaryReader reader);
    public ulong get_ImageBase();
    public ulong get_SizeOfStackReserve();
    public ulong get_SizeOfStackCommit();
    public ulong get_SizeOfHeapReserve();
    public ulong get_SizeOfHeapCommit();
    protected virtual void ReadImageBase(IBinaryReader reader);
    protected virtual void ReadStackHeapSizes(IBinaryReader reader);
}
public abstract class JetBrains.Metadata.Utils.PE.OptionalNtHeaderBase : object {
    private UInt32 myNumberOfRvaAndSizes;
    private DllCharacteristics myDllCharacteristics;
    private UInt32 myFileAlignment;
    private UInt32 myCheckSum;
    private UInt32 mySizeOfHeaders;
    private UInt32 mySizeOfImage;
    private ushort myImageVersionMajor;
    private ushort myImageVersionMinor;
    private UInt32 myLoaderFlags;
    private ushort myOsVersionMajor;
    private ushort myOsVersionMinor;
    private UInt32 myWin32VersionValue;
    private UInt32 mySectionAlignment;
    private Subsystem mySubsystem;
    private ushort mySubsysVersionMajor;
    private ushort mySubsysVersionMinor;
    public UInt32 SectionAlignment { get; }
    public UInt32 FileAlignment { get; }
    public ushort MajorOperatingSystemVersion { get; }
    public ushort MinorOperatingSystemVersion { get; }
    public ushort MajorImageVersion { get; }
    public ushort MinorImageVersion { get; }
    public ushort MajorSubsystemVersion { get; }
    public ushort MinorSubsystemVersion { get; }
    public UInt32 Win32VersionValue { get; }
    public UInt32 SizeOfImage { get; }
    public UInt32 SizeOfHeaders { get; }
    public UInt32 CheckSum { get; }
    public Subsystem Subsystem { get; }
    public DllCharacteristics DllCharacteristics { get; }
    public UInt32 LoaderFlags { get; }
    public UInt32 NumberOfRvaAndSizes { get; }
    protected OptionalNtHeaderBase(IBinaryReader reader);
    public UInt32 get_SectionAlignment();
    public UInt32 get_FileAlignment();
    public ushort get_MajorOperatingSystemVersion();
    public ushort get_MinorOperatingSystemVersion();
    public ushort get_MajorImageVersion();
    public ushort get_MinorImageVersion();
    public ushort get_MajorSubsystemVersion();
    public ushort get_MinorSubsystemVersion();
    public UInt32 get_Win32VersionValue();
    public UInt32 get_SizeOfImage();
    public UInt32 get_SizeOfHeaders();
    public UInt32 get_CheckSum();
    public Subsystem get_Subsystem();
    public DllCharacteristics get_DllCharacteristics();
    public UInt32 get_LoaderFlags();
    public UInt32 get_NumberOfRvaAndSizes();
    protected abstract virtual void ReadImageBase(IBinaryReader reader);
    protected abstract virtual void ReadStackHeapSizes(IBinaryReader reader);
}
public class JetBrains.Metadata.Utils.PE.PdbChecksum : object {
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Checksum>k__BackingField;
    [NotNullAttribute]
public string Algorithm { get; }
    [NotNullAttribute]
public Byte[] Checksum { get; }
    public PdbChecksum(string algorithm, Byte[] checksum);
    [CompilerGeneratedAttribute]
public string get_Algorithm();
    [CompilerGeneratedAttribute]
public Byte[] get_Checksum();
}
public enum JetBrains.Metadata.Utils.PE.PeDirectoryEntry : Enum {
    public int value__;
    public static PeDirectoryEntry Export;
    public static PeDirectoryEntry Import;
    public static PeDirectoryEntry Resource;
    public static PeDirectoryEntry Exception;
    public static PeDirectoryEntry Security;
    public static PeDirectoryEntry BaseReloc;
    public static PeDirectoryEntry Debug;
    public static PeDirectoryEntry Architecture;
    public static PeDirectoryEntry GlobalPtr;
    public static PeDirectoryEntry Tls;
    public static PeDirectoryEntry LoadConfig;
    public static PeDirectoryEntry BoundImport;
    public static PeDirectoryEntry ImportAddressTable;
    public static PeDirectoryEntry DelayImport;
    public static PeDirectoryEntry ComDescriptor;
    public static PeDirectoryEntry Unknown;
}
public class JetBrains.Metadata.Utils.PE.PEFile : CliImage {
    private CoffHeader myCOFFHeader;
    private DataDirectory[] myDirs;
    private DosHeader myDosHeader;
    private OptionalNtHeaderBase myNTHeader;
    private PEHeader myPEHeader;
    public int EndOffset;
    [CompilerGeneratedAttribute]
private ReadyToRunHeader <ReadyToRunHeader>k__BackingField;
    public int Offset { get; }
    public DosHeader DOSheader { get; }
    public CoffHeader COFFheader { get; }
    public PEHeader PEHeader { get; }
    public OptionalNtHeaderBase NTHeader { get; }
    public DataDirectory[] Entries { get; }
    [CanBeNullAttribute]
public ReadyToRunHeader ReadyToRunHeader { get; }
    public bool IsValid { get; }
    public NativeImageType NativeImageType { get; }
    public PEFile(IBinaryReader reader);
    public virtual int get_Offset();
    public DosHeader get_DOSheader();
    public CoffHeader get_COFFheader();
    public PEHeader get_PEHeader();
    public OptionalNtHeaderBase get_NTHeader();
    public DataDirectory[] get_Entries();
    public virtual DataDirectory GetDataDirectoryEntry(PeDirectoryEntry directoryId);
    [CompilerGeneratedAttribute]
public ReadyToRunHeader get_ReadyToRunHeader();
    public bool get_IsValid();
    private UInt32 GetReadyToRunHeaderRva();
    public NativeImageType get_NativeImageType();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.PE.PEFileEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<DebugInfo> GetDebugInfos(CliImage cliImage);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use PEFileEx.GetDebugInfos instead")]
public static IList`1<DebugInfo7> GetDebugInfos7(CliImage cliImage);
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<PdbChecksum> GetChecksums(CliImage cliImage);
    private static IEnumerable`1<Entry> DebugEntries(CliImage cliImage);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static Byte[] GetDecompressedEmbeddedPortablePdb(CliImage cliImage);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static EntireResourceDirectory GetResources(PEFile peFile);
    [ExtensionAttribute]
public static MetadataToken GetEntryPoint(CliImage cliImage);
    public static CliImage ReadCliImage(IBinaryReader reader);
    public static Nullable`1<ImageId> GetImageId(IAssemblyLocation assemblyLocation);
}
public class JetBrains.Metadata.Utils.PE.PEHeader : object {
    private UInt32 myBaseOfCode;
    private UInt32 mySizeOfCode;
    private UInt32 myAddressOfEntryPoint;
    private UInt32 mySizeOfInitializedData;
    private byte myLinkerVersionMinor;
    private byte myLinkVersionMajor;
    private PESignature myMagic;
    private UInt32 mySizeOfUninitializedData;
    public PESignature Magic { get; }
    public byte MajorLinkerVersion { get; }
    public byte MinorLinkerVersion { get; }
    public UInt32 SizeOfCode { get; }
    public UInt32 SizeOfInitializedData { get; }
    public UInt32 SizeOfUninitializedData { get; }
    public UInt32 AddressOfEntryPoint { get; }
    public UInt32 BaseOfCode { get; }
    public PEHeader(IBinaryReader reader);
    public PESignature get_Magic();
    public byte get_MajorLinkerVersion();
    public byte get_MinorLinkerVersion();
    public UInt32 get_SizeOfCode();
    public UInt32 get_SizeOfInitializedData();
    public UInt32 get_SizeOfUninitializedData();
    public UInt32 get_AddressOfEntryPoint();
    public UInt32 get_BaseOfCode();
}
public enum JetBrains.Metadata.Utils.PE.PESignature : Enum {
    public ushort value__;
    public static PESignature PE_32BIT;
    public static PESignature PE_64BIT;
    public static PESignature PE_ROM;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Utils.PE.SectionCharacteristics : Enum {
    public UInt32 value__;
    public static SectionCharacteristics TypeDsect;
    public static SectionCharacteristics TypeNoload;
    public static SectionCharacteristics TypeGroup;
    public static SectionCharacteristics TypeNoPad;
    public static SectionCharacteristics TypeCopy;
    public static SectionCharacteristics CntCode;
    public static SectionCharacteristics CntInitializedData;
    public static SectionCharacteristics CntUninitializedData;
    public static SectionCharacteristics LnkOther;
    public static SectionCharacteristics LnkInfo;
    public static SectionCharacteristics TypeOver;
    public static SectionCharacteristics LnkRemove;
    public static SectionCharacteristics LnkComdat;
    public static SectionCharacteristics NoDeferSpecExc;
    public static SectionCharacteristics Gprel;
    public static SectionCharacteristics MemPurgeable;
    public static SectionCharacteristics Mem16Bit;
    public static SectionCharacteristics MemLocked;
    public static SectionCharacteristics MemPreload;
    public static SectionCharacteristics AlignMask;
    public static SectionCharacteristics AlignDefault;
    public static SectionCharacteristics AlignReserved;
    public static SectionCharacteristics Align1Bytes;
    public static SectionCharacteristics Align2Bytes;
    public static SectionCharacteristics Align4Bytes;
    public static SectionCharacteristics Align8Bytes;
    public static SectionCharacteristics Align16Bytes;
    public static SectionCharacteristics Align32Bytes;
    public static SectionCharacteristics Align64Bytes;
    public static SectionCharacteristics Align128Bytes;
    public static SectionCharacteristics Align256Bytes;
    public static SectionCharacteristics Align512Bytes;
    public static SectionCharacteristics Align1024Bytes;
    public static SectionCharacteristics Align2048Bytes;
    public static SectionCharacteristics Align4096Bytes;
    public static SectionCharacteristics Align8192Bytes;
    public static SectionCharacteristics LnkNrelocOvfl;
    public static SectionCharacteristics MemDiscardable;
    public static SectionCharacteristics MemNotCached;
    public static SectionCharacteristics MemNotPaged;
    public static SectionCharacteristics MemShared;
    public static SectionCharacteristics MemExecute;
    public static SectionCharacteristics MemRead;
    public static SectionCharacteristics MemWrite;
}
[DebuggerDisplayAttribute("Start={VirtualAddress} Size={VirtualSize}")]
public class JetBrains.Metadata.Utils.PE.SectionHeader : SectionHeaderBase {
    private static int NameSize;
    public static int Size;
    [CompilerGeneratedAttribute]
private int <PointerToRelocations>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PointerToLineNumbers>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NumberOfRelocations>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NumberOfLineNumbers>k__BackingField;
    [CompilerGeneratedAttribute]
private SectionCharacteristics <Characteristics>k__BackingField;
    public int PointerToRelocations { get; }
    public int PointerToLineNumbers { get; }
    public ushort NumberOfRelocations { get; }
    public ushort NumberOfLineNumbers { get; }
    public SectionCharacteristics Characteristics { get; }
    public SectionHeader(IBinaryReader reader);
    [CompilerGeneratedAttribute]
public int get_PointerToRelocations();
    [CompilerGeneratedAttribute]
public int get_PointerToLineNumbers();
    [CompilerGeneratedAttribute]
public ushort get_NumberOfRelocations();
    [CompilerGeneratedAttribute]
public ushort get_NumberOfLineNumbers();
    [CompilerGeneratedAttribute]
public SectionCharacteristics get_Characteristics();
}
public class JetBrains.Metadata.Utils.PE.SectionHeaderBase : object {
    [CompilerGeneratedAttribute]
private int <VirtualSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VirtualAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SizeOfRawData>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PointerToRawData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int VirtualSize { get; }
    public int VirtualAddress { get; }
    public int SizeOfRawData { get; }
    public int PointerToRawData { get; }
    public string Name { get; }
    protected SectionHeaderBase(string name, int virtualSize, int virtualAddress, int sizeOfRawData, int pointerToRawData);
    [CompilerGeneratedAttribute]
public int get_VirtualSize();
    [CompilerGeneratedAttribute]
public int get_VirtualAddress();
    [CompilerGeneratedAttribute]
public int get_SizeOfRawData();
    [CompilerGeneratedAttribute]
public int get_PointerToRawData();
    [CompilerGeneratedAttribute]
public string get_Name();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Metadata.Utils.PE.SectionHeaderTable : DictionaryBase {
    public SectionHeader Item { get; }
    public SectionHeader get_Item(string name);
    internal void AddSection(SectionHeader hdr);
}
public class JetBrains.Metadata.Utils.PE.StreamHeader : object {
    private string myName;
    private int myAlignedNameLength;
    private int myOffset;
    private int mySize;
    public int Offset { get; }
    public int Size { get; }
    public string Name { get; }
    public int StreamHeaderSize { get; }
    public int AlignedNameLength { get; }
    public StreamHeader(IBinaryReader reader);
    public int get_Offset();
    public int get_Size();
    public string get_Name();
    public int get_StreamHeaderSize();
    public int get_AlignedNameLength();
}
public enum JetBrains.Metadata.Utils.PE.Subsystem : Enum {
    public ushort value__;
    public static Subsystem UNKNOWN;
    public static Subsystem NATIVE;
    public static Subsystem WINDOWS_GUI;
    public static Subsystem WINDOWS_CUI;
    public static Subsystem OS2_CUI;
    public static Subsystem POSIX_CUI;
    public static Subsystem NATIVE_WINDOWS;
    public static Subsystem WINDOWS_CE_GUI;
    public static Subsystem EFI_APPLICATION;
    public static Subsystem EFI_BOOT_SERVICE_DRIVER;
    public static Subsystem EFI_RUNTIME_DRIVER;
    public static Subsystem EFI_ROM;
    public static Subsystem XBOX;
    public static Subsystem WINDOWS_BOOT_APPLICATION;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.PE.UserStrings : object {
    public static int UserStringHeapId;
    [ExtensionAttribute]
public static bool IsUserString(MetadataToken token);
    public static MetadataToken CreateUserStringToken(int offset);
}
public class JetBrains.Metadata.Utils.PredefinedAssembliesAssemblyLoader : object {
    [CanBeNullAttribute]
private List`1<AssemblyNameAndLocation> myKnownAssemblies;
    [NotNullAttribute]
protected Dictionary`2<AssemblyNameAndLocation, Assembly> myLoadedAssemblies;
    public PredefinedAssembliesAssemblyLoader(IEnumerable`1<AssemblyNameAndLocation> predefinedAssemblies);
    private sealed virtual override Assembly JetBrains.Metadata.Utils.IAssemblyLoader.GetAssemblyByName(string fullAssemblyName);
    protected virtual AssemblyNameAndLocation GetKnownAssemblyAndLocationByName(string assemblyName);
    [CanBeNullAttribute]
public Assembly Load(string assemblyName);
    private static bool Matches(AssemblyNameInfo knownAssemblyName, AssemblyNameInfo lookingAssemblyName);
    public static PredefinedAssembliesAssemblyLoader DirectoryLoader(VirtualFileSystemPath assembliesLocation);
    [CanBeNullAttribute]
public string AddKnownAssembly(VirtualFileSystemPath assemblyPath);
}
public class JetBrains.Metadata.Utils.ReadyToRun.CompilerIdentifierSection : StringSection {
    public CompilerIdentifierSection(ReadyToRunSectionType type, DataDirectory dataDirectory);
}
public class JetBrains.Metadata.Utils.ReadyToRun.ImportSectionsSection : ReadyToRunSection {
    public ImportSectionsSection(ReadyToRunSectionType type, DataDirectory dataDirectory);
    protected virtual void ReadContent(IBinaryReader reader, PEFile peFile, int size);
}
public class JetBrains.Metadata.Utils.ReadyToRun.ReadyToRunCoreHeader : object {
    public static int OffsetToSections;
    [CompilerGeneratedAttribute]
private ReadyToRunFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <NumberOfSections>k__BackingField;
    [NotNullAttribute]
private Lazy`1<IReadOnlyList`1<ReadyToRunSection>> mySections;
    public ReadyToRunFlags Flags { get; }
    public UInt32 NumberOfSections { get; }
    [NotNullAttribute]
public IReadOnlyList`1<ReadyToRunSection> Sections { get; }
    public ReadyToRunCoreHeader(IBinaryReader reader, PEFile peFile);
    [CompilerGeneratedAttribute]
public ReadyToRunFlags get_Flags();
    [CompilerGeneratedAttribute]
public UInt32 get_NumberOfSections();
    public IReadOnlyList`1<ReadyToRunSection> get_Sections();
}
public class JetBrains.Metadata.Utils.ReadyToRun.ReadyToRunFixup : object {
    public int Offset;
    public ReadyToRunFixupKind FixupKind;
}
public enum JetBrains.Metadata.Utils.ReadyToRun.ReadyToRunFixupKind : Enum {
    public int value__;
    public static ReadyToRunFixupKind Invalid;
    public static ReadyToRunFixupKind ThisObjDictionaryLookup;
    public static ReadyToRunFixupKind TypeDictionaryLookup;
    public static ReadyToRunFixupKind MethodDictionaryLookup;
    public static ReadyToRunFixupKind TypeHandle;
    public static ReadyToRunFixupKind MethodHandle;
    public static ReadyToRunFixupKind FieldHandle;
    public static ReadyToRunFixupKind MethodEntry;
    public static ReadyToRunFixupKind MethodEntry_DefToken;
    public static ReadyToRunFixupKind MethodEntry_RefToken;
    public static ReadyToRunFixupKind VirtualEntry;
    public static ReadyToRunFixupKind VirtualEntry_DefToken;
    public static ReadyToRunFixupKind VirtualEntry_RefToken;
    public static ReadyToRunFixupKind VirtualEntry_Slot;
    public static ReadyToRunFixupKind Helper;
    public static ReadyToRunFixupKind StringHandle;
    public static ReadyToRunFixupKind NewObject;
    public static ReadyToRunFixupKind NewArray;
    public static ReadyToRunFixupKind IsInstanceOf;
    public static ReadyToRunFixupKind ChkCast;
    public static ReadyToRunFixupKind FieldAddress;
    public static ReadyToRunFixupKind CctorTrigger;
    public static ReadyToRunFixupKind StaticBaseNonGC;
    public static ReadyToRunFixupKind StaticBaseGC;
    public static ReadyToRunFixupKind ThreadStaticBaseNonGC;
    public static ReadyToRunFixupKind ThreadStaticBaseGC;
    public static ReadyToRunFixupKind FieldBaseOffset;
    public static ReadyToRunFixupKind FieldOffset;
    public static ReadyToRunFixupKind TypeDictionary;
    public static ReadyToRunFixupKind MethodDictionary;
    public static ReadyToRunFixupKind Check_TypeLayout;
    public static ReadyToRunFixupKind Check_FieldOffset;
    public static ReadyToRunFixupKind DelegateCtor;
    public static ReadyToRunFixupKind DeclaringTypeHandle;
    public static ReadyToRunFixupKind IndirectPInvokeTarget;
    public static ReadyToRunFixupKind PInvokeTarget;
    public static ReadyToRunFixupKind Check_InstructionSetSupport;
    public static ReadyToRunFixupKind Verify_FieldOffset;
    public static ReadyToRunFixupKind Verify_TypeLayout;
    public static ReadyToRunFixupKind Check_VirtualFunctionOverride;
    public static ReadyToRunFixupKind Verify_VirtualFunctionOverride;
    public static ReadyToRunFixupKind ModuleOverride;
}
public enum JetBrains.Metadata.Utils.ReadyToRun.ReadyToRunFlags : Enum {
    public UInt32 value__;
    public static ReadyToRunFlags PLATFORM_NEUTRAL_SOURCE;
    public static ReadyToRunFlags SKIP_TYPE_VALIDATION;
    public static ReadyToRunFlags PARTIAL;
    public static ReadyToRunFlags NONSHARED_PINVOKE_STUBS;
    public static ReadyToRunFlags EMBEDDED_MSIL;
    public static ReadyToRunFlags COMPONENT;
}
public class JetBrains.Metadata.Utils.ReadyToRun.ReadyToRunHeader : object {
    public static UInt32 ReadyToRunSignature;
    public static int OffsetToCoreHeader;
    [CompilerGeneratedAttribute]
private UInt32 <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadyToRunCoreHeader <CoreHeader>k__BackingField;
    public UInt32 Signature { get; }
    public ushort MajorVersion { get; }
    public ushort MinorVersion { get; }
    [NotNullAttribute]
public ReadyToRunCoreHeader CoreHeader { get; }
    public ReadyToRunHeader(IBinaryReader reader, PEFile peFile);
    [CompilerGeneratedAttribute]
public UInt32 get_Signature();
    [CompilerGeneratedAttribute]
public ushort get_MajorVersion();
    [CompilerGeneratedAttribute]
public ushort get_MinorVersion();
    [CompilerGeneratedAttribute]
public ReadyToRunCoreHeader get_CoreHeader();
}
public class JetBrains.Metadata.Utils.ReadyToRun.ReadyToRunImportSectionEntry : object {
}
public enum JetBrains.Metadata.Utils.ReadyToRun.ReadyToRunInstructionSet : Enum {
    public int value__;
    public static ReadyToRunInstructionSet Sse;
    public static ReadyToRunInstructionSet Sse2;
    public static ReadyToRunInstructionSet Sse3;
    public static ReadyToRunInstructionSet Ssse3;
    public static ReadyToRunInstructionSet Sse41;
    public static ReadyToRunInstructionSet Sse42;
    public static ReadyToRunInstructionSet Avx;
    public static ReadyToRunInstructionSet Avx2;
    public static ReadyToRunInstructionSet Aes;
    public static ReadyToRunInstructionSet Bmi1;
    public static ReadyToRunInstructionSet Bmi2;
    public static ReadyToRunInstructionSet Fma;
    public static ReadyToRunInstructionSet Lzcnt;
    public static ReadyToRunInstructionSet Pclmulqdq;
    public static ReadyToRunInstructionSet Popcnt;
    public static ReadyToRunInstructionSet ArmBase;
    public static ReadyToRunInstructionSet AdvSimd;
    public static ReadyToRunInstructionSet Crc32;
    public static ReadyToRunInstructionSet Sha1;
    public static ReadyToRunInstructionSet Sha256;
    public static ReadyToRunInstructionSet Atomics;
    public static ReadyToRunInstructionSet X86Base;
    public static ReadyToRunInstructionSet Dp;
    public static ReadyToRunInstructionSet Rdm;
    public static ReadyToRunInstructionSet AvxVnni;
}
public class JetBrains.Metadata.Utils.ReadyToRun.ReadyToRunSection : object {
    public static int Size;
    [CompilerGeneratedAttribute]
private ReadyToRunSectionType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private DataDirectory <DataDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public ReadyToRunSectionType Type { get; }
    public DataDirectory DataDirectory { get; }
    public string Value { get; protected set; }
    public ReadyToRunSection(ReadyToRunSectionType type, DataDirectory dataDirectory);
    [CompilerGeneratedAttribute]
public ReadyToRunSectionType get_Type();
    [CompilerGeneratedAttribute]
public DataDirectory get_DataDirectory();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
protected void set_Value(string value);
    protected virtual void ReadContent(IBinaryReader reader, PEFile peFile, int size);
    public static ReadyToRunSection Read(IBinaryReader reader, PEFile peFile);
    public static void ReadContent(ReadyToRunSection section, IBinaryReader reader, PEFile peFile);
    private static ReadyToRunSection CreateSection(ReadyToRunSectionType type, DataDirectory directory);
    public UInt32 ReadUInt(IBinaryReader reader);
}
public enum JetBrains.Metadata.Utils.ReadyToRun.ReadyToRunSectionType : Enum {
    public UInt32 value__;
    public static ReadyToRunSectionType CompilerIdentifier;
    public static ReadyToRunSectionType ImportSections;
    public static ReadyToRunSectionType RuntimeFunctions;
    public static ReadyToRunSectionType MethodDefEntryPoints;
    public static ReadyToRunSectionType ExceptionInfo;
    public static ReadyToRunSectionType DebugInfo;
    public static ReadyToRunSectionType DelayLoadMethodCallThunks;
    public static ReadyToRunSectionType AvailableTypes_Old;
    public static ReadyToRunSectionType AvailableTypes;
    public static ReadyToRunSectionType InstanceMethodEntryPoints;
    public static ReadyToRunSectionType InliningInfo;
    public static ReadyToRunSectionType ProfileDataInfo;
    public static ReadyToRunSectionType ManifestMetadata;
    public static ReadyToRunSectionType AttributePresence;
    public static ReadyToRunSectionType InliningInfo2;
    public static ReadyToRunSectionType ComponentAssemblies;
    public static ReadyToRunSectionType OwnerCompositeExecutable;
    public static ReadyToRunSectionType PgoInstrumentationData;
    public static ReadyToRunSectionType ManifestAssemblyMvids;
}
public class JetBrains.Metadata.Utils.ReadyToRun.ReadyToRunSignature : object {
    [CompilerGeneratedAttribute]
private ReadyToRunFixupKind <FixupKind>k__BackingField;
    public ReadyToRunFixupKind FixupKind { get; public set; }
    [CompilerGeneratedAttribute]
public ReadyToRunFixupKind get_FixupKind();
    [CompilerGeneratedAttribute]
public void set_FixupKind(ReadyToRunFixupKind value);
}
public class JetBrains.Metadata.Utils.ReadyToRun.StringSection : ReadyToRunSection {
    public StringSection(ReadyToRunSectionType type, DataDirectory dataDirectory);
    protected virtual void ReadContent(IBinaryReader reader, PEFile peFile, int size);
}
[FlagsAttribute]
public enum JetBrains.Metadata.Utils.SdkAppliesTo : Enum {
    public int value__;
    public static SdkAppliesTo WindowsAppContainer;
    public static SdkAppliesTo VisualC;
    public static SdkAppliesTo VB;
    public static SdkAppliesTo CSharp;
    public static SdkAppliesTo WindowsXAML;
    public static SdkAppliesTo JavaScript;
    public static SdkAppliesTo Managed;
    public static SdkAppliesTo Native;
    public static SdkAppliesTo Undefined;
}
public class JetBrains.Metadata.Utils.SdkModuleInfo : object {
    private string myIdentity;
    private string myVersion;
    private bool myIsPlatformSdk;
    private SdkAppliesTo myAppliesTo;
    private VirtualFileSystemPath myManifestPath;
    private ICollection`1<VirtualFileSystemPath> myNestedAssemblies;
    private JetHashSet`1<VirtualFileSystemPath> myContentFiles;
    private JetHashSet`1<VirtualFileSystemPath> myHierarchyItems;
    private string mySdkName;
    private VirtualFileSystemPath myRootFolderForContentFiles;
    private List`1<string> mySdkDependencies;
    public string Identity { get; }
    public VirtualFileSystemPath ManifestPath { get; }
    public ICollection`1<VirtualFileSystemPath> NestedAssemblies { get; }
    [CanBeNullAttribute]
public VirtualFileSystemPath RootFolderForContentFiles { get; }
    public JetHashSet`1<VirtualFileSystemPath> ContentFiles { get; }
    public JetHashSet`1<VirtualFileSystemPath> HierarchyItems { get; }
    public string SdkName { get; }
    public string Version { get; }
    public bool IsPlatformSdk { get; }
    public List`1<string> SdkDependencies { get; }
    public SdkAppliesTo AppliesTo { get; }
    public SdkModuleInfo(string sdkName, VirtualFileSystemPath sdkManifestPath, VirtualFileSystemPath contentRootPath, string identity, string version, bool isPlatformSdk, SdkAppliesTo appliesTo);
    public string get_Identity();
    public VirtualFileSystemPath get_ManifestPath();
    public ICollection`1<VirtualFileSystemPath> get_NestedAssemblies();
    public VirtualFileSystemPath get_RootFolderForContentFiles();
    public JetHashSet`1<VirtualFileSystemPath> get_ContentFiles();
    public JetHashSet`1<VirtualFileSystemPath> get_HierarchyItems();
    public string get_SdkName();
    public string get_Version();
    public bool get_IsPlatformSdk();
    public List`1<string> get_SdkDependencies();
    public SdkAppliesTo get_AppliesTo();
    public void AddContentItem(VirtualFileSystemPath absoluteFilePath);
    public void TryAddNestedAssembly(VirtualFileSystemPath absoluteFilePath);
    public void DumpShort(TextWriter to);
    public void RetriveAdditionalInfo(XmlElement fileListElement);
    public void DumpFull(TextWriter to);
}
public class JetBrains.Metadata.Utils.StreamBinaryReader : object {
    private static int InternalBufferSize;
    [NotNullAttribute]
private Stream myStream;
    private int myBufSizePositionInStream;
    [NotNullAttribute]
private Byte[] myBuf;
    private int myBufPos;
    private int myBufSize;
    public int Position { get; public set; }
    public int Length { get; }
    public StreamBinaryReader(Stream stream);
    public StreamBinaryReader(Stream stream, int position);
    public StreamBinaryReader(Stream stream, int position, int customBufferSize);
    public sealed virtual int get_Position();
    public sealed virtual void set_Position(int value);
    public sealed virtual int get_Length();
    public sealed virtual IBinaryReader Clone();
    public sealed virtual char ReadChar();
    public sealed virtual float ReadSingle();
    public sealed virtual double ReadDouble();
    public sealed virtual short ReadInt16();
    public sealed virtual sbyte ReadSByte();
    public sealed virtual byte ReadUInt8();
    public sealed virtual ushort ReadUInt16();
    public sealed virtual int ReadInt32();
    public sealed virtual UInt32 ReadUInt32();
    public sealed virtual long ReadInt64();
    public sealed virtual ulong ReadUInt64();
    public sealed virtual void Read(Byte[] buffer, int offset, int count);
    public sealed virtual byte ReadByte();
    public sealed virtual string ReadStringUtf8();
    public sealed virtual string ReadStringUtf16le(int cbLength);
    public sealed virtual UInt32 ReadCompressedInteger();
    public sealed virtual string ReadUtf8Constant();
    public sealed virtual void Skip(int bytes);
    private void PrepareStream();
    private void FillBuffer(int bytes);
    private void FillBufferCore(int bytes);
    [ConditionalAttribute("JET_MODE_ASSERT_PARANOID")]
private void AssertValidBuffer();
}
public class JetBrains.Metadata.Utils.TargetPlatformData : object {
    private bool myIsEmpty;
    [CompilerGeneratedAttribute]
private string <TargetPlatformIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformVersion>k__BackingField;
    [NotNullAttribute]
public string TargetPlatformIdentifier { get; private set; }
    [NotNullAttribute]
public string TargetPlatformVersion { get; private set; }
    public bool IsEmpty { get; }
    public TargetPlatformData(string targetPlatformIdentifier, string targetPlatformVersion);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformIdentifier();
    [CompilerGeneratedAttribute]
private void set_TargetPlatformIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformVersion();
    [CompilerGeneratedAttribute]
private void set_TargetPlatformVersion(string value);
    public void Write(UnsafeWriter writer);
    public void Read(UnsafeReader reader);
    public bool get_IsEmpty();
    public static void WriteEmpty(UnsafeWriter writer);
}
public static class JetBrains.Metadata.Utils.ToolLocationHelper : object {
    private static string Annotated;
    private static string RedistFolder;
    private static string ReferencesFolder;
    private static string DesignTimeFolder;
    private static string DebugConfiguration;
    private static string RetailConfiguration;
    private static string CommonConfiguration;
    private static string NeutralArchitecture;
    private static string AnyCPU;
    private static string Amd64;
    private static string Msil;
    private static string X64;
    private static string X86;
    private static string ARM;
    public static string SDKManifestFileName;
    private static ToolLocationHelper();
    public static ICollection`1<VirtualFileSystemPath> GetContentRoots(VirtualFileSystemPath sdkRoot, string targetConfiguration, string targetArchitecture);
    public static ICollection`1<VirtualFileSystemPath> GetContentRootsForSpecifiedTargetPlatform(VirtualFileSystemPath sdkRoot, string targetArchitecture);
    private static IEnumerable`1<VirtualFileSystemPath> ReadFolder(string rootFolderName, string targetArchitecture, VirtualFileSystemPath sdkRootPath);
    [IteratorStateMachineAttribute("JetBrains.Metadata.Utils.ToolLocationHelper/<EnumerateContentRoots>d__17")]
public static IEnumerable`1<VirtualFileSystemPath> EnumerateContentRoots(VirtualFileSystemPath sdkRoot, string targetConfiguration, string targetArchitecture);
    [IteratorStateMachineAttribute("JetBrains.Metadata.Utils.ToolLocationHelper/<ReadFolder>d__18")]
private static IEnumerable`1<VirtualFileSystemPath> ReadFolder(string rootFolderName, string targetConfiguration, string targetArchitecture, VirtualFileSystemPath sdkRootPath);
    private static string RemapSdkArchitecture(string targetArchitecture);
    [CanBeNullAttribute]
private static VirtualFileSystemPath Combine(VirtualFileSystemPath sdkRootPath, string contentFolderName, string targetConfiguration, string targetArchitecture);
    [CanBeNullAttribute]
public static SdkModuleInfo GetSdkModuleInfo(VirtualFileSystemPath manifestPath, ICollection`1<VirtualFileSystemPath> contentRoots);
    private static bool IsRedistContentRoot(VirtualFileSystemPath contentRoot);
    private static void FillContents(IEnumerable`1<VirtualFileSystemPath> contentRoots, XmlElement fileListElement, SdkModuleInfo result, XmlDocument sdkManifestDoc);
    [CanBeNullAttribute]
private static SdkModuleInfo RetrieveSdkModuleInfo(VirtualFileSystemPath contentRoot, VirtualFileSystemPath manifestPath, XmlElement fileListElement);
    private static SdkAppliesTo ParseAppliesTo(string value);
    [NotNullAttribute]
public static VirtualFileSystemPath GetPlatformSDKPath(TargetPlatformData targetPlatformData, IInteractionContext context);
    private static string CreatePlatfromSdkIdentity(string sdkName, string sdkVersion);
    private static string CreateExtensionSdkIdentity(string sdkName, XmlElement fileListElement, String& name, String& version);
    private static void FillContentItems(VirtualFileSystemPath contentRoot, SdkModuleInfo result, string mask);
    private static void FillNestedAssemblies(VirtualFileSystemPath contentRoot, SdkModuleInfo result, bool addOnlyWinmd);
}
public class JetBrains.Metadata.Utils.TypeAnnotationsEnumerator`1 : ValueType {
    private TAnnotation mySingleAnnotation;
    [CanBeNullAttribute]
private TAnnotation[] myAnnotations;
    private int myIndex;
    public static TypeAnnotationsEnumerator`1<TAnnotation> Empty;
    public bool IsEmptyOrRepeatsSingleAnnotation { get; }
    public TAnnotation Current { get; }
    public TypeAnnotationsEnumerator`1(TAnnotation annotation, bool isRepeat);
    public TypeAnnotationsEnumerator`1(TAnnotation[] annotations, int startIndex);
    private static TypeAnnotationsEnumerator`1();
    public bool get_IsEmptyOrRepeatsSingleAnnotation();
    public bool MoveNext();
    public TAnnotation get_Current();
    public TAnnotation GetNextOrDefault(TAnnotation fallbackValue);
}
public abstract class JetBrains.Metadata.Utils.TypeName.AbstractTypeNameParser`1 : object {
    private TypeNameParserArrayRanksOrder myArrayRanksOrder;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [NotNullAttribute]
protected string TypeName { get; }
    protected AbstractTypeNameParser`1(string typeName);
    protected AbstractTypeNameParser`1(string typeName, TypeNameParserArrayRanksOrder arrayRanksOrder);
    [CompilerGeneratedAttribute]
protected string get_TypeName();
    [NotNullAttribute]
public TType Parse();
    [NotNullAttribute]
protected abstract virtual TType CreateUnresolvedType(string typeName, TextRange typeNameRange);
    [NotNullAttribute]
private TType CreatePlainType(ParsedTypeName parsed, string assemblyName, TextRange assemblyNameRange, TextRange assemblyFullNameRange);
    [NotNullAttribute]
protected abstract virtual TType CreateTypeByNameAndAssembly(string typeName, TextRange typeNameRange, string assemblyName, TextRange assemblyNameRange, TextRange assemblyFullNameRange, TType[] genericArguments);
    [NotNullAttribute]
private TType CreateQualifiedType(ParsedTypeName parsed, string assemblyName, TextRange assemblyNameRange, TextRange assemblyFullNameRange);
    [NotNullAttribute]
protected abstract virtual TType CreatePointerType(TType elementType);
    [NotNullAttribute]
protected abstract virtual TType CreateArrayType(TType elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    [NotNullAttribute]
protected abstract virtual TType CreateArrayType(TType elementType);
    [NotNullAttribute]
protected abstract virtual TType CreateReferenceType(TType elementType);
    [NotNullAttribute]
private TType CreateTypeFromParsedName(ParsedTypeName parsed);
}
public class JetBrains.Metadata.Utils.TypeName.InvalidTypeNameException : Exception {
    public InvalidTypeNameException(string message);
    public InvalidTypeNameException(string message, Exception exInner);
}
internal class JetBrains.Metadata.Utils.TypeName.NameToken : Token {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange <Range>k__BackingField;
    public string Value { get; }
    public TextRange Range { get; }
    public NameToken(string val, TextRange range);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public TextRange get_Range();
    public virtual string ToString();
}
public class JetBrains.Metadata.Utils.TypeName.ParsedTypeName : object {
    private string myFullName;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange <NameRange>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVector>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Rank>k__BackingField;
    [CompilerGeneratedAttribute]
private ParsedTypeName <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ParsedTypeName> <GenericArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange <AssemblyNameRange>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyFullName>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange <AssemblyFullNameRange>k__BackingField;
    public string Name { get; }
    public TextRange NameRange { get; }
    public bool IsPointer { get; internal set; }
    public bool IsReference { get; internal set; }
    public bool IsArray { get; internal set; }
    public bool IsVector { get; internal set; }
    public UInt32 Rank { get; internal set; }
    public ParsedTypeName ElementType { get; internal set; }
    public List`1<ParsedTypeName> GenericArgs { get; }
    public string AssemblyName { get; internal set; }
    public TextRange AssemblyNameRange { get; internal set; }
    public string AssemblyFullName { get; internal set; }
    public TextRange AssemblyFullNameRange { get; internal set; }
    public string FullName { get; }
    public ParsedTypeName(string name, TextRange range);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public TextRange get_NameRange();
    [CompilerGeneratedAttribute]
public bool get_IsPointer();
    [CompilerGeneratedAttribute]
internal void set_IsPointer(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReference();
    [CompilerGeneratedAttribute]
internal void set_IsReference(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsArray();
    [CompilerGeneratedAttribute]
internal void set_IsArray(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsVector();
    [CompilerGeneratedAttribute]
internal void set_IsVector(bool value);
    [CompilerGeneratedAttribute]
public UInt32 get_Rank();
    [CompilerGeneratedAttribute]
internal void set_Rank(UInt32 value);
    [CompilerGeneratedAttribute]
public ParsedTypeName get_ElementType();
    [CompilerGeneratedAttribute]
internal void set_ElementType(ParsedTypeName value);
    [CompilerGeneratedAttribute]
public List`1<ParsedTypeName> get_GenericArgs();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
internal void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public TextRange get_AssemblyNameRange();
    [CompilerGeneratedAttribute]
internal void set_AssemblyNameRange(TextRange value);
    [CompilerGeneratedAttribute]
public string get_AssemblyFullName();
    [CompilerGeneratedAttribute]
internal void set_AssemblyFullName(string value);
    [CompilerGeneratedAttribute]
public TextRange get_AssemblyFullNameRange();
    [CompilerGeneratedAttribute]
internal void set_AssemblyFullNameRange(TextRange value);
    public string get_FullName();
    public virtual string ToString();
    public static ParsedTypeName Parse(string typeNameString);
}
internal class JetBrains.Metadata.Utils.TypeName.Parser : object {
    private Lexer myLex;
    private Stack`1<ParsedTypeName> myNameStack;
    private Token myCurrentToken;
    private Token myNextToken;
    public ParsedTypeName TypeName { get; }
    private ParsedTypeName Context { get; }
    public Parser(string name);
    public ParsedTypeName get_TypeName();
    private void Advance();
    private ParsedTypeName get_Context();
    private bool START();
    private bool AQN();
    private bool ASSEMSPEC();
    private bool FULLNAME();
    private bool GENPARAMS();
    private bool GENARGS();
    private bool GENARG();
    private bool EAQN();
    private bool QUALIFIER();
    private bool ARRAY();
    private bool RANK(UInt32& rank);
    private bool NAME();
}
internal class JetBrains.Metadata.Utils.TypeName.Token : object {
    private TokenType myType;
    public TokenType Type { get; }
    public Token(TokenType t);
    public TokenType get_Type();
    public virtual string ToString();
    public bool IsType(TokenType type);
}
[FlagsAttribute]
internal enum JetBrains.Metadata.Utils.TypeName.TokenType : Enum {
    public int value__;
    public static TokenType Empty;
    public static TokenType Identifier;
    public static TokenType OpenSqBracket;
    public static TokenType CloseSqBracket;
    public static TokenType Comma;
    public static TokenType Astrix;
    public static TokenType Amperstand;
    public static TokenType Apostrof;
    public static TokenType End;
    public static TokenType NAME;
    public static TokenType ASSEMSPEC;
    public static TokenType GENPARAM;
    public static TokenType FULLNAME;
    public static TokenType AQN;
    public static TokenType GENARG;
    public static TokenType GENARGS;
    public static TokenType EAQN;
    public static TokenType ARRAY;
    public static TokenType QUALIFIER;
    public static TokenType RANK;
}
public enum JetBrains.Metadata.Utils.TypeName.TypeNameParserArrayRanksOrder : Enum {
    public int value__;
    public static TypeNameParserArrayRanksOrder MSIL;
    public static TypeNameParserArrayRanksOrder CSHARP;
}
public class JetBrains.Metadata.Utils.UnmanagedBlob : object {
    public static UnmanagedBlob Empty;
    private UnmanagedBlock myBuffer;
    private Byte* myBuf;
    private int myLimit;
    private int myStartOffset;
    internal IntPtr InternalBuffer { get; }
    internal UnmanagedBlock InternalUnmanagedBlock { get; }
    public int Length { get; }
    internal int InternalStartOffset { get; }
    public UnmanagedBlob(UnmanagedBlock block);
    public UnmanagedBlob(UnmanagedBlob source);
    public UnmanagedBlob(UnmanagedBlob source, int start);
    public UnmanagedBlob(UnmanagedBlob source, int start, int length);
    private static UnmanagedBlob();
    internal IntPtr get_InternalBuffer();
    internal UnmanagedBlock get_InternalUnmanagedBlock();
    public sealed virtual int get_Length();
    internal int get_InternalStartOffset();
    public sealed virtual IBlob Clone();
    public sealed virtual IBinaryReader CreateReader(int position);
    public sealed virtual IBlob Slice(int position, int length);
    public sealed virtual byte ReadByte(int offset);
    public sealed virtual ushort ReadUInt16(int offset);
    public sealed virtual UInt32 ReadUInt32(int offset);
    public sealed virtual string ReadStringUtf8(int offset, Int32& bytesLenIncludingTerminatingZero);
    public sealed virtual void Read(int sourceOffset, Byte[] buffer, int bufferOffset, int count);
    public sealed virtual UInt32 ReadCompressedInteger(int offset, Int32& size);
    public sealed virtual string ReadUtf8Constant(int offset, Int32& bytesLen);
    public sealed virtual bool EqualBytes(int offset, Byte[] bytes);
    private string Read0TerminatedString(int startOffset, Int32& actualStringLength);
    public sealed virtual ulong ReadUInt64(int offset);
}
public class JetBrains.Metadata.Utils.WebCil.WasmSection : object {
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HeaderSize>k__BackingField;
    [CompilerGeneratedAttribute]
private WasmSectionId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <DataSize>k__BackingField;
    public int Offset { get; }
    public int HeaderSize { get; }
    public WasmSectionId Id { get; }
    public UInt32 DataSize { get; }
    public WasmSection(int offset, int headerSize, WasmSectionId id, UInt32 dataSize);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public int get_HeaderSize();
    [CompilerGeneratedAttribute]
public WasmSectionId get_Id();
    [CompilerGeneratedAttribute]
public UInt32 get_DataSize();
}
public enum JetBrains.Metadata.Utils.WebCil.WasmSectionId : Enum {
    public byte value__;
    public static WasmSectionId Custom;
    public static WasmSectionId Type;
    public static WasmSectionId Import;
    public static WasmSectionId Function;
    public static WasmSectionId Table;
    public static WasmSectionId Memory;
    public static WasmSectionId Global;
    public static WasmSectionId Export;
    public static WasmSectionId Start;
    public static WasmSectionId Element;
    public static WasmSectionId Code;
    public static WasmSectionId Data;
    public static WasmSectionId DataCount;
}
public static class JetBrains.Metadata.Utils.WebCil.WebAssemblyUtil : object {
    public static bool IsWebAssembly(IAssemblyLocation assemblyLocation);
}
public class JetBrains.Metadata.Utils.WebCil.WebCilHeader : object {
    public static UInt32 WebCilSignature;
    public static int WebCilHeaderSize;
    [CompilerGeneratedAttribute]
private UInt32 <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NumberOfCoffSections>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Reserved>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <PeCliHeaderRva>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <PeCliHeaderSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <PeDebugDirectoryRva>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <PeDebugDirectorySize>k__BackingField;
    public UInt32 Signature { get; }
    public ushort MajorVersion { get; }
    public ushort MinorVersion { get; }
    public ushort NumberOfCoffSections { get; }
    public ushort Reserved { get; }
    public UInt32 PeCliHeaderRva { get; }
    public UInt32 PeCliHeaderSize { get; }
    public UInt32 PeDebugDirectoryRva { get; }
    public UInt32 PeDebugDirectorySize { get; }
    public bool IsValid { get; }
    public WebCilHeader(IBinaryReader reader);
    [CompilerGeneratedAttribute]
public UInt32 get_Signature();
    [CompilerGeneratedAttribute]
public ushort get_MajorVersion();
    [CompilerGeneratedAttribute]
public ushort get_MinorVersion();
    [CompilerGeneratedAttribute]
public ushort get_NumberOfCoffSections();
    [CompilerGeneratedAttribute]
public ushort get_Reserved();
    [CompilerGeneratedAttribute]
public UInt32 get_PeCliHeaderRva();
    [CompilerGeneratedAttribute]
public UInt32 get_PeCliHeaderSize();
    [CompilerGeneratedAttribute]
public UInt32 get_PeDebugDirectoryRva();
    [CompilerGeneratedAttribute]
public UInt32 get_PeDebugDirectorySize();
    public bool get_IsValid();
}
public class JetBrains.Metadata.Utils.WebCil.WebCilPayload : CliImage {
    [CompilerGeneratedAttribute]
private WebCilHeader <WebCilHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    public WebCilHeader WebCilHeader { get; }
    public int Offset { get; }
    public WebCilPayload(IBinaryReader reader);
    [CompilerGeneratedAttribute]
public WebCilHeader get_WebCilHeader();
    [CompilerGeneratedAttribute]
public virtual int get_Offset();
    public virtual DataDirectory GetDataDirectoryEntry(PeDirectoryEntry directoryId);
}
[DebuggerDisplayAttribute("Start={VirtualAddress} Size={VirtualSize}")]
public class JetBrains.Metadata.Utils.WebCil.WebCilSectionHeader : SectionHeaderBase {
    public static int Size;
    public WebCilSectionHeader(IBinaryReader reader, int webCilPayloadOffset, int index);
}
public class JetBrains.Metadata.Utils.WebCil.WebCilWasmModule : object {
    public static UInt32 WasmSignature;
    private static int WasmHeaderSize;
    [CompilerGeneratedAttribute]
private UInt32 <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<WasmSection> <Sections>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WebCilSectionIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private WebCilPayload <WebCil>k__BackingField;
    public UInt32 Signature { get; }
    public UInt32 Version { get; }
    public List`1<WasmSection> Sections { get; }
    public int WebCilSectionIndex { get; private set; }
    [CanBeNullAttribute]
public WebCilPayload WebCil { get; private set; }
    public bool IsValid { get; }
    public WebCilWasmModule(IBinaryReader reader);
    [CompilerGeneratedAttribute]
public UInt32 get_Signature();
    [CompilerGeneratedAttribute]
public UInt32 get_Version();
    [CompilerGeneratedAttribute]
public List`1<WasmSection> get_Sections();
    [CompilerGeneratedAttribute]
public int get_WebCilSectionIndex();
    [CompilerGeneratedAttribute]
private void set_WebCilSectionIndex(int value);
    [CompilerGeneratedAttribute]
public WebCilPayload get_WebCil();
    [CompilerGeneratedAttribute]
private void set_WebCil(WebCilPayload value);
    private void ReadSections(IBinaryReader reader);
    private bool TryReadWebCil(IBinaryReader reader);
    private static bool IsPassiveSegment(byte segmentCode);
    public bool get_IsValid();
}
public class JetBrains.Metadata.Verifier.BamlReferencesVerifier : object {
    private IMetadataAssembly myAssembly;
    private IVerifierMessagesConsumer myMessages;
    public BamlReferencesVerifier(IMetadataAssembly assembly, IVerifierMessagesConsumer messages);
    public void Verify();
}
public interface JetBrains.Metadata.Verifier.IVerifierMessagesConsumer {
    public abstract virtual void ReportUnresolvedType(IMetadataTypeInfo unresolvedType, IMetadataEntity referencedFrom);
    public abstract virtual void ReportUnresolvedForwardedTypeTarget(AssemblyNameInfo forwardedTypeTargetAssembly, IMetadataAssembly referencedFrom);
    public abstract virtual void ReportUnresolvedType(BamlTypeInfo unresolvedType, IMetadataAssembly referencedFromAssembly, string referencedFromResourceKey);
    public abstract virtual void ReportParsingException(IMetadataEntity entity, Exception ex);
    public abstract virtual void ReportUnresolvedEntity(IMetadataEntity unresolvedEntity, IMetadataEntity referencedFrom);
    public abstract virtual void ReportBadAttributeValues(IMetadataEntity referencedFrom);
    public abstract virtual void ReportBadEnumValue(IMetadataTypeInfo enumType, decimal value, IMetadataEntity referencedFrom);
    public abstract virtual void ReportUnresolvedTypeCtor(IMetadataTypeInfo ctorTypeInfo, IMetadataEntity referencedFrom);
    public abstract virtual void ReportNotImplementedMember(IMetadataClassType memberOwner, IMetadataTypeMember member, IMetadataTypeInfo typeInfo);
}
public static class JetBrains.Metadata.Verifier.MetadataVerifier : object {
    public static void Verify(IMetadataAssembly metadataAssembly, IVerifierMessagesConsumer messagesConsumer);
}
public class JetBrains.Metadata.Verifier.MethodImplementationsVerifier : object {
    private IVerifierMessagesConsumer myMessages;
    public MethodImplementationsVerifier(IVerifierMessagesConsumer messages);
    public void Verify(IMetadataAssembly assembly);
    private void VerifyTypeInfo(IMetadataTypeInfo typeInfo);
    private IList`1<IMetadataClassType> GetBaseClassesChain(IMetadataTypeInfo typeInfo);
    [CanBeNullAttribute]
private IMetadataMethod SearchForMethodImplementation(MethodSignature methodSignature, string methodName, IList`1<IMetadataClassType> baseClassesChain, int startIndex);
    [CanBeNullAttribute]
private IMetadataMethod SearchMethod(IMetadataClassType classType, MethodSignature methodSignature, string methodName);
    private void CheckInterfacesMembersImplemented(IMetadataClassType memberOwner, IEnumerable`1<IMetadataMethod> methods, IMetadataClassType classType);
    [CanBeNullAttribute]
private static IMetadataTypeMember SearchAnyTypeMemberImplementationWithBaseClasses(IMetadataClassType memberOwner, IMetadataTypeMember memberToSearch, IMetadataClassType classType);
    [CanBeNullAttribute]
private static IMetadataTypeMember SearchAnyTypeMemberImplementation(IMetadataClassType memberOwner, IMetadataTypeMember memberToSearch, IMetadataClassType classType);
    [CanBeNullAttribute]
private static IMetadataTypeMember SearchTypeMemberByExplicitImplementation(IMetadataClassType memberOwner, IMetadataTypeMember memberToSearch, IMetadataClassType classType);
    private static IMetadataTypeMember SearchMemberBySignature(IMetadataClassType memberToSearchOwner, IMetadataTypeMember memberToSearch, IMetadataClassType classType);
}
public class JetBrains.Metadata.Verifier.UnresolvedEntitiesVerifier : object {
    private IVerifierMessagesConsumer myMessages;
    public UnresolvedEntitiesVerifier(IVerifierMessagesConsumer messages);
    public void Verify(IMetadataAssembly assembly);
    private void VerifyTypeInfo(IMetadataTypeInfo typeInfo, IImageBodyReader imageBodyReader);
    private void VerifyEvent(IMetadataEvent metadataEvent);
    private void VerifyProperty(IMetadataProperty metadataProperty);
    private void VerifyField(IMetadataField metadataField);
    private void VerifyMethod(IMetadataMethod metadataMethod, IImageBodyReader imageBodyReader);
    private void VerifyMethodSignature(MethodSignature methodSignature, IMetadataEntity referencedFrom);
    private void VerifyFieldSpecification(FieldSpecification fieldSpecification, IMetadataEntity referencedFrom);
    private void VerifyMethodInstantiation(MethodInstantiation methodInstantiation, IMetadataEntity referencedFrom);
    private void VerifyMethodSpecification(MethodSpecification methodSpecification, IMetadataEntity referencedFrom);
    private void VerifyParameter(IMetadataParameter metadataParameter);
    private void VerifySecurity(IMetadataSecurityOwner securityOwner);
    private void VerifySecurityRow(IMetadataSecurityRow securityRow);
    private void VerifyReturnValue(IMetadataReturnValue returnValue);
    private void VerifyTypeParameter(IMetadataTypeParameter typeParameter);
    private void VerifyMetadataEntity(IMetadataEntity metadataEntity);
    private void VerifyCustomAttribute(IMetadataCustomAttribute customAttribute);
    private void VerifyAttributeNamedArgument(IMetadataAttributeNamedArgument namedArgument, IMetadataEntity referencedFrom);
    private void VerifyMetadataAttributeValue(MetadataAttributeValue value, IMetadataEntity referencedFrom);
    private decimal ConvertLiteralValueToDecimal(object value);
    private void VerifyType(IMetadataType metadataType, IMetadataEntity referencedFrom);
}
public class JetBrains.Metadata.Verifier.VerifierMessagesConsumer : object {
    private TextWriter myOutput;
    private HashSet`1<IMetadataTypeInfo> ifaces;
    public VerifierMessagesConsumer(TextWriter output);
    public sealed virtual void ReportUnresolvedType(IMetadataTypeInfo unresolvedType, IMetadataEntity referencedFrom);
    public sealed virtual void ReportUnresolvedForwardedTypeTarget(AssemblyNameInfo forwardedTypeTargetAssembly, IMetadataAssembly referencedFrom);
    public sealed virtual void ReportUnresolvedType(BamlTypeInfo unresolvedType, IMetadataAssembly referencedFromAssembly, string referencedFromResourceKey);
    public sealed virtual void ReportParsingException(IMetadataEntity entity, Exception ex);
    public sealed virtual void ReportUnresolvedEntity(IMetadataEntity unresolvedEntity, IMetadataEntity referencedFrom);
    public sealed virtual void ReportBadAttributeValues(IMetadataEntity referencedFrom);
    public sealed virtual void ReportBadEnumValue(IMetadataTypeInfo enumType, decimal value, IMetadataEntity referencedFrom);
    public sealed virtual void ReportUnresolvedTypeCtor(IMetadataTypeInfo ctorTypeInfo, IMetadataEntity referencedFrom);
    private string GetMemberPresentableName(IMetadataClassType memberOwner, IMetadataTypeMember member);
    public sealed virtual void ReportNotImplementedMember(IMetadataClassType memberOwner, IMetadataTypeMember member, IMetadataTypeInfo typeInfo);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
