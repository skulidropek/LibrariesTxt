[ShellComponentAttribute("16")]
[DerivedComponentsInstantiationRequirementAttribute("0")]
public class JetBrains.Symbols.DefaultPdbCmdExecutionConfirmation : object {
    public virtual bool RequestCommandExecutionConfirmation(string command, string pattern);
}
[ShellComponentAttribute("16")]
[DerivedComponentsInstantiationRequirementAttribute("0")]
public class JetBrains.Symbols.DefaultPdbSpecificLogger : object {
    public virtual void LogFailure(string format, Object[] args);
    public virtual void LogInformation(string format, Object[] args);
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.Downloader.DownloaderCookiesStorage : object {
    private ProductSettingsLocation mySettingsLocation;
    private CookieSerializableCollection myCookies;
    public DownloaderCookiesStorage(ProductSettingsLocation settingsLocation);
    private FileSystemPath GetStoragePath();
    private void LoadInitialCookies();
    protected virtual void LoadCookies(FileSystemPath path);
    protected virtual void SaveCookies();
    public void AddCookies(IEnumerable`1<Cookie> newCookies);
    public void InitializeCookieContainer(CookieContainer container);
    [CompilerGeneratedAttribute]
private void <LoadInitialCookies>b__4_0();
}
public class JetBrains.Symbols.Downloader.DownloadResult : object {
    [CompilerGeneratedAttribute]
private Uri <ResponseUri>k__BackingField;
    private CookieCollection myCookies;
    private FileSystemPath myDataFile;
    private WebHeaderCollection myHeaders;
    private Nullable`1<HttpStatusCode> myHttpCode;
    private string myErrorDescription;
    [CanBeNullAttribute]
public Uri ResponseUri { get; }
    public WebHeaderCollection Headers { get; }
    public CookieCollection Cookies { get; }
    public FileSystemPath DataFile { get; }
    public Nullable`1<HttpStatusCode> HttpCode { get; }
    public string ErrorDescription { get; }
    public DownloadResult(WebHeaderCollection headers, FileSystemPath dataFile, CookieCollection cookies, Nullable`1<HttpStatusCode> httpCode, string errorDescription, Uri responseUri);
    [CompilerGeneratedAttribute]
public Uri get_ResponseUri();
    public WebHeaderCollection get_Headers();
    public CookieCollection get_Cookies();
    public FileSystemPath get_DataFile();
    public Nullable`1<HttpStatusCode> get_HttpCode();
    public string get_ErrorDescription();
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.Downloader.DownloadServiceImpl : object {
    private static string SymbolServerVersionDefault;
    private static int RequestTimeout;
    private Lazy`1<string> mySymbolServerVersion;
    private DownloaderCookiesStorage myDownloaderCookiesStorage;
    private IPdbSpecificLogger myPdbSpecificLogger;
    private WebProxySettingsReader myProxySettings;
    private IThreading myMainThread;
    private EulaDialog myEulaDialog;
    public DownloadServiceImpl(DownloaderCookiesStorage downloaderCookiesStorage, IPdbSpecificLogger pdbSpecificLogger, WebProxySettingsReader proxySettings, IThreading mainThread, EulaDialog eulaDialog);
    public virtual DownloadStatus DownloadFile(Uri uri, FileSystemPath local, string taskName, IProgressIndicator indicator, IReadOnlyDictionary`2<string, string> additionalHeaders, Func`2<DownloadResult, bool> extraValidation);
    private DownloadStatus DownloadFile(Uri uri, FileSystemPath local, string taskName, IProgressIndicator indicator, bool askEula, IReadOnlyDictionary`2<string, string> additionalHeaders, Func`2<DownloadResult, bool> extraValidation);
    private DownloadStatus MoveResult(Uri uri, FileSystemPath result, FileSystemPath local, bool deleteResult);
    private HttpWebRequest CreateRequest(Uri uri, CookieContainer cookieContainer, IReadOnlyDictionary`2<string, string> additionalHeaders);
    private static string GetSymbolServerVersion();
    private static string GetSymbolServerVersionSafe();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JetBrains.Symbols.Downloader.DownloadStatus : ValueType {
    [CompilerGeneratedAttribute]
private DownloadStatusResult <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<HttpStatusCode> <HttpStatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorDescription>k__BackingField;
    public DownloadStatusResult Result { get; }
    public Nullable`1<HttpStatusCode> HttpStatusCode { get; }
    public string ErrorDescription { get; }
    public bool Succeded { get; }
    public bool Cancelled { get; }
    public DownloadStatus(DownloadStatusResult result, Nullable`1<HttpStatusCode> httpCode, string errorDescription);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public DownloadStatusResult get_Result();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<HttpStatusCode> get_HttpStatusCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ErrorDescription();
    public bool get_Succeded();
    public bool get_Cancelled();
}
public enum JetBrains.Symbols.Downloader.DownloadStatusResult : Enum {
    public int value__;
    public static DownloadStatusResult OK;
    public static DownloadStatusResult CANCELLED;
    public static DownloadStatusResult ERROR;
}
public class JetBrains.Symbols.Downloader.EulaContent : object {
    private string myAcceptButton;
    private string myAcceptKey;
    private string myDeclineButtonText;
    private string myDeclineKey;
    private string myDialogTitle;
    private string myEulaText;
    private string myFullEulaBody;
    private static string RESPONSE_RE;
    private static Regex ResponseParser;
    public string FullEulaBody { get; }
    public string EulaText { get; }
    public string AcceptButtonText { get; }
    public string AcceptKey { get; }
    public string DeclineButtonText { get; }
    public string DeclineKey { get; }
    public string DialogTitle { get; }
    public EulaContent(string eulaBodyToBeParsed);
    private static EulaContent();
    public string get_FullEulaBody();
    public string get_EulaText();
    public string get_AcceptButtonText();
    public string get_AcceptKey();
    public string get_DeclineButtonText();
    public string get_DeclineKey();
    public string get_DialogTitle();
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.Downloader.EulaDialog : object {
    public virtual bool Show(EulaContent content);
}
internal class JetBrains.Symbols.Downloader.HttpDownloader : object {
    private static ILogger ourLogger;
    private HttpWebRequest myRequest;
    private DownloadResult myResult;
    public HttpDownloader(HttpWebRequest request);
    private static HttpDownloader();
    [CanBeNullAttribute]
public DownloadResult Execute(IProgressIndicator indicator, string taskName);
    public static Nullable`1<HttpStatusCode> GetHttpStatusCode(WebException exception);
    private void SafeDownloadThread(IProgressIndicator indicator, string taskName);
    private void DownloadThread(IProgressIndicator indicator, string taskName);
}
public interface JetBrains.Symbols.Downloader.IDownloadService {
    public abstract virtual DownloadStatus DownloadFile(Uri uri, FileSystemPath local, string taskName, IProgressIndicator indicator, IReadOnlyDictionary`2<string, string> additionalHeaders, Func`2<DownloadResult, bool> extraValidation);
}
public interface JetBrains.Symbols.IPdbCmdExecutionConfirmation {
    public abstract virtual bool RequestCommandExecutionConfirmation(string command, string pattern);
}
public interface JetBrains.Symbols.IPdbSpecificLogger {
    [StringFormatMethodAttribute("format")]
public abstract virtual void LogFailure(string format, Object[] args);
    [StringFormatMethodAttribute("format")]
public abstract virtual void LogInformation(string format, Object[] args);
}
public interface JetBrains.Symbols.ISourcesCache {
    public FileSystemPath PrimaryCacheDir { get; }
    public abstract virtual FileSystemPath get_PrimaryCacheDir();
    [CanBeNullAttribute]
public abstract virtual FileSystemPath Locate(SourceLocation sourceLocation);
}
public interface JetBrains.Symbols.ISourcesDownloader {
    public abstract virtual SourceDownloadResult Download(SourceLocation sourceLocation, FileSystemPath cacheDirectory, IProgressIndicator progressIndicator, ISourceLinkCredentialManager credentialManager);
}
public interface JetBrains.Symbols.ISymbolsDownloader {
    public abstract virtual SymbolsDownloadResult Download(IDebugAssemblyInfo assemblyInfo, SymbolsSource symbolsSource, IProgressIndicator progressIndicator);
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.Providers.AppSpecificSymbolsProvider : object {
    private AppSpecificSymbolsCache mySymbolsCache;
    private ISymbolsDownloader mySymbolsDownloader;
    public int Priority { get; }
    public IEnumerable`1<SymbolsSource> SymbolsSources { get; }
    public AppSpecificSymbolsProvider(AppSpecificSymbolsCache symbolsCache, ISymbolsDownloader symbolsDownloader);
    public sealed virtual int get_Priority();
    public sealed virtual ICollection`1<FileSystemPath> GetPdbFiles(IDebugAssemblyInfo assemblyInfo);
    public sealed virtual bool DownloadPdbFile(IDebugAssemblyInfo assemblyInfo, IProgressIndicator progress);
    public sealed virtual IEnumerable`1<SymbolsSource> get_SymbolsSources();
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.Providers.EmbeddedPortablePdbSymbolsProvider : object {
    public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual ICollection`1<FileSystemPath> GetPdbFiles(IDebugAssemblyInfo assemblyInfo);
    public sealed virtual bool DownloadPdbFile(IDebugAssemblyInfo assemblyInfo, IProgressIndicator progress);
}
public interface JetBrains.Symbols.Providers.ISourceSymbolsProvider {
    public IEnumerable`1<SymbolsSource> SymbolsSources { get; }
    public abstract virtual IEnumerable`1<SymbolsSource> get_SymbolsSources();
}
[DerivedComponentsInstantiationRequirementAttribute("1")]
public interface JetBrains.Symbols.Providers.ISymbolsProvider {
    public int Priority { get; }
    public abstract virtual int get_Priority();
    [NotNullAttribute]
public abstract virtual ICollection`1<FileSystemPath> GetPdbFiles(IDebugAssemblyInfo assemblyInfo);
    public abstract virtual bool DownloadPdbFile(IDebugAssemblyInfo assemblyInfo, IProgressIndicator progress);
}
public interface JetBrains.Symbols.Providers.ISymbolsProvidersManager {
    public IEnumerable`1<ISymbolsProvider> OrderedProviders { get; }
    public abstract virtual IEnumerable`1<ISymbolsProvider> get_OrderedProviders();
    public abstract virtual PdbPathInfo[] GetPdbFilesInfo(IDebugAssemblyInfo assemblyInfo);
    public abstract virtual bool DownloadPdbFile(IDebugAssemblyInfo assemblyInfo, IProgressIndicator progress);
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.Providers.MicrosoftSourceSymbolsProvider : SingleServerSymbolProvider {
    private static string SymbolServer;
    public MicrosoftSourceSymbolsProvider(SymbolSourceSymbolsCache symbolSourceSymbolsCache, ISymbolsDownloader symbolDownloader);
    protected virtual bool IsApplicable(IDebugAssemblyInfo assemblyInfo);
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.Providers.NextToDllSymbolsProvider : object {
    public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual ICollection`1<FileSystemPath> GetPdbFiles(IDebugAssemblyInfo assemblyInfo);
    public sealed virtual bool DownloadPdbFile(IDebugAssemblyInfo assemblyInfo, IProgressIndicator progress);
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.Providers.NtSymbolPathSymbolsProvider : object {
    private NtSymbolPathSymbolsCache mySymbolsCache;
    private ISymbolsDownloader mySymbolsDownloader;
    public int Priority { get; }
    public IEnumerable`1<SymbolsSource> SymbolsSources { get; }
    public NtSymbolPathSymbolsProvider(NtSymbolPathSymbolsCache symbolsCache, ISymbolsDownloader symbolsDownloader);
    public sealed virtual int get_Priority();
    public sealed virtual ICollection`1<FileSystemPath> GetPdbFiles(IDebugAssemblyInfo assemblyInfo);
    public sealed virtual bool DownloadPdbFile(IDebugAssemblyInfo assemblyInfo, IProgressIndicator progress);
    public sealed virtual IEnumerable`1<SymbolsSource> get_SymbolsSources();
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.Providers.NuGetSourceSymbolsProvider : SingleServerSymbolProvider {
    private static string SymbolServer;
    public NuGetSourceSymbolsProvider(SymbolSourceSymbolsCache symbolSourceSymbolsCache, ISymbolsDownloader symbolsDownloader);
    protected virtual bool IsApplicable(IDebugAssemblyInfo assemblyInfo);
}
public class JetBrains.Symbols.Providers.PdbPathInfo : object {
    [NotNullAttribute]
private FileSystemPath myPath;
    private ISymbolsProvider mySymbolsProvider;
    public ISymbolsProvider SymbolsProvider { get; }
    [NotNullAttribute]
public FileSystemPath Path { get; }
    public PdbPathInfo(FileSystemPath path, ISymbolsProvider symbolsProvider);
    public ISymbolsProvider get_SymbolsProvider();
    public FileSystemPath get_Path();
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.Providers.ReferenceSourceSymbolsProvider : SingleServerSymbolProvider {
    private static string RefSrcSymbolServer;
    public ReferenceSourceSymbolsProvider(ReferenceSourceSymbolsCache referenceSourceSymbolsCache, ISymbolsDownloader symbolsDownloader);
    protected virtual bool IsApplicable(IDebugAssemblyInfo assemblyInfo);
}
public abstract class JetBrains.Symbols.Providers.SingleServerSymbolProvider : UrlSourceSymbolProvider {
    protected string ServerUrl;
    public IEnumerable`1<SymbolsSource> SymbolsSources { get; }
    protected SingleServerSymbolProvider(SymbolsCacheBase sourceSymbolsCache, ISymbolsDownloader symbolDownloader, string serverUrl);
    [IteratorStateMachineAttribute("JetBrains.Symbols.Providers.SingleServerSymbolProvider/<get_SymbolsSources>d__3")]
public virtual IEnumerable`1<SymbolsSource> get_SymbolsSources();
}
public abstract class JetBrains.Symbols.Providers.SmartSymbolProvider : object {
    private SymbolsCacheBase mySourceSymbolsCache;
    private ISymbolsDownloader mySymbolDownloader;
    protected FileSystemPath CacheDirectory { get; }
    protected ISymbolsDownloader SymbolsDownloader { get; }
    public int Priority { get; }
    public IEnumerable`1<SymbolsSource> SymbolsSources { get; }
    protected SmartSymbolProvider(SymbolsCacheBase sourceSymbolsCache, ISymbolsDownloader symbolDownloader);
    protected FileSystemPath get_CacheDirectory();
    protected ISymbolsDownloader get_SymbolsDownloader();
    protected abstract virtual bool IsApplicable(IDebugAssemblyInfo assemblyInfo);
    public virtual int get_Priority();
    public sealed virtual ICollection`1<FileSystemPath> GetPdbFiles(IDebugAssemblyInfo assemblyInfo);
    public abstract virtual bool DownloadPdbFile(IDebugAssemblyInfo assemblyInfo, IProgressIndicator progress);
    public abstract virtual IEnumerable`1<SymbolsSource> get_SymbolsSources();
}
public static class JetBrains.Symbols.Providers.SymbolsProviderHelper : object {
    public static bool DownloadPdbFile(IDebugAssemblyInfo assemblyInfo, IProgressIndicator progress, ISymbolsDownloader symbolsDownloader, IEnumerable`1<SymbolsSource> sources);
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.Providers.SymbolsProvidersManager : object {
    private Lazy`1<IEnumerable`1<ISymbolsProvider>> myOrderedProviders;
    public IEnumerable`1<ISymbolsProvider> OrderedProviders { get; }
    public SymbolsProvidersManager(IEnumerable`1<ISymbolsProvider> providers);
    public sealed virtual IEnumerable`1<ISymbolsProvider> get_OrderedProviders();
    public sealed virtual PdbPathInfo[] GetPdbFilesInfo(IDebugAssemblyInfo assemblyInfo);
    public sealed virtual bool DownloadPdbFile(IDebugAssemblyInfo assemblyInfo, IProgressIndicator progress);
}
public abstract class JetBrains.Symbols.Providers.UrlSourceSymbolProvider : SmartSymbolProvider {
    protected UrlSourceSymbolProvider(SymbolsCacheBase sourceSymbolsCache, ISymbolsDownloader symbolDownloader);
    public virtual bool DownloadPdbFile(IDebugAssemblyInfo assemblyInfo, IProgressIndicator progress);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.Symbols.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string Downloaded_Of__Text { get; }
    public static string Downloaded_SoFar_Text { get; }
    public static string DownloadingPdbFileFor__Text { get; }
    public static string Downloading_From__Text { get; }
    public static string Downloading_PdbFrom__Text { get; }
    public static string ErrorWhileDownloadingFrom_DestinationFilePathIsTooLong__Text { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get_Downloaded_Of__Text();
    public static string get_Downloaded_SoFar_Text();
    public static string get_DownloadingPdbFileFor__Text();
    public static string get_Downloading_From__Text();
    public static string get_Downloading_PdbFrom__Text();
    public static string get_ErrorWhileDownloadingFrom_DestinationFilePathIsTooLong__Text();
}
public enum JetBrains.Symbols.SourceDownloadKind : Enum {
    public int value__;
    public static SourceDownloadKind Ok;
    public static SourceDownloadKind NotFound;
    public static SourceDownloadKind Cancelled;
    public static SourceDownloadKind Error;
    public static SourceDownloadKind Unauthorized;
}
public class JetBrains.Symbols.SourceDownloadResult : object {
    [CompilerGeneratedAttribute]
private static SourceDownloadResult <Ok>k__BackingField;
    [CompilerGeneratedAttribute]
private static SourceDownloadResult <NotFound>k__BackingField;
    [CompilerGeneratedAttribute]
private static SourceDownloadResult <Cancelled>k__BackingField;
    [CompilerGeneratedAttribute]
private static SourceDownloadResult <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceDownloadKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <UnauthorizedUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<HttpStatusCode> <StatusCode>k__BackingField;
    public static SourceDownloadResult Ok { get; }
    public static SourceDownloadResult NotFound { get; }
    public static SourceDownloadResult Cancelled { get; }
    public static SourceDownloadResult Error { get; }
    public SourceDownloadKind Kind { get; }
    [CanBeNullAttribute]
public Uri UnauthorizedUri { get; }
    [CanBeNullAttribute]
public Nullable`1<HttpStatusCode> StatusCode { get; }
    public SourceDownloadResult(SourceDownloadKind kind, Nullable`1<HttpStatusCode> statusCode, Uri unauthorizedUri);
    private static SourceDownloadResult();
    [CompilerGeneratedAttribute]
public static SourceDownloadResult get_Ok();
    [CompilerGeneratedAttribute]
public static SourceDownloadResult get_NotFound();
    [CompilerGeneratedAttribute]
public static SourceDownloadResult get_Cancelled();
    [CompilerGeneratedAttribute]
public static SourceDownloadResult get_Error();
    [CompilerGeneratedAttribute]
public SourceDownloadKind get_Kind();
    [CompilerGeneratedAttribute]
public Uri get_UnauthorizedUri();
    [CompilerGeneratedAttribute]
public Nullable`1<HttpStatusCode> get_StatusCode();
    public virtual string ToString();
}
[ShellComponentAttribute("10")]
public class JetBrains.Symbols.SourceLinkOrEmbeddedSourcesCache : object {
    private IPdbSpecificLogger myPdbSpecificLogger;
    private ILogger myLogger;
    private Lazy`1<FileSystemPath> myLazyCacheDirectory;
    private HashAlgorithm myDefaultHashAlgorithm;
    private object myHashAlgorithmLockObject;
    private static string PropertiesFileExtension;
    private static int PropertiesFileSignature;
    [NotNullAttribute]
private FileSystemPath CacheDirectory { get; }
    public FileSystemPath PrimaryCacheDir { get; }
    public SourceLinkOrEmbeddedSourcesCache(SourceLinkOrEmbeddedSourcesCacheDirectory cacheDirectory, IPdbSpecificLogger pdbSpecificLogger, ILogger logger);
    private FileSystemPath get_CacheDirectory();
    public sealed virtual FileSystemPath get_PrimaryCacheDir();
    public sealed virtual FileSystemPath Locate(SourceLocation sourceLocation);
    private FileSystemPath GetItemPath(AssemblyId assemblyId, int sourceIndex, FileSystemPath sourcePathFromPdb);
    private FileSystemPath GetItemPath(AssemblyId assemblyId, Byte[] sourceChecksum, FileSystemPath sourcePathFromPdb, String& itemRelativePath);
    private FileSystemPath GetItemPath(AssemblyId assemblyId, PdbDocumentInfo sourceInfo, string sourceFileNameFromPdb);
    private static string GetItemRelativePath(AssemblyId assemblyId, int sourceIndex, FileSystemPath sourcePathFromPdb);
    public string GetItemRelativePath(AssemblyId assemblyId, PdbDocumentInfo sourceInfo, FileSystemPath sourcePathFromPdb);
    private static void AppendChecksumFolder(StringBuilder sb, Byte[] sourceChecksum);
    [NotNullAttribute]
public static string GetChecksumFolder(Byte[] sourceChecksum);
    [CanBeNullAttribute]
public FileSystemPath TryGetSource(AssemblyId assemblyId, PdbDocumentInfo sourceInfo, string sourceFileNameFromPdb, FileSystemPath pdbPath, DebugInfoType debugInfoType);
    [CanBeNullAttribute]
public Byte[] TryGetSourceChecksum(FileSystemPath cacheItemPath);
    public PdbDocumentInfo TryGetSourceInfo(FileSystemPath cacheItemPath, ParsedPdb pdb);
    [ObsoleteAttribute("Use GetAssemblyIds or TryGetSourceChecksum")]
public AssemblyId TryGetAssemblyId(FileSystemPath cacheItemPath);
    [NotNullAttribute]
public IList`1<AssemblyId> GetAssemblyIds(FileSystemPath cacheItemPath);
    public bool InCache(FileSystemPath cacheItemPath);
    public FileSystemPath GetSourceLinkPath(AssemblyId assemblyId);
    private HashAlgorithm GetDefaultHashAlgorithm();
    private Byte[] GetDefaultChecksum(Byte[] sourceContent);
    [NotNullAttribute]
public FileSystemPath GetOrAddSource(Byte[] checksum, string sourceFileNameFromPdb, Func`1<Byte[]> getContent);
    [NotNullAttribute]
private FileSystemPath GetOrAddSource(AssemblyId assemblyId, PdbDocumentInfo sourceInfo, string sourceFileNameFromPdb, Byte[] content, Func`1<Byte[]> getContent);
    [NotNullAttribute]
public FileSystemPath GetOrAddSource(AssemblyId assemblyId, PdbDocumentInfo sourceInfo, string sourceFileNameFromPdb, Func`1<Byte[]> getContent);
    private static void ClearReadonly(FileSystemPath path);
    private static void SetReadonly(FileSystemPath path);
    private void WriteProperties(FileSystemPath cacheItemPath, Byte[] checksum, AssemblyId assemblyId);
    private bool ReadProperties(FileSystemPath cacheItemPath, Byte[]& checksum, IList`1& ids);
    [NotNullAttribute]
private static FileSystemPath GetPropertiesFile(FileSystemPath cacheItemPath);
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.SourceLinkOrEmbeddedSourcesCacheDirectory : object {
    private static string SourcesCacheFolder;
    private ProductSettingsLocation myProductSettingsLocation;
    public SourceLinkOrEmbeddedSourcesCacheDirectory(ProductSettingsLocation productSettingsLocation);
    [NotNullAttribute]
public virtual FileSystemPath GetDirectory();
}
[IsReadOnlyAttribute]
public class JetBrains.Symbols.SourceLinks.AuthorizationToken : ValueType {
    private string myAuthorizationValue;
    [CompilerGeneratedAttribute]
private AuthorizationTokenType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessToken>k__BackingField;
    public AuthorizationTokenType Type { get; }
    public string AccessToken { get; }
    public AuthorizationToken(AuthorizationTokenType type, string accessToken);
    [CompilerGeneratedAttribute]
public AuthorizationTokenType get_Type();
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    public static AuthorizationToken Basic(string username, string password);
    public static AuthorizationToken Bearer(string token);
    public static AuthorizationToken Token(string token);
    public static AuthorizationToken Create(AuthorizationTokenType type, string username, string password);
    public virtual string ToString();
}
public enum JetBrains.Symbols.SourceLinks.AuthorizationTokenType : Enum {
    public int value__;
    public static AuthorizationTokenType Bearer;
    public static AuthorizationTokenType Basic;
    public static AuthorizationTokenType Token;
}
[ExtensionAttribute]
public static class JetBrains.Symbols.SourceLinks.AuthorizationTokenTypeEx : object {
    [ExtensionAttribute]
public static bool IsRequiredUserName(Nullable`1<AuthorizationTokenType> type);
}
[ShellComponentAttribute("16")]
internal class JetBrains.Symbols.SourceLinks.AzureRepos : object {
    public SourceLinkServer Server { get; }
    public int Priority { get; }
    public Nullable`1<AuthorizationTokenType> AuthorizationType { get; }
    public bool IsSupportedHeadRequest { get; }
    public sealed virtual SourceLinkServer get_Server();
    public sealed virtual int get_Priority();
    public sealed virtual Nullable`1<AuthorizationTokenType> get_AuthorizationType();
    public sealed virtual bool get_IsSupportedHeadRequest();
    public sealed virtual Uri GetAuthorizationUri(Uri rawUri);
    public sealed virtual bool IsApplicable(Uri uri);
}
[ShellComponentAttribute("16")]
internal class JetBrains.Symbols.SourceLinks.AzureReposVisualStudio : object {
    public SourceLinkServer Server { get; }
    public int Priority { get; }
    public Nullable`1<AuthorizationTokenType> AuthorizationType { get; }
    public bool IsSupportedHeadRequest { get; }
    public sealed virtual SourceLinkServer get_Server();
    public sealed virtual int get_Priority();
    public sealed virtual Nullable`1<AuthorizationTokenType> get_AuthorizationType();
    public sealed virtual bool get_IsSupportedHeadRequest();
    public sealed virtual Uri GetAuthorizationUri(Uri rawUri);
    public sealed virtual bool IsApplicable(Uri uri);
}
[ShellComponentAttribute("16")]
internal class JetBrains.Symbols.SourceLinks.BitBucket : object {
    private static string DnsSafeHost;
    private static Uri ourUri;
    public SourceLinkServer Server { get; }
    public int Priority { get; }
    public Nullable`1<AuthorizationTokenType> AuthorizationType { get; }
    public bool IsSupportedHeadRequest { get; }
    private static BitBucket();
    public sealed virtual SourceLinkServer get_Server();
    public sealed virtual int get_Priority();
    public sealed virtual Nullable`1<AuthorizationTokenType> get_AuthorizationType();
    public sealed virtual bool get_IsSupportedHeadRequest();
    public sealed virtual Uri GetAuthorizationUri(Uri rawUri);
    public sealed virtual bool IsApplicable(Uri uri);
}
[ShellComponentAttribute("16")]
internal class JetBrains.Symbols.SourceLinks.Default : object {
    public SourceLinkServer Server { get; }
    public int Priority { get; }
    public Nullable`1<AuthorizationTokenType> AuthorizationType { get; }
    public bool IsSupportedHeadRequest { get; }
    public sealed virtual SourceLinkServer get_Server();
    public sealed virtual int get_Priority();
    public sealed virtual Nullable`1<AuthorizationTokenType> get_AuthorizationType();
    public sealed virtual bool get_IsSupportedHeadRequest();
    public sealed virtual Uri GetAuthorizationUri(Uri rawUri);
    public sealed virtual bool IsApplicable(Uri uri);
}
[ShellComponentAttribute("16")]
internal class JetBrains.Symbols.SourceLinks.GitHub : object {
    private static string GithubUser;
    private static Uri ourUri;
    public SourceLinkServer Server { get; }
    public int Priority { get; }
    public Nullable`1<AuthorizationTokenType> AuthorizationType { get; }
    public bool IsSupportedHeadRequest { get; }
    private static GitHub();
    public sealed virtual SourceLinkServer get_Server();
    public sealed virtual int get_Priority();
    public sealed virtual Nullable`1<AuthorizationTokenType> get_AuthorizationType();
    public sealed virtual bool get_IsSupportedHeadRequest();
    public sealed virtual Uri GetAuthorizationUri(Uri rawUri);
    public sealed virtual bool IsApplicable(Uri uri);
}
public interface JetBrains.Symbols.SourceLinks.ISourceLinkCredentialManager {
    public IProperty`1<bool> IsEnabled { get; }
    public abstract virtual IProperty`1<bool> get_IsEnabled();
    [CanBeNullAttribute]
public abstract virtual Nullable`1<AuthorizationToken> TryGetCachedAuthorizationToken(Uri uri);
    [CanBeNullAttribute]
public abstract virtual Nullable`1<AuthorizationToken> TryGetAuthorizationToken(Uri uri, Func`1<bool> checkForInterrupt);
    [ItemCanBeNullAttribute]
public abstract virtual Task`1<Nullable`1<AuthorizationToken>> TryGetAuthorizationTokenAsync(Lifetime lifetime, Uri uri);
    public abstract virtual Task`1<Nullable`1<ValidatedToken>> AskAuthorizationTokenAsync(Lifetime lifetime, Uri uri);
    public abstract virtual void LogDownloadSuccessfully(Uri uri);
    public abstract virtual void LogCannotDownload(Uri uri);
}
public interface JetBrains.Symbols.SourceLinks.ISourceLinkCredentialProvider {
    public int Priority { get; }
    public abstract virtual int get_Priority();
    public abstract virtual Task`1<SourceLinkCredentials> GetAsync(Lifetime lifetime, Uri authUri);
}
public interface JetBrains.Symbols.SourceLinks.ISourceLinkCredentialStore {
    public abstract virtual Task`1<bool> SetAsync(Lifetime lifetime, Uri authUri, SourceLinkCredentials credentials);
}
public interface JetBrains.Symbols.SourceLinks.ISourceLinkInfoProvider {
    public SourceLinkServer Server { get; }
    public int Priority { get; }
    public Nullable`1<AuthorizationTokenType> AuthorizationType { get; }
    public bool IsSupportedHeadRequest { get; }
    public abstract virtual SourceLinkServer get_Server();
    public abstract virtual int get_Priority();
    public abstract virtual Nullable`1<AuthorizationTokenType> get_AuthorizationType();
    public abstract virtual bool get_IsSupportedHeadRequest();
    [NotNullAttribute]
public abstract virtual Uri GetAuthorizationUri(Uri rawUri);
    public abstract virtual bool IsApplicable(Uri uri);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("UserName:{UserName}, Password: {Password}")]
public class JetBrains.Symbols.SourceLinks.SourceLinkCredentials : ValueType {
    [CompilerGeneratedAttribute]
private string <UserName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<SourceLinkCredentials> <Comparer>k__BackingField;
    public static SourceLinkCredentials Unsuccess { get; }
    public bool Success { get; }
    [CanBeNullAttribute]
public string UserName { get; }
    [CanBeNullAttribute]
public string Password { get; }
    public static IEqualityComparer`1<SourceLinkCredentials> Comparer { get; }
    public SourceLinkCredentials(string userName, string password);
    private static SourceLinkCredentials();
    public static SourceLinkCredentials get_Unsuccess();
    public bool get_Success();
    [CompilerGeneratedAttribute]
public string get_UserName();
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<SourceLinkCredentials> get_Comparer();
}
public enum JetBrains.Symbols.SourceLinks.SourceLinkServer : Enum {
    public int value__;
    public static SourceLinkServer Github;
    public static SourceLinkServer Bitbucket;
    public static SourceLinkServer AzureRepos;
    public static SourceLinkServer AzureReposVisualStudio;
    public static SourceLinkServer GitLab;
    public static SourceLinkServer GitWeb;
    public static SourceLinkServer Unknown;
}
[IsReadOnlyAttribute]
public class JetBrains.Symbols.SourceLinks.ValidatedToken : ValueType {
    [CompilerGeneratedAttribute]
private AuthorizationToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceLinkCredentials <Credentials>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <Status>k__BackingField;
    public AuthorizationToken Token { get; }
    public SourceLinkCredentials Credentials { get; }
    public HttpStatusCode Status { get; }
    public ValidatedToken(AuthorizationToken token, SourceLinkCredentials credentials, HttpStatusCode status);
    [CompilerGeneratedAttribute]
public AuthorizationToken get_Token();
    [CompilerGeneratedAttribute]
public SourceLinkCredentials get_Credentials();
    [CompilerGeneratedAttribute]
public HttpStatusCode get_Status();
    public sealed virtual bool Equals(ValidatedToken other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ShellComponentAttribute("16")]
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Symbols.SourceLinks.WindowsCredentialManagerProvider : object {
    public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual Task`1<SourceLinkCredentials> GetAsync(Lifetime lifetime, Uri authUri);
    public sealed virtual Task`1<bool> SetAsync(Lifetime lifetime, Uri authUri, SourceLinkCredentials credentials);
    private static string CreateApplicationName(Uri uri);
    private static SourceLinkCredentials FromWindowsCredentials(WindowsCredential credential);
}
public class JetBrains.Symbols.SourceLinks.WindowsGitCredentialManager : object {
    private static ILogger ourLogger;
    [CompilerGeneratedAttribute]
private static WindowsGitCredentialManager <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private static FileSystemPath <Exe>k__BackingField;
    [CanBeNullAttribute]
public static WindowsGitCredentialManager Instance { get; }
    public static FileSystemPath Exe { get; }
    private static WindowsGitCredentialManager();
    [CompilerGeneratedAttribute]
public static WindowsGitCredentialManager get_Instance();
    [CompilerGeneratedAttribute]
public static FileSystemPath get_Exe();
    [AsyncStateMachineAttribute("JetBrains.Symbols.SourceLinks.WindowsGitCredentialManager/<CallAsync>d__7")]
private static Task`1<Process> CallAsync(Lifetime lifetime, Uri uri, string arg);
    public Task`1<SourceLinkCredentials> GetAsync(Lifetime lifetime, Uri authUri);
    private static SourceLinkCredentials TryGetCredentials(Process process);
    private static Dictionary`2<string, string> ParseOutput(string output);
}
[ShellComponentAttribute("16")]
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Symbols.SourceLinks.WindowsGitCredentialManagerProvider : object {
    private Task`1<SourceLinkCredentials> myUnsuccess;
    public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual Task`1<SourceLinkCredentials> GetAsync(Lifetime lifetime, Uri authUri);
}
[ShellComponentAttribute("0")]
public class JetBrains.Symbols.SourcesDownloaderImpl : object {
    private static TimeSpan MaxCmdExecutionTime;
    private IPdbCmdExecutionConfirmation myCmdExecutionConfirmation;
    private IPdbSpecificLogger myPdbSpecificLogger;
    private IDownloadService myDownloadService;
    public SourcesDownloaderImpl(IPdbCmdExecutionConfirmation cmdExecutionConfirmation, IPdbSpecificLogger pdbSpecificLogger, IDownloadService downloadService);
    private static SourcesDownloaderImpl();
    private static string SafeReadAllText(FileSystemPath path);
    public virtual SourceDownloadResult Download(SourceLocation sourceLocation, FileSystemPath cacheDirectory, IProgressIndicator progressIndicator, ISourceLinkCredentialManager credentialManager);
    protected virtual void AssignWorkingDirectory(BinShOrCmdExeProcessRunner runner);
    [CompilerGeneratedAttribute]
internal static bool <Download>g__ContainsFileName|6_6(Uri uri, <>c__DisplayClass6_3& );
    [CompilerGeneratedAttribute]
internal static bool <Download>g__IsAuthorized|6_2(DownloadStatus status);
    [CompilerGeneratedAttribute]
internal static bool <Download>g__IsUnauthorized|6_3(DownloadStatus status);
}
public abstract class JetBrains.Symbols.SrcSrvSourcesCache : object {
    [NotNullAttribute]
public IProperty`1<ImmutableArray`1<FileSystemPath>> CacheDirectories { get; }
    public FileSystemPath PrimaryCacheDir { get; }
    public abstract virtual IProperty`1<ImmutableArray`1<FileSystemPath>> get_CacheDirectories();
    public abstract virtual FileSystemPath get_PrimaryCacheDir();
    public abstract virtual FileSystemPath Locate(SourceLocation sourceLocation);
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.SrcSrvSourcesCacheImpl : SrcSrvSourcesCache {
    private IProperty`1<ImmutableArray`1<FileSystemPath>> myCacheDirectories;
    public IProperty`1<ImmutableArray`1<FileSystemPath>> CacheDirectories { get; }
    public FileSystemPath PrimaryCacheDir { get; }
    public virtual IProperty`1<ImmutableArray`1<FileSystemPath>> get_CacheDirectories();
    public virtual FileSystemPath get_PrimaryCacheDir();
    public virtual FileSystemPath Locate(SourceLocation sourceLocation);
    private void ResetToFallbackCacheLocation();
    private sealed virtual override void JetBrains.Application.Infra.IExternalSourcesDebugInfoProvider.Dump(TextWriter sw);
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.SymbolsCache.AppSpecificSymbolsCache : SymbolsCacheBase {
    private IProperty`1<ImmutableArray`1<SymbolsSource>> mySymbolsSources;
    public IProperty`1<ImmutableArray`1<SymbolsSource>> SymbolsSources { get; }
    public FileSystemPath CacheDirectory { get; }
    public AppSpecificSymbolsCache(Lifetime lifetime);
    public IProperty`1<ImmutableArray`1<SymbolsSource>> get_SymbolsSources();
    public static FileSystemPath GetFallbackCacheLocation();
    private sealed virtual override void JetBrains.Application.Infra.IExternalSourcesDebugInfoProvider.Dump(TextWriter sw);
    public virtual FileSystemPath get_CacheDirectory();
    [CompilerGeneratedAttribute]
private ImmutableArray`1<FileSystemPath> <.ctor>b__1_0(ImmutableArray`1<SymbolsSource> ss);
    [CompilerGeneratedAttribute]
private FileSystemPath <.ctor>b__1_1(SymbolsSource x);
}
public interface JetBrains.Symbols.SymbolsCache.IDirectorySymbolsCache {
    public IProperty`1<ImmutableArray`1<FileSystemPath>> SymbolsDirectories { get; }
    public abstract virtual IProperty`1<ImmutableArray`1<FileSystemPath>> get_SymbolsDirectories();
}
public interface JetBrains.Symbols.SymbolsCache.ISymbolsCache {
    [NotNullAttribute]
public abstract virtual ICollection`1<FileSystemPath> LocatePdbFile(IDebugAssemblyInfo assemblyInfo);
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.SymbolsCache.NtSymbolPathSymbolsCache : SymbolsCacheBase {
    private ImmutableArray`1<SymbolsSource> mySymbolsSources;
    public IEnumerable`1<SymbolsSource> SymbolsSources { get; }
    public FileSystemPath CacheDirectory { get; }
    public NtSymbolPathSymbolsCache(Lifetime lifetime);
    public IEnumerable`1<SymbolsSource> get_SymbolsSources();
    private sealed virtual override void JetBrains.Application.Infra.IExternalSourcesDebugInfoProvider.Dump(TextWriter sw);
    public virtual FileSystemPath get_CacheDirectory();
    [CompilerGeneratedAttribute]
private FileSystemPath <.ctor>b__1_1(SymbolsSource x);
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.SymbolsCache.PackagedReferenceSourceDetector : object {
    public virtual FileSystemPath[] GetPaths();
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.SymbolsCache.ReferenceSourceSymbolsCache : SymbolsCacheBase {
    private static string DirectoryName;
    private FileSystemPath myCacheDirectory;
    public FileSystemPath CacheDirectory { get; }
    public ReferenceSourceSymbolsCache(Lifetime lifetime, PackagedReferenceSourceDetector packagedReferenceSourceDetector);
    public virtual FileSystemPath get_CacheDirectory();
    private sealed virtual override void JetBrains.Application.Infra.IExternalSourcesDebugInfoProvider.Dump(TextWriter sw);
    [CompilerGeneratedAttribute]
private FileSystemPath <.ctor>b__2_0();
}
public abstract class JetBrains.Symbols.SymbolsCache.SymbolsCacheBase : object {
    private IProperty`1<ImmutableArray`1<FileSystemPath>> mySymbolsDirectories;
    public IProperty`1<ImmutableArray`1<FileSystemPath>> SymbolsDirectories { get; }
    [NotNullAttribute]
public FileSystemPath CacheDirectory { get; }
    protected SymbolsCacheBase(Lifetime lifetime);
    protected ICollection`1<FileSystemPath> SearchPdbInSymbolsSources(string pdbName, string pdbSignature);
    private FileSystemPath SearchPdbInCache(FileSystemPath cacheDir, string pdbSignature, string pdbName);
    public sealed virtual ICollection`1<FileSystemPath> LocatePdbFile(IDebugAssemblyInfo assemblyInfo);
    public sealed virtual IProperty`1<ImmutableArray`1<FileSystemPath>> get_SymbolsDirectories();
    public abstract virtual FileSystemPath get_CacheDirectory();
}
public static class JetBrains.Symbols.SymbolsCache.SymbolsCacheStructureUtil : object {
    public static FileSystemPath GetPdbFilePath(FileSystemPath rootFolder, string pdbFileName, string pdbSignature);
    public static FileSystemPath GetPdbFolderPath(FileSystemPath rootFolder, string pdbFileName, string pdbSignature);
    public static bool TryExtractPdbNameAndSignature(FileSystemPath pdbPath, PdbNameAndSignature& pdb);
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.SymbolsCache.SymbolSourceSymbolsCache : SymbolsCacheBase {
    private static string DirectoryName;
    private FileSystemPath myCacheDirectory;
    [NotNullAttribute]
public FileSystemPath CacheDirectory { get; }
    public SymbolSourceSymbolsCache(Lifetime lifetime);
    public virtual FileSystemPath get_CacheDirectory();
    private sealed virtual override void JetBrains.Application.Infra.IExternalSourcesDebugInfoProvider.Dump(TextWriter sw);
    [CompilerGeneratedAttribute]
private FileSystemPath <.ctor>b__2_0();
}
[ShellComponentAttribute("16")]
public class JetBrains.Symbols.SymbolsDownloaderCached : SymbolsDownloaderSimple {
    private static TimeSpan ourNotFoundValid;
    private static TimeSpan ourOkValid;
    private static TimeSpan ourServerErrorValid;
    private static TimeSpan ourCancelledValid;
    private Dictionary`2<string, DownloadRecord> myDownloads;
    private IPdbSpecificLogger myPdbSpecificLogger;
    public SymbolsDownloaderCached(IPdbSpecificLogger pdbSpecificLogger, IDownloadService downloadService);
    private static SymbolsDownloaderCached();
    public virtual SymbolsDownloadResult Download(IDebugAssemblyInfo assemblyInfo, SymbolsSource symbolsSource, IProgressIndicator indicator);
    private static TimeSpan GetValidTime(SymbolsDownloadResult result);
    private Nullable`1<SymbolsDownloadResult> GetCachedDownloadResult(string downloadId);
    private sealed virtual override void JetBrains.Application.Infra.IExternalSourcesDebugInfoProvider.Dump(TextWriter sw);
}
public class JetBrains.Symbols.SymbolsDownloaderSimple : object {
    private IPdbSpecificLogger myPdbSpecificLogger;
    private IDownloadService myDownloadService;
    public SymbolsDownloaderSimple(IPdbSpecificLogger pdbSpecificLogger, IDownloadService downloadService);
    public virtual SymbolsDownloadResult Download(IDebugAssemblyInfo assemblyInfo, SymbolsSource symbolsSource, IProgressIndicator progressIndicator);
    private static string EnsureEndsWithSlash(string s);
    private static DownloadStatus DownloadPdb(string pdbSignature, string pbdChecksum, SymbolsSource symbolsSource, string pdbNameWithoutExtension, bool compressed, IDownloadService downloader, IProgressIndicator progressIndicator);
    private static FileSystemPath GetTargetPdbPath(SymbolsSource symbolsSource, string pdbNameWithoutExtension, string pdbSignature, bool compressed);
}
public enum JetBrains.Symbols.SymbolsDownloadResult : Enum {
    public int value__;
    public static SymbolsDownloadResult Ok;
    public static SymbolsDownloadResult NotFound;
    public static SymbolsDownloadResult Cancelled;
    public static SymbolsDownloadResult Error;
}
[ZoneDefinitionAttribute]
public class JetBrains.Symbols.SymbolsImplZone : object {
}
public class JetBrains.Symbols.SymbolsSource : object {
    private FileSystemPath myCacheDirectory;
    private string myUrl;
    [CanBeNullAttribute]
public string Url { get; }
    [NotNullAttribute]
public FileSystemPath CacheDirectory { get; }
    public SymbolsSource(string url, FileSystemPath cacheDirectory);
    public SymbolsSource(FileSystemPath cacheDirectory);
    public string get_Url();
    public FileSystemPath get_CacheDirectory();
    public sealed virtual bool Equals(SymbolsSource other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CanBeNullAttribute]
public static SymbolsSource ParseAsteriskCoded(string str, FileSystemPath defaultCacheDir);
    [CanBeNullAttribute]
private static SymbolsSource GetSymbolSource(string url, FileSystemPath cacheDir);
    [CanBeNullAttribute]
private static SymbolsSource GetSymbolSource(string url, string cacheDir);
    private static bool IsRemotePath(string str);
    [NotNullAttribute]
public static SymbolsSource[] ParsePathString(string path, FileSystemPath primaryDir);
}
public class JetBrains.Symbols.Utils.BinShOrCmdExeProcessRunner : object {
    private static string ExecutableCmd;
    private static string ArgumentsFormatCmd;
    private static string ExecutableBinSh;
    private static string ArgumentsFormatBinSh;
    private string myScript;
    private Process myProcess;
    private Thread myReadErrorsThread;
    private Thread myReadOutputThread;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myTimeout;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DataHandler OnStdErrData;
    [CompilerGeneratedAttribute]
private DataHandler OnStdOutData;
    public string WorkingDirectory { get; public set; }
    public TimeSpan MaxExecutionTime { get; public set; }
    public bool Timeout { get; }
    public int ExitCode { get; }
    public BinShOrCmdExeProcessRunner(Lifetime lifetime, string script);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(string value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxExecutionTime();
    [CompilerGeneratedAttribute]
public void set_MaxExecutionTime(TimeSpan value);
    public bool get_Timeout();
    public int get_ExitCode();
    [CompilerGeneratedAttribute]
public void add_OnStdErrData(DataHandler value);
    [CompilerGeneratedAttribute]
public void remove_OnStdErrData(DataHandler value);
    [CompilerGeneratedAttribute]
public void add_OnStdOutData(DataHandler value);
    [CompilerGeneratedAttribute]
public void remove_OnStdOutData(DataHandler value);
    public void Run();
    private void FireStdErrData(Byte[] buf, int offset, int count);
    private void FireStdOutData(Byte[] buf, int offset, int count);
    private void ReadErrorsThread();
    private void ReadOutputThread();
    private static void ReadStream(Stream stream, Action`3<Byte[], int, int> handler);
    [CompilerGeneratedAttribute]
private void <.ctor>b__11_0();
}
public static class JetBrains.Symbols.Utils.CabUtil : object {
    public static bool IsCabHeader(FileSystemPath compressedPdbPath);
    public static bool ExtractCompressedPdb(FileSystemPath compressedPdbPath, FileSystemPath uncompressedPdbPath, IPdbSpecificLogger pdbSpecificLogger);
}
[XmlRootAttribute("Cookies")]
public class JetBrains.Symbols.Utils.CookieSerializableCollection : object {
    private static XmlSerializer XmlSerializer;
    private List`1<SerializableCookie> myCookies;
    [XmlElementAttribute("Cookie")]
public SerializableCookie[] Cookies { get; public set; }
    private static CookieSerializableCollection();
    public SerializableCookie[] get_Cookies();
    public void set_Cookies(SerializableCookie[] value);
    private int IndexOfCookie(string domain, string name);
    [NotNullAttribute]
public static CookieSerializableCollection Deserialize(XmlReader xmlReader);
    public void Serialize(XmlWriter xmlWriter);
}
public static class JetBrains.Symbols.Utils.ReferenceSourceUtilsMetadata : object {
    public static string Microsoft;
    public static bool IsRelatedToReferenceSource(FileSystemPath assemblyFile);
}
public class JetBrains.Symbols.Utils.SerializableCookie : object {
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommentUri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Discard>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Expired>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Expires>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HttpOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Secure>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    public string Comment { get; public set; }
    public string CommentUri { get; public set; }
    public bool Discard { get; public set; }
    public string Domain { get; public set; }
    public bool Expired { get; public set; }
    public DateTime Expires { get; public set; }
    public bool HttpOnly { get; public set; }
    public string Name { get; public set; }
    public string Path { get; public set; }
    public string Port { get; public set; }
    public bool Secure { get; public set; }
    public string Value { get; public set; }
    public int Version { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
public void set_Comment(string value);
    [CompilerGeneratedAttribute]
public string get_CommentUri();
    [CompilerGeneratedAttribute]
public void set_CommentUri(string value);
    [CompilerGeneratedAttribute]
public bool get_Discard();
    [CompilerGeneratedAttribute]
public void set_Discard(bool value);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(string value);
    [CompilerGeneratedAttribute]
public bool get_Expired();
    [CompilerGeneratedAttribute]
public void set_Expired(bool value);
    [CompilerGeneratedAttribute]
public DateTime get_Expires();
    [CompilerGeneratedAttribute]
public void set_Expires(DateTime value);
    [CompilerGeneratedAttribute]
public bool get_HttpOnly();
    [CompilerGeneratedAttribute]
public void set_HttpOnly(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(string value);
    [CompilerGeneratedAttribute]
public bool get_Secure();
    [CompilerGeneratedAttribute]
public void set_Secure(bool value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    public static SerializableCookie FromCookie(Cookie c);
    public Cookie ToCookie();
}
[ZoneMarkerAttribute]
public class JetBrains.Symbols.ZoneMarker : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
