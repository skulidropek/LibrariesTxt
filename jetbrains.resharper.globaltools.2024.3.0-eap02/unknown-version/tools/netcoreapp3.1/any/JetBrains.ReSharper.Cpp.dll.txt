public class CppLambdaFunctionDefinition : CppFunctionDeclaration {
    private LambdaExpression myLambda;
    public ICppDeclarationTrailingNode TrailingNode { get; }
    public FunctionParameters Parameters { get; }
    public ITreeNode FunctionDeclarationNode { get; }
    public CppLambdaFunctionDefinition(LambdaExpression lambda);
    public virtual ICppDeclarationTrailingNode get_TrailingNode();
    public virtual FunctionParameters get_Parameters();
    public virtual ITreeNode get_FunctionDeclarationNode();
    public virtual ICppFunctionDeclaratorResolveEntity GetFunctionResolveEntity();
    public virtual CppTypeSelection GetReturnTypeSelection();
}
public static class CppPredefinedMacrosUtil : object {
    public static void AddPredefinedMacros(CppRootInclusionContext result, CppCompilationProperties props, CppLanguageDialect dialect);
    public static void ProcessForcedIncludes(CppRootInclusionContext state, CppCompilationProperties props, FileProcessingOptions options);
    private static int Get_MSC_VER(PlatformToolsetVersion toolset);
    private static CppPPDefineSymbol GetMsvcLangMacro(CppCompilationProperties props);
    private static CppPPDefineSymbol GetCPlusPlusMacroFromLanguageStandard(CppCompilationProperties props);
    private static CppLanguageStandard GetRealLanguageStandard(CppCompilationProperties props);
    private static CppPPDefineSymbol GetCPlusPlusMacroFromCompilationProperties(CppCompilationProperties props);
    private static void ProcessMSVCMacros(CppRootInclusionContext result, CppCompilationProperties props);
    private static void ProcessAppleMacros(CppRootInclusionContext result, CppCompilationProperties props);
    private static CppPPDefineSymbol[] GetArchitectureDefines(CppCompilationProperties props);
    public static CppPPDefineSymbol[] GetUnsupportedGnuKeywordsHacks();
    private static void ProcessUnknownToolkitMacros(CppRootInclusionContext result, CppCompilationProperties props);
    private static void ProcessReSharperMacros(CppRootInclusionContext result);
    private static void ProcessBuiltinMacros(CppRootInclusionContext result, CppLanguageDialect dialect);
    private static void ProcessMacrosFromCompilationProperties(CppRootInclusionContext result, CppCompilationProperties props);
    private static void ProcessPredefinedMacros(CppRootInclusionContext result, CppCompilationProperties props);
    private static void ProcessFeatureTestMacros(CppRootInclusionContext ctx, CppLanguageDialect dialect);
}
internal class CppSimpleDeclarationFunctionDefinition : CppFunctionDeclaration {
    [CompilerGeneratedAttribute]
private SimpleDeclaration <DeclarationNode>k__BackingField;
    public ICppDeclarationTrailingNode TrailingNode { get; }
    public FunctionParameters Parameters { get; }
    public ITreeNode FunctionDeclarationNode { get; }
    public SimpleDeclaration DeclarationNode { get; }
    public CppSimpleDeclarationFunctionDefinition(SimpleDeclaration simpleDecl);
    public virtual ICppDeclarationTrailingNode get_TrailingNode();
    public virtual FunctionParameters get_Parameters();
    public virtual ITreeNode get_FunctionDeclarationNode();
    public virtual ICppFunctionDeclaratorResolveEntity GetFunctionResolveEntity();
    public virtual CppTypeSelection GetReturnTypeSelection();
    [CompilerGeneratedAttribute]
public SimpleDeclaration get_DeclarationNode();
}
[IsReadOnlyAttribute]
internal class CppTokenProcessorGuard : ValueType {
    private CppPreprocessor myOwner;
    private ITokenProcessor myProcessor;
    public CppTokenProcessorGuard(CppPreprocessor owner, ITokenProcessor processor);
    public sealed virtual void Dispose();
}
public class DoxygenCppFileReference : TreeReferenceBase`1<CppDoxygenFileRef> {
    private DoxygenCppFileReference myQualifier;
    private TextRange myElementRange;
    private string myPathPart;
    private bool myIsFolder;
    public bool IsFolderReference { get; }
    public ICppFileReference ParentReference { get; }
    public DoxygenCppFileReference(CppDoxygenFileRef owner, DoxygenCppFileReference qualifier, string pathPart, TextRange range, bool isFolder);
    public virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public IReference BindTo(IDeclaredElement element, DoxygenCppFileReference contextRef);
    private IReference ReplacePath(IPath newPath, bool onlyName);
    public virtual IAccessContext GetAccessContext();
    public virtual TreeTextRange GetTreeTextRange();
    public virtual string GetName();
    public sealed virtual string GetFullPath();
    public sealed virtual bool get_IsFolderReference();
    public sealed virtual ICppFileReference get_ParentReference();
    public sealed virtual IEnumerable`1<VirtualFileSystemPath> GetSearchPaths();
    public virtual ResolveResultWithInfo ResolveWithoutCache();
    private CppInclusionContext GetResolveContext();
}
public class FileSystemPathWithRange : object {
    private VirtualFileSystemPath myPath;
    private TextRange myTextRange;
    public VirtualFileSystemPath Path { get; }
    public TextRange Range { get; }
    public IPath Empty { get; }
    public string ExtensionNoDot { get; }
    public string ExtensionWithDot { get; }
    public string FullPath { get; }
    public bool IsAbsolute { get; }
    public bool IsEmpty { get; }
    public string Name { get; }
    public string NameWithoutExtension { get; }
    public bool IsValidOnCurrentOS { get; }
    public IPath Parent { get; }
    public StringSlicesEnumerable Components { get; }
    public FileSystemPathWithRange(VirtualFileSystemPath path, TextRange textRange);
    public VirtualFileSystemPath get_Path();
    public TextRange get_Range();
    public sealed virtual IPath get_Empty();
    public sealed virtual string get_ExtensionNoDot();
    public sealed virtual string get_ExtensionWithDot();
    public sealed virtual string get_FullPath();
    public sealed virtual bool get_IsAbsolute();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual string get_Name();
    public sealed virtual string get_NameWithoutExtension();
    public sealed virtual bool get_IsValidOnCurrentOS();
    public sealed virtual IPath get_Parent();
    public sealed virtual IPath Combine(RelativePath other);
    public sealed virtual IPath Parse(string text);
    public sealed virtual Uri ToDirectoryUri();
    public sealed virtual Uri ToUri();
    public sealed virtual IPath TryCombine(string component);
    public sealed virtual StringSlicesEnumerable get_Components();
    public bool Equals(FileSystemPathWithRange other);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public interface JetBrains.ReSharper.Cpp.Caches.IUnrealCacheParticipant`1 {
}
public interface JetBrains.ReSharper.Cpp.Caches.IUnrealCacheSerializable {
}
public interface JetBrains.ReSharper.Cpp.Caches.IUnrealCacheSerializer`1 {
    public abstract virtual T Load(BinaryReader reader);
    public abstract virtual void Save(T obj, BinaryWriter writer);
}
public interface JetBrains.ReSharper.Cpp.Caches.IUnrealCacheSerializerProvider`1 {
    public IUnrealCacheSerializer`1<T> Serializer { get; }
    public abstract virtual IUnrealCacheSerializer`1<T> get_Serializer();
}
public static class JetBrains.ReSharper.Cpp.Parsing.Preprocessor.CppHasAttributeUtil : object {
    public static HasAttributeKind GetHasAttributeKind(CppPPDefineSymbol symbol);
}
public enum JetBrains.ReSharper.Cpp.Parsing.Preprocessor.HasAttributeKind : Enum {
    public int value__;
    public static HasAttributeKind Attribute;
    public static HasAttributeKind CAttribute;
    public static HasAttributeKind CppAttribute;
}
internal class JetBrains.ReSharper.Cpp.Src.Symbols.Builders.CppGGDeclareHungarianBuilder : ValueType {
    private ICppDeclarationBuilder myParentBuilder;
    private CppComplexOffset myLocation;
    private CppGGDeclareHungarianMode myMode;
    private CppQualType myUnresolvedType;
    private CppQualType myReplacedType;
    private string myPatternName;
    public CppGGDeclareHungarianBuilder(ICppDeclarationBuilder parentBuilder);
    public void LearnLocation(CppComplexOffset location);
    public void LearnMode(string mode);
    public void LearnType(ICppDeclarationBuilder typeDeclBuilder);
    public void LearnPatternName(string patternName);
    public ICppSymbol Finish();
}
public class JetBrains.ReSharper.Cpp.Src.Tree.GGDeclareHungarian : BaseSymbolNode`1<CppGGDeclareHungarianSymbol> {
    public NodeType NodeType { get; }
    public GGDeclareHungarian(ICppSymbol symbol);
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Cpp.Src.Tree.GnuAddressOfLabelExpression : CppExpressionNode {
    public NodeType NodeType { get; }
    public ITokenNode LabelNameNode { get; }
    public virtual NodeType get_NodeType();
    public virtual CppDependentInfo GetDependentInfo();
    public ITokenNode get_LabelNameNode();
    public sealed virtual string GetLabelName();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
}
public static class JetBrains.ReSharper.Cpp.Symbols.DumpSymbolsAndEntitiesUtil : object {
    private static void PrintWithIndent(TextWriter writer, int level, object obj);
    private static void PrintPreprocessorSymbols(TextWriter writer, CppPreprocessorSymbols& ppSymbols, CppComplexOffset offset, int indentLevel);
    private static void DumpSymbolsInternal(TextWriter writer, ICppSymbol root, CppPreprocessorSymbols& preprocessorSymbols, int level);
    public static void DumpSymbols(TextWriter writer, ICppSymbol root, ICppSymbol[] ppSymbols, int indentLevel);
    public static void DumpSymbolTable(TextWriter writer, CppFileSymbolTable symbolTable);
    private static void DumpAttributes(TextWriter writer, ICppDeclaratorResolveEntity declarator);
    private static void DumpAttributes(TextWriter writer, CppAttributeList attributes);
    private static void DumpOwningModule(TextWriter writer, string owningModule);
    private static void DumpOwningModule(TextWriter writer, ICppResolveEntity ent);
    public static void DumpAttributes(TextWriter writer, IEnumerable`1<ICppResolveEntity> entities);
    private static bool IsStdNamespace(ICppResolveEntity ent);
    private static bool IsGeneratedEntity(ICppResolveEntity ent);
    private static void DumpResolveEntitiesInternal(TextWriter writer, ICppResolveEntity root, int level, bool onlyGlobal, OneToListMap`2<ICppResolveEntity, ICppResolveEntity> childrenMap);
    private static bool ContainsOnlyFriendDeclarators(ICppResolveEntity root);
    private static IOrderedEnumerable`1<T> SortByLocationAnchor(IEnumerable`1<T> es);
    public static void DumpResolveEntities(TextWriter writer, CppFile file);
    public static void DumpGlobalResolveEntities(TextWriter writer, ICppResolveEntity root);
}
public interface JetBrains.ReSharper.Cpp.Symbols.ICppInlineInNamespaceResolveEntity {
}
public static class JetBrains.ReSharper.Cpp.Util.CppDeclaratorValueDeducingUtil : object {
    [CanBeNullAttribute]
public static ICppLiteralValue TryDeduceValue(ICppResolvedExpression expr, ICppLiteralValue exprValue, ICppDeclaratorResolveEntity declarator, CppTypeContext& tc);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Cpp.Util.CppExceptionWrapper : ValueType {
    private object myExceptionOrDispatchInfo;
    public CppExceptionWrapper(Exception exception);
    [DoesNotReturnAttribute]
public void Throw();
    private static bool ShouldCaptureStackTrace(Exception e);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Cpp.Util.CppProgressIndicatorUtil : object {
    [ExtensionAttribute]
public static void InvokeItem(IProgressIndicator progress, string itemText, double units, Action action);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static T InvokeItem(IProgressIndicator progress, string itemText, double units, Func`1<T> func);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Cpp.Util.CppStdTraitsUtil : object {
    public static Nullable`1<CppTraitOrConceptReferenceResult> IsValueTraitOrConceptReference(ICppResolvedQualifiedReferenceExpression qualRef, bool isUE4Solution);
    [ExtensionAttribute]
public static bool IsIsConstructible(CppTraitOrConceptReferenceResult& traitOrConceptRef, ICppTemplateArgument[]& templateArgs);
    [ExtensionAttribute]
public static bool IsIsSame(CppTraitOrConceptReferenceResult& traitOrConceptRef, ICppTemplateArgument[]& templateArgs);
    [ExtensionAttribute]
public static bool IsIsBaseOf(CppTraitOrConceptReferenceResult& traitOrConceptRef, ICppTemplateArgument[]& templateArgs);
    [ExtensionAttribute]
public static bool IsIsDerivedFrom(CppTraitOrConceptReferenceResult& traitOrConceptRef, ICppTemplateArgument[]& templateArgs);
    [CanBeNullAttribute]
private static ICppTypeTemplateInstantiationResolveEntity DropValueTail(CppDependentResolveEntity depEntity);
}
public abstract class JetBrains.ReSharper.Feature.Services.Cpp.Util.CppRequirementCollectorWithResult`1 : object {
    [CompilerGeneratedAttribute]
private TResult <Result>k__BackingField;
    public TResult Result { get; private set; }
    [CompilerGeneratedAttribute]
public TResult get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(TResult value);
    protected virtual TResult LearnTrueValueRequirement(ICppResolvedExpression expr);
    protected virtual TResult LearnFalseValueRequirement(ICppResolvedExpression expr);
    public sealed virtual void LearnTrueValueRequirement(ICppResolvedExpression expr, Boolean& expandRecursively);
    public sealed virtual void LearnFalseValueRequirement(ICppResolvedExpression expr, Boolean& expandRecursively);
}
public static class JetBrains.ReSharper.Feature.Services.Cpp.Util.CppRequirementUtil : object {
    public static void CollectRequirements(ICppFunctionDeclaratorResolveEntity primaryTemplate, ICppRequirementCollector collector, CppViewPos& vp);
    private static void CollectRequirements(CppTemplateParametersBase templateParams, ICppTemplateArgument[] defaults, ICppRequirementCollector collector);
    public static void CollectRequirements(ICppClassResolveEntity clazz, ICppRequirementCollector collector, CppViewPos& vp);
    public static void CollectRequirements(ICppResolvedExpression expr, ICppRequirementCollector collector, bool value);
    private static void CollectTypeRequirements(CppQualType type, ICppRequirementCollector collector);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.Cpp.Util.CppStdAlgorithmUtil : object {
    private static CppQualifiedName ourGlobalStdRangesQualifier;
    public static CppQualifiedName GlobalStdRangesViewsQualifier;
    private static CppStdAlgorithmUtil();
    public static bool IsDirectlyInStdNamespace(ICppResolveEntity entity);
    public static string GetNameOfTemplateFunctionDirectlyInStdNamespace(CppResolveResult& resolveResult);
    public static QualifiedReference GetQualifiedReferenceNodeFromCallExpression(CallExpression callExpr);
    public static CppQualifiedName AddRangesQualifier(CppQualifiedNamePart namePart);
    public static CppQualifiedName AddGlobalStdRangesQualifier(CppQualifiedNamePart namePart);
    [CanBeNullAttribute]
public static ICppExpressionNode ExtractBeginCallArgument(ICppExpressionNode node, bool isDeref, Boolean& isConst);
    [CanBeNullAttribute]
public static ICppExpressionNode ExtractEndCallArgument(ICppExpressionNode node, bool isDeref, Boolean& isConst);
    [ExtensionAttribute]
public static bool IsStdCustomizationPoint(ICppFunctionDeclaratorResolveEntity function);
    [ExtensionAttribute]
public static bool IsCoroutinePromiseType(IClassOrEnumSpecifier clazz);
    [ExtensionAttribute]
public static bool IsStdCustomizationType(AliasDeclaration alias);
    [ExtensionAttribute]
public static bool IsStdCustomizationType(ICppTypeDeclaratorResolveEntity alias);
    [CanBeNullAttribute]
private static ICppExpressionNode ExtractBeginOrEndCallArgument(ICppExpressionNode node, bool isDeref, Boolean& outIsConst, BeginEndNameResolver nameResolver);
    public static bool IsSameExpression(ICppExpression left, ICppExpression right);
    public static bool IsStdRangesView(QualifiedReference qualRef);
    public static bool IsStdRangesView(ICppDeclaratorResolveEntity var);
    public static bool IsStdRangesView(ICppParserSymbol parserSymbol);
    public static bool IsStdRangesView(CppVariableModuleEntity var);
}
public interface JetBrains.ReSharper.Feature.Services.Cpp.Util.ICppRequirementCollector {
    public abstract virtual void LearnTrueValueRequirement(ICppResolvedExpression expr, Boolean& expandRecursively);
    public abstract virtual void LearnFalseValueRequirement(ICppResolvedExpression expr, Boolean& expandRecursively);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.AbstractExpandingVisitorHelper`2 : object {
    public CppSubstitutionDriver myDriver;
    protected AbstractExpandingVisitorHelper`2(CppSubstitutionDriver driver);
    public abstract virtual T Substitute(T t, ICppSubstitutionContext ctx);
    public abstract virtual T Pack(T t, CppSubstitutionContext args);
    public abstract virtual T GetUnknown();
    public abstract virtual CppSubstitutionContext SeekExpansionClosure(T t);
    public abstract virtual T GetPackExpansionPattern(PackT pack);
    public abstract virtual T WrapPack(PackT pack);
    public abstract virtual void GetUnexpandedPackDependencies(T t, ICollection`1<ICppTemplateParameterPack> output);
    protected virtual bool TryUnpackBuiltins(T pattern, CppList`1& result);
    protected abstract virtual bool IsSubstitutionFailure(T t);
    public ICppTemplateArgument DropExpansionIfDependent(ICppTemplateArgument a, Boolean& defer);
    protected virtual bool ShouldDeferPackExpansionTypeArgument(CppQualType& modreq(System.Runtime.InteropServices.InAttribute) t);
    public CppList`1<T> Expand(PackT pack);
    public bool Expand(PackT pack, CppList`1& result, SubstitutionStatus& status, bool checkSubstitutionFailure);
}
internal class JetBrains.ReSharper.Psi.Cpp.BlockShaders.<BlockShadersParsingHelper>FAAAB9D9C4BDFA7B93B23B2B5B04293D5B2A991BFE81C717786D75544D448DD40__BlockShaderBuilder : BlockShadersScopeBuilderBase`1<BSBlockShaderSymbol> {
    public <BlockShadersParsingHelper>FAAAB9D9C4BDFA7B93B23B2B5B04293D5B2A991BFE81C717786D75544D448DD40__BlockShaderBuilder(ICppBuilder parent, CppFileSymbolsCache cache, BSBlockShaderSymbol symbol);
    public <BlockShadersParsingHelper>FAAAB9D9C4BDFA7B93B23B2B5B04293D5B2A991BFE81C717786D75544D448DD40__BlockShaderBuilder(ICppBuilder parent, BSBlockShaderSymbol symbol);
}
internal class JetBrains.ReSharper.Psi.Cpp.BlockShaders.<BlockShadersParsingHelper>FAAAB9D9C4BDFA7B93B23B2B5B04293D5B2A991BFE81C717786D75544D448DD40__BlockShaderInterfaceBuilder : BlockShadersScopeBuilderBase`1<BSBlockShaderInterfaceSymbol> {
    public <BlockShadersParsingHelper>FAAAB9D9C4BDFA7B93B23B2B5B04293D5B2A991BFE81C717786D75544D448DD40__BlockShaderInterfaceBuilder(ICppBuilder parent, CppFileSymbolsCache cache, BSBlockShaderInterfaceSymbol symbol);
    public <BlockShadersParsingHelper>FAAAB9D9C4BDFA7B93B23B2B5B04293D5B2A991BFE81C717786D75544D448DD40__BlockShaderInterfaceBuilder(ICppBuilder parent, BSBlockShaderInterfaceSymbol symbol);
}
internal class JetBrains.ReSharper.Psi.Cpp.BlockShaders.<BlockShadersParsingHelper>FAAAB9D9C4BDFA7B93B23B2B5B04293D5B2A991BFE81C717786D75544D448DD40__CustomizationPointBuilder : BlockShadersScopeBuilderBase`1<BSCustomizationPointSymbol> {
    public <BlockShadersParsingHelper>FAAAB9D9C4BDFA7B93B23B2B5B04293D5B2A991BFE81C717786D75544D448DD40__CustomizationPointBuilder(ICppBuilder parent, CppFileSymbolsCache cache, BSCustomizationPointSymbol symbol);
    public <BlockShadersParsingHelper>FAAAB9D9C4BDFA7B93B23B2B5B04293D5B2A991BFE81C717786D75544D448DD40__CustomizationPointBuilder(ICppBuilder parent, BSCustomizationPointSymbol symbol);
    public sealed virtual ICppParserSymbol GetClassParentSymbol();
}
internal class JetBrains.ReSharper.Psi.Cpp.BlockShaders.<BlockShadersParsingHelper>FAAAB9D9C4BDFA7B93B23B2B5B04293D5B2A991BFE81C717786D75544D448DD40__IsolatedScopeResolveEntity : CppScopeStatementResolveEntity {
    private static CppQualifiedId ourStaticName;
    public CppQualifiedNamePart Name { get; }
    public <BlockShadersParsingHelper>FAAAB9D9C4BDFA7B93B23B2B5B04293D5B2A991BFE81C717786D75544D448DD40__IsolatedScopeResolveEntity(ICppResolveEntity parent);
    private static <BlockShadersParsingHelper>FAAAB9D9C4BDFA7B93B23B2B5B04293D5B2A991BFE81C717786D75544D448DD40__IsolatedScopeResolveEntity();
    public virtual CppQualifiedNamePart get_Name();
}
internal class JetBrains.ReSharper.Psi.Cpp.BlockShaders.<BlockShadersParsingHelper>FAAAB9D9C4BDFA7B93B23B2B5B04293D5B2A991BFE81C717786D75544D448DD40__TemplateBuilder : BlockShadersScopeBuilderBase`1<BSTemplateSymbol> {
    public <BlockShadersParsingHelper>FAAAB9D9C4BDFA7B93B23B2B5B04293D5B2A991BFE81C717786D75544D448DD40__TemplateBuilder(ICppBuilder parent, CppFileSymbolsCache cache, BSTemplateSymbol symbol);
    public <BlockShadersParsingHelper>FAAAB9D9C4BDFA7B93B23B2B5B04293D5B2A991BFE81C717786D75544D448DD40__TemplateBuilder(ICppBuilder parent, BSTemplateSymbol symbol);
    public sealed virtual ICppParserSymbol GetClassParentSymbol();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.BlockShadersKeywordTokenNodeType : CppKeywordTokenNodeType {
    public bool IsScopeSpecifier;
    public BlockShadersKeywordTokenNodeType(string s, CppTokenKind kind, string text, bool isScopeSpecifier);
}
internal static class JetBrains.ReSharper.Psi.Cpp.BlockShaders.BlockShadersParsingHelper`2 : object {
    private static Dictionary`2<CppTokenKind, Pair`2<CppKeywordTokenNodeType, CppCompositeNodeType>> stageTokenTypeInfo;
    private static BlockShadersParsingHelper`2();
    public static void ParseTopLevelScope(CppParsingBase`2<TTraits, TMarkerGuard> hlslParsing, ICppBuilder root, ICppPreprocessor preprocessor);
    private static CppModuleId GetModuleId(CppFileLocation location);
    private static void RegisterModule(ParsingContext& ctx);
    private static void ParseImportsDeclaration(ParsingContext& ctx);
    private static void ParseIncludesDeclaration(ParsingContext& ctx, TMarkerGuard& markerGuard);
    private static void ParseBlock(ParsingContext& ctx, TMarkerGuard& markerGuard);
    private static void ParseImplementation(ParsingContext& ctx, TMarkerGuard& mk);
    private static void ParseResource(ParsingContext& ctx, TMarkerGuard& markerGuard, List`1<BSAttributeData> attributes);
    private static ICppMutableClassResolveEntity ParseClassLikeDeclaration(DeclarationContext& declarationContext, bool shouldParseName, TDeclarationParsing& entryParsing, ICppSymbolWithBracedBody bracedBodySymbol, bool isResource);
    private static void ParseClassLikeDeclarationBody(DeclarationContext& declarationCtx, CppClassBuilder classBuilder, TDeclarationParsing& entryParsing, ICppSymbolWithBracedBody bracedBodySymbol);
    private static List`1<BSAttributeData> ParseAttributesIfAny(ParsingContext& ctx);
    private static BSAttributeData TryParseAttribute(ParsingContext& ctx);
    private static bool TryParseTypeName(ParsingContext& ctx);
    private static IBSAttributeParameterValue ParseAttributeParameterValue(ParsingContext& ctx);
    private static bool IsClosingToken(ParsingContext& ctx);
    private static bool TryParseToken(ParsingContext& ctx, CppTokenNodeType tokenNodeType);
    private static bool ParseToken(ParsingContext& ctx, CppTokenNodeType tokenNodeType);
    private static bool IsIdentifier(ParsingContext& ctx);
    private static bool TryParseIdentifier(ParsingContext& ctx);
    private static CppQualifiedNamePart ParseName(ParsingContext& ctx);
    private static bool ParseIdentifier(ParsingContext& ctx);
    private static bool ParseStringLiteral(ParsingContext& ctx);
    private static bool ParseNumericLiteral(ParsingContext& ctx);
    private static void ProcessInclude(CppComplexOffset offset, string directiveContent, ICppFileSymbolsCache symbolCache, CppInclusionContext inclusionContext, FileProcessingOptions options, bool isLocal);
    private static IList`1<ValueTuple`2<CppComplexOffset, string>> CollectIncludes(ParsingContext& ctx);
    private static CppList`1<BSInterfaceMemberData> ParseInterfaceDeclaration(ParsingContext& ctx, TMarkerGuard& markerGuard);
    private static void ParseFunctionDeclaration(ParsingContext& ctx, TMarkerGuard& markerGuard);
    private static void ParseStructDeclaration(ParsingContext& ctx, bool topLevelDeclaration);
    private static void ParseInvalidDeclaration(ParsingContext& ctx);
    private static void ParseNextBracesSequence(ParsingContext& ctx);
    private static CppTokenKind BSKeywordTokenKind(ParsingContext& ctx);
    [CanBeNullAttribute]
private static CppTokenNodeType TryGetBSKeyword(ParsingContext& ctx);
    private static void AdvanceWithKeyword(ParsingContext& ctx, CppKeywordTokenNodeType keyword);
    private static bool TryParseKeyword(ParsingContext& ctx, CppKeywordTokenNodeType keyword);
    private static bool OpenDeclarationBody(ParsingContext& ctx);
    private static void ReportMissingClosingBraceForDeclarationBody(ParsingContext& ctx);
    private static void ParseEmbracedDeclarationEntries(ParsingContext& ctx, TEntryParsing& parsing);
    private static void ParseEmbracedStringEntries(ParsingContext& ctx, TEntryParsing& parsing);
    private static void ParseEmbracedEntries(ParsingContext& ctx, TEntryParsing& parsing);
    private static void ParseEmbracedEntries(ParsingContext& ctx, TEntryDecorationParsing decorationParsing, TEntryParsing& parsing);
    private static void ParseDeclarationEntry(ParsingContext& ctx, TEntryParsing& entryParsing);
    private static void ParseDecoratedEntry(ParsingContext& ctx, TEntryDecorationParsing decorationParsing, TEntryParsing& parsing);
    private static bool ParseList(ParsingContext& ctx, CppTokenNodeType openTt, CppTokenNodeType closeTt, string errorHint, TParsing& parsing);
    private static bool ParseRange(ParsingContext& ctx, CppTokenNodeType stopTt, string errorHint, TParsing& parsing);
    private static void ParseNamespace(ParsingContext& ctx, TMarkerGuard& mk, TParsing& entryParsing);
    private static bool TryParseBlockUsage(ParsingContext& ctx, TMarkerGuard& markerGuard);
    private static bool ParseLinkOverrideElement(ParsingContext& ctx);
    private static bool ParseLinkOverrides(ParsingContext& ctx);
    private static void ParseBlockShader(ParsingContext& ctx, TMarkerGuard& mk);
    private static void ParseBlockShaderInterface(ParsingContext& ctx, TMarkerGuard& mk);
    private static void ParseScope(ParsingContext& ctx, CppCompositeNodeType nodeType, BlockShadersScopeBuilderBase`1<TSymbol> scopeBuilder, TParsing& parsing, TMarkerGuard& mk);
    private static void ParseTemplate(ParsingContext& ctx, TMarkerGuard& mk);
    private static void ParseRegisterTemplateWithInterface(ParsingContext& ctx, TMarkerGuard& mk);
    private static void ParseKeywords(ParsingContext& ctx, TMarkerGuard& markerGuard);
    private static void ParseCustomizationPoint(ParsingContext& ctx, TMarkerGuard& markerGuard);
    private static void ParsePass(ParsingContext& ctx, TMarkerGuard& markerGuard);
    private static void ParseTags(ParsingContext& ctx, TMarkerGuard& markerGuard);
    private static void ParseRenderStates(ParsingContext& ctx);
    private static void ParsePragmas(ParsingContext& ctx, TMarkerGuard& markerGuard);
    private static void ParseStage(ParsingContext& ctx, CppTokenKind stageType, TMarkerGuard& markerGuard);
    private static void ParseSetup(ParsingContext& ctx, TMarkerGuard& markerGuard);
    private static void ParseLinkOverrideExpression(ParsingContext& ctx, bool isOuterExpression);
    private static void ParseLinkOverrideTypeCast(ParsingContext& ctx);
    private static bool ParseLinkOverrideAccessor(ParsingContext& ctx);
}
internal static class JetBrains.ReSharper.Psi.Cpp.BlockShaders.BlockShadersParsingUtils : object {
    internal static CppRootInclusionContext CreateIsolatedContext(CppInclusionContext inclusionContext);
    internal static void RegisterEntity(ICppBuilder builder, CppFileSymbolsCache cache, BlockShadersResolveEntity resolveEntity, CppParserSymbol symbol);
}
internal class JetBrains.ReSharper.Psi.Cpp.BlockShaders.BlockShadersScopeBuilderBase`1 : CppBuilderWithParent {
    [CompilerGeneratedAttribute]
private CppFileSymbolsCache <cache>P;
    [CompilerGeneratedAttribute]
private BlockShadersResolveEntity`1<TSymbol> <entity>P;
    public TSymbol Symbol { get; }
    public ICppScopeResolveEntity ResolveEntity { get; }
    public BlockShadersScopeBuilderBase`1(ICppBuilder parent, CppFileSymbolsCache cache, BlockShadersResolveEntity`1<TSymbol> entity);
    public virtual void AddChild(CppParserSymbol sym);
    public TSymbol get_Symbol();
    public virtual ICppScopeResolveEntity get_ResolveEntity();
    public void Finish();
}
public static class JetBrains.ReSharper.Psi.Cpp.BlockShaders.BlockShadersTokenTypes : object {
    private static LexerDictionary`1<CppTokenNodeType> ourKeywords;
    public static CppKeywordTokenNodeType Imports;
    public static CppKeywordTokenNodeType Block;
    public static CppKeywordTokenNodeType Interface;
    public static CppKeywordTokenNodeType Function;
    public static CppKeywordTokenNodeType Struct;
    public static CppKeywordTokenNodeType Includes;
    public static CppKeywordTokenNodeType Resource;
    public static CppKeywordTokenNodeType Namespace;
    public static CppKeywordTokenNodeType BlockShaderInterface;
    public static CppKeywordTokenNodeType CustomizationPoint;
    public static CppKeywordTokenNodeType RegisterTemplatesWithInterface;
    public static CppKeywordTokenNodeType Keywords;
    public static CppKeywordTokenNodeType BlockShader;
    public static CppKeywordTokenNodeType Implements;
    public static CppKeywordTokenNodeType Implementation;
    public static CppKeywordTokenNodeType Template;
    public static CppKeywordTokenNodeType Pass;
    public static CppKeywordTokenNodeType Pragmas;
    public static CppKeywordTokenNodeType VertexStage;
    public static CppKeywordTokenNodeType FragmentStage;
    public static CppKeywordTokenNodeType HullMappingStage;
    public static CppKeywordTokenNodeType HullPostStage;
    public static CppKeywordTokenNodeType HullConstantStage;
    public static CppKeywordTokenNodeType DomainMappingStage;
    public static CppKeywordTokenNodeType DomainPostStage;
    public static CppKeywordTokenNodeType Setup;
    public static CppKeywordTokenNodeType Tags;
    public static CppKeywordTokenNodeType RenderStates;
    public static CppKeywordTokenNodeType Default;
    public static CppKeywordTokenNodeType Discard;
    public static CppKeywordTokenNodeType Extends;
    public static NodeTypeSet KEYWORDS;
    private static BlockShadersTokenTypes();
    private static CppKeywordTokenNodeType RegisterKeyword(CppKeywordTokenNodeType keyword);
    private static CppKeywordTokenNodeType RegisterKeyword(CppTokenKind kind, string text, bool isScopeSpecifier);
    [CanBeNullAttribute]
public static CppTokenNodeType TryGetKeyword(string text);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Caches.BSAttributeDataMarshaller : object {
    public static BSAttributeDataMarshaller Instance;
    private static BSAttributeDataMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, BSAttributeData value);
    public sealed virtual BSAttributeData Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Caches.BSAttributeNamedParameterMarshaller : CppPolymorphicMarshaller`1<BSAttributeNamedParameter> {
    public virtual void Marshal(CppMarshallingContext context, BSAttributeNamedParameter value);
    public virtual BSAttributeNamedParameter Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Caches.BSAttributeParameterListMarshaller : CppPolymorphicMarshaller`1<BSAttributeParameterValueList> {
    public virtual void Marshal(CppMarshallingContext context, BSAttributeParameterValueList value);
    public virtual BSAttributeParameterValueList Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Caches.BSAttributeStandaloneValueMarshaller : CppPolymorphicMarshaller`1<BSAttributeParameterStandaloneValue> {
    public virtual void Marshal(CppMarshallingContext context, BSAttributeParameterStandaloneValue value);
    public virtual BSAttributeParameterStandaloneValue Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Caches.BSBlockShaderInterfaceSymbolMarshaller : CppPolymorphicMarshaller`1<BSBlockShaderInterfaceSymbol> {
    public virtual void Marshal(CppMarshallingContext context, BSBlockShaderInterfaceSymbol value);
    public virtual BSBlockShaderInterfaceSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Caches.BSBlockShaderSymbolMarshaller : CppPolymorphicMarshaller`1<BSBlockShaderSymbol> {
    public virtual void Marshal(CppMarshallingContext context, BSBlockShaderSymbol value);
    public virtual BSBlockShaderSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Caches.BSBlockSymbolMarshaller : CppPolymorphicMarshaller`1<BSBlockSymbol> {
    public virtual void Marshal(CppMarshallingContext context, BSBlockSymbol value);
    public virtual BSBlockSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Caches.BSCustomizationPointImplementationSymbolMarshaller : CppPolymorphicMarshaller`1<BSCustomizationPointImplementationSymbol> {
    public virtual void Marshal(CppMarshallingContext context, BSCustomizationPointImplementationSymbol value);
    public virtual BSCustomizationPointImplementationSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Caches.BSCustomizationPointSymbolMarshaller : CppPolymorphicMarshaller`1<BSCustomizationPointSymbol> {
    public virtual void Marshal(CppMarshallingContext context, BSCustomizationPointSymbol value);
    public virtual BSCustomizationPointSymbol Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Caches.BSInterfaceMemberDataMarshaller : object {
    public static BSInterfaceMemberDataMarshaller Instance;
    private static BSInterfaceMemberDataMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, BSInterfaceMemberData value);
    public sealed virtual BSInterfaceMemberData Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Caches.BSTemplateSymbolMarshaller : CppPolymorphicMarshaller`1<BSTemplateSymbol> {
    public virtual void Marshal(CppMarshallingContext context, BSTemplateSymbol value);
    public virtual BSTemplateSymbol Unmarshal(CppUnmarshallingContext context);
}
public static class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Language.BlockShadersDeclaredElementTypes : object {
    public static CppDeclaredElementType BLOCK;
    public static CppDeclaredElementType BLOCK_SHADER;
    public static CppDeclaredElementType BLOCK_SHADER_INTERFACE;
    public static CppDeclaredElementType CUSTOMIZATION_POINT;
    public static CppDeclaredElementType CUSTOMIZATION_POINT_IMPLEMENTATION;
    public static CppDeclaredElementType TEMPLATE;
    public static CppDeclaredElementType RESOURCE;
    public static HashSet`1<CppDeclaredElementType> BLOCK_SHADER_DECLARED_ELEMENT_TYPES;
    private static BlockShadersDeclaredElementTypes();
}
public static class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BlockShadersCompositeNodesFactory : object {
    [CanBeNullAttribute]
public static CppCompositeNode TryCreateNode(CppCompositeNodeType nodeType, object userData);
}
public static class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BlockShadersCompositeNodeTypes : object {
    public static CppCompositeNodeType IMPORTS_DECLARATION;
    public static CppCompositeNodeType IMPORT_ENTRY;
    public static CppCompositeNodeType BLOCK_DECLARATION;
    public static CppCompositeNodeType RESOURCE_DECLARATION;
    public static CppCompositeNodeType INTERFACE_DECLARATION;
    public static CppCompositeNodeType FUNCTION_DECLARATION;
    public static CppCompositeNodeType INCLUDES_DECLARATION;
    public static CppCompositeNodeType INCLUDE_ENTRY;
    public static CppCompositeNodeType ATTRIBUTE_LIST;
    public static CppCompositeNodeType ATTRIBUTE;
    public static CppCompositeNodeType ATTRIBUTE_NAME;
    public static CppCompositeNodeType ATTRIBUTE_PARAMETER;
    public static CppCompositeNodeType ATTRIBUTE_PARAMETER_NAME;
    public static CppCompositeNodeType ATTRIBUTE_PARAMETER_VALUE;
    public static CppCompositeNodeType NAMESPACE;
    public static CppCompositeNodeType BLOCK_SHADER_INTERFACE;
    public static CppCompositeNodeType CUSTOMIZATION_POINT;
    public static CppCompositeNodeType REGISTER_TEMPLATE_WITH_INTERFACE;
    public static CppCompositeNodeType BLOCK_SHADER;
    public static CppCompositeNodeType NAME;
    public static CppCompositeNodeType TEMPLATE_NAME;
    public static CppCompositeNodeType BLOCK_SHADER_INTERFACE_REFERENCE;
    public static CppCompositeNodeType IMPLEMENTATION;
    public static CppCompositeNodeType BLOCK_USAGE;
    public static CppCompositeNodeType TEMPLATE;
    public static CppCompositeNodeType PASS;
    public static CppCompositeNodeType PRAGMAS;
    public static CppCompositeNodeType VERTEX_STAGE;
    public static CppCompositeNodeType FRAGMENT_STAGE;
    public static CppCompositeNodeType HULL_MAPPING_STAGE;
    public static CppCompositeNodeType HULL_POST_STAGE;
    public static CppCompositeNodeType HULL_CONSTANT_STAGE;
    public static CppCompositeNodeType DOMAIN_MAPPING_STAGE;
    public static CppCompositeNodeType DOMAIN_POST_STAGE;
    public static CppCompositeNodeType SETUP;
    public static CppCompositeNodeType BLOCK_REFERENCE;
    public static CppCompositeNodeType TAGS;
    public static CppCompositeNodeType TAG;
    public static CppCompositeNodeType LINK_INPUT_OVERRIDE;
    public static CppCompositeNodeType LINK_OUTPUT_OVERRIDE;
    public static CppCompositeNodeType LINK_OVERRIDE_EXPRESSION;
    public static CppCompositeNodeType KEYWORDS_DECLARATION;
    public static NodeTypeSet BLOCK_SHADERS_BRACED_DECLARATIONS;
    public static NodeTypeSet BLOCK_SHADERS_TYPES;
    public static NodeTypeSet LINK_OVERRIDE_TYPES;
    private static BlockShadersCompositeNodeTypes();
}
public static class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BlockShadersLinkOverrideNavigator : object {
    public static BSBlockReferenceNode GetBlockReferenceNode(BSLinkOverrideExpression expr);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSAttribute : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSAttributeList : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSAttributeName : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public static class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSAttributeNavigator : object {
    [CanBeNullAttribute]
public static Declaration GetCorrespondingDeclaration(BSAttribute attribute);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSAttributeParameter : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSAttributeParameterName : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSAttributeParameterValue : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public static class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSAttributeParameterValueNavigator : object {
    public static bool IsSemanticAttributeValue(BSAttributeParameterValue val);
    public static BSAttribute GetAttribute(BSAttributeParameterValue val);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSBlockDeclaration : BaseNamedSymbolNode`1<BSBlockSymbol> {
    public NodeType NodeType { get; }
    public BSBlockDeclaration(BSBlockSymbol symbol);
    public virtual NodeType get_NodeType();
    public virtual CppTreeElementRange GetNameTokenRange();
    public virtual CppComplexOffset GetComplexOffset();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSBlockReferenceNode : CppCompositeNode {
    private Reference myReference;
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    [ContractAnnotationAttribute("true => resolveEntity: notnull; false => resolveEntity: null")]
public bool TryResolve(BSBlockResolveEntity& resolveEntity);
    public virtual void DropReferences();
    public sealed virtual CppTreeElementRange GetNameTokenRange();
    public virtual ReferenceCollection GetFirstClassReferences();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSBlockShader : BaseNamedSymbolNode`1<BSBlockShaderSymbol> {
    [CompilerGeneratedAttribute]
private BSBlockShaderResolveEntity <resolveEntity>P;
    public NodeType NodeType { get; }
    public BSBlockShader(BSBlockShaderResolveEntity resolveEntity);
    public virtual NodeType get_NodeType();
    public List`1<BSBlockShaderInterfaceReferenceNode> GetInterfaceReferences();
    public sealed virtual ICppScopeResolveEntity GetResolveScope();
    public virtual CppTreeElementRange GetNameTokenRange();
    public virtual CppComplexOffset GetComplexOffset();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSBlockShaderExtensions : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSBlockShaderExtensions/<GetReferencesEnumerator>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<BSBlockShaderInterfaceReferenceNode> GetReferencesEnumerator(BSBlockShader blockShader);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSBlockShaderInterface : BaseNamedSymbolNode`1<BSBlockShaderInterfaceSymbol> {
    [CompilerGeneratedAttribute]
private BSBlockShaderInterfaceResolveEntity <resolveEntity>P;
    public NodeType NodeType { get; }
    public BSBlockShaderInterface(BSBlockShaderInterfaceResolveEntity resolveEntity);
    public virtual NodeType get_NodeType();
    public sealed virtual ICppScopeResolveEntity GetResolveScope();
    public virtual CppTreeElementRange GetNameTokenRange();
    public virtual CppComplexOffset GetComplexOffset();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSBlockShaderInterfaceReferenceNode : CppCompositeNode {
    private Reference myReference;
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    [ContractAnnotationAttribute("true => resolveEntity: notnull; false => resolveEntity: null")]
public bool TryResolve(BSBlockShaderInterfaceResolveEntity& resolveEntity);
    public virtual void DropReferences();
    public string GetName();
    public sealed virtual CppTreeElementRange GetNameTokenRange();
    public virtual ReferenceCollection GetFirstClassReferences();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSBlockUsage : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    [CanBeNullAttribute]
public BSBlockReferenceNode GetBlockReferenceNode();
    public CppList`1<BSLinkOverrideBase> GetLinkOverrides();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSCustomizationPoint : BaseNamedSymbolNode`1<BSCustomizationPointSymbol> {
    public NodeType NodeType { get; }
    public BSCustomizationPoint(BSCustomizationPointSymbol symbol);
    public virtual NodeType get_NodeType();
    public virtual CppTreeElementRange GetNameTokenRange();
    public BSName GetName();
    public virtual CppComplexOffset GetComplexOffset();
    private CppGenericKeywordTokenNode GetCustomizationPointKeywordNode();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSFragmentStage : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSFunctionDeclaration : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSImplementation : BaseNamedSymbolNode`1<BSCustomizationPointImplementationSymbol> {
    public NodeType NodeType { get; }
    public BSImplementation(BSCustomizationPointImplementationSymbol symbol);
    public virtual NodeType get_NodeType();
    public virtual CppTreeElementRange GetNameTokenRange();
    public virtual CppComplexOffset GetComplexOffset();
    public BSCustomizationPointResolveEntity GetCustomizationPoint();
    private IList`1<BSCustomizationPointResolveEntity> GetCustomizationPointCandidates();
    public ITreeNode GetName();
    [CanBeNullAttribute]
private BSBlockShaderInterfaceReferenceNode GetFollowingInterfaceReference();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSImportEntry : CppCompositeNode {
    private IReadOnlyList`1<IReference> myReferences;
    public NodeType NodeType { get; }
    public ITokenNode ImportPath { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_ImportPath();
    public virtual ReferenceCollection GetFirstClassReferences();
    private static ICppFileReference CreateReference(BSImportEntry importNode, int offsetInNodeText, string text, TextRange rangeInPath, ICppFileReference parent, bool isFolder);
    private IReadOnlyList`1<IReference> CalculateReferences();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSImportFileReference : CppBaseFileReference`1<BSImportEntry> {
    protected ITokenNode PathToken { get; }
    public BSImportFileReference(BSImportEntry owner, ICppFileReference parentReference, string pathPart, TextRange range, bool isFolderReference);
    protected virtual ITokenNode get_PathToken();
    public virtual IEnumerable`1<VirtualFileSystemPath> GetSearchPaths();
    public virtual ResolveResultWithInfo ResolveWithoutCache();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSImportsDeclaration : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSIncludeEntry : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSIncludesDeclaration : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSInterfaceDeclaration : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSKeywordsDeclaration : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSLinkInputOverride : BSLinkOverrideBase {
    public NodeType NodeType { get; }
    public BSInterfaceMemberFlowType FlowType { get; }
    public virtual NodeType get_NodeType();
    public virtual BSInterfaceMemberFlowType get_FlowType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSLinkOutputOverride : BSLinkOverrideBase {
    public NodeType NodeType { get; }
    public BSInterfaceMemberFlowType FlowType { get; }
    public virtual NodeType get_NodeType();
    public virtual BSInterfaceMemberFlowType get_FlowType();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSLinkOverrideBase : CppCompositeNode {
    public BSInterfaceMemberFlowType FlowType { get; }
    [CanBeNullAttribute]
public BSLinkOverrideExpression LeftExpression { get; }
    [CanBeNullAttribute]
public BSLinkOverrideExpression RightExpression { get; }
    public abstract virtual BSInterfaceMemberFlowType get_FlowType();
    public BSLinkOverrideExpression get_LeftExpression();
    public BSLinkOverrideExpression get_RightExpression();
    public virtual short GetChildRole(TreeElement child);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSLinkOverrideExpression : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public bool IsDiscard();
    public bool IsIdentifier();
    [CanBeNullAttribute]
public string GetVariableName();
    public bool IsLeftExpression();
    public bool IsRightExpression();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSName : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public string GetShortName();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSNamespace : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSPass : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSPragmas : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSRegisterTemplateWithInterface : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSResourceDeclaration : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual CppComplexOffset GetComplexOffset();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSSetup : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSTag : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSTagsNode : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSTemplate : BaseNamedSymbolNode`1<BSTemplateSymbol> {
    [CompilerGeneratedAttribute]
private BSTemplateResolveEntity <resolveEntity>P;
    public NodeType NodeType { get; }
    public BSTemplate(BSTemplateResolveEntity resolveEntity);
    public virtual NodeType get_NodeType();
    public sealed virtual ICppScopeResolveEntity GetResolveScope();
    public virtual CppTreeElementRange GetNameTokenRange();
    public virtual CppComplexOffset GetComplexOffset();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSTemplateName : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.BSVertexStage : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public static class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Tree.ChildRole : object {
    public static short NONE;
    public static short BS_LEFT_LINK_OVERRIDE_EXPRESSION;
    public static short BS_RIGHT_LINK_OVERRIDE_EXPRESSION;
    public static short LAST;
}
public static class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Utils.BlockShadersRelatedEntitiesSearchUtil : object {
    public static IEnumerable`1<BSCustomizationPointResolveEntity> GetCustomizationPoints(BSCustomizationPointImplementationResolveEntity implEntity);
    public static IEnumerable`1<BSCustomizationPointImplementationSymbol> GetCustomizationPointImplementationSymbols(BSCustomizationPointResolveEntity ent);
}
public static class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Psi.Utils.ResourceParsingUtil : object {
    public static IDictionary`2<string, CppQualType> GetAvailableFieldsFromAttributes(List`1<BSAttributeData> attributes, ICppMutableClassResolveEntity classEntity);
    private static CppQualifiedNamePart GetTextureTypeName(string dimension);
    private static ICppTemplateArgument[] CreateTypeTemplateArguments(string type, CppViewPos viewPos, ICppResolvedTypeFactory verboseFactory);
    private static Dictionary`2<string, string> GetPossibleAttributeParameters(BSKnownAttributeType attrType);
    private static CppQualType ResolveTextureType(string dimension, string innerTypeName, CppViewPos viewPos, ICppResolvedTypeFactory tf);
}
public static class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BlockShadersGeneratedMembers : object {
    public static void GenerateAndAddImplicitMember(CppQualType type, ICppMutableClassResolveEntity cent, CppQualifiedNamePart name);
}
public enum JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BlockShadersLookupType : Enum {
    public int value__;
    public static BlockShadersLookupType Block;
    public static BlockShadersLookupType BlockShaderInterface;
    public static BlockShadersLookupType CustomizationPoint;
}
public abstract class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BlockShadersLookupUtil : object {
    public static FrugalLocalList`1<ICppResolveEntity> LookupEntities(ICppScopeResolveEntity scope, CppQualifiedNamePart name, BlockShadersLookupType blockShadersLookupType, Nullable`1<CppQualifiedNamePart> interfaceName);
    public static FrugalLocalList`1<ICppResolveEntity> LookupEntities(CppViewPos viewPos, CppQualifiedNamePart name, BlockShadersLookupType blockShadersLookupType, Nullable`1<CppQualifiedNamePart> interfaceName);
    private static FrugalLocalList`1<ICppResolveEntity> LookupEntitiesInScope(ICppScopeResolveEntity scope, CppQualifiedNamePart name, CppLocationAnchor anchor, BlockShadersLookupType blockShadersLookupType);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BlockShadersResolveEntity : CppScopeResolveEntityBase {
    [CompilerGeneratedAttribute]
private ICppParserSymbol <symbol>P;
    [CompilerGeneratedAttribute]
private CppDeclaredElementType <declaredElementType>P;
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppDeclaredElementType DeclaredElementType { get; }
    protected BlockShadersResolveEntity(ICppResolveEntityParent parent, ICppParserSymbol symbol, CppLocationAnchor locationAnchor, CppDeclaredElementType declaredElementType);
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public CppDeclaredElementType get_DeclaredElementType();
    public virtual TResult Accept(ICppResolveEntityVisitor`1<TResult> visitor);
    public virtual string ToString();
    public virtual CppQualRefEntities ClassifyBSResolveEntity();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BlockShadersResolveEntity`1 : BlockShadersResolveEntity {
    [CompilerGeneratedAttribute]
private T <symbol>P;
    public T Symbol { get; }
    protected BlockShadersResolveEntity`1(ICppResolveEntity parent, T symbol, CppLocationAnchor locationAnchor, CppDeclaredElementType declaredElementType);
    public T get_Symbol();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSAttributeData : object {
    [CompilerGeneratedAttribute]
private string <name>P;
    [CompilerGeneratedAttribute]
private CppList`1<IBSAttributeParameter> <parameters>P;
    public CppList`1<IBSAttributeParameter> Parameters { get; }
    public BSAttributeData(string name, CppList`1<IBSAttributeParameter> parameters);
    public BSKnownAttributeType GetType();
    public CppList`1<IBSAttributeParameter> get_Parameters();
    public string GetName();
    public virtual bool Equals(object obj);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSAttributeNamedParameter : object {
    public string Identifier;
    public IBSAttributeParameterValue Value;
    public BSAttributeNamedParameter(string identifier, IBSAttributeParameterValue value);
    public virtual bool Equals(object obj);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSAttributeParameterStandaloneValue : IBSAttributeParameterValue {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public BSAttributeParameterStandaloneValue(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    public virtual bool Equals(object obj);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSAttributeParameterValueList : IBSAttributeParameterValue {
    [CompilerGeneratedAttribute]
private CppList`1<IBSAttributeParameterValue> <Values>k__BackingField;
    public CppList`1<IBSAttributeParameterValue> Values { get; }
    public BSAttributeParameterValueList(CppList`1<IBSAttributeParameterValue> values);
    [CompilerGeneratedAttribute]
public CppList`1<IBSAttributeParameterValue> get_Values();
    public void Add(IBSAttributeParameterValue paramValue, int depth);
    public virtual bool Equals(object obj);
}
public static class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSAttributeUtils : object {
    private static Dictionary`2<string, BSKnownAttributeType> ourAttributeTypes;
    private static BSAttributeUtils();
    public static BSKnownAttributeType GetAttributeTypeByName(string name);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSBlockModuleEntity : object {
    private ICppScopeModuleEntity myParent;
    private BSBlockSymbol mySymbol;
    public BSBlockModuleEntity(ICppScopeModuleEntity parent, BSBlockSymbol symbol);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual ICppScopeModuleEntity GetParent();
    public sealed virtual bool IsExplicitlyExported();
    public ICppResolveEntity Import(ICppScopeResolveEntity parent, CppLocationAnchor anchor);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSBlockResolveEntity : BlockShadersResolveEntity`1<BSBlockSymbol> {
    public BSBlockResolveEntity(ICppResolveEntity parent, BSBlockSymbol symbol, CppLocationAnchor locationAnchor);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSBlockShaderInterfaceModuleEntity : object {
    private ICppScopeModuleEntity myParent;
    private BSBlockShaderInterfaceSymbol mySymbol;
    public BSBlockShaderInterfaceModuleEntity(ICppScopeModuleEntity parent, BSBlockShaderInterfaceSymbol symbol);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public sealed virtual CppImportResult`1<ICppScopeResolveEntity> ImportScopeAutoParent(CppModuleImportingContext ctx);
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual ICppScopeModuleEntity GetParent();
    public sealed virtual bool IsExplicitlyExported();
    public sealed virtual ICppResolveEntity Import(CppModuleImportingContext ctx, ICppScopeResolveEntity parent, CppLocationAnchor anchor);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSBlockShaderInterfaceResolveEntity : BlockShadersResolveEntity`1<BSBlockShaderInterfaceSymbol> {
    public BSBlockShaderInterfaceResolveEntity(ICppResolveEntity parent, BSBlockShaderInterfaceSymbol symbol, CppLocationAnchor locationAnchor);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSBlockShaderInterfaceSymbol : BSScopeSymbol {
    public BSBlockShaderInterfaceSymbol(CppQualifiedName name, CppSymbolLocation loc);
    public virtual TResult Accept(ICppSymbolVisitor`1<TResult> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSBlockShaderModuleEntity : object {
    private ICppScopeModuleEntity myParent;
    private BSBlockShaderSymbol mySymbol;
    public BSBlockShaderModuleEntity(ICppScopeModuleEntity parent, BSBlockShaderSymbol symbol);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public sealed virtual CppImportResult`1<ICppScopeResolveEntity> ImportScopeAutoParent(CppModuleImportingContext ctx);
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual ICppScopeModuleEntity GetParent();
    public sealed virtual bool IsExplicitlyExported();
    public sealed virtual ICppResolveEntity Import(CppModuleImportingContext ctx, ICppScopeResolveEntity parent, CppLocationAnchor anchor);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSBlockShaderResolveEntity : BlockShadersResolveEntity`1<BSBlockShaderSymbol> {
    public BSBlockShaderResolveEntity(ICppResolveEntity parent, BSBlockShaderSymbol symbol, CppLocationAnchor locationAnchor);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSBlockShaderSymbol : BSScopeSymbol {
    public CppList`1<CppQualifiedNamePart> ImplementedInterfaces;
    public BSBlockShaderSymbol(CppQualifiedName name, CppSymbolLocation loc);
    public virtual TResult Accept(ICppSymbolVisitor`1<TResult> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSBlockSymbol : BSScopeSymbol {
    public CppList`1<BSInterfaceMemberData> Members;
    public BSBlockSymbol(CppQualifiedName name, CppSymbolLocation loc);
    public virtual TResult Accept(ICppSymbolVisitor`1<TResult> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSCustomizationPointImplementationModuleEntity : object {
    private ICppModuleEntity myParent;
    private BSCustomizationPointImplementationSymbol mySymbol;
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSCustomizationPointImplementationResolveEntity : BlockShadersResolveEntity`1<BSCustomizationPointImplementationSymbol> {
    public BSCustomizationPointImplementationResolveEntity(ICppResolveEntity parent, BSCustomizationPointImplementationSymbol symbol, CppLocationAnchor locationAnchor);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSCustomizationPointImplementationSymbol : BSScopeSymbol {
    public BSCustomizationPointImplementationSymbol(CppQualifiedName name, CppSymbolLocation loc);
    public virtual TResult Accept(ICppSymbolVisitor`1<TResult> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSCustomizationPointModuleEntity : object {
    private ICppModuleEntity myParent;
    private BSCustomizationPointSymbol mySymbol;
    public BSCustomizationPointModuleEntity(ICppModuleEntity parent, BSCustomizationPointSymbol symbol);
    public BSCustomizationPointSymbol GetSymbol();
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public ICppResolveEntity Import(ICppScopeResolveEntity parent, CppLocationAnchor anchor);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSCustomizationPointResolveEntity : BlockShadersResolveEntity`1<BSCustomizationPointSymbol> {
    public BSCustomizationPointResolveEntity(ICppResolveEntity parent, BSCustomizationPointSymbol symbol, CppLocationAnchor locationAnchor);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSCustomizationPointResolveEntityExtensions : object {
    [ExtensionAttribute]
public static BSBlockShaderInterfaceResolveEntity GetParentBlockShaderInterface(BSCustomizationPointResolveEntity ent);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSCustomizationPointSymbol : BSScopeSymbol {
    public CppList`1<BSInterfaceMemberData> Members;
    public BSCustomizationPointSymbol(CppQualifiedName name, CppSymbolLocation loc);
    public virtual TResult Accept(ICppSymbolVisitor`1<TResult> visitor);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSInterfaceMemberData : ValueType {
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <name>P;
    [CompilerGeneratedAttribute]
private BSInterfaceMemberFlowType <flowType>P;
    [CompilerGeneratedAttribute]
private CppList`1<BSAttributeData> <attributes>P;
    public static IEqualityComparer`1<BSInterfaceMemberData> EqualityComparer;
    public CppQualifiedNamePart Name { get; }
    public BSInterfaceMemberFlowType FlowType { get; }
    public CppList`1<BSAttributeData> Attributes { get; }
    public BSInterfaceMemberData(CppQualifiedNamePart name, BSInterfaceMemberFlowType flowType, CppList`1<BSAttributeData> attributes);
    private static BSInterfaceMemberData();
    public CppQualifiedNamePart get_Name();
    public BSInterfaceMemberFlowType get_FlowType();
    public CppList`1<BSAttributeData> get_Attributes();
    public bool Equals(BSInterfaceMemberData data);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSInterfaceMemberDataModuleEntity : object {
    [CompilerGeneratedAttribute]
private BSInterfaceMemberData <data>P;
    private BSInterfaceMemberData Data { get; }
    public BSInterfaceMemberDataModuleEntity(BSInterfaceMemberData data);
    private BSInterfaceMemberData get_Data();
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public static CppSlice MarshalRange(ReadOnlySpan`1<BSInterfaceMemberData> members, CppModuleMarshallingContext context);
    public static CppList`1<BSInterfaceMemberData> UnmarshalCppList(CppSlice slice, CppModuleUnmarshallingContext context);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSInterfaceMemberFlowType : Enum {
    public byte value__;
    public static BSInterfaceMemberFlowType None;
    public static BSInterfaceMemberFlowType In;
    public static BSInterfaceMemberFlowType Out;
    public static BSInterfaceMemberFlowType InOut;
}
public enum JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSKnownAttributeType : Enum {
    public byte value__;
    public static BSKnownAttributeType None;
    public static BSKnownAttributeType Default;
    public static BSKnownAttributeType Property;
    public static BSKnownAttributeType Texture;
    public static BSKnownAttributeType SampledTexture;
    public static BSKnownAttributeType System;
}
public abstract class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSScopeSymbol : CppScopeSymbol {
    private CppComplexOffset myBodyStartOffset;
    private CppComplexOffset myBodyEndOffset;
    protected BSScopeSymbol(CppQualifiedName name, CppSymbolLocation loc);
    public sealed virtual void SetBodyStartOffset(CppComplexOffset offset);
    public sealed virtual CppComplexOffset GetBodyStartOffset();
    public sealed virtual void SetBodyEndOffset(CppComplexOffset offset);
    public sealed virtual CppComplexOffset GetBodyEndOffset();
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSTemplateModuleEntity : object {
    private ICppScopeModuleEntity myParent;
    private BSTemplateSymbol mySymbol;
    public BSTemplateModuleEntity(ICppScopeModuleEntity parent, BSTemplateSymbol symbol);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public sealed virtual CppImportResult`1<ICppScopeResolveEntity> ImportScopeAutoParent(CppModuleImportingContext ctx);
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual ICppScopeModuleEntity GetParent();
    public sealed virtual bool IsExplicitlyExported();
    public sealed virtual ICppResolveEntity Import(CppModuleImportingContext ctx, ICppScopeResolveEntity parent, CppLocationAnchor anchor);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSTemplateResolveEntity : BlockShadersResolveEntity`1<BSTemplateSymbol> {
    public BSTemplateResolveEntity(ICppResolveEntity parent, BSTemplateSymbol symbol, CppLocationAnchor locationAnchor);
}
public class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.BSTemplateSymbol : BSScopeSymbol {
    public BSTemplateSymbol(CppQualifiedName name, CppSymbolLocation loc);
    public virtual TResult Accept(ICppSymbolVisitor`1<TResult> visitor);
}
public interface JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.IBlockShadersScopeModuleEntity {
    public abstract virtual ICppResolveEntity Import(CppModuleImportingContext ctx, ICppScopeResolveEntity parent, CppLocationAnchor anchor);
}
public interface JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.IBSAttributeParameter {
}
public abstract class JetBrains.ReSharper.Psi.Cpp.BlockShaders.Symbols.IBSAttributeParameterValue : object {
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.ArgumentListMarshaller : CppPolymorphicMarshaller`1<CppArgumentList> {
    public virtual void Marshal(CppMarshallingContext context, CppArgumentList value);
    public virtual CppArgumentList Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppAliasDeclarationSymbolMarshaller : CppPolymorphicMarshaller`1<CppAliasDeclarationSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppAliasDeclarationSymbol value);
    public virtual CppAliasDeclarationSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppAlignOfExpressionMarshaller : CppPolymorphicMarshaller`1<CppAlignOfExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppAlignOfExpression value);
    public virtual CppAlignOfExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppAllByRefLambdaCaptureMarshaller : CppPolymorphicMarshaller`1<CppAllByRefLambdaCapture> {
    public virtual void Marshal(CppMarshallingContext context, CppAllByRefLambdaCapture value);
    public virtual CppAllByRefLambdaCapture Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppAllByValueLambdaCaptureMarshaller : CppPolymorphicMarshaller`1<CppAllByValueLambdaCapture> {
    public virtual void Marshal(CppMarshallingContext context, CppAllByValueLambdaCapture value);
    public virtual CppAllByValueLambdaCapture Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppAnonymousCStructDeclarationSymbolMarshaller : CppPolymorphicMarshaller`1<CppAnonymousCStructDeclarationSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppAnonymousCStructDeclarationSymbol value);
    public virtual CppAnonymousCStructDeclarationSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppAnonymousIdMarshaller : CppPolymorphicMarshaller`1<CppAnonymousId> {
    public virtual void Marshal(CppMarshallingContext context, CppAnonymousId value);
    public virtual CppAnonymousId Unmarshal(CppUnmarshallingContext context);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppAnonymousNameHelper : object {
    public virtual int GetSymbolLocationHash(ICppParserSymbol symbol);
    public virtual int GetContainingSymbolFileHash(ICppParserSymbol symbol);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppArrayTypeMarshaller : CppPolymorphicMarshaller`1<CppArrayType> {
    public virtual void Marshal(CppMarshallingContext context, CppArrayType value);
    public virtual CppArrayType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppAttributeFormatMarshaller : CppPolymorphicMarshaller`1<CppAttributeFormat> {
    public virtual void Marshal(CppMarshallingContext context, CppAttributeFormat value);
    public virtual CppAttributeFormat Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppAttributeListMarshaller : object {
    public static CppAttributeListMarshaller Instance;
    private static CppAttributeListMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppAttributeList value);
    public sealed virtual CppAttributeList Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppAttributeMarshaller : CppPolymorphicMarshaller`1<CppAttribute> {
    public virtual void Marshal(CppMarshallingContext context, CppAttribute value);
    public virtual CppAttribute Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppAttributeNameMarshaller : object {
    public static CppAttributeNameMarshaller Instance;
    private static CppAttributeNameMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppAttributeName name);
    public sealed virtual CppAttributeName Unmarshal(CppUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppAttributeWithArgumentMarshaller`1 : CppPolymorphicMarshaller`1<CppAttributeWithArgument`1<TArg>> {
    public virtual void Marshal(CppMarshallingContext context, CppAttributeWithArgument`1<TArg> value);
    public virtual CppAttributeWithArgument`1<TArg> Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppAttributeWithArgumentsMarshaller : CppPolymorphicMarshaller`1<CppAttributeWithArguments`1<CppStringLiteralValue>> {
    public virtual void Marshal(CppMarshallingContext context, CppAttributeWithArguments`1<CppStringLiteralValue> value);
    public virtual CppAttributeWithArguments`1<CppStringLiteralValue> Unmarshal(CppUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppBaseDescriptionWithNameMarshaller : object {
    public static CppBaseDescriptionWithNameMarshaller Instance;
    private static CppBaseDescriptionWithNameMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppBasicBaseDescription`1<CppQualifiedName> value);
    public sealed virtual CppBasicBaseDescription`1<CppQualifiedName> Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppBaseTypeConstraintMarshaller : CppPolymorphicMarshaller`1<CppBaseTypeConstraint> {
    public virtual void Marshal(CppMarshallingContext context, CppBaseTypeConstraint value);
    public virtual CppBaseTypeConstraint Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppBinaryExpressionMarshaller : CppPolymorphicMarshaller`1<CppBinaryExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppBinaryExpression value);
    public virtual CppBinaryExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppBoolValueExpressionMarshaller : CppPolymorphicMarshaller`1<CppBoolValue> {
    public virtual void Marshal(CppMarshallingContext context, CppBoolValue value);
    public virtual CppBoolValue Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppBracedInitListExpressionMarshaller : CppPolymorphicMarshaller`1<CppBracedInitListExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppBracedInitListExpression value);
    public virtual CppBracedInitListExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppBraceInitializedTemporaryExpressionMarshaller : CppPolymorphicMarshaller`1<CppBraceInitializedTemporaryExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppBraceInitializedTemporaryExpression value);
    public virtual CppBraceInitializedTemporaryExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppBuiltinAddressOfExpressionMarshaller : CppPolymorphicMarshaller`1<CppBuiltinAddressOfExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppBuiltinAddressOfExpression value);
    public virtual CppBuiltinAddressOfExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppBuiltinOffsetOfExpressionMarshaller : CppPolymorphicMarshaller`1<CppBuiltinOffsetOfExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppBuiltinOffsetOfExpression value);
    public virtual CppBuiltinOffsetOfExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppBuiltinTypeTraitTypeMarshaller : CppPolymorphicMarshaller`1<CppBuiltinTypeTraitType> {
    public virtual void Marshal(CppMarshallingContext context, CppBuiltinTypeTraitType value);
    public virtual CppBuiltinTypeTraitType Unmarshal(CppUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppC11GenericExpressionClauseMarshaller : object {
    public static CppC11GenericExpressionClauseMarshaller Instance;
    private static CppC11GenericExpressionClauseMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppC11GenericExpressionClause value);
    public sealed virtual CppC11GenericExpressionClause Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppC11GenericExpressionMarshaller : CppPolymorphicMarshaller`1<CppC11GenericExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppC11GenericExpression value);
    public virtual CppC11GenericExpression Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppCachedMarshaller`1 : object {
    private ICppMarshaller`1<T> myMarshaller;
    public CppCachedMarshaller`1(ICppMarshaller`1<T> marshaller);
    public virtual void Marshal(CppMarshallingContext context, T value);
    public virtual T Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCallExpressionMarshaller : CppPolymorphicMarshaller`1<CppCallExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppCallExpression value);
    public virtual CppCallExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCastExpressionMarshaller : CppPolymorphicMarshaller`1<CppCastExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppCastExpression value);
    public virtual CppCastExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCatchBlockSymbolMarshaller : CppPolymorphicMarshaller`1<CppCatchBlockSymbol> {
    public static CppCatchBlockSymbolMarshaller Instance;
    private static CppCatchBlockSymbolMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppCatchBlockSymbol value);
    public sealed virtual CppCatchBlockSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppChar16ValueExpressionMarshaller : CppPolymorphicMarshaller`1<Char16T> {
    public virtual void Marshal(CppMarshallingContext context, Char16T value);
    public virtual Char16T Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppChar32ValueExpressionMarshaller : CppPolymorphicMarshaller`1<Char32T> {
    public virtual void Marshal(CppMarshallingContext context, Char32T value);
    public virtual Char32T Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppChar8ValueExpressionMarshaller : CppPolymorphicMarshaller`1<Char8T> {
    public virtual void Marshal(CppMarshallingContext context, Char8T value);
    public virtual Char8T Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCharValueExpressionMarshaller : CppPolymorphicMarshaller`1<Char> {
    public virtual void Marshal(CppMarshallingContext context, Char value);
    public virtual Char Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppClassSymbolMarshaller : CppPolymorphicMarshaller`1<CppClassSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppClassSymbol value);
    public virtual CppClassSymbol Unmarshal(CppUnmarshallingContext context);
    internal static UInt32 Pack(CppClassKey classKey, CppAccessibility accessibility, CppClassVirtualSpecifiers virtualSpecifiers, byte flags);
    internal static ValueTuple`4<CppClassKey, CppAccessibility, CppClassVirtualSpecifiers, UInt32> Unpack(UInt32 unitedBitSet);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppClassTypeMarshaller : CppPolymorphicMarshaller`1<CppClassType> {
    public virtual void Marshal(CppMarshallingContext context, CppClassType value);
    public virtual CppClassType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCliArrayTypeMarshaller : CppPolymorphicMarshaller`1<CppCliArrayType> {
    public virtual void Marshal(CppMarshallingContext context, CppCliArrayType value);
    public virtual CppCliArrayType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCliFinalizerTagMarshaller : CppPolymorphicMarshaller`1<CppCliFinalizerTag> {
    public virtual void Marshal(CppMarshallingContext context, CppCliFinalizerTag value);
    public virtual CppCliFinalizerTag Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCliHandleTypeMarshaller : CppPolymorphicMarshaller`1<CppCliHandleType> {
    public virtual void Marshal(CppMarshallingContext context, CppCliHandleType value);
    public virtual CppCliHandleType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCliInteriorPointerTypeMarshaller : CppPolymorphicMarshaller`1<CppCliInteriorPointerType> {
    public virtual void Marshal(CppMarshallingContext context, CppCliInteriorPointerType value);
    public virtual CppCliInteriorPointerType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCliMultiArgumentSubscriptExpressionMarshaller : CppPolymorphicMarshaller`1<CppCliMultiArgumentSubscriptExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppCliMultiArgumentSubscriptExpression value);
    public virtual CppCliMultiArgumentSubscriptExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCliPinPointerTypeMarshaller : CppPolymorphicMarshaller`1<CppCliPinPointerType> {
    public virtual void Marshal(CppMarshallingContext context, CppCliPinPointerType value);
    public virtual CppCliPinPointerType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCliSimpleTypeIdMarshaller : CppPolymorphicMarshaller`1<CppCliSimpleTypeId> {
    public virtual void Marshal(CppMarshallingContext context, CppCliSimpleTypeId value);
    public virtual CppCliSimpleTypeId Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCliTypeIdExpressionMarshaller : CppPolymorphicMarshaller`1<CppCliTypeIdExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppCliTypeIdExpression value);
    public virtual CppCliTypeIdExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCoAwaitExpressionMarshaller : CppPolymorphicMarshaller`1<CppCoAwaitExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppCoAwaitExpression value);
    public virtual CppCoAwaitExpression Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppCollectionMarshaller`2 : object {
    private ICppMarshaller`1<T> myItemMarshaller;
    public CppCollectionMarshaller`2(ICppMarshaller`1<T> itemMarshaller);
    public sealed virtual void Marshal(CppMarshallingContext context, TCol value);
    public sealed virtual TCol Unmarshal(CppUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppComplexOffsetMarshaller : object {
    public static CppComplexOffsetMarshaller Instance;
    private static CppComplexOffsetMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppComplexOffset value);
    public sealed virtual CppComplexOffset Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCompoundStatementInExpressionSymbolMarshaller : CppPolymorphicMarshaller`1<CppCompoundStatementInExpressionSymbol> {
    public static CppCompoundStatementInExpressionSymbolMarshaller Instance;
    private static CppCompoundStatementInExpressionSymbolMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppCompoundStatementInExpressionSymbol value);
    public sealed virtual CppCompoundStatementInExpressionSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCompoundStatementSymbolMarshaller : CppPolymorphicMarshaller`1<CppCompoundStatementSymbol> {
    public static CppCompoundStatementSymbolMarshaller Instance;
    private static CppCompoundStatementSymbolMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppCompoundStatementSymbol value);
    public sealed virtual CppCompoundStatementSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppConceptDefinitionSymbolMarshaller : CppPolymorphicMarshaller`1<CppConceptDefinitionSymbol> {
    public static CppConceptDefinitionSymbolMarshaller Instance;
    private static CppConceptDefinitionSymbolMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppConceptDefinitionSymbol value);
    public virtual CppConceptDefinitionSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppConceptTypeTemplateParameterPackSymbolMarshaller : CppPolymorphicMarshaller`1<CppConceptTypeTemplateParameterPackSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppConceptTypeTemplateParameterPackSymbol value);
    public virtual CppConceptTypeTemplateParameterPackSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppConceptTypeTemplateParameterSymbolMarshaller : CppPolymorphicMarshaller`1<CppConceptTypeTemplateParameterSymbol> {
    public static CppConceptTypeTemplateParameterSymbolMarshaller Instance;
    private static CppConceptTypeTemplateParameterSymbolMarshaller();
    public virtual void Marshal(CppMarshallingContext context, CppConceptTypeTemplateParameterSymbol value);
    public virtual CppConceptTypeTemplateParameterSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppConceptTypeTemplateParameterWithArgumentSymbolMarshaller : CppPolymorphicMarshaller`1<CppConceptTypeTemplateParameterWithArgumentSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppConceptTypeTemplateParameterWithArgumentSymbol value);
    public virtual CppConceptTypeTemplateParameterWithArgumentSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppConditionalExpressionMarshaller : CppPolymorphicMarshaller`1<CppConditionalExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppConditionalExpression value);
    public virtual CppConditionalExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppConversionIdMarshaller : CppPolymorphicMarshaller`1<CppConversionId> {
    public virtual void Marshal(CppMarshallingContext context, CppConversionId value);
    public virtual CppConversionId Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppCountingSetMarshaller`1 : object {
    private IEqualityComparer`1<T> myComparer;
    private ICppMarshaller`1<T> myItemMarshaller;
    public CppCountingSetMarshaller`1(ICppMarshaller`1<T> itemMarshaller, IEqualityComparer`1<T> comparer);
    public virtual void Marshal(CppMarshallingContext context, CountingSet`1<T> value);
    public virtual CountingSet`1<T> Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCoYieldExpressionMarshaller : CppPolymorphicMarshaller`1<CppCoYieldExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppCoYieldExpression value);
    public virtual CppCoYieldExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCtorInitializerStatementSymbolMarshaller : CppPolymorphicMarshaller`1<CppCtorInitializerStatementSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppCtorInitializerStatementSymbol value);
    public virtual CppCtorInitializerStatementSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCxxCliDelegateSymbolMarshaller : CppPolymorphicMarshaller`1<CppCxxCliDelegateSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppCxxCliDelegateSymbol value);
    public virtual CppCxxCliDelegateSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppCxxCliPropertySymbolMarshaller : CppPolymorphicMarshaller`1<CppCxxCliPropertySymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppCxxCliPropertySymbol value);
    public virtual CppCxxCliPropertySymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDeclarationSpecifierTypeMarshaller : CppPolymorphicMarshaller`1<CppDeclarationSpecifierType> {
    public virtual void Marshal(CppMarshallingContext context, CppDeclarationSpecifierType value);
    public virtual CppDeclarationSpecifierType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDeclarationSymbolMarshaller : CppPolymorphicMarshaller`1<CppDeclarationSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppDeclarationSymbol value);
    public virtual CppDeclarationSymbol Unmarshal(CppUnmarshallingContext context);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Caches.CppDeclaratorInitializerMarshaller : object {
    [ExtensionAttribute]
public static void MarshalInitializer(CppMarshallingContext context, CppDeclaratorInitializer initializer);
    [ExtensionAttribute]
public static CppDeclaratorInitializer UnmarshalInitializer(CppUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDeclaratorSymbolMarshaller : object {
    public static void Marshal(CppMarshallingContext context, CppDeclaratorSymbol value);
    public static RawData UnmarshalData(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDeclaratorWithAttributesSymbolMarshaller : CppPolymorphicMarshaller`1<CppDeclaratorWithAttributesSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppDeclaratorWithAttributesSymbol value);
    public virtual CppDeclaratorWithAttributesSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDeclaratorWithFuncBodySymbolMarshaller : CppPolymorphicMarshaller`1<CppDeclaratorWithFuncBodySymbol> {
    public static CppDeclaratorWithFuncBodySymbolMarshaller Instance;
    private static CppDeclaratorWithFuncBodySymbolMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppDeclaratorWithFuncBodySymbol value);
    public static RawData UnmarshalData(CppUnmarshallingContext context, CppUnpackedQualTypeAndInitializer& typeAndInitializer, CppSymbolTemplateParametersList& paramList, CppCompoundStatementSymbol& funcBody);
    public virtual CppDeclaratorWithFuncBodySymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDeclaratorWithInitializerSymbolMarshaller : CppPolymorphicMarshaller`1<CppDeclaratorWithInitializerSymbol> {
    public static CppDeclaratorWithInitializerSymbolMarshaller Instance;
    private static CppDeclaratorWithInitializerSymbolMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppDeclaratorWithInitializerSymbol value);
    public static RawData UnmarshalData(CppUnmarshallingContext context, CppUnpackedQualTypeAndInitializer& typeAndInitializer);
    public virtual CppDeclaratorWithInitializerSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDeclaratorWithTemplateParametersSymbolMarshaller : CppPolymorphicMarshaller`1<CppDeclaratorWithTemplateParametersSymbol> {
    public static CppDeclaratorWithTemplateParametersSymbolMarshaller Instance;
    private static CppDeclaratorWithTemplateParametersSymbolMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppDeclaratorWithTemplateParametersSymbol value);
    public static RawData UnmarshalData(CppUnmarshallingContext context, CppUnpackedQualTypeAndInitializer& typeAndInitializer, CppSymbolTemplateParametersList& paramList);
    public virtual CppDeclaratorWithTemplateParametersSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDecltypeDestructorTagMarshaller : CppPolymorphicMarshaller`1<CppDecltypeDestructorTag> {
    public virtual void Marshal(CppMarshallingContext context, CppDecltypeDestructorTag value);
    public virtual CppDecltypeDestructorTag Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDecltypeIdMarshaller : CppPolymorphicMarshaller`1<CppDecltypeId> {
    public virtual void Marshal(CppMarshallingContext context, CppDecltypeId value);
    public virtual CppDecltypeId Unmarshal(CppUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDefineKeyMarshaller : object {
    public static CppDefineKeyMarshaller Instance;
    public static CppKeyValuePairMarshaller`2<CppDefineKey, int> DefinitionMarshallerInstance;
    private static CppDefineKeyMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppDefineKey value);
    public sealed virtual CppDefineKey Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDeleteExpressionMarshaller : CppPolymorphicMarshaller`1<CppDeleteExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppDeleteExpression value);
    public virtual CppDeleteExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDesignationMarshaller : CppPolymorphicMarshaller`1<CppDesignation> {
    public virtual void Marshal(CppMarshallingContext context, CppDesignation value);
    public virtual CppDesignation Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDestructorTagMarshaller : CppPolymorphicMarshaller`1<CppDestructorTag> {
    public virtual void Marshal(CppMarshallingContext context, CppDestructorTag value);
    public virtual CppDestructorTag Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDiscardedValueExpressionMarshaller : CppPolymorphicMarshaller`1<CppDiscardedIntValueExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppDiscardedIntValueExpression e);
    public virtual CppDiscardedIntValueExpression Unmarshal(CppUnmarshallingContext context);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppDocumentBuffer : ValueType {
    public IBuffer Buffer;
    public TextRange Range;
    public CppDocumentBuffer(IBuffer buffer);
    public CppDocumentBuffer(IBuffer buffer, TextRange range);
    public IBuffer GetProjectedBuffer();
    public static CppDocumentBuffer MakeInvalid();
    public bool IsValid();
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDoStatementSymbolMarshaller : CppPolymorphicMarshaller`1<CppDoStatementSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppDoStatementSymbol value);
    public virtual CppDoStatementSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDoubleArgumentTypeTraitExpressionMarshaller : CppPolymorphicMarshaller`1<CppDoubleArgumentTypeTraitExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppDoubleArgumentTypeTraitExpression value);
    public virtual CppDoubleArgumentTypeTraitExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDoubleValueExpressionMarshaller : CppPolymorphicMarshaller`1<Double> {
    public virtual void Marshal(CppMarshallingContext context, Double value);
    public virtual Double Unmarshal(CppUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDynamicExceptionSpecificationElementMarshaller : object {
    public static CppDynamicExceptionSpecificationElementMarshaller Instance;
    private static CppDynamicExceptionSpecificationElementMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, Element value);
    public sealed virtual Element Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppDynamicExceptionSpecificationMarshaller : CppPolymorphicMarshaller`1<CppDynamicExceptionSpecification> {
    public virtual void Marshal(CppMarshallingContext context, CppDynamicExceptionSpecification value);
    public virtual CppDynamicExceptionSpecification Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppElaboratedTypeReferenceMarshaller : CppPolymorphicMarshaller`1<CppElaboratedTypeReference> {
    public virtual void Marshal(CppMarshallingContext context, CppElaboratedTypeReference value);
    public virtual CppElaboratedTypeReference Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppEmptyExpressionMarshaller : CppPolymorphicMarshaller`1<CppEmptyExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppEmptyExpression value);
    public virtual CppEmptyExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppEnumeratorSymbolMarshaller : CppPolymorphicMarshaller`1<CppEnumeratorSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppEnumeratorSymbol value);
    public virtual CppEnumeratorSymbol Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppEnumMarshaller`1 : object {
    public static CppEnumMarshaller`1<TEnum> Instance;
    private static CppEnumMarshaller`1();
    public virtual void Marshal(CppMarshallingContext context, TEnum value);
    public virtual TEnum Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppEnumTypeMarshaller : CppPolymorphicMarshaller`1<CppEnumType> {
    public virtual void Marshal(CppMarshallingContext context, CppEnumType value);
    public virtual CppEnumType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppEnumWithBaseSymbolMarshaller : CppPolymorphicMarshaller`1<CppEnumWithBaseSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppEnumWithBaseSymbol value);
    public virtual CppEnumWithBaseSymbol Unmarshal(CppUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppExceptionSpecificationMarshaller : object {
    public static ICppMarshaller`1<ICppExceptionSpecification> Instance;
    private static CppExceptionSpecificationMarshaller();
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppExportBlockSymbolMarshaller : CppPolymorphicMarshaller`1<CppExportBlockSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppExportBlockSymbol value);
    public virtual CppExportBlockSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppExpressionAttributeMarshaller : CppAttributeWithArgumentMarshaller`1<ICppExpression> {
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppExpressionMarshaller : object {
    public static CppExpressionMarshaller Instance;
    private static CppExpressionMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, ICppExpression value);
    public sealed virtual ICppExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppExpressionStatementSymbolMarshaller : CppPolymorphicMarshaller`1<CppExpressionStatementSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppExpressionStatementSymbol value);
    public virtual CppExpressionStatementSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppExpressionTemplateArgumentMarshaller : CppPolymorphicMarshaller`1<CppExpressionTemplateArgument> {
    public static CppExpressionTemplateArgumentMarshaller Instance;
    private static CppExpressionTemplateArgumentMarshaller();
    public virtual void Marshal(CppMarshallingContext context, CppExpressionTemplateArgument value);
    public virtual CppExpressionTemplateArgument Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppExpressionTemplateArgumentPackMarshaller : CppPolymorphicMarshaller`1<CppExpressionTemplateArgumentPack> {
    public virtual void Marshal(CppMarshallingContext context, CppExpressionTemplateArgumentPack value);
    public virtual CppExpressionTemplateArgumentPack Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppExpressionTemplateParameterPackSymbolMarshaller : CppPolymorphicMarshaller`1<CppExpressionTemplateParameterPackSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppExpressionTemplateParameterPackSymbol value);
    public virtual CppExpressionTemplateParameterPackSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppExpressionTemplateParameterSymbolMarshaller : CppPolymorphicMarshaller`1<CppExpressionTemplateParameterSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppExpressionTemplateParameterSymbol value);
    public virtual CppExpressionTemplateParameterSymbol Unmarshal(CppUnmarshallingContext context);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Caches.CppExternalModule : UserDataHolder {
    public string Name { get; }
    public string DisplayName { get; }
    public TargetFrameworkId TargetFrameworkId { get; }
    public PsiLanguageType PsiLanguage { get; }
    public ProjectFileType ProjectFileType { get; }
    public IModule ContainingProjectModule { get; }
    public IEnumerable`1<IPsiSourceFile> SourceFiles { get; }
    public virtual object Execute(IChangeMap changeMap);
    public virtual string get_Name();
    public virtual string get_DisplayName();
    public virtual TargetFrameworkId get_TargetFrameworkId();
    public abstract virtual IPsiServices GetPsiServices();
    public abstract virtual ISolution GetSolution();
    public virtual PsiLanguageType get_PsiLanguage();
    public virtual ProjectFileType get_ProjectFileType();
    public virtual IEnumerable`1<IPsiModuleReference> GetReferences(IModuleReferenceResolveContext ctx);
    public virtual IModule get_ContainingProjectModule();
    public abstract virtual IEnumerable`1<IPsiSourceFile> get_SourceFiles();
    public virtual ICollection`1<PreProcessingDirective> GetAllDefines();
    public virtual bool IsValid();
    public virtual string GetPersistentID();
    public abstract virtual IPsiSourceFile LookupFile(VirtualFileSystemPath path);
    public abstract virtual IPsiSourceFile LookupFileInAnyProject(VirtualFileSystemPath path);
    public abstract virtual IPsiSourceFile LookupInAnyProjectAndCreateFile(VirtualFileSystemPath path);
    public abstract virtual CppFileLocation[] GetOrCreateStandardLibraryFiles();
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileContextSignature : object {
    public static CppKeyValuePairMarshaller`2<string, List`1<int>> MacroPopsMarshallerInstance;
    private int myHashCodeCache;
    private CppFileLocation myFile;
    [CompilerGeneratedAttribute]
private CppDefineKey[] <Defined>k__BackingField;
    [CompilerGeneratedAttribute]
private CppDefineKey[] <NotDefined>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyValuePair`2[] <Definitions>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyValuePair`2[] <MacroPops>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TreatWChar_tAsBuiltInType>k__BackingField;
    public CppFileLocation File { get; }
    public CppDefineKey[] Defined { get; }
    public CppDefineKey[] NotDefined { get; }
    public KeyValuePair`2[] Definitions { get; }
    public KeyValuePair`2[] MacroPops { get; }
    public bool TreatWChar_tAsBuiltInType { get; }
    public CppFileContextSignature(CppFileLocation file, CppDefineKey[] defined, CppDefineKey[] notDefined, KeyValuePair`2[] definitions, KeyValuePair`2[] macroPops, bool treatWChar_tAsBuiltInType);
    private CppFileContextSignature(CppFileLocation file, CppDefineKey[] defined, CppDefineKey[] notDefined, KeyValuePair`2[] definitions, KeyValuePair`2[] macroPops, bool treatWChar_tAsBuiltInType, int hashCode);
    private static CppFileContextSignature();
    public CppFileLocation get_File();
    [CompilerGeneratedAttribute]
public CppDefineKey[] get_Defined();
    [CompilerGeneratedAttribute]
public CppDefineKey[] get_NotDefined();
    [CompilerGeneratedAttribute]
public KeyValuePair`2[] get_Definitions();
    [CompilerGeneratedAttribute]
public KeyValuePair`2[] get_MacroPops();
    [CompilerGeneratedAttribute]
public bool get_TreatWChar_tAsBuiltInType();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static void Marshal(CppMarshallingContext context, CppFileContextSignature value);
    public static CppFileContextSignature Unmarshal(CppUnmarshallingContext context);
    public static void Marshal(CppFileContextSignatureUnsafeMarshaller marshaller, UnsafeWriter writer, CppFileContextSignature value);
    public static CppFileContextSignature Unmarshal(CppFileContextSignatureUnsafeMarshaller marshaller, UnsafeReader reader);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileContextSignatureBuilder : object {
    private HashSet`1<CppDefineKey> myDefined;
    private Dictionary`2<CppDefineKey, int> myDefinitions;
    private CppFileLocation myFile;
    private Dictionary`2<string, List`1<int>> myMacroPopContext;
    private HashSet`1<CppDefineKey> myNotDefined;
    private bool myTreatWChar_tAsBuiltInType;
    public CppFileContextSignatureBuilder(CppFileLocation file, bool treatWChar_tAsBuiltInType);
    public void MarkDefinedOrNot(CppDefineKey name, bool isDefined);
    public void MarkMacroPop(string name, string substitution);
    public void MarkDefinition(CppDefineKey name, string substitution);
    public CppFileContextSignature BuildContextSignature();
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileContextSignatureMarshaller : object {
    public static CppFileContextSignatureMarshaller Instance;
    private static CppFileContextSignatureMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppFileContextSignature value);
    public sealed virtual CppFileContextSignature Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileContextSignatureUnsafeMarshaller : object {
    private ChunkList`1<CppFileLocation> myFiles;
    private CompactMap`2<CppFileLocation, int> myFileToId;
    private LockObject myLock;
    private ChunkList`1<string> myStrings;
    private CompactMap`2<string, int> myStringToId;
    public sealed virtual void Marshal(UnsafeWriter writer, CppFileContextSignature signature);
    public sealed virtual CppFileContextSignature Unmarshal(UnsafeReader reader);
    public void WriteFileLocation(UnsafeWriter writer, CppFileLocation file);
    public CppFileLocation ReadFileLocation(UnsafeReader reader);
    public void WriteString(UnsafeWriter writer, string str);
    public void WriteDefineKey(UnsafeWriter writer, CppDefineKey key);
    public string ReadString(UnsafeReader reader);
    public CppDefineKey ReadDefineKey(UnsafeReader reader);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileContextSignatureUtil : object {
    public static bool IsConformedToContext(CppFileContextSignature sig, CppInclusionContext context);
    public static void PushToContext(CppFileContextSignature sig, CppInclusionContext context);
    private static bool IsConformedToContextInternal(CppFileContextSignature sig, CppInclusionContext context, bool notify);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileLocation : ValueType {
    public static CppFileLocation EMPTY;
    public static CppFileLocation C_STANDARD_LIBRARY_FILE;
    public static CppFileLocation CPP_STANDARD_LIBRARY_FILE;
    private static CppFileLocation UE_BEFORE_53_GENERATED_HEADER_STUB_FILE;
    private static CppFileLocation UE_SINCE_53_GENERATED_HEADER_STUB_FILE;
    public static CppFileLocation[] ALL_STANDARD_LIBRARY_FILES;
    private static HashSet`1<CppFileLocation> ALL_UE_GENERATED_FILES;
    public static CppFileLocation[] ALL_LIBRARY_FILES;
    [CompilerGeneratedAttribute]
private IPath <Data>k__BackingField;
    public string Name { get; }
    public string FullPath { get; }
    public VirtualFileSystemPath Location { get; }
    public IPath Data { get; }
    public TextRange RootRange { get; }
    public CppFileLocation(CppExternalModule module, VirtualFileSystemPath path);
    public CppFileLocation(CppExternalModule module, CppFileLocation file);
    public CppFileLocation(IPsiSourceFile sourceFile);
    public CppFileLocation(IPsiSourceFile sourceFile, TextRange injectRange);
    public CppFileLocation(VirtualFileSystemPath path);
    public CppFileLocation(FileSystemPathWithRange path);
    private static CppFileLocation();
    public bool IsStandardLibraryFile();
    public bool IsUnrealGeneratedStubFile();
    public bool IsLibraryFile();
    [ObsoleteAttribute("Prefer overload that takes CppExternalModule")]
public IDocument GetDocument(ISolution solution);
    public IDocument GetDocument(ISolution solution, CppExternalModule externalModule);
    public IDocument TryGetDocument(ISolution solution);
    public CppDocumentBuffer GetDocumentBuffer(ISolution solution);
    public IProjectFile GetRandomProjectFile(ISolution solution);
    public FrugalLocalList`1<IProjectFile> GetAllProjectFiles(ISolution solution);
    public IProjectFile GetProjectFile(IProject project);
    public IProject GetRandomProject(ISolution solution);
    [ObsoleteAttribute("Prefer overload that takes CppExternalModule")]
public IPsiSourceFile GetRandomSourceFile(ISolution solution);
    public IPsiSourceFile GetRandomSourceFile(CppExternalModule externalModule);
    public IPsiSourceFile GetRandomSourceFileInNonSharedProject(ISolution solution, IProject projectHint);
    public CppSmallList`1<IPsiSourceFile> GetAllSourceFiles(ISolution solution, CppExternalModule externalModule);
    [ObsoleteAttribute("Prefer overload that takes CppExternalModule")]
public CppSmallList`1<IPsiSourceFile> GetAllSourceFiles(ISolution solution);
    public long GetAggregatedTimestamp(ISolution solution, CppExternalModule externalModule);
    public static CppFileLocation GetUnrealGeneratedStubFile(CppUE4Version version);
    public string get_Name();
    public string get_FullPath();
    public VirtualFileSystemPath get_Location();
    [CompilerGeneratedAttribute]
public IPath get_Data();
    public TextRange get_RootRange();
    public bool IsValid();
    public bool Exists();
    public bool IsInjected();
    public sealed virtual bool Equals(CppFileLocation other);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileLocationComparer : object {
    public static CppFileLocationComparer Instance;
    private static CppFileLocationComparer();
    public virtual int Compare(CppFileLocation lhs, CppFileLocation rhs);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileLocationMarshaller : object {
    public static CppFileLocationMarshaller Instance;
    private static CppFileLocationMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppFileLocation value);
    public sealed virtual CppFileLocation Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileLocationPersistentCache`1 : AbstractPersistentCache`2<CppFileLocation, TData> {
    private static int FILE_SIZE_MIN;
    private static int FILE_SIZE_MAX;
    private string myCacheDirectoryName;
    private IPersistentSortedMap`2<long, CppFileContextSignature> myContextSignatures;
    private CppExternalModule myExternalModule;
    private object myLock;
    private ILogger myLogger;
    private CppMarshallingContext myMarshallingContext;
    private string myName;
    private IPsiServices myPsiServices;
    private FileSystemPath mySolutionCacheFolder;
    private ICppMarshaller`1<TData> myValueMarshaller;
    private Byte[] myBytes;
    private IDictionary`2<CppFileLocation, TData> myData;
    private IProgressIndicator myProgress;
    private Dictionary`2<CppFileLocation, long> myTimestamps;
    private CppUnmarshallingIntern myUnmarshallingIntern;
    [CompilerGeneratedAttribute]
private int <FormatVersion>k__BackingField;
    protected FileSystemPath CacheDirectory { get; }
    protected int FormatVersion { get; }
    protected bool CheckTotalConsistency { get; }
    protected string LoadSaveProgressText { get; }
    protected int FileSizeMin { get; }
    protected int FileSizeMax { get; }
    public CppFileLocationPersistentCache`1(int formatVersion, string cacheDirectoryName, IPsiConfiguration psiConfiguration, IPsiServices psiServices, ILogger logger, string name, ICppMarshaller`1<TData> valueMarshaller, IPersistentSortedMap`2<long, CppFileContextSignature> contextSignatures, CppExternalModule externalModule);
    protected virtual FileSystemPath get_CacheDirectory();
    [CompilerGeneratedAttribute]
protected virtual int get_FormatVersion();
    protected virtual bool get_CheckTotalConsistency();
    protected virtual string get_LoadSaveProgressText();
    protected virtual int get_FileSizeMin();
    protected virtual int get_FileSizeMax();
    protected virtual bool IsKeyValid(CppFileLocation file);
    protected virtual void WriteKey(BinaryWriter writer, CppFileLocation file);
    protected virtual bool ReadKey(BinaryReader reader, CppFileLocation& fileLocation);
    protected virtual void DataLoaded(CppFileLocation key, TData data, bool keyValid, Action& waitToContinue);
    protected virtual IDisposable DataLock();
    protected virtual void WriteData(BinaryWriter writer, CppFileLocation key, TData data);
    protected virtual TData ReadData(ArraySegment`1<byte> bytes, CppFileLocation key);
    protected virtual TData ReadData(BinaryReader reader, CppFileLocation key);
    public CompactMap`2<CppFileLocation, TData> Load(IProgressIndicator progress, Dictionary`2<CppFileLocation, long> timestamps, CppUnmarshallingIntern unmarshallingIntern);
    public void Save(IProgressIndicator progress, Func`1<bool> checkForInterrupt);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileLocationUnsafeMarshaller : object {
    public static CppFileLocationUnsafeMarshaller Instance;
    private static CppFileLocationUnsafeMarshaller();
    public sealed virtual void Marshal(UnsafeWriter writer, CppFileLocation value);
    public sealed virtual CppFileLocation Unmarshal(UnsafeReader reader);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileLocationUtil : object {
    [ExtensionAttribute]
public static DocumentRange GetDocumentRange(CppFileLocation file, ISolution solution, int offset);
    [ExtensionAttribute]
public static string GetDisplayName(CppFileLocation file);
    [ExtensionAttribute]
public static bool IsNonUserFile(CppFileLocation file, ISolution solution);
}
[DebuggerDisplayAttribute("File = {File}")]
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileSymbols : object {
    private CppFileLocation myFile;
    [CompilerGeneratedAttribute]
private ICppSymbol[] <PreprocessorSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private CppNamespaceSymbol <GlobalNamespaceSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EqualityHashCode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReferenceCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InternCount>k__BackingField;
    public CppFileLocation File { get; }
    public ICppSymbol[] PreprocessorSymbols { get; }
    public CppNamespaceSymbol GlobalNamespaceSymbol { get; }
    public int EqualityHashCode { get; }
    public int ReferenceCount { get; public set; }
    public int InternCount { get; public set; }
    public CppFileSymbols(CppFileLocation file, CppNamespaceSymbol globalNamespace, List`1<ICppSymbol> preprocessorSymbols);
    private CppFileSymbols(CppFileLocation file, CppNamespaceSymbol globalNamespace, ICppSymbol[] preprocessorSymbols, int hashCode);
    public CppFileLocation get_File();
    [CompilerGeneratedAttribute]
public ICppSymbol[] get_PreprocessorSymbols();
    [CompilerGeneratedAttribute]
public CppNamespaceSymbol get_GlobalNamespaceSymbol();
    [CompilerGeneratedAttribute]
public int get_EqualityHashCode();
    [CompilerGeneratedAttribute]
public int get_ReferenceCount();
    [CompilerGeneratedAttribute]
public void set_ReferenceCount(int value);
    [CompilerGeneratedAttribute]
public int get_InternCount();
    [CompilerGeneratedAttribute]
public void set_InternCount(int value);
    public static void Marshal(CppMarshallingContext context, CppFileSymbols value);
    public static CppFileSymbols Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileSymbolsEqualityComparer : object {
    public static CppFileSymbolsEqualityComparer Instance;
    private static CppFileSymbolsEqualityComparer();
    public sealed virtual bool Equals(CppFileSymbols lhs, CppFileSymbols rhs);
    public sealed virtual int GetHashCode(CppFileSymbols symbols);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileSymbolsMarshaller : CppCachedMarshaller`1<CppFileSymbols> {
    public static CppFileSymbolsMarshaller Instance;
    private static CppFileSymbolsMarshaller();
}
[DebuggerDisplayAttribute("File = {FileSymbols.File}")]
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileSymbolTable : object {
    [CompilerGeneratedAttribute]
private long <TableId>k__BackingField;
    [CompilerGeneratedAttribute]
private CppFileSymbols <FileSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private CppScopeDescription[] <NamespaceContext>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReferenceCount>k__BackingField;
    [CompilerGeneratedAttribute]
private CppLanguageKind <LanguageKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPragmaOnce>k__BackingField;
    public long TableId { get; }
    public CppFileSymbols FileSymbols { get; }
    public ICppSymbol[] PreprocessorSymbols { get; }
    public CppNamespaceSymbol GlobalNamespaceSymbol { get; }
    public CppScopeDescription[] NamespaceContext { get; }
    public CppFileLocation File { get; }
    public int ReferenceCount { get; public set; }
    public CppLanguageKind LanguageKind { get; }
    public bool IsPragmaOnce { get; }
    public CppFileSymbolTable(long id, CppFileSymbols fileSymbols, CppScopeDescription[] namespaceContext, bool pragmaOnce, CppLanguageKind languageKind);
    [CompilerGeneratedAttribute]
public long get_TableId();
    [CompilerGeneratedAttribute]
public CppFileSymbols get_FileSymbols();
    public ICppSymbol[] get_PreprocessorSymbols();
    public CppNamespaceSymbol get_GlobalNamespaceSymbol();
    [CompilerGeneratedAttribute]
public CppScopeDescription[] get_NamespaceContext();
    public CppFileLocation get_File();
    [CompilerGeneratedAttribute]
public int get_ReferenceCount();
    [CompilerGeneratedAttribute]
public void set_ReferenceCount(int value);
    [CompilerGeneratedAttribute]
public CppLanguageKind get_LanguageKind();
    [CompilerGeneratedAttribute]
public bool get_IsPragmaOnce();
    private void CheckInvariant();
    public bool ContainsSymbol(ICppSymbol symbol);
    public static bool LookUpSymbol(ICppSymbol root, ICppSymbol symbol);
    public static void Marshal(CppMarshallingContext context, CppFileSymbolTable table);
    public static CppFileSymbolTable Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileSymbolTableEqualityComparer : object {
    public static CppFileSymbolTableEqualityComparer Instance;
    private static CppFileSymbolTableEqualityComparer();
    public sealed virtual bool Equals(CppFileSymbolTable lhs, CppFileSymbolTable rhs);
    public sealed virtual int GetHashCode(CppFileSymbolTable table);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileSymbolTableMarshaller : object {
    public static CppFileSymbolTableMarshaller Instance;
    private static CppFileSymbolTableMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppFileSymbolTable value);
    public sealed virtual CppFileSymbolTable Unmarshal(CppUnmarshallingContext context);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileSymbolTablePack : ValueType {
    private CppList`1<CppFileSymbolTable> mySymbolTables;
    [CompilerGeneratedAttribute]
private CppFileTextSignature <TextSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDirty>k__BackingField;
    public CppFileTextSignature TextSignature { get; public set; }
    public int Count { get; }
    public CppFileSymbolTable Item { get; public set; }
    public bool IsDirty { get; public set; }
    public CppFileSymbolTablePack(CppFileTextSignature signature);
    public CppFileSymbolTablePack(CppFileTextSignature textSignature, CppList`1<CppFileSymbolTable> symbolTables, bool isDirty);
    public void Add(CppFileSymbolTable table);
    public bool Remove(CppFileSymbolTable table);
    public bool IsEmpty();
    public CppListEnumerator`1<CppFileSymbolTable> GetEnumerator();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CppFileTextSignature get_TextSignature();
    [CompilerGeneratedAttribute]
public void set_TextSignature(CppFileTextSignature value);
    public bool Contains(CppFileSymbolTable table);
    public int get_Count();
    public CppFileSymbolTable get_Item(int idx);
    public void set_Item(int idx, CppFileSymbolTable value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsDirty();
    [CompilerGeneratedAttribute]
public void set_IsDirty(bool value);
    public void RemoveAt(int index);
    public static void Marshal(CppMarshallingContext context, CppFileSymbolTablePack value);
    public static CppFileSymbolTablePack Unmarshal(CppUnmarshallingContext context);
    public bool Equals(CppFileSymbolTablePack rhs);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileSymbolTablePackMarshaller : object {
    public static CppFileSymbolTablePackMarshaller Instance;
    private static CppFileSymbolTablePackMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppFileSymbolTablePack value);
    public sealed virtual CppFileSymbolTablePack Unmarshal(CppUnmarshallingContext context);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileTextSignature : ValueType {
    public static CppFileTextSignature EMPTY;
    [CompilerGeneratedAttribute]
private int <HashValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasQtGeneratedComment>k__BackingField;
    public int HashValue { get; }
    public bool HasQtGeneratedComment { get; }
    public CppFileTextSignature(int hashValue, bool hasQtGeneratedComment);
    private static CppFileTextSignature();
    [CompilerGeneratedAttribute]
public int get_HashValue();
    [CompilerGeneratedAttribute]
public bool get_HasQtGeneratedComment();
    public sealed virtual bool Equals(CppFileTextSignature r);
    public virtual bool Equals(object r);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static void Marshal(CppMarshallingContext context, CppFileTextSignature value);
    public static CppFileTextSignature Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileTextSignatureMarshaller : object {
    public static CppFileTextSignatureMarshaller Instance;
    private static CppFileTextSignatureMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppFileTextSignature value);
    public sealed virtual CppFileTextSignature Unmarshal(CppUnmarshallingContext context);
}
public static class JetBrains.ReSharper.Psi.Cpp.Caches.CppFileTextSignatureUtil : object {
    public static Nullable`1<int> CalculateIncludeDirectiveHash(CppTokenKind tt);
    public static Nullable`1<int> CalculateIfOrElifDirectiveHash(CppTokenKind tt);
    public static CppFileTextSignature Calculate(CppDocumentBuffer docBuffer);
    public static int CalculateDirectiveBodyHash(string buffer, int start, int end);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppFloatValueExpressionMarshaller : CppPolymorphicMarshaller`1<Float> {
    public virtual void Marshal(CppMarshallingContext context, Float value);
    public virtual Float Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppFoldExpressionMarshaller : CppPolymorphicMarshaller`1<CppFoldExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppFoldExpression value);
    public virtual CppFoldExpression Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppForcedIncludeSnapshotCache : object {
    private OptimizedPersistentSortedMap`2<CppFileLocation, CppModule> myForcedIncludeSnapshotMap;
    private DeadlockDetector myForcedIncludeSnapshotLock;
    private CppGlobalSymbolCache mySymbolCache;
    private Lifetime myLifetime;
    private IShellLocks myShellLocks;
    private ILogger myLogger;
    private Dictionary`2<CppFileLocation, ExportTask> myExportTasks;
    private List`1<Action> myBuildJobsToEnqueueAfterCommit;
    private HashSet`1<CppFileLocation> myQueuedBuildJobs;
    private Lazy`1<SingleThreadExecutor> myBuildJobThread;
    private bool myEnableInMemoryModulesCache;
    private bool myIsCacheReleased;
    public CppForcedIncludeSnapshotCache(CppGlobalSymbolCache symbolCache, ISolutionCaches solutionCaches, IShellLocks shellLocks, Lifetime lifetime, CppUnmarshallingIntern unmarshallingIntern, IApplicationWideContextBoundSettingStore settingsStore);
    public bool EnableModuleLikeForcedIncludes();
    public void InitCache();
    public void Invalidate(HashSet`1<CppFileLocation> includers);
    public void Clear();
    public void ReleaseCache();
    public CppModule GetOrCreateForcedIncludeSnapshot(CppFileLocation file, FileProcessingOptions options, CppRootInclusionContext context, Boolean& wasCreated);
    private void WaitForTask(Task exportTask);
    private void EnqueueBuildForcedIncludeSnapshotJob(CppFileLocation file, CppFileLocation rootFile);
    private void BuildForcedIncludeSnapshotFromBackgroundThread(CppFileLocation file, CppFileLocation rootFile);
    private void BuildForcedIncludeSnapshot(CppFileLocation file, CppFileLocation rootFile);
    private CppModule ExportModule(CppFileLocation file, CppRootInclusionContext context);
    [CompilerGeneratedAttribute]
private SingleThreadExecutor <.ctor>b__12_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_1();
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_3();
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppForStatementSymbolMarshaller : CppPolymorphicMarshaller`1<CppForStatementSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppForStatementSymbol value);
    public virtual CppForStatementSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppFwdClassSymbolMarshaller : CppPolymorphicMarshaller`1<CppFwdClassSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppFwdClassSymbol value);
    public virtual CppFwdClassSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppFwdEnumWithBaseSymbolMarshaller : CppPolymorphicMarshaller`1<CppFwdEnumWithBaseSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppFwdEnumWithBaseSymbol value);
    public virtual CppFwdEnumWithBaseSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppGcnewConstraintMarshaller : CppPolymorphicMarshaller`1<CppGcnewConstraint> {
    public virtual void Marshal(CppMarshallingContext context, CppGcnewConstraint value);
    public virtual CppGcnewConstraint Unmarshal(CppUnmarshallingContext context);
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppGeneratedFilesCache : object {
    private static int TIME_OUT_TO_START_MS;
    private static string FileName;
    private static string FolderName;
    private Dictionary`2<ImportDescription, VirtualFileSystemPath> myGeneratedFiles;
    private Dictionary`2<ImportDescription, string> myGeneratedFilesOutput;
    private OneToSetMap`2<string, ImportDescription> myReferenceTextToImportDescriptionMap;
    private object myLock;
    private FileSystemPath myCacheFolder;
    private ILogger myLogger;
    public CppGeneratedFilesCache(SolutionCaches caches, ChangeManager changeManager, Lifetime lifetime, ILogger logger);
    public virtual object Execute(IChangeMap changeMap);
    private VirtualFileSystemPath ProcessDirectory(VirtualFileSystemPath tmp, string pattern, ImportDescription desc, string referenceText, string output);
    private FileSystemPath GetImportCacheFolder(ImportDescription desc);
    public VirtualFileSystemPath GenerateFile(string referenceText, string propText, CppInclusionContext state, String& output);
    public VirtualFileSystemPath FindClCompiler(string executablePath, IProject project);
    public string ProcessOutput(string output);
    public CppList`1<VirtualFileSystemPath> InvalidateGeneratedFiles(VirtualFileSystemPath file);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppGenericParameterSymbolMarshaller : CppPolymorphicMarshaller`1<CppGenericParameterSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppGenericParameterSymbol value);
    public virtual CppGenericParameterSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppGGDeclareHungarianSymbolMarshaller : CppPolymorphicMarshaller`1<CppGGDeclareHungarianSymbol> {
    public static CppGGDeclareHungarianSymbolMarshaller Instance;
    private static CppGGDeclareHungarianSymbolMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppGGDeclareHungarianSymbol value);
    public virtual CppGGDeclareHungarianSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppGlobalNamespaceIdMarshaller : CppPolymorphicMarshaller`1<CppGlobalNamespaceId> {
    public virtual void Marshal(CppMarshallingContext context, CppGlobalNamespaceId value);
    public virtual CppGlobalNamespaceId Unmarshal(CppUnmarshallingContext context);
}
[PsiComponentAttribute("4")]
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppGlobalSymbolCache : object {
    private static int CACHE_FORMAT_VERSION;
    private static int MAX_REFERENCES_TO_SYMBOL_TABLE;
    [ThreadStaticAttribute]
private static List`1<CppFileSymbolTable> ourTablesToCheck;
    private CppObjectIntern`1<string> myStringIntern;
    private CompactMap`2<CppFileLocation, CppFileSymbolTablePack> myFileToSymbolTablesMap;
    private CppFileLocationPersistentCache`1<CppFileSymbolTablePack> myFileToSymbolTablesCache;
    private CompactMap`2<CppFileLocation, SourceFileState> mySourceFileToAllSymbolTablesMap;
    private CppFileLocationPersistentCache`1<SourceFileState> mySourceFileToAllSymbolTablesCache;
    private CompactMap`2<CppFileSymbolTable, FrugalLocalHashSet`1<CppFileLocation>> mySymbolTableToSourceFilesMap;
    private CompactMap`2<long, CppFileSymbolTable> myIdToSymbolTableMap;
    private OptimizedPersistentSortedMap`2<long, CppFileContextSignature> myContextSignatureMap;
    private CppFileLocationPersistentCache`1<IntSet> myWordsCache;
    private OptimizedPersistentSortedMap`2<CppFileLocation, IntSet> myWordsMap;
    private JetHashSet`1<CppFileSymbols> mySymbolsIntern;
    private long myNextSymbolTableId;
    private HashSet`1<CppFileSymbolTable> myPotentialGarbageTables;
    private HashSet`1<CppFileLocation> myFilesWithRemovedTables;
    private CppUnmarshallingIntern myUnmarshallingIntern;
    private LockObject myLock;
    private LockObject myWordsLock;
    private IPsiConfiguration myPsiConfiguration;
    private ILogger myLogger;
    private long myCacheVersion;
    private DeadlockDetector myDeadlockDetector;
    private ICppPerfEventAccumulator myPerfEvents;
    private List`1<KeyValuePair`2<CppFileLocation, long>> myLoadTimestamps;
    private ICppUnitTestFileExplorer myUnitTestFileExplorer;
    private Lifetime myLifetime;
    private bool myIsCacheReleased;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ICppCompilationPropertiesProvider> <CompilationPropertiesProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppTodoManager <TodoManager>k__BackingField;
    [CompilerGeneratedAttribute]
private CppLinkageEntityCache <LinkageCache>k__BackingField;
    [CompilerGeneratedAttribute]
private CppIncludesGraphCache <IncludesGraphCache>k__BackingField;
    [CompilerGeneratedAttribute]
private CppSymbolNameCache <SymbolNameCache>k__BackingField;
    [CompilerGeneratedAttribute]
private CppPchCache <PchCache>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppGlobalCache <GlobalCache>k__BackingField;
    [CompilerGeneratedAttribute]
private CppForcedIncludeSnapshotCache <ForcedIncludeSnapshotCache>k__BackingField;
    [CompilerGeneratedAttribute]
private CppModulesCache <ModulesCache>k__BackingField;
    [CompilerGeneratedAttribute]
private CppExternalModule <CppModule>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private IShellLocks <ShellLocks>k__BackingField;
    [CompilerGeneratedAttribute]
private CommonIdentifierIntern <CommonIdentifierIntern>k__BackingField;
    [CompilerGeneratedAttribute]
private MarkerListPool <MarkerListPool>k__BackingField;
    [CompilerGeneratedAttribute]
private CharArrayBuffersPool <CharArrayBuffersPool>k__BackingField;
    [CompilerGeneratedAttribute]
private PackedTokensPagesPool <PackedTokensPagesPool>k__BackingField;
    [CompilerGeneratedAttribute]
private CppDefineSymbolMapPool <DefineSymbolMapPool>k__BackingField;
    [CompilerGeneratedAttribute]
private CppUndefMapPool <UndefMapPool>k__BackingField;
    [CompilerGeneratedAttribute]
private CppPendingActionsMapPool <PendingActionsMapPool>k__BackingField;
    [CompilerGeneratedAttribute]
private CppMergeSymbolActionsPool <MergeSymbolActionsPool>k__BackingField;
    [CompilerGeneratedAttribute]
private CppScopeChildrenMapPool <ScopeChildrenMapPool>k__BackingField;
    [CompilerGeneratedAttribute]
private CppPropertiesCache <PropertiesCache>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppIntelliSenseInfoProvider <IntelliSenseInfoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private CppProjectPropertiesSettingsKeyAccessor <ProjectPropertiesAccessor>k__BackingField;
    [CompilerGeneratedAttribute]
private CppSymbolTypeIntern <TypeIntern>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiServices <PsiServices>k__BackingField;
    [CompilerGeneratedAttribute]
private CppIncludePathsBroker <IncludePathsBroker>k__BackingField;
    [CompilerGeneratedAttribute]
private CppAnonymousNameHelper <AnonymousNameHelper>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppUE4SolutionDetector <UE4SolutionDetector>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppUE4ModuleNamesProvider <UE4ModuleNamesProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSymbolsRemoved OnFileSymbolsRemoved;
    public IReadOnlyList`1<ICppCompilationPropertiesProvider> CompilationPropertiesProviders { get; }
    public ICppTodoManager TodoManager { get; }
    public CppLinkageEntityCache LinkageCache { get; }
    public CppIncludesGraphCache IncludesGraphCache { get; }
    public CppSymbolNameCache SymbolNameCache { get; }
    public CppPchCache PchCache { get; }
    public ICppGlobalCache GlobalCache { get; private set; }
    public CppForcedIncludeSnapshotCache ForcedIncludeSnapshotCache { get; }
    public CppModulesCache ModulesCache { get; }
    public CppExternalModule CppModule { get; }
    public ISolution Solution { get; }
    public IShellLocks ShellLocks { get; }
    public CommonIdentifierIntern CommonIdentifierIntern { get; }
    public MarkerListPool MarkerListPool { get; }
    public CharArrayBuffersPool CharArrayBuffersPool { get; }
    public PackedTokensPagesPool PackedTokensPagesPool { get; }
    public CppDefineSymbolMapPool DefineSymbolMapPool { get; }
    public CppUndefMapPool UndefMapPool { get; }
    public CppPendingActionsMapPool PendingActionsMapPool { get; }
    public CppMergeSymbolActionsPool MergeSymbolActionsPool { get; }
    public CppScopeChildrenMapPool ScopeChildrenMapPool { get; }
    public CppPropertiesCache PropertiesCache { get; }
    public ICppIntelliSenseInfoProvider IntelliSenseInfoProvider { get; }
    public CppProjectPropertiesSettingsKeyAccessor ProjectPropertiesAccessor { get; }
    public CppSymbolTypeIntern TypeIntern { get; }
    public IPsiServices PsiServices { get; }
    public CppIncludePathsBroker IncludePathsBroker { get; }
    public CppAnonymousNameHelper AnonymousNameHelper { get; }
    public ICppUE4SolutionDetector UE4SolutionDetector { get; }
    public ICppUE4ModuleNamesProvider UE4ModuleNamesProvider { get; }
    public CppGlobalSymbolCache(ISolution solution, CppPchCache pchCache, IShellLocks shellLocks, IPsiServices psiServices, IPsiConfiguration psiConfiguration, Lifetime lifetime, IFileSystemTracker fileSystemTracker, CommonIdentifierIntern commonIdentifierIntern, MarkerListPool markerListPool, CharArrayBuffersPool charArrayBuffersPool, PackedTokensPagesPool packedTokensPagesPool, CppPropertiesCache propertiesCache, ICppTodoManager todoManager, ICppUnitTestFileExplorer unitTestFileExplorer, ISolutionCaches solutionCaches, ICppIntelliSenseInfoProvider intelliSenseInfoProvider, CppAnonymousNameHelper anonymousNameHelper, ICppUE4SolutionDetector ue4SolutionDetector, ICppUE4ModuleNamesProvider ue4ModuleNamesProvider, CppProjectPropertiesSettingsKeyAccessor projectPropertiesAccessor, IApplicationWideContextBoundSettingStore settingsStore, CppExternalModule externalModule, IOrderedImmutableList`2<ICppCompilationPropertiesProvider, CppCompilationPropertiesProviderAttribute> compilationPropertiesProviders);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ICppCompilationPropertiesProvider> get_CompilationPropertiesProviders();
    [CompilerGeneratedAttribute]
public ICppTodoManager get_TodoManager();
    [CompilerGeneratedAttribute]
public CppLinkageEntityCache get_LinkageCache();
    [CompilerGeneratedAttribute]
public CppIncludesGraphCache get_IncludesGraphCache();
    [CompilerGeneratedAttribute]
public CppSymbolNameCache get_SymbolNameCache();
    [CompilerGeneratedAttribute]
public CppPchCache get_PchCache();
    [CompilerGeneratedAttribute]
public ICppGlobalCache get_GlobalCache();
    [CompilerGeneratedAttribute]
private void set_GlobalCache(ICppGlobalCache value);
    [CompilerGeneratedAttribute]
public CppForcedIncludeSnapshotCache get_ForcedIncludeSnapshotCache();
    [CompilerGeneratedAttribute]
public CppModulesCache get_ModulesCache();
    [CompilerGeneratedAttribute]
public CppExternalModule get_CppModule();
    [CompilerGeneratedAttribute]
public ISolution get_Solution();
    [CompilerGeneratedAttribute]
public IShellLocks get_ShellLocks();
    [CompilerGeneratedAttribute]
public CommonIdentifierIntern get_CommonIdentifierIntern();
    [CompilerGeneratedAttribute]
public MarkerListPool get_MarkerListPool();
    [CompilerGeneratedAttribute]
public CharArrayBuffersPool get_CharArrayBuffersPool();
    [CompilerGeneratedAttribute]
public PackedTokensPagesPool get_PackedTokensPagesPool();
    [CompilerGeneratedAttribute]
public CppDefineSymbolMapPool get_DefineSymbolMapPool();
    [CompilerGeneratedAttribute]
public CppUndefMapPool get_UndefMapPool();
    [CompilerGeneratedAttribute]
public CppPendingActionsMapPool get_PendingActionsMapPool();
    [CompilerGeneratedAttribute]
public CppMergeSymbolActionsPool get_MergeSymbolActionsPool();
    [CompilerGeneratedAttribute]
public CppScopeChildrenMapPool get_ScopeChildrenMapPool();
    [CompilerGeneratedAttribute]
public CppPropertiesCache get_PropertiesCache();
    [CompilerGeneratedAttribute]
public ICppIntelliSenseInfoProvider get_IntelliSenseInfoProvider();
    [CompilerGeneratedAttribute]
public CppProjectPropertiesSettingsKeyAccessor get_ProjectPropertiesAccessor();
    [CompilerGeneratedAttribute]
public CppSymbolTypeIntern get_TypeIntern();
    [CompilerGeneratedAttribute]
public IPsiServices get_PsiServices();
    [CompilerGeneratedAttribute]
public CppIncludePathsBroker get_IncludePathsBroker();
    [CompilerGeneratedAttribute]
public CppAnonymousNameHelper get_AnonymousNameHelper();
    [CompilerGeneratedAttribute]
public ICppUE4SolutionDetector get_UE4SolutionDetector();
    [CompilerGeneratedAttribute]
public ICppUE4ModuleNamesProvider get_UE4ModuleNamesProvider();
    public ILogger GetLogger();
    public ICppPerfEventAccumulator GetPerfEvents();
    public void LookupAndProcessTableForFile(CppFileLocation source, CppFileLocation target, FileProcessingOptions options, CppInclusionContext context, VirtualFileSystemPath includeSearchPath);
    public bool CanReparse(CppFile file);
    public CppFileSymbolTable CreateFileSymbolTable(CppFileSymbols symbols, CppScopeDescription[] namespaceContext, bool isPragmaOnceFile, CppLanguageKind languageKind);
    [ConditionalAttribute("JET_DEBUG_MODE")]
private static void CheckSymbolsAndNamespaceContextConsistency(CppScopeSymbol topLevelSymbol, CppScopeDescription[] namespaceContext);
    public void InvalidateFileBeforeReparse(CppFileLocation file);
    public void RegisterTableFromCppFile(CppFile cppFile);
    internal CppInclusionContextResult TryProcessFileUsingSourceFilePassThroughInclusionContextCreatedException(FileProcessingOptions fileToProcess, CppFileLocation sourceFile, Lifetime lifetime, HashSet`1<CppFileLocation> modulesBeingImported);
    public CppInclusionContextResult TryProcessFileUsingSourceFile(FileProcessingOptions fileToProcess, CppFileLocation sourceFile, Lifetime lifetime);
    public bool IsFileProcessed(CppFileLocation file);
    public CppList`1<CppFileSymbolTable> GetTablesForFile(CppFileLocation file);
    public virtual bool IsLibraryFile(CppFileLocation file);
    public bool HasQtGeneratedComment(CppFileLocation file);
    public CppInclusionContextResult GetInclusionContextNoThrow(IPsiSourceFile sourceFile);
    public object LoadCache(IProgressIndicator progress);
    public void MergeCache(IProgressIndicator progress, object data);
    public void CollectStaleFiles(IProgressIndicator progress, List`1<CppFileLocation> filesToDrop, List`1<CppFileLocation> changedFiles, List`1<CppFileLocation> filesWithChangedProperties, ILogger logger);
    public void ResetCache();
    public void SaveCache(IProgressIndicator progress, Func`1<bool> checkForInterrupt);
    private FileSystemPath GetPathForSymbolNameCacheData();
    public void ReleaseCache();
    public CppFile BuildAndProcessTableForFile(CppFileLocation file, ILazyCachingLexer lexer, CppInclusionContext context, bool registerSymbolTable);
    [CompilerGeneratedAttribute]
public void add_OnFileSymbolsRemoved(FileSymbolsRemoved value);
    [CompilerGeneratedAttribute]
public void remove_OnFileSymbolsRemoved(FileSymbolsRemoved value);
    public CppObjectIntern`1<string> GetStringIntern();
    public void SetOwnerCache(ICppGlobalCache owner);
    public void InvalidateIncluderOfFileName(string fileName, ICollection`1<CppFileLocation> dirtyFiles);
    public void InvalidateIncludeeWithIncluders(CppFileLocation file, ICollection`1<CppFileLocation> dirtyFiles);
    public void MarkFilesAndIncludeesAsDirty(ICollection`1<CppFileLocation> files);
    public void DropFile(CppFileLocation file, ICollection`1<CppFileLocation> dirtyFiles);
    public void CollectGarbageTables();
    public void InvalidateAllDirtyFiles(ICollection`1<CppFileLocation> dirtyFiles);
    public CppFileContextSignature GetFileContextSignatureForTable(long id);
    public CppFileSymbolTable GetFileSymbolTable(long tableId);
    public void EnsureFileIsProcessed(CppFileLocation file, Lifetime lifetime, ICppProcessingCallback progress);
    public bool ContainsFile(CppFileLocation file);
    public CppList`1<CppFileSymbolTable> GetAllTables();
    public List`1<CppFileLocation> GetAllFilesWithTables();
    public void AppendFilesContainingWord(IList`1<string> queries, HashSet`1<IPsiSourceFile> result);
    public bool CanContainWord(IPsiSourceFile sourceFile, string word);
    public bool IsEmpty();
    public bool IsConsistent();
    public void AssertIsConsistent();
    public void CheckMarshalling();
    private void InitCache();
    private void DisposeCache();
    private void InitCachesInOptimizedMaps();
    private void InvalidateFileWithIncluders(CppFileLocation file, bool onlyLinkageEntities, ICollection`1<CppFileLocation> dirtyFiles);
    private void InvalidateFileWithIncludersImpl(CppFileLocation file, HashSet`1<CppFileLocation> includers, bool onlyLinkageEntities, ICollection`1<CppFileLocation> dirtyFiles);
    private void InvalidateSourceFile(CppFileLocation includee, ICollection`1<CppFileLocation> dirtyFiles);
    private void MarkFilesAsDirty(HashSet`1<CppFileLocation> files);
    private void InvalidateSymbolTables(CppFileLocation includee);
    private bool InvalidateTable(CppFileSymbolTable table);
    private void RemoveTableFromPack(CppFileSymbolTable table);
    private void RemoveTable(CppFileSymbolTable table);
    private CppFile BuildAndProcessTableForFile(CppFileLocation file, IDocument documentHint, FileProcessingOptions options, CppDocumentBuffer docBuffer, ILexer`1<int> lexer, CppInclusionContext context, bool registerTable, ICppParser parser);
    private void AddTableToSourceFileState(CppFileSymbolTable internedTable, CppFileSymbolTable originalTable, CppInclusionContext context);
    private void RemoveFilePack(CppFileLocation file);
    private void UpdateFilePack(CppFileLocation file, CppFileSymbolTablePack pack);
    private void AddSourceFileForSymbolTable(CppFileSymbolTable symbolTable, CppFileLocation sourceFile);
    private void RemoveSourceFileForSymbolTable(CppFileSymbolTable symbolTable, CppFileLocation sourceFile);
    private CppFileSymbolTable GetConformingTable(CppFileLocation file, CppInclusionContext context, bool onlyReferencedTables, CppUniqueLock& lock);
    private static bool CanParseProject(IProject project);
    private bool CanParseFile(CppFileLocation sourceFile, IProjectFile projectFile);
    private IProjectFile SelectProjectFile(IProjectFile projectHint, CppFileLocation sourceFile);
    private void AssertTableIsInPack(CppFileSymbolTable table);
    private void RaiseOnFileSymbolsRemovedEvent();
    private CppFileSymbolTable RegisterSymbolsForFile(CppFileTextSignature textSignature, CppFileSymbolTable table, IDocument documentHint, CppFileContextSignature contextSignature, CppInclusionContext context);
    private void AppendTodoItems(CppFileSymbolTable table, CppDocumentBuffer docBuffer);
    private void AppendWords(CppFileLocation file, ICppParser parser, ICppPreprocessor pp);
    private void SetWords(CppFileLocation file, IntSet words);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Caches.CppGlobalSymbolCacheUtil : object {
    [ExtensionAttribute]
public static CppGlobalSymbolCache GetGlobalSymbolCache(ISolution solution);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppGnuAddressOfLabelExpressionMarshaller : CppPolymorphicMarshaller`1<CppGnuAddressOfLabelExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppGnuAddressOfLabelExpression value);
    public virtual CppGnuAddressOfLabelExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppGnuBuiltinConstantPExpressionMarshaller : CppPolymorphicMarshaller`1<CppGnuBuiltinConstantPExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppGnuBuiltinConstantPExpression value);
    public virtual CppGnuBuiltinConstantPExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppGnuStatementExpressionMarshaller : CppPolymorphicMarshaller`1<CppGnuStatementExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppGnuStatementExpression value);
    public virtual CppGnuStatementExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppGotoStatementSymbolMarshaller : CppPolymorphicMarshaller`1<CppGotoStatementSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppGotoStatementSymbol value);
    public virtual CppGotoStatementSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppHalfValueExpressionMarshaller : CppPolymorphicMarshaller`1<Half> {
    public virtual void Marshal(CppMarshallingContext context, Half value);
    public virtual Half Unmarshal(CppUnmarshallingContext context);
}
[CppCompilationPropertiesProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppHashedPlatformCompilationPropertiesProvider : object {
    private static int PlatformNameLength;
    private static long PlatformNameHashCode;
    public sealed virtual CppCompilationProperties GetCompilationProperties(IProject project, IProjectFile projectFile, CppFileLocation rootFile, CppGlobalSymbolCache globalCache, CppIntelliSenseInfo intelliSenseInfo);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppHLSLBufferSymbolMarshaller : CppPolymorphicMarshaller`1<CppHLSLBufferSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppHLSLBufferSymbol value);
    public virtual CppHLSLBufferSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppIfStatementSymbolMarshaller : CppPolymorphicMarshaller`1<CppIfStatementSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppIfStatementSymbol value);
    public virtual CppIfStatementSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppImportHeaderDirectiveSymbolMarshaller : CppPolymorphicMarshaller`1<CppImportHeaderUnitDirectiveSymbol> {
    public static CppImportHeaderDirectiveSymbolMarshaller Instance;
    private static CppImportHeaderDirectiveSymbolMarshaller();
    public virtual void Marshal(CppMarshallingContext context, CppImportHeaderUnitDirectiveSymbol value);
    public virtual CppImportHeaderUnitDirectiveSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppImportModuleDirectiveSymbolMarshaller : CppPolymorphicMarshaller`1<CppImportModuleDirectiveSymbol> {
    public static CppImportModuleDirectiveSymbolMarshaller Instance;
    private static CppImportModuleDirectiveSymbolMarshaller();
    public virtual void Marshal(CppMarshallingContext context, CppImportModuleDirectiveSymbol value);
    public virtual CppImportModuleDirectiveSymbol Unmarshal(CppUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppIncludeDirectiveContentMarshaller : object {
    public static CppIncludeDirectiveContentMarshaller Instance;
    private static CppIncludeDirectiveContentMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppIncludeDirectiveContent value);
    public sealed virtual CppIncludeDirectiveContent Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppIncludesGraphCache : object {
    private CppGlobalSymbolCache myGlobalSymbolCache;
    private CompactMap`2<CppFileLocation, IncludesData> myIncludees;
    private CompactMap`2<CppFileLocation, IncludesData> myIncluders;
    private CppFileLocationPersistentCache`1<IncludesData> myIncludeesCache;
    private Dictionary`2<CppFileLocation, HashSet`1<CppFileLocation>> myFileToAllIncludersCache;
    private Dictionary`2<CppFileLocation, SourceFileInfo> myHeaderFileToSourceFilesMap;
    private int myFormatVersion;
    private IPsiConfiguration myPsiConfiguration;
    private LockObject myLock;
    public ISolution Solution { get; }
    public ICppUE4SolutionDetector UE4Detector { get; }
    public ICppUE4ModuleNamesProvider UE4ModuleNamesProvider { get; }
    public CppIncludesGraphCache(CppGlobalSymbolCache globalSymbolCache, int formatVersion, IPsiConfiguration psiConfiguration);
    public ISolution get_Solution();
    public ICppUE4SolutionDetector get_UE4Detector();
    public ICppUE4ModuleNamesProvider get_UE4ModuleNamesProvider();
    public object LoadCache(IProgressIndicator progress, Dictionary`2<CppFileLocation, long> timestamps, CppUnmarshallingIntern unmarshallingIntern);
    public void MergeCache(object cache);
    public void ResetCache();
    public void SaveCache(IProgressIndicator progress, Func`1<bool> checkForInterrupt);
    public void ReleaseCache();
    public bool IsInclude(CppFileLocation include);
    public bool IsInlineInclude(CppFileLocation include);
    public void MarkIncludeeAndIncluder(CppFileLocation includee, CppFileLocation includer);
    public bool MarkInlineIncludeeAndIncluder(CppFileLocation includee, CppFileLocation includer);
    public void CacheSourceFileForFile(CppInclusionContext context, CppFileLocation file);
    public void InvalidateIncluder(CppFileLocation file);
    public void DropFile(CppFileLocation file);
    public IEnumerable`1<CppFileLocation> GetIncluders(CppFileLocation includee);
    public bool HasIncluders(CppFileLocation includee);
    public IEnumerable`1<CppFileLocation> GetIncludees(CppFileLocation includer);
    public IEnumerable`1<CppFileLocation> GetIncludeesAndIncluders(CppFileLocation file);
    public ICollection`1<CppFileLocation> GetFiles();
    public IEnumerable`1<CppFileLocation> CollectPossibleRootsForFile(CppFileLocation current);
    public HashSet`1<CppFileLocation> CollectAllIncludersAndLocalIncluders(CppFileLocation includee);
    public HashSet`1<CppFileLocation> CollectAllIncludersAndLocalIncluders(IEnumerable`1<CppFileLocation> includees);
    public HashSet`1<CppFileLocation> CollectAllIncludeesAndLocalIncludees(IEnumerable`1<CppFileLocation> files);
    public bool FileHasIncluderFromSet(CppFileLocation file, HashSet`1<CppFileLocation> includers);
    private static bool IsInclusionContextBuilt(CppInclusionContextResult result);
    public CppInclusionContextResult ProcessFile(FileProcessingOptions options, Lifetime lifetime);
    public bool IsConsistent();
    public void CheckMarshalling();
    private void InitCache();
    private void DisposeCache();
    private static void CollectFilesInHierarchy(CompactMap`2<CppFileLocation, IncludesData> hierarchy, CppFileLocation includee, HashSet`1<CppFileLocation> result);
    private bool FileHasIncluderFromSetImpl(CppFileLocation file, HashSet`1<CppFileLocation> includers, HashSet`1<CppFileLocation> processedFiles);
    private void CollectPossibleRoots(CppFileLocation current, HashSet`1<CppFileLocation> processedFiles, List`1<CppFileLocation> sources);
    private CppInclusionContextResult ProcessFileUsingFirstSourceFile(FileProcessingOptions options, CppFileLocation current, HashSet`1<CppFileLocation> processedFiles, FileTypeFunctor fileTypeFunctor, SequentialLifetimes lifetimes);
    private static void InvalidateImpl(CompactMap`2<CppFileLocation, IncludesData> forwardMap, CompactMap`2<CppFileLocation, IncludesData> reverseMap, CppFileLocationPersistentCache`1<IncludesData> forwardCache, CppFileLocationPersistentCache`1<IncludesData> reverseCache, CppFileLocation key, bool dropKey);
    private static bool IsConsistentImpl(CompactMap`2<CppFileLocation, IncludesData> map, CompactMap`2<CppFileLocation, IncludesData> reverseMap);
    private static ValueTuple`2<List`1<T>, int> SortByFileType(IEnumerable`1<T> items, Func`2<T, FileType> fileTypeCallback);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppInclusionContextCreatedException : Exception {
    private CppInclusionContext myContext;
    public CppInclusionContextCreatedException(CppInclusionContext context);
    public CppInclusionContext GetInclusionContext();
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppIndexingStat : object {
    public static ILogger Logger;
    private static CppIndexingStat();
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppInMemoryModuleCache : object {
    private LockObject myLock;
    private StrongToWeakDictionary`2<CppFileLocation, CppModule> myWeakRefCache;
    private UnlimitedInactiveItemsEvictingCache`2<CppFileLocation, CppModule> myEvictingCache;
    public int Count { get; }
    public CppInMemoryModuleCache(Lifetime lifetime);
    public sealed virtual void AddToCache(CppFileLocation key, CppModule value);
    public sealed virtual bool RemoveFromCache(CppFileLocation key);
    public sealed virtual bool ContainsKeyInCache(CppFileLocation key);
    public sealed virtual void Clear();
    public sealed virtual bool TryGetFromCache(CppFileLocation key, CppModule& value);
    public sealed virtual CppFileLocation TryGetInternedKey(CppFileLocation key);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<KeyValuePair`2<CppFileLocation, CppModule>> GetEnumerator();
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppInt64Marshaller : object {
    public static CppInt64Marshaller Instance;
    private static CppInt64Marshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, long value);
    public sealed virtual long Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppInternalFailureMarshaller : CppPolymorphicMarshaller`1<CppInternalFailure> {
    public virtual void Marshal(CppMarshallingContext context, CppInternalFailure value);
    public virtual CppInternalFailure Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppIntMarshaller : object {
    public static CppIntMarshaller Instance;
    private static CppIntMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, int value);
    public sealed virtual int Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppIntValueExpressionMarshaller : CppPolymorphicMarshaller`1<Int> {
    public virtual void Marshal(CppMarshallingContext context, Int value);
    public virtual Int Unmarshal(CppUnmarshallingContext context);
}
public static class JetBrains.ReSharper.Psi.Cpp.Caches.CppJournalTestUtil : object {
    private static Result Success(string dump);
    private static Result Fail(string dump);
    public static void HandleResolveEntity(ICppResolveEntity ent);
    public static Result RunJournalTest(ISolution solution, IProject project, IPsiSourceFile psiSourceFile, bool isCli);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppKeyValuePairMarshaller`2 : object {
    private ICppMarshaller`1<Key> myKeyMarshaller;
    private ICppMarshaller`1<Value> myValueMarshaller;
    public CppKeyValuePairMarshaller`2(ICppMarshaller`1<Key> keyMarshaller, ICppMarshaller`1<Value> valueMarshaller);
    public sealed virtual void Marshal(CppMarshallingContext context, KeyValuePair`2<Key, Value> value);
    public sealed virtual KeyValuePair`2<Key, Value> Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppLambdaExpressionMarshaller : CppPolymorphicMarshaller`1<CppLambdaExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppLambdaExpression value);
    public virtual CppLambdaExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppLambdaIdMarshaller : CppPolymorphicMarshaller`1<CppLambdaId> {
    public virtual void Marshal(CppMarshallingContext context, CppLambdaId value);
    public virtual CppLambdaId Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppLambdaInitCaptureMarshaller : CppPolymorphicMarshaller`1<CppLambdaInitCaptureSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppLambdaInitCaptureSymbol value);
    public virtual CppLambdaInitCaptureSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppLambdaSymbolMarshaller : CppPolymorphicMarshaller`1<CppLambdaSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppLambdaSymbol value);
    public virtual CppLambdaSymbol Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppLinkageEntityCache : object {
    private CppGlobalSymbolCache myGlobalSymbolCache;
    private ILogger myLogger;
    private CompactOneToSetMap`2<CppFileLocation, ICppParserSymbol> mySourceToSymbolsMap;
    private CompactMap`2<ICppParserSymbol, ICppLinkageEntity> mySymbolToLinkageEntityMap;
    private CompactOneToListMap`2<ICppParserSymbol, ICppLinkageEntity> mySymbolToBaseLinkageEntitiesMap;
    private LockObject myLock;
    private IShellLocks myShellLocks;
    public CppGlobalSymbolCache GlobalCache { get; }
    public CppLinkageEntityCache(CppGlobalSymbolCache globalSymbolCache, IShellLocks shellLocks);
    public OneToSetMap`2<ICppLinkageEntity, ICppLinkageEntity> BuildBaseToDerivedMap(IEnumerable`1<ICppLinkageEntity> linkageEntitiesEnumerable, bool directInheritorsOnly, IProgressIndicator pi);
    public ICollection`1<ICppParserSymbol> FindSymbols(ICppLinkageEntity linkageEntity);
    public ICollection`1<ICppParserSymbol> FindUnmatchedSymbols(ICppLinkageEntity linkageEntity, bool findDeclarations);
    public OneToSetMap`2<ICppLinkageEntity, ICppParserSymbol> FindSymbols(IEnumerable`1<ICppLinkageEntity> linkageEntities);
    public OneToSetMap`2<ICppLinkageEntity, ICppParserSymbol> FindSymbols(IEnumerable`1<ICppLinkageEntity> linkageEntities, bool findFwdClassSymbolsAndFriendDeclarations, Func`2<ICppParserSymbol, bool> customChecker);
    public ICppLinkageEntity FindEntityBySymbol(ICppParserSymbol symbol);
    public IDictionary`2<ICppParserSymbol, ICppLinkageEntity> FindEntitiesBySymbols(IEnumerable`1<ICppParserSymbol> allSymbols);
    public OneToSetMap`2<ICppLinkageEntity, ICppParserSymbol> FindChildren(IEnumerable`1<ICppLinkageEntity> linkageEntities, CppQualifiedNamePart name);
    public OneToSetMap`2<ICppLinkageEntity, ICppParserSymbol> FindChildren(ICppLinkageEntity linkageEntity, CppQualifiedNamePart name);
    public OneToSetMap`2<ICppLinkageEntity, ICppParserSymbol> FindChildren(IEnumerable`1<ICppLinkageEntity> linkageEntities);
    public ICollection`1<ICppLinkageEntity> FindSpecializations(ICppLinkageEntity linkageEntity);
    public OneToSetMap`2<ICppLinkageEntity, ICppLinkageEntity> FindSpecializations(IEnumerable`1<ICppLinkageEntity> linkageEntities);
    public ICollection`1<ICppLinkageEntity> FindBases(ICppLinkageEntity linkageEntity);
    public ICppLinkageEntity TryGetLinkageEntity(ICppResolveEntity resolveEntity);
    public void CacheSymbolsFromResolveEntity(ICppResolveEntity resolveEntity, ICppLinkageEntity linkageEntity);
    public CppGlobalSymbolCache get_GlobalCache();
    public void ResetCache();
    public OneToSetMap`2<ICppLinkageEntity, ICppParserSymbol> FindSymbolsWithBatchFilter(IEnumerable`1<ICppLinkageEntity> linkageEntities, bool findFwdClassSymbolsAndFriendDeclarations, Func`2<IEnumerable`1<ICppParserSymbol>, IEnumerable`1<ICppParserSymbol>> customFilter);
    public void InvalidateSourceFiles(HashSet`1<CppFileLocation> sourceFiles);
    public CppGlobalSymbolCache GetGlobalSymbolCache();
    public bool MarkNonResolvedSymbols(IEnumerable`1<ICppParserSymbol> symbols, CppFileLocation sourceFile);
    private bool GetLinkageEntity(ICppParserSymbol symbol, ICppLinkageEntity& result);
    private IEnumerable`1<ICppParserSymbol> GetCandidateLinkageEntitySymbols(ICppLinkageEntity parent, CppQualifiedNamePart name);
    public List`1<ICppParserSymbol> GetCandidateLinkageEntitySymbols(ICppLinkageEntity linkageEntity, bool ignoreType);
    private ICollection`1<ICppParserSymbol> GetCandidateSymbolsForDerivedClasses(ICppLinkageEntity linkageEntity, bool directInheritorsOnly);
    private IEnumerable`1<ICppParserSymbol> GetCandidateSymbolsForDerivedLinkageEntities(IEnumerable`1<ICppLinkageEntity> linkageEntities, bool directInheritorsOnly);
    public static void VisitResolveEntitiesForSymbols(CppGlobalSymbolCache globalCache, HashSet`1<ICppParserSymbol> symbols, Action`1<ICppResolveEntity> action, StringBuilder sb);
    private static bool ClassAllowsLinkageEntityCaching(ICppClassResolveEntity ent);
    private static bool ShouldBeCached(ICppResolveEntity ent);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Caches.CppLinkageEntityCache/<GetGroupedDeclaratorSymbolPartsForLinkageEntityCaching>d__39`1")]
private static IEnumerable`1<ICppSymbol> GetGroupedDeclaratorSymbolPartsForLinkageEntityCaching(CppSmallList`1<T> ungrouped);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Caches.CppLinkageEntityCache/<GetGroupedDeclaratorSymbolPartsForLinkageEntityCaching>d__40`1")]
private static IEnumerable`1<ICppSymbol> GetGroupedDeclaratorSymbolPartsForLinkageEntityCaching(CppList`1<T> ungrouped);
    private static IEnumerable`1<ICppSymbol> GetSymbolPartsForLinkageEntityCaching(ICppResolveEntity ent);
    private static bool CanSymbolsFromResolveEntityBeCached(ICppResolveEntity resolveEntity);
    private static TriBool DoesSymbolMapToLinkageEntity(ICppSymbol symbol);
    private static List`1<ICppLinkageEntity> FindBaseLinkageEntities(ICppResolveEntity resolveEntity);
    private static ICppLinkageEntity GetContainingClass(ICppLinkageEntity linkageEntity);
    private static EntityType GetLinkageEntityType(ICppLinkageEntity ent);
    private static EntityType GetParserSymbolType(ICppParserSymbol symbol);
    private static void DumpLinkageEntities(StringBuilder sb, IEnumerable`1<ICppLinkageEntity> linkageEntities);
    private static CppFileLocation GetSymbolFileLocation(ICppParserSymbol sym);
    private static void DumpSymbols(StringBuilder sb, IEnumerable`1<ICppParserSymbol> symbols, string title);
    [CompilerGeneratedAttribute]
internal static void <GetCandidateSymbolsForDerivedLinkageEntities>g__AddSymbol|35_0(ICppParserSymbol symbol, <>c__DisplayClass35_0& , <>c__DisplayClass35_1& , <>c__DisplayClass35_2& );
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppLinkageSpecSymbolMarshaller : CppPolymorphicMarshaller`1<CppLinkageSpecSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppLinkageSpecSymbol value);
    public virtual CppLinkageSpecSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppLong32ValueExpressionMarshaller : CppPolymorphicMarshaller`1<Long32> {
    public virtual void Marshal(CppMarshallingContext context, Long32 value);
    public virtual Long32 Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppLong64ValueExpressionMarshaller : CppPolymorphicMarshaller`1<Long64> {
    public virtual void Marshal(CppMarshallingContext context, Long64 value);
    public virtual Long64 Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppLongDoubleValueExpressionMarshaller : CppPolymorphicMarshaller`1<LongDouble> {
    public virtual void Marshal(CppMarshallingContext context, LongDouble value);
    public virtual LongDouble Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppLongLongValueExpressionMarshaller : CppPolymorphicMarshaller`1<LongLong> {
    public virtual void Marshal(CppMarshallingContext context, LongLong value);
    public virtual LongLong Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppLookupFailureMarshaller : CppPolymorphicMarshaller`1<CppLookupFailure> {
    public virtual void Marshal(CppMarshallingContext context, CppLookupFailure value);
    public virtual CppLookupFailure Unmarshal(CppUnmarshallingContext context);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Caches.CppMarshalBracedInitListUtil : object {
    [ExtensionAttribute]
public static void MarshalBracedInitListExpression(CppMarshallingContext context, ICppBracedInitListExpression value);
    [ExtensionAttribute]
public static CppBracedInitListExpression UnmarshalBracedInitListExpression(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppMarshallingContext : object {
    private Dictionary`2<ICppExpression, int> myExpressionToId;
    private Dictionary`2<object, int> myObjectToId;
    private UnsafeWriter myWriter;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IPersistentSortedMap`2<long, CppFileContextSignature> <ContextSignatures>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack`1<CppScopeSymbol> <ParentSymbols>k__BackingField;
    public ILogger Logger { get; }
    public IPersistentSortedMap`2<long, CppFileContextSignature> ContextSignatures { get; public set; }
    public Stack`1<CppScopeSymbol> ParentSymbols { get; }
    public UnsafeWriter Writer { get; }
    public CppMarshallingContext(ILogger logger);
    public CppMarshallingContext(UnsafeWriter writer, ILogger logger);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public IPersistentSortedMap`2<long, CppFileContextSignature> get_ContextSignatures();
    [CompilerGeneratedAttribute]
public void set_ContextSignatures(IPersistentSortedMap`2<long, CppFileContextSignature> value);
    [CompilerGeneratedAttribute]
public Stack`1<CppScopeSymbol> get_ParentSymbols();
    public UnsafeWriter get_Writer();
    public void Init(UnsafeWriter writer);
    public void Clear();
    public void Write(T value, ICppMarshaller`1<T> marshaller);
    public void Write(T value, IUnsafeMarshaller`1<T> marshaller);
    public void WriteArray(T[] arr, ICppMarshaller`1<T> elementMarshaller);
    public void WriteCollection(ICollection`1<T> collection, ICppMarshaller`1<T> elementMarshaller);
    public void WriteCppList(CppList`1<T> list, ICppMarshaller`1<T> elementMarshaller);
    public void WriteCppSmallList(CppSmallList`1<T> list, ICppMarshaller`1<T> elementMarshaller);
    public void WriteCppSmallArray(CppSmallArray`1<T> list, ICppMarshaller`1<T> elementMarshaller);
    public void WriteDictionary(IDictionary`2<Key, Value> dictionary, ICppMarshaller`1<Key> keyMarshaller, ICppMarshaller`1<Value> valueMarshaller);
    public void WriteFrugalLocalHashSet(FrugalLocalHashSet`1<Key> hashSet, ICppMarshaller`1<Key> keyMarshaller);
    public void WriteEnum(TEnum value);
    public void WriteCached(T value, ICppMarshaller`1<T> uncachedMarshaller);
    public void WriteCachedExpression(ICppExpression value, ICppMarshaller`1<ICppExpression> uncachedMarshaller);
    public bool WriteBool(bool b);
    public void WriteByte(byte b);
    public void WriteInt32(int x);
    public void WriteUInt32(UInt32 x);
    public void WriteInt16(short x);
    public void WriteUInt16(ushort x);
    public void WriteInt64(long x);
    public void WriteUInt64(ulong x);
    public void WriteString(string str);
    public void WriteByteArray(Byte[] arr);
    public void WriteFloat(float x);
    public void WriteDouble(double x);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppMemberAccessDesignatorMarshaller : CppPolymorphicMarshaller`1<CppMemberAccessDesignator> {
    public virtual void Marshal(CppMarshallingContext context, CppMemberAccessDesignator d);
    public virtual CppMemberAccessDesignator Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppMemberAccessExpressionMarshaller : CppPolymorphicMarshaller`1<CppMemberAccessExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppMemberAccessExpression value);
    public virtual CppMemberAccessExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppMemberPointerTypeMarshaller : CppPolymorphicMarshaller`1<CppMemberPointerType> {
    public virtual void Marshal(CppMarshallingContext context, CppMemberPointerType value);
    public virtual CppMemberPointerType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppModuleDirectiveSymbolMarshaller : CppPolymorphicMarshaller`1<CppModuleDirectiveSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppModuleDirectiveSymbol value);
    public virtual CppModuleDirectiveSymbol Unmarshal(CppUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppModuleIdMarshaller : object {
    public static CppModuleIdMarshaller Instance;
    private static CppModuleIdMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppModuleId value);
    public sealed virtual CppModuleId Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppModuleMarshaller : object {
    public static CppModuleMarshaller Instance;
    private static CppModuleMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext ctx, CppModule module);
    public sealed virtual CppModule Unmarshal(CppUnmarshallingContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppModulesCache : object {
    private CppGlobalSymbolCache mySymbolCache;
    private Lifetime myLifetime;
    private ILogger myLogger;
    private IShellLocks myShellLocks;
    private HashSet`1<CppFileLocation> myModuleFiles;
    private OptimizedPersistentSortedMap`2<CppFileLocation, CppModule> myModulesMap;
    private DeadlockDetector myModuleLock;
    private BidirectionalMapOnDictionary`2<CppModuleId, CppFileLocation> myModuleIdToLocationMap;
    private HashSet`1<CppFileLocation> myIsModuleInterface;
    private bool myEnableInMemoryModulesCache;
    private HashSet`1<CppFileLocation> myDirtyModules;
    private object myModuleProcessingLock;
    private static RelativePath ourPathToStandardModules;
    public CppModulesCache(CppGlobalSymbolCache cache, ISolutionCaches solutionCaches, IShellLocks shellLocks, Lifetime lifetime, CppUnmarshallingIntern unmarshallingIntern, DeadlockDetector deadlockDetector, IApplicationWideContextBoundSettingStore settingsStore);
    private static CppModulesCache();
    public void InitCache();
    private CppRootInclusionContext MergeHeaderUnit(CppFileLocation file, CppInclusionContext context, FileProcessingOptions options, Lifetime lifetime);
    private CppModule MergeAndExportHeaderUnit(CppFileLocation file, CppInclusionContext context, FileProcessingOptions options);
    private void RegisterModule(CppModule module);
    private CppModule GetOrCreateHeaderUnit(CppFileLocation file, CppInclusionContext context, FileProcessingOptions options);
    private bool NeedToMergeModule(CppModule module, FileProcessingOptions options);
    [CanBeNullAttribute]
private CppModule GetOrCreateModule(CppFileLocation file, CppInclusionContext context, FileProcessingOptions origOptions);
    public void ImportHeaderUnit(CppImportHeaderUnitDirectiveSymbol importSymbol, CppInclusionContext context, FileProcessingOptions options);
    public void ImportHeaderUnit(CppModule module, CppInclusionContext context, FileProcessingOptions options);
    private void ImportHeaderUnitImport(CppFileLocation target, CppInclusionContext context, FileProcessingOptions options, bool isImplicitlyImported);
    public ValueTuple`2<CppFileLocation, bool> ResolveModuleId(CppModuleId moduleId);
    private CppFileLocation TryResolvePathToStandardModule(CppModuleId moduleId, CppInclusionContext inclusionContext);
    public List`1<CppModuleId> GetKnownModuleIds();
    public void ImportModule(CppImportModuleDirectiveSymbol importSymbol, CppInclusionContext context, FileProcessingOptions options);
    private void ImportModule(CppFileLocation source, CppModuleId moduleId, CppInclusionContext context, FileProcessingOptions options, Boolean& wasRejectedBecauseOfRecursiveImport, bool isImplicitlyImported, bool skipNonInterfaceUnits);
    internal void ImportModule(CppFileLocation source, CppFileLocation target, CppModuleId moduleId, CppInclusionContext context, FileProcessingOptions options, Boolean& wasRejectedBecauseOfRecursiveImport, bool isImplicitlyImported, bool sameModule);
    private void ImportModuleCore(CppFileLocation source, CppFileLocation target, CppModuleId moduleId, CppInclusionContext context, FileProcessingOptions options, Boolean& wasRejectedBecauseOfRecursiveImport, bool isImplicitlyImported, bool sameModule);
    private bool ImportModule(CppModule module, CppModuleId moduleId, CppInclusionContext context, FileProcessingOptions options, CppModuleImportMode mode);
    public void InvalidateCachedModules(HashSet`1<CppFileLocation> files);
    public void InvalidateFile(CppFileLocation file);
    public void DropFile(CppFileLocation file);
    public void ProcessModuleDirective(CppModuleId moduleId, CppFileLocation file, bool isExported, CppInclusionContext context, FileProcessingOptions options);
    private void RegisterLocationForModuleId(CppModuleId moduleId, CppFileLocation file, bool isExported);
    private void ProcessModuleInterface(CppFileLocation file);
    public void MarkModuleAsDirty(CppFileLocation file);
    private void ProcessModuleInterfaces();
}
[SettingsKeyAttribute("System.Reflection.Missing", "C++ modules cache settings")]
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppModulesCacheSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Enable in-memory modules cache")]
public bool EnableInMemoryModulesCache;
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppMSAssumeExpressionMarshaller : CppPolymorphicMarshaller`1<CppMSAssumeExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppMSAssumeExpression value);
    public virtual CppMSAssumeExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppMSNoopExpressionMarshaller : CppPolymorphicMarshaller`1<CppMSNoopExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppMSNoopExpression value);
    public virtual CppMSNoopExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppMSSuperIdMarshaller : CppPolymorphicMarshaller`1<CppMSSuperId> {
    public virtual void Marshal(CppMarshallingContext context, CppMSSuperId value);
    public virtual CppMSSuperId Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppMSUuidOfExpressionMarshaller : CppPolymorphicMarshaller`1<CppMSUuidOfExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppMSUuidOfExpression value);
    public virtual CppMSUuidOfExpression Unmarshal(CppUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppMultiArgumentTypeTraitExpressionElementMarshaller : object {
    public static CppMultiArgumentTypeTraitExpressionElementMarshaller Instance;
    private static CppMultiArgumentTypeTraitExpressionElementMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, Element value);
    public sealed virtual Element Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppMultiArgumentTypeTraitExpressionMarshaller : CppPolymorphicMarshaller`1<CppMultiArgumentTypeTraitExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppMultiArgumentTypeTraitExpression value);
    public virtual CppMultiArgumentTypeTraitExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppNamedLambdaCaptureMarshaller : CppPolymorphicMarshaller`1<CppNamedLambdaCapture> {
    public virtual void Marshal(CppMarshallingContext context, CppNamedLambdaCapture value);
    public virtual CppNamedLambdaCapture Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppNamespaceAliasSymbolMarshaller : CppPolymorphicMarshaller`1<CppNamespaceAliasSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppNamespaceAliasSymbol value);
    public virtual CppNamespaceAliasSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppNamespaceQualifierSymbolMarshaller : CppPolymorphicMarshaller`1<CppNamespaceQualifierSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppNamespaceQualifierSymbol value);
    public virtual CppNamespaceQualifierSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppNamespaceSymbolMarshaller : CppPolymorphicMarshaller`1<CppNamespaceSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppNamespaceSymbol value);
    public virtual CppNamespaceSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppNewExpressionMarshaller : CppPolymorphicMarshaller`1<CppNewExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppNewExpression value);
    public virtual CppNewExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppNoExceptExpressionMarshaller : CppPolymorphicMarshaller`1<CppNoExceptExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppNoExceptExpression value);
    public virtual CppNoExceptExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppNoExceptSpecificationMarshaller : CppPolymorphicMarshaller`1<CppNoExceptSpecification> {
    public virtual void Marshal(CppMarshallingContext context, CppNoExceptSpecification value);
    public virtual CppNoExceptSpecification Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppNoExceptSpecificationWithoutArgMarshaller : CppPolymorphicMarshaller`1<CppNoExceptSpecificationWithoutArg> {
    public virtual void Marshal(CppMarshallingContext context, CppNoExceptSpecificationWithoutArg value);
    public virtual CppNoExceptSpecificationWithoutArg Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppNullPtrTValueExpressionMarshaller : CppPolymorphicMarshaller`1<CppNullptrValue> {
    public virtual void Marshal(CppMarshallingContext context, CppNullptrValue value);
    public virtual CppNullptrValue Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppNullptrTypeMarshaller : CppPolymorphicMarshaller`1<CppNullptrType> {
    public virtual void Marshal(CppMarshallingContext context, CppNullptrType value);
    public virtual CppNullptrType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppNullValueExpressionMarshaller : CppPolymorphicMarshaller`1<CppNullValueExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppNullValueExpression value);
    public virtual CppNullValueExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppNumericTypeMarshaller : CppPolymorphicMarshaller`1<CppNumericType> {
    public virtual void Marshal(CppMarshallingContext context, CppNumericType value);
    public virtual CppNumericType Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppObjectIntern`1 : object {
    private WeakHashSet`1<T> myHashSet;
    public CppObjectIntern`1(IEqualityComparer`1<T> comparer);
    public sealed virtual void Dispose();
    public T Intern(T obj);
    public bool IsInterned(T obj);
    private void Dispose(bool disposing);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppOperatorIdMarshaller : CppPolymorphicMarshaller`1<CppOperatorId> {
    public virtual void Marshal(CppMarshallingContext context, CppOperatorId value);
    public virtual CppOperatorId Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppPackExpansionExpressionMarshaller : CppPolymorphicMarshaller`1<CppPackExpansionExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppPackExpansionExpression value);
    public virtual CppPackExpansionExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppPackExpansionTypeMarshaller : CppPolymorphicMarshaller`1<CppPackExpansionType> {
    public virtual void Marshal(CppMarshallingContext context, CppPackExpansionType value);
    public virtual CppPackExpansionType Unmarshal(CppUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppParameterDeclaratorDataMarshaller : object {
    public static CppParameterDeclaratorDataMarshaller Instance;
    private static CppParameterDeclaratorDataMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppParameterDeclaratorData value);
    public sealed virtual CppParameterDeclaratorData Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppParameterDeclaratorsDataMarshaller : object {
    public static CppParameterDeclaratorsDataMarshaller Instance;
    private static CppParameterDeclaratorsDataMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppParameterDeclaratorsData value);
    public sealed virtual CppParameterDeclaratorsData Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppParenExpressionMarshaller : CppPolymorphicMarshaller`1<CppParenExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppParenExpression value);
    public virtual CppParenExpression Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppParserWithoutPsi : object {
    public static CppParserWithoutPsi Instance;
    private static CppParserWithoutPsi();
    public sealed virtual ParseResult Parse(CppFileLocation file, CppDocumentBuffer docBuffer, ILexer`1<int> lexer, CppInclusionContext childContext, FileProcessingOptions options, Lifetime lifetime, CppGlobalSymbolCache cache);
    public sealed virtual CppFileTextSignature GetFileTextSignature(ICppPreprocessor pp, CppDocumentBuffer docBuffer);
    public sealed virtual void GetWords(ICppPreprocessor pp, IntSet& words);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppParserWithPsi : object {
    public static CppParserWithPsi Instance;
    private static CppParserWithPsi();
    public sealed virtual ParseResult Parse(CppFileLocation file, CppDocumentBuffer _, ILexer`1<int> lexer, CppInclusionContext childContext, FileProcessingOptions options, Lifetime lifetime, CppGlobalSymbolCache cache);
    public sealed virtual CppFileTextSignature GetFileTextSignature(ICppPreprocessor _, CppDocumentBuffer docBuffer);
    public sealed virtual void GetWords(ICppPreprocessor pp, IntSet& words);
}
[PsiComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppPchCache : object {
    private CppExternalModule myModule;
    private object myLockObject;
    private Dictionary`2<IProject, ProjectPchDescriptor> myPsiModuleCaches;
    public CppPchCache(CppExternalModule module);
    public ProjectPchDescriptor GetCachedProjectPchDescriptor(IProject project);
    public void RemovePchCache(IProject project);
    public ProjectPchDescriptor GetProjectPchDescriptor(IProject project, CppGlobalSymbolCache cache);
    public static PchDescriptor GetPchFile(CppInclusionContext context);
    public static CppFileLocation GetPchFileLocation(CppInclusionContext context);
    public static VirtualFileSystemPath GetPchFilePath(IProject project, string precompiledHeaderThrough, string precompiledHeaderFile);
    private static string GetDefaultPchName(IProject project);
    private ProjectPchDescriptor TryAddProjectPchDescriptor(IProject project, ProjectPchDescriptor pchFiles);
    private void ProcessPrecompiledHeaderFromCompilationProperties(IProject project, CppCompilationProperties properties, ProjectPchDescriptor pchFiles);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppPointerTypeMarshaller : CppPolymorphicMarshaller`1<CppPointerType> {
    public virtual void Marshal(CppMarshallingContext context, CppPointerType value);
    public virtual CppPointerType Unmarshal(CppUnmarshallingContext context);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Caches.CppPolymorphicMarshaller`1 : object {
    public abstract virtual void Marshal(CppMarshallingContext context, T value);
    public abstract virtual T Unmarshal(CppUnmarshallingContext context);
    public virtual void PolymorphicMarshal(CppMarshallingContext context, object value);
    public virtual object PolymorphicUnmarshal(CppUnmarshallingContext context);
}
[AttributeUsageAttribute("4")]
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppPolymorphicMarshallerAttribute : PartAttribute {
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppPolymorphicMarshallers : object {
    public static int NullId;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Type, ValueTuple`2<ICppPolymorphicMarshaller, int>> myMarshallerByType;
    private Dictionary`2<int, ICppPolymorphicMarshaller> myMarshallerByHash;
    [CompilerGeneratedAttribute]
private static CppPolymorphicMarshallers <Instance>k__BackingField;
    public static CppPolymorphicMarshallers Instance { get; private set; }
    public CppPolymorphicMarshallers(Lifetime lifetime, ShellPartCatalogSet catalogSet);
    [CompilerGeneratedAttribute]
public static CppPolymorphicMarshallers get_Instance();
    [CompilerGeneratedAttribute]
private static void set_Instance(CppPolymorphicMarshallers value);
    public ICppPolymorphicMarshaller GetMarshaller(int hashCode);
    public ValueTuple`2<ICppPolymorphicMarshaller, int> GetMarshaller(Type type);
    private static int CalcHash(Type type);
    private void ViewClass(Lifetime lifetime, Type type);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppPolymorphicTypeMarshaller`1 : object {
    public static CppPolymorphicTypeMarshaller`1<T> Instance;
    private static CppPolymorphicTypeMarshaller`1();
    public sealed virtual void Marshal(CppMarshallingContext context, T value);
    public sealed virtual T Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppPostfixExpressionMarshaller : CppPolymorphicMarshaller`1<CppPostfixExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppPostfixExpression value);
    public virtual CppPostfixExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppPPDefineSymbolMarshaller : CppPolymorphicMarshaller`1<CppPPDefineSymbol> {
    public static CppPPDefineSymbolMarshaller Instance;
    private static CppPPDefineSymbolMarshaller();
    public virtual void Marshal(CppMarshallingContext context, CppPPDefineSymbol value);
    public virtual CppPPDefineSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppPPImportSymbolMarshaller : CppPolymorphicMarshaller`1<CppPPImportSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppPPImportSymbol value);
    public virtual CppPPImportSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppPPIncludeSymbolMarshaller : CppPolymorphicMarshaller`1<CppPPIncludeSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppPPIncludeSymbol value);
    public virtual CppPPIncludeSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppPPPragmaIncludeAliasSymbolMarshaller : CppPolymorphicMarshaller`1<CppPPPragmaIncludeAliasSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppPPPragmaIncludeAliasSymbol value);
    public virtual CppPPPragmaIncludeAliasSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppPPPragmaPackPopSymbolMarshaller : CppPolymorphicMarshaller`1<CppPPPragmaPackPopSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppPPPragmaPackPopSymbol value);
    public virtual CppPPPragmaPackPopSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppPPPragmaPackPushSymbolMarshaller : CppPolymorphicMarshaller`1<CppPPPragmaPackPushSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppPPPragmaPackPushSymbol value);
    public virtual CppPPPragmaPackPushSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppPPPragmaPackSymbolMarshaller : CppPolymorphicMarshaller`1<CppPPPragmaPackSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppPPPragmaPackSymbol value);
    public virtual CppPPPragmaPackSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppPPPragmaPopSymbolMarshaller : CppPolymorphicMarshaller`1<CppPPPragmaPopSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppPPPragmaPopSymbol value);
    public virtual CppPPPragmaPopSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppPPPragmaPushSymbolMarshaller : CppPolymorphicMarshaller`1<CppPPPragmaPushSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppPPPragmaPushSymbol value);
    public virtual CppPPPragmaPushSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppPPPragmaWarningAsErrorSymbolMarshaller : CppPolymorphicMarshaller`1<CppPPPragmaWarningSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppPPPragmaWarningSymbol value);
    public virtual CppPPPragmaWarningSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppPPUndefSymbolMarshaller : CppPolymorphicMarshaller`1<CppPPUndefSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppPPUndefSymbol value);
    public virtual CppPPUndefSymbol Unmarshal(CppUnmarshallingContext context);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppPropertiesCache : object {
    private String[] mySeparator;
    private ConcurrentDictionary`2<Pair`2<string, VirtualFileSystemPath>, CppCompilationProperties> myCmdLineCompilationProperties;
    private ConcurrentDictionary`2<FullCompilationPropertiesKey, CppCompilationProperties> myFullCompilationProperties;
    private ConcurrentDictionary`2<string, List`1<string>> myForcedIncludes;
    private ConcurrentDictionary`2<string, List`1<CppPPDefineSymbol>> myPredefinedMacros;
    private ConcurrentDictionary`2<string, List`1<string>> myPredefinedUndefs;
    public IList`1<CppPPDefineSymbol> GetPredefinedMacros(string predefinedMacros);
    public IList`1<string> GetPredefinedUndefs(string predefinedMacros);
    public IList`1<string> GetForcedIncludes(string forcedIncludes);
    public CppCompilationProperties GetCachedCompilationProperties(string cmdLine, VirtualFileSystemPath projectLocation);
    public CppCompilationProperties GetCachedCompilationProperties(CppIntelliSenseInfo context, IProject project, CppProjectPropertiesSettingsKeyAccessor projPropsAccessor);
    public CppCompilationProperties GetCachedCompilationProperties(String[] cmdLineArgs, ICollection`1<VirtualFileSystemPath> includePaths, IProject project, CppProjectPropertiesSettingsKeyAccessor projPropsAccessor);
    public void Clear();
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppQualifiedNameMarshaller : object {
    public static CppQualifiedNameMarshaller Instance;
    private static CppQualifiedNameMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppQualifiedName value);
    public sealed virtual CppQualifiedName Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppQualifiedNamePartMarshaller : object {
    public static CppQualifiedNamePartMarshaller Instance;
    private static CppQualifiedNamePartMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppQualifiedNamePart value);
    public sealed virtual CppQualifiedNamePart Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppQualifiedReferenceExpressionMarshaller : CppPolymorphicMarshaller`1<CppQualifiedReferenceExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppQualifiedReferenceExpression value);
    public virtual CppQualifiedReferenceExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppQualifiedReferenceTemplateArgumentMarshaller : CppPolymorphicMarshaller`1<CppQualifiedReferenceTemplateArgument> {
    public static CppQualifiedReferenceTemplateArgumentMarshaller Instance;
    private static CppQualifiedReferenceTemplateArgumentMarshaller();
    public virtual void Marshal(CppMarshallingContext context, CppQualifiedReferenceTemplateArgument value);
    public virtual CppQualifiedReferenceTemplateArgument Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppQualTypeMarshaller : object {
    public static CppQualTypeMarshaller Instance;
    internal static ICppMarshaller`1<CppType> TypeMarshaller;
    private static CppQualTypeMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppQualType value);
    public sealed virtual CppQualType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppRefConstraintMarshaller : CppPolymorphicMarshaller`1<CppRefConstraint> {
    public virtual void Marshal(CppMarshallingContext context, CppRefConstraint value);
    public virtual CppRefConstraint Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppRequiresExpressionItemCompoundSymbolMarshaller : CppPolymorphicMarshaller`1<CppRequiresExpressionItemCompoundSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppRequiresExpressionItemCompoundSymbol value);
    public virtual CppRequiresExpressionItemCompoundSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppRequiresExpressionItemNestedSymbolMarshaller : CppPolymorphicMarshaller`1<CppRequiresExpressionItemNestedSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppRequiresExpressionItemNestedSymbol value);
    public virtual CppRequiresExpressionItemNestedSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppRequiresExpressionItemSimpleSymbolMarshaller : CppPolymorphicMarshaller`1<CppRequiresExpressionItemSimpleSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppRequiresExpressionItemSimpleSymbol value);
    public virtual CppRequiresExpressionItemSimpleSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppRequiresExpressionItemTypenameSymbolMarshaller : CppPolymorphicMarshaller`1<CppRequiresExpressionItemTypenameSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppRequiresExpressionItemTypenameSymbol value);
    public virtual CppRequiresExpressionItemTypenameSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppRequiresExpressionMarshaller : CppPolymorphicMarshaller`1<CppRequiresExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppRequiresExpression value);
    public virtual CppRequiresExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppRequiresExpressionSymbolMarshaller : CppPolymorphicMarshaller`1<CppRequiresExpressionSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppRequiresExpressionSymbol value);
    public virtual CppRequiresExpressionSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppResolvedStructuredBindingIdMarshaller : CppPolymorphicMarshaller`1<CppResolvedStructuredBindingId> {
    public virtual void Marshal(CppMarshallingContext context, CppResolvedStructuredBindingId value);
    public virtual CppResolvedStructuredBindingId Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppReturnStatementSymbolMarshaller : CppPolymorphicMarshaller`1<CppReturnStatementSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppReturnStatementSymbol value);
    public virtual CppReturnStatementSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppRLEBracedInitListExpressionMarshaller : CppPolymorphicMarshaller`1<CppRLEBracedInitListExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppRLEBracedInitListExpression value);
    public virtual CppRLEBracedInitListExpression Unmarshal(CppUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppScopeDescriptionMarshaller : object {
    public static CppScopeDescriptionMarshaller Instance;
    private static CppScopeDescriptionMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppScopeDescription value);
    public sealed virtual CppScopeDescription Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppShortValueExpressionMarshaller : CppPolymorphicMarshaller`1<Short> {
    public virtual void Marshal(CppMarshallingContext context, Short value);
    public virtual Short Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppSignedCharValueExpressionMarshaller : CppPolymorphicMarshaller`1<SignedChar> {
    public virtual void Marshal(CppMarshallingContext context, SignedChar value);
    public virtual SignedChar Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppSimpleDeclaratorSymbolMarshaller : CppPolymorphicMarshaller`1<CppSimpleDeclaratorSymbol> {
    public static CppDeclaratorSymbolMarshaller Instance;
    private static CppSimpleDeclaratorSymbolMarshaller();
    public virtual void Marshal(CppMarshallingContext context, CppSimpleDeclaratorSymbol value);
    public virtual CppSimpleDeclaratorSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppSimpleDeclaratorSymbolWithAffectedSymbolsMarshaller : CppPolymorphicMarshaller`1<CppSimpleDeclaratorSymbolWithAffectedSymbols> {
    public static CppDeclaratorSymbolMarshaller Instance;
    private static CppSimpleDeclaratorSymbolWithAffectedSymbolsMarshaller();
    public virtual void Marshal(CppMarshallingContext context, CppSimpleDeclaratorSymbolWithAffectedSymbols value);
    public virtual CppSimpleDeclaratorSymbolWithAffectedSymbols Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppSimpleDeclaratorSymbolWithQualifiedTypeMarshaller : CppPolymorphicMarshaller`1<CppSimpleDeclaratorSymbolWithQualifiedType> {
    public static CppDeclaratorSymbolMarshaller Instance;
    private static CppSimpleDeclaratorSymbolWithQualifiedTypeMarshaller();
    public virtual void Marshal(CppMarshallingContext context, CppSimpleDeclaratorSymbolWithQualifiedType value);
    public virtual CppSimpleDeclaratorSymbolWithQualifiedType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppSingleArgumentTypeTraitExpressionMarshaller : CppPolymorphicMarshaller`1<CppSingleArgumentTypeTraitExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppSingleArgumentTypeTraitExpression value);
    public virtual CppSingleArgumentTypeTraitExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppSizeOfEllipsisExpressionMarshaller : CppPolymorphicMarshaller`1<CppSizeOfEllipsisExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppSizeOfEllipsisExpression value);
    public virtual CppSizeOfEllipsisExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppSizeOfExpressionMarshaller : CppPolymorphicMarshaller`1<CppSizeOfExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppSizeOfExpression value);
    public virtual CppSizeOfExpression Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppSmallArrayMarshaller`1 : object {
    private ICppMarshaller`1<T> myItemMarshaller;
    public CppSmallArrayMarshaller`1(ICppMarshaller`1<T> itemMarshaller);
    public sealed virtual void Marshal(CppMarshallingContext context, CppSmallArray`1<T> value);
    public sealed virtual CppSmallArray`1<T> Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppStringLiteralAttributeMarshaller : CppAttributeWithArgumentMarshaller`1<CppStringLiteralValue> {
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppStringLiteralMultiValueExpressionMarshaller : CppPolymorphicMarshaller`1<CppStringLiteralMultiPartValue> {
    public virtual void Marshal(CppMarshallingContext context, CppStringLiteralMultiPartValue value);
    public virtual CppStringLiteralMultiPartValue Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppStringLiteralSingleValueExpressionMarshaller : CppPolymorphicMarshaller`1<CppStringLiteralSinglePartValue> {
    public virtual void Marshal(CppMarshallingContext context, CppStringLiteralSinglePartValue value);
    public virtual CppStringLiteralSinglePartValue Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppStringMarshaller : object {
    public static CppStringMarshaller Instance;
    private static CppStringMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, string value);
    public sealed virtual string Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppStringMarshallerNoIntern : object {
    public static CppStringMarshallerNoIntern Instance;
    private static CppStringMarshallerNoIntern();
    public sealed virtual void Marshal(CppMarshallingContext context, string value);
    public sealed virtual string Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppStringPolymorphicMarshaller : CppPolymorphicMarshaller`1<string> {
    public virtual void Marshal(CppMarshallingContext context, string value);
    public virtual string Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppStructuredBindingSymbolMarshaller : CppPolymorphicMarshaller`1<CppStructuredBindingSymbol> {
    public static CppStructuredBindingSymbolMarshaller Instance;
    private static CppStructuredBindingSymbolMarshaller();
    public virtual void Marshal(CppMarshallingContext context, CppStructuredBindingSymbol value);
    public virtual CppStructuredBindingSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppSubscriptDesignatorMarshaller : CppPolymorphicMarshaller`1<CppSubscriptDesignator> {
    public virtual void Marshal(CppMarshallingContext context, CppSubscriptDesignator d);
    public virtual CppSubscriptDesignator Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppSubscriptExpressionMarshaller : CppPolymorphicMarshaller`1<CppSubscriptExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppSubscriptExpression value);
    public virtual CppSubscriptExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppSubstitutionIdMarshaller : CppPolymorphicMarshaller`1<CppSubstitutionId> {
    public virtual void Marshal(CppMarshallingContext context, CppSubstitutionId value);
    public virtual CppSubstitutionId Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppSwitchStatementSymbolMarshaller : CppPolymorphicMarshaller`1<CppSwitchStatementSymbol> {
    public static CppSwitchStatementSymbolMarshaller Instance;
    private static CppSwitchStatementSymbolMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppSwitchStatementSymbol value);
    public sealed virtual CppSwitchStatementSymbol Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppSymbolConstraintClauseMarshaller : object {
    public static CppSymbolConstraintClauseMarshaller Instance;
    private static CppSymbolConstraintClauseMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppSymbolConstraintClause value);
    public sealed virtual CppSymbolConstraintClause Unmarshal(CppUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppSymbolLocationMarshaller : object {
    public static CppSymbolLocationMarshaller Instance;
    private static CppSymbolLocationMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppSymbolLocation value);
    public sealed virtual CppSymbolLocation Unmarshal(CppUnmarshallingContext context);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Caches.CppSymbolMarshallersUtil : object {
    public static bool IsClassSymbolParent(ICppParserSymbol symbol);
    public static ICppParserSymbol FindSymbolParent(Stack`1<CppScopeSymbol> parentSymbols, CppSymbolType symbolType);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertSymbolParent(CppMarshallingContext context, ICppParserSymbol value, CppSymbolType symbolType);
    public static void WriteCppSymbolData(CppMarshallingContext context, CppSymbol value);
    public static void ReadCppSymbolData(CppUnmarshallingContext context, CppComplexOffset& symbolLocation);
    public static void WriteCppParserSymbolData(CppMarshallingContext context, CppParserSymbol value, CppSymbolType symbolType);
    public static void ReadCppParserSymbolData(CppUnmarshallingContext context, CppComplexOffset& symbolLocation, CppQualifiedName& name, ICppParserSymbol& parent, CppSymbolType symbolType);
    [ExtensionAttribute]
public static void WriteContainingFile(CppMarshallingContext context, ICppSymbol value);
    [ExtensionAttribute]
public static CppFileLocation ReadContainingFile(CppUnmarshallingContext context);
    public static void WriteChildren(CppScopeSymbol scope, CppMarshallingContext context);
    public static void ReadChildren(CppScopeSymbol scope, CppUnmarshallingContext context);
    public static void MarshalLoopStatement(CppMarshallingContext context, CppLoopStatementSymbol value);
    public static Symbol UnmarshalLoopStatement(CppUnmarshallingContext context, Symbol symbol);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppSymbolNameCache : object {
    [ThreadStaticAttribute]
private static CachedSymbolFinder ourCachedSymbolFinder;
    [ThreadStaticAttribute]
private static Action`1<Pair`2<string, ICppSymbol>> ourFindCachedSymbolAction;
    private Treap`1<Pair`2<string, ICppSymbol>> myNameToSymbolsMap;
    private Treap`1<Pair`2<string, ICppSymbol>> myFileNameToIncludeMap;
    private CountingMultiMap`2<string, string> myTypeAliasesMap;
    private CountingMultiMap`2<string, string> myNamespaceAliasesMap;
    private Treap`1<Pair`2<string, ICppSymbol>> myNameToDerivedClassesMap;
    private Action`2<string, string> myTypeAliasesMapAddFunc;
    private Action`2<string, string> myTypeAliasesMapRemoveFunc;
    private Action`2<string, string> myNamespaceAliasesMapAddFunc;
    private Action`2<string, string> myNamespaceAliasesMapRemoveFunc;
    private Action`1<Pair`2<string, ICppSymbol>> myNameToDerivedClassesMapAddFunc;
    private Action`1<Pair`2<string, ICppSymbol>> myNameToDerivedClassesMapRemoveFunc;
    private Action`1<ICppSymbol> myAddSymbolAction;
    private Action`1<ICppSymbol> myRemoveSymbolAction;
    private ReaderWriterLockSlim myLock;
    private bool myCachesLoadedDebug;
    private CppSymbolNameVisitor mySymbolNameVisitor;
    public string DbgDescription { get; }
    public CppSymbolNameCache(CppAnonymousNameHelper anonymousNameHelper);
    public string get_DbgDescription();
    public void ResetCache();
    public CapacityStat GetCapacity();
    public void SetCapacity(CapacityStat capacity);
    public void MarkAsLoaded();
    public List`1<ICppSymbol> GetSymbols();
    public void ForEachSymbol(Action`1<Pair`2<string, ICppSymbol>> action);
    public List`1<Pair`2<string, ICppSymbol>> GetSortedNamesWithSymbols();
    public CppList`1<ICppSymbol> GetSymbolsByShortName(string shortName);
    public CppList`1<ICppSymbol> GetSymbolsByShortNameWithReadLockHeld(string shortName);
    public CppList`1<CppPPIncludeSymbol> GetIncludersByFileName(string fileName);
    public CppList`1<CppClassSymbol> GetDerivedClasses(string name);
    public ICppSymbol FindCachedSymbol(ICppSymbol symbol);
    public void ForEachSymbolWithName(string shortName, Action`1<Pair`2<string, ICppSymbol>> action);
    public ICollection`1<string> GetTypeAliases(string name);
    public ICollection`1<string> GetNamespaceAliases(string name);
    public void AddSymbols(CppFileSymbols symbols, bool loading);
    public void RemoveSymbols(CppFileSymbols symbols);
    public string GetSymbolName(ICppSymbol symbol);
    private void ProcessTypeAliases(ICppSymbol symbol, Action`2<string, string> action);
    private void ProcessNamespaceAliases(ICppSymbol symbol, Action`2<string, string> action);
    private void ProcessDerivedClasses(ICppSymbol symbol, Action`1<Pair`2<string, ICppSymbol>> action);
    private void AddSymbol(ICppSymbol symbol);
    private void RemoveSymbol(ICppSymbol symbol);
    private static ICollection`1<string> GetAliasesImpl(string name, CountingMultiMap`2<string, string> aliasesMap);
    private static void ForEachSymbolWithName(Treap`1<Pair`2<string, ICppSymbol>> treap, string name, Action`1<Pair`2<string, ICppSymbol>> action);
    private static string GetAliasFromQualifiedName(CppQualifiedName name);
    private static bool IsInsideTemplate(ICppParserSymbol symbol);
    [CompilerGeneratedAttribute]
private void <ResetCache>b__21_0(string x, string y);
    [CompilerGeneratedAttribute]
private void <ResetCache>b__21_1(string x, string y);
    [CompilerGeneratedAttribute]
private void <ResetCache>b__21_2(string x, string y);
    [CompilerGeneratedAttribute]
private void <ResetCache>b__21_3(string x, string y);
    [CompilerGeneratedAttribute]
private void <ResetCache>b__21_4(Pair`2<string, ICppSymbol> x);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppSymbolNameVisitor : CppAbstractSymbolVisitor`1<string> {
    private CppAnonymousNameHelper myAnonymousNameHelper;
    public CppSymbolNameVisitor(CppAnonymousNameHelper anonymousNameHelper);
    public virtual string Visit(ICppSymbol s);
    public virtual string Visit(CppDeclarationSymbol s);
    public virtual string Visit(CppUsingDirectiveSymbol s);
    public virtual string Visit(CppLambdaSymbol s);
    public virtual string Visit(CppLambdaInitCaptureSymbol s);
    public virtual string Visit(CppEnumeratorSymbol sym);
    public virtual string Visit(ICppParserSymbol parserSymbol);
    public virtual string Visit(CppPPDefineSymbol ppSymbol);
    public virtual string Visit(CppPPMacroParameterSymbol ppSymbol);
    public virtual string Visit(CppPPIncludeSymbol ppSymbol);
    public virtual string Visit(CppModuleDirectiveSymbol symbol);
    public virtual string Visit(CppImportModuleDirectiveSymbol symbol);
}
public static class JetBrains.ReSharper.Psi.Cpp.Caches.CppSymbolTableMerger : object {
    public static void MergeSymbolsToGlobalNamespace(CppGlobalSymbolCache owner, CppFileSymbolTable table, FileProcessingOptions options, CppInclusionContext context);
    public static void MergeSymbolsToResolveEntity(ICppFileResolveEntitiesCache cache, CppList`1<ICppSymbol> symbols, ICppScopeResolveEntity targetResolveEntity);
    public static Nullable`1<EitherValue`2<ICppClassResolveEntity, CppPendingActionWithResultActivator`1<ICppClassResolveEntity>>> MergeClassSymbol(ICppFileResolveEntitiesCache cache, ICppClassSymbol sym, ICppScopeResolveEntity scope, CppCreateClassAndReplaceClassTypeContext& ctx);
    public static void MergeFunctionBody(ICppFileResolveEntitiesCache fileCache, CppDeclaratorSymbol symbol, CppFunctionDeclaratorResolveEntity func, CppLocationAnchor anchorForBody);
    public static void MergeCxxCliOverrideSpecifiers(CppDeclaratorSymbol symbol, CppFunctionDeclaratorResolveEntity func, CppCreateClassAndReplaceClassTypeContext& ctx);
    public static CppLocationAnchor IncrementAnchorUpTo(ICppFileResolveEntitiesCache cache, CppLocationAnchor endAnchor);
    public static CppQualType GetTypeOfMergeClassResult(ICppFileResolveEntitiesCache cache, ICppResolvedTypeFactory tf, Nullable`1<EitherValue`2<ICppClassResolveEntity, CppPendingActionWithResultActivator`1<ICppClassResolveEntity>>> classOrActivator);
    private static bool IsUnscopedEnumWithBody(ICppClassSymbol sym);
    private static void AddActionActivatorToInlineNamespaces(ICppFileResolveEntitiesCache cache, CppNamespaceResolveEntity ns, CppQualifiedNamePart name, CppPendingActionActivator activator, bool actionCanTouchInlineNamespaces);
    private static bool WillClassBeFoundInNamespace(ICppClassSymbol sym, CppNamespaceResolveEntity ns, CppLocationAnchor anchor);
    private static bool HasUsingDeclarations(CppNamespaceResolveEntity ns, CppQualifiedNamePart name);
    private static bool IsPendingActionForResolveEntityAllowed(CppNamespaceResolveEntity ns, CppQualifiedNamePart resolveEntityName, bool visitInlineNamespaces);
    private static bool ShouldSymbolReferenceExistingClass(ICppClassSymbol sym);
    private static bool ShouldSymbolReferenceExistingDeclarator(CppDeclaratorSymbol sym);
    private static bool IsAnonymousSubclass(ICppClassSymbol symbol, ICppScopeResolveEntity scope);
    private static int ComputeAnchorDeltaForClassSymbolMergeAction(ICppClassSymbol symbol);
    private static CppMergeDeclaratorSymbolAction CreateMergeDeclaratorSymbolAction(ICppFileResolveEntitiesCache cache, CppDeclaratorSymbol symbol, ICppScopeResolveEntity scope, CppQualType declSpecType, bool shouldSetSynonymTypedef);
    private static CppMergeClassSymbolAction CreateMergeClassSymbolAction(ICppFileResolveEntitiesCache cache, ICppClassSymbol symbol, ICppScopeResolveEntity scope);
    private static CppNamespaceResolveEntity FindNamespaceScope(ICppResolveEntity scope);
    private static bool AreAffectedNamesMissingInScopeImpl(CppSmallList`1<ICppClassSymbol> affectedSymbols, ICppScopeResolveEntity scope, CppLocationAnchor anchor);
    private static void AddPendingActionsForAffectedNames(ICppFileResolveEntitiesCache cache, CppNamespaceResolveEntity ns, CppQualifiedNamePart name, CppPendingActionActivator activator, CppSmallList`1<ICppClassSymbol> affectedSymbols);
    private static string GetMessageWithThread(string message);
    [StringFormatMethodAttribute("message")]
private static void TraceWithThread(string message);
    [StringFormatMethodAttribute("message")]
private static void TraceWithThread(string message, T1 t1);
    [StringFormatMethodAttribute("message")]
private static void TraceWithThread(string message, T1 t1, T2 t2);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppSymbolTemplateParametersListMarshaller : object {
    public static CppSymbolTemplateParametersListMarshaller Instance;
    private static CppSymbolTemplateParametersListMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppSymbolTemplateParametersList value);
    public sealed virtual CppSymbolTemplateParametersList Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppSymbolTemplateParametersMarshaller : object {
    public static CppSymbolTemplateParametersMarshaller Instance;
    private static CppSymbolTemplateParametersMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppSymbolTemplateParameters value);
    public sealed virtual CppSymbolTemplateParameters Unmarshal(CppUnmarshallingContext context);
}
public enum JetBrains.ReSharper.Psi.Cpp.Caches.CppSymbolType : Enum {
    public int value__;
    public static CppSymbolType REGULAR;
    public static CppSymbolType CLASS;
    public static CppSymbolType LAMBDA;
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppTemplateTemplateParameterPackSymbolMarshaller : CppPolymorphicMarshaller`1<CppTemplateTemplateParameterPackSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppTemplateTemplateParameterPackSymbol value);
    public virtual CppTemplateTemplateParameterPackSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppTemplateTemplateParameterSymbolMarshaller : CppPolymorphicMarshaller`1<CppTemplateTemplateParameterSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppTemplateTemplateParameterSymbol value);
    public virtual CppTemplateTemplateParameterSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppThisByValueLambdaCaptureMarshaller : CppPolymorphicMarshaller`1<CppThisByValueLambdaCapture> {
    public virtual void Marshal(CppMarshallingContext context, CppThisByValueLambdaCapture value);
    public virtual CppThisByValueLambdaCapture Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppThisExpressionMarshaller : CppPolymorphicMarshaller`1<CppThisExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppThisExpression value);
    public virtual CppThisExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppThisLambdaCaptureMarshaller : CppPolymorphicMarshaller`1<CppThisLambdaCapture> {
    public virtual void Marshal(CppMarshallingContext context, CppThisLambdaCapture value);
    public virtual CppThisLambdaCapture Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppThrowAnySpecificationMarshaller : CppPolymorphicMarshaller`1<CppThrowAnySpecification> {
    public virtual void Marshal(CppMarshallingContext context, CppThrowAnySpecification value);
    public virtual CppThrowAnySpecification Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppThrowExpressionMarshaller : CppPolymorphicMarshaller`1<CppThrowExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppThrowExpression value);
    public virtual CppThrowExpression Unmarshal(CppUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppTypeAndCategoryMarshaller : object {
    public static CppTypeAndCategoryMarshaller Instance;
    private static CppTypeAndCategoryMarshaller();
    public virtual void Marshal(CppMarshallingContext context, CppTypeAndCategory value);
    public virtual CppTypeAndCategory Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppTypeIdExpressionMarshaller : CppPolymorphicMarshaller`1<CppTypeIdExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppTypeIdExpression value);
    public virtual CppTypeIdExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppTypeIdMarshaller : CppPolymorphicMarshaller`1<CppTypeId> {
    public virtual void Marshal(CppMarshallingContext context, CppTypeId value);
    public virtual CppTypeId Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppTypeIdOrExpressionAttributeMarshaller : CppAttributeWithArgumentMarshaller`1<ICppTypeIdOrExpression> {
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppTypeOfTypeIdMarshaller : CppPolymorphicMarshaller`1<CppTypeOfTypeId> {
    public virtual void Marshal(CppMarshallingContext context, CppTypeOfTypeId value);
    public virtual CppTypeOfTypeId Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppTypeReferenceMarshaller : CppPolymorphicMarshaller`1<CppTypeReference> {
    public virtual void Marshal(CppMarshallingContext context, CppTypeReference value);
    public virtual CppTypeReference Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppTypeTemplateArgumentMarshaller : CppPolymorphicMarshaller`1<CppTypeTemplateArgument> {
    public virtual void Marshal(CppMarshallingContext context, CppTypeTemplateArgument value);
    public virtual CppTypeTemplateArgument Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppTypeTemplateArgumentPackMarshaller : CppPolymorphicMarshaller`1<CppTypeTemplateArgumentPack> {
    public virtual void Marshal(CppMarshallingContext context, CppTypeTemplateArgumentPack value);
    public virtual CppTypeTemplateArgumentPack Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppTypeTemplateParameterPackSymbolMarshaller : CppPolymorphicMarshaller`1<CppTypeTemplateParameterPackSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppTypeTemplateParameterPackSymbol value);
    public virtual CppTypeTemplateParameterPackSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppTypeTemplateParameterSymbolMarshaller : CppPolymorphicMarshaller`1<CppTypeTemplateParameterSymbol> {
    public static void MarshalBase(CppMarshallingContext context, CppTypeTemplateParameterSymbol value);
    public virtual void Marshal(CppMarshallingContext context, CppTypeTemplateParameterSymbol value);
    public static void Unmarshal(CppUnmarshallingContext context, CppSymbolLocation& symbolLocation, String& name, CppTypeTemplateParameterKey& key);
    public virtual CppTypeTemplateParameterSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppTypeTemplateParameterWithArgumentSymbolMarshaller : CppPolymorphicMarshaller`1<CppTypeTemplateParameterWithArgumentSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppTypeTemplateParameterWithArgumentSymbol value);
    public virtual CppTypeTemplateParameterWithArgumentSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnaryExpressionMarshaller : CppPolymorphicMarshaller`1<CppUnaryExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppUnaryExpression value);
    public virtual CppUnaryExpression Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppUncachedFileSymbolsMarshaller : object {
    public static CppUncachedFileSymbolsMarshaller Instance;
    private static CppUncachedFileSymbolsMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, CppFileSymbols value);
    public sealed virtual CppFileSymbols Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppUncachedStringMarshaller : object {
    public static CppUncachedStringMarshaller Instance;
    private static CppUncachedStringMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, string value);
    public sealed virtual string Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppUncachedStringMarshallerNoIntern : object {
    public static CppUncachedStringMarshallerNoIntern Instance;
    private static CppUncachedStringMarshallerNoIntern();
    public sealed virtual void Marshal(CppMarshallingContext context, string value);
    public sealed virtual string Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnknownArraySizeExpressionMarshaller : CppPolymorphicMarshaller`1<CppUnknownArraySizeExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppUnknownArraySizeExpression e);
    public virtual CppUnknownArraySizeExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnknownTypeMarshaller : CppPolymorphicMarshaller`1<CppUnknownType> {
    public virtual void Marshal(CppMarshallingContext context, CppUnknownType value);
    public virtual CppUnknownType Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnmarshallingContext : object {
    private UnsafeReader myReader;
    private CppList`1<ICppExpression> myExpressions;
    private CppList`1<object> myObjects;
    [CompilerGeneratedAttribute]
private CppUnmarshallingIntern <Intern>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IPersistentSortedMap`2<long, CppFileContextSignature> <ContextSignatures>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack`1<CppScopeSymbol> <ParentSymbols>k__BackingField;
    public CppUnmarshallingIntern Intern { get; }
    public ILogger Logger { get; }
    public IPersistentSortedMap`2<long, CppFileContextSignature> ContextSignatures { get; public set; }
    public Stack`1<CppScopeSymbol> ParentSymbols { get; }
    public UnsafeReader Reader { get; }
    public CppUnmarshallingContext(UnsafeReader reader, CppUnmarshallingIntern intern, ILogger logger);
    [CompilerGeneratedAttribute]
public CppUnmarshallingIntern get_Intern();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public IPersistentSortedMap`2<long, CppFileContextSignature> get_ContextSignatures();
    [CompilerGeneratedAttribute]
public void set_ContextSignatures(IPersistentSortedMap`2<long, CppFileContextSignature> value);
    [CompilerGeneratedAttribute]
public Stack`1<CppScopeSymbol> get_ParentSymbols();
    public UnsafeReader get_Reader();
    public T Read(ICppMarshaller`1<T> marshaller);
    public T Read(IUnsafeMarshaller`1<T> marshaller);
    public T[] ReadArray(ICppMarshaller`1<T> elementMarshaller);
    public List`1<T> ReadList(ICppMarshaller`1<T> elementMarshaller);
    public CppList`1<T> ReadCppList(ICppMarshaller`1<T> elementMarshaller);
    public CppSmallList`1<T> ReadCppSmallList(ICppMarshaller`1<T> elementMarshaller);
    public CppSmallArray`1<T> ReadCppSmallArray(ICppMarshaller`1<T> elementMarshaller);
    public TCol ReadCollection(ICppMarshaller`1<T> elementMarshaller);
    public Dict ReadDictionary(ICppMarshaller`1<Key> keyMarshaller, ICppMarshaller`1<Value> valueMarshaller);
    public FrugalLocalHashSet`1<Key> ReadFrugalLocalHashSet(ICppMarshaller`1<Key> keyMarshaller);
    public TEnum ReadEnum();
    public T ReadCached(ICppMarshaller`1<T> uncachedMarshaller);
    public ICppExpression ReadCachedExpression(ICppMarshaller`1<ICppExpression> uncachedMarshaller);
    public bool ReadBool();
    public byte ReadByte();
    public int ReadInt32();
    public UInt32 ReadUInt32();
    public short ReadInt16();
    public ushort ReadUInt16();
    public long ReadInt64();
    public ulong ReadUInt64();
    public string ReadString();
    public Byte[] ReadByteArray();
    public float ReadFloat();
    public double ReadDouble();
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnmarshallingIntern : object {
    private ConcurrentDictionary`2<CppQualifiedNamePart, CppQualifiedNamePart> myNamePartIntern;
    private ConcurrentDictionary`2<string, string> myTokenIntern;
    [CompilerGeneratedAttribute]
private CppSymbolTypeIntern <TypeIntern>k__BackingField;
    public CppSymbolTypeIntern TypeIntern { get; }
    public CppUnmarshallingIntern(CppSymbolTypeIntern typeIntern);
    [CompilerGeneratedAttribute]
public CppSymbolTypeIntern get_TypeIntern();
    public string Intern(string str);
    public CppQualifiedNamePart Intern(CppQualifiedNamePart namePart);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnresolvedAutoTypeMarshaller : CppPolymorphicMarshaller`1<CppAutoType> {
    public virtual void Marshal(CppMarshallingContext context, CppAutoType value);
    public virtual CppAutoType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnresolvedFunctionMultipleArgumentsTypeMarshaller : CppPolymorphicMarshaller`1<CppUnresolvedFunctionMultipleArgumentsType> {
    public static void MarshalBase(CppMarshallingContext context, CppUnresolvedFunctionMultipleArgumentsType value);
    public virtual void Marshal(CppMarshallingContext context, CppUnresolvedFunctionMultipleArgumentsType value);
    public static void Unmarshal(CppUnmarshallingContext context, CppQualType& returnType, CppParameterDeclaratorsData& params, CppFunctionFlags& flags);
    public virtual CppUnresolvedFunctionMultipleArgumentsType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnresolvedFunctionSingleArgumentTypeMarshaller : CppPolymorphicMarshaller`1<CppUnresolvedFunctionSingleArgumentType> {
    public static void MarshalBase(CppMarshallingContext context, CppUnresolvedFunctionSingleArgumentType value);
    public virtual void Marshal(CppMarshallingContext context, CppUnresolvedFunctionSingleArgumentType value);
    public static void Unmarshal(CppUnmarshallingContext context, CppQualType& returnType, CppFunctionFlags& flags, CppParameterDeclaratorData& param, CppFileLocation& containingFile, Boolean& isParameterPack);
    public virtual CppUnresolvedFunctionSingleArgumentType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnresolvedFunctionSingleArgumentWithExceptionSpecificationTypeMarshaller : CppPolymorphicMarshaller`1<CppUnresolvedFunctionSingleArgumentWithExceptionSpecificationType> {
    public virtual void Marshal(CppMarshallingContext context, CppUnresolvedFunctionSingleArgumentWithExceptionSpecificationType value);
    public virtual CppUnresolvedFunctionSingleArgumentWithExceptionSpecificationType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnresolvedFunctionSingleArgumentWithTrailingReturnTypeMarshaller : CppPolymorphicMarshaller`1<CppUnresolvedFunctionSingleArgumentWithTrailingReturnType> {
    public static void MarshalBase(CppMarshallingContext context, CppUnresolvedFunctionSingleArgumentWithTrailingReturnType value);
    public virtual void Marshal(CppMarshallingContext context, CppUnresolvedFunctionSingleArgumentWithTrailingReturnType value);
    public static void Unmarshal(CppUnmarshallingContext context, CppQualType& returnType, CppFunctionFlags& flags, CppParameterDeclaratorData& param, CppFileLocation& containingFile, Boolean& isParameterPack, CppQualType& trailingReturnType);
    public virtual CppUnresolvedFunctionSingleArgumentWithTrailingReturnType Unmarshal(CppUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnresolvedFunctionTypeMarshaller : object {
    public static void Marshal(CppMarshallingContext context, CppUnresolvedFunctionType value);
    public static void Unmarshal(CppUnmarshallingContext context, CppQualType& returnType, CppFunctionFlags& flags);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnresolvedFunctionWithExceptionSpecificationTypeMarshaller : CppPolymorphicMarshaller`1<CppUnresolvedFunctionWithExceptionSpecificationType> {
    public virtual void Marshal(CppMarshallingContext context, CppUnresolvedFunctionWithExceptionSpecificationType value);
    public virtual CppUnresolvedFunctionWithExceptionSpecificationType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnresolvedFunctionWithoutArgumentsTypeMarshaller : CppPolymorphicMarshaller`1<CppUnresolvedFunctionWithoutArgumentsType> {
    public virtual void Marshal(CppMarshallingContext context, CppUnresolvedFunctionWithoutArgumentsType value);
    public virtual CppUnresolvedFunctionWithoutArgumentsType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnresolvedFunctionWithoutArgumentsWithExceptionSpecificationTypeMarshaller : CppPolymorphicMarshaller`1<CppUnresolvedFunctionWithoutArgumentsWithExceptionSpecificationType> {
    public virtual void Marshal(CppMarshallingContext context, CppUnresolvedFunctionWithoutArgumentsWithExceptionSpecificationType value);
    public virtual CppUnresolvedFunctionWithoutArgumentsWithExceptionSpecificationType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnresolvedFunctionWithoutArgumentsWithTrailingReturnTypeMarshaller : CppPolymorphicMarshaller`1<CppUnresolvedFunctionWithoutArgumentsWithTrailingReturnType> {
    public static void MarshalBase(CppMarshallingContext context, CppUnresolvedFunctionWithoutArgumentsWithTrailingReturnType value);
    public virtual void Marshal(CppMarshallingContext context, CppUnresolvedFunctionWithoutArgumentsWithTrailingReturnType value);
    public static void Unmarshal(CppUnmarshallingContext context, CppQualType& returnType, CppFunctionFlags& flags, CppQualType& trailingReturnType);
    public virtual CppUnresolvedFunctionWithoutArgumentsWithTrailingReturnType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnresolvedFunctionWithTrailingReturnTypeMarshaller : CppPolymorphicMarshaller`1<CppUnresolvedFunctionWithTrailingReturnType> {
    public static void MarshalBase(CppMarshallingContext context, CppUnresolvedFunctionWithTrailingReturnType value);
    public virtual void Marshal(CppMarshallingContext context, CppUnresolvedFunctionWithTrailingReturnType value);
    public static void Unmarshal(CppUnmarshallingContext context, CppQualType& returnType, CppParameterDeclaratorsData& params, CppFunctionFlags& flags, CppQualType& trailingReturnType);
    public virtual CppUnresolvedFunctionWithTrailingReturnType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnresolvedStructuredBindingIdMarshaller : CppPolymorphicMarshaller`1<CppUnresolvedStructuredBindingId> {
    public virtual void Marshal(CppMarshallingContext context, CppUnresolvedStructuredBindingId value);
    public virtual CppUnresolvedStructuredBindingId Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnsafeMarshallerAdaptor`1 : object {
    private CppUnmarshallingIntern myUnmarshallingIntern;
    private ILogger myLogger;
    private ICppMarshaller`1<T> myMarshaller;
    public CppUnsafeMarshallerAdaptor`1(CppUnmarshallingIntern intern, ILogger logger, ICppMarshaller`1<T> marshaller);
    public sealed virtual void Marshal(UnsafeWriter writer, T value);
    public sealed virtual T Unmarshal(UnsafeReader reader);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnsignedCharValueExpressionMarshaller : CppPolymorphicMarshaller`1<UnsignedChar> {
    public virtual void Marshal(CppMarshallingContext context, UnsignedChar value);
    public virtual UnsignedChar Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnsignedLong32ValueExpressionMarshaller : CppPolymorphicMarshaller`1<UnsignedLong32> {
    public virtual void Marshal(CppMarshallingContext context, UnsignedLong32 value);
    public virtual UnsignedLong32 Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnsignedLong64ValueExpressionMarshaller : CppPolymorphicMarshaller`1<UnsignedLong64> {
    public virtual void Marshal(CppMarshallingContext context, UnsignedLong64 value);
    public virtual UnsignedLong64 Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnsignedLongLongValueExpressionMarshaller : CppPolymorphicMarshaller`1<UnsignedLongLong> {
    public virtual void Marshal(CppMarshallingContext context, UnsignedLongLong value);
    public virtual UnsignedLongLong Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnsignedShortValueExpressionMarshaller : CppPolymorphicMarshaller`1<UnsignedShort> {
    public virtual void Marshal(CppMarshallingContext context, UnsignedShort value);
    public virtual UnsignedShort Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUnsignedValueExpressionMarshaller : CppPolymorphicMarshaller`1<UnsignedInt> {
    public virtual void Marshal(CppMarshallingContext context, UnsignedInt value);
    public virtual UnsignedInt Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUserDefinedLiteralCharacterValueMarshaller : CppPolymorphicMarshaller`1<CppUserDefinedLiteralCharacterValue> {
    public virtual void Marshal(CppMarshallingContext context, CppUserDefinedLiteralCharacterValue value);
    public virtual CppUserDefinedLiteralCharacterValue Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUserDefinedLiteralExpressionMarshaller : CppPolymorphicMarshaller`1<CppUserDefinedLiteralExpression> {
    public virtual void Marshal(CppMarshallingContext context, CppUserDefinedLiteralExpression value);
    public virtual CppUserDefinedLiteralExpression Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUserDefinedLiteralFloatValueMarshaller : CppPolymorphicMarshaller`1<CppUserDefinedLiteralFloatValue> {
    public virtual void Marshal(CppMarshallingContext context, CppUserDefinedLiteralFloatValue value);
    public virtual CppUserDefinedLiteralFloatValue Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUserDefinedLiteralIdMarshaller : CppPolymorphicMarshaller`1<CppUserDefinedLiteralId> {
    public virtual void Marshal(CppMarshallingContext context, CppUserDefinedLiteralId value);
    public virtual CppUserDefinedLiteralId Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUserDefinedLiteralIntValueMarshaller : CppPolymorphicMarshaller`1<CppUserDefinedLiteralIntValue> {
    public virtual void Marshal(CppMarshallingContext context, CppUserDefinedLiteralIntValue value);
    public virtual CppUserDefinedLiteralIntValue Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUserDefinedLiteralStringValueMarshaller : CppPolymorphicMarshaller`1<CppUserDefinedLiteralStringValue> {
    public virtual void Marshal(CppMarshallingContext context, CppUserDefinedLiteralStringValue value);
    public virtual CppUserDefinedLiteralStringValue Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUsingDeclarationSymbolMarshaller : CppPolymorphicMarshaller`1<CppUsingDeclarationSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppUsingDeclarationSymbol value);
    public virtual CppUsingDeclarationSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUsingDirectiveSymbolMarshaller : CppPolymorphicMarshaller`1<CppUsingDirectiveSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppUsingDirectiveSymbol value);
    public virtual CppUsingDirectiveSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppUsingEnumDeclarationSymbolMarshaller : CppPolymorphicMarshaller`1<CppUsingEnumDeclarationSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppUsingEnumDeclarationSymbol value);
    public virtual CppUsingEnumDeclarationSymbol Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppValueConstraintMarshaller : CppPolymorphicMarshaller`1<CppValueConstraint> {
    public virtual void Marshal(CppMarshallingContext context, CppValueConstraint value);
    public virtual CppValueConstraint Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppVectorTypeMarshaller : CppPolymorphicMarshaller`1<CppVectorType> {
    public virtual void Marshal(CppMarshallingContext context, CppVectorType value);
    public virtual CppVectorType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppVoidTypeMarshaller : CppPolymorphicMarshaller`1<CppVoidType> {
    public virtual void Marshal(CppMarshallingContext context, CppVoidType value);
    public virtual CppVoidType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppWCharT16ValueExpressionMarshaller : CppPolymorphicMarshaller`1<WCharT16> {
    public virtual void Marshal(CppMarshallingContext context, WCharT16 value);
    public virtual WCharT16 Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppWCharT32ValueExpressionMarshaller : CppPolymorphicMarshaller`1<WCharT32> {
    public virtual void Marshal(CppMarshallingContext context, WCharT32 value);
    public virtual WCharT32 Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.CppWhileStatementSymbolMarshaller : CppPolymorphicMarshaller`1<CppWhileStatementSymbol> {
    public virtual void Marshal(CppMarshallingContext context, CppWhileStatementSymbol value);
    public virtual CppWhileStatementSymbol Unmarshal(CppUnmarshallingContext context);
}
public static class JetBrains.ReSharper.Psi.Cpp.Caches.CppWordIndexUtil : object {
    public static int GetWordCode(IBuffer buffer, int start, int end);
    public static int GetWordCode(string buffer, int start, int end);
    public static int GetWordCode(string text);
    public static int GetLowerWordCode(StringSlice text);
    private static bool IsIdentifierFirstLetter(char ch);
    private static bool IsIdentifierSecondLetter(char ch);
    private static void AddWordsFromCommentImpl(string comment, IntSet words);
    private static void AddWordsFromCommentImpl(string comment, StringBuilder words);
    private static string GetTokenTextFromPreprocessor(CppPreprocessor preprocessor, Token t);
    private static string GetUserDefinedSuffixFromNumericLiteral(string text, CppLanguageDialect dialect);
    private static string GetUserDefinedLiteralSuffix(TokenNodeType tokenType, string text, CppLanguageDialect dialect);
    private static ITreeNode GetNextNode(ITreeNode current);
    private static void EnumerateWordsImpl(CppPsiBuilder psiBuilder, CppLanguageDialect dialect, TOutput words);
    public static void AddWordsFromIncludeDirective(string include, IntSet words);
    public static void AddWordsFromIncludeDirective(CppIncludeDirectiveContent include, IntSet words);
    public static void AddWordsFromComment(IBuffer comment, int start, int end, IntSet words);
    public static void AddWordsFromComment(string comment, int start, int end, IntSet words);
    public static void EnumerateWords(CppPsiBuilder psiBuilder, CppLanguageDialect dialect, StringBuilder words);
    public static void EnumerateWords(CppPsiBuilder psiBuilder, CppLanguageDialect dialect, IntSet words);
    public static void EnumerateWords(CppPreprocessor preprocessor, IntSet words);
    public static IntSet EnumerateWords(ITreeNode root, ICppChameleonNode oldChameleon, ICppChameleonNode newChameleon, CppLanguageDialect dialect);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.DeadlockDetector.DeadlockDetector : object {
    private Dictionary`2<CppFileLocation, int> myFileToThread;
    private Dictionary`2<int, CppFileLocation> myFileBeingAcquired;
    private HashSet`1<int> myThreadsToInterrupt;
    private HashSet`1<int> mySeenThreads;
    private LockObject myLock;
    private ILogger myLogger;
    public bool Acquire(CppInclusionContext context, CppFileLocation fileToAcquire);
    public void Release(CppFileLocation fileToRelease);
    private bool CanAcquire(CppFileLocation fileToAcquire, Int32& threadWithLock);
    private string DescribeContext(CppInclusionContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.DeadlockDetector.DeadlockDetectorGuard : ValueType {
    private DeadlockDetector myDetector;
    private CppFileLocation myFile;
    public DeadlockDetectorGuard(DeadlockDetector detector, CppInclusionContext context, CppFileLocation file, IShellLocks shellLocks);
    public sealed virtual void Dispose();
    public void Release();
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.DefineComparer : object {
    public static DefineComparer Instance;
    private static DefineComparer();
    public sealed virtual int Compare(KeyValuePair`2<CppDefineKey, int> lhs, KeyValuePair`2<CppDefineKey, int> rhs);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.DefineKeyComparer : object {
    public static DefineKeyComparer Instance;
    private static DefineKeyComparer();
    public sealed virtual int Compare(CppDefineKey lhs, CppDefineKey rhs);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.FileProcessingOptions : object {
    private bool myStopAtFile;
    [CompilerGeneratedAttribute]
private CppFileLocation <File>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFile <ProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppProcessingCallback <ProcessingCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowPendingActions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CollectPPUsages>k__BackingField;
    [CompilerGeneratedAttribute]
private CppFileLocation <PreferredRootFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProcessForcedIncludes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanCreateForcedIncludeSnapshot>k__BackingField;
    public CppFileLocation File { get; }
    public IProjectFile ProjectFile { get; }
    public CppFileLocation FileToStopAt { get; }
    public ICppProcessingCallback ProcessingCallback { get; }
    public bool AllowPendingActions { get; public set; }
    public bool CollectPPUsages { get; }
    public CppFileLocation PreferredRootFile { get; public set; }
    public bool ProcessForcedIncludes { get; public set; }
    public bool CanCreateForcedIncludeSnapshot { get; public set; }
    public FileProcessingOptions(CppFileLocation file, bool stopAtFile, bool allowPendingActions, bool collectPPUsages, ICppProcessingCallback callback);
    public FileProcessingOptions(IPsiSourceFile file, bool stopAtFile, bool allowPendingActions, bool collectPPUsages, ICppProcessingCallback callback);
    [CompilerGeneratedAttribute]
public CppFileLocation get_File();
    [CompilerGeneratedAttribute]
public IProjectFile get_ProjectFile();
    public CppFileLocation get_FileToStopAt();
    [CompilerGeneratedAttribute]
public ICppProcessingCallback get_ProcessingCallback();
    [CompilerGeneratedAttribute]
public bool get_AllowPendingActions();
    [CompilerGeneratedAttribute]
public void set_AllowPendingActions(bool value);
    [CompilerGeneratedAttribute]
public bool get_CollectPPUsages();
    [CompilerGeneratedAttribute]
public CppFileLocation get_PreferredRootFile();
    [CompilerGeneratedAttribute]
public void set_PreferredRootFile(CppFileLocation value);
    [CompilerGeneratedAttribute]
public bool get_ProcessForcedIncludes();
    [CompilerGeneratedAttribute]
public void set_ProcessForcedIncludes(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanCreateForcedIncludeSnapshot();
    [CompilerGeneratedAttribute]
public void set_CanCreateForcedIncludeSnapshot(bool value);
    public virtual bool IsFileProcessed(CppInclusionContext context);
    public virtual bool ShouldMergeQualifiedDeclaratorSymbol(CppDeclaratorSymbol symbol);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.FileSystemPathMarshaller : CppCachedMarshaller`1<VirtualFileSystemPath> {
    public static FileSystemPathMarshaller Instance;
    private static FileSystemPathMarshaller();
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.FileSystemPathWithRangeMarshaller : CppCachedMarshaller`1<FileSystemPathWithRange> {
    public static FileSystemPathWithRangeMarshaller Instance;
    private static FileSystemPathWithRangeMarshaller();
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.HlslMatrixTypeMarshaller : CppPolymorphicMarshaller`1<HlslMatrixType> {
    public virtual void Marshal(CppMarshallingContext context, HlslMatrixType value);
    public virtual HlslMatrixType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.HlslSamplerTypeMarshaller : CppPolymorphicMarshaller`1<HlslSamplerType> {
    public virtual void Marshal(CppMarshallingContext context, HlslSamplerType value);
    public virtual HlslSamplerType Unmarshal(CppUnmarshallingContext context);
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Caches.HlslVectorTypeMarshaller : CppPolymorphicMarshaller`1<HlslVectorType> {
    public virtual void Marshal(CppMarshallingContext context, HlslVectorType value);
    public virtual HlslVectorType Unmarshal(CppUnmarshallingContext context);
}
public interface JetBrains.ReSharper.Psi.Cpp.Caches.ICppGlobalCache {
    public IProperty`1<bool> IsIdle { get; }
    public IProperty`1<bool> IsClrCachesIdle { get; }
    public IProperty`1<bool> IsCacheStarted { get; }
    public IProperty`1<bool> IsInitialUpdateFinished { get; }
    public bool EnableCppCliSupport { get; }
    public int MaxCacheConcurrency { get; }
    public int MaxCodeAnalysisConcurrency { get; }
    public CppExternalModule CppModule { get; }
    public abstract virtual IProperty`1<bool> get_IsIdle();
    public abstract virtual IProperty`1<bool> get_IsClrCachesIdle();
    public abstract virtual IProperty`1<bool> get_IsCacheStarted();
    public abstract virtual IProperty`1<bool> get_IsInitialUpdateFinished();
    public abstract virtual bool get_EnableCppCliSupport();
    public abstract virtual int get_MaxCacheConcurrency();
    public abstract virtual int get_MaxCodeAnalysisConcurrency();
    public abstract virtual CppExternalModule get_CppModule();
    public abstract virtual void InvalidatePsiForFile(CppFileLocation sourceFile);
    public abstract virtual void InvalidatePsiForFiles(HashSet`1<CppFileLocation> files);
    public abstract virtual void InvalidatePsiForFileImmediately(CppFileLocation sourceFile);
    public abstract virtual void InvalidatePsiAndSymbolsForFileImmediately(CppFileLocation fileLocation);
    public abstract virtual void InvalidatePsiForOpenTextControls(CppFileLocation file);
    public abstract virtual void RegisterClrSymbolCacheDependence(CppFileLocation location);
    public abstract virtual void UpdateTextIndex(CppFileLocation location, IDocument documentHint);
    public abstract virtual bool ShouldBuildPsi(IPsiSourceFile sourceFile);
}
public interface JetBrains.ReSharper.Psi.Cpp.Caches.ICppLibraryFile {
}
public interface JetBrains.ReSharper.Psi.Cpp.Caches.ICppMarshaller`1 {
    public abstract virtual void Marshal(CppMarshallingContext context, T value);
    public abstract virtual T Unmarshal(CppUnmarshallingContext context);
}
public interface JetBrains.ReSharper.Psi.Cpp.Caches.ICppParser {
    public abstract virtual ParseResult Parse(CppFileLocation file, CppDocumentBuffer doc, ILexer`1<int> lexer, CppInclusionContext childContext, FileProcessingOptions options, Lifetime lifetime, CppGlobalSymbolCache cache);
    public abstract virtual CppFileTextSignature GetFileTextSignature(ICppPreprocessor pp, CppDocumentBuffer docBuffer);
    public abstract virtual void GetWords(ICppPreprocessor pp, IntSet& words);
}
public interface JetBrains.ReSharper.Psi.Cpp.Caches.ICppPolymorphicMarshaller {
    public abstract virtual void PolymorphicMarshal(CppMarshallingContext context, object value);
    public abstract virtual object PolymorphicUnmarshal(CppUnmarshallingContext context);
}
public interface JetBrains.ReSharper.Psi.Cpp.Caches.ICppProcessingCallback {
    public abstract virtual IDisposable CreateFileParsingCookie(CppFileLocation file);
}
public interface JetBrains.ReSharper.Psi.Cpp.Caches.ICppTodoManager {
    public abstract virtual void ProcessSourceFile(IPsiSourceFile sourceFile, CppFileSymbolTable symbols, ILexer lexer);
    public abstract virtual void QueueSourceFile(IPsiSourceFile sourceFile);
    public abstract virtual void DropSourceFile(IPsiSourceFile sourceFile);
    public abstract virtual void InvalidateStaleFiles();
}
public interface JetBrains.ReSharper.Psi.Cpp.Caches.ICppUnitTestFileExplorer {
    public abstract virtual void Explore(CppFileSymbolTable table);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.IntSetMarshaller : object {
    public static IntSetMarshaller Instance;
    private static IntSetMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, IntSet value);
    public sealed virtual IntSet Unmarshal(CppUnmarshallingContext context);
}
public interface JetBrains.ReSharper.Psi.Cpp.Caches.IPreferredRootFileProvider {
    public abstract virtual CppFileLocation GetPreferredRootFile(CppFileLocation currentFile);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.MemInitListSymbol : CppScopeSymbol {
    public static MemInitListSymbol Instance;
    private static MemInitListSymbol();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.ParseResult : ValueType {
    public ICppPreprocessor Preprocessor;
    public CppFileSymbolsCache FileSymbolsCache;
    public CppFile File;
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.PreferredRootFileUtil : object {
    public static CppFileLocation GetPreferredRootFile(ISolution solution, CppFileLocation currentFile);
}
internal class JetBrains.ReSharper.Psi.Cpp.Caches.Treap`1 : object {
    private int myRoot;
    private int myFree;
    private ChunkList`1<Item<T>> myItems;
    private IComparer`1<T> myComparer;
    private IEqualityComparer`1<T> myEqualityComparer;
    private Random myRandom;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; private set; }
    public int Capacity { get; }
    public Treap`1(IComparer`1<T> comparer, IEqualityComparer`1<T> equalityComparer);
    public void InitListOfItems(int capacity);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public int get_Capacity();
    public void Add(T value);
    public bool Remove(T value);
    public bool Contains(T v);
    public void GetValuesBetween(T left, T right, Action`1<T> f);
    public void GetSortedValues(Action`1<T> f);
    public ChunkList`1<Item<T>> GetItemsInternal();
    private void Split(int node, T value, Int32& leftChild, Int32& rightChild);
    private int Add(int node, T value, int prob);
    private int Merge(int leftChild, int rightChild);
    private bool Remove(Int32& node, T value);
    private bool Contains(int node, T value);
    private void GetAllValues(int node, Action`1<T> f);
    private void GetValuesBetween(int node, T left, T right, Action`1<T> f);
    private void GetValuesBetweenLeft(int node, T left, Action`1<T> f);
    private void GetValuesBetweenRight(int node, T right, Action`1<T> f);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.UncachedFileSystemPathMarshaller : object {
    public static UncachedFileSystemPathMarshaller Instance;
    private static UncachedFileSystemPathMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, VirtualFileSystemPath value);
    public sealed virtual VirtualFileSystemPath Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Caches.UncachedFileSystemPathWithRangeMarshaller : object {
    public static UncachedFileSystemPathWithRangeMarshaller Instance;
    private static UncachedFileSystemPathWithRangeMarshaller();
    public sealed virtual void Marshal(CppMarshallingContext context, FileSystemPathWithRange value);
    public sealed virtual FileSystemPathWithRange Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.CodeStyle.AnchorPreserver : object {
    private ICodeFormatterImpl myFormatter;
    private ITreeNode myOldAnchor;
    private ITreeNode myNode;
    public AnchorPreserver(ITreeNode oldAnchor, ICodeFormatterImpl formatter);
    public sealed virtual void Dispose();
    public void SetNodeBeforeAnchor(ITreeNode node);
    public static ITreeNode FindNextAnchor(ITreeNode node, ICodeFormatterImpl formatter);
}
public interface JetBrains.ReSharper.Psi.Cpp.CodeStyle.ICppCodeFormatter {
}
public class JetBrains.ReSharper.Psi.Cpp.CodeStyle.IndentPreserver : object {
    private bool myEnabled;
    private string myOldIndent;
    private ICodeFormatterImpl myFormatter;
    private ITreeNode myNode;
    public IndentPreserver(ITreeNode node, ICodeFormatterImpl formatter);
    public IndentPreserver(ITreeNode node, bool enabled, ICodeFormatterImpl formatter);
    public sealed virtual void Dispose();
    private void Init();
}
public static class JetBrains.ReSharper.Psi.Cpp.CppAssertion : object {
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void Assert(bool condition, string message);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void Assert(bool condition, JetConditionalInterpolatedStringHandler& messageHandler);
    [AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void Assert(bool condition, string message, T arg);
    [AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void Assert(bool condition, string message, T1 arg1, T2 arg2);
    [AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void Assert(bool condition, string message, T1 arg1, T2 arg2, T3 arg3);
    [AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void Assert(bool condition, string message, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertNotNull(T condition, string message);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertNotNull(T condition, JetNotNullConditionalInterpolatedStringHandler& messageHandler);
    [AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertNotNull(T1 condition, string message, T2 arg);
    [AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertNotNull(T1 condition, string message, T2 arg1, T3 arg2);
    [AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertNotNull(T1 condition, string message, T2 arg1, T3 arg2, T4 arg3);
    [AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertNotNull(T1 condition, string message, T2 arg1, T3 arg2, T4 arg3, T5 arg4);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void Fail(string message);
    [AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void Fail(string message, T arg);
    [AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void Fail(string message, T1 arg1, T2 arg2);
    [AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void Fail(string message, T1 arg1, T2 arg2, T3 arg3);
    [AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void Fail(string message, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_SLOW_ASSERT_ENABLE")]
public static void AssertSlow(bool condition, string message);
}
public class JetBrains.ReSharper.Psi.Cpp.CppElementFactory : object {
    [CompilerGeneratedAttribute]
private IPsiModule <PsiModule>k__BackingField;
    public static ITokenNode AND_TOKEN;
    public static ITokenNode COLON2X_TOKEN;
    public static ITokenNode COMMA_TOKEN;
    public static ITokenNode DOT_TOKEN;
    public static ITokenNode ELLIPSIS_TOKEN;
    public static ITokenNode EQ_TOKEN;
    public static ITokenNode EXCL_TOKEN;
    public static ITokenNode GT_TOKEN;
    public static ITokenNode LBRACE_TOKEN;
    public static ITokenNode LT_TOKEN;
    public static ITokenNode MUL_TOKEN;
    public static ITokenNode RBRACE_TOKEN;
    public static ITokenNode SEMICOLON_TOKEN;
    public static ITokenNode SPACE_TOKEN;
    public static ITokenNode THIS_TOKEN;
    public IPsiModule PsiModule { get; }
    public CppElementFactory(IPsiModule module);
    private static CppElementFactory();
    public static TNode CreateAndSandboxNode(CppCompositeNodeType nodeType, IPsiModule psiModule);
    public static CppElementFactory GetInstance(IPsiModule module);
    [CompilerGeneratedAttribute]
public IPsiModule get_PsiModule();
    public CppFile CreateFile(string text);
    public CppCodeFragment CreateTopLevelCodeFragment(CppLanguageDialect dialect, string text);
    public CppCodeFragment CreateTopLevelCodeFragmentInContext(CppInclusionContext ctx, string text);
    public CppCodeFragment CreateTopLevelCodeFragmentInContextOfUnit(ITreeNode pivot, string text);
    public CppCodeFragment CreateCodeFragmentInContextOfUnit(ITreeNode pivot, string text);
    public CppDoxygenCommentNode CreateDoxygenCommentNode(string text, CppLanguageDialect dialect);
    public ICppStatement CreateStatementWithoutPreprocessing(string text);
    public ICppStatement CreateStatementWithoutPreprocessing(string format, ITreeNode[] args);
    public ICppStatement CreateStatementWithoutPreprocessing(ITreeNode pivot, string text);
    public ICppStatement CreateStatementWithoutPreprocessing(ITreeNode pivot, string format, ITreeNode[] args);
    public ICppStatement CreateStatementWithPreprocessingInEmptyContext(ITreeNode pivot, string text);
    public ICppStatement CreateStatementWithPreprocessingInContextOfUnit(ITreeNode pivot, string text);
    public Declaration CreateParameterDeclaratorWithPreprocessingInEmptyContext(ICppCompositeNode pivot, string format, ITreeNode[] args);
    public Declaration CreateParameterDeclaratorWithPreprocessingInContextOfUnit(ICppCompositeNode pivot, string format, ITreeNode[] args);
    public Declaration CreateCatchSectionDeclarationWithPreprocessingInContextOfUnit(ICppCompositeNode pivot, string text);
    public MacroCall CreateMacroCall(string text);
    public MacroDefinition CreateMacroDefinition(string text);
    public ICppTopLevelDeclarationNode CreateTopLevelDeclarationWithoutPreprocessing(ICppCompositeNode pivot, string text, ITreeNode[] args);
    public ICppTopLevelDeclarationNode CreateTopLevelDeclarationWithoutPreprocessingInEmptyContext(ICppCompositeNode pivot, string text);
    public ICppTopLevelDeclarationNode CreateTopLevelDeclarationWithPreprocessingInEmptyContext(ICppCompositeNode pivot, string text, ITreeNode[] args);
    public ICppTopLevelDeclarationNode CreateTopLevelDeclarationWithPreprocessingInContextOfUnit(ITreeNode pivot, string text, ITreeNode[] args);
    public ICppTopLevelDeclarationNode CreateTopLevelDeclarationWithPreprocessingInContextOfUnit(ITreeNode pivot, CppViewPos& viewPos, string text, ITreeNode[] args);
    public ICppExpressionNode CreateExpressionWithoutPreprocessing(string text);
    public ICppExpressionNode CreateExpressionWithoutPreprocessing(string format, ITreeNode[] args);
    public ICppExpressionNode CreateExpressionWithoutPreprocessing(ICppCompositeNode pivot, string text);
    public ICppExpressionNode CreateExpressionWithoutPreprocessing(ICppCompositeNode pivot, string format, ITreeNode[] args);
    public ICppExpressionNode CreateExpressionWithoutPreprocessing(CppLanguageDialect languageDialect, ICppCompositeNode pivot, string format, ITreeNode[] args);
    public ICppExpressionNode CreateExpressionWithPreprocessingInContextOfUnit(ICppCompositeNode pivot, string format, ITreeNode[] args);
    public ElaboratedTypeSpecifier CreateElaboratedTypeSpecifier(CppClassTag classTag, DeclarationSpecifierTypename typeName);
    public bool TryParseFunctionArgumentListWithoutPreprocessingInDetectionMode(ICppCompositeNode pivot, string text);
    public TemplateArgumentList CreateEmptyTemplateArgumentList(ICppCompositeNode pivot);
    public TemplateArgumentList CreateTemplateArgumentListWithSingleArgument(ICppCompositeNode pivot);
    public TemplateArgumentList CreateTemplateArgumentList(IList`1<ICppTypeIdOrExpressionNode> templArgs);
    public ParametersAndQualifiers CreateParametersAndQualifiers(IList`1<Declaration> parameters, bool explicitThis);
    public AmpRestrictionSpecifier CreateAmpRestrictionSpecifier(CppRestrictionSpecifiers specs);
    public TrailingReturnType CreateTrailingReturnType(TypeId typeId);
    public ArraySizeSpecifier CreateArraySizeSpecifier(ICppExpressionNode sizeExpr);
    public TNode CreateReferenceWithoutPreprocessing(ICppCompositeNode pivot, string text, CppCompositeNodeType nodeType);
    public NameQualifier CreateNameQualifier(ICppCompositeNode pivot, string qualifierTextWithoutColon2x);
    public NameQualifier CreateNameQualifierInEmptyContext(string qualifierTextWithoutColon2x);
    public static CppInclusionContext CreatePreprocessorContext(ICppCompositeNode pivot);
    public static CppInclusionContext CreatePreprocessorContext(CppFileSymbolsCache cache, CppComplexOffset pivotOffset);
    public ICppDirective CreateDirective(string text);
    public ImportDirective CreateImportDirective(string importText);
    public UsingDirective CreateUsingNamespaceDirective(string namespaceName);
    public NamespaceDefinition CreateNamespaceDefinition(string namespaceName);
    public NamespaceAliasDefinition CreateNamespaceAliasDefinition(string aliasName, string namespaceName);
    public MSDeclSpec CreateMsDeclspecNoReturn();
    public AttributeList CreateNodiscardAttributeList();
    public AttributeList CreateNodiscardAttributeList(ICppAttribute noDiscardAttr);
    public GnuStyleAttributeList CreateGnuStyleAttribute(string attrName, ICppExpressionNode argument, CppLanguageDialect dialect);
    public FunctionArgumentList CreateFunctionArgumentList(IList`1<ICppExpressionNode> arguments);
    public BracedInitList CreateBracedArgumentList(IList`1<ICppExpressionNode> arguments);
    public FunctionArgumentList CreateFunctionArgumentList(ICppCompositeNode pivot, string format, ICppExpressionNode[] args);
    public FunctionArgumentList CreateFunctionArgumentList(ICppCompositeNode pivot, ICppExpressionNode[] args);
    public TrailingReturnType CreateTrailingReturnType(string typeIdText);
    public NestedDeclarator CreateParenthesizedDeclrator(NestedDeclarator innerDeclarator);
    public AbstractDeclarator CreateAbstractDeclarator(NestedDeclarator declarator);
    public Declaration CreateDeclaration(DeclarationSpecifiers declSpecs, ICppNonNestedDeclaratorNode declarator);
    public SimpleDeclaration CreateSimpleDeclarationInEmptyContext(CppLanguageDialect dialect, string text);
    public AliasDeclaration CreateAliasDeclarationInEmptyContext(string text);
    public TNode CreateDeclarationInContextOfUnit(ICppCompositeNode pivot, string text, ITreeNode[] args);
    public SimpleDeclaration CreateMemberDeclaration(string text, ITreeNode[] args);
    public Enumerator CreateEnumeratorDeclaration(string text);
    public TemplateDeclaration CreateTemplateDeclaration(CppLanguageDialect dialect, string text);
    public TemplateDeclaration CreateTemplateDeclaration(IList`1<ICppTemplateParameterNode> templParams, ICppTopLevelDeclarationNode innerDecl);
    public DeclarationStatement CreateDeclarationStatement(ICppTopLevelDeclarationNode decl);
    public PureSpecifier CreatePureSpecifier();
    public DeleteSpecifier CreateDeleteSpecifier();
    public DefaultSpecifier CreateDefaultSpecifier();
    public AccessSpecifier CreateAccessSpecifier(CppTokenNodeType tokenType);
    public AccessSpecifier CreateAccessSpecifier(CppAccessibility accessibility);
    public CtorBlock CreateCtorBlock(CtorInitializer ctorInit);
    public CtorInitializer CreateCtorInitializer(MemInitializer memInit);
    public MemInitializer CreateMemInitializer(string memberName, ICppExpressionNode initExpr, bool useUniformInitialization);
    public CppList`1<ITokenNode> CreateClassKey(CppClassKey key);
    public Declarator CreateDeclarator(NestedDeclarator decl);
    public InitDeclarator CreateEqInitDeclarator(NestedDeclarator decl, ICppExpressionNode initializer);
    public InitDeclarator CreateBracedInitDeclarator(NestedDeclarator decl, ICppExpressionNode initializer);
    public InitDeclarator CreateEqBracedInitDeclarator(NestedDeclarator decl, ICppExpressionNode initializer);
    public CastExpression CreateCastExpression(CppLanguageDialect dialect, CppTokenNodeType tokenType, TypeId typeId, ICppExpressionNode expression);
    public CallExpression CreateFunctionStyleCastExpression(TypeId typeId, ICppExpressionNode expression);
    public EmptyExpression CreateEmptyExpression();
    public CallExpression CreateCallExpression(QualifiedReference callee, FunctionArgumentList args);
    public ICppExpressionNode CreateCtorCallExpression(QualifiedReference type, ICppExpressionsArgumentListNode args);
    public UnaryExpression CreateUnaryExpression(CppOperatorKind operatorKind, ICppExpressionNode operand);
    public BinaryExpression CreateBinaryExpression(CppOperatorKind operatorKind, ICppExpressionNode left, ICppExpressionNode right);
    public DynamicExceptionSpecification CreateDynamicExceptionSpecification(IList`1<DynamicExceptionSpecificationElement> elements);
    public NoExceptSpecification CreateNoExceptSpecification(ICppExpressionNode expression);
    public NoExceptSpecification CreateNoExceptSpecification(TriBool value);
    public CppUnparsedTextNode CreateUnparsedTextNode(string text);
    public TNode CreateUnparsedTextNode(string text, CppCompositeNodeType nodeType);
    public static ITokenNode CreateBlockComment(string text);
    public static ITokenNode CreateIdentifier(string text);
    public CppDoxygenCommandNode CreateDoxygenCommandNode(CppDoxygenCommandNameNode name, CppLanguageDialect dialect, string text);
    public static AttributeList CreateMaybeUnusedAttribute(ISolution solution);
    public static AttributeList CreateNoreturnAttribute(ISolution solution);
    public static AttributeList CreateAttributeList(ISolution solution, string attributeList);
    public static PPPragmaDirective CreatePragmaOnce(ISolution solution);
    public UsingEnumDeclaration CreateUsingEnumDeclaration(string enumText);
    public TNode CreateDeclarationInEmptyContext(CppLanguageDialect dialect, string text);
    public CppTreeElementRange CreateModuleName(string text);
    private ICppNestedDeclarationNode CreateDeclarationInContext(CppInclusionContext ctx, string text, ITreeNode[] args);
    private static IList`1<ParameterMarker> ParseFormatString(String& format, ITreeNode[] args);
    private static TNode Clear(TNode node);
    private static TNode SubstituteNodes(TNode node, IList`1<ParameterMarker> markers, ITreeNode[] args);
    private static ILazyCachingLexer CreateCachingLexer(string text, CppLanguageDialect dialect);
    private static CppParser CreateParserFromText(IPsiModule module, CppLanguageDialect dialect, string text);
    private static IParser CreateDoxygenParserFromText(IPsiModule module, CppLanguageDialect dialect, string text);
    private static CppParser CreateParserFromTextWithInclusionContext(string text, CppInclusionContext inclusionContext);
    private static ICppExpressionNode GetExpression(SimpleDeclaration decl);
}
public enum JetBrains.ReSharper.Psi.Cpp.CppFileFlavour : Enum {
    public byte value__;
    public static CppFileFlavour OrdinaryFile;
    public static CppFileFlavour MicrosoftLibraryFile;
    public static CppFileFlavour BoostScopeExitFile;
    public static CppFileFlavour BoostTypeOfFile;
    public static CppFileFlavour BoostOtherLibraryFile;
    public static CppFileFlavour PixarUSDPreprocessorUtils;
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("JetBrains.ReSharper.Psi.Cpp.CppListDebugView`1")]
public class JetBrains.ReSharper.Psi.Cpp.CppList`1 : ValueType {
    private T[] myItems;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; private set; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public CppList`1(T item);
    public CppList`1(T item1, T item2);
    public CppList`1(IEnumerable`1<T> items);
    public CppList`1(int capacity);
    public CppList`1<T> Copy();
    [IsReadOnlyAttribute]
public T[] ToArray();
    public T[] TakeArray();
    public CppSmallArray`1<T> TakeSmallArray();
    public List`1<T> ToList();
    public CppListEnumerator`1<T> GetEnumerator();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.CppList`1/<ToEnumerable>d__11")]
public IEnumerable`1<T> ToEnumerable();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public bool get_IsReadOnly();
    public void Add(T item);
    public void AddRange(CppList`1<T> items);
    public void AddRange(ICollection`1<T> items);
    public void AddRange(IEnumerable`1<T> items);
    public void Alloc(int n);
    public void Clear();
    public bool Contains(T item);
    public void CopyTo(T[] dest, int idx);
    public bool Remove(T item);
    public T get_Item(int i);
    public void set_Item(int i, T value);
    public int IndexOf(T item);
    public void Insert(int i, T val);
    public void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public void CopyTo(CppList`1& destination, int count);
    public T First();
    public T First(Predicate`1<T> predicate);
    public T FirstOrDefault();
    public T FirstOrDefault(Predicate`1<T> predicate);
    public T Single();
    public T SingleItem(T defaultValue);
    public T Last();
    public T LastOrDefault();
    public bool Any();
    public bool Any(Predicate`1<T> predicate);
    public bool All(Predicate`1<T> predicate);
    public int LastIndexOf(T item);
    public bool IsEmpty();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> comparison);
    public void Append(T[] a, int length);
    public void Append(CppList`1<T> other);
    public void Resize(int newSize);
    public int BinarySearch(T item);
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public void ClearNoFill();
    public void SetRawStorage(T[] items, int size);
    public T[] GetRawStorage();
    public static ReadOnlySpan`1<T> op_Implicit(CppList`1<T> list);
    private void Expand(int min);
    private int CalculateNewCapacity(int min);
    public void Shuffle(Random rnd);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.CppListDebugView`1 : ValueType {
    private CppList`1<T> myList;
    [NotNullAttribute]
[DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public CppListDebugView`1(CppList`1<T> localList);
    public T[] get_Items();
}
public class JetBrains.ReSharper.Psi.Cpp.CppListEnumerator`1 : ValueType {
    private CppList`1<T> myList;
    private int myIndex;
    private int myCount;
    [CompilerGeneratedAttribute]
private T <Current>k__BackingField;
    public T Current { get; private set; }
    public CppListEnumerator`1(CppList`1<T> list);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public T get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(T value);
    public bool MoveNext();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.CppListUtil : object {
    [ExtensionAttribute]
public static CppList`1<T> AsCppList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static bool SequenceEqual(CppList`1<T> lhs, CppList`1<T> rhs, IEqualityComparer`1<T> comparer);
}
public class JetBrains.ReSharper.Psi.Cpp.CppRecursionCounter`1 : object {
    [ThreadStaticAttribute]
private static int ourCounter;
    [CompilerGeneratedAttribute]
private static int <Limit>k__BackingField;
    public static int Limit { get; }
    private static CppRecursionCounter`1();
    [CompilerGeneratedAttribute]
public static int get_Limit();
    public static bool Increment();
    public static void Decrement();
    public static CppRecursionGuard<TCounter> Enter();
}
public class JetBrains.ReSharper.Psi.Cpp.CppRecursionCounterWithKey`1 : object {
    [ThreadStaticAttribute]
private static Dictionary`2<object, int> ourRecursiveCallsForKeys;
    [CompilerGeneratedAttribute]
private static int <Limit>k__BackingField;
    private static Dictionary`2<object, int> RecursiveCallsForKeys { get; }
    public static int Limit { get; }
    private static CppRecursionCounterWithKey`1();
    private static Dictionary`2<object, int> get_RecursiveCallsForKeys();
    [CompilerGeneratedAttribute]
public static int get_Limit();
    public static bool Increment(object key);
    public static void Decrement(object key);
    public static CppPreventRecursionGuardWithKey<TCounter> Enter(object key);
}
public class JetBrains.ReSharper.Psi.Cpp.CppSingleValue`1 : ValueType {
    private Nullable`1<T> myElement;
    public void Add(T value);
    public void AddRange(CppSingleValue`1<T> other);
    public bool HasValue();
    public static bool op_Implicit(CppSingleValue`1<T> value);
    public T GetValue();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Cpp.CppSmallArray`1 : ValueType {
    public static CppSmallArray`1<T> Empty;
    private object myItemOrItems;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public CppSmallArray`1(T item);
    public CppSmallArray`1(IEnumerable`1<T> items);
    public CppSmallArray`1(CppList`1<T> items);
    public CppSmallArray`1(T[] items);
    private static CppSmallArray`1();
    public static CppSmallArray`1<T> Copy(CppSmallArray`1<T> other);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public CppSmallArrayEnumerator`1<T> GetEnumerator();
    [PureAttribute]
public bool IsEmpty();
    [PureAttribute]
public T First();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] a, int destinationIndex);
    public void CopyTo(T[] a, int destinationIndex, int length);
    public T[] ToArray();
    public sealed virtual bool Remove(T item);
    public sealed virtual T get_Item(int i);
    public sealed virtual void set_Item(int i, T value);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int i, T val);
    public sealed virtual void RemoveAt(int i);
    public void Sort(Comparison`1<T> comparison);
    internal object GetRaw();
    internal static CppSmallArray`1<T> FromRaw(object data);
}
public class JetBrains.ReSharper.Psi.Cpp.CppSmallArrayEnumerator`1 : ValueType {
    private CppSmallArray`1<T> myList;
    private int myIndex;
    private int myCount;
    [CompilerGeneratedAttribute]
private T <Current>k__BackingField;
    public T Current { get; private set; }
    private object System.Collections.IEnumerator.Current { get; }
    public object CurrentEnumerator { get; }
    public CppSmallArrayEnumerator`1(CppSmallArray`1<T> list);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual T get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(T value);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public object get_CurrentEnumerator();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.CppSmallEnumerable`1 : ValueType {
    public static CppSmallEnumerable`1<T> Empty;
    private object myItemOrItems;
    public int Count { get; }
    public CppSmallEnumerable`1(T item);
    public CppSmallEnumerable`1(IEnumerable`1<T> items);
    private static CppSmallEnumerable`1();
    public Enumerator<T> GetEnumerator();
    public CppSmallList`1<T> ToSmallList();
    public bool IsEmpty();
    public bool IsEmptyOrSingle();
    public int get_Count();
    public T First();
    public T LastOrDefault();
    public CppSmallEnumerable`1<T> Where(Func`2<T, bool> predicate);
    public object GetRaw();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Cpp.CppSmallList`1 : ValueType {
    public static CppSmallList`1<T> Empty;
    private object myItemOrItems;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public CppSmallList`1(T item);
    public CppSmallList`1(T item1, T item2);
    public CppSmallList`1(IEnumerable`1<T> items);
    public CppSmallList`1(JetHashSet`1<T> items);
    public CppSmallList`1(CppSmallList`1<T> items);
    internal CppSmallList`1(ListHolder<T> list);
    private static CppSmallList`1();
    public static CppSmallList`1<T> Copy(CppSmallList`1<T> other);
    [IsReadOnlyAttribute]
public CppSmallListEnumerator`1<T> GetEnumerator();
    [IsReadOnlyAttribute]
[IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.CppSmallList`1/<ToEnumerable>d__11")]
public IEnumerable`1<T> ToEnumerable();
    public bool IsEmpty();
    public void AddRange(CppSmallList`1<T> other);
    public void RemoveRange(int first, int count);
    [IsReadOnlyAttribute]
public int get_Count();
    public bool get_IsReadOnly();
    public void Add(T item);
    public void Clear();
    public bool Contains(T item);
    public void CopyTo(T[] arr, int i);
    public bool Remove(T item);
    public T get_Item(int i);
    public void set_Item(int i, T value);
    public int IndexOf(T item);
    public void Insert(int i, T val);
    public void RemoveAt(int i);
    public void Sort(IComparer`1<T> comparer);
    public T FirstOrDefault();
    public T Single();
    [IsReadOnlyAttribute]
public T SingleItem(T defaultValue);
    public bool All(Predicate`1<T> predicate);
    public bool Any(Predicate`1<T> predicate);
    public T[] TakeArray();
    internal object GetRaw();
    private ListHolder<T> ConvertToDynamic();
    private void TryConvertToStatic(ListHolder<T> storage);
}
public class JetBrains.ReSharper.Psi.Cpp.CppSmallListEnumerator`1 : ValueType {
    private CppSmallList`1<T> myList;
    private int myIndex;
    private int myCount;
    [CompilerGeneratedAttribute]
private T <Current>k__BackingField;
    public T Current { get; private set; }
    public CppSmallListEnumerator`1(CppSmallList`1<T> list);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public T get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(T value);
    public bool MoveNext();
}
public class JetBrains.ReSharper.Psi.Cpp.CppTreeNodeVisitor`1 : object {
    public virtual TResult VisitNode(ITreeNode node);
}
public enum JetBrains.ReSharper.Psi.Cpp.Doxygen.ArgRange : Enum {
    public int value__;
    public static ArgRange Word;
    public static ArgRange Line;
    public static ArgRange BracedWord;
    public static ArgRange QuotedString;
    public static ArgRange Paragraph;
    public static ArgRange CommaSeparatedList;
    public static ArgRange BracketedCommaSeparatedList;
    public static ArgRange QualifiedReference;
}
public enum JetBrains.ReSharper.Psi.Cpp.Doxygen.ArgRefType : Enum {
    public int value__;
    public static ArgRefType None;
    public static ArgRefType FileRef;
    public static ArgRefType NamespaceRef;
    public static ArgRefType ClassRef;
    public static ArgRefType FunctionRef;
    public static ArgRefType ParamRef;
    public static ArgRefType TemplateParamRef;
    public static ArgRefType QualifiedReference;
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Doxygen.Argument : ValueType {
    [CompilerGeneratedAttribute]
private ArgRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ArgRefType <RefType>k__BackingField;
    public ArgRange Range { get; public set; }
    public bool IsOptional { get; public set; }
    public string Name { get; public set; }
    public ArgRefType RefType { get; public set; }
    public Argument(ArgRange Range, bool IsOptional, string Name, ArgRefType RefType);
    [CompilerGeneratedAttribute]
public ArgRange get_Range();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Range(ArgRange value);
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsOptional(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public ArgRefType get_RefType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RefType(ArgRefType value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Argument left, Argument right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Argument left, Argument right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Argument other);
    [CompilerGeneratedAttribute]
public void Deconstruct(ArgRange& Range, Boolean& IsOptional, String& Name, ArgRefType& RefType);
}
public class JetBrains.ReSharper.Psi.Cpp.Doxygen.Command : object {
    public string Name;
    public Argument[] Args;
    public bool Valid;
    public Command(string name, Argument[] args, bool isValidInCpp);
}
public static class JetBrains.ReSharper.Psi.Cpp.Doxygen.CommandHelper : object {
    public static Dictionary`2<string, Command> Commands;
    public static Dictionary`2<string, PairedDoxygenCommand> PairedCommands;
    public static Dictionary`2<string, PairedDoxygenCommand> PairedCommandEndings;
    public static Dictionary`2<string, DoxygenSimpleListCommand> SimpleListCommands;
    public static Dictionary`2<string, PairedHtmlTag> PairedHtmlTags;
    public static HashSet`1<string> IsSectioning;
    private static CommandHelper();
    public static bool CommandHasLineArg(string commandName);
    [CompilerGeneratedAttribute]
internal static Argument <.cctor>g__Arg|6_0(ArgRange range, bool isOptional, string name, ArgRefType refType);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__AddCommand|6_1(string name, Argument[] args);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__AddUselessCommand|6_2(string name, Argument[] args);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__AddPairedCommand|6_3(string startName, string endName, Argument[] args);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__AddSimpleListCommand|6_4(string name);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__AddPairedHtmlTag|6_5(string name, string description, bool omitEndTagIfParentClosed, String[] tags);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Doxygen.CppDoxygenFile : FileElementBase {
}
public class JetBrains.ReSharper.Psi.Cpp.Doxygen.CppDoxygenFilteringLexer : FilteringLexer {
    public CppDoxygenFilteringLexer(ILexer lexer);
    protected virtual bool Skip(TokenNodeType tt);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Cpp.Doxygen.CppDoxygenInjectedPsiProvider : IndependentInjectedPsiProvider {
    public PsiLanguageType GeneratedLanguage { get; }
    public bool ProvidedLanguageCanHaveNestedInjects { get; }
    public static bool IsApplicableToNode(ITreeNode node);
    public virtual bool IsApplicable(PsiLanguageType originalLanguage);
    public virtual bool IsApplicableToNode(ITreeNode node, IInjectedFileContext context);
    public virtual bool CouldBeApplicableToDescendants(ITreeNode node);
    public virtual PsiLanguageType get_GeneratedLanguage();
    public virtual bool get_ProvidedLanguageCanHaveNestedInjects();
    public virtual IInjectedNodeContext CreateInjectedNodeContext(IInjectedFileContext fileContext, ITreeNode originalNode);
    public virtual IInjectedNodeContext Regenerate(IndependentInjectedNodeContext nodeContext);
    protected virtual bool CanBeGeneratedNode(ITreeNode node);
    protected virtual bool CanBeOriginalNode(ITreeNode node);
}
[LanguageDefinitionAttribute("CPP_DOXYGEN")]
public class JetBrains.ReSharper.Psi.Cpp.Doxygen.CppDoxygenLanguage : UnmanagedKnownLanguage {
    public static string Name;
    public static string PresentableName;
    [CompilerGeneratedAttribute]
private static CppDoxygenLanguage <Instance>k__BackingField;
    [CanBeNullAttribute]
[UsedImplicitlyAttribute]
public static CppDoxygenLanguage Instance { get; public set; }
    public PsiLanguageCategories SupportedCategories { get; }
    protected CppDoxygenLanguage(string name);
    protected CppDoxygenLanguage(string name, string presentableName);
    [CompilerGeneratedAttribute]
public static CppDoxygenLanguage get_Instance();
    [CompilerGeneratedAttribute]
public static void set_Instance(CppDoxygenLanguage value);
    public virtual PsiLanguageCategories get_SupportedCategories();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.Cpp.Doxygen.CppDoxygenLanguage", "16")]
public class JetBrains.ReSharper.Psi.Cpp.Doxygen.CppDoxygenLanguageService : LanguageService {
    [CompilerGeneratedAttribute]
private ICodeFormatter <CodeFormatter>k__BackingField;
    public ICodeFormatter CodeFormatter { get; }
    public bool IsCaseSensitive { get; }
    public ILanguageCacheProvider CacheProvider { get; }
    public IDeclaredElementPresenter DeclaredElementPresenter { get; }
    public bool SupportTypeMemberCache { get; }
    public ITypePresenter TypePresenter { get; }
    public bool ParticipatesInClrCaches { get; }
    public CppDoxygenLanguageService(CppDoxygenLanguage language, IConstantValueService constantValueService);
    [CompilerGeneratedAttribute]
public virtual ICodeFormatter get_CodeFormatter();
    public virtual bool get_IsCaseSensitive();
    public virtual ILanguageCacheProvider get_CacheProvider();
    public virtual IDeclaredElementPresenter get_DeclaredElementPresenter();
    public virtual bool get_SupportTypeMemberCache();
    public virtual ITypePresenter get_TypePresenter();
    public virtual ILexerFactory GetPrimaryLexerFactory();
    public virtual ILexer CreateFilteringLexer(ILexer lexer);
    public virtual bool IsValidName(DeclaredElementType elementType, string name);
    public virtual IParser CreateParser(ILexer lexer, IPsiModule module, IPsiSourceFile sourceFile);
    public virtual IEnumerable`1<ITypeDeclaration> FindTypeDeclarations(IFile file);
    public virtual ReferenceAccessType GetReferenceAccessType(IDeclaredElement target, IReference reference);
    public virtual bool get_ParticipatesInClrCaches();
}
public class JetBrains.ReSharper.Psi.Cpp.Doxygen.CppDoxygenLexerFactory : object {
    public sealed virtual ILexer CreateLexer(IBuffer buffer);
}
public class JetBrains.ReSharper.Psi.Cpp.Doxygen.DoxygenSimpleListCommand : PairedCommandBase {
    public DoxygenSimpleListCommand(string name);
    public virtual bool HasEndingName(string name);
}
public interface JetBrains.ReSharper.Psi.Cpp.Doxygen.IPairedCommand {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual bool HasEndingName(string name);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Doxygen.PairedCommandBase : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    protected PairedCommandBase(string name);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    public abstract virtual bool HasEndingName(string name);
}
public class JetBrains.ReSharper.Psi.Cpp.Doxygen.PairedDoxygenCommand : PairedCommandBase {
    public string EndName;
    public Argument[] Args;
    public bool Valid;
    public PairedDoxygenCommand(string startName, string endName, Argument[] args, bool valid);
    public virtual bool HasEndingName(string name);
}
public class JetBrains.ReSharper.Psi.Cpp.Doxygen.PairedHtmlTag : PairedCommandBase {
    public bool OmitEndTagIfParentClosed;
    public String[] BreakingTags;
    public PairedHtmlTag(string name, bool omitEndTagIfParentClosed, String[] breakingTags);
    public virtual bool HasEndingName(string name);
    public bool HasBreakingTag(string name);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppAbstractExpressionVisitorWithDefaults`1 : object {
    public virtual TResult Visit(ICppEmptyExpression expr);
    public virtual TResult Visit(ICppResolvedLiteralExpression expr);
    public virtual TResult Visit(ICppUserDefinedLiteralExpression expr);
    public virtual TResult Visit(ICppResolvedUserDefinedLiteralExpression expr);
    public virtual TResult Visit(ICppThisExpression expr);
    public virtual TResult Visit(ICppResolvedThisExpression expr);
    public virtual TResult Visit(ICppParenExpression expr);
    public virtual TResult Visit(ICppBinaryExpression expr);
    public virtual TResult Visit(ICppResolvedBinaryExpression expr);
    public virtual TResult Visit(ICppUnaryExpression expr);
    public virtual TResult Visit(ICppResolvedUnaryExpression expr);
    public virtual TResult Visit(ICppPostfixExpression expr);
    public virtual TResult Visit(ICppResolvedPostfixExpression expr);
    public virtual TResult Visit(ICppConditionalExpression expr);
    public virtual TResult Visit(ICppResolvedConditionalExpression expr);
    public virtual TResult Visit(ICppQualifiedReferenceExpression expr);
    public virtual TResult Visit(ICppResolvedQualifiedReferenceExpression expr);
    public virtual TResult Visit(ICppLinkageQualifiedReferenceExpression expr);
    public virtual TResult Visit(ICppMemberAccessExpression expr);
    public virtual TResult Visit(ICppResolvedMemberAccessExpression expr);
    public virtual TResult Visit(ICppNewExpression expr);
    public virtual TResult Visit(ICppResolvedNewExpression expr);
    public virtual TResult Visit(ICppDeleteExpression expr);
    public virtual TResult Visit(ICppSubscriptExpression expr);
    public virtual TResult Visit(ICppResolvedSubscriptExpression expr);
    public virtual TResult Visit(ICppCallExpression expr);
    public virtual TResult Visit(ICppResolvedCallExpression expr);
    public virtual TResult Visit(ICppCastExpression expr);
    public virtual TResult Visit(ICppResolvedCastExpression expr);
    public virtual TResult Visit(ICppSizeOfExpression expr);
    public virtual TResult Visit(ICppResolvedSizeOfExpression expr);
    public virtual TResult Visit(ICppSizeOfEllipsisExpression expr);
    public virtual TResult Visit(ICppResolvedSizeOfEllipsisExpression expr);
    public virtual TResult Visit(ICppAlignOfExpression expr);
    public virtual TResult Visit(ICppResolvedAlignOfExpression expr);
    public virtual TResult Visit(ICppTypeIdExpression expr);
    public virtual TResult Visit(ICppResolvedTypeIdExpression expr);
    public virtual TResult Visit(ICppNoExceptExpression expr);
    public virtual TResult Visit(ICppResolvedNoExceptExpression expr);
    public virtual TResult Visit(ICppSingleArgumentTypeTraitExpression expr);
    public virtual TResult Visit(ICppResolvedSingleArgumentTypeTraitExpression expr);
    public virtual TResult Visit(ICppDoubleArgumentTypeTraitExpression expr);
    public virtual TResult Visit(ICppResolvedDoubleArgumentTypeTraitExpression expr);
    public virtual TResult Visit(ICppMultiArgumentTypeTraitExpression expr);
    public virtual TResult Visit(ICppResolvedMultiArgumentTypeTraitExpression expr);
    public virtual TResult Visit(ICppMSUuidOfExpression expr);
    public virtual TResult Visit(ICppResolvedMSUuidOfExpression expr);
    public virtual TResult Visit(ICppMSEventHookExpression expr);
    public virtual TResult Visit(ICppResolvedMSEventHookExpression expr);
    public virtual TResult Visit(ICppMSNoopExpression expr);
    public virtual TResult Visit(ICppMSAssumeExpression expr);
    public virtual TResult Visit(ICppBuiltinAddressOfExpression expr);
    public virtual TResult Visit(ICppResolvedBuiltinAddressOfExpression expr);
    public virtual TResult Visit(ICppBuiltinOffsetOfExpression expr);
    public virtual TResult Visit(ICppResolvedBuiltinOffsetOfExpression expr);
    public virtual TResult Visit(ICppGnuBuiltinConstantPExpression expr);
    public virtual TResult Visit(ICppResolvedGnuBuiltinConstantPExpression expr);
    public virtual TResult Visit(ICppGNUAddressOfLabelExpression expr);
    public virtual TResult Visit(ICppResolvedGNUAddressOfLabelExpression expr);
    public virtual TResult Visit(ICppThrowExpression expr);
    public virtual TResult Visit(ICppBracedInitListExpression expr);
    public virtual TResult Visit(ICppResolvedBracedInitListExpression expr);
    public virtual TResult Visit(ICppBraceInitializedTemporaryExpression expr);
    public virtual TResult Visit(ICppResolvedBraceInitializedTemporaryExpression expr);
    public virtual TResult Visit(ICppLambdaExpression expr);
    public virtual TResult Visit(ICppReplacedLambdaExpression expr);
    public virtual TResult Visit(ICppGnuStatementExpression expr);
    public virtual TResult Visit(ICppReplacedGnuStatementExpression expr);
    public virtual TResult Visit(ICppRequiresExpression expr);
    public virtual TResult Visit(ICppReplacedRequiresExpression expr);
    public virtual TResult Visit(ICppLinkageRequiresExpression expr);
    public virtual TResult Visit(ICppCliMultiArgumentSubscriptExpression expr);
    public virtual TResult Visit(ICppResolvedCliMultiArgumentSubscriptExpression expr);
    public virtual TResult Visit(ICppCliTypeIdExpression expr);
    public virtual TResult Visit(ICppResolvedCliTypeIdExpression expr);
    public virtual TResult Visit(ICppPackExpansionExpression expr);
    public virtual TResult Visit(ICppResolvedPackExpansionExpression expr);
    public virtual TResult Visit(ICppFoldExpression expr);
    public virtual TResult Visit(ICppResolvedFoldExpression expr);
    public virtual TResult Visit(ICppCoAwaitExpression expr);
    public virtual TResult Visit(ICppResolvedCoAwaitExpression expr);
    public virtual TResult Visit(ICppCoYieldExpression expr);
    public virtual TResult Visit(ICppResolvedCoYieldExpression expr);
    public virtual TResult Visit(ICppDesignation expr);
    public virtual TResult Visit(ICppResolvedDesignation expr);
    public virtual TResult Visit(ICppC11GenericExpression expr);
    public virtual TResult Visit(ICppResolvedC11GenericExpression expr);
    public abstract virtual TResult VisitExpression(ICppExpression expr);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppAbstractForwardingExpressionVisitor`1 : CppAbstractExpressionVisitorWithDefaults`1<TResult> {
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppAbstractResolvedExpressionVisitor`1 : CppAbstractExpressionVisitorWithDefaults`1<TResult> {
    public virtual TResult VisitExpression(ICppExpression expr);
    public abstract virtual TResult VisitExpression(ICppResolvedExpression expr);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppAlignOfExpression : CppExpressionBase {
    private ICppTypeIdOrExpression myArgument;
    public CppAlignOfExpression(ICppTypeIdOrExpression argument);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppTypeIdOrExpression GetArgument();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppAllLambdaCaptureDescription : CppLambdaCaptureDescription {
    public CppLambdaCaptureDescriptionKind Kind { get; }
    public CppAllLambdaCaptureDescription(CppLambdaCaptureStyle captureStyle);
    public virtual CppLambdaCaptureDescriptionKind get_Kind();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppArgumentList : object {
    public static CppArgumentList EmptyList;
    private ICppExpression[] myArguments;
    public CppArgumentList(ICppExpression[] arguments);
    public CppArgumentList(ICppExpression arg);
    private static CppArgumentList();
    public sealed virtual ICppExpression[] GetArguments();
    public sealed virtual CppArgumentListKind GetArgListKind();
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Cpp.Expressions.CppArgumentListKind : Enum {
    public byte value__;
    public static CppArgumentListKind BRACED;
    public static CppArgumentListKind PAREN;
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppArrayValue : object {
    public int Length { get; }
    public abstract virtual int get_Length();
    public abstract virtual ICppEvaluationResult At(int index, ICppEvaluationErrorTracker errorTracker);
    public virtual ICppLiteralValue GetValue();
    public sealed virtual Result Accept(ICppValueVisitor`1<Result> visitor);
    public abstract virtual bool ContainsEvaluationFail(CppEvaluationParams evalParams);
    public virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public virtual TriBool IsNoexcept();
    public abstract virtual CppDependentInfo GetDependentInfo();
    public abstract virtual CppTypeContext TryGetTypeContext();
    public abstract virtual CppQualType GetElementType(ICppResolvedTypeFactory tf);
    public abstract virtual string Present(ICppPresenter p);
    public virtual bool EqualReferences(CppArrayValue other);
    public virtual UpdateStatus UpdateElementValue(int index, ICppEvaluationResult newValue);
    protected static string PresentArrayValue(CppArrayValue array, ICppPresenter presenter);
}
internal class JetBrains.ReSharper.Psi.Cpp.Expressions.CppAssertTypeClassVisitor : object {
    private CppTypeClasses myTypec;
    public CppAssertTypeClassVisitor(CppTypeClasses typec);
    public sealed virtual bool Visit(ICppEmptyExpression e);
    public sealed virtual bool Visit(ICppResolvedLiteralExpression e);
    public sealed virtual bool Visit(ICppUserDefinedLiteralExpression e);
    public sealed virtual bool Visit(ICppResolvedUserDefinedLiteralExpression e);
    public sealed virtual bool Visit(ICppThisExpression e);
    public sealed virtual bool Visit(ICppResolvedThisExpression e);
    public sealed virtual bool Visit(ICppParenExpression e);
    public sealed virtual bool Visit(ICppBinaryExpression e);
    public sealed virtual bool Visit(ICppResolvedBinaryExpression e);
    public sealed virtual bool Visit(ICppUnaryExpression e);
    public sealed virtual bool Visit(ICppResolvedUnaryExpression e);
    public sealed virtual bool Visit(ICppPostfixExpression e);
    public sealed virtual bool Visit(ICppResolvedPostfixExpression e);
    public sealed virtual bool Visit(ICppConditionalExpression e);
    public sealed virtual bool Visit(ICppResolvedConditionalExpression e);
    public sealed virtual bool Visit(ICppQualifiedReferenceExpression e);
    public sealed virtual bool Visit(ICppResolvedQualifiedReferenceExpression e);
    public sealed virtual bool Visit(ICppMemberAccessExpression e);
    public sealed virtual bool Visit(ICppResolvedMemberAccessExpression e);
    public sealed virtual bool Visit(ICppNewExpression e);
    public sealed virtual bool Visit(ICppResolvedNewExpression e);
    public sealed virtual bool Visit(ICppDeleteExpression e);
    public sealed virtual bool Visit(ICppSubscriptExpression e);
    public sealed virtual bool Visit(ICppResolvedSubscriptExpression e);
    public sealed virtual bool Visit(ICppCallExpression e);
    public sealed virtual bool Visit(ICppResolvedCallExpression e);
    public sealed virtual bool Visit(ICppCastExpression e);
    public sealed virtual bool Visit(ICppResolvedCastExpression e);
    public sealed virtual bool Visit(ICppSizeOfExpression e);
    public sealed virtual bool Visit(ICppSizeOfEllipsisExpression e);
    public sealed virtual bool Visit(ICppResolvedSizeOfExpression e);
    public sealed virtual bool Visit(ICppResolvedSizeOfEllipsisExpression e);
    public sealed virtual bool Visit(ICppAlignOfExpression e);
    public sealed virtual bool Visit(ICppResolvedAlignOfExpression e);
    public sealed virtual bool Visit(ICppTypeIdExpression e);
    public sealed virtual bool Visit(ICppResolvedTypeIdExpression e);
    public sealed virtual bool Visit(ICppNoExceptExpression e);
    public sealed virtual bool Visit(ICppResolvedNoExceptExpression e);
    public sealed virtual bool Visit(ICppSingleArgumentTypeTraitExpression e);
    public sealed virtual bool Visit(ICppResolvedSingleArgumentTypeTraitExpression e);
    public sealed virtual bool Visit(ICppDoubleArgumentTypeTraitExpression e);
    public sealed virtual bool Visit(ICppResolvedDoubleArgumentTypeTraitExpression e);
    public sealed virtual bool Visit(ICppMultiArgumentTypeTraitExpression e);
    public sealed virtual bool Visit(ICppResolvedMultiArgumentTypeTraitExpression e);
    public sealed virtual bool Visit(ICppMSUuidOfExpression e);
    public sealed virtual bool Visit(ICppResolvedMSUuidOfExpression e);
    public sealed virtual bool Visit(ICppMSEventHookExpression e);
    public sealed virtual bool Visit(ICppResolvedMSEventHookExpression e);
    public sealed virtual bool Visit(ICppMSNoopExpression e);
    public sealed virtual bool Visit(ICppMSAssumeExpression e);
    public sealed virtual bool Visit(ICppBuiltinAddressOfExpression e);
    public sealed virtual bool Visit(ICppResolvedBuiltinAddressOfExpression e);
    public sealed virtual bool Visit(ICppGnuBuiltinConstantPExpression e);
    public sealed virtual bool Visit(ICppResolvedGnuBuiltinConstantPExpression e);
    public sealed virtual bool Visit(ICppGNUAddressOfLabelExpression expr);
    public sealed virtual bool Visit(ICppResolvedGNUAddressOfLabelExpression expr);
    public sealed virtual bool Visit(ICppBuiltinOffsetOfExpression e);
    public sealed virtual bool Visit(ICppResolvedBuiltinOffsetOfExpression e);
    public sealed virtual bool Visit(ICppThrowExpression e);
    public sealed virtual bool Visit(ICppBracedInitListExpression e);
    public sealed virtual bool Visit(ICppResolvedBracedInitListExpression e);
    public sealed virtual bool Visit(ICppBraceInitializedTemporaryExpression e);
    public sealed virtual bool Visit(ICppResolvedBraceInitializedTemporaryExpression e);
    public sealed virtual bool Visit(ICppLambdaExpression e);
    public sealed virtual bool Visit(ICppReplacedLambdaExpression e);
    public sealed virtual bool Visit(ICppGnuStatementExpression e);
    public sealed virtual bool Visit(ICppReplacedGnuStatementExpression e);
    public sealed virtual bool Visit(ICppRequiresExpression e);
    public sealed virtual bool Visit(ICppReplacedRequiresExpression e);
    public sealed virtual bool Visit(ICppLinkageRequiresExpression e);
    public sealed virtual bool Visit(ICppLinkageQualifiedReferenceExpression e);
    public sealed virtual bool Visit(ICppCliMultiArgumentSubscriptExpression expr);
    public sealed virtual bool Visit(ICppResolvedCliMultiArgumentSubscriptExpression expr);
    public sealed virtual bool Visit(ICppCliTypeIdExpression e);
    public sealed virtual bool Visit(ICppResolvedCliTypeIdExpression e);
    public sealed virtual bool Visit(ICppPackExpansionExpression e);
    public sealed virtual bool Visit(ICppResolvedPackExpansionExpression e);
    public sealed virtual bool Visit(ICppFoldExpression e);
    public sealed virtual bool Visit(ICppResolvedFoldExpression e);
    public sealed virtual bool Visit(ICppCoAwaitExpression e);
    public sealed virtual bool Visit(ICppResolvedCoAwaitExpression e);
    public sealed virtual bool Visit(ICppCoYieldExpression e);
    public sealed virtual bool Visit(ICppResolvedCoYieldExpression e);
    public sealed virtual bool Visit(ICppDesignation d);
    public sealed virtual bool Visit(ICppResolvedDesignation d);
    public sealed virtual bool Visit(ICppC11GenericExpression e);
    public sealed virtual bool Visit(ICppResolvedC11GenericExpression e);
    public void VisitGenericClauses(ICppC11GenericExpression e);
    public void VisitArgumentList(ICppArgumentList argList);
    public void VisitArguments(ICppExpression[] args);
    public void VisitArguments(CppSmallArray`1<ICppExpression> args);
    private void VisitTypeIdOrExpression(ICppTypeIdOrExpression toe);
    private void ReApply(ICppExpression expr);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppBaseDesignator : object {
    private ICppDesignator myQualifier;
    protected CppBaseDesignator(ICppDesignator qualifier);
    public sealed virtual ICppDesignator GetQualifier();
    public abstract virtual TResult Accept(ICppDesignatorVisitor`1<TResult> v);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppBinaryExpression : CppExpressionBase {
    private ICppExpression myLeftArgument;
    private ICppExpression myRightArgument;
    private CppOperatorKind myOperatorKind;
    [DebuggerStepThroughAttribute]
public CppBinaryExpression(ICppExpression leftArgument, ICppExpression rightArgument, CppOperatorKind operatorKind);
    [DebuggerStepThroughAttribute]
public sealed virtual ICppExpression GetLeftArgument();
    [DebuggerStepThroughAttribute]
public sealed virtual ICppExpression GetRightArgument();
    [DebuggerStepThroughAttribute]
public sealed virtual CppOperatorKind GetOperatorKind();
    [DebuggerStepThroughAttribute]
public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppBoolValue : CppValueBase`1<bool> {
    public static CppBoolValue False;
    public static CppBoolValue True;
    private CppBoolValue(bool value);
    private static CppBoolValue();
    public static CppBoolValue Create(bool value);
    public virtual Result Accept(ICppValueVisitor`1<Result> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppBracedInitListExpression : CppExpressionBase {
    public static CppBracedInitListExpression Empty;
    private ICppExpression[] myArgument;
    private bool myHasBeenShrinked;
    protected CppBracedInitListExpression(ICppExpression[] arguments, bool hasBeenShrinked);
    private static CppBracedInitListExpression();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppExpression[] GetArguments();
    public sealed virtual bool HasBeenShrinked();
    public sealed virtual CppArgumentListKind GetArgListKind();
    public static CppBracedInitListExpression Create(ICppExpression[] arguments, bool hasBeenShrinked);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppBracedInitListValue : CppValueBase {
    [CompilerGeneratedAttribute]
private bool <hasBeenShrinked>P;
    [NotNullAttribute]
public ICppExpression[] Elements;
    public static CppBracedInitListValue Empty;
    public CppBracedInitListValue(ICppExpression[] elements, bool hasBeenShrinked);
    private static CppBracedInitListValue();
    public virtual Result Accept(ICppValueVisitor`1<Result> visitor);
    public virtual bool Equals(object obj);
    public bool Equals(CppBracedInitListValue rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual ICppExpression[] GetArguments();
    public sealed virtual CppArgumentListKind GetArgListKind();
    public sealed virtual bool HasBeenShrinked();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppBraceInitializedTemporaryExpression : CppExpressionBase {
    private ICppTypeIdOrExpression myInitializerTypeNode;
    private ICppBracedInitListExpression myArgumentList;
    public CppBraceInitializedTemporaryExpression(ICppTypeIdOrExpression initializerTypeNode, ICppBracedInitListExpression argumentList);
    public sealed virtual ICppTypeIdOrExpression GetInitializerTypeNode();
    public sealed virtual ICppBracedInitListExpression GetArgumentList();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppBuiltinAddressOfExpression : CppExpressionBase {
    protected ICppExpression myArgument;
    public CppBuiltinAddressOfExpression(ICppExpression argument);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppExpression GetArgument();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppBuiltinOffsetOfExpression : CppExpressionBase {
    private CppQualType myTypeArgument;
    private CppQualifiedName myMemberDesignator;
    public CppBuiltinOffsetOfExpression(CppQualType typeArgument, CppQualifiedName memberDesignator);
    public sealed virtual CppQualType GetTypeArgument();
    public sealed virtual CppQualifiedName GetMemberDesignator();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppC11GenericExpression : CppExpressionBase {
    private ICppExpression myControllingExpression;
    private CppC11GenericExpressionClause[] myClauses;
    [DebuggerStepThroughAttribute]
public CppC11GenericExpression(ICppExpression control, CppC11GenericExpressionClause[] clauses);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    [DebuggerStepThroughAttribute]
public sealed virtual ICppExpression GetControllingExpression();
    [DebuggerStepThroughAttribute]
public sealed virtual CppC11GenericExpressionClause[] GetClauses();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppC11GenericExpressionClause : ValueType {
    public bool IsDefault;
    public CppQualType Type;
    public ICppExpression Expression;
    public CppC11GenericExpressionClause(ICppExpression arg);
    public CppC11GenericExpressionClause(CppQualType type, ICppExpression arg);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppCallExpression : CppExpressionBase {
    private ICppTypeIdOrExpression myCallee;
    private ICppExpression[] myArguments;
    [DebuggerStepThroughAttribute]
public CppCallExpression(ICppTypeIdOrExpression callee, ICppExpression[] arguments);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    [DebuggerStepThroughAttribute]
public sealed virtual ICppTypeIdOrExpression GetCallee();
    [DebuggerStepThroughAttribute]
public sealed virtual ICppExpression[] GetArguments();
}
public enum JetBrains.ReSharper.Psi.Cpp.Expressions.CppCallExpressionKind : Enum {
    public int value__;
    public static CppCallExpressionKind CALL;
    public static CppCallExpressionKind CAST;
}
internal class JetBrains.ReSharper.Psi.Cpp.Expressions.CppCanBeLazyMerged : object {
    private ICppLazyMergingDataConsumer myResultConsumer;
    public CppCanBeLazyMerged(ICppLazyMergingDataConsumer resultConsumer);
    public sealed virtual bool Visit(ICppEmptyExpression e);
    public sealed virtual bool Visit(ICppResolvedLiteralExpression e);
    public sealed virtual bool Visit(ICppUserDefinedLiteralExpression e);
    public sealed virtual bool Visit(ICppResolvedUserDefinedLiteralExpression e);
    public sealed virtual bool Visit(ICppThisExpression e);
    public sealed virtual bool Visit(ICppResolvedThisExpression e);
    public sealed virtual bool Visit(ICppParenExpression e);
    public sealed virtual bool Visit(ICppBinaryExpression e);
    public sealed virtual bool Visit(ICppResolvedBinaryExpression e);
    public sealed virtual bool Visit(ICppUnaryExpression e);
    public sealed virtual bool Visit(ICppResolvedUnaryExpression e);
    public sealed virtual bool Visit(ICppPostfixExpression e);
    public sealed virtual bool Visit(ICppResolvedPostfixExpression e);
    public sealed virtual bool Visit(ICppConditionalExpression e);
    public sealed virtual bool Visit(ICppResolvedConditionalExpression e);
    public sealed virtual bool Visit(ICppQualifiedReferenceExpression e);
    public sealed virtual bool Visit(ICppResolvedQualifiedReferenceExpression e);
    public sealed virtual bool Visit(ICppLinkageQualifiedReferenceExpression e);
    public sealed virtual bool Visit(ICppMemberAccessExpression e);
    public sealed virtual bool Visit(ICppResolvedMemberAccessExpression e);
    public sealed virtual bool Visit(ICppNewExpression e);
    public sealed virtual bool Visit(ICppResolvedNewExpression e);
    public sealed virtual bool Visit(ICppDeleteExpression e);
    public sealed virtual bool Visit(ICppSubscriptExpression e);
    public sealed virtual bool Visit(ICppResolvedSubscriptExpression e);
    public sealed virtual bool Visit(ICppCallExpression e);
    public sealed virtual bool Visit(ICppResolvedCallExpression e);
    public sealed virtual bool Visit(ICppCastExpression e);
    public sealed virtual bool Visit(ICppResolvedCastExpression e);
    public sealed virtual bool Visit(ICppSizeOfExpression e);
    public sealed virtual bool Visit(ICppResolvedSizeOfExpression e);
    public sealed virtual bool Visit(ICppSizeOfEllipsisExpression e);
    public sealed virtual bool Visit(ICppResolvedSizeOfEllipsisExpression e);
    public sealed virtual bool Visit(ICppAlignOfExpression e);
    public sealed virtual bool Visit(ICppResolvedAlignOfExpression e);
    public sealed virtual bool Visit(ICppTypeIdExpression e);
    public sealed virtual bool Visit(ICppResolvedTypeIdExpression e);
    public sealed virtual bool Visit(ICppNoExceptExpression noExcept);
    public sealed virtual bool Visit(ICppResolvedNoExceptExpression e);
    public sealed virtual bool Visit(ICppSingleArgumentTypeTraitExpression e);
    public sealed virtual bool Visit(ICppResolvedSingleArgumentTypeTraitExpression e);
    public sealed virtual bool Visit(ICppDoubleArgumentTypeTraitExpression e);
    public sealed virtual bool Visit(ICppResolvedDoubleArgumentTypeTraitExpression e);
    public sealed virtual bool Visit(ICppMultiArgumentTypeTraitExpression e);
    public sealed virtual bool Visit(ICppResolvedMultiArgumentTypeTraitExpression e);
    public sealed virtual bool Visit(ICppMSUuidOfExpression e);
    public sealed virtual bool Visit(ICppResolvedMSUuidOfExpression e);
    public sealed virtual bool Visit(ICppMSEventHookExpression e);
    public sealed virtual bool Visit(ICppResolvedMSEventHookExpression e);
    public sealed virtual bool Visit(ICppMSNoopExpression e);
    public sealed virtual bool Visit(ICppMSAssumeExpression e);
    public sealed virtual bool Visit(ICppBuiltinAddressOfExpression e);
    public sealed virtual bool Visit(ICppResolvedBuiltinAddressOfExpression e);
    public sealed virtual bool Visit(ICppGnuBuiltinConstantPExpression e);
    public sealed virtual bool Visit(ICppResolvedGnuBuiltinConstantPExpression e);
    public sealed virtual bool Visit(ICppGNUAddressOfLabelExpression e);
    public sealed virtual bool Visit(ICppResolvedGNUAddressOfLabelExpression e);
    public sealed virtual bool Visit(ICppBuiltinOffsetOfExpression e);
    public sealed virtual bool Visit(ICppResolvedBuiltinOffsetOfExpression e);
    public sealed virtual bool Visit(ICppThrowExpression e);
    public sealed virtual bool Visit(ICppBracedInitListExpression e);
    public sealed virtual bool Visit(ICppResolvedBracedInitListExpression e);
    public sealed virtual bool Visit(ICppBraceInitializedTemporaryExpression e);
    public sealed virtual bool Visit(ICppResolvedBraceInitializedTemporaryExpression e);
    public sealed virtual bool Visit(ICppLambdaExpression lambda);
    public sealed virtual bool Visit(ICppReplacedLambdaExpression e);
    public sealed virtual bool Visit(ICppGnuStatementExpression stmt);
    public sealed virtual bool Visit(ICppReplacedGnuStatementExpression _);
    public sealed virtual bool Visit(ICppRequiresExpression expr);
    public sealed virtual bool Visit(ICppReplacedRequiresExpression e);
    public sealed virtual bool Visit(ICppLinkageRequiresExpression e);
    public sealed virtual bool Visit(ICppCliMultiArgumentSubscriptExpression expr);
    public sealed virtual bool Visit(ICppResolvedCliMultiArgumentSubscriptExpression expr);
    public sealed virtual bool Visit(ICppCliTypeIdExpression expr);
    public sealed virtual bool Visit(ICppResolvedCliTypeIdExpression e);
    public sealed virtual bool Visit(ICppPackExpansionExpression e);
    public sealed virtual bool Visit(ICppResolvedPackExpansionExpression e);
    public sealed virtual bool Visit(ICppC11GenericExpression e);
    public sealed virtual bool Visit(ICppResolvedC11GenericExpression e);
    public sealed virtual bool Visit(ICppFoldExpression e);
    public sealed virtual bool Visit(ICppResolvedFoldExpression e);
    public sealed virtual bool Visit(ICppCoAwaitExpression e);
    public sealed virtual bool Visit(ICppResolvedCoAwaitExpression e);
    public sealed virtual bool Visit(ICppCoYieldExpression e);
    public sealed virtual bool Visit(ICppResolvedCoYieldExpression e);
    public sealed virtual bool Visit(ICppDesignation e);
    public sealed virtual bool Visit(ICppResolvedDesignation e);
    public void VisitGenericClauses(ICppC11GenericExpression e);
    public bool VisitArgumentList(ICppArgumentList argList);
    public bool VisitArguments(ICppExpression[] args);
    public bool VisitTypeIdOrExpression(ICppTypeIdOrExpression toe);
    private void ReApply(ICppDesignator designator);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppCastExpression : CppExpressionBase {
    private ICppExpression myArgument;
    private CppCastType myCastType;
    private CppQualType myQualType;
    public CppCastExpression(ICppExpression argument, CppCastType castType, CppQualType qualType);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppExpression GetArgument();
    public sealed virtual CppCastType GetCastType();
    public sealed virtual CppQualType GetQualType();
}
public enum JetBrains.ReSharper.Psi.Cpp.Expressions.CppCastType : Enum {
    public int value__;
    public static CppCastType C_STYLE;
    public static CppCastType STATIC_CAST;
    public static CppCastType DYNAMIC_CAST;
    public static CppCastType REINTERPRET_CAST;
    public static CppCastType CONST_CAST;
    public static CppCastType SAFE_CAST;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppCastTypeEx : object {
    [ExtensionAttribute]
public static CppCastType TokenTypeToCastType(TokenNodeType tt);
    [ExtensionAttribute]
public static string NonCStyleCastTypeToString(CppCastType castType);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppCheckSubstitutionFailureExpressionVisitor : CppAbstractResolvedExpressionVisitor`1<bool> {
    public static CppCheckSubstitutionFailureExpressionVisitor Instance;
    private static CppCheckSubstitutionFailureExpressionVisitor();
    public virtual bool VisitExpression(ICppResolvedExpression expr);
    public virtual bool Visit(ICppEmptyExpression expr);
    public virtual bool Visit(ICppResolvedLiteralExpression expr);
    public virtual bool Visit(ICppResolvedUserDefinedLiteralExpression expr);
    public virtual bool Visit(ICppResolvedThisExpression expr);
    public virtual bool Visit(ICppParenExpression expr);
    public virtual bool Visit(ICppResolvedBinaryExpression expr);
    public virtual bool Visit(ICppResolvedUnaryExpression expr);
    public virtual bool Visit(ICppResolvedPostfixExpression expr);
    public virtual bool Visit(ICppResolvedConditionalExpression expr);
    public virtual bool Visit(ICppResolvedQualifiedReferenceExpression expr);
    public virtual bool Visit(ICppResolvedMemberAccessExpression expr);
    public virtual bool Visit(ICppResolvedNewExpression expr);
    public virtual bool Visit(ICppDeleteExpression expr);
    public virtual bool Visit(ICppResolvedSubscriptExpression expr);
    public virtual bool Visit(ICppResolvedCallExpression expr);
    public virtual bool Visit(ICppResolvedCastExpression expr);
    public virtual bool Visit(ICppResolvedSizeOfExpression expr);
    public virtual bool Visit(ICppResolvedSizeOfEllipsisExpression expr);
    public virtual bool Visit(ICppResolvedAlignOfExpression expr);
    public virtual bool Visit(ICppResolvedTypeIdExpression expr);
    public virtual bool Visit(ICppResolvedNoExceptExpression expr);
    public virtual bool Visit(ICppResolvedSingleArgumentTypeTraitExpression expr);
    public virtual bool Visit(ICppResolvedDoubleArgumentTypeTraitExpression expr);
    public virtual bool Visit(ICppResolvedMultiArgumentTypeTraitExpression expr);
    public virtual bool Visit(ICppResolvedMSUuidOfExpression expr);
    public virtual bool Visit(ICppResolvedMSEventHookExpression expr);
    public virtual bool Visit(ICppMSNoopExpression expr);
    public virtual bool Visit(ICppMSAssumeExpression expr);
    public virtual bool Visit(ICppResolvedBuiltinAddressOfExpression expr);
    public virtual bool Visit(ICppResolvedBuiltinOffsetOfExpression expr);
    public virtual bool Visit(ICppResolvedGnuBuiltinConstantPExpression expr);
    public virtual bool Visit(ICppThrowExpression expr);
    public virtual bool Visit(ICppResolvedBracedInitListExpression expr);
    public virtual bool Visit(ICppResolvedBraceInitializedTemporaryExpression expr);
    public virtual bool Visit(ICppLambdaExpression expr);
    public virtual bool Visit(ICppRequiresExpression expr);
    public virtual bool Visit(ICppResolvedCliMultiArgumentSubscriptExpression expr);
    public virtual bool Visit(ICppReplacedLambdaExpression expr);
    public virtual bool Visit(ICppReplacedGnuStatementExpression _);
    public virtual bool Visit(ICppReplacedRequiresExpression expr);
    public virtual bool Visit(ICppLinkageRequiresExpression expr);
    public virtual bool Visit(ICppResolvedPackExpansionExpression expr);
    public virtual bool Visit(ICppResolvedCliTypeIdExpression expr);
    public virtual bool Visit(ICppResolvedFoldExpression expr);
    public virtual bool Visit(ICppResolvedCoAwaitExpression expr);
    public virtual bool Visit(ICppResolvedCoYieldExpression expr);
    public virtual bool Visit(ICppResolvedC11GenericExpression expr);
    public virtual bool Visit(ICppResolvedDesignation d);
    public bool ReApply(ICppResolvedExpression expr);
    public bool ReApply(CppQualType type);
    public bool ReApply(ICppArgumentList argList);
    public bool ReApply(ICppExpression[] args);
    public bool ReApply(ICppTypeIdOrExpression te);
    public bool ReApply(ICppResolveEntity re);
    private bool ReApplyToResolvedOperator(CppResolveResult& rr, ICppResolvedExpression expr);
    private bool ReApplyToResolvedReference(CppResolveResult& rr);
    private bool ReApplyToCalledExpression(ICppTypeIdOrExpression expr);
    private bool VisitBinaryExpression(ICppResolvedBinaryExpression expr, bool fromCall);
    private bool Visit(ICppResolvedQualifiedReferenceExpression expr, bool couldBeType);
    private static bool HasTypeOrUnknownDependentArguments(ICppExpression[] arguments);
    private static bool IsCallOfConstructorOfAbstractClass(ICppFunctionDeclaratorResolveEntity func, ICppResolvedOperatorCallExpression expr);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppClassMemberEvaluatorUtil : object {
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static CppEvaluationFail EvaluateMember(CppObjectValue objectValue, ICppResolveEntity member, TEvaluator evaluator);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppClassTraitsUtil : object {
    public static bool IsFinalOrSealed(CppQualType argument, CppViewPos& viewPos);
    public static bool IsClass(CppQualType argument);
    public static bool IsUnion(CppQualType argument);
    public static bool IsEnum(CppQualType argument);
    public static bool IsFunction(CppQualType argument);
    public static bool IsObject(CppQualType argument);
    public static bool IsAbstract(CppQualType argument, CppViewPos& viewPos);
    public static bool IsPolymorphic(CppQualType argument, CppViewPos& viewPos);
    public static bool IsInterfaceClass(CppQualType argument);
    public static bool IsRefArray(CppQualType argument);
    public static bool IsRefClass(CppQualType argument);
    public static bool IsValueClass(CppQualType argument);
    public static bool IsDelegate(CppQualType argument);
    public static bool IsCompound(CppQualType argument);
    public static bool IsFundamental(CppQualType argument);
    [ExtensionAttribute]
public static TriBool HasUniqueObjectRepresentations(CppQualType argument, CppViewPos& vp);
    public static CppFunctionTraits CopyAssignmentTraits(CppQualType type, CppTypeContext& tc, ICppFriendDeclTargetResolveEntity accessScope);
    public static CppFunctionTraits MoveAssignmentTraits(CppQualType type, CppTypeContext& tc, ICppFriendDeclTargetResolveEntity accessScope);
    public static bool IsAssignable(CppQualType to, CppQualType from, CppTypeContext& tc, ICppFriendDeclTargetResolveEntity accessScope);
    public static bool IsTriviallyAssignable(CppQualType to, CppQualType from, CppTypeContext& tc, ICppFriendDeclTargetResolveEntity accessScope);
    public static bool IsMoveAssignable(CppQualType type, CppTypeContext& context, ICppFriendDeclTargetResolveEntity accessScope);
    public static bool IsTriviallyCopyAssignable(CppQualType type, CppTypeContext& context, ICppFriendDeclTargetResolveEntity accessScope);
    public static bool IsTriviallyMoveAssignable(CppQualType type, CppTypeContext& context, ICppFriendDeclTargetResolveEntity accessScope);
    private static CppQualType MakeLValueConstReference(CppQualType type);
    public static CppFunctionTraits AssignmentTraits(CppQualType to, CppQualType from, CppTypeContext& tc, ICppFriendDeclTargetResolveEntity accessScope);
    private static CppFunctionTraits BuiltinAssignmentTraits(CppTypeAndCategory leftType, CppViewPos& vp);
    public static bool IsCopyConstructible(CppQualType type, CppTypeContext& ctx, ICppFriendDeclTargetResolveEntity accessScope);
    public static bool IsMoveConstructible(CppQualType type, CppTypeContext& ctx, ICppFriendDeclTargetResolveEntity accessScope);
    public static bool IsDefaultConstructible(CppQualType type, CppTypeContext& tc);
    public static bool IsConstructible(ICppResolvedMultiArgumentTypeTraitExpression e, CppTypeContext& typeContext);
    private static bool CanBeParenAggregate(CppQualType targetType, CppTypeContext& tc);
    public static bool IsTriviallyDefaultConstructible(CppQualType type, CppTypeContext& typeContext);
    public static bool IsTriviallyConstructible(ICppResolvedMultiArgumentTypeTraitExpression e, CppTypeContext& typeContext);
    public static CppFunctionTraits CopyCtorTraits(CppQualType type, CppTypeContext& typeContext, ICppFriendDeclTargetResolveEntity accessScope);
    public static CppFunctionTraits MoveCtorTraits(CppQualType type, CppTypeContext& typeContext, ICppFriendDeclTargetResolveEntity accessScope);
    public static CppTypeAndCategory AddRValueReference(CppQualType type);
    private static ICppExpression[] CreateIsConstructibleMockArguments(CppList`1<Element> arguments);
    private static CppFunctionTraits GetConversionTraits(CppImplicitConversionSequence conv, ICppFriendDeclTargetResolveEntity accessScope, CppExpressionInfo from, CppTypeContext& tc);
    private static CppTypeAndCategory MakeLValueConst(CppQualType type);
    private static CppFunctionTraits GetConstructionTraits(CppQualType type, CppTypeContext& typeContext, ICppFriendDeclTargetResolveEntity accessScope, CppTypeAndCategory argType);
    private static CppExpressionInfo CreateFromArgument(CppList`1<Element> arguments);
    private static bool IsDestructorDeletedOrNonPublic(ICppFunctionDeclaratorResolveEntity dtor, CppViewPos& vp);
    public static bool HasNotSatisfiedRequirement(CppGroupedFunctionDeclaratorResolveEntity dtor, CppViewPos& vp);
    public static bool HasDeletedOrNonPublicDestructor(ICppClassResolveEntity clazz, CppViewPos& vp);
    public static bool CalculateHasTrivialDestructor(ICppClassResolveEntity clazz, CppViewPos& vp);
    public static bool CalculateHasNothrowDestructor(ICppClassResolveEntity clazz, CppViewPos& vp);
    private static bool BaseClassIsNothrowDestructible(ICppClassResolveEntity baseClass, ICppClassResolveEntity currentClass, CppViewPos vp);
    public static bool IsDestructible(CppQualType type, CppViewPos& vp);
    public static bool IsTriviallyDestructible(CppQualType type, CppViewPos& vp);
    public static bool IsNothrowDestructible(CppQualType type, CppViewPos& vp, bool isTypeOfField);
    private static bool IsPOD(ICppClassResolveEntity clazz, CppViewPos& vp);
    public static bool IsPOD(CppQualType type, CppViewPos& viewPos);
    private static bool TraverseBases(ICppClassResolveEntity clazz, HashSet`1<ICppClassResolveEntity> bases, ICppClassResolveEntity& nonEmptyBase, bool stopOnFirstNonEmptyBase);
    public static bool MSetContainsBase(ICppClassResolveEntity clazz, HashSet`1<ICppClassResolveEntity> bases);
    public static bool IsStandardLayout(ICppClassResolveEntity clazz, CppViewPos& viewPos);
    public static bool CalculateIsStandardLayout(ICppClassResolveEntity clazz, CppViewPos& viewPos);
    public static bool IsStandardLayout(CppQualType type, CppViewPos& viewPos);
    public static bool CalculateIsTriviallyCopyable(ICppClassResolveEntity clazz, CppViewPos& viewPos);
    public static bool CalculateIsTriviallyCopyableWithoutRegardToDestructor(ICppClassResolveEntity clazz, CppViewPos& vp);
    private static bool AllSubobjectAreTriviallyCopyable(ICppClassResolveEntity clazz, CppViewPos& vp);
    private static MemberProperty CalcMemberProperty(CppGroupedFunctionDeclaratorResolveEntity ctor);
    public static bool CalculateHasTrivialConstructor(ICppClassResolveEntity clazz);
    public static bool IsTriviallyCopyable(CppQualType type, CppViewPos& viewPos);
    public static bool HasTrivialConstructor(CppQualType type, CppViewPos& viewPos);
    public static bool IsTrivial(CppQualType type, CppViewPos& viewPos);
    public static bool HasVirtualDestructor(CppQualType type, CppViewPos& viewPos);
    public static bool HasFinalizer(CppQualType type, CppViewPos& viewPos);
    [CompilerGeneratedAttribute]
internal static bool <IsConstructible>g__CanBeAggregateInitialized|29_0(CppQualType targetType, CppTypeContext& typeContext, ICppExpression[] arguments);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppClassValueUtil : object {
    public static ICppEvaluationResult CreateDefaultInitialized(ICppClassResolveEntity clazz, CppExpressionEvaluator evaluator, bool zeroPreInitialize);
    public static ICppEvaluationResult CreateZeroInitialized(ICppClassResolveEntity clazz, CppExpressionEvaluator evaluator);
    public static ICppEvaluationResult EvaluateParenCtor(ICppClassResolveEntity clazz, ICppExpression[] arguments, CppExpressionEvaluator evaluator, bool zeroPreInitializeIfValueInitialization);
    public static ICppEvaluationResult EvaluateBracedCtor(ICppClassResolveEntity clazz, ICppResolvedBracedInitListExpression bracedList, CppExpressionEvaluator evaluator);
    private static ICppEvaluationResult EvaluateTrivialCtor(ICppClassResolveEntity clazz, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
public static Nullable`1<CppList`1<ICppClassResolveEntity>> GetBasesForEvaluation(ICppClassResolveEntity clazz, CppExpressionEvaluator evaluator, CppEvaluationFail& error);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppCliMultiArgumentSubscriptExpression : CppExpressionBase {
    private ICppExpression[] myIndexArguments;
    private ICppExpression myLeftArgument;
    public CppCliMultiArgumentSubscriptExpression(ICppExpression leftArgument, ICppExpression[] indexArguments);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppExpression GetLeftArgument();
    public sealed virtual ICppExpression[] GetIndexArguments();
    public sealed virtual int GetIndexArgumentCount();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppCliTypeIdExpression : CppExpressionBase {
    private CppQualifiedName myArgument;
    public CppCliTypeIdExpression(CppQualifiedName argument);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppQualifiedName GetArgument();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppCoAwaitExpression : CppExpressionBase {
    private ICppExpression myArgument;
    public CppCoAwaitExpression(ICppExpression argument);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppExpression GetArgument();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppConditionalExpression : CppExpressionBase {
    private ICppExpression myFirstArgument;
    private ICppExpression mySecondArgument;
    private ICppExpression myThirdArgument;
    private CppConditionalExprKind myExprKind;
    public CppConditionalExpression(ICppExpression firstArgument, ICppExpression secondArgument, ICppExpression thirdArgument, CppConditionalExprKind exprKind);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppExpression GetFirstArgument();
    public sealed virtual ICppExpression GetSecondArgument();
    public sealed virtual ICppExpression GetThirdArgument();
    public sealed virtual CppConditionalExprKind GetKind();
}
internal class JetBrains.ReSharper.Psi.Cpp.Expressions.CppContainsLambdaVisitor : CppAbstractResolvedExpressionVisitor`1<bool> {
    public static CppContainsLambdaVisitor Instance;
    private static CppContainsLambdaVisitor();
    private bool ReApply(ICppExpression expr);
    private bool ReApply(ICppExpression[] args);
    private bool ReApply(ICppArgumentList argList);
    private bool ReApply(ICppTypeIdOrExpression typeOrExpr);
    public virtual bool VisitExpression(ICppResolvedExpression expr);
    public virtual bool Visit(ICppEmptyExpression e);
    public virtual bool Visit(ICppResolvedLiteralExpression e);
    public virtual bool Visit(ICppResolvedUserDefinedLiteralExpression e);
    public virtual bool Visit(ICppResolvedThisExpression e);
    public virtual bool Visit(ICppParenExpression expr);
    public virtual bool Visit(ICppResolvedBinaryExpression expr);
    public virtual bool Visit(ICppResolvedUnaryExpression expr);
    public virtual bool Visit(ICppResolvedPostfixExpression expr);
    public virtual bool Visit(ICppResolvedConditionalExpression expr);
    public virtual bool Visit(ICppResolvedQualifiedReferenceExpression e);
    public virtual bool Visit(ICppResolvedMemberAccessExpression expr);
    public virtual bool Visit(ICppResolvedNewExpression expr);
    public virtual bool Visit(ICppDeleteExpression expr);
    public virtual bool Visit(ICppResolvedSubscriptExpression expr);
    public virtual bool Visit(ICppResolvedCallExpression expr);
    public virtual bool Visit(ICppResolvedCastExpression expr);
    public virtual bool Visit(ICppResolvedSizeOfExpression expr);
    public virtual bool Visit(ICppResolvedSizeOfEllipsisExpression e);
    public virtual bool Visit(ICppResolvedAlignOfExpression expr);
    public virtual bool Visit(ICppResolvedTypeIdExpression expr);
    public virtual bool Visit(ICppResolvedNoExceptExpression expr);
    public virtual bool Visit(ICppResolvedSingleArgumentTypeTraitExpression e);
    public virtual bool Visit(ICppResolvedDoubleArgumentTypeTraitExpression e);
    public virtual bool Visit(ICppResolvedMultiArgumentTypeTraitExpression e);
    public virtual bool Visit(ICppResolvedMSUuidOfExpression expr);
    public virtual bool Visit(ICppMSNoopExpression e);
    public virtual bool Visit(ICppMSAssumeExpression expr);
    public virtual bool Visit(ICppResolvedBuiltinAddressOfExpression expr);
    public virtual bool Visit(ICppResolvedGnuBuiltinConstantPExpression expr);
    public virtual bool Visit(ICppResolvedBuiltinOffsetOfExpression e);
    public virtual bool Visit(ICppThrowExpression expr);
    public virtual bool Visit(ICppResolvedBracedInitListExpression expr);
    public virtual bool Visit(ICppResolvedBraceInitializedTemporaryExpression expr);
    public virtual bool Visit(ICppReplacedLambdaExpression e);
    public virtual bool Visit(ICppReplacedGnuStatementExpression _);
    public virtual bool Visit(ICppReplacedRequiresExpression e);
    public virtual bool Visit(ICppLinkageRequiresExpression e);
    public virtual bool Visit(ICppResolvedPackExpansionExpression expr);
    public virtual bool Visit(ICppResolvedCliTypeIdExpression e);
    public virtual bool Visit(ICppResolvedFoldExpression expr);
    public virtual bool Visit(ICppResolvedCoAwaitExpression expr);
    public virtual bool Visit(ICppResolvedCoYieldExpression expr);
    public virtual bool Visit(ICppResolvedC11GenericExpression expr);
    public virtual bool Visit(ICppResolvedDesignation d);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppConvertValueUtil : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppEvaluationResult ConvertValue(ICppValueExpression exprValue, CppQualType destType, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppEvaluationResult ConvertValue(CppExpressionValue source, CppQualType destType, CppExpressionEvaluator evaluator);
    private static bool ValueHasTypeQuickCheck(ICppValue val, CppQualType type, CppLanguageDialect dialect);
    internal static bool ValueHasTypeQuickCheck(ICppEvaluationResult val, CppNumericType numeric, CppLanguageDialect dialect);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppEvaluationResult ConvertToSigned(CppExpressionValue val, CppSignedValueKind signedKind, CppExpressionEvaluator evaluator);
    [CanBeNullAttribute]
private static ICppEvaluationResult ConvertToSignedImpl(CppExpressionValue val, CppSignedValueKind signedKind, CppQualType destType, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppEvaluationResult ConvertToUnsigned(CppExpressionValue val, CppUnsignedValueKind unsignedKind, CppExpressionEvaluator evaluator);
    [CanBeNullAttribute]
private static ICppEvaluationResult ConvertToUnsignedImpl(CppExpressionValue val, CppUnsignedValueKind unsignedKind, CppQualType destType, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppEvaluationResult ConvertToFloating(CppExpressionValue src, CppFloatingValueKind floatingKind, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
[CanBeNullAttribute]
private static ICppEvaluationResult ConvertToFloatingImpl(CppExpressionValue src, CppFloatingValueKind floatingKind, CppQualType destType, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppEvaluationResult ConvertToBool(CppExpressionValue src, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
public static TriBool ConvertToTriBool(CppExpressionValue src, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppEvaluationResult ConvertToPointer(CppExpressionValue src, CppQualType destType, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
[CanBeNullAttribute]
private static ICppEvaluationResult ConvertToArray(CppExpressionValue val, CppQualType destType, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
[CanBeNullAttribute]
private static ICppEvaluationResult ConvertToObject(CppExpressionValue source, ICppClassResolveEntity clazz, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
[CanBeNullAttribute]
private static ICppEvaluationResult ConvertToReference(CppExpressionValue src, CppQualType destType, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
[CanBeNullAttribute]
private static ICppEvaluationResult ConvertToNullptr(CppExpressionValue src, CppQualType destType, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
[CanBeNullAttribute]
private static ICppEvaluationResult ConvertToEnum(CppExpressionValue src, CppQualType destType, ICppClassResolveEntity enumeration, CppExpressionEvaluator evaluator);
    [CanBeNullAttribute]
private static CppReferenceValue TryBindReference(ICppValue val, CppQualType destType, CppTypeContext& tc);
    [CanBeNullAttribute]
private static ICppGroupedFunctionDeclaratorResolveEntity ResolveOverloadedFunction(CppFunctionOverloadSetValue value, CppQualType destType, CppTypeContext& tc);
    private static bool TryRunUserDefinedConversion(CppExpressionValue src, CppQualType destType, CppExpressionEvaluator evaluator, ICppEvaluationResult& result);
    private static CppEnumValue ConvertEnum(ICppIntegralValue initializerValue, ICppClassResolveEntity targetEnum, CppExpressionEvaluator evaluator);
    private static CppEnumValue ConvertEnum(CppEnumValue source, ICppClassResolveEntity targetEnum, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
public static ICppEvaluationResult ConvertToSizeT(CppExpressionValue value, CppExpressionEvaluator evaluator);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppCoYieldExpression : CppExpressionBase {
    private ICppExpression myArgument;
    public CppCoYieldExpression(ICppExpression argument);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public virtual ICppExpression GetArgument();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppCreateClassAndReplaceClassTypeUtil : object {
    [ExtensionAttribute]
public static ICppExpression CreateClassAndReplaceClassType(ICppExpression input, CppCreateClassAndReplaceClassTypeVisitor visitor);
    [ExtensionAttribute]
public static ICppExpression CreateClassAndReplaceClassType(ICppExpression input, CppCreateClassAndReplaceClassTypeContext& ctx);
    [ExtensionAttribute]
public static ICppTypeIdOrExpression CreateClassAndReplaceClassType(ICppTypeIdOrExpression input, CppCreateClassAndReplaceClassTypeContext& ctx);
    [ExtensionAttribute]
public static ICppArgumentList CreateClassAndReplaceClassType(ICppArgumentList input, CppCreateClassAndReplaceClassTypeContext& ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppCreateClassAndReplaceClassTypeVisitor : CppIdentityExpressionVisitor {
    private CppCreateClassAndReplaceClassTypeContext ctx;
    public CppCreateClassAndReplaceClassTypeVisitor(CppCreateClassAndReplaceClassTypeContext& ctx);
    public virtual ICppExpression Visit(ICppLambdaExpression e);
    public virtual ICppExpression Visit(ICppGnuStatementExpression e);
    public virtual ICppExpression Visit(ICppRequiresExpression e);
    private void CreateParameterList(CppParameterDeclaratorsData input, CppRequiresExpressionScopeResolveEntity scope);
    public virtual CppQualifiedName ReApply(CppQualifiedName name);
    public virtual CppQualType ReApply(CppQualType type);
    public CppCreateClassAndReplaceClassTypeVisitor Init(ICppScopeResolveEntity lexicalParent, ICppScopeResolveEntity structuralParent, CppTemplateHeaders& templateHeaders, CppQualType declSpecQualType);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppDeclaratorLambdaCaptureDescription : CppLambdaCaptureDescription {
    [CompilerGeneratedAttribute]
private ICppVariableDeclaratorResolveEntity <Declarator>k__BackingField;
    public CppLambdaCaptureDescriptionKind Kind { get; }
    [CanBeNullAttribute]
public ICppVariableDeclaratorResolveEntity Declarator { get; }
    public CppDeclaratorLambdaCaptureDescription(CppLambdaCaptureStyle captureStyle, ICppVariableDeclaratorResolveEntity resolveEntity);
    public virtual CppLambdaCaptureDescriptionKind get_Kind();
    [CompilerGeneratedAttribute]
public ICppVariableDeclaratorResolveEntity get_Declarator();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppDeclaratorLvalue : CppLval {
    [CompilerGeneratedAttribute]
private ICppDeclaratorResolveEntity <Declarator>k__BackingField;
    public ICppDeclaratorResolveEntity Declarator { get; }
    public CppDeclaratorLvalue(ICppDeclaratorResolveEntity declarator);
    [CompilerGeneratedAttribute]
public ICppDeclaratorResolveEntity get_Declarator();
    public virtual TResult Accept(ICppLvalVisitor`1<TResult> vis);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppDeleteExpression : CppExpressionBase {
    private ICppExpression myArgument;
    [CompilerGeneratedAttribute]
private DeleteExpressionKind <Kind>k__BackingField;
    public DeleteExpressionKind Kind { get; }
    public CppDeleteExpression(ICppExpression argument, DeleteExpressionKind kind);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppExpression GetArgument();
    [CompilerGeneratedAttribute]
public sealed virtual DeleteExpressionKind get_Kind();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppDependencyKillerValue : object {
    private ICppExpressionTemplateParameterOrPack myParam;
    public CppDependencyKillerValue(ICppExpressionTemplateParameterOrPack param);
    public sealed virtual ICppLiteralValue GetValue();
    public sealed virtual Result Accept(ICppValueVisitor`1<Result> visitor);
    public sealed virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public sealed virtual bool ContainsEvaluationFail(CppEvaluationParams _);
    public virtual string ToString();
    public ICppExpressionTemplateParameterOrPack GetTemplateParam();
    private bool Equals(CppDependencyKillerValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppDependentInfoCalculationUtil : object {
    [ExtensionAttribute]
public static CppDependentInfo AddValueDependencyIfTypeDependent(CppDependentInfo dinfo);
    [ExtensionAttribute]
public static CppDependentInfo ReplaceTypeToValueAndInstantiationDependencyForExpr(CppDependentInfo dinfo);
    [ExtensionAttribute]
public static CppDependentInfo ReplaceTypeToValueAndInstantiationDependencyForType(CppDependentInfo dinfo);
    [ExtensionAttribute]
public static CppDependentInfo DepInfoOfExpressionWithTypelikeArgument(ICppTypeIdOrExpression argument);
    [ExtensionAttribute]
public static CppDependentInfo DepInfoOfExpressionWithTypelikeArgument(CppDependentInfo argumentDep);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppDerefObjectLv : CppLval {
    [CompilerGeneratedAttribute]
private CppLval <DereferencedObj>k__BackingField;
    public CppLval DereferencedObj { get; }
    public CppDerefObjectLv(CppLval dereferencedObj);
    [CompilerGeneratedAttribute]
public CppLval get_DereferencedObj();
    public virtual TResult Accept(ICppLvalVisitor`1<TResult> vis);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppDesignation : object {
    private ICppDesignator myDesignator;
    private ICppExpression myInitializer;
    private InitializerKind myInitializerKind;
    public CppDesignation(ICppDesignator designator, ICppExpression initializer, InitializerKind initializerKind);
    public sealed virtual ICppDesignator GetDesignator();
    public sealed virtual ICppExpression GetInitializer();
    public sealed virtual InitializerKind GetInitializerKind();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppDesignationValue : CppValueBase {
    [NotNullAttribute]
private ICppDesignator myDesignator;
    [CompilerGeneratedAttribute]
private ICppResolvedExpression <Initializer>k__BackingField;
    private InitializerKind myInitializerKind;
    [NotNullAttribute]
public ICppResolvedExpression Initializer { get; }
    public CppDesignationValue(ICppDesignator designator, ICppResolvedExpression initializer, InitializerKind initializerKind);
    [CompilerGeneratedAttribute]
public ICppResolvedExpression get_Initializer();
    public string Present(ICppPresenter presenter);
    public virtual string ToString();
    public virtual CppTypeContext TryGetTypeContext();
    private bool Equals(CppDesignationValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Result Accept(ICppValueVisitor`1<Result> visitor);
    public sealed virtual ICppDesignator GetDesignator();
    public sealed virtual ICppExpression GetInitializer();
    public sealed virtual InitializerKind GetInitializerKind();
    public sealed virtual ICppResolvedExpression GetResolvedInitializer();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppDiscardedIntValueExpression : CppEmptyExpression {
    public static CppDiscardedIntValueExpression Instance;
    private static CppDiscardedIntValueExpression();
    public virtual CppDependentInfo GetDependentInfo();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppDoubleArgumentTypeTraitExpression : CppExpressionBase {
    private CppQualType myFirstArgument;
    private CppQualType mySecondArgument;
    private CppDoubleArgumentTypeTraitKind myKind;
    public CppDoubleArgumentTypeTraitExpression(CppQualType firstArgument, CppQualType secondArgument, CppDoubleArgumentTypeTraitKind kind);
    [DebuggerStepThroughAttribute]
public sealed virtual CppQualType GetFirstArgument();
    [DebuggerStepThroughAttribute]
public sealed virtual CppQualType GetSecondArgument();
    [DebuggerStepThroughAttribute]
public sealed virtual CppDoubleArgumentTypeTraitKind GetKind();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public enum JetBrains.ReSharper.Psi.Cpp.Expressions.CppDoubleArgumentTypeTraitKind : Enum {
    public int value__;
    public static CppDoubleArgumentTypeTraitKind IS_BASE_OF;
    public static CppDoubleArgumentTypeTraitKind IS_CONVERTIBLE_TO;
    public static CppDoubleArgumentTypeTraitKind IS_TRIVIALLY_ASSIGNABLE;
    public static CppDoubleArgumentTypeTraitKind IS_NOTHROW_ASSIGNABLE;
    public static CppDoubleArgumentTypeTraitKind IS_ASSIGNABLE;
    public static CppDoubleArgumentTypeTraitKind IS_SAME;
    public static CppDoubleArgumentTypeTraitKind IS_SAME_AS;
    public static CppDoubleArgumentTypeTraitKind IS_CONVERTIBLE;
    public static CppDoubleArgumentTypeTraitKind IS_NOTHROW_CONVERTIBLE;
    public static CppDoubleArgumentTypeTraitKind BUILTIN_TYPES_COMPATIBLE_P;
    public static CppDoubleArgumentTypeTraitKind IS_LAYOUT_COMPATIBLE;
    public static CppDoubleArgumentTypeTraitKind IS_POINTER_INTERCONVERTIBLE_BASE_OF;
    public static CppDoubleArgumentTypeTraitKind REFERENCE_CONSTRUCTS_FROM_TEMPORARY;
    public static CppDoubleArgumentTypeTraitKind REFERENCE_CONVERTS_FROM_TEMPORARY;
}
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppDoubleArgumentTypeTraitKindUtil : object {
    private static HashMap`2<TokenNodeType, CppDoubleArgumentTypeTraitKind> ourTokenToKind;
    private static HashMap`2<CppDoubleArgumentTypeTraitKind, TokenNodeType> ourKindToToken;
    private static CppDoubleArgumentTypeTraitKindUtil();
    public static CppDoubleArgumentTypeTraitKind TokenTypeToDoubleArgumentTypeTraitKind(TokenNodeType tok);
    public static string GetRepresentation(CppDoubleArgumentTypeTraitKind kind);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__Add|2_0(TokenNodeType token, CppDoubleArgumentTypeTraitKind kind);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppEmptyExpression : CppExpressionBase {
    public static CppEmptyExpression InstanceWithAggregateParenInitInfo;
    public static CppEmptyExpression InstanceWithInternalFailure;
    public static CppEmptyExpression InstanceWithSubstitutionFailure;
    private CppUnknownEntityInfo myInfo;
    protected CppEmptyExpression(CppUnknownEntityInfo info);
    private static CppEmptyExpression();
    public virtual CppUnknownEntityInfo GetInfo();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public virtual CppDependentInfo GetDependentInfo();
    public virtual TriBool IsNoexcept();
    public virtual CppTypeContext TryGetTypeContext();
    public static CppEmptyExpression Create(CppUnknownEntityInfo info);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppEnumValue : CppValueBase {
    private ICppClassResolveEntity myEnumeration;
    [NotNullAttribute]
public ICppIntegralValue UnderlyingValue;
    public CppEnumValue(ICppIntegralValue underlyingValue, ICppClassResolveEntity enumeration);
    public virtual Result Accept(ICppValueVisitor`1<Result> visitor);
    public virtual CppTypeContext TryGetTypeContext();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public ICppClassResolveEntity GetEnumeration();
    public string Present(ICppPresenter presenter);
}
internal class JetBrains.ReSharper.Psi.Cpp.Expressions.CppEqualsLvalVisitor : object {
    private CppLval myRhs;
    public CppEqualsLvalVisitor(CppLval rhs);
    public sealed virtual bool Visit(CppDeclaratorLvalue lhs);
    public sealed virtual bool Visit(CppThisObjectLv lhs);
    public sealed virtual bool Visit(CppObjectMemberLv lhs);
    public sealed virtual bool Visit(CppDerefObjectLv val);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppEvaluationErrorTracker : object {
    public static ICppEvaluationErrorTracker Default;
    private static CppEvaluationFail[] ourErrorByKind;
    private static CppEvaluationErrorTracker();
    public virtual bool ShouldReevaluate(CppEvaluationFail fail);
    public virtual CppEvaluationFail Fail(CppEvaluationFailureKind kind);
    public virtual CppEvaluationFail CallOfNonConstexprFunction(ICppFunctionDeclaratorResolveEntity function);
    public virtual CppEvaluationFail InvalidBodyOfConstexprFunction(ICppFunctionDeclaratorResolveEntity function);
    public virtual CppEvaluationFail UnresolvedReference(ICppResolvedQualifiedReferenceExpression expr);
    public virtual CppEvaluationFail UnresolvedExpression(ICppResolvedExpression expr);
    public virtual CppEvaluationFail IndexOutOfBounds(int index, int length);
    public virtual CppEvaluationFail NonIntegralArrayIndex(ICppResolvedExpression index, CppQualType type);
    public virtual CppEvaluationFail InvalidZeroInitialization(CppQualType type);
    public virtual CppEvaluationFail DeclaratorOfVoidType();
    public virtual CppEvaluationFail NonVoidReturnInVoidFunction(ICppValue value);
    public virtual CppEvaluationFail VoidReturnInNonVoidFunction(CppQualType type);
    public virtual CppEvaluationFail OffsetOfNonClassType(CppQualType type);
    public virtual CppEvaluationFail OffsetOfIncompleteType(ICppClassResolveEntity clazz);
    public virtual CppEvaluationFail OffsetOfUnresolvedDesignator(CppQualifiedName designator);
    public virtual CppEvaluationFail OffsetOfNonNonStaticDataMember(ICppResolveEntity entity);
    public virtual CppEvaluationFail OffsetOfBitfield(ICppDeclaratorResolveEntity declarator);
    public virtual CppEvaluationFail BadConversion(ICppResolvedExpression sourceExpr, CppQualType destType, ICppResolvedTypeFactory tf, bool isInitialization);
    public virtual CppEvaluationFail DuplicatedCtorInitializer(ICppResolveEntity member);
    public virtual CppEvaluationFail InternalUnsupportedFunction(ICppFunctionDeclaratorResolveEntity function);
    public virtual CppEvaluationFail InternalUnsupportedStatement(ICppResolveEntity statement);
    public virtual CppEvaluationFail InternalTooManyIterations();
    protected static bool MayProvideContext(CppEvaluationFailureKind failureKind);
    public virtual void EnterFunctionScope(ICppFunctionDeclaratorResolveEntity function);
    public virtual void LeaveFunctionScope();
    public virtual void EnterVariableScope(ICppGroupedVariableDeclaratorResolveEntity declarator);
    public virtual void LeaveVariableScope();
    private static CppEvaluationFail[] GenerateErrors();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppEvaluationErrorTrackerUtil : object {
    [ExtensionAttribute]
public static CppEvaluationFail InternalFail(ICppEvaluationErrorTracker tracker);
    [ExtensionAttribute]
public static CppEvaluationFail InternalFail(CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
public static ICppEvaluationResult GetValue(ICppGroupedVariableDeclaratorResolveEntity var, CppEvaluationParams evalParams);
    [ExtensionAttribute]
public static ICppEvaluationResult GetValue(ICppEnumeratorResolveEntity enumerator);
    [ExtensionAttribute]
public static ICppEvaluationResult At(CppArrayValue array, int index);
    [ExtensionAttribute]
public static bool IsInternalError(ICppEvaluationResult result);
    [ExtensionAttribute]
public static bool IsInternalEvaluationError(CppUnknownEntityInfo info);
    [ExtensionAttribute]
public static bool IsInternalError(CppExpressionEvaluationFailure info);
    [ExtensionAttribute]
private static bool IsInternalError(CppEvaluationFailureKind failure);
    [ExtensionAttribute]
public static UseFunctionScopeGuard UseFunctionScope(ICppEvaluationErrorTracker tracker, ICppFunctionDeclaratorResolveEntity declarator);
    [ExtensionAttribute]
public static UseVariableScopeGuard UseVariableScope(ICppEvaluationErrorTracker tracker, ICppGroupedVariableDeclaratorResolveEntity declarator);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppEvaluationFail : CppEmptyExpression {
    public CppExpressionEvaluationFailure Failure { get; }
    public CppEvaluationFailureKind FailureKind { get; }
    public CppEvaluationFail(CppExpressionEvaluationFailure failure);
    public sealed virtual bool ContainsEvaluationFail(CppEvaluationParams p);
    public CppExpressionEvaluationFailure get_Failure();
    public CppEvaluationFailureKind get_FailureKind();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppEvaluationParams : ValueType {
    public static CppEvaluationParams ForConstExpr;
    public static CppEvaluationParams Permissive;
    public bool IsPermissive;
    public CppIsConstantEvaluatedAssumedValue IsConstantEvaluatedAssumedValue;
    private CppEvaluationParams(bool isPermissive, CppIsConstantEvaluatedAssumedValue isConstantEvaluatedAssumedValue);
    private static CppEvaluationParams();
    public CppEvaluationParams With(CppIsConstantEvaluatedAssumedValue value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CppEvaluationParams left, CppEvaluationParams right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CppEvaluationParams left, CppEvaluationParams right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CppEvaluationParams other);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppEvaluationResultUtil : object {
    [ExtensionAttribute]
public static int GetEvalResultHashCode(ICppEvaluationResult result);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppEvaluationUtil : object {
    private static CppEvaluationFail ourDummySlot;
    private static CppEvaluationUtil();
    [ExtensionAttribute]
public static bool CanEvaluate(ICppResolvedExpression expr, CppQualType targetType);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static CppStringLiteralArrayValue TryCreateStringLiteralArray(CppStringLiteralValue literal, CppQualType targetType, CppTypeContext& tc);
    [CanBeNullAttribute]
public static ICppEvaluationResult EvaluateArrayAggregateInit(CppQualType targetType, ICppExpression[] srcArray, CppExpressionEvaluator evaluator);
    private static ICppEvaluationResult[] CreateArrayOfDummySlots(int n);
    [CanBeNullAttribute]
public static ICppEvaluationResult EvaluateClassAggregateInit(CppQualType ctype, ICppExpression[] arguments, CppArgumentListKind kind, CppExpressionEvaluator evaluator);
    [MustUseReturnValueAttribute]
private static ICppEvaluationResult EvaluateSingleAggregateInitItem(ICppValue objectOrArray, CppAggregateInitializationConversionItem item, CppExpressionEvaluator evaluator);
    private static ICppEvaluationResult EvaluateDummySlot(CppQualType memberType, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
private static bool HasAnyInitializedMemberOf(CppObjectValue thisObject, ICppClassResolveEntity clazz);
    private static ICppEvaluationResult EvaluateUnionEmptyAggregateInit(ICppClassResolveEntity clazz, CppExpressionEvaluator evaluator);
    [MustUseReturnValueAttribute]
private static bool PrepareClassForAggregateInitialization(CppObjectValue objectValue, ICppClassResolveEntity clazz, CppExpressionEvaluator evaluator, CppEvaluationFail& error);
    [MustUseReturnValueAttribute]
[CanBeNullAttribute]
private static ICppEvaluationResult FinishAggregateInitialization(ICppValue value, CppExpressionEvaluator evaluator);
    [MustUseReturnValueAttribute]
private static ICppEvaluationResult FinishClassAggregateInitialization(CppObjectValue thisObject, CppExpressionEvaluator evaluator);
    [MustUseReturnValueAttribute]
private static ICppEvaluationResult FinishClassAggregateInitializationImpl(CppObjectValue thisObject, ICppClassResolveEntity clazz, CppExpressionEvaluator evaluator);
    [MustUseReturnValueAttribute]
private static ICppEvaluationResult FinishArrayAggregateInitialization(CppArrayValue thisArray, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
private static bool IsDummySlot(ICppEvaluationResult result);
    [CanBeNullAttribute]
private static ICppEvaluationResult InitializedByEmptyBraces(CppQualType type, CppExpressionEvaluator evaluator);
}
internal enum JetBrains.ReSharper.Psi.Cpp.Expressions.CppExitStatus : Enum {
    public int value__;
    public static CppExitStatus Return;
    public static CppExitStatus Break;
    public static CppExitStatus Continue;
    public static CppExitStatus Nothing;
    public static CppExitStatus LastExpression;
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppExpressionBase : object {
    public abstract virtual Result Accept(ICppExpressionVisitor`1<Result> v);
    public sealed virtual string ToString();
    public sealed virtual bool Equals(object other);
    public sealed virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppExpressionEvaluationUtil : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppEvaluationResult EvaluateExpression(ICppResolvedExpression expr, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
[PublicAPIAttribute("This overload is needed to forbid evaluation of expressions statically known to be already evaluated")]
[ObsoleteAttribute("No need to evaluate already evaluated expression", "True")]
public static void EvaluateExpression(ICppEvaluationResult result, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppEvaluationResult EvaluateAndConvert(ICppResolvedExpression expr, CppQualType destType, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
public static TriBool EvaluateAndConvertToTriBool(ICppResolvedExpression expr, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
public static ICppEvaluationResult EvaluateCondition(ICppResolvedExpression expr, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
public static ICppEvaluationResult EvaluateTypeConstruction(CppExpressionEvaluator evaluator, ICppResolvedOperatorCallExpression e, ICppExpression[] args, CppArgumentListKind argListKind, CppQualType qualType);
    [ExtensionAttribute]
public static ICppEvaluationResult EvaluateClassTypeConstruction(CppExpressionEvaluator evaluator, CppResolveResult rr, ICppExpression[] args, CppArgumentListKind argListKind, CppQualType classType, bool zeroPreInitializeIfValueInitialization);
    [ExtensionAttribute]
private static ICppEvaluationResult EvaluateArrayTypeConstruction(CppExpressionEvaluator evaluator, CppResolveResult rr, ICppExpression[] args, CppQualType qualType);
    private static ICppEvaluationResult CreateStdInitializerList(ICppClassResolveEntity clazz, CppQualType elementType, ICppExpression[] args, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
public static ICppEvaluationResult Cast(CppExpressionEvaluator evaluator, ICppExpression arg, CppQualType destType);
    [ExtensionAttribute]
public static TriBool EvaluateRequiresClauseExpression(ICppResolvedExpression expr, CppTypeContext& tc, bool deep);
    [ExtensionAttribute]
public static TriBool EvaluateRequiresClauseExpression(CppExpressionEvaluator evaluator, ICppResolvedExpression expression);
    [ExtensionAttribute]
private static TriBool EvaluateRequiresClauseExpressionDeep(CppExpressionEvaluator evaluator, ICppResolvedExpression expression);
    [ExtensionAttribute]
public static Nullable`1<int> EvaluateToInt(ICppResolvedExpression expr, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
public static Nullable`1<ulong> EvaluateToSizeT(ICppResolvedExpression expr, CppExpressionEvaluator evaluator);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppExpressionEvaluator : CppAbstractResolvedExpressionVisitor`1<ICppEvaluationResult> {
    public CppTypeContext TypeContext;
    [CompilerGeneratedAttribute]
private CppEvaluationParams <EvalParams>k__BackingField;
    [CompilerGeneratedAttribute]
private CppFunctionEvaluationContext <FunctionCtx>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppEvaluationErrorTracker <ErrorTracker>k__BackingField;
    private static int FoldDepthLimit;
    public CppEvaluationParams EvalParams { get; private set; }
    [CanBeNullAttribute]
public CppFunctionEvaluationContext FunctionCtx { get; private set; }
    [NotNullAttribute]
public ICppEvaluationErrorTracker ErrorTracker { get; }
    public ICppResolvedTypeFactory TypeFactory { get; }
    [DebuggerStepThroughAttribute]
public CppExpressionEvaluator(CppTypeContext typeContext, CppEvaluationParams evalParams, CppFunctionEvaluationContext functionCtx, ICppEvaluationErrorTracker errorTracker);
    [CompilerGeneratedAttribute]
public CppEvaluationParams get_EvalParams();
    [CompilerGeneratedAttribute]
private void set_EvalParams(CppEvaluationParams value);
    [CompilerGeneratedAttribute]
public CppFunctionEvaluationContext get_FunctionCtx();
    [CompilerGeneratedAttribute]
private void set_FunctionCtx(CppFunctionEvaluationContext value);
    [CompilerGeneratedAttribute]
public ICppEvaluationErrorTracker get_ErrorTracker();
    public ICppResolvedTypeFactory get_TypeFactory();
    public ICppEvaluationResult ReApply(ICppResolvedExpression expr);
    public virtual ICppEvaluationResult VisitExpression(ICppResolvedExpression expr);
    public virtual ICppEvaluationResult Visit(ICppEmptyExpression e);
    public virtual ICppEvaluationResult Visit(ICppResolvedLiteralExpression e);
    public virtual ICppEvaluationResult Visit(ICppResolvedUserDefinedLiteralExpression e);
    public virtual ICppEvaluationResult Visit(ICppResolvedThisExpression _);
    public virtual ICppEvaluationResult Visit(ICppParenExpression e);
    public virtual ICppEvaluationResult Visit(ICppResolvedBinaryExpression e);
    private static bool IsDeepLeftFold(ICppResolvedExpression e, CppOperatorKind op);
    private ICppEvaluationResult EvaluateLeftFold(ICppResolvedBinaryExpression e, CppOperatorKind op);
    private ICppEvaluationResult EvaluateBinaryLogicalOp(ICppResolvedBinaryExpression e, CppOperatorKind op);
    public virtual ICppEvaluationResult Visit(ICppResolvedUnaryExpression e);
    public virtual ICppEvaluationResult Visit(ICppResolvedPostfixExpression e);
    public virtual ICppEvaluationResult Visit(ICppResolvedConditionalExpression e);
    public virtual ICppEvaluationResult Visit(ICppResolvedQualifiedReferenceExpression e);
    private ICppEvaluationResult CalculateArrayRank(ICppGroupedVariableDeclaratorResolveEntity var);
    private static CppQualType GetArrayTypeAtDimension(CppQualType type, ulong dimension);
    private ICppEvaluationResult CalculateArrayExtent(ICppGroupedVariableDeclaratorResolveEntity var);
    public virtual ICppEvaluationResult Visit(ICppResolvedMemberAccessExpression e);
    public virtual ICppEvaluationResult Visit(ICppResolvedNewExpression _);
    public virtual ICppEvaluationResult Visit(ICppDeleteExpression _);
    public virtual ICppEvaluationResult Visit(ICppResolvedSubscriptExpression expr);
    private ICppEvaluationResult EvalBuiltinSubscript(ICppResolvedExpression leftArg, ICppResolvedExpression indexArg, ICppFunctionDeclaratorResolveEntity builtin);
    private ICppEvaluationResult EvalOverloadedSubscript(ICppResolvedExpression leftArg, CppSmallArray`1<ICppExpression> indices, ICppResolveEntity overload);
    public virtual ICppEvaluationResult Visit(ICppResolvedCallExpression e);
    private ICppValue GetThisRef(ICppResolvedCallExpression e, ICppGroupedFunctionDeclaratorResolveEntity func, ICppEvaluationResult& fail);
    public static bool IsLambdaParenOperator(ICppGroupedFunctionDeclaratorResolveEntity func);
    private static bool IsCallOfFunctor(ICppGroupedFunctionDeclaratorResolveEntity func, ICppExpression callee);
    private static bool IsParenOperator(CppQualifiedNamePart name);
    public virtual ICppEvaluationResult Visit(ICppResolvedCastExpression e);
    private static bool IsAddressOf(ICppExpression expr);
    public virtual ICppEvaluationResult Visit(ICppResolvedSizeOfExpression e);
    public virtual ICppEvaluationResult Visit(ICppResolvedSizeOfEllipsisExpression e);
    public virtual ICppEvaluationResult Visit(ICppResolvedAlignOfExpression e);
    public virtual ICppEvaluationResult Visit(ICppResolvedTypeIdExpression _);
    private ICppEvaluationResult ToValue(TriBool b);
    public virtual ICppEvaluationResult Visit(ICppResolvedNoExceptExpression e);
    public virtual ICppEvaluationResult Visit(ICppResolvedSingleArgumentTypeTraitExpression e);
    private TriBool Calculate(CppSingleArgumentTypeTraitKind kind, CppQualType type, CppViewPos& vp);
    private static bool IsSigned(CppQualType type);
    private static bool IsUnsigned(CppQualType type);
    public virtual ICppEvaluationResult Visit(ICppResolvedDoubleArgumentTypeTraitExpression e);
    private bool ReferenceConstructsFromTemporary(CppQualType targetType, CppQualType sourceType);
    private bool ReferenceConvertsFromTemporary(CppQualType targetType, CppQualType sourceType);
    private bool ReferenceConstructsOrConvertsFromTemporary(CppQualType targetType, CppQualType sourceType, CppConversionParameters parameters);
    private CppFunctionTraits GetAssignmentTraits(ICppResolvedDoubleArgumentTypeTraitExpression e);
    public virtual ICppEvaluationResult Visit(ICppResolvedMultiArgumentTypeTraitExpression e);
    public virtual ICppEvaluationResult Visit(ICppResolvedMSUuidOfExpression e);
    public virtual ICppEvaluationResult Visit(ICppResolvedMSEventHookExpression e);
    public virtual ICppEvaluationResult Visit(ICppMSNoopExpression _);
    public virtual ICppEvaluationResult Visit(ICppMSAssumeExpression _);
    public virtual ICppEvaluationResult Visit(ICppResolvedBuiltinAddressOfExpression _);
    public virtual ICppEvaluationResult Visit(ICppResolvedBuiltinOffsetOfExpression e);
    public virtual ICppEvaluationResult Visit(ICppResolvedGnuBuiltinConstantPExpression e);
    public virtual ICppEvaluationResult Visit(ICppResolvedGNUAddressOfLabelExpression e);
    public virtual ICppEvaluationResult Visit(ICppThrowExpression _);
    public virtual ICppEvaluationResult Visit(ICppResolvedBracedInitListExpression expr);
    public virtual ICppEvaluationResult Visit(ICppResolvedBraceInitializedTemporaryExpression e);
    public virtual ICppEvaluationResult Visit(ICppResolvedCliMultiArgumentSubscriptExpression _);
    public virtual ICppEvaluationResult Visit(ICppReplacedLambdaExpression lambda);
    public virtual ICppEvaluationResult Visit(ICppReplacedGnuStatementExpression expr);
    public virtual ICppEvaluationResult Visit(ICppRequiresExpression _);
    public virtual ICppEvaluationResult Visit(ICppReplacedRequiresExpression expr);
    public virtual ICppEvaluationResult Visit(ICppResolvedC11GenericExpression e);
    public virtual ICppEvaluationResult Visit(ICppLinkageRequiresExpression _);
    public virtual ICppEvaluationResult Visit(ICppResolvedPackExpansionExpression expr);
    public virtual ICppEvaluationResult Visit(ICppResolvedCliTypeIdExpression _);
    public virtual ICppEvaluationResult Visit(ICppResolvedFoldExpression _);
    public virtual ICppEvaluationResult Visit(ICppResolvedCoAwaitExpression expr);
    public virtual ICppEvaluationResult Visit(ICppResolvedCoYieldExpression expr);
    public virtual ICppEvaluationResult Visit(ICppResolvedDesignation expr);
    private CppTypeAndCategory TypeOf(ICppResolvedExpression expr);
    public CppEvaluationFail Fail(CppEvaluationFailureKind kind);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppExpressionEvaluatorUtil : object {
    [ExtensionAttribute]
public static CppExpressionEvaluator CreateEvaluator(CppTypeContext& tc, CppEvaluationParams evalParams, CppFunctionEvaluationContext functionCtx, ICppEvaluationErrorTracker errorTracker);
    [ExtensionAttribute]
public static CppExpressionEvaluator CreateEvaluator(ICppExpressionNode node, CppEvaluationParams evalParams, CppFunctionEvaluationContext functionCtx, ICppEvaluationErrorTracker errorTracker);
    [ExtensionAttribute]
public static ChangeFunctionContextGuard ChangeFunctionContext(CppExpressionEvaluator evaluator, CppFunctionEvaluationContext functionCtx);
    [ExtensionAttribute]
private static ChangeEvaluationParamsGuard ChangeEvalParams(CppExpressionEvaluator evaluator, CppEvaluationParams evalParams);
    [ExtensionAttribute]
public static ChangeEvaluationParamsGuard ChangeEvaluationContext(CppExpressionEvaluator evaluator, ICppFunctionDeclaratorResolveEntity func);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICppEvaluationErrorTracker GetErrorTrackerOrDefault(CppExpressionEvaluator evaluator);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppExpressionInfo : ValueType {
    public ICppResolvedExpression Expression;
    public CppTypeAndCategory TypeAndCategory;
    public CppQualType Type { get; public set; }
    public CppValueCategory Category { get; }
    public CppExpressionInfo(ICppResolvedExpression expression, CppTypeAndCategory typeAndCategory);
    public CppQualType get_Type();
    public void set_Type(CppQualType value);
    public CppValueCategory get_Category();
    public static CppExpressionInfo FromPsiNode(ICppExpressionNode node);
    public static CppExpressionInfo FromExpression(ICppResolvedExpression expr, ICppResolvedTypeFactory tf);
    public static CppExpressionInfo CreateTemporary(CppTypeAndCategory typeAndCategory);
    public bool IsValid();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppExpressionsUtil : object {
    [ExtensionAttribute]
public static bool IsPackExpansion(ICppExpression expr);
    [ExtensionAttribute]
public static ICppExpression DropPackExpansion(ICppExpression expr);
    [ExtensionAttribute]
public static ICppExpression GetExpressionThroughParens(ICppExpression expr);
    [ExtensionAttribute]
public static ICppResolvedExpression GetExpressionThroughParens(ICppResolvedExpression expr);
    public static ICppResolvedExpression GetNewInitializer(ICppResolvedNewExpression e);
    public static ICppResolvedExpression GetNewInitializer(ICppArgumentList newArgList);
    public static bool IsFunctionalCastTypeNode(ICppResolveEntity ent, ICppResolvedTypeFactory tf);
    public static bool IsEmpty(ICppExpression expr);
    public static bool IsStringLiteral(ICppExpression expr);
    public static bool IsStringLiteralExpr(ICppExpression expr);
    public static bool ShouldBeRvalueInReturn(ICppExpression expr);
    [CanBeNullAttribute]
public static CppUnknownEntityInfo GetUnknownInfo(ICppExpression expr);
    [ExtensionAttribute]
public static ICppResolveEntity GetResolveEntityIfResolvedOk(ICppAnyResolvedReferenceExpression expr);
    public static FrugalLocalList`1<ICppResolveEntity> GetAddressOfFuncSourceExpressionCandidates(ICppResolvedQualifiedReferenceExpression qualRef, ICppTemplateArgument[]& explicitArgs);
    public static ICppResolvedQualifiedReferenceExpression GetCandidateReferenceForOverloadedFunctions(ICppExpression expr, Boolean& addPointer);
    [ExtensionAttribute]
public static bool IsOverloadedFunctions(ICppExpression expr);
    public static bool IsCxxCliPropertyAccess(ICppExpression expr);
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertTypeClass(ICppExpression input, CppTypeClasses typec);
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertTypeClass(ICppArgumentList input, CppTypeClasses typec);
    [ExtensionAttribute]
public static int GetExpressionHashCode(ICppExpression e);
    [ExtensionAttribute]
public static int ArgListHashCode(ICppArgumentList argList);
    [ExtensionAttribute]
public static bool HasSubstitutionFailure(ICppResolvedExpression e);
    [ExtensionAttribute]
public static CppTypeAndCategory GetTypeAndCategory(ICppResolvedExpression expr, ICppResolvedTypeFactory tf);
    public static CppTypeAndCategory GetTypeAndCategoryWithoutCache(ICppExpression expr, ICppRootFileResolveEntitiesCache resolveCache, ICppResolvedTypeFactory tf);
    private static void CheckExpressionType(CppQualType type, ICppExpression expr);
    [ExtensionAttribute]
public static bool ContainsLambda(ICppResolvedExpression expr);
    [ExtensionAttribute]
public static void UpdateLazyMergingInfo(ICppArgumentList input, ICppLazyMergingDataConsumer resultConsumer);
    [ExtensionAttribute]
public static void UpdateLazyMergingInfo(ICppExpression input, ICppLazyMergingDataConsumer resultConsumer);
    [ExtensionAttribute]
public static bool CanBePresented(ICppExpression expr);
    public static ICppValueExpression GetValueIfValueExpression(ICppExpression e);
    [ExtensionAttribute]
public static ICppResolvedExpression AddSubstitutionFailure(ICppResolvedExpression substitutionResult);
    public static bool BinaryRequiresOverloading(ICppResolvedExpression leftOp, ICppResolvedExpression rightOp, CppOperatorKind kind, ICppResolvedTypeFactory tf);
    private static bool UnaryRequiresOverloading(ICppResolvedExpression operand, ICppResolvedTypeFactory tf);
    public static bool UnaryRequiresOverloading(ICppResolvedExpression arg, CppOperatorKind kind, CppTypeContext& tc);
    public static bool CheckQualifiedReferenceForMemberType(ICppResolvedQualifiedReferenceExpression ref, CppQualType& memberT, CppTypeContext& tc);
    private static ICppDeclaratorResolveEntity GetDeclaratorIfMember(ICppResolvedQualifiedReferenceExpression ref, CppTypeContext& tc);
    [ExtensionAttribute]
public static ICppDeclaratorResolveEntity GetDeclaratorIfFunctionSpecialization(ICppResolvedQualifiedReferenceExpression expr, FrugalLocalList`1<ICppResolveEntity> candidates, CppTypeContext& tc);
    public static ICppDeclaratorResolveEntity GetDeclaratorIfFunctionSpecialization(CppQualifiedName nameHint, FrugalLocalList`1<ICppResolveEntity> candidates, CppTypeContext& tc);
    public static bool PostfixRequiresOverloading(ICppResolvedExpression arg, ICppResolvedTypeFactory tf);
    public static bool SubscriptRequiresOverloading(ICppResolvedExpression left, CppSmallArray`1<ICppExpression> indices, ICppResolvedTypeFactory tf);
    public static ICppResolvedExpression TryEvaluateArraySize(ICppResolvedExpression sizeExpr, CppTypeContext& tc, bool cliArrayRank);
    public static ICppResolvedExpression TryEvaluateVectorSize(ICppResolvedExpression sizeExpr, CppTypeContext& tc);
    public static bool IsNullPointerConstant(CppExpressionInfo info, CppTypeContext& tc);
    public static CppDependentInfo GetArgumentListDependentInfo(ICppArgumentList argList);
    public static ICppResolveEntity GetResolveEntityIfResolvedOk(ICppResolvedQualifiedReferenceExpression expr);
    public static ICppResolveEntity GetResolveEntityIfResolvedOk(ICppResolvedMemberAccessExpression expr);
    public static bool IsFunctionalCastTypeNode(ICppTypeIdOrExpression typeNode, ICppResolvedTypeFactory tf);
    public static CppCallExpressionKind GetCallExpressionKind(ICppCallExpression expr, ICppResolvedTypeFactory tf);
    public static CppQualType GetTypeForTypeId(ICppTypeId typeId, ICppResolvedTypeFactory tf);
    public static CppQualType GetTypeForNewTypeId(ICppNewExpression newExpr, ICppResolvedTypeFactory tf);
    public static CppQualType GetTypeForCastTypeId(ICppResolvedCastExpression castExpr, ICppResolvedTypeFactory tf);
    public static CppQualType GetTypeForTypeIdOrExpression(ICppTypeIdOrExpression expr, ICppResolvedTypeFactory tf);
    public static CppQualType GetTypeForTypeNode(ICppCallExpression call, CppTypeContext& tc);
    public static CppQualType GetTypeForTypeNode(ICppResolvedBraceInitializedTemporaryExpression expr, CppTypeContext& tc);
    public static CppQualType GetTypeForTypeNode(ICppTypeIdOrExpression expr, ICppArgumentList list, CppTypeContext& tc);
    public static CppQualType GetTypeForTypeNode(ICppTypeIdOrExpression expr, ICppExpression[] list, CppTypeContext& tc);
    private static CppQualType GetTypeForTypeNodeImpl(ICppTypeIdOrExpression typeNode, TArgumentList argList, CppTypeContext& tc);
    private static CppQualType DecorateTypeAfterQualifierReferenceResolve(CppQualType undecorated, ICppResolvedQualifiedReferenceExpression qualRef, ICppResolveEntity resolvedPrimaryEntity, CppTypeContext& tc, bool hasCTAD);
    [CanBeNullAttribute]
private static ICppResolvedExpression TryEvaluateArraySizeFromArguments(CppQualType arrayType, TArgumentList argList, CppTypeContext& tc, CppLanguageDialect dialect);
    public static CppQualType GetLookupScopeType(ICppResolvedMemberAccessExpression expr, ICppResolvedTypeFactory tf);
    public static CppQualType GetLookupScopeTypeNonFixed(ICppResolvedMemberAccessExpression expr, ICppResolvedTypeFactory tf);
    public static CppQualType GetLookupScopeTypeForDot(ICppResolvedExpression qualifierExpression, ICppResolvedTypeFactory tf);
    public static CppQualType GetLookupScopeTypeForDotNonFixed(ICppResolvedExpression qualifierExpression, ICppResolvedTypeFactory tf);
    public static CppQualType GetLookupScopeTypeForArrow(ICppResolvedExpression qualifierExpression, CppResolveResult& arrowResolveResult, ICppResolvedTypeFactory tf);
    public static CppQualType GetLookupScopeTypeForArrowNonFixed(CppResolveResult& arrowResolveResult);
    public static CppTypeAndCategory GetLookupScopeTypeAndCategory(ICppResolvedMemberAccessExpression expr, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static bool IsPointerToMemberWhenUnaryArgument(ICppResolvedQualifiedReferenceExpression ref, CppTypeContext& tc);
    public static bool AreEqual(ICppExpression lhs, ICppExpression rhs);
    public static bool AreEqual(ICppTypeIdOrExpression lhs, ICppTypeIdOrExpression rhs);
    public static bool AreEqual(ICppTypeId lhs, ICppTypeId rhs);
    public static int HashCode(ICppExpression e);
    public static bool ArgListsAreEqual(ICppArgumentList lhs, ICppArgumentList rhs);
    [CanBeNullAttribute]
public static ICppResolvedExpression GetInitSource(ICppArgumentList argList);
    [CanBeNullAttribute]
private static ICppResolvedExpression GetInitSourceFromArguments(ICppExpression[] arguments);
    public static bool IsInitializationNotOverloading(ICppCallExpression call, CppTypeContext& tc);
    [CanBeNullAttribute]
private static ICppResolvedExpression GetInitSourceFromCallExpression(ICppCallExpression call);
    public static bool TryTraverseImplicitConversion(ICppTypeIdOrExpression callee, ICppExpression[] arguments, ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams, CppTypeContext& tc);
    public static bool IsInitializationNotOverloading(ICppNewExpression expr, CppTypeContext& tc);
    public static void BuildConversionOfExpression(ICppNewExpression expr, ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams, CppTypeContext& tc);
    public static void BuildConversionOfNewOperator(ICppNewExpression expr, ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams, ICppFileResolveEntitiesCache resolveCache, CppTypeContext& tc);
    public static CppCastConversion BuildCastConversion(ICppResolvedCastExpression cast);
    public static CppCastConversion BuildCastConversion(ICppResolvedExpression fromExpr, CppQualType targetT, CppCastType castType, CppTypeContext& tc);
    public static TriBool CallOnThis(ICppResolvedOperatorCallExpression callOpExpr);
    public static TriBool CallOnThisOrItsMembers(ICppResolvedOperatorCallExpression callOpExpr);
    public static TriBool CallOnThisOrItsEmbeddedMembers(ICppResolvedOperatorCallExpression callOpExpr);
    private static TriBool CallOnThisInternal(ICppResolvedOperatorCallExpression callOpExpr, MembersChaining c);
    public static TriBool AccessOnThis(ICppExpression expr, CppViewPos& viewPos);
    public static TriBool AccessOnThisOrItsMembers(ICppExpression expr, CppViewPos& viewPos);
    public static TriBool AccessOnThisOrItsEmbeddedMembers(ICppExpression expr, CppViewPos& viewPos);
    private static TriBool CheckWhetherReferencesThis(ICppExpression expr, CppViewPos& viewPos, MembersChaining c);
    private static TriBool CheckWhetherReferencesThis(CppResolveResult& rr, CppViewPos& viewPos);
    [ExtensionAttribute]
public static ICppResolvedExpression ResolveExpression(ICppExpression expr, CppTypeContext& tc, ICppFileResolveEntitiesCache cache);
    [ExtensionAttribute]
public static ICppResolvedExpression ResolveExpression(ICppExpression expr, ICppCompositeNode context);
    [ExtensionAttribute]
public static ICppArgumentList ResolveArgumentList(ICppArgumentList argList, CppTypeContext& tc, ICppFileResolveEntitiesCache cache);
    public static IEnumerable`1<ICppResolveEntity> GetNestedEntities(ICppExpression expr);
    public static ICppExpression[] GetAdjustedOperatorNewArguments(ICppNewExpression expr, CppGlobalNamespaceResolveEntity globalNamespace);
    public static ICppExpression[] GetBracedInitListArguments(ICppExpression expr);
    public static TriBool EvaluateNoexceptSpecArg(ICppResolvedExpression arg);
    [ExtensionAttribute]
public static ICppExpression TransformResolvedToLinkageExpression(ICppExpression expr, CppCreateLinkageEntityContext ctx);
    [ExtensionAttribute]
public static CppQualType GetBuiltinOperatorType(BinaryExpression expr, CppTypeContext& tc);
    [ExtensionAttribute]
public static CppQualType GetBuiltinOperatorType(UnaryExpression expr, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType GetBuiltinOperatorType(PostfixExpression expr, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType GetBuiltinOperatorType(SubscriptExpression expr, ICppResolvedTypeFactory tf);
    public static CppQualType BuiltinSubscriptType(CppTypeAndCategory leftT, CppTypeAndCategory rightT, ICppResolvedTypeFactory typeFactory);
    public static bool IsCliEventSubscription(CppOperatorKind kind, ICppExpression leftArg, ICppCxxCliPropertyDeclaratorResolveEntity& prop);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppResolvedExpression UnwrapTemporaryExpression(ICppResolvedExpression expr);
    [CompilerGeneratedAttribute]
internal static ICppExpression <CheckWhetherReferencesThis>g__TryDropDeref|93_0(ICppExpression expr);
    [CompilerGeneratedAttribute]
internal static bool <CheckWhetherReferencesThis>g__IsThisObjectOrEmbeddedMember|93_1(ICppExpression expr);
    [CompilerGeneratedAttribute]
internal static bool <CheckWhetherReferencesThis>g__GoingThroughDerefChain|93_2(ICppResolvedMemberAccessExpression memAcc);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppExpressionValue : ValueType {
    [NotNullAttribute]
public ICppValue Value;
    [NotNullAttribute]
public ICppResolvedExpression Expression;
    public CppExpressionValue(ICppValue value, ICppResolvedExpression expression);
    public CppExpressionValue(ICppValueExpression value);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppExpressionValues : ValueType {
    [NotNullAttribute]
public ICppValue[] Values;
    [NotNullAttribute]
public ICppExpression[] Expressions;
    public static CppExpressionValues Empty;
    public int Length { get; }
    public CppExpressionValue Item { get; }
    public CppExpressionValues(ICppValue[] values, ICppExpression[] expressions);
    public CppExpressionValues(CppExpressionValue expr);
    private static CppExpressionValues();
    public int get_Length();
    public CppExpressionValue get_Item(int i);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CppExpressionValues left, CppExpressionValues right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CppExpressionValues left, CppExpressionValues right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CppExpressionValues other);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppExpressionValueUtil : object {
    [ExtensionAttribute]
public static CppExpressionValue ToExprValue(ICppValue value, ICppResolvedExpression expr);
    [ExtensionAttribute]
public static CppExpressionValue ToExprValue(ICppValueExpression value);
    [ExtensionAttribute]
public static Nullable`1<CppExpressionValues> Evaluate(ICppExpression[] expressions, CppExpressionEvaluator evaluator, ICppEvaluationResult& evalFail);
    [ExtensionAttribute]
public static CppTypeAndCategory GetTypeAndCategory(CppExpressionValue value, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType GetCppType(CppExpressionValue value, ICppResolvedTypeFactory tf);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppExpressionVisitorRecursionBreaker`1 : ValueType {
    private static int DepthLimit;
    private CppCountingDictionary`2<ICppExpression, TResult> myComputationCache;
    private int myCurrentDepth;
    public TResult ReApply(ICppExpression input, ICppExpressionVisitor`1<TResult> visitor);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppFloatingValueBase`1 : CppValueBase`1<T> {
    public CppFloatingValueRepresentation Representation { get; }
    public CppFloatingValueKind FloatingKind { get; }
    protected CppFloatingValueBase`1(T value);
    public sealed virtual Result Accept(ICppValueVisitor`1<Result> visitor);
    public abstract virtual CppFloatingValueRepresentation get_Representation();
    public abstract virtual CppFloatingValueKind get_FloatingKind();
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Cpp.Expressions.CppFloatingValueKind : Enum {
    public int value__;
    public static CppFloatingValueKind HALF;
    public static CppFloatingValueKind FLOAT;
    public static CppFloatingValueKind DOUBLE;
    public static CppFloatingValueKind LONG_DOUBLE;
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppFloatingValueRepresentation : ValueType {
    public double Value;
    public CppFloatingValueRepresentation WithValue(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CppFloatingValueRepresentation left, CppFloatingValueRepresentation right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CppFloatingValueRepresentation left, CppFloatingValueRepresentation right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CppFloatingValueRepresentation other);
}
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppFloatingValues : object {
    public static ICppFloatingValue Create(CppFloatingValueKind kind, CppFloatingValueRepresentation repr);
    public static ICppFloatingValue Create(CppFloatingValueKind kind, double value);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppFoldExpression : CppExpressionBase {
    private ICppExpression myLeftArgument;
    private CppOperatorKind myOperatorKind;
    private ICppExpression myRightArgument;
    [DebuggerStepThroughAttribute]
public CppFoldExpression(ICppExpression leftArgument, ICppExpression rightArgument, CppOperatorKind operatorKind);
    [DebuggerStepThroughAttribute]
public virtual ICppExpression GetLeftArgument();
    [DebuggerStepThroughAttribute]
public virtual ICppExpression GetRightArgument();
    [DebuggerStepThroughAttribute]
public virtual CppOperatorKind GetOperatorKind();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
internal class JetBrains.ReSharper.Psi.Cpp.Expressions.CppFuncEvaluationResult : ValueType {
    [CanBeNullAttribute]
public ICppEvaluationResult EvalResult;
    public CppExitStatus Status;
    private CppFuncEvaluationResult(ICppEvaluationResult evalResult, CppExitStatus status);
    public static CppFuncEvaluationResult Create(ICppEvaluationResult evalResult);
    public static CppFuncEvaluationResult CreateLastExpression(ICppEvaluationResult evalResult);
    public static CppFuncEvaluationResult Fail(CppExpressionEvaluator evaluator);
    public static CppFuncEvaluationResult TooManyIterations(CppExpressionEvaluator evaluator);
    public static CppFuncEvaluationResult UnresolvedExpression(CppExpressionEvaluator evaluator, ICppResolvedExpression expr);
    public static CppFuncEvaluationResult NoReturn();
    public static CppFuncEvaluationResult Break();
    public static CppFuncEvaluationResult Continue();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppFunctionEvaluationContext : object {
    private static int STEP_COUNT_LIMIT;
    private Dictionary`2<ICppGroupedVariableDeclaratorResolveEntity, ICppEvaluationResult> myValues;
    [CanBeNullAttribute]
private ICppFunctionBodyResolveEntity myFunctionBody;
    [CanBeNullAttribute]
private CppReferenceValue myThisObject;
    [CanBeNullAttribute]
private CppFunctionEvaluationContext myParent;
    private int myStepCounter;
    [CanBeNullAttribute]
public ICppFunctionDeclaratorResolveEntity Function { get; }
    public CppFunctionEvaluationContext(ICppFunctionBodyResolveEntity functionBody, CppReferenceValue thisObject, CppFunctionEvaluationContext parent);
    [CanBeNullAttribute]
public ICppEvaluationResult GetValue(ICppGroupedVariableDeclaratorResolveEntity var, CppExpressionEvaluator evaluator);
    public void Add(ICppGroupedVariableDeclaratorResolveEntity var, ICppEvaluationResult value);
    public void AddOrUpdate(ICppGroupedVariableDeclaratorResolveEntity var, ICppValue value);
    public bool Update(ICppGroupedVariableDeclaratorResolveEntity var, ICppValue newValue);
    public CppReferenceValue GetThisObject();
    public bool IncrementAndCheckStepCounter();
    private ICppEvaluationResult EvaluateAndCache(ICppGroupedVariableDeclaratorResolveEntity var, CppDeclaratorInitializer initializer, CppExpressionEvaluator evaluator);
    [CanBeNullAttribute]
private static ICppEvaluationResult GetValue(CppFunctionEvaluationContext functionCtx, CppExpressionEvaluator evaluator, ICppGroupedVariableDeclaratorResolveEntity var);
    [CanBeNullAttribute]
private ICppResolveEntity FunctionScope();
    public ICppFunctionDeclaratorResolveEntity get_Function();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppFunctionEvaluationUtil : object {
    private static int MAX_BUILTIN_EVALUATION_STEPS;
    private static Dictionary`2<CppQualifiedId, BuiltinFunc> ourBuiltinNameToKind;
    private static CppFunctionEvaluationUtil();
    [ExtensionAttribute]
[CanBeNullAttribute]
private static CppPointerToArrayElement ConvertToPointerToArray(CppExpressionValue this, CppExpressionEvaluator evaluator, CppEvaluationFail& error);
    private static bool IsNonConstexprAnError(ICppGroupedFunctionDeclaratorResolveEntity func, CppLanguageDialect dialect);
    [ExtensionAttribute]
public static ICppEvaluationResult EvaluateFunction(ICppGroupedFunctionDeclaratorResolveEntity func, ICppExpression[] args, CppExpressionEvaluator evaluator, ICppValue thisObject);
    [ExtensionAttribute]
public static ICppEvaluationResult EvaluateFunction(ICppGroupedFunctionDeclaratorResolveEntity func, CppExpressionValues args, CppExpressionEvaluator evaluator, ICppValue thisObject);
    [ExtensionAttribute]
public static ICppEvaluationResult EvaluateConstructor(ICppGroupedFunctionDeclaratorResolveEntity func, CppExpressionValues args, ICppClassResolveEntity clazz, CppExpressionEvaluator evaluator, bool zeroPreInitializeIfValueInitialization);
    [CanBeNullAttribute]
private static CppEvaluationFail CollectMemberInitializers(ICppScopeResolveEntity body, IDictionary`2<ICppResolveEntity, CppCtorInitializerStatementResolveEntityBase> initializers, CppExpressionEvaluator evaluator);
    private static CppReferenceValue GetThisRef(ICppValue thisObject);
    private static bool GetActualImplementationIfVirtual(ICppGroupedFunctionDeclaratorResolveEntity& func, CppExpressionEvaluator evaluator, ICppValue thisObject);
    private static ICppEvaluationResult EvaluateBuiltin(ICppGroupedFunctionDeclaratorResolveEntity function, BuiltinFunc builtinKind, CppExpressionValues argValues, CppExpressionEvaluator evaluator);
    private static ICppEvaluationResult EvaluateFloatingComparison(CppExpressionValues argValues, CppExpressionEvaluator evaluator, Func`3<double, double, bool> compareFn);
    private static double SignalingNan();
    private static float SignalingNanf();
    public static ICppEvaluationResult EvaluateStatementExpr(ICppReplacedGnuStatementExpression expr, CppExpressionEvaluator evaluator);
    [CanBeNullAttribute]
private static CppEvaluationFail EvaluateAndAddToContext(CppGroupedVariableDeclaratorResolveEntity var, CppExpressionEvaluator evaluator);
    private static CppList`1<ICppResolveEntity> CollectStatements(ICppScopeStatementResolveEntity scope);
    [CanBeNullAttribute]
internal static CppEvaluationFail ProcessDeclarations(ICppScopeResolveEntity scope, CppExpressionEvaluator evaluator);
    [CanBeNullAttribute]
internal static CppEvaluationFail EvaluateCondition(ICppResolvedExpression condition, CppExpressionEvaluator evaluator, Boolean& result);
    internal static CppFuncEvaluationResult EvaluateScopeStatements(ICppScopeStatementResolveEntity scope, CppExpressionEvaluator evaluator, bool returnLast, CppQualType retType);
    private static CppFuncEvaluationResult EvaluateStatement(ICppResolveEntity stmt, CppExpressionEvaluator evaluator, ICppResolveEntity lastStmt, CppQualType retType);
    private static CppFuncEvaluationResult EvaluateRetStatement(ICppReturnStatementResolveEntity ret, CppExpressionEvaluator evaluator, CppQualType retType);
    private static CppFuncEvaluationResult EvaluateIfStatement(ICppIfStatementResolveEntity ifStmt, CppExpressionEvaluator evaluator, CppQualType retType);
    private static CppFuncEvaluationResult EvaluateExprStatement(CppExpressionStatementResolveEntityBase exprStmt, CppExpressionEvaluator evaluator, ICppResolveEntity lastStmt);
    private static CppFuncEvaluationResult EvaluateGotoStatement(CppGotoStatementResolveEntityBase gotoStmt, CppExpressionEvaluator evaluator);
    private static bool EvalDefaultParamValues(ICppParameterListResolveEntity parameterList, CppList`1<ICppVariableDeclaratorResolveEntity> params, CppQualType[] paramTypes, int argsCount, ICppGroupedFunctionDeclaratorResolveEntity func, CppFunctionEvaluationContext newFunctionCtx, CppExpressionEvaluator currentEvaluator, ICppEvaluationResult& evalFail);
    private static bool EvaluateArguments(ICppParameterListResolveEntity parameterList, CppList`1<ICppVariableDeclaratorResolveEntity> params, CppQualType[] paramTypes, CppExpressionValues args, bool explicitThis, ICppValue thisValue, ICppGroupedFunctionDeclaratorResolveEntity func, CppFunctionEvaluationContext newFunctionCtx, CppExpressionEvaluator currentEvaluator, ICppEvaluationResult& evalFail);
    private static Nullable`1<int> EvaluateStrlen(CppPointerToArrayElement pointerToArrayElement, CppExpressionEvaluator evaluator);
    private static Nullable`1<ByteRepresentation> ConvertToByteArray(CppExpressionValue value, CppExpressionEvaluator evaluator, CppEvaluationFail& error);
    private static Nullable`1<ulong> ConvertToSizeT(CppExpressionValue value, CppExpressionEvaluator evaluator, CppEvaluationFail& error);
    private static int CompareThreeWay(byte left, byte right);
    private static ICppEvaluationResult EvaluateMemCmp(CppExpressionValue left, CppExpressionValue right, CppExpressionValue len, CppExpressionEvaluator evaluator);
    [NotNullAttribute]
private static ICppEvaluationResult EvaluateCharMemChr(CppPointerToArrayElement pointer, CppExpressionValue ch, int length, CppExpressionEvaluator evaluator, bool findFromEnd);
    private static ICppEvaluationResult EvaluateFirstFoundSet(CppExpressionValues argValues, ICppGroupedFunctionDeclaratorResolveEntity function, CppExpressionEvaluator evaluator);
    private static ICppEvaluationResult EvaluateCountZeroBits(CppExpressionValues argValues, ICppGroupedFunctionDeclaratorResolveEntity function, CppExpressionEvaluator evaluator, ZeroBitCountDirection direction);
    private static int LeadingZeroCount(ulong x, CppUnsignedValueKind valueKind);
    private static int TrailingZeroCount(ulong x, CppUnsignedValueKind valueKind);
    [CanBeNullAttribute]
private static string GetTypeName(CppQualType type);
    [CanBeNullAttribute]
private static string GetEnumeratorName(ICppValue value);
    private static BuiltinFunc BuiltinFuncKind(ICppGroupedFunctionDeclaratorResolveEntity func);
    [ExtensionAttribute]
public static CppFunctionEvaluationContext CreateNested(CppFunctionEvaluationContext functionCtx, ICppFunctionBodyResolveEntity functionBody, CppReferenceValue thisObject);
    [CompilerGeneratedAttribute]
internal static ICppEvaluationResult <EvaluateConstructor>g__EvaluateMemberInitializer|5_0(ICppGroupedVariableDeclaratorResolveEntity member, CppExpressionEvaluator evaluator, bool zeroPreInitializeIfValueInitialization);
    [CompilerGeneratedAttribute]
internal static bool <EvaluateConstructor>g__IsUnionMember|5_1(ICppResolveEntity entity);
    [CompilerGeneratedAttribute]
internal static ICppGroupedFunctionDeclaratorResolveEntity <EvaluateConstructor>g__TryGetInheritedCtorBase|5_2(ICppGroupedFunctionDeclaratorResolveEntity func);
    [CompilerGeneratedAttribute]
internal static CppQualType <EvaluateBuiltin>g__GetFirstTypeArgument|9_6(ICppGroupedFunctionDeclaratorResolveEntity function, int expectedTemplargsCount);
    [CompilerGeneratedAttribute]
internal static Nullable`1<CppList`1<ICppVariableDeclaratorResolveEntity>> <EvalDefaultParamValues>g__FindParamsWithDefaults|25_0(<>c__DisplayClass25_0& );
    [CompilerGeneratedAttribute]
internal static bool <EvaluateArguments>g__IsRefToItself|26_0(CppQualType paramType, ICppEvaluationResult value, ICppGroupedVariableDeclaratorResolveEntity parameter);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppFunctionOverloadSetValue : CppValueBase {
    [NotNullAttribute]
public ICppResolvedExpression Expression;
    public CppFunctionOverloadSetValue(ICppResolvedExpression expression);
    public virtual Result Accept(ICppValueVisitor`1<Result> visitor);
    public virtual CppTypeContext TryGetTypeContext();
    public virtual bool ContainsEvaluationFail(CppEvaluationParams params);
    public string Present(ICppPresenter presenter);
    public virtual string ToString();
    private bool Equals(CppFunctionOverloadSetValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppGetDecltypeUtil : object {
    [ExtensionAttribute]
public static CppQualType GetDecltype(ICppResolvedExpression expr, CppDecltypeKind kind, ICppResolvedTypeFactory tf, bool returnUnknownTypeIfExpressionIsUnknownDependent);
    [ExtensionAttribute]
public static CppQualType GetDecltype(ICppResolvedExpression expr, CppDecltypeKind kind, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType GetDecltypeOfNonDependentExpression(ICppResolvedExpression expr, CppDecltypeKind kind, ICppResolvedTypeFactory tf);
    private static ICppDeclaratorResolveEntity GetDeclaratorOfMemberAccessOrQualifiedReference(ICppExpression e);
    [CompilerGeneratedAttribute]
internal static CppQualType <GetDecltypeOfNonDependentExpression>g__GetTypeofType|2_0(<>c__DisplayClass2_0& );
}
internal class JetBrains.ReSharper.Psi.Cpp.Expressions.CppGetExpressionTypeVisitor : CppAbstractResolvedExpressionVisitor`1<CppTypeAndCategory> {
    private ICppRootFileResolveEntitiesCache myResolveCache;
    private ICppResolvedTypeFactory myTypeFactory;
    [DebuggerStepThroughAttribute]
public CppGetExpressionTypeVisitor(ICppRootFileResolveEntitiesCache resolveCache, ICppResolvedTypeFactory tf);
    public virtual CppTypeAndCategory VisitExpression(ICppResolvedExpression expr);
    public virtual CppTypeAndCategory Visit(ICppEmptyExpression expr);
    public virtual CppTypeAndCategory Visit(ICppResolvedTypeIdExpression expr);
    public virtual CppTypeAndCategory Visit(ICppResolvedBinaryExpression expr);
    public virtual CppTypeAndCategory Visit(ICppResolvedUnaryExpression expr);
    private bool IsDereferencingTMapIterator(ICppResolvedUnaryExpression expr, ICppTemplateArgument[]& mapTemplateArguments);
    public virtual CppTypeAndCategory Visit(ICppResolvedPostfixExpression expr);
    public virtual CppTypeAndCategory Visit(ICppResolvedSubscriptExpression expr);
    private TriBool EvaluateGnuChooseExprCondition(ICppResolvedExpression condition, CppViewPos viewPos);
    private CppTypeAndCategory VisitGnuChooseExpr(ICppResolvedConditionalExpression expr, CppViewPos viewPos);
    public virtual CppTypeAndCategory Visit(ICppResolvedConditionalExpression expr);
    public virtual CppTypeAndCategory Visit(ICppResolvedQualifiedReferenceExpression expr);
    public virtual CppTypeAndCategory Visit(ICppResolvedMemberAccessExpression expr);
    public virtual CppTypeAndCategory Visit(ICppResolvedCallExpression expr);
    private static ICppResolveEntity GetCalledFunction(ICppResolvedCallExpression call);
    public virtual CppTypeAndCategory Visit(ICppResolvedThisExpression e);
    public virtual CppTypeAndCategory Visit(ICppResolvedAlignOfExpression e);
    public virtual CppTypeAndCategory Visit(ICppMSUuidOfExpression _);
    public virtual CppTypeAndCategory Visit(ICppResolvedMSUuidOfExpression e);
    public virtual CppTypeAndCategory Visit(ICppMSEventHookExpression _);
    public virtual CppTypeAndCategory Visit(ICppResolvedMSEventHookExpression _);
    public virtual CppTypeAndCategory Visit(ICppCastExpression e);
    public virtual CppTypeAndCategory Visit(ICppResolvedCastExpression e);
    public virtual CppTypeAndCategory Visit(ICppDeleteExpression e);
    public virtual CppTypeAndCategory Visit(ICppLambdaExpression e);
    public virtual CppTypeAndCategory Visit(ICppGnuStatementExpression e);
    public virtual CppTypeAndCategory Visit(ICppReplacedLambdaExpression e);
    public virtual CppTypeAndCategory Visit(ICppReplacedGnuStatementExpression e);
    public virtual CppTypeAndCategory Visit(ICppRequiresExpression e);
    public virtual CppTypeAndCategory Visit(ICppReplacedRequiresExpression e);
    public virtual CppTypeAndCategory Visit(ICppLinkageRequiresExpression e);
    public virtual CppTypeAndCategory Visit(ICppResolvedCliMultiArgumentSubscriptExpression expr);
    public virtual CppTypeAndCategory Visit(ICppResolvedCliTypeIdExpression expr);
    public virtual CppTypeAndCategory Visit(ICppMSAssumeExpression e);
    public virtual CppTypeAndCategory Visit(ICppResolvedBuiltinAddressOfExpression e);
    public virtual CppTypeAndCategory Visit(ICppResolvedBuiltinOffsetOfExpression e);
    public virtual CppTypeAndCategory Visit(ICppResolvedGnuBuiltinConstantPExpression e);
    public virtual CppTypeAndCategory Visit(ICppResolvedGNUAddressOfLabelExpression e);
    public virtual CppTypeAndCategory Visit(ICppMSNoopExpression e);
    public virtual CppTypeAndCategory Visit(ICppResolvedSingleArgumentTypeTraitExpression e);
    public virtual CppTypeAndCategory Visit(ICppResolvedDoubleArgumentTypeTraitExpression e);
    public virtual CppTypeAndCategory Visit(ICppResolvedMultiArgumentTypeTraitExpression e);
    public virtual CppTypeAndCategory Visit(ICppResolvedNewExpression e);
    public virtual CppTypeAndCategory Visit(ICppResolvedNoExceptExpression e);
    public virtual CppTypeAndCategory Visit(ICppParenExpression e);
    public virtual CppTypeAndCategory Visit(ICppResolvedSizeOfExpression e);
    public virtual CppTypeAndCategory Visit(ICppResolvedSizeOfEllipsisExpression e);
    public virtual CppTypeAndCategory Visit(ICppThrowExpression e);
    public virtual CppTypeAndCategory Visit(ICppResolvedBracedInitListExpression _);
    public virtual CppTypeAndCategory Visit(ICppResolvedDesignation d);
    public virtual CppTypeAndCategory Visit(ICppResolvedBraceInitializedTemporaryExpression e);
    public virtual CppTypeAndCategory Visit(ICppResolvedLiteralExpression e);
    public virtual CppTypeAndCategory Visit(ICppResolvedUserDefinedLiteralExpression expr);
    public virtual CppTypeAndCategory Visit(ICppResolvedPackExpansionExpression e);
    public virtual CppTypeAndCategory Visit(ICppResolvedFoldExpression _);
    public virtual CppTypeAndCategory Visit(ICppResolvedCoAwaitExpression expr);
    public virtual CppTypeAndCategory Visit(ICppResolvedCoYieldExpression expr);
    public virtual CppTypeAndCategory Visit(ICppResolvedC11GenericExpression expr);
    private CppTypeAndCategory GetReturnTypeOfResolvedFunction(CppResolveResult& rr, ICppResolvedOperatorCallExpression context);
    private CppTypeAndCategory GetReturnTypeOfAwaitResume(CppResolveResult& rr);
    private CppTypeAndCategory GetTypeForQualifiedReference(ICppResolvedExpression expr, ICppDeclaratorResolveEntity decl, CppQualType entType, CppTypeAndCategory thisType);
    private CppTypeAndCategory GetTypeForMemberAccess(ICppResolvedExpression expr, CppResolveResult pp, CppTypeAndCategory thisType, CppViewPos& viewPos);
    private CppTypeAndCategory GetMemberAccessTypeAndCategory(ICppResolvedExpression expr, ICppDeclaratorResolveEntity ent, CppTypeAndCategory objType);
    private CppTypeAndCategory GetMemberAccessTypeAndCategory(CppTypeAndCategory inner, CppTypeAndCategory obj);
    private CppQualType SizeT();
    public CppTypeAndCategory TypeOf(ICppResolvedExpression expr);
    private CppTypeAndCategory GetCachedValue(ICppExpression expr, ICppExpressionNode node, Key`1<Ref`1<CppTypeAndCategory>> key);
    private static void AddScopeSuggestionsFrom(CppQualType& type, CppQualType typeForScopes, ICppResolvedTypeFactory tf);
    private void AddScopeSuggestionsFrom(CppQualType& type, ICppResolvedExpression exprForScopes);
    private CppTypeAndCategory AddScopeSuggestionsFrom(CppTypeAndCategory tc, ICppResolvedExpression exprForScopes);
    private static bool ShouldBeLValue(ICppDeclaratorResolveEntity ent, CppQualType entType);
    private static bool ShouldBeXValue(ICppDeclaratorResolveEntity ent, CppQualType entType);
    private static bool ArePointerConversionCandidates(CppExpressionInfo second, CppExpressionInfo third, CppTypeContext& tc);
    private static CppTypeAndCategory DoConditionalOverloadResolution(CppViewPos& viewPos, ICppResolvedTypeFactory typeFactory, CppTypeAndCategory secondArgT, CppTypeAndCategory thirdArgT, Boolean& overloadingSucceeded);
    private static bool IsLocalToLambda(ICppDeclaratorResolveEntity decl, CppLambdaClassResolveEntity lambda);
    private static bool IsCapturedByReference(ICppDeclaratorResolveEntity decl, CppLambdaSymbol lambda);
}
internal class JetBrains.ReSharper.Psi.Cpp.Expressions.CppGetLvalTypeVisitor : object {
    private CppTypeContext myTypeContext;
    public CppGetLvalTypeVisitor(CppTypeContext& tc);
    public sealed virtual CppQualType Visit(CppDeclaratorLvalue val);
    public sealed virtual CppQualType Visit(CppThisObjectLv val);
    public sealed virtual CppQualType Visit(CppObjectMemberLv val);
    public sealed virtual CppQualType Visit(CppDerefObjectLv val);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppGnuAddressOfLabelExpression : CppExpressionBase {
    private string myLabelName;
    public CppGnuAddressOfLabelExpression(string labelName);
    public sealed virtual string GetLabelName();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> v);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppGnuBuiltinConstantPExpression : CppExpressionBase {
    protected ICppExpression myArgument;
    public CppGnuBuiltinConstantPExpression(ICppExpression argument);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppExpression GetArgument();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppGnuStatementExpression : CppExpressionBase {
    private CppCompoundStatementInExpressionSymbol mySymbol;
    public CppGnuStatementExpression(CppCompoundStatementInExpressionSymbol sym);
    public sealed virtual CppCompoundStatementInExpressionSymbol GetStatementSymbol();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppHashCodeExpressionVisitor : object {
    public static CppHashCodeExpressionVisitor Instance;
    private static CppHashCodeExpressionVisitor();
    public virtual int Visit(ICppMemberAccessDesignator d);
    public virtual int Visit(ICppSubscriptDesignator d);
    public virtual int Visit(ICppEmptyExpression expr);
    public virtual int Visit(ICppResolvedLiteralExpression expr);
    public virtual int Visit(ICppUserDefinedLiteralExpression expr);
    public virtual int Visit(ICppResolvedUserDefinedLiteralExpression expr);
    public virtual int Visit(ICppThisExpression expr);
    public virtual int Visit(ICppResolvedThisExpression expr);
    public virtual int Visit(ICppParenExpression expr);
    public virtual int Visit(ICppBinaryExpression expr);
    public virtual int Visit(ICppResolvedBinaryExpression expr);
    public virtual int Visit(ICppUnaryExpression expr);
    public virtual int Visit(ICppResolvedUnaryExpression expr);
    public virtual int Visit(ICppPostfixExpression expr);
    public virtual int Visit(ICppResolvedPostfixExpression expr);
    public virtual int Visit(ICppConditionalExpression expr);
    public virtual int Visit(ICppResolvedConditionalExpression expr);
    public virtual int Visit(ICppQualifiedReferenceExpression expr);
    public virtual int Visit(ICppResolvedQualifiedReferenceExpression expr);
    public virtual int Visit(ICppLinkageQualifiedReferenceExpression expr);
    public virtual int Visit(ICppMemberAccessExpression expr);
    public virtual int Visit(ICppResolvedMemberAccessExpression expr);
    public virtual int Visit(ICppNewExpression expr);
    public virtual int Visit(ICppResolvedNewExpression expr);
    public virtual int Visit(ICppDeleteExpression expr);
    public virtual int Visit(ICppSubscriptExpression expr);
    public virtual int Visit(ICppResolvedSubscriptExpression expr);
    public virtual int Visit(ICppCallExpression expr);
    public virtual int Visit(ICppResolvedCallExpression expr);
    public virtual int Visit(ICppCastExpression expr);
    public virtual int Visit(ICppResolvedCastExpression expr);
    public virtual int Visit(ICppSizeOfExpression expr);
    public virtual int Visit(ICppSizeOfEllipsisExpression expr);
    public virtual int Visit(ICppResolvedSizeOfExpression expr);
    public virtual int Visit(ICppResolvedSizeOfEllipsisExpression expr);
    public virtual int Visit(ICppAlignOfExpression expr);
    public virtual int Visit(ICppResolvedAlignOfExpression expr);
    public virtual int Visit(ICppTypeIdExpression expr);
    public virtual int Visit(ICppResolvedTypeIdExpression expr);
    public virtual int Visit(ICppNoExceptExpression expr);
    public virtual int Visit(ICppResolvedNoExceptExpression expr);
    public virtual int Visit(ICppSingleArgumentTypeTraitExpression expr);
    public virtual int Visit(ICppResolvedSingleArgumentTypeTraitExpression expr);
    public virtual int Visit(ICppDoubleArgumentTypeTraitExpression expr);
    public virtual int Visit(ICppResolvedDoubleArgumentTypeTraitExpression expr);
    public virtual int Visit(ICppMultiArgumentTypeTraitExpression expr);
    public virtual int Visit(ICppResolvedMultiArgumentTypeTraitExpression expr);
    public virtual int Visit(ICppMSUuidOfExpression expr);
    public virtual int Visit(ICppResolvedMSUuidOfExpression expr);
    public virtual int Visit(ICppMSEventHookExpression expr);
    public virtual int Visit(ICppResolvedMSEventHookExpression expr);
    public virtual int Visit(ICppMSNoopExpression expr);
    public virtual int Visit(ICppMSAssumeExpression expr);
    public virtual int Visit(ICppBuiltinAddressOfExpression expr);
    public virtual int Visit(ICppResolvedBuiltinAddressOfExpression expr);
    public virtual int Visit(ICppBuiltinOffsetOfExpression expr);
    public virtual int Visit(ICppResolvedBuiltinOffsetOfExpression expr);
    public virtual int Visit(ICppGnuBuiltinConstantPExpression expr);
    public virtual int Visit(ICppResolvedGnuBuiltinConstantPExpression expr);
    public virtual int Visit(ICppGNUAddressOfLabelExpression expr);
    public virtual int Visit(ICppResolvedGNUAddressOfLabelExpression expr);
    public virtual int Visit(ICppThrowExpression expr);
    public virtual int Visit(ICppBracedInitListExpression expr);
    public virtual int Visit(ICppResolvedBracedInitListExpression expr);
    public virtual int Visit(ICppBraceInitializedTemporaryExpression expr);
    public virtual int Visit(ICppResolvedBraceInitializedTemporaryExpression expr);
    public virtual int Visit(ICppLambdaExpression expr);
    public virtual int Visit(ICppReplacedLambdaExpression expr);
    public sealed virtual int Visit(ICppGnuStatementExpression expr);
    public sealed virtual int Visit(ICppReplacedGnuStatementExpression expr);
    public virtual int Visit(ICppRequiresExpression expr);
    public virtual int Visit(ICppReplacedRequiresExpression expr);
    public virtual int Visit(ICppLinkageRequiresExpression expr);
    public virtual int Visit(ICppCliMultiArgumentSubscriptExpression expr);
    public virtual int Visit(ICppResolvedCliMultiArgumentSubscriptExpression expr);
    public virtual int Visit(ICppCliTypeIdExpression expr);
    public virtual int Visit(ICppResolvedCliTypeIdExpression expr);
    public virtual int Visit(ICppPackExpansionExpression expr);
    public virtual int Visit(ICppResolvedPackExpansionExpression expr);
    public virtual int Visit(ICppFoldExpression expr);
    public virtual int Visit(ICppResolvedFoldExpression expr);
    public virtual int Visit(ICppCoAwaitExpression expr);
    public virtual int Visit(ICppResolvedCoAwaitExpression expr);
    public virtual int Visit(ICppCoYieldExpression expr);
    public virtual int Visit(ICppResolvedCoYieldExpression expr);
    public virtual int Visit(ICppDesignation d);
    public virtual int Visit(ICppResolvedDesignation d);
    public virtual int Visit(ICppC11GenericExpression expr);
    public virtual int Visit(ICppResolvedC11GenericExpression expr);
    public virtual int Visit(ICppRequiresExpressionItemTypename item);
    public virtual int Visit(ICppRequiresExpressionItemSimple item);
    public virtual int Visit(ICppRequiresExpressionItemNested item);
    public virtual int Visit(ICppRequiresExpressionItemCompound item);
    public int ReApply(ICppArgumentList lhs);
    private int ReApplyF(ICppExpression expr);
    private int ReApplyToTypeF(CppQualType type);
    private int ReApplyToRequiresItemF(ICppRequiresExpressionItem item);
    private int ReApply(ICppExpression expr);
    private int ReApply(ICppTypeIdOrExpression lhs);
    private int ReApply(ICppTemplateParameterPack pack);
    private int ReApply(CppLookupResult lhs);
    private int ReApply(ICppExpression[] args);
    private int ReApply(CppSmallArray`1<ICppExpression> args);
    private int ReApply(IEnumerable`1<ICppRequiresExpressionItem> items);
    private int ReApply(CppNewExpressionResolveResult resolveResult);
    protected virtual int ReApply(CppResolveResult& modreq(System.Runtime.InteropServices.InAttribute) lhs);
    protected virtual int ReApply(CppQualType type);
    protected virtual int ReApply(CppQualifiedName name);
    protected virtual int ReApply(ICppValue val);
}
internal class JetBrains.ReSharper.Psi.Cpp.Expressions.CppHashCodeLvalVisitor : object {
    public sealed virtual int Visit(CppDeclaratorLvalue val);
    public sealed virtual int Visit(CppThisObjectLv val);
    public sealed virtual int Visit(CppObjectMemberLv val);
    public sealed virtual int Visit(CppDerefObjectLv val);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppHexFloatUtil : object {
    public static Nullable`1<HexFloat> TryParseHexFloat(string str);
    public static double HexFloatToDouble(HexFloat number);
    public static bool TryParseFloat(string str, Single& value);
    public static bool TryParseDouble(string str, Double& value);
    private static int HexToDigit(char ch);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppIdentityExpressionVisitor : CppAbstractForwardingExpressionVisitor`1<ICppExpression> {
    private CppExpressionVisitorRecursionBreaker`1<ICppExpression> myRecursionBreaker;
    public virtual ICppDesignator Visit(ICppMemberAccessDesignator d);
    public virtual ICppDesignator Visit(ICppSubscriptDesignator d);
    public virtual ICppExpression VisitExpression(ICppExpression expr);
    public virtual ICppExpression Visit(ICppEmptyExpression e);
    public virtual ICppExpression Visit(ICppResolvedLiteralExpression e);
    public virtual ICppExpression Visit(ICppUserDefinedLiteralExpression e);
    public virtual ICppExpression Visit(ICppThisExpression e);
    public virtual ICppExpression Visit(ICppParenExpression e);
    public virtual ICppExpression Visit(ICppBinaryExpression e);
    public virtual ICppExpression Visit(ICppUnaryExpression e);
    public virtual ICppExpression Visit(ICppPostfixExpression e);
    public virtual ICppExpression Visit(ICppConditionalExpression e);
    public virtual ICppExpression Visit(ICppQualifiedReferenceExpression e);
    public virtual ICppExpression Visit(ICppResolvedQualifiedReferenceExpression e);
    public virtual ICppExpression Visit(ICppLinkageQualifiedReferenceExpression e);
    public virtual ICppExpression Visit(ICppMemberAccessExpression e);
    public virtual ICppExpression Visit(ICppNewExpression e);
    public virtual ICppExpression Visit(ICppDeleteExpression e);
    public virtual ICppExpression Visit(ICppSubscriptExpression e);
    public virtual ICppExpression Visit(ICppCallExpression e);
    public virtual ICppExpression Visit(ICppCastExpression e);
    public virtual ICppExpression Visit(ICppSizeOfExpression e);
    public virtual ICppExpression Visit(ICppSizeOfEllipsisExpression e);
    public virtual ICppExpression Visit(ICppAlignOfExpression e);
    public virtual ICppExpression Visit(ICppTypeIdExpression e);
    public virtual ICppExpression Visit(ICppNoExceptExpression e);
    public virtual ICppExpression Visit(ICppSingleArgumentTypeTraitExpression e);
    public virtual ICppExpression Visit(ICppDoubleArgumentTypeTraitExpression e);
    public virtual ICppExpression Visit(ICppMultiArgumentTypeTraitExpression e);
    public virtual ICppExpression Visit(ICppMSUuidOfExpression e);
    public virtual ICppExpression Visit(ICppMSEventHookExpression e);
    public virtual ICppExpression Visit(ICppMSNoopExpression e);
    public virtual ICppExpression Visit(ICppMSAssumeExpression e);
    public virtual ICppExpression Visit(ICppBuiltinAddressOfExpression e);
    public virtual ICppExpression Visit(ICppBuiltinOffsetOfExpression e);
    public virtual ICppExpression Visit(ICppGnuBuiltinConstantPExpression e);
    public virtual ICppExpression Visit(ICppGNUAddressOfLabelExpression e);
    public virtual ICppExpression Visit(ICppThrowExpression e);
    public virtual ICppExpression Visit(ICppBracedInitListExpression e);
    private CppBracedInitListExpression VisitBracedInitList(ICppBracedInitListExpression e);
    public virtual ICppExpression Visit(ICppBraceInitializedTemporaryExpression e);
    public virtual ICppExpression Visit(ICppLambdaExpression e);
    public virtual ICppExpression Visit(ICppReplacedLambdaExpression e);
    public virtual ICppExpression Visit(ICppGnuStatementExpression e);
    public virtual ICppExpression Visit(ICppReplacedGnuStatementExpression e);
    public virtual ICppExpression Visit(ICppRequiresExpression e);
    public virtual ICppExpression Visit(ICppReplacedRequiresExpression e);
    public virtual ICppExpression Visit(ICppLinkageRequiresExpression e);
    public virtual ICppExpression Visit(ICppCliMultiArgumentSubscriptExpression e);
    public virtual ICppExpression Visit(ICppCliTypeIdExpression e);
    public virtual ICppExpression Visit(ICppPackExpansionExpression e);
    public virtual ICppExpression Visit(ICppFoldExpression e);
    public virtual ICppExpression Visit(ICppCoAwaitExpression e);
    public virtual ICppExpression Visit(ICppCoYieldExpression e);
    public virtual ICppExpression Visit(ICppDesignation e);
    public virtual ICppExpression Visit(ICppC11GenericExpression e);
    public virtual CppQualifiedName ReApply(CppQualifiedName name);
    public virtual ICppArgumentList ReApply(ICppArgumentList argList);
    public virtual ICppTypeIdOrExpression ReApply(ICppTypeIdOrExpression tidexp);
    public virtual CppQualType ReApply(CppQualType type);
    private ICppExpression ReApply(ICppExpression e);
    protected ICppExpression[] ReApply(ICppExpression[] args);
    protected CppSmallArray`1<ICppExpression> ReApply(CppSmallArray`1<ICppExpression> args);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppInitializerEvaluationUtil : object {
    [CanBeNullAttribute]
public static ICppEvaluationResult EvaluateExpressionInInitializer(ICppResolvedExpression expr, CppQualType targetType, CppConversionParameters convParams, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
public static ICppEvaluationResult Evaluate(CppDeclaratorInitializer initializer, CppQualType qualType, CppExpressionEvaluator evaluator, bool zeroInitializeIfNoInitializer);
    [ExtensionAttribute]
public static ICppEvaluationResult EvaluateCtorInitializer(CppCtorInitializerStatementResolveEntityBase ctorInitializer, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
public static ICppEvaluationResult EvaluateEnumeratorInitializer(ICppEnumeratorResolveEntity enumerator, CppViewPos& vp, ICppEvaluationErrorTracker errorTracker);
    [NotNullAttribute]
private static ICppIntegralValue Increment(ICppIntegralValue value);
    [NotNullAttribute]
private static ICppIntegralValue Increment(ICppSignedIntegralValue value);
    [NotNullAttribute]
private static ICppIntegralValue Increment(ICppUnsignedIntegralValue value);
    [NotNullAttribute]
private static ICppIntegralValue Increment(CppBoolValue value);
}
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppIntegralValues : object {
    public static ICppUnsignedIntegralValue Create(CppUnsignedValueKind kind, CppUnsignedValueRepresentation repr);
    public static ICppUnsignedIntegralValue Create(CppUnsignedValueKind kind, ulong value);
    public static ICppSignedIntegralValue Create(CppSignedValueKind kind, CppSignedValueRepresentation repr);
    public static ICppSignedIntegralValue Create(CppSignedValueKind kind, long value);
    public static long GetMaxSignedValue(byte bitSize);
    public static long GetMinSignedValue(byte bitSize);
    public static ulong GetMaxUnsignedValue(byte bitSize);
    public static ulong GetMinUnsignedValue(byte _);
}
public enum JetBrains.ReSharper.Psi.Cpp.Expressions.CppIsConstantEvaluatedAssumedValue : Enum {
    public int value__;
    public static CppIsConstantEvaluatedAssumedValue ASSUME_TRUE;
    public static CppIsConstantEvaluatedAssumedValue ASSUME_FALSE;
    public static CppIsConstantEvaluatedAssumedValue ASSUME_NEITHER;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppIsNoexceptUtil : object {
    private static TriBool IsNoexceptCallImpl(ICppResolvedOperatorCallExpression call, ICppExpression[] args);
    [ExtensionAttribute]
public static TriBool IsNoexceptCall(ICppResolvedCallExpression e);
    [ExtensionAttribute]
public static TriBool IsNoexceptCall(ICppResolvedBraceInitializedTemporaryExpression e);
    [ExtensionAttribute]
public static TriBool IsNoexcept(ICppExceptionSpecification exceptionSpecification, CppTypeContext& tc);
    [ExtensionAttribute]
public static TriBool EvaluateNoexceptSpecArg(ICppResolvedExpression arg);
    public static TriBool EvaluateNoexceptSpecArg(ICppResolvedExpression arg, CppTypeContext& tc);
    [ExtensionAttribute]
public static TriBool IsCalledFunctionNoexcept(CppResolveResult& resolvedOp, CppViewPos& viewPos);
    [ExtensionAttribute]
public static TriBool IsNoexcept(ICppGroupedFunctionDeclaratorResolveEntity func, CppViewPos& viewPos);
    public static TriBool IsCalledFunctionNoexcept(ICppResolvedOperatorCallExpression expr);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppLambdaCaptureDescription : object {
    [CompilerGeneratedAttribute]
private CppLambdaCaptureStyle <CaptureStyle>k__BackingField;
    public CppLambdaCaptureDescriptionKind Kind { get; }
    public CppLambdaCaptureStyle CaptureStyle { get; }
    protected CppLambdaCaptureDescription(CppLambdaCaptureStyle captureStyle);
    public abstract virtual CppLambdaCaptureDescriptionKind get_Kind();
    [CompilerGeneratedAttribute]
public CppLambdaCaptureStyle get_CaptureStyle();
}
public enum JetBrains.ReSharper.Psi.Cpp.Expressions.CppLambdaCaptureDescriptionKind : Enum {
    public int value__;
    public static CppLambdaCaptureDescriptionKind CaptureAll;
    public static CppLambdaCaptureDescriptionKind CaptureVar;
    public static CppLambdaCaptureDescriptionKind CaptureWithInitializer;
    public static CppLambdaCaptureDescriptionKind CaptureThis;
    public static CppLambdaCaptureDescriptionKind CaptureThisByValue;
}
public enum JetBrains.ReSharper.Psi.Cpp.Expressions.CppLambdaCaptureStyle : Enum {
    public int value__;
    public static CppLambdaCaptureStyle ByRef;
    public static CppLambdaCaptureStyle ByVal;
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppLambdaExpression : CppExpressionBase {
    private CppLambdaSymbol mySymbol;
    public CppLambdaExpression(CppLambdaSymbol sym);
    public sealed virtual CppLambdaSymbol GetLambdaSymbol();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppLambdaInitCaptureDescription : CppLambdaCaptureDescription {
    [CompilerGeneratedAttribute]
private ICppVariableDeclaratorResolveEntity <Declarator>k__BackingField;
    public ICppVariableDeclaratorResolveEntity Declarator { get; }
    public CppLambdaCaptureDescriptionKind Kind { get; }
    public CppLambdaInitCaptureDescription(CppLambdaCaptureStyle captureStyle, ICppVariableDeclaratorResolveEntity resolveEntity);
    [CompilerGeneratedAttribute]
public ICppVariableDeclaratorResolveEntity get_Declarator();
    public virtual CppLambdaCaptureDescriptionKind get_Kind();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppLinkageExpressionHashCodeUtil : object {
    [ExtensionAttribute]
public static int GetLinkageExpressionHashCode(ICppExpression expr, CppCreateLinkageEntityContext ctx);
    [ExtensionAttribute]
public static int GetLinkageExpressionHashCode(ICppExpression expr, CppCreateLinkageEntityContext ctx, Boolean& error);
}
internal class JetBrains.ReSharper.Psi.Cpp.Expressions.CppLinkageHashCodeExpressionVisitor : CppHashCodeExpressionVisitor {
    private CppCreateLinkageEntityContext myContext;
    private bool myError;
    public bool Error { get; }
    public CppLinkageHashCodeExpressionVisitor(CppCreateLinkageEntityContext typeIntern);
    public bool get_Error();
    protected virtual int ReApply(CppResolveResult& modreq(System.Runtime.InteropServices.InAttribute) lhs);
    protected virtual int ReApply(CppQualType type);
    protected virtual int ReApply(CppQualifiedName name);
    protected virtual int ReApply(ICppValue val);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppLinkageObjectValue : object {
    private ICppAnyLinkageEntityOrTemplateParameter myClass;
    private Dictionary`2<ICppAnyLinkageEntityOrTemplateParameter, ICppExpression> myFields;
    private CppDependentInfo myDepInfo;
    public CppLinkageObjectValue(ICppAnyLinkageEntityOrTemplateParameter clent, Dictionary`2<ICppAnyLinkageEntityOrTemplateParameter, ICppExpression> fields, CppDependentInfo deps);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual ICppLiteralValue GetValue();
    public sealed virtual Result Accept(ICppValueVisitor`1<Result> visitor);
    public sealed virtual CppTypeContext TryGetTypeContext();
    public sealed virtual bool ContainsEvaluationFail(CppEvaluationParams evalParams);
    public sealed virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public ICppAnyLinkageEntityOrTemplateParameter GetClass();
    public Dictionary`2<ICppAnyLinkageEntityOrTemplateParameter, ICppExpression> GetFields();
    public virtual int GetHashCode();
    public virtual bool Equals(object rhs);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppLinkageQualifiedReferenceExpression : CppExpressionBase {
    private CppQualifiedName myName;
    private Status myStatus;
    private IEnumerable`1<ICppAnyLinkageEntityOrTemplateParameter> myEntities;
    public CppLinkageQualifiedReferenceExpression(CppQualifiedName name, Status status, IEnumerable`1<ICppAnyLinkageEntityOrTemplateParameter> entities);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppQualifiedName GetQualifiedName();
    public sealed virtual Status GetResolveStatus();
    public sealed virtual IEnumerable`1<ICppAnyLinkageEntityOrTemplateParameter> GetLinkageEntities();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppLinkageRequiresExpression : CppExpressionBase {
    private CppList`1<ICppRequiresExpressionItem> myItems;
    private IEnumerable`1<ICppParameterLinkageEntity> myParameters;
    public CppLinkageRequiresExpression(IEnumerable`1<ICppParameterLinkageEntity> params, CppList`1<ICppRequiresExpressionItem> items);
    public sealed virtual IEnumerable`1<ICppParameterLinkageEntity> GetParameters();
    public sealed virtual CppList`1<ICppRequiresExpressionItem> GetItems();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppLval : object {
    public virtual bool Equals(CppLval rhs);
    [NotNullAttribute]
public static CppLval MakeLocalVariableLvalue(ICppDeclaratorResolveEntity declEnt);
    [CanBeNullAttribute]
public static CppLval MakeDeclaratorLvalue(ICppResolveEntity declEntScope, ICppDeclaratorResolveEntity declEnt, CppViewPos& thisViewPos, bool shouldComputeSubobject);
    [CanBeNullAttribute]
public static CppLval MakeMemberAccessDeclaratorLvalue(CppLval object, Nullable`1<CppSubobject> subobject, ICppDeclaratorResolveEntity member);
    private static CppLval MakeDeclaratorLvalueImpl(CppLval object, Nullable`1<CppSubobject> subobject, ICppDeclaratorResolveEntity declEnt);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public abstract virtual TResult Accept(ICppLvalVisitor`1<TResult> vis);
}
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppLvalUtil : object {
    public static CppQualType GetLvalDeclaratorType(CppLval val, CppViewPos& vp);
    public static ICppDeclaratorResolveEntity GetReferencedDeclarator(CppLval val);
    public static CppLval GetInnermostQualifier(CppLval val);
    public static CppLval GetDereferencedObject(CppDerefObjectLv lv);
    public static CppLval GetDereferencedObject(CppDerefObjectLv lv, Int32& derefsCount);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppMemberAccessDesignator : CppBaseDesignator {
    private string myName;
    public CppMemberAccessDesignator(ICppDesignator qualifier, string name);
    public virtual TResult Accept(ICppDesignatorVisitor`1<TResult> visitor);
    public sealed virtual string GetName();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppMemberAccessExpression : CppExpressionBase {
    private ICppExpression myLeftArgument;
    private CppQualifiedName myRightArgument;
    private CppMemberAccessType myAccessType;
    public CppMemberAccessExpression(ICppExpression leftArgument, CppQualifiedName rightArgument, CppMemberAccessType accessType);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppExpression GetLeftArgument();
    public sealed virtual CppQualifiedName GetRightArgument();
    public sealed virtual CppMemberAccessType GetAccessType();
}
public enum JetBrains.ReSharper.Psi.Cpp.Expressions.CppMemberAccessType : Enum {
    public int value__;
    public static CppMemberAccessType DOT;
    public static CppMemberAccessType DEREF;
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppMemberAccessTypeUtil : object {
    public static CppMemberAccessType MemberAccessTypeByToken(TokenNodeType tt);
    public static string MemberAccessTypeToString(CppMemberAccessType mat);
    public static CppMemberAccessType GetOtherAccesType(CppMemberAccessType mat);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppMSAssumeExpression : CppExpressionBase {
    private ICppExpression myArgument;
    public CppMSAssumeExpression(ICppExpression argument);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppExpression GetArgument();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppMSEventHookExpression : CppExpressionBase {
    private ICppArgumentList myArgumentList;
    private bool myUnhook;
    public CppMSEventHookExpression(bool unhook, ICppArgumentList argumentList);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual bool IsUnhook();
    public sealed virtual ICppArgumentList GetArgumentList();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppMSNoopExpression : CppExpressionBase {
    public static CppMSNoopExpression Instance;
    private static CppMSNoopExpression();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppMSUuidOfExpression : CppExpressionBase {
    private ICppTypeIdOrExpression myArgument;
    public CppMSUuidOfExpression(ICppTypeIdOrExpression argument);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppTypeIdOrExpression GetArgument();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppMultiArgumentTypeTraitExpression : CppExpressionBase {
    [CompilerGeneratedAttribute]
private CppList`1<Element> <args>P;
    [CompilerGeneratedAttribute]
private CppMultiArgumentTypeTraitKind <kind>P;
    public CppMultiArgumentTypeTraitExpression(CppList`1<Element> args, CppMultiArgumentTypeTraitKind kind);
    public sealed virtual CppList`1<Element> GetArguments();
    public sealed virtual CppMultiArgumentTypeTraitKind GetKind();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public enum JetBrains.ReSharper.Psi.Cpp.Expressions.CppMultiArgumentTypeTraitKind : Enum {
    public int value__;
    public static CppMultiArgumentTypeTraitKind IS_CONSTRUCTIBLE;
    public static CppMultiArgumentTypeTraitKind IS_TRIVIALLY_CONSTRUCTIBLE;
    public static CppMultiArgumentTypeTraitKind IS_NOTHROW_CONSTRUCTIBLE;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppMultiArgumentTypeTraitKindUtil : object {
    private static HashMap`2<TokenNodeType, CppMultiArgumentTypeTraitKind> ourTokenToKind;
    private static HashMap`2<CppMultiArgumentTypeTraitKind, TokenNodeType> ourKindToToken;
    private static CppMultiArgumentTypeTraitKindUtil();
    public static CppMultiArgumentTypeTraitKind TokenTypeToMultiArgumentTypeTraitKind(TokenNodeType tok);
    [ExtensionAttribute]
public static string GetRepresentation(CppMultiArgumentTypeTraitKind kind);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__Add|2_0(TokenNodeType token, CppMultiArgumentTypeTraitKind kind);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppNewExpression : CppExpressionBase {
    private bool myIsGCNew;
    private bool myIsFromGlobalNamespace;
    private CppQualType myQualType;
    private ICppArgumentList myOperatorArgumentList;
    private ICppArgumentList myConstructorArgumentList;
    public CppNewExpression(bool isGCNew, bool isFromGlobalNamespace, CppQualType qualType, ICppArgumentList operatorArgumentList, ICppArgumentList argumentList);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual bool IsCliGCNew();
    public sealed virtual bool IsFromGlobalNamespace();
    public sealed virtual CppQualType GetQualType();
    public sealed virtual ICppArgumentList GetOperatorArgumentList();
    public sealed virtual ICppArgumentList GetConstructorArgumentList();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppNoExceptExpression : CppExpressionBase {
    protected ICppExpression myArgument;
    public CppNoExceptExpression(ICppExpression argument);
    public sealed virtual ICppExpression GetArgument();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppNullPointer : CppPointerValue {
    private CppQualType myType;
    public CppNullPointer(CppQualType type);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string Present(ICppPresenter presenter);
    public virtual bool CastToBool();
    public virtual ICppValue Increment();
    public virtual ICppValue Decrement();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory _);
    public virtual ICppEvaluationResult Deref();
    public CppQualType GetCppType();
    public virtual TriBool EqualValues(CppPointerValue other);
    public virtual CppDependentInfo GetDependentInfo();
    public virtual CppTypeContext TryGetTypeContext();
    public virtual bool ContainsEvaluationFail(CppEvaluationParams _);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppNullptrValue : CppValueBase {
    public static CppNullptrValue Instance;
    private static CppNullptrValue();
    public virtual Result Accept(ICppValueVisitor`1<Result> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppNullValueExpression : object {
    public static CppNullValueExpression INSTANCE;
    private static CppNullValueExpression();
    public sealed virtual ICppLiteralValue GetValue();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public sealed virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppObjectMemberLv : CppLval {
    [CompilerGeneratedAttribute]
private CppLval <OwningObject>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CppSubobject> <Subobject>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppDeclaratorResolveEntity <Member>k__BackingField;
    public CppLval OwningObject { get; }
    public Nullable`1<CppSubobject> Subobject { get; }
    public ICppDeclaratorResolveEntity Member { get; }
    public CppObjectMemberLv(CppLval object, Nullable`1<CppSubobject> subobject, ICppDeclaratorResolveEntity member);
    [CompilerGeneratedAttribute]
public CppLval get_OwningObject();
    [CompilerGeneratedAttribute]
public Nullable`1<CppSubobject> get_Subobject();
    [CompilerGeneratedAttribute]
public ICppDeclaratorResolveEntity get_Member();
    public virtual TResult Accept(ICppLvalVisitor`1<TResult> vis);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppObjectValue : CppValueBase {
    [NotNullAttribute]
public ICppClassResolveEntity Class;
    [NotNullAttribute]
public Dictionary`2<ICppGroupedVariableDeclaratorResolveEntity, ICppEvaluationResult> Fields;
    public CppObjectValue(ICppClassResolveEntity clazz, Dictionary`2<ICppGroupedVariableDeclaratorResolveEntity, ICppEvaluationResult> fields);
    public virtual Result Accept(ICppValueVisitor`1<Result> visitor);
    public virtual bool ContainsEvaluationFail(CppEvaluationParams params);
    public string Present(ICppPresenter presenter);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public static bool EqualsDeep(CppObjectValue a, CppObjectValue b);
    public virtual int GetHashCode();
    public ICppEvaluationResult GetField(ICppGroupedVariableDeclaratorResolveEntity var);
    public void SetField(ICppGroupedVariableDeclaratorResolveEntity var, ICppEvaluationResult value);
    public void SetFieldsFrom(CppObjectValue rhs);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppPackExpansionExpression : CppExpressionBase {
    protected ICppExpression myPattern;
    public ICppExpression Pattern { get; }
    public CppPackExpansionExpression(ICppExpression expr);
    public sealed virtual ICppExpression get_Pattern();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppParenExpression : CppExpressionBase {
    private ICppExpression myInnerExpression;
    public CppParenExpression(ICppExpression innerExpression);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppExpression GetInnerExpression();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppPointerToArrayElement : CppPointerValue {
    public CppArrayValue Array;
    public int Index;
    public CppPointerToArrayElement(CppArrayValue array, int index);
    public virtual bool CastToBool();
    public virtual ICppValue Increment();
    public virtual ICppValue Decrement();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeFactory);
    public virtual CppTypeContext TryGetTypeContext();
    public virtual bool ContainsEvaluationFail(CppEvaluationParams evalParams);
    public virtual ICppEvaluationResult Deref();
    public virtual CppDependentInfo GetDependentInfo();
    public virtual TriBool EqualValues(CppPointerValue other);
    public virtual bool Equals(object other);
    public bool Equals(CppPointerToArrayElement that);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string Present(ICppPresenter presenter);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppPointerToDeclarator : CppPointerValue {
    private ICppGroupedDeclaratorResolveEntity myDecl;
    private CppViewPos myViewPos;
    private CppPointerToDeclarator(ICppGroupedDeclaratorResolveEntity decl, CppViewPos& viewPos);
    public static CppPointerValue Create(ICppGroupedDeclaratorResolveEntity decl, CppViewPos& viewPos, CppExpressionEvaluator evaluator);
    public static CppPointerValue Create(ICppGroupedFunctionDeclaratorResolveEntity decl, CppViewPos& viewPos);
    public static CppPointerValue CreateUnsafe(ICppGroupedDeclaratorResolveEntity decl, CppViewPos& viewPos, CppExpressionEvaluator evaluator);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string Present(ICppPresenter presenter);
    public virtual bool CastToBool();
    public virtual ICppValue Increment();
    public virtual ICppValue Decrement();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeFactory);
    public virtual CppTypeContext TryGetTypeContext();
    public virtual bool ContainsEvaluationFail(CppEvaluationParams evalParams);
    public virtual ICppEvaluationResult Deref();
    public virtual TriBool EqualValues(CppPointerValue other);
    public ICppDeclaratorResolveEntity GetDeclarator();
    public virtual CppDependentInfo GetDependentInfo();
    private static TriBool EqualsImpl(ICppDeclaratorResolveEntity a, ICppDeclaratorResolveEntity b);
    [CompilerGeneratedAttribute]
internal static bool <EqualsImpl>g__IsIndeterminateReference|20_0(ICppDeclaratorResolveEntity decl);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppPointerToReference : CppPointerValue {
    private CppReferenceValue myValue;
    public CppPointerToReference(CppReferenceValue temporary);
    public virtual bool CastToBool();
    public virtual ICppValue Increment();
    public virtual ICppValue Decrement();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory tf);
    public virtual ICppEvaluationResult Deref();
    public virtual CppDependentInfo GetDependentInfo();
    public virtual CppTypeContext TryGetTypeContext();
    public virtual bool ContainsEvaluationFail(CppEvaluationParams evalParams);
    public virtual TriBool EqualValues(CppPointerValue obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string Present(ICppPresenter presenter);
    public CppReferenceValue GetPointee();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppPointerToTemplateParameterObject : CppPointerValue {
    private CppObjectValue myValue;
    public CppPointerToTemplateParameterObject(CppObjectValue temporary);
    public virtual bool CastToBool();
    public virtual ICppValue Increment();
    public virtual ICppValue Decrement();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory tf);
    public virtual ICppEvaluationResult Deref();
    public virtual CppDependentInfo GetDependentInfo();
    public virtual CppTypeContext TryGetTypeContext();
    public virtual bool ContainsEvaluationFail(CppEvaluationParams evalParams);
    public CppObjectValue GetObjectValue();
    public virtual TriBool EqualValues(CppPointerValue obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string Present(ICppPresenter presenter);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppPointerValue : object {
    public sealed virtual ICppLiteralValue GetValue();
    public sealed virtual Result Accept(ICppValueVisitor`1<Result> visitor);
    public sealed virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public sealed virtual TriBool IsNoexcept();
    public abstract virtual CppDependentInfo GetDependentInfo();
    public abstract virtual CppTypeContext TryGetTypeContext();
    public abstract virtual bool ContainsEvaluationFail(CppEvaluationParams _);
    public abstract virtual string Present(ICppPresenter presenter);
    public abstract virtual bool CastToBool();
    [CanBeNullAttribute]
public abstract virtual ICppValue Increment();
    [CanBeNullAttribute]
public abstract virtual ICppValue Decrement();
    public abstract virtual CppQualType GetCppType(ICppResolvedTypeFactory _);
    public abstract virtual ICppEvaluationResult Deref();
    public abstract virtual TriBool EqualValues(CppPointerValue _);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppPostfixExpression : CppExpressionBase {
    private ICppExpression myArgument;
    private CppOperatorKind myOperatorKind;
    public CppPostfixExpression(ICppExpression argument, CppOperatorKind operatorKind);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppExpression GetArgument();
    public sealed virtual CppOperatorKind GetOperatorKind();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppPPValueUtil : object {
    [ExtensionAttribute]
public static bool IsZero(ICppPPValue value);
    [ExtensionAttribute]
public static bool IsSigned(ICppPPValue value);
    [ExtensionAttribute]
public static bool IsUnsigned(ICppPPValue value);
    [ExtensionAttribute]
public static ICppPPSignedValue ToSigned(ICppPPValue value);
    [ExtensionAttribute]
public static ICppPPUnsignedValue ToUnsigned(ICppPPValue value);
    public static ICppPPSignedValue CreateSigned(long value);
    public static ICppPPUnsignedValue CreateUnsigned(ulong value);
    [ExtensionAttribute]
private static ICppPPValue ToPPValue(ICppValue value);
    [ExtensionAttribute]
public static ICppPPValue PerformPPUnaryOperation(ICppPPValue value, CppOperatorKind kind);
    public static ICppPPValue PerformPPBinaryOperation(ICppPPValue lhs, ICppPPValue rhs, CppOperatorKind binaryKind);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppPtr : CppRefPtr {
    public CppPtr(CppLval obj);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppQualifiedReferenceExpression : CppExpressionBase {
    private CppQualifiedName myQualifiedName;
    public CppQualifiedReferenceExpression(CppQualifiedName qualifiedName);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppQualifiedName GetQualifiedName();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppRef : CppRefPtr {
    public CppRef(CppLval obj);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppReferenceToArrayElement : CppReferenceValue {
    public CppArrayValue Array;
    public int Index;
    public CppReferenceToArrayElement(CppArrayValue array, int index);
    public virtual CppDependentInfo GetDependentInfo();
    public virtual CppTypeContext TryGetTypeContext();
    public virtual bool ContainsEvaluationFail(CppEvaluationParams evalParams);
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory tf);
    public virtual ICppValue AddressOf();
    public virtual ICppEvaluationResult GetReferencedValue(CppExpressionEvaluator evaluator);
    public virtual UpdateStatus UpdateReferencedValue(CppExpressionEvaluator evaluator, ICppValue newValue);
    public virtual string Present(ICppPresenter presenter);
    public virtual bool Equals(object obj);
    private bool Equals(CppReferenceToArrayElement that);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppReferenceToDeclarator : CppReferenceValue {
    private ICppGroupedDeclaratorResolveEntity myDecl;
    private CppViewPos myViewPos;
    protected CppReferenceToDeclarator(ICppGroupedDeclaratorResolveEntity decl, CppViewPos& viewPos);
    public static CppReferenceValue Create(ICppGroupedDeclaratorResolveEntity decl, CppViewPos& viewPos, CppExpressionEvaluator evaluator);
    public static CppReferenceValue Create(ICppGroupedFunctionDeclaratorResolveEntity decl, CppViewPos& viewPos);
    public static CppReferenceToDeclarator CreateUnsafe(ICppGroupedDeclaratorResolveEntity decl, CppViewPos& viewPos, CppExpressionEvaluator evaluator);
    [CanBeNullAttribute]
internal static CppReferenceValue GetValueAsReference(ICppGroupedDeclaratorResolveEntity decl, CppExpressionEvaluator evaluator);
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory tf);
    public virtual CppDependentInfo GetDependentInfo();
    public virtual ICppEvaluationResult GetReferencedValue(CppExpressionEvaluator evaluator);
    public virtual UpdateStatus UpdateReferencedValue(CppExpressionEvaluator evaluator, ICppValue newValue);
    public virtual CppTypeContext TryGetTypeContext();
    public virtual bool ContainsEvaluationFail(CppEvaluationParams evalParams);
    public ICppGroupedDeclaratorResolveEntity GetDeclarator();
    public virtual ICppValue AddressOf();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string Present(ICppPresenter presenter);
    protected bool Equals(CppReferenceToDeclarator that);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppReferenceToField : CppReferenceToDeclarator {
    private ICppValue myObject;
    private bool myDoDeref;
    private CppReferenceToField(ICppGroupedDeclaratorResolveEntity decl, CppViewPos& vp, ICppValue object, bool deref);
    public static CppReferenceValue Create(ICppGroupedDeclaratorResolveEntity decl, CppViewPos& vp, ICppValue object, bool deref, CppExpressionEvaluator evaluator);
    public static CppReferenceToField CreateUnsafe(ICppGroupedDeclaratorResolveEntity decl, CppViewPos& vp, ICppValue object, bool deref, CppExpressionEvaluator evaluator);
    public ICppValue GetObject();
    public bool DoDeref();
    public virtual ICppValue AddressOf();
    public virtual ICppEvaluationResult GetReferencedValue(CppExpressionEvaluator evaluator);
    private static ICppEvaluationResult GetReferencedValue(ICppGroupedDeclaratorResolveEntity declarator, ICppValue object, bool doDeref, CppExpressionEvaluator evaluator);
    public virtual UpdateStatus UpdateReferencedValue(CppExpressionEvaluator evaluator, ICppValue newValue);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string Present(ICppPresenter presenter);
    public virtual bool ContainsEvaluationFail(CppEvaluationParams evalParams);
    protected bool Equals(CppReferenceToField that);
    private static ICppEvaluationResult DerefObject(ICppValue object, bool doDeref, CppExpressionEvaluator evaluator);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppReferenceToTemplateParameterObject : CppReferenceValue {
    private CppObjectValue myValue;
    public CppReferenceToTemplateParameterObject(CppObjectValue temporary);
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory tf);
    public virtual CppDependentInfo GetDependentInfo();
    public virtual CppTypeContext TryGetTypeContext();
    public virtual bool ContainsEvaluationFail(CppEvaluationParams evalParams);
    public virtual ICppEvaluationResult GetReferencedValue(CppExpressionEvaluator evaluator);
    public virtual UpdateStatus UpdateReferencedValue(CppExpressionEvaluator evaluator, ICppValue newValue);
    public virtual ICppValue AddressOf();
    public CppObjectValue GetObjectValue();
    public virtual string ToString();
    public virtual string Present(ICppPresenter presenter);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppReferenceToTemporary : CppReferenceValue {
    private ICppValue myTemporary;
    private bool myIsConst;
    public CppReferenceToTemporary(ICppValue temporary);
    public CppReferenceToTemporary(ICppValue temporary, bool isConst);
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory tf);
    public virtual CppDependentInfo GetDependentInfo();
    public virtual CppTypeContext TryGetTypeContext();
    public virtual bool ContainsEvaluationFail(CppEvaluationParams evalParams);
    public virtual ICppEvaluationResult GetReferencedValue(CppExpressionEvaluator evaluator);
    public virtual UpdateStatus UpdateReferencedValue(CppExpressionEvaluator evaluator, ICppValue newValue);
    public bool IsConst();
    public virtual string ToString();
    public virtual string Present(ICppPresenter presenter);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppReferenceValue : object {
    public virtual ICppLiteralValue GetValue();
    public sealed virtual Result Accept(ICppValueVisitor`1<Result> visitor);
    public virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public abstract virtual CppDependentInfo GetDependentInfo();
    public virtual TriBool IsNoexcept();
    public abstract virtual CppTypeContext TryGetTypeContext();
    public abstract virtual bool ContainsEvaluationFail(CppEvaluationParams params);
    public abstract virtual string Present(ICppPresenter presenter);
    public abstract virtual CppQualType GetCppType(ICppResolvedTypeFactory tf);
    public virtual CppTypeAndCategory GetTypeAndCategory(ICppResolvedTypeFactory tf);
    public virtual ICppValue AddressOf();
    [CanBeNullAttribute]
public abstract virtual ICppEvaluationResult GetReferencedValue(CppExpressionEvaluator evaluator);
    [MustUseReturnValueAttribute]
public abstract virtual UpdateStatus UpdateReferencedValue(CppExpressionEvaluator evaluator, ICppValue newValue);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppRefPtr : object {
    [CompilerGeneratedAttribute]
private CppLval <Obj>k__BackingField;
    public CppLval Obj { get; }
    protected CppRefPtr(CppLval obj);
    [CompilerGeneratedAttribute]
public CppLval get_Obj();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppRefPtrUtil : object {
    [ExtensionAttribute]
private static CppPtr TakeAddress(CppRef ref);
    [ExtensionAttribute]
private static CppRef Dereference(CppPtr ptr);
    [ExtensionAttribute]
public static CppRef DoDereference(CppRefPtr val);
    [CanBeNullAttribute]
public static CppRefPtr ComputeRefPtrForExpression(ICppExpressionNode expr, bool shouldComputeSubobjects, ICppResolvedTypeFactory tf);
    [CanBeNullAttribute]
public static CppRefPtr ComputeRefPtrForExpression(ICppExpressionNode expr, bool shouldComputeSubobjects, ICppResolvedTypeFactory tf, ICppExpressionNode& initialReferenceNode);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppReplacedGnuStatementExpression : CppExpressionBase {
    private CppCompoundStatementResolveEntity myEnt;
    private CppDependentInfo myDependentInfo;
    private CppExpressionStatementResolveEntityBase myLastStatement;
    public CppReplacedGnuStatementExpression(CppCompoundStatementResolveEntity ent);
    public sealed virtual CppCompoundStatementResolveEntity GetStatementResolveEntity();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public sealed virtual ICppResolvedExpression GetResultExpression();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppReplacedLambdaExpression : CppExpressionBase {
    private ICppClassResolveEntity myEnt;
    private CppDependentInfo myDependentInfo;
    public CppReplacedLambdaExpression(ICppClassResolveEntity ent);
    public sealed virtual ICppClassResolveEntity GetClassResolveEntity();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppReplacedRequiresExpression : CppExpressionBase {
    private CppDependentInfo myDependentInfo;
    private ICppRequiresExpressionScopeResolveEntity myEnt;
    public CppReplacedRequiresExpression(ICppRequiresExpressionScopeResolveEntity ent);
    public sealed virtual ICppRequiresExpressionScopeResolveEntity GetScopeResolveEntity();
    public sealed virtual CppList`1<ICppRequiresExpressionItem> GetResolvedItems();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public static CppDependentInfo CalculateDependentInfo(ICppRequiresExpressionScopeResolveEntity ent);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppRequiresExpression : CppExpressionBase {
    private CppRequiresExpressionSymbol mySymbol;
    public CppRequiresExpression(CppRequiresExpressionSymbol sym);
    public virtual CppRequiresExpressionSymbol GetRequiresSymbol();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppRequiresExpressionItem : object {
    public abstract virtual Result Accept(ICppRequiresExpressionItemVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppRequiresExpressionItemCompound : CppRequiresExpressionItem {
    [CompilerGeneratedAttribute]
private ICppExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppExpression <ReturnTypeConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private CppQualType <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoExcept>k__BackingField;
    public ICppExpression Expression { get; }
    public ICppExpression ReturnTypeConstraint { get; }
    public CppQualType ReturnType { get; }
    public bool NoExcept { get; }
    public CppRequiresExpressionItemCompound(ICppExpression expression, ICppExpression rettypecon, CppQualType rettype, bool noExcept);
    [CompilerGeneratedAttribute]
public sealed virtual ICppExpression get_Expression();
    [CompilerGeneratedAttribute]
public sealed virtual ICppExpression get_ReturnTypeConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual CppQualType get_ReturnType();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NoExcept();
    public virtual Result Accept(ICppRequiresExpressionItemVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppRequiresExpressionItemNested : CppRequiresExpressionItem {
    [CompilerGeneratedAttribute]
private ICppExpression <Expression>k__BackingField;
    public ICppExpression Expression { get; }
    public CppRequiresExpressionItemNested(ICppExpression expression);
    [CompilerGeneratedAttribute]
public sealed virtual ICppExpression get_Expression();
    public virtual Result Accept(ICppRequiresExpressionItemVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppRequiresExpressionItemSimple : CppRequiresExpressionItem {
    [CompilerGeneratedAttribute]
private ICppExpression <Expression>k__BackingField;
    public ICppExpression Expression { get; }
    public CppRequiresExpressionItemSimple(ICppExpression expression);
    [CompilerGeneratedAttribute]
public sealed virtual ICppExpression get_Expression();
    public virtual Result Accept(ICppRequiresExpressionItemVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppRequiresExpressionItemTypename : CppRequiresExpressionItem {
    [CompilerGeneratedAttribute]
private CppQualType <Type>k__BackingField;
    public CppQualType Type { get; }
    public CppRequiresExpressionItemTypename(CppQualType type);
    [CompilerGeneratedAttribute]
public sealed virtual CppQualType get_Type();
    public virtual Result Accept(ICppRequiresExpressionItemVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedAlignOfExpression : CppAlignOfExpression {
    private CppViewPos myViewPos;
    private CppDependentInfo myDependentInfo;
    public CppResolvedAlignOfExpression(ICppTypeIdOrExpression argument, CppViewPos& viewPos);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedBinaryExpression : CppBinaryExpression {
    private CppViewPos myViewPos;
    private CppResolveResult myResolvedOperator;
    private CppDependentInfo myDependentInfo;
    [DebuggerStepThroughAttribute]
public CppResolvedBinaryExpression(ICppResolvedExpression leftArgument, ICppResolvedExpression rightArgument, CppOperatorKind operatorKind, CppViewPos& viewPos, CppResolveResult& resolvedOperator, CppDependentInfo dependentInfo);
    [DebuggerStepThroughAttribute]
public sealed virtual CppViewPos GetViewPos();
    [DebuggerStepThroughAttribute]
public sealed virtual CppResolveResult GetResolvedOperator();
    [DebuggerStepThroughAttribute]
public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppResolvedExpression GetResolvedLeftArgument();
    public sealed virtual ICppResolvedExpression GetResolvedRightArgument();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public static TriBool IsNoexcept(ICppResolvedBinaryExpression expr);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedBracedInitListExpression : CppBracedInitListExpression {
    public static CppResolvedBracedInitListExpression Empty;
    private CppDependentInfo myDepInfo;
    public CppResolvedBracedInitListExpression(ICppExpression[] arguments, bool hasBeenShrinked, CppDependentInfo depInfo);
    private static CppResolvedBracedInitListExpression();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppTypeContext TryGetTypeContext();
    public static CppResolvedBracedInitListExpression Create(ICppExpression[] arguments, bool hasBeenShrinked);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedBraceInitializedTemporaryExpression : CppBraceInitializedTemporaryExpression {
    private CppResolveResult myResolveResult;
    private CppViewPos myViewPos;
    private CppDependentInfo myDependentInfo;
    public CppResolvedBraceInitializedTemporaryExpression(ICppTypeIdOrExpression initializerTypeNode, ICppResolvedBracedInitListExpression argumentList, CppResolveResult& rr, CppViewPos& vp, CppDependentInfo depInfo);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppResolveResult GetResolvedOperator();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual ICppResolvedBracedInitListExpression GetResolvedArgumentList();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public static CppDependentInfo CalculateDependentInfo(ICppTypeIdOrExpression typeNode, ICppResolvedBracedInitListExpression argumentList);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedBuiltinAddressOfExpression : CppBuiltinAddressOfExpression {
    public CppResolvedBuiltinAddressOfExpression(ICppResolvedExpression argument);
    public sealed virtual ICppResolvedExpression GetResolvedArgument();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedBuiltinOffsetOfExpression : CppExpressionBase {
    private CppQualType myTypeArgument;
    private CppQualifiedName myMemberDesignator;
    private CppResolveResult myResolvedMember;
    private CppDependentInfo myDependentInfo;
    public CppResolvedBuiltinOffsetOfExpression(CppQualType typeArgument, CppQualifiedName memberDesignator, CppResolveResult resolvedMember);
    public sealed virtual CppQualType GetTypeArgument();
    public sealed virtual CppQualifiedName GetMemberDesignator();
    public sealed virtual CppResolveResult GetResolvedMemberDesignator();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public static CppDependentInfo CalculateDependentInfo(ICppResolvedBuiltinOffsetOfExpression expr);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedC11GenericExpression : CppC11GenericExpression {
    private CppViewPos myViewPos;
    private CppDependentInfo myDependentInfo;
    private bool myIsResultResolved;
    private ICppResolvedExpression myResolvedResultExpression;
    public CppResolvedC11GenericExpression(ICppResolvedExpression control, CppC11GenericExpressionClause[] clauses, CppViewPos& viewPos);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> e);
    public sealed virtual ICppResolvedExpression GetResolvedControllingExpression();
    public sealed virtual ICppResolvedExpression GetResolvedResultExpression();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public sealed virtual CppViewPos GetViewPos();
    public static CppDependentInfo CalcDependentInfo(ICppResolvedC11GenericExpression expr);
    public static CppQualType GetControllingExpressionType(ICppResolvedC11GenericExpression expr);
    public static ICppResolvedExpression ResolveResult(ICppResolvedC11GenericExpression expr);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedCallExpression : CppCallExpression {
    private CppCallExpressionKind myKind;
    private CppResolveResult myResolvedOperator;
    private CppViewPos myViewPos;
    private CppDependentInfo myDependentInfo;
    public CppResolvedCallExpression(ICppTypeIdOrExpression callee, ICppExpression[] arguments, CppCallExpressionKind kind, CppResolveResult& resolvedOperator, CppViewPos& viewPos, CppDependentInfo depInfo);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> e);
    public sealed virtual CppCallExpressionKind GetExpressionKind();
    public sealed virtual CppResolveResult GetResolvedOperator();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public static CppDependentInfo CalculateDependentInfo(ICppTypeIdOrExpression invokedTypeIdOrExpression, ICppExpression[] arguments, ICppResolvedTypeFactory tf);
    private static CppDependentInfo DepInfoOfFunctionCall(ICppResolvedQualifiedReferenceExpression qualRef, ICppExpression invokedExpression, CppDependentInfo argsInfo);
    private static CppDependentInfo DepInfoOfMemberCall(ICppResolvedMemberAccessExpression memAccess, CppDependentInfo argsInfo);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedCastExpression : CppCastExpression {
    private CppResolveResult myResolvedOperator;
    private CppViewPos myViewPos;
    private CppDependentInfo myDependentInfo;
    public CppResolvedCastExpression(ICppResolvedExpression argument, CppCastType castType, CppQualType qualType, CppResolveResult& resolvedOperator, CppViewPos& viewPos, CppDependentInfo depInfo);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppResolveResult GetResolvedOperator();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual ICppResolvedExpression GetResolvedArgument();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public static CppDependentInfo CalculateDependentInfoOfCast(ICppResolvedExpression from, CppQualType to);
    public static TriBool IsNoexcept(ICppResolvedCastExpression cast);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedCliMultiArgumentSubscriptExpression : CppCliMultiArgumentSubscriptExpression {
    private CppViewPos myViewPos;
    private CppDependentInfo myDependentInfo;
    public CppResolvedCliMultiArgumentSubscriptExpression(ICppExpression leftArgument, ICppExpression[] indexArguments, CppViewPos& viewPos);
    public sealed virtual CppResolveResult GetResolvedOperator();
    public sealed virtual ICppResolvedExpression GetResolvedLeftArgument();
    public sealed virtual CppViewPos GetViewPos();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public static CppDependentInfo CalculateDependentInfo(ICppResolvedCliMultiArgumentSubscriptExpression expr);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedCliTypeIdExpression : CppCliTypeIdExpression {
    private CppLookupResult myLookupResult;
    private CppViewPos myViewPos;
    public CppResolvedCliTypeIdExpression(CppQualifiedName argument, CppViewPos& vp, CppLookupResult lookupResult);
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppLookupResult GetLookupResult();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedCoAwaitExpression : CppCoAwaitExpression {
    private CppViewPos myViewPos;
    private CppCoAwaitResolveResult myResolveResult;
    private CppDependentInfo myDependentInfo;
    public CppResolvedCoAwaitExpression(ICppResolvedExpression argument, CppCoAwaitResolveResult resolveResult, CppViewPos& viewPos);
    public sealed virtual CppCoAwaitResolveResult GetResolveResult();
    public sealed virtual ICppResolvedExpression GetResolvedArgument();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedConditionalExpression : CppConditionalExpression {
    private CppViewPos myViewPos;
    private CppDependentInfo myDependentInfo;
    public CppResolvedConditionalExpression(ICppExpression firstArgument, ICppExpression secondArgument, ICppExpression thirdArgument, CppConditionalExprKind exprKind, CppViewPos& viewPosForType);
    public sealed virtual ICppResolvedExpression GetResolvedFirstArgument();
    public sealed virtual ICppResolvedExpression GetResolvedSecondArgument();
    public sealed virtual ICppResolvedExpression GetResolvedThirdArgument();
    public sealed virtual CppViewPos GetViewPosForOverloading();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public static CppDependentInfo CalculateDependentInfo(ICppResolvedConditionalExpression e);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedCoYieldExpression : CppCoYieldExpression {
    private CppViewPos myViewPos;
    private CppCoYieldResolveResult myResolveResult;
    private CppDependentInfo myDependentInfo;
    public CppResolvedCoYieldExpression(ICppResolvedExpression argument, CppCoYieldResolveResult resolveResult, CppViewPos& viewPos);
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppCoYieldResolveResult GetResolveResult();
    public sealed virtual ICppResolvedExpression GetResolvedArgument();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedDesignation : CppDesignation {
    public CppResolvedDesignation(ICppDesignator cppDesignator, ICppResolvedExpression initializer, InitializerKind initializerKind);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public sealed virtual ICppResolvedExpression GetResolvedInitializer();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedDoubleArgumentTypeTraitExpression : CppDoubleArgumentTypeTraitExpression {
    private CppDependentInfo myDependentInfo;
    public CppResolvedDoubleArgumentTypeTraitExpression(CppQualType firstArgument, CppQualType secondArgument, CppDoubleArgumentTypeTraitKind kind);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public static CppDependentInfo CalculateDependentInfo(ICppResolvedDoubleArgumentTypeTraitExpression e);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedFoldExpression : object {
    private ICppResolvedExpression myInitArgument;
    private bool myIsLeftFold;
    private CppOperatorKind myOperatorKind;
    private ICppResolvedExpression myPackArgument;
    [CompilerGeneratedAttribute]
private CppSubstitutionContext <ExpansionClosure>k__BackingField;
    public ICppResolvedExpression Pattern { get; }
    public CppSubstitutionContext ExpansionClosure { get; }
    public CppResolvedFoldExpression(ICppResolvedExpression packArgument, ICppResolvedExpression initArgument, bool isLeftFold, CppOperatorKind operatorKind);
    public CppResolvedFoldExpression(ICppResolvedExpression packArgument, ICppResolvedExpression initArgument, bool isLeftFold, CppOperatorKind operatorKind, CppSubstitutionContext closure);
    public sealed virtual ICppResolvedExpression GetPackArgument();
    public sealed virtual ICppResolvedExpression GetInitArgument();
    public sealed virtual CppOperatorKind GetOperatorKind();
    public sealed virtual bool IsLeftFold();
    public sealed virtual ICppResolvedExpression get_Pattern();
    [CompilerGeneratedAttribute]
public sealed virtual CppSubstitutionContext get_ExpansionClosure();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public sealed virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedGNUAddressOfLabelExpression : CppExpressionBase {
    private string myLabelName;
    private CppViewPos myViewPos;
    public CppResolvedGNUAddressOfLabelExpression(string labelName, CppViewPos& viewPos);
    public sealed virtual string GetLabelName();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> v);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedGnuBuiltinConstantPExpression : CppGnuBuiltinConstantPExpression {
    public CppResolvedGnuBuiltinConstantPExpression(ICppResolvedExpression argument);
    public sealed virtual ICppResolvedExpression GetResolvedArgument();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedMemberAccessExpression : CppMemberAccessExpression {
    private CppResolveResult myArrowResolveResult;
    private CppResolveResult myMemberResolveResult;
    private CppViewPos myViewPos;
    private CppDependentInfo myDependentInfo;
    public CppResolvedMemberAccessExpression(ICppExpression leftArgument, CppQualifiedName rightArgument, CppMemberAccessType accessType, CppResolveResult& arrowResolveResult, CppResolveResult& memberResolveResult, CppViewPos& viewPos);
    public sealed virtual CppResolveResult GetLookupScopeResolveResult();
    public sealed virtual CppResolveResult GetResolvedReference();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual ICppResolvedExpression GetResolvedLeftArgument();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public ICppResolveEntity GetResolvedScope();
    public static CppDependentInfo CalculateDependentInfo(ICppResolvedMemberAccessExpression expr);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedMSEventHookExpression : CppMSEventHookExpression {
    private CppDependentInfo myDependentInfo;
    private CppViewPos myViewPos;
    public CppResolvedMSEventHookExpression(bool unhook, ICppArgumentList argumentList, CppViewPos& viewPos);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> e);
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public static CppDependentInfo CalculateDependentInfo(ICppResolvedMSEventHookExpression expr);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedMSUuidOfExpression : CppMSUuidOfExpression {
    private CppViewPos myViewPos;
    private CppDependentInfo myDependentInfo;
    public CppResolvedMSUuidOfExpression(ICppTypeIdOrExpression argument, CppViewPos& viewPos);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedMultiArgumentTypeTraitExpression : CppMultiArgumentTypeTraitExpression {
    private CppDependentInfo myDependentInfo;
    public CppResolvedMultiArgumentTypeTraitExpression(CppList`1<Element> args, CppMultiArgumentTypeTraitKind kind);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public static CppDependentInfo CalculateDependentInfo(ICppResolvedMultiArgumentTypeTraitExpression e);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedNewExpression : CppNewExpression {
    private CppNewExpressionResolveResult myResolvedOperator;
    private CppViewPos myViewPos;
    private CppDependentInfo myDependentInfo;
    public CppResolvedNewExpression(bool isGCNew, bool isFromGlobalNamespace, CppQualType qualType, ICppArgumentList operatorArgumentList, ICppArgumentList constructorArgumentList, CppNewExpressionResolveResult resolvedOperator, CppViewPos& viewPos, CppDependentInfo depInfo);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppNewExpressionResolveResult GetResolvedOperator();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public static CppDependentInfo CalculateDependentInfo(CppQualType type, ICppArgumentList operatorArgumentList, ICppArgumentList constructorArgumentList);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedNoExceptExpression : CppNoExceptExpression {
    public CppResolvedNoExceptExpression(ICppResolvedExpression argument);
    public sealed virtual ICppResolvedExpression GetResolvedArgument();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedPackExpansionExpression : CppPackExpansionExpression {
    [CompilerGeneratedAttribute]
private CppSubstitutionContext <ExpansionClosure>k__BackingField;
    public CppSubstitutionContext ExpansionClosure { get; }
    public CppResolvedPackExpansionExpression(ICppResolvedExpression pattern);
    public CppResolvedPackExpansionExpression(ICppResolvedExpression pattern, CppSubstitutionContext closure);
    [CompilerGeneratedAttribute]
public CppSubstitutionContext get_ExpansionClosure();
    public sealed virtual ICppResolvedExpression GetResolvedPattern();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedParenExpression : CppParenExpression {
    public CppResolvedParenExpression(ICppResolvedExpression inner);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    private ICppResolvedExpression GetResolvedInner();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedPostfixExpression : CppPostfixExpression {
    private CppDependentInfo myDependentInfo;
    private CppResolveResult myResolvedOperator;
    private CppViewPos myViewPos;
    public CppResolvedPostfixExpression(ICppResolvedExpression argument, CppOperatorKind operatorKind, CppViewPos& viewPos, CppResolveResult& resolvedOperator, CppDependentInfo depInfo);
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppResolveResult GetResolvedOperator();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual ICppResolvedExpression GetResolvedArgument();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedQualifiedReferenceExpression : CppExpressionBase {
    private CppQualifiedName myResolvedName;
    private CppResolveResult myResolveResult;
    private CppViewPos myViewPos;
    private CppDependentInfo myDependentInfo;
    public CppResolvedQualifiedReferenceExpression(CppQualifiedName resolvedName, CppResolveResult& resolvedReference, CppViewPos& viewPos);
    public CppResolvedQualifiedReferenceExpression(CppQualifiedName resolvedName, CppResolveResult& resolvedReference, CppViewPos& viewPos, CppDependentInfo dependentInfo);
    public sealed virtual CppResolveResult GetResolvedReference();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppQualifiedName GetResolvedNameHint();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public static CppDependentInfo CalculateDependentInfo(ICppResolvedQualifiedReferenceExpression ref);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedSingleArgumentTypeTraitExpression : CppSingleArgumentTypeTraitExpression {
    private CppDependentInfo myDependentInfo;
    public CppResolvedSingleArgumentTypeTraitExpression(CppQualType argument, CppSingleArgumentTypeTraitKind kind);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public static CppDependentInfo CalculateDependentInfo(ICppResolvedSingleArgumentTypeTraitExpression e);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedSizeOfEllipsisExpression : CppExpressionBase {
    private CppQualifiedName myUnresolvedArgument;
    private CppResolveResult myResolvedArgument;
    private CppViewPos myViewPos;
    public CppResolvedSizeOfEllipsisExpression(CppQualifiedName unresolvedArgument, CppResolveResult& resolvedArgument, CppViewPos& viewPos);
    public sealed virtual CppQualifiedName GetArgument();
    public sealed virtual CppResolveResult GetResolvedArgument();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedSizeOfExpression : CppSizeOfExpression {
    private CppViewPos myViewPos;
    private CppDependentInfo myDependentInfo;
    public CppResolvedSizeOfExpression(ICppTypeIdOrExpression argument, CppViewPos& viewPos);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    internal static CppDependentInfo CalculateDependentInfo(ICppTypeIdOrExpression argument, ICppResolvedSizeOfExpression expr);
    private static CppDependentInfo CalculateDependentInfo(CppQualType argument, ICppResolvedSizeOfExpression expr);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedStringLiteralValue : CppStringLiteralValue {
    private FrugalLocalList`1<string> myParts;
    private CppLanguageDialect myDialect;
    public FrugalLocalList`1<string> Parts { get; }
    public CppResolvedStringLiteralValue(FrugalLocalList`1<string> parts, CppLanguageDialect dialect);
    public virtual FrugalLocalList`1<string> get_Parts();
    public CppLanguageDialect GetDialect();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedSubscriptDesignator : CppSubscriptDesignator {
    public CppResolvedSubscriptDesignator(ICppDesignator qualifier, ICppResolvedExpression index);
    public sealed virtual ICppResolvedExpression GetResolvedIndex();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedSubscriptExpression : CppSubscriptExpression {
    private CppViewPos myViewPos;
    private CppResolveResult myResolvedOperator;
    private CppDependentInfo myDependentInfo;
    public CppResolvedSubscriptExpression(ICppResolvedExpression leftArgument, CppSmallArray`1<ICppExpression> indexArguments, CppViewPos& viewPos, CppResolveResult& resolvedOp, CppDependentInfo depInfo);
    public sealed virtual CppResolveResult GetResolvedOperator();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppResolvedExpression GetResolvedLeftArgument();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedThisExpression : CppThisExpression {
    private CppDependentInfo myDependentInfo;
    private CppQualType myType;
    public CppResolvedThisExpression(CppQualType thisType, CppDependentInfo depInfo);
    public CppResolvedThisExpression(CppQualType thisType);
    public sealed virtual CppQualType GetThisObjectType();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedThrowExpression : CppThrowExpression {
    public static CppResolvedThrowExpression WithoutArg;
    public CppResolvedThrowExpression(ICppResolvedExpression argument);
    private static CppResolvedThrowExpression();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
}
internal class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedToLinkageExpressionConverter : CppIdentityExpressionVisitor {
    private CppCreateLinkageEntityContext myContext;
    public CppResolvedToLinkageExpressionConverter(CppCreateLinkageEntityContext typeIntern);
    public virtual ICppExpression Visit(ICppResolvedLiteralExpression expr);
    public virtual ICppExpression Visit(ICppResolvedQualifiedReferenceExpression expr);
    public virtual ICppExpression Visit(ICppReplacedRequiresExpression expr);
    public virtual ICppExpression Visit(ICppResolvedFoldExpression fold);
    public virtual CppQualType ReApply(CppQualType type);
    public virtual CppQualifiedName ReApply(CppQualifiedName name);
    private IEnumerable`1<ICppAnyLinkageEntityOrTemplateParameter> ReApply(CppResolveResult& lhs);
    private ICppExpression ReApply(ICppValue val);
    private static ICppExpression WrapEntityReference(ICppResolveEntity entity);
    private CppLinkageObjectValue ObjectToLinkage(CppObjectValue obj);
    private ICppAnyLinkageEntityOrTemplateParameter ResolveEntityToLinkage(ICppResolveEntity entity);
    private ICppAnyLinkageEntityOrTemplateParameter LookupCachedLinkage(ICppResolveEntity entity);
    private static ICppExpression TransformResolvedToLinkageExpression(ICppExpression expr, CppCreateLinkageEntityContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedTypeIdExpression : CppTypeIdExpression {
    private CppViewPos myViewPos;
    private CppDependentInfo myDependentInfo;
    public CppResolvedTypeIdExpression(ICppTypeIdOrExpression argument, CppViewPos& vp);
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedUnaryExpression : CppUnaryExpression {
    private CppDependentInfo myDependentInfo;
    private CppResolveResult myResolvedOperator;
    private CppViewPos myViewPos;
    public CppResolvedUnaryExpression(ICppResolvedExpression argument, CppOperatorKind operatorKind, CppViewPos& viewPos, CppResolveResult& opRr, CppDependentInfo depInfo);
    [DebuggerStepThroughAttribute]
public sealed virtual CppViewPos GetViewPos();
    [DebuggerStepThroughAttribute]
public sealed virtual CppResolveResult GetResolvedOperator();
    [DebuggerStepThroughAttribute]
public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppResolvedExpression GetResolvedArgument();
    public static TriBool IsNoexcept(ICppResolvedUnaryExpression unary);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolvedUserDefinedLiteralExpression : CppUserDefinedLiteralExpression {
    private CppResolveResult myResolvedOperator;
    private CppViewPos myViewPos;
    public CppResolvedUserDefinedLiteralExpression(ICppUserDefinedLiteralValue value, string suffix, CppResolveResult& resolvedOperator, CppViewPos& viewPos);
    public sealed virtual CppResolveResult GetResolvedOperator();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppResolveExpressionVisitor : CppAbstractExpressionVisitorWithDefaults`1<ICppResolvedExpression> {
    private CppResolveEngine myResolveEngine;
    private CppExpressionVisitorRecursionBreaker`1<ICppResolvedExpression> myRecursionBreaker;
    public CppResolveEngine ResolveEngine { get; }
    [DebuggerStepThroughAttribute]
public CppResolveExpressionVisitor(CppTypeContext& tc, ICppFileResolveEntitiesCache cache);
    public virtual ICppResolvedExpression Visit(ICppAlignOfExpression e);
    public virtual ICppResolvedExpression Visit(ICppBinaryExpression e);
    public virtual ICppResolvedExpression Visit(ICppBraceInitializedTemporaryExpression e);
    public virtual ICppResolvedExpression Visit(ICppBracedInitListExpression e);
    public virtual ICppResolvedExpression Visit(ICppCallExpression e);
    private ICppTypeIdOrExpression VisitCalleeOrInitializerTypeNode(ICppTypeIdOrExpression typeIdOrExpression, ICppExpression[] arguments);
    public virtual ICppResolvedExpression Visit(ICppCastExpression e);
    public virtual ICppResolvedExpression Visit(ICppConditionalExpression e);
    public virtual ICppResolvedExpression Visit(ICppEmptyExpression e);
    public virtual ICppResolvedExpression Visit(ICppLambdaExpression e);
    public virtual ICppResolvedExpression Visit(ICppReplacedLambdaExpression e);
    public virtual ICppResolvedExpression Visit(ICppGnuStatementExpression e);
    public virtual ICppResolvedExpression Visit(ICppReplacedGnuStatementExpression e);
    public virtual ICppResolvedExpression Visit(ICppRequiresExpression e);
    public virtual ICppResolvedExpression Visit(ICppReplacedRequiresExpression e);
    public virtual ICppResolvedExpression Visit(ICppMemberAccessExpression e);
    protected ICppResolvedMemberAccessExpression ResolveMemberAccess(ICppResolvedExpression qualifier, CppQualifiedName name, CppMemberAccessType accessType, CppResolveResult cachedUnqual);
    public virtual ICppResolvedExpression Visit(ICppMSAssumeExpression e);
    public virtual ICppResolvedExpression Visit(ICppBuiltinAddressOfExpression e);
    public virtual ICppResolvedExpression Visit(ICppBuiltinOffsetOfExpression e);
    public virtual ICppResolvedExpression Visit(ICppGnuBuiltinConstantPExpression e);
    public virtual ICppResolvedExpression Visit(ICppGNUAddressOfLabelExpression e);
    public virtual ICppResolvedExpression Visit(ICppSingleArgumentTypeTraitExpression e);
    public virtual ICppResolvedExpression Visit(ICppDoubleArgumentTypeTraitExpression e);
    public virtual ICppResolvedExpression Visit(ICppMultiArgumentTypeTraitExpression e);
    public virtual ICppResolvedExpression Visit(ICppMSNoopExpression e);
    public virtual ICppResolvedExpression Visit(ICppMSUuidOfExpression e);
    public virtual ICppResolvedExpression Visit(ICppMSEventHookExpression e);
    public virtual ICppResolvedExpression Visit(ICppNewExpression e);
    public virtual ICppResolvedExpression Visit(ICppNoExceptExpression e);
    public virtual ICppResolvedExpression Visit(ICppDeleteExpression e);
    public virtual ICppResolvedExpression Visit(ICppParenExpression e);
    public virtual ICppResolvedExpression Visit(ICppPostfixExpression e);
    public virtual ICppResolvedExpression Visit(ICppQualifiedReferenceExpression e);
    public virtual ICppResolvedExpression Visit(ICppSizeOfExpression e);
    public virtual ICppResolvedExpression Visit(ICppSizeOfEllipsisExpression e);
    public virtual ICppResolvedExpression Visit(ICppSubscriptExpression e);
    public virtual ICppResolvedExpression Visit(ICppCliMultiArgumentSubscriptExpression e);
    public virtual ICppResolvedExpression Visit(ICppCliTypeIdExpression e);
    public virtual ICppResolvedExpression Visit(ICppUserDefinedLiteralExpression e);
    public virtual ICppResolvedExpression Visit(ICppThisExpression e);
    public virtual ICppResolvedExpression Visit(ICppThrowExpression e);
    public virtual ICppResolvedExpression Visit(ICppTypeIdExpression e);
    public virtual ICppResolvedExpression Visit(ICppResolvedLiteralExpression e);
    public virtual ICppResolvedExpression Visit(ICppUnaryExpression e);
    public virtual ICppResolvedExpression Visit(ICppPackExpansionExpression e);
    public virtual ICppResolvedExpression Visit(ICppFoldExpression e);
    public virtual ICppResolvedExpression Visit(ICppCoAwaitExpression e);
    public virtual ICppResolvedExpression Visit(ICppCoYieldExpression e);
    public virtual ICppResolvedExpression Visit(ICppDesignation e);
    public virtual ICppResolvedExpression Visit(ICppC11GenericExpression e);
    public virtual ICppResolvedExpression VisitExpression(ICppExpression expr);
    public virtual ICppDesignator Visit(ICppMemberAccessDesignator m);
    public virtual ICppDesignator Visit(ICppSubscriptDesignator sd);
    public virtual ICppTypeIdOrExpression VisitTypeIdOrExpression(ICppTypeIdOrExpression e);
    public CppResolveEngine get_ResolveEngine();
    public ICppArgumentList ResolveArgumentList(ICppArgumentList argList);
    public CppQualType ResolveType(CppQualType type, ICppResolvedExpression autoInitializer);
    protected virtual CppQualifiedName VisitName(CppQualifiedName name);
    protected virtual ICppExpression[] ReApply(ICppExpression[] args);
    public virtual CppSmallArray`1<ICppExpression> ReApply(CppSmallArray`1<ICppExpression> args);
    protected ICppResolvedExpression ReApply(ICppExpression e);
    private ICppArgumentList ReApply(ICppArgumentList argList);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppRLEArrayValue : CppArrayValue {
    public ICppEvaluationResult[] Elements;
    public CppQualType ElementType;
    public int ActualSize;
    public ICppEvaluationResult DefaultValue;
    public int Length { get; }
    public CppRLEArrayValue(ICppEvaluationResult[] elements, CppQualType elementType, int actualSize, ICppEvaluationResult defaultValue);
    public static CppArrayValue Create(CppQualType elementType, int actualSize, ICppEvaluationResult defaultValue);
    public virtual int get_Length();
    public virtual ICppEvaluationResult At(int index, ICppEvaluationErrorTracker errorTracker);
    public virtual UpdateStatus UpdateElementValue(int index, ICppEvaluationResult newValue);
    private void Unshrink(int newSize);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    private static void Combine(Int32& seed, int elementHashCode);
    public virtual string ToString();
    public virtual CppQualType GetElementType(ICppResolvedTypeFactory tf);
    public virtual bool ContainsEvaluationFail(CppEvaluationParams evalParams);
    public virtual string Present(ICppPresenter presenter);
    public virtual CppTypeContext TryGetTypeContext();
    public virtual CppDependentInfo GetDependentInfo();
    private static bool Equals(CppRLEArrayValue a, CppRLEArrayValue b);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppRLEBracedInitListExpression : object {
    public static int SmallInitListSize;
    private ICppExpression myArgumentSample;
    private int myNumberOfArguments;
    private ICppExpression[] myFirstElements;
    public CppRLEBracedInitListExpression(ICppExpression argumentSample, ICppExpression[] elements, bool shrinkElements);
    public CppRLEBracedInitListExpression(ICppExpression argumentSample, int numberOfArguments, ICppExpression[] firstElements);
    public sealed virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public ICppExpression GetArgumentSample();
    public int GetNumberOfArguments();
    public ICppExpression[] GetFirstElements();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static ICppExpression ExpandExpression(ICppExpression expr);
    private static bool IsArrayOfInts(ICppExpression[] args);
    public static bool IsArrayOfBraces(ICppExpression[] args);
    private static bool ArrayContainsEmptyExpression(ICppExpression[] args);
    internal static ICppExpression ShrinkBracedInitList(ICppBracedInitListExpression bracedInitList);
    private CppBracedInitListExpression ExpandRLEBracedInitList();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppRuntimeArrayValue : CppArrayValue {
    public CppQualType ElementType;
    private Nullable`1<int> mySize;
    public CppReferenceToDeclarator Declarator;
    public int Length { get; }
    public CppRuntimeArrayValue(CppQualType elementType, Nullable`1<int> size, CppReferenceToDeclarator declarator);
    public virtual int get_Length();
    public virtual ICppEvaluationResult At(int index, ICppEvaluationErrorTracker errorTracker);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual CppQualType GetElementType(ICppResolvedTypeFactory tf);
    public virtual bool ContainsEvaluationFail(CppEvaluationParams evalParams);
    public virtual string Present(ICppPresenter presenter);
    public virtual CppTypeContext TryGetTypeContext();
    public virtual CppDependentInfo GetDependentInfo();
    public bool Equals(CppRuntimeArrayValue other);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppSignedValueBase`1 : CppValueBase`1<T> {
    public CppSignedValueRepresentation Representation { get; }
    public CppSignedValueKind SignedKind { get; }
    protected CppSignedValueBase`1(T repr);
    public abstract virtual CppSignedValueRepresentation get_Representation();
    public abstract virtual CppSignedValueKind get_SignedKind();
    public sealed virtual Result Accept(ICppValueVisitor`1<Result> visitor);
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Cpp.Expressions.CppSignedValueKind : Enum {
    public int value__;
    public static CppSignedValueKind CHAR;
    public static CppSignedValueKind SIGNED_CHAR;
    public static CppSignedValueKind SHORT;
    public static CppSignedValueKind INT;
    public static CppSignedValueKind LONG32;
    public static CppSignedValueKind LONG64;
    public static CppSignedValueKind LONGLONG;
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppSignedValueRepresentation : ValueType {
    public long Value;
    public byte BitSize;
    public long MaxValue { get; }
    public long MinValue { get; }
    public CppSignedValueRepresentation WithValue(long value);
    private long WrapValue(long value);
    public long get_MaxValue();
    public long get_MinValue();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CppSignedValueRepresentation left, CppSignedValueRepresentation right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CppSignedValueRepresentation left, CppSignedValueRepresentation right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CppSignedValueRepresentation other);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppSimpleArrayValue : CppArrayValue {
    public ICppEvaluationResult[] Elements;
    public CppQualType ElementType;
    public int Length { get; }
    public CppSimpleArrayValue(ICppEvaluationResult[] elements, CppQualType elementType);
    public virtual int get_Length();
    public virtual ICppEvaluationResult At(int index, ICppEvaluationErrorTracker errorTracker);
    public virtual UpdateStatus UpdateElementValue(int index, ICppEvaluationResult newValue);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual CppQualType GetElementType(ICppResolvedTypeFactory tf);
    public virtual bool ContainsEvaluationFail(CppEvaluationParams evalParams);
    public virtual string Present(ICppPresenter presenter);
    public virtual CppTypeContext TryGetTypeContext();
    public virtual CppDependentInfo GetDependentInfo();
    public bool Equals(CppSimpleArrayValue other);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppSingleArgumentTypeTraitExpression : CppExpressionBase {
    private CppQualType myArgument;
    private CppSingleArgumentTypeTraitKind myKind;
    public CppSingleArgumentTypeTraitExpression(CppQualType argument, CppSingleArgumentTypeTraitKind kind);
    public sealed virtual CppQualType GetArgument();
    public sealed virtual CppSingleArgumentTypeTraitKind GetKind();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public enum JetBrains.ReSharper.Psi.Cpp.Expressions.CppSingleArgumentTypeTraitKind : Enum {
    public int value__;
    public static CppSingleArgumentTypeTraitKind HAS_ASSIGN;
    public static CppSingleArgumentTypeTraitKind HAS_COPY;
    public static CppSingleArgumentTypeTraitKind HAS_FINALIZER;
    public static CppSingleArgumentTypeTraitKind HAS_NOTHROW_ASSIGN;
    public static CppSingleArgumentTypeTraitKind HAS_NOTHROW_CONSTRUCTOR;
    public static CppSingleArgumentTypeTraitKind HAS_NOTHROW_COPY;
    public static CppSingleArgumentTypeTraitKind HAS_TRIVIAL_ASSIGN;
    public static CppSingleArgumentTypeTraitKind HAS_TRIVIAL_CONSTRUCTOR;
    public static CppSingleArgumentTypeTraitKind HAS_TRIVIAL_COPY;
    public static CppSingleArgumentTypeTraitKind HAS_TRIVIAL_DESTRUCTOR;
    public static CppSingleArgumentTypeTraitKind HAS_USER_DESTRUCTOR;
    public static CppSingleArgumentTypeTraitKind HAS_VIRTUAL_DESTRUCTOR;
    public static CppSingleArgumentTypeTraitKind IS_ABSTRACT;
    public static CppSingleArgumentTypeTraitKind IS_AGGREGATE;
    public static CppSingleArgumentTypeTraitKind IS_CLASS;
    public static CppSingleArgumentTypeTraitKind IS_DELEGATE;
    public static CppSingleArgumentTypeTraitKind IS_EMPTY;
    public static CppSingleArgumentTypeTraitKind IS_ENUM;
    public static CppSingleArgumentTypeTraitKind IS_FINAL;
    public static CppSingleArgumentTypeTraitKind IS_INTERFACE_CLASS;
    public static CppSingleArgumentTypeTraitKind IS_POD;
    public static CppSingleArgumentTypeTraitKind IS_POLYMORPHIC;
    public static CppSingleArgumentTypeTraitKind IS_REF_ARRAY;
    public static CppSingleArgumentTypeTraitKind IS_REF_CLASS;
    public static CppSingleArgumentTypeTraitKind IS_SEALED;
    public static CppSingleArgumentTypeTraitKind IS_SIMPLE_VALUE_CLASS;
    public static CppSingleArgumentTypeTraitKind IS_UNION;
    public static CppSingleArgumentTypeTraitKind IS_VALUE_CLASS;
    public static CppSingleArgumentTypeTraitKind IS_STANDARD_LAYOUT;
    public static CppSingleArgumentTypeTraitKind IS_LITERAL;
    public static CppSingleArgumentTypeTraitKind IS_LITERAL_TYPE;
    public static CppSingleArgumentTypeTraitKind IS_TRIVIAL;
    public static CppSingleArgumentTypeTraitKind HAS_TRIVIAL_MOVE_CONSTRUCTOR;
    public static CppSingleArgumentTypeTraitKind HAS_TRIVIAL_MOVE_ASSIGN;
    public static CppSingleArgumentTypeTraitKind HAS_NOTHROW_MOVE_ASSIGN;
    public static CppSingleArgumentTypeTraitKind IS_DESTRUCTIBLE;
    public static CppSingleArgumentTypeTraitKind IS_NOTHROW_DESTRUCTIBLE;
    public static CppSingleArgumentTypeTraitKind IS_TRIVIALLY_DESTRUCTIBLE;
    public static CppSingleArgumentTypeTraitKind IS_TRIVIALLY_COPYABLE;
    public static CppSingleArgumentTypeTraitKind HAS_UNIQUE_OBJECT_REPRSENTATIONS;
    public static CppSingleArgumentTypeTraitKind IS_FUNCTION;
    public static CppSingleArgumentTypeTraitKind IS_OBJECT;
    public static CppSingleArgumentTypeTraitKind IS_ARRAY;
    public static CppSingleArgumentTypeTraitKind IS_UNBOUNDED_ARRAY;
    public static CppSingleArgumentTypeTraitKind IS_POINTER;
    public static CppSingleArgumentTypeTraitKind IS_MEMBER_POINTER;
    public static CppSingleArgumentTypeTraitKind IS_MEMBER_FUNCTION_POINTER;
    public static CppSingleArgumentTypeTraitKind IS_MEMBER_OBJECT_POINTER;
    public static CppSingleArgumentTypeTraitKind IS_REFERENCE;
    public static CppSingleArgumentTypeTraitKind IS_LVALUE_REFERENCE;
    public static CppSingleArgumentTypeTraitKind IS_RVALUE_REFERENCE;
    public static CppSingleArgumentTypeTraitKind IS_CONST;
    public static CppSingleArgumentTypeTraitKind IS_VOLATILE;
    public static CppSingleArgumentTypeTraitKind IS_NULLPTR;
    public static CppSingleArgumentTypeTraitKind IS_SCALAR;
    public static CppSingleArgumentTypeTraitKind IS_ARITHMETIC;
    public static CppSingleArgumentTypeTraitKind IS_COMPOUND;
    public static CppSingleArgumentTypeTraitKind IS_FUNDAMENTAL;
    public static CppSingleArgumentTypeTraitKind IS_COMPLETE_TYPE;
    public static CppSingleArgumentTypeTraitKind IS_SIGNED;
    public static CppSingleArgumentTypeTraitKind IS_UNSIGNED;
    public static CppSingleArgumentTypeTraitKind IS_VOID;
    public static CppSingleArgumentTypeTraitKind IS_INTEGRAL;
    public static CppSingleArgumentTypeTraitKind IS_FLOATING_POINT;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppSingleArgumentTypeTraitKindUtil : object {
    private static HashMap`2<TokenNodeType, CppSingleArgumentTypeTraitKind> ourTokenToKind;
    private static HashMap`2<CppSingleArgumentTypeTraitKind, TokenNodeType> ourKindToToken;
    private static CppSingleArgumentTypeTraitKindUtil();
    public static CppSingleArgumentTypeTraitKind TokenTypeToSingleArgumentTypeTraitKind(TokenNodeType tok);
    [ExtensionAttribute]
public static string GetRepresentation(CppSingleArgumentTypeTraitKind kind);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__Add|2_0(TokenNodeType token, CppSingleArgumentTypeTraitKind kind);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppSizeOfEllipsisExpression : CppExpressionBase {
    private CppQualifiedName myArgument;
    public CppSizeOfEllipsisExpression(CppQualifiedName argument);
    public sealed virtual CppQualifiedName GetArgument();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppSizeOfExpression : CppExpressionBase {
    private ICppTypeIdOrExpression myArgument;
    public CppSizeOfExpression(ICppTypeIdOrExpression argument);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppTypeIdOrExpression GetArgument();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppStringLiteralArrayValue : CppArrayValue {
    private UInt32[] myCharacters;
    private CppStringLiteralType myLiteralType;
    public CppResolvedStringLiteralValue Literal;
    public CppQualType ElementType;
    public int ArraySize;
    public int Length { get; }
    private CppStringLiteralArrayValue(CppResolvedStringLiteralValue literal, UInt32[] characters, int arraySize, CppStringLiteralType literalType, CppQualType elementType);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CanBeNullAttribute]
public static CppStringLiteralArrayValue TryCreate(CppResolvedStringLiteralValue literal, CppQualType targetElementType, Nullable`1<int> size);
    [NotNullAttribute]
public static CppStringLiteralArrayValue Create(CppResolvedStringLiteralValue literal);
    public virtual CppQualType GetElementType(ICppResolvedTypeFactory _);
    public virtual bool ContainsEvaluationFail(CppEvaluationParams _);
    public virtual string Present(ICppPresenter presenter);
    public virtual bool EqualReferences(CppArrayValue other);
    public virtual int get_Length();
    public virtual ICppEvaluationResult At(int index, ICppEvaluationErrorTracker errorTracker);
    public virtual CppDependentInfo GetDependentInfo();
    public virtual CppTypeContext TryGetTypeContext();
    private bool Equals(CppStringLiteralArrayValue other);
    private static bool IsCompatibleCharacterType(CppQualType type, CppStringLiteralType literalType);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppStringLiteralMultiPartValue : CppStringLiteralValue {
    private String[] myParts;
    public FrugalLocalList`1<string> Parts { get; }
    public CppStringLiteralMultiPartValue(String[] parts);
    public String[] GetParts();
    public virtual FrugalLocalList`1<string> get_Parts();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppStringLiteralSinglePartValue : CppStringLiteralValue {
    private string mySinglePart;
    public FrugalLocalList`1<string> Parts { get; }
    public CppStringLiteralSinglePartValue(string singlePart);
    public string GetSinglePart();
    public virtual FrugalLocalList`1<string> get_Parts();
}
public enum JetBrains.ReSharper.Psi.Cpp.Expressions.CppStringLiteralType : Enum {
    public int value__;
    public static CppStringLiteralType REGULAR;
    public static CppStringLiteralType WIDE;
    public static CppStringLiteralType CHAR8;
    public static CppStringLiteralType CHAR16;
    public static CppStringLiteralType CHAR32;
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppStringLiteralValue : CppValueBase {
    public FrugalLocalList`1<string> Parts { get; }
    public static CppStringLiteralValue Create(FrugalLocalList`1<string> parts);
    public abstract virtual FrugalLocalList`1<string> get_Parts();
    public virtual Result Accept(ICppValueVisitor`1<Result> visitor);
    public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppStringLiteralValueUtil : object {
    [ExtensionAttribute]
public static string BuildString(CppStringLiteralValue value);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppSubscriptDesignator : CppBaseDesignator {
    protected ICppExpression myIndex;
    public CppSubscriptDesignator(ICppDesignator qualifier, ICppExpression index);
    public virtual TResult Accept(ICppDesignatorVisitor`1<TResult> visitor);
    public sealed virtual ICppExpression GetIndex();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppSubscriptExpression : CppExpressionBase {
    private ICppExpression myLeftArgument;
    private CppSmallArray`1<ICppExpression> myIndexArguments;
    public CppSubscriptExpression(ICppExpression leftArgument, CppSmallArray`1<ICppExpression> indexArguments);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public virtual ICppExpression GetLeftArgument();
    public virtual CppSmallArray`1<ICppExpression> GetIndexArguments();
    public virtual int GetIndexArgumentCount();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppSubstitutedResolvedQualifiedReferenceExpression : CppResolvedQualifiedReferenceExpression {
    public ICppResolvedQualifiedReferenceExpression InnerReference;
    public ICppSubstitutionContext SubstitutionContext;
    public CppSubstitutedResolvedQualifiedReferenceExpression(CppQualifiedName resolvedName, CppResolveResult& resolvedReference, CppViewPos& viewPos, ICppResolvedQualifiedReferenceExpression innerReference, ICppSubstitutionContext substitutionContext);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppThisByValueLambdaCaptureDescription : CppLambdaCaptureDescription {
    public CppLambdaCaptureDescriptionKind Kind { get; }
    public virtual CppLambdaCaptureDescriptionKind get_Kind();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppThisExpression : CppExpressionBase {
    public static CppThisExpression Instance;
    private static CppThisExpression();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppThisLambdaCaptureDescription : CppLambdaCaptureDescription {
    public CppLambdaCaptureDescriptionKind Kind { get; }
    public virtual CppLambdaCaptureDescriptionKind get_Kind();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppThisObjectLv : CppLval {
    public virtual TResult Accept(ICppLvalVisitor`1<TResult> vis);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppThrowExpression : CppExpressionBase {
    [CanBeNullAttribute]
private ICppExpression myArgument;
    public CppThrowExpression(ICppExpression argument);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppExpression GetArgument();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppTypeId : object {
    private CppQualType myQualType;
    public CppTypeId(CppQualType qualType);
    public sealed virtual CppQualType GetQualType();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppTypeIdExpression : CppExpressionBase {
    private ICppTypeIdOrExpression myArgument;
    public CppTypeIdExpression(ICppTypeIdOrExpression argument);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppTypeIdOrExpression GetArgument();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppTypeIdOrExpressionUtil : object {
    [ExtensionAttribute]
public static bool IsPackExpansion(ICppTypeIdOrExpression typeIdOrExpr);
    [ExtensionAttribute]
public static void UpdateLazyMergingInfo(ICppTypeIdOrExpression input, ICppLazyMergingDataConsumer resultConsumer);
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertTypeClass(ICppTypeIdOrExpression input, CppTypeClasses typec);
    [ExtensionAttribute]
public static ICppTypeIdOrExpression ResolveTypeIdOrExpression(ICppTypeIdOrExpression arg, CppTypeContext& tc, ICppFileResolveEntitiesCache cache);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppUnaryExpression : CppExpressionBase {
    private ICppExpression myArgument;
    private CppOperatorKind myOperatorKind;
    public CppUnaryExpression(ICppExpression argument, CppOperatorKind operatorKind);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual ICppExpression GetArgument();
    public sealed virtual CppOperatorKind GetOperatorKind();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppUnknownArraySizeExpression : CppEmptyExpression {
    public static CppUnknownArraySizeExpression Instance;
    private static CppUnknownArraySizeExpression();
    public virtual CppDependentInfo GetDependentInfo();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppUnsignedValueBase`1 : CppValueBase`1<T> {
    public CppUnsignedValueRepresentation Representation { get; }
    public CppUnsignedValueKind UnsignedKind { get; }
    protected CppUnsignedValueBase`1(T repr);
    public abstract virtual CppUnsignedValueRepresentation get_Representation();
    public abstract virtual CppUnsignedValueKind get_UnsignedKind();
    public sealed virtual Result Accept(ICppValueVisitor`1<Result> visitor);
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Cpp.Expressions.CppUnsignedValueKind : Enum {
    public int value__;
    public static CppUnsignedValueKind UNSIGNED_CHAR;
    public static CppUnsignedValueKind WCHAR_T16;
    public static CppUnsignedValueKind WCHAR_T32;
    public static CppUnsignedValueKind CHAR8_T;
    public static CppUnsignedValueKind CHAR16_T;
    public static CppUnsignedValueKind CHAR32_T;
    public static CppUnsignedValueKind UNSIGNED_SHORT;
    public static CppUnsignedValueKind UNSIGNED;
    public static CppUnsignedValueKind UNSIGNED_LONG32;
    public static CppUnsignedValueKind UNSIGNED_LONG64;
    public static CppUnsignedValueKind UNSIGNED_LONGLONG;
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppUnsignedValueRepresentation : ValueType {
    public ulong Value;
    public byte BitSize;
    public ulong MaxValue { get; }
    public ulong MinValue { get; }
    public CppUnsignedValueRepresentation WithValue(ulong value);
    private ulong WrapValue(ulong value);
    public ulong get_MaxValue();
    public ulong get_MinValue();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CppUnsignedValueRepresentation left, CppUnsignedValueRepresentation right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CppUnsignedValueRepresentation left, CppUnsignedValueRepresentation right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CppUnsignedValueRepresentation other);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppUserDefinedLiteralCharacterValue : object {
    private string myText;
    private UInt32 myValue;
    private CppCharType myCharType;
    public CppUserDefinedLiteralCharacterValue(string text, UInt32 value, CppCharType type);
    public sealed virtual CppUserDefinedLiteralValueKind GetKind(CppLanguageDialect dialect);
    public sealed virtual string Present(string with_suffix, ICppPresenter presenter);
    public sealed virtual string GetRawText();
    public sealed virtual ICppExpression[] CreateFunctionArguments(CppLanguageDialect dialect);
    public string GetText();
    public UInt32 GetValue();
    public CppCharType GetCharType();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppUserDefinedLiteralExpression : CppExpressionBase {
    private ICppUserDefinedLiteralValue myLiteralValue;
    private string mySuffix;
    public CppUserDefinedLiteralExpression(ICppUserDefinedLiteralValue value, string suffix);
    public sealed virtual ICppUserDefinedLiteralValue GetLiteralValue();
    public sealed virtual string GetSuffix();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppUserDefinedLiteralFloatValue : object {
    private string myText;
    private double myValue;
    public CppUserDefinedLiteralFloatValue(string text, double value);
    public sealed virtual CppUserDefinedLiteralValueKind GetKind(CppLanguageDialect dialect);
    public sealed virtual string Present(string with_suffix, ICppPresenter presenter);
    public sealed virtual string GetRawText();
    public sealed virtual ICppExpression[] CreateFunctionArguments(CppLanguageDialect dialect);
    public string GetText();
    public double GetValue();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppUserDefinedLiteralIntValue : object {
    private string myText;
    private ulong myValue;
    private bool myHasOverflow;
    public CppUserDefinedLiteralIntValue(string text, ulong value, bool hasOverflow);
    public sealed virtual CppUserDefinedLiteralValueKind GetKind(CppLanguageDialect dialect);
    public sealed virtual string Present(string with_suffix, ICppPresenter presenter);
    public sealed virtual string GetRawText();
    public string GetText();
    public ulong GetValue();
    public bool HasOverflow();
    public sealed virtual ICppExpression[] CreateFunctionArguments(CppLanguageDialect dialect);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppUserDefinedLiteralStringValue : object {
    private FrugalLocalList`1<string> myParts;
    private bool myStringTypeReady;
    private CppStringLiteralType myStringType;
    public CppUserDefinedLiteralStringValue(FrugalLocalList`1<string> parts);
    public sealed virtual CppUserDefinedLiteralValueKind GetKind(CppLanguageDialect dialect);
    public sealed virtual string Present(string with_suffix, ICppPresenter presenter);
    public sealed virtual string GetRawText();
    public sealed virtual ICppExpression[] CreateFunctionArguments(CppLanguageDialect dialect);
    public FrugalLocalList`1<string> GetParts();
    public CppStringLiteralType GetStringType(CppLanguageDialect dialect);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public enum JetBrains.ReSharper.Psi.Cpp.Expressions.CppUserDefinedLiteralValueKind : Enum {
    public int value__;
    public static CppUserDefinedLiteralValueKind INTEGER;
    public static CppUserDefinedLiteralValueKind FLOATING_POINT;
    public static CppUserDefinedLiteralValueKind CHARACTER_REGULAR;
    public static CppUserDefinedLiteralValueKind CHARACTER_WIDE;
    public static CppUserDefinedLiteralValueKind CHARACTER_CHAR8;
    public static CppUserDefinedLiteralValueKind CHARACTER_CHAR16;
    public static CppUserDefinedLiteralValueKind CHARACTER_CHAR32;
    public static CppUserDefinedLiteralValueKind STRING_REGULAR;
    public static CppUserDefinedLiteralValueKind STRING_WIDE;
    public static CppUserDefinedLiteralValueKind STRING_CHAR8;
    public static CppUserDefinedLiteralValueKind STRING_CHAR16;
    public static CppUserDefinedLiteralValueKind STRING_CHAR32;
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppValueBase : object {
    public sealed virtual ICppLiteralValue GetValue();
    public sealed virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public virtual CppTypeContext TryGetTypeContext();
    public abstract virtual Result Accept(ICppValueVisitor`1<Result> visitor);
    public virtual bool ContainsEvaluationFail(CppEvaluationParams params);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppValueBase`1 : CppValueBase {
    [CompilerGeneratedAttribute]
private T <RawRepresentation>k__BackingField;
    public T RawRepresentation { get; }
    protected CppValueBase`1(T repr);
    [CompilerGeneratedAttribute]
public sealed virtual T get_RawRepresentation();
    protected bool Equals(CppValueBase`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppValueKindUtil : object {
    [ExtensionAttribute]
public static byte GetBitSize(CppUnsignedValueKind kind);
    [ExtensionAttribute]
public static byte GetBitSize(CppSignedValueKind kind);
    [ExtensionAttribute]
public static Nullable`1<CppSignedValueKind> ToSignedValueKind(CppIntTypeKind kind, CppLanguageDialect dialect);
    [ExtensionAttribute]
public static Nullable`1<CppUnsignedValueKind> ToUnsignedValueKind(CppIntTypeKind kind, CppLanguageDialect dialect);
    [ExtensionAttribute]
public static CppFloatingValueKind ToFloatingValueKind(CppFloatTypeKind kind);
    [ExtensionAttribute]
public static CppQualType ToQualType(CppSignedValueKind kind);
    [ExtensionAttribute]
public static CppQualType ToQualType(CppUnsignedValueKind kind);
    [ExtensionAttribute]
public static CppQualType ToQualType(CppFloatingValueKind kind);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Expressions.CppValueUtil : object {
    [ExtensionAttribute]
[ObsoleteAttribute]
public static ICppValueExpression AsExpression(ICppValue value);
    [ExtensionAttribute]
[ObsoleteAttribute("`ICppValueExpression` is already an expression", "True")]
public static void AsExpression(ICppValueExpression value);
    [ExtensionAttribute]
public static bool IsEmptyObjectValue(ICppValue value);
    [ExtensionAttribute]
public static ICppEvaluationResult CreateDefaultInitialized(CppQualType type, CppExpressionEvaluator evaluator, bool zeroPreInitialize);
    public static bool ContainsEvaluationFail(ICppEvaluationResult result, CppEvaluationParams evalParams);
    public static bool ContainsEvaluationFail(ICppDeclaratorResolveEntity decl, CppEvaluationParams evalParams);
    public static bool TryParseDoubleValueFromText(string str, Double& value);
    public static ICppFloatingValue CreateFloatValueFromText(string str, CppLanguageDialect cppLanguageDialect);
    public static ICppIntegralValue CreateCharacterValueFromText(string str, CppLanguageDialect dialect);
    public static ICppIntegralValue CreateCharacterValue(UInt32 result, CppCharType charType, int bytes, CppLanguageDialect dialect);
    public static ICppUnsignedIntegralValue CreateSizeTValue(CppLanguageDialect dialect, int val);
    public static ICppValue CreatePtrDiffValue(CppLanguageDialect dialect, int val);
    [ExtensionAttribute]
public static Nullable`1<long> ExtractPtrDiffValue(ICppValue value, CppLanguageDialect dialect);
    [ExtensionAttribute]
public static ICppEvaluationResult DeepCopyValue(ICppEvaluationResult result);
    [ExtensionAttribute]
public static ICppValue DeepCopyValue(ICppValue val);
    public static Dictionary`2<ICppGroupedVariableDeclaratorResolveEntity, ICppEvaluationResult> DeepCopyFields(Dictionary`2<ICppGroupedVariableDeclaratorResolveEntity, ICppEvaluationResult> fields);
    public static ICppUnsignedIntegralValue CreateSizeTValue(ICppResolvedTypeFactory tf, int val);
    private static CppQualType GetDepKillerValueType(CppDependencyKillerValue depKiller, ICppResolvedTypeFactory typeFactory);
    private static CppTypeAndCategory GetTypeOfStringLiteralExpression(FrugalLocalList`1<string> parts, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType GetCppType(ICppValue value, ICppResolvedTypeFactory typeFactory);
    [ExtensionAttribute]
public static CppQualType GetCppType(ICppValue value, CppTypeContext& tc);
    [ExtensionAttribute]
public static CppTypeAndCategory GetTypeAndCategory(ICppValue value, ICppResolvedTypeFactory typeFactory);
    [ExtensionAttribute]
public static Nullable`1<ulong> GetValueIfNonNegative(ICppIntegralValue value);
    [ExtensionAttribute]
public static Nullable`1<ulong> GetValueIfNumericAndNonNegative(ICppValue value);
    [ExtensionAttribute]
public static ICppEvaluationResult UnwrapReference(ICppEvaluationResult arg, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
public static ICppEvaluationResult UnwrapPointer(ICppEvaluationResult arg, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
public static ICppEnumeratorResolveEntity FindEnumerator(CppEnumValue enumValue);
    [ExtensionAttribute]
public static ICppEvaluationResult GetValue(CppExpressionEvaluator evaluator, ICppGroupedVariableDeclaratorResolveEntity var);
    [ExtensionAttribute]
[ObsoleteAttribute]
public static TriBool IsZero(ICppValueExpression expr, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
[ObsoleteAttribute]
public static TriBool IsZero(ICppResolvedExpression expr, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
public static bool IsZero(ICppIntegralValue value);
    [ExtensionAttribute]
[ObsoleteAttribute]
private static TriBool IsZero(CppExpressionValue value, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
[ObsoleteAttribute]
public static TriBool IsZeroOrNegative(CppExpressionValue value, CppExpressionEvaluator evaluator);
    [ExtensionAttribute]
public static bool IsZeroOrNegative(ICppIntegralValue value);
    [ExtensionAttribute]
public static ICppEvaluationResult MakeZeroInitializedValue(CppQualType type, CppExpressionEvaluator evaluator);
    public static ICppEvaluationResult PerformBinaryOperation(CppExpressionValue a, CppExpressionValue b, CppOperatorKind binaryKind, CppExpressionEvaluator evaluator, ICppFunctionDeclaratorResolveEntity builtin);
    private static ICppEvaluationResult PerformBinaryOperationImpl(CppExpressionValue a, CppExpressionValue b, CppQualType aType, CppQualType bType, CppOperatorKind binaryKind, CppExpressionEvaluator evaluator);
    [NotNullAttribute]
public static ICppEvaluationResult ShiftPointer(CppPointerValue ptr, long delta, CppExpressionEvaluator evaluator);
    [CanBeNullAttribute]
private static ICppEvaluationResult TryPerformPointerArithmetic(ICppValue aValue, ICppValue bValue, CppQualType aType, CppQualType bType, CppOperatorKind binaryKind, CppLanguageDialect dialect, CppExpressionEvaluator evaluator);
    private static TriBool TryComparePointers(ICppValue left, ICppValue right, CppOperatorKind binaryKind);
    private static Nullable`1<CppQualType> GetResultType(CppQualType aType, CppQualType bType, CppOperatorKind binaryKind, CppLanguageDialect dialect);
    private static ICppEvaluationResult ConvertAndAddValues(ICppValue lhs, ICppValue rhs, CppOperatorKind binaryKind, CppQualType type, CppExpressionEvaluator evaluator);
    public static ICppValue PerformBinaryOperation(ICppSignedIntegralValueBase lhs, ICppSignedIntegralValueBase rhs, CppSignedValueKind signedKind, CppOperatorKind binaryKind);
    public static ICppValue PerformBinaryOperation(ICppUnsignedIntegralValueBase lhs, ICppUnsignedIntegralValueBase rhs, CppUnsignedValueKind unsignedKind, CppOperatorKind binaryKind);
    private static CppBoolValue PerformBinaryOperation(bool lhs, bool rhs, CppOperatorKind binaryKind);
    private static ICppValue PerformBinaryOperation(CppFloatingValueRepresentation lhsRepr, CppFloatingValueRepresentation rhsRepr, CppFloatingValueKind floatingKind, CppOperatorKind binaryKind);
    private static long AndOrImpl(long lhs, long rhs, CppOperatorKind binaryKind);
    private static ICppUnsignedIntegralValue SafeDiv(CppUnsignedValueRepresentation a, CppUnsignedValueRepresentation b, CppUnsignedValueKind unsignedKind);
    private static ICppSignedIntegralValue SafeDiv(CppSignedValueRepresentation a, CppSignedValueRepresentation b, CppSignedValueKind signedKind);
    private static ICppUnsignedIntegralValue SafeRem(CppUnsignedValueRepresentation a, CppUnsignedValueRepresentation b, CppUnsignedValueKind unsignedKind);
    private static ICppSignedIntegralValue SafeRem(CppSignedValueRepresentation a, CppSignedValueRepresentation b, CppSignedValueKind signedKind);
    private static ICppFloatingValue SafeDiv(CppFloatingValueRepresentation a, CppFloatingValueRepresentation b, CppFloatingValueKind floatingKind);
    private static float SafeDiv(float a, float b);
    private static double SafeDiv(double a, double b);
    [ExtensionAttribute]
public static ICppEvaluationResult PerformUnaryOperation(CppExpressionValue a, CppOperatorKind kind, CppExpressionEvaluator evaluator, CppQualType paramType);
    [ExtensionAttribute]
public static ICppEvaluationResult PerformPostfixOperation(CppExpressionValue value, CppOperatorKind kind, CppExpressionEvaluator evaluator);
    public static ICppSignedIntegralValue PerformUnaryOperation(ICppSignedIntegralValueBase value, CppOperatorKind opKind);
    public static ICppUnsignedIntegralValue PerformUnaryOperation(ICppUnsignedIntegralValueBase value, CppOperatorKind opKind);
    private static ICppFloatingValue PerformUnaryOperation(ICppFloatingValue value, CppOperatorKind opKind);
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static ICppEvaluationResult <TryPerformPointerArithmetic>g__TryAdd|42_0(ICppValue left, ICppValue right, CppLanguageDialect dialect, CppExpressionEvaluator evaluator);
    [CompilerGeneratedAttribute]
internal static bool <TryPerformPointerArithmetic>g__IsPointerOrNullPtr|42_1(CppQualType type);
    [CompilerGeneratedAttribute]
internal static TriBool <TryComparePointers>g__AreEqual|43_0(ICppValue left, ICppValue right);
    [CompilerGeneratedAttribute]
internal static bool <TryComparePointers>g__IsZeroPointer|43_2(ICppValue value);
    [CompilerGeneratedAttribute]
internal static TriBool <TryComparePointers>g__IsLess|43_1(ICppValue left, ICppValue right);
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.CppVoidValue : object {
    public static CppVoidValue Instance;
    private static CppVoidValue();
    public sealed virtual Result Accept(ICppValueVisitor`1<Result> visitor);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool ContainsEvaluationFail(CppEvaluationParams params);
    public string Present(ICppPresenter presenter);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Expressions.CppWalkExpressionVisitor : CppAbstractForwardingExpressionVisitor`1<CppMonostate> {
    public virtual CppMonostate Visit(ICppEmptyExpression expr);
    public virtual CppMonostate Visit(ICppResolvedLiteralExpression expr);
    public virtual CppMonostate Visit(ICppUserDefinedLiteralExpression expr);
    public virtual CppMonostate Visit(ICppThisExpression expr);
    public virtual CppMonostate Visit(ICppQualifiedReferenceExpression expr);
    public virtual CppMonostate Visit(ICppResolvedQualifiedReferenceExpression expr);
    public virtual CppMonostate Visit(ICppSizeOfEllipsisExpression expr);
    public virtual CppMonostate Visit(ICppAlignOfExpression expr);
    public virtual CppMonostate Visit(ICppNoExceptExpression expr);
    public virtual CppMonostate Visit(ICppSingleArgumentTypeTraitExpression expr);
    public virtual CppMonostate Visit(ICppDoubleArgumentTypeTraitExpression expr);
    public virtual CppMonostate Visit(ICppMultiArgumentTypeTraitExpression expr);
    public virtual CppMonostate Visit(ICppMSNoopExpression expr);
    public virtual CppMonostate Visit(ICppLambdaExpression expr);
    public virtual CppMonostate Visit(ICppReplacedLambdaExpression expr);
    public virtual CppMonostate Visit(ICppRequiresExpression expr);
    public virtual CppMonostate Visit(ICppCliTypeIdExpression expr);
    public virtual CppMonostate Visit(ICppParenExpression e);
    public virtual CppMonostate Visit(ICppBinaryExpression e);
    public virtual CppMonostate Visit(ICppUnaryExpression e);
    public virtual CppMonostate Visit(ICppPostfixExpression e);
    public virtual CppMonostate Visit(ICppConditionalExpression e);
    public virtual CppMonostate Visit(ICppMemberAccessExpression e);
    public virtual CppMonostate Visit(ICppNewExpression e);
    public virtual CppMonostate Visit(ICppDeleteExpression e);
    public virtual CppMonostate Visit(ICppSubscriptExpression e);
    public virtual CppMonostate Visit(ICppCallExpression e);
    public virtual CppMonostate Visit(ICppCastExpression e);
    public virtual CppMonostate Visit(ICppSizeOfExpression e);
    public virtual CppMonostate Visit(ICppTypeIdExpression e);
    public virtual CppMonostate Visit(ICppMSUuidOfExpression e);
    public virtual CppMonostate Visit(ICppMSEventHookExpression e);
    public virtual CppMonostate Visit(ICppMSAssumeExpression e);
    public virtual CppMonostate Visit(ICppBuiltinAddressOfExpression e);
    public virtual CppMonostate Visit(ICppGnuBuiltinConstantPExpression e);
    public virtual CppMonostate Visit(ICppThrowExpression e);
    public virtual CppMonostate Visit(ICppBracedInitListExpression e);
    public virtual CppMonostate Visit(ICppBraceInitializedTemporaryExpression e);
    public virtual CppMonostate Visit(ICppReplacedRequiresExpression e);
    public virtual CppMonostate Visit(ICppLinkageRequiresExpression e);
    public virtual CppMonostate Visit(ICppCliMultiArgumentSubscriptExpression expr);
    public virtual CppMonostate Visit(ICppPackExpansionExpression e);
    public virtual CppMonostate Visit(ICppFoldExpression e);
    public virtual CppMonostate Visit(ICppCoAwaitExpression e);
    public virtual CppMonostate Visit(ICppCoYieldExpression e);
    public virtual CppMonostate Visit(ICppDesignation e);
    public virtual CppMonostate Visit(ICppC11GenericExpression e);
    protected void ReApply(ICppExpression expr);
    protected void ReApply(ICppTypeIdOrExpression toe);
    protected void ReApplyList(ICppArgumentList argList);
    protected void ReApplyList(ICppExpression[] argList);
}
public enum JetBrains.ReSharper.Psi.Cpp.Expressions.DeleteExpressionKind : Enum {
    public int value__;
    public static DeleteExpressionKind SingleObject;
    public static DeleteExpressionKind ArrayObject;
}
public class JetBrains.ReSharper.Psi.Cpp.Expressions.HexFloat : ValueType {
    public bool IsNegative;
    public ulong Mantissa;
    public int Exponent;
    public HexFloat(bool isNegative, ulong digits, int exponent);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(HexFloat other);
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppAlignOfExpression {
    public abstract virtual ICppTypeIdOrExpression GetArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppAnyResolvedReferenceExpression {
    public abstract virtual CppResolveResult GetResolvedReference();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppAnySubscriptExpression {
    public abstract virtual ICppExpression GetLeftArgument();
    public abstract virtual int GetIndexArgumentCount();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppArgumentList {
    public abstract virtual ICppExpression[] GetArguments();
    public abstract virtual CppArgumentListKind GetArgListKind();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppBinaryExpression {
    public abstract virtual ICppExpression GetLeftArgument();
    public abstract virtual ICppExpression GetRightArgument();
    public abstract virtual CppOperatorKind GetOperatorKind();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppBracedInitListExpression {
    public abstract virtual bool HasBeenShrinked();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppBraceInitializedTemporaryExpression {
    public abstract virtual ICppTypeIdOrExpression GetInitializerTypeNode();
    public abstract virtual ICppBracedInitListExpression GetArgumentList();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppBuiltinAddressOfExpression {
    [CanBeNullAttribute]
public abstract virtual ICppExpression GetArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppBuiltinOffsetOfExpression {
    public abstract virtual CppQualType GetTypeArgument();
    public abstract virtual CppQualifiedName GetMemberDesignator();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppC11GenericExpression {
    public abstract virtual ICppExpression GetControllingExpression();
    public abstract virtual CppC11GenericExpressionClause[] GetClauses();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppCallExpression {
    public abstract virtual ICppTypeIdOrExpression GetCallee();
    public abstract virtual ICppExpression[] GetArguments();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppCastExpression {
    public abstract virtual ICppExpression GetArgument();
    public abstract virtual CppCastType GetCastType();
    public abstract virtual CppQualType GetQualType();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppClassMemberEvaluator {
    public abstract virtual ICppEvaluationResult Evaluate(CppGroupedVariableDeclaratorResolveEntity member);
    public abstract virtual ICppEvaluationResult Evaluate(ICppClassResolveEntity clazz);
    public abstract virtual CppEvaluationFail Fail(CppEvaluationFailureKind kind);
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppCliMultiArgumentSubscriptExpression {
    public abstract virtual ICppExpression[] GetIndexArguments();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppCliTypeIdExpression {
    public abstract virtual CppQualifiedName GetArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppCoAwaitExpression {
    public abstract virtual ICppExpression GetArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppConditionalExpression {
    public abstract virtual ICppExpression GetFirstArgument();
    public abstract virtual ICppExpression GetSecondArgument();
    public abstract virtual ICppExpression GetThirdArgument();
    public abstract virtual CppConditionalExprKind GetKind();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppCoYieldExpression {
    public abstract virtual ICppExpression GetArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppDeleteExpression {
    public DeleteExpressionKind Kind { get; }
    public abstract virtual DeleteExpressionKind get_Kind();
    public abstract virtual ICppExpression GetArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppDesignation {
    public abstract virtual ICppDesignator GetDesignator();
    public abstract virtual ICppExpression GetInitializer();
    public abstract virtual InitializerKind GetInitializerKind();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppDesignator {
    [CanBeNullAttribute]
public abstract virtual ICppDesignator GetQualifier();
    public abstract virtual TResult Accept(ICppDesignatorVisitor`1<TResult> visitor);
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppDesignatorVisitor`1 {
    public abstract virtual TResult Visit(ICppMemberAccessDesignator d);
    public abstract virtual TResult Visit(ICppSubscriptDesignator d);
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppDoubleArgumentTypeTraitExpression {
    public abstract virtual CppQualType GetFirstArgument();
    public abstract virtual CppQualType GetSecondArgument();
    public abstract virtual CppDoubleArgumentTypeTraitKind GetKind();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppEmptyExpression {
    public abstract virtual CppUnknownEntityInfo GetInfo();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppEnumValue {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppEvaluationErrorTracker {
    public abstract virtual bool ShouldReevaluate(CppEvaluationFail fail);
    public abstract virtual CppEvaluationFail Fail(CppEvaluationFailureKind kind);
    public abstract virtual CppEvaluationFail CallOfNonConstexprFunction(ICppFunctionDeclaratorResolveEntity function);
    public abstract virtual CppEvaluationFail InvalidBodyOfConstexprFunction(ICppFunctionDeclaratorResolveEntity function);
    public abstract virtual CppEvaluationFail UnresolvedReference(ICppResolvedQualifiedReferenceExpression expr);
    public abstract virtual CppEvaluationFail UnresolvedExpression(ICppResolvedExpression expr);
    public abstract virtual CppEvaluationFail IndexOutOfBounds(int index, int length);
    public abstract virtual CppEvaluationFail NonIntegralArrayIndex(ICppResolvedExpression index, CppQualType type);
    public abstract virtual CppEvaluationFail InvalidZeroInitialization(CppQualType type);
    public abstract virtual CppEvaluationFail DeclaratorOfVoidType();
    public abstract virtual CppEvaluationFail NonVoidReturnInVoidFunction(ICppValue value);
    public abstract virtual CppEvaluationFail VoidReturnInNonVoidFunction(CppQualType type);
    public abstract virtual CppEvaluationFail OffsetOfNonClassType(CppQualType type);
    public abstract virtual CppEvaluationFail OffsetOfIncompleteType(ICppClassResolveEntity clazz);
    public abstract virtual CppEvaluationFail OffsetOfUnresolvedDesignator(CppQualifiedName designator);
    public abstract virtual CppEvaluationFail OffsetOfNonNonStaticDataMember(ICppResolveEntity entity);
    public abstract virtual CppEvaluationFail OffsetOfBitfield(ICppDeclaratorResolveEntity declarator);
    public abstract virtual CppEvaluationFail BadConversion(ICppResolvedExpression sourceExpr, CppQualType destType, ICppResolvedTypeFactory tf, bool isInitialization);
    public abstract virtual CppEvaluationFail DuplicatedCtorInitializer(ICppResolveEntity member);
    public abstract virtual CppEvaluationFail InternalUnsupportedFunction(ICppFunctionDeclaratorResolveEntity function);
    public abstract virtual CppEvaluationFail InternalUnsupportedStatement(ICppResolveEntity statement);
    public abstract virtual CppEvaluationFail InternalTooManyIterations();
    public abstract virtual void EnterFunctionScope(ICppFunctionDeclaratorResolveEntity function);
    public abstract virtual void LeaveFunctionScope();
    public abstract virtual void EnterVariableScope(ICppGroupedVariableDeclaratorResolveEntity declarator);
    public abstract virtual void LeaveVariableScope();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppEvaluationResult {
    public abstract virtual bool ContainsEvaluationFail(CppEvaluationParams params);
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppExpression {
    public abstract virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppExpressionVisitor`1 {
    public abstract virtual Result Visit(ICppEmptyExpression expr);
    public abstract virtual Result Visit(ICppResolvedLiteralExpression expr);
    public abstract virtual Result Visit(ICppUserDefinedLiteralExpression expr);
    public abstract virtual Result Visit(ICppResolvedUserDefinedLiteralExpression expr);
    public abstract virtual Result Visit(ICppThisExpression expr);
    public abstract virtual Result Visit(ICppResolvedThisExpression expr);
    public abstract virtual Result Visit(ICppParenExpression expr);
    public abstract virtual Result Visit(ICppBinaryExpression expr);
    public abstract virtual Result Visit(ICppResolvedBinaryExpression expr);
    public abstract virtual Result Visit(ICppUnaryExpression expr);
    public abstract virtual Result Visit(ICppResolvedUnaryExpression expr);
    public abstract virtual Result Visit(ICppPostfixExpression expr);
    public abstract virtual Result Visit(ICppResolvedPostfixExpression expr);
    public abstract virtual Result Visit(ICppConditionalExpression expr);
    public abstract virtual Result Visit(ICppResolvedConditionalExpression expr);
    public abstract virtual Result Visit(ICppQualifiedReferenceExpression expr);
    public abstract virtual Result Visit(ICppResolvedQualifiedReferenceExpression expr);
    public abstract virtual Result Visit(ICppLinkageQualifiedReferenceExpression expr);
    public abstract virtual Result Visit(ICppMemberAccessExpression expr);
    public abstract virtual Result Visit(ICppResolvedMemberAccessExpression expr);
    public abstract virtual Result Visit(ICppNewExpression expr);
    public abstract virtual Result Visit(ICppResolvedNewExpression expr);
    public abstract virtual Result Visit(ICppDeleteExpression expr);
    public abstract virtual Result Visit(ICppSubscriptExpression expr);
    public abstract virtual Result Visit(ICppResolvedSubscriptExpression expr);
    public abstract virtual Result Visit(ICppCallExpression expr);
    public abstract virtual Result Visit(ICppResolvedCallExpression expr);
    public abstract virtual Result Visit(ICppCastExpression expr);
    public abstract virtual Result Visit(ICppResolvedCastExpression expr);
    public abstract virtual Result Visit(ICppSizeOfExpression expr);
    public abstract virtual Result Visit(ICppResolvedSizeOfExpression expr);
    public abstract virtual Result Visit(ICppSizeOfEllipsisExpression expr);
    public abstract virtual Result Visit(ICppResolvedSizeOfEllipsisExpression expr);
    public abstract virtual Result Visit(ICppAlignOfExpression expr);
    public abstract virtual Result Visit(ICppResolvedAlignOfExpression expr);
    public abstract virtual Result Visit(ICppTypeIdExpression expr);
    public abstract virtual Result Visit(ICppResolvedTypeIdExpression expr);
    public abstract virtual Result Visit(ICppNoExceptExpression expr);
    public abstract virtual Result Visit(ICppResolvedNoExceptExpression expr);
    public abstract virtual Result Visit(ICppSingleArgumentTypeTraitExpression expr);
    public abstract virtual Result Visit(ICppResolvedSingleArgumentTypeTraitExpression expr);
    public abstract virtual Result Visit(ICppDoubleArgumentTypeTraitExpression expr);
    public abstract virtual Result Visit(ICppResolvedDoubleArgumentTypeTraitExpression expr);
    public abstract virtual Result Visit(ICppMultiArgumentTypeTraitExpression expr);
    public abstract virtual Result Visit(ICppResolvedMultiArgumentTypeTraitExpression expr);
    public abstract virtual Result Visit(ICppMSUuidOfExpression expr);
    public abstract virtual Result Visit(ICppResolvedMSUuidOfExpression expr);
    public abstract virtual Result Visit(ICppMSEventHookExpression expr);
    public abstract virtual Result Visit(ICppResolvedMSEventHookExpression expr);
    public abstract virtual Result Visit(ICppMSNoopExpression expr);
    public abstract virtual Result Visit(ICppMSAssumeExpression expr);
    public abstract virtual Result Visit(ICppBuiltinAddressOfExpression expr);
    public abstract virtual Result Visit(ICppResolvedBuiltinAddressOfExpression expr);
    public abstract virtual Result Visit(ICppBuiltinOffsetOfExpression expr);
    public abstract virtual Result Visit(ICppResolvedBuiltinOffsetOfExpression expr);
    public abstract virtual Result Visit(ICppGnuBuiltinConstantPExpression expr);
    public abstract virtual Result Visit(ICppResolvedGnuBuiltinConstantPExpression expr);
    public abstract virtual Result Visit(ICppGNUAddressOfLabelExpression expr);
    public abstract virtual Result Visit(ICppResolvedGNUAddressOfLabelExpression expr);
    public abstract virtual Result Visit(ICppThrowExpression expr);
    public abstract virtual Result Visit(ICppBracedInitListExpression expr);
    public abstract virtual Result Visit(ICppResolvedBracedInitListExpression expr);
    public abstract virtual Result Visit(ICppBraceInitializedTemporaryExpression expr);
    public abstract virtual Result Visit(ICppResolvedBraceInitializedTemporaryExpression expr);
    public abstract virtual Result Visit(ICppLambdaExpression expr);
    public abstract virtual Result Visit(ICppReplacedLambdaExpression expr);
    public abstract virtual Result Visit(ICppGnuStatementExpression expr);
    public abstract virtual Result Visit(ICppReplacedGnuStatementExpression expr);
    public abstract virtual Result Visit(ICppRequiresExpression expr);
    public abstract virtual Result Visit(ICppCliMultiArgumentSubscriptExpression expr);
    public abstract virtual Result Visit(ICppResolvedCliMultiArgumentSubscriptExpression expr);
    public abstract virtual Result Visit(ICppCliTypeIdExpression expr);
    public abstract virtual Result Visit(ICppResolvedCliTypeIdExpression expr);
    public abstract virtual Result Visit(ICppPackExpansionExpression expr);
    public abstract virtual Result Visit(ICppResolvedPackExpansionExpression expr);
    public abstract virtual Result Visit(ICppFoldExpression expr);
    public abstract virtual Result Visit(ICppResolvedFoldExpression expr);
    public abstract virtual Result Visit(ICppCoAwaitExpression expr);
    public abstract virtual Result Visit(ICppResolvedCoAwaitExpression expr);
    public abstract virtual Result Visit(ICppCoYieldExpression expr);
    public abstract virtual Result Visit(ICppResolvedCoYieldExpression expr);
    public abstract virtual Result Visit(ICppC11GenericExpression expr);
    public abstract virtual Result Visit(ICppResolvedC11GenericExpression expr);
    public abstract virtual Result Visit(ICppDesignation expr);
    public abstract virtual Result Visit(ICppResolvedDesignation expr);
    public abstract virtual Result Visit(ICppReplacedRequiresExpression expr);
    public abstract virtual Result Visit(ICppLinkageRequiresExpression expr);
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppFloatingValue {
    public CppFloatingValueRepresentation Representation { get; }
    public CppFloatingValueKind FloatingKind { get; }
    public abstract virtual CppFloatingValueRepresentation get_Representation();
    public abstract virtual CppFloatingValueKind get_FloatingKind();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppFoldExpression {
    public abstract virtual ICppExpression GetLeftArgument();
    public abstract virtual ICppExpression GetRightArgument();
    public abstract virtual CppOperatorKind GetOperatorKind();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppGNUAddressOfLabelExpression {
    public abstract virtual string GetLabelName();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppGnuBuiltinConstantPExpression {
    [CanBeNullAttribute]
public abstract virtual ICppExpression GetArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppGnuStatementExpression {
    public abstract virtual CppCompoundStatementInExpressionSymbol GetStatementSymbol();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppIntegralValue {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppLambdaExpression {
    public abstract virtual CppLambdaSymbol GetLambdaSymbol();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppLinkageQualifiedReferenceExpression {
    public abstract virtual Status GetResolveStatus();
    public abstract virtual IEnumerable`1<ICppAnyLinkageEntityOrTemplateParameter> GetLinkageEntities();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppLinkageRequiresExpression {
    public abstract virtual IEnumerable`1<ICppParameterLinkageEntity> GetParameters();
    public abstract virtual CppList`1<ICppRequiresExpressionItem> GetItems();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppLiteralValue {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppLvalVisitor`1 {
    public abstract virtual TResult Visit(CppDeclaratorLvalue val);
    public abstract virtual TResult Visit(CppThisObjectLv val);
    public abstract virtual TResult Visit(CppObjectMemberLv val);
    public abstract virtual TResult Visit(CppDerefObjectLv val);
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppMemberAccessDesignator {
    public abstract virtual string GetName();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppMemberAccessExpression {
    public abstract virtual ICppExpression GetLeftArgument();
    public abstract virtual CppQualifiedName GetRightArgument();
    public abstract virtual CppMemberAccessType GetAccessType();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppMSAssumeExpression {
    [CanBeNullAttribute]
public abstract virtual ICppExpression GetArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppMSEventHookExpression {
    public abstract virtual bool IsUnhook();
    public abstract virtual ICppArgumentList GetArgumentList();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppMSNoopExpression {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppMSUuidOfExpression {
    public abstract virtual ICppTypeIdOrExpression GetArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppMultiArgumentTypeTraitExpression {
    public abstract virtual CppList`1<Element> GetArguments();
    public abstract virtual CppMultiArgumentTypeTraitKind GetKind();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppNewExpression {
    public abstract virtual CppQualType GetQualType();
    public abstract virtual bool IsCliGCNew();
    public abstract virtual bool IsFromGlobalNamespace();
    [CanBeNullAttribute]
public abstract virtual ICppArgumentList GetOperatorArgumentList();
    [CanBeNullAttribute]
public abstract virtual ICppArgumentList GetConstructorArgumentList();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppNoExceptExpression {
    public abstract virtual ICppExpression GetArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppObjectValue {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppPackExpansionExpression {
    public ICppExpression Pattern { get; }
    public abstract virtual ICppExpression get_Pattern();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppParenExpression {
    public abstract virtual ICppExpression GetInnerExpression();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppPointerValue {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppPostfixExpression {
    public abstract virtual ICppExpression GetArgument();
    public abstract virtual CppOperatorKind GetOperatorKind();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppPPSignedValue {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppPPUnsignedValue {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppPPValue {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppQualifiedReferenceExpression {
    public abstract virtual CppQualifiedName GetQualifiedName();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppQualTypeValueKindVisitor`1 {
    public abstract virtual TResult VisitSigned(CppSignedValueKind signedKind);
    public abstract virtual TResult VisitUnsigned(CppUnsignedValueKind unsignedKind);
    public abstract virtual TResult VisitFloating(CppFloatingValueKind floatingKind);
    public abstract virtual TResult VisitBool();
    public abstract virtual TResult VisitNullptr();
    public abstract virtual TResult VisitPointer();
    public abstract virtual TResult VisitArray();
    public abstract virtual TResult VisitObject(ICppClassResolveEntity clazz);
    public abstract virtual TResult VisitReference();
    public abstract virtual TResult VisitEnumerator(ICppClassResolveEntity enumeration);
    public abstract virtual TResult VisitVoid();
    public abstract virtual TResult VisitInvalid();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppReferenceValue {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppReplacedGnuStatementExpression {
    public abstract virtual CppCompoundStatementResolveEntity GetStatementResolveEntity();
    public abstract virtual ICppResolvedExpression GetResultExpression();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppReplacedLambdaExpression {
    public abstract virtual ICppClassResolveEntity GetClassResolveEntity();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppReplacedRequiresExpression {
    public abstract virtual ICppRequiresExpressionScopeResolveEntity GetScopeResolveEntity();
    public abstract virtual CppList`1<ICppRequiresExpressionItem> GetResolvedItems();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppRequiresExpression {
    public abstract virtual CppRequiresExpressionSymbol GetRequiresSymbol();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppRequiresExpressionItem {
    public abstract virtual Result Accept(ICppRequiresExpressionItemVisitor`1<Result> visitor);
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppRequiresExpressionItemCompound {
    public ICppExpression Expression { get; }
    public ICppExpression ReturnTypeConstraint { get; }
    public CppQualType ReturnType { get; }
    public bool NoExcept { get; }
    public abstract virtual ICppExpression get_Expression();
    public abstract virtual ICppExpression get_ReturnTypeConstraint();
    public abstract virtual CppQualType get_ReturnType();
    public abstract virtual bool get_NoExcept();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppRequiresExpressionItemNested {
    public ICppExpression Expression { get; }
    public abstract virtual ICppExpression get_Expression();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppRequiresExpressionItemSimple {
    public ICppExpression Expression { get; }
    public abstract virtual ICppExpression get_Expression();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppRequiresExpressionItemTypename {
    public CppQualType Type { get; }
    public abstract virtual CppQualType get_Type();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppRequiresExpressionItemVisitor`1 {
    public abstract virtual Result Visit(ICppRequiresExpressionItemTypename e);
    public abstract virtual Result Visit(ICppRequiresExpressionItemSimple e);
    public abstract virtual Result Visit(ICppRequiresExpressionItemNested e);
    public abstract virtual Result Visit(ICppRequiresExpressionItemCompound e);
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedAlignOfExpression {
    public abstract virtual CppViewPos GetViewPos();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedAnySubscriptExpression {
    public abstract virtual ICppResolvedExpression GetResolvedLeftArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedBinaryExpression {
    public abstract virtual ICppResolvedExpression GetResolvedLeftArgument();
    public abstract virtual ICppResolvedExpression GetResolvedRightArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedBracedInitListExpression {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedBraceInitializedTemporaryExpression {
    public abstract virtual ICppResolvedBracedInitListExpression GetResolvedArgumentList();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedBuiltinAddressOfExpression {
    [CanBeNullAttribute]
public abstract virtual ICppResolvedExpression GetResolvedArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedBuiltinOffsetOfExpression {
    public abstract virtual CppResolveResult GetResolvedMemberDesignator();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedC11GenericExpression {
    public abstract virtual ICppResolvedExpression GetResolvedControllingExpression();
    [CanBeNullAttribute]
public abstract virtual ICppResolvedExpression GetResolvedResultExpression();
    public abstract virtual CppViewPos GetViewPos();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedCallExpression {
    public abstract virtual CppCallExpressionKind GetExpressionKind();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedCastExpression {
    public abstract virtual ICppResolvedExpression GetResolvedArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedCliMultiArgumentSubscriptExpression {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedCliTypeIdExpression {
    public abstract virtual CppViewPos GetViewPos();
    public abstract virtual CppLookupResult GetLookupResult();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedCoAwaitExpression {
    public abstract virtual CppCoAwaitResolveResult GetResolveResult();
    public abstract virtual ICppResolvedExpression GetResolvedArgument();
    public abstract virtual CppViewPos GetViewPos();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedConditionalExpression {
    public abstract virtual CppViewPos GetViewPosForOverloading();
    public abstract virtual ICppResolvedExpression GetResolvedFirstArgument();
    public abstract virtual ICppResolvedExpression GetResolvedSecondArgument();
    public abstract virtual ICppResolvedExpression GetResolvedThirdArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedCoYieldExpression {
    public abstract virtual CppCoYieldResolveResult GetResolveResult();
    public abstract virtual ICppResolvedExpression GetResolvedArgument();
    public abstract virtual CppViewPos GetViewPos();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedDesignation {
    public abstract virtual ICppResolvedExpression GetResolvedInitializer();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedDoubleArgumentTypeTraitExpression {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedExpression {
    public abstract virtual CppDependentInfo GetDependentInfo();
    public abstract virtual TriBool IsNoexcept();
    public abstract virtual CppTypeContext TryGetTypeContext();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedFoldExpression {
    public ICppResolvedExpression Pattern { get; }
    public CppSubstitutionContext ExpansionClosure { get; }
    public abstract virtual ICppResolvedExpression get_Pattern();
    public abstract virtual CppSubstitutionContext get_ExpansionClosure();
    [NotNullAttribute]
public abstract virtual ICppResolvedExpression GetPackArgument();
    [CanBeNullAttribute]
public abstract virtual ICppResolvedExpression GetInitArgument();
    public abstract virtual bool IsLeftFold();
    public abstract virtual CppOperatorKind GetOperatorKind();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedGNUAddressOfLabelExpression {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedGnuBuiltinConstantPExpression {
    [CanBeNullAttribute]
public abstract virtual ICppResolvedExpression GetResolvedArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedLiteralExpression {
    [CanBeNullAttribute]
public abstract virtual ICppLiteralValue GetValue();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedMemberAccessExpression {
    public abstract virtual CppResolveResult GetLookupScopeResolveResult();
    public abstract virtual CppViewPos GetViewPos();
    public abstract virtual ICppResolvedExpression GetResolvedLeftArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedMSEventHookExpression {
    public abstract virtual CppViewPos GetViewPos();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedMSUuidOfExpression {
    public abstract virtual CppViewPos GetViewPos();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedMultiArgumentTypeTraitExpression {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedNewExpression {
    public abstract virtual CppNewExpressionResolveResult GetResolvedOperator();
    public abstract virtual CppViewPos GetViewPos();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedNoExceptExpression {
    public abstract virtual ICppResolvedExpression GetResolvedArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedOperatorCallExpression {
    public abstract virtual CppResolveResult GetResolvedOperator();
    public abstract virtual CppViewPos GetViewPos();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedPackExpansionExpression {
    public abstract virtual ICppResolvedExpression GetResolvedPattern();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedPostfixExpression {
    public abstract virtual ICppResolvedExpression GetResolvedArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedQualifiedReferenceExpression {
    public abstract virtual CppQualifiedName GetResolvedNameHint();
    public abstract virtual CppViewPos GetViewPos();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedSingleArgumentTypeTraitExpression {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedSizeOfEllipsisExpression {
    public abstract virtual CppViewPos GetViewPos();
    public abstract virtual CppResolveResult GetResolvedArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedSizeOfExpression {
    public abstract virtual CppViewPos GetViewPos();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedSubscriptDesignator {
    public abstract virtual ICppResolvedExpression GetResolvedIndex();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedSubscriptExpression {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedThisExpression {
    public abstract virtual CppQualType GetThisObjectType();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedTypeIdExpression {
    public abstract virtual CppViewPos GetViewPos();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedUnaryExpression {
    public abstract virtual ICppResolvedExpression GetResolvedArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppResolvedUserDefinedLiteralExpression {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppSignedIntegralValue {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppSignedIntegralValueBase {
    public CppSignedValueRepresentation Representation { get; }
    public CppSignedValueKind SignedKind { get; }
    public abstract virtual CppSignedValueRepresentation get_Representation();
    public abstract virtual CppSignedValueKind get_SignedKind();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppSingleArgumentTypeTraitExpression {
    public abstract virtual CppQualType GetArgument();
    public abstract virtual CppSingleArgumentTypeTraitKind GetKind();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppSizeOfEllipsisExpression {
    public abstract virtual CppQualifiedName GetArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppSizeOfExpression {
    public abstract virtual ICppTypeIdOrExpression GetArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppSubscriptDesignator {
    public abstract virtual ICppExpression GetIndex();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppSubscriptExpression {
    public abstract virtual CppSmallArray`1<ICppExpression> GetIndexArguments();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppThisExpression {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppThrowExpression {
    [CanBeNullAttribute]
public abstract virtual ICppExpression GetArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppTypeId {
    public abstract virtual CppQualType GetQualType();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppTypeIdExpression {
    public abstract virtual ICppTypeIdOrExpression GetArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppTypeIdOrExpression {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppUnaryExpression {
    public abstract virtual ICppExpression GetArgument();
    public abstract virtual CppOperatorKind GetOperatorKind();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppUnsignedIntegralValue {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppUnsignedIntegralValueBase {
    public CppUnsignedValueRepresentation Representation { get; }
    public CppUnsignedValueKind UnsignedKind { get; }
    public abstract virtual CppUnsignedValueRepresentation get_Representation();
    public abstract virtual CppUnsignedValueKind get_UnsignedKind();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppUserDefinedLiteralExpression {
    public abstract virtual ICppUserDefinedLiteralValue GetLiteralValue();
    public abstract virtual string GetSuffix();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppUserDefinedLiteralValue {
    public abstract virtual CppUserDefinedLiteralValueKind GetKind(CppLanguageDialect dialect);
    public abstract virtual string Present(string withSuffix, ICppPresenter _);
    public abstract virtual string GetRawText();
    [CanBeNullAttribute]
public abstract virtual ICppExpression[] CreateFunctionArguments(CppLanguageDialect dialect);
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppValue {
    public abstract virtual Result Accept(ICppValueVisitor`1<Result> visitor);
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppValueExpression {
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppValueRepresentation`1 {
    public T RawRepresentation { get; }
    public abstract virtual T get_RawRepresentation();
}
public interface JetBrains.ReSharper.Psi.Cpp.Expressions.ICppValueVisitor`1 {
    public abstract virtual Result Visit(ICppSignedIntegralValue value);
    public abstract virtual Result Visit(ICppUnsignedIntegralValue value);
    public abstract virtual Result Visit(CppBoolValue value);
    public abstract virtual Result Visit(ICppFloatingValue value);
    public abstract virtual Result Visit(CppNullptrValue value);
    public abstract virtual Result Visit(CppStringLiteralValue value);
    public abstract virtual Result Visit(CppPointerValue value);
    public abstract virtual Result Visit(CppReferenceValue value);
    public abstract virtual Result Visit(CppArrayValue value);
    public abstract virtual Result Visit(CppBracedInitListValue value);
    public abstract virtual Result Visit(CppObjectValue value);
    public abstract virtual Result Visit(CppEnumValue value);
    public abstract virtual Result Visit(CppDesignationValue value);
    public abstract virtual Result Visit(CppFunctionOverloadSetValue value);
    public abstract virtual Result Visit(CppVoidValue value);
    public abstract virtual Result VisitUnknown(ICppValue value);
}
public interface JetBrains.ReSharper.Psi.Cpp.ICheckableInvariantHolder {
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Lang.CppClionResolveEmulator : ValueType {
    private ICppFileResolveEntitiesCache myFileCache;
    private CppTypeContext myTypeContext;
    public CppClionResolveEmulator(ICppCompositeNode node);
    public CppClionResolveEmulator(ICppFileResolveEntitiesCache resolveCache, CppTypeContext& tc);
    [CanBeNullAttribute]
public IEnumerable`1<ICppResolveEntity> ResolveMemberAccessMember(ICppResolvedMemberAccessExpression memAccess);
    public IEnumerable`1<ICppResolveEntity> ResolveUnaryExpression(UnaryExpression unaryExpression);
    public IEnumerable`1<ICppResolveEntity> ResolveBinaryExpression(BinaryExpression binaryExpression);
    private CppSmallList`1<CppTypeAndCategory> TypeOf(ICppExpressionNode expr);
    public CppExpressionInfo TryGetExpressionWithKilledDeps(ICppResolvedExpression expr);
    public static CppSmallList`1<CppTypeAndCategory> GetClionTypeOf(ICppExpressionNode expr, CppTypeContext& tc, ICppFileResolveEntitiesCache cache);
    public static Nullable`1<CppScopeDepKillingResult> FillSubstitutionContext(ICppGroupedFunctionDeclaratorResolveEntity func, CppTypeContext& tc, ICppScopeResolveEntity depKillerScope);
    public static bool CanKillDependenciesInLambda(LambdaExpression lambda);
    [CanBeNullAttribute]
public static CppSubstitutionDriver GetSubstitutionContextForDependenciesKiller(CppTypeContext& tc);
    [CanBeNullAttribute]
public static ICppValueExpression MakeDepKillerValue(ICppExpressionTemplateParameterOrPack etp, CppTypeContext& tc);
    [CanBeNullAttribute]
private IEnumerable`1<ICppResolveEntity> TryResolveUsingExpressionSubstitution(TExpression expr);
    private static CppTypeAndCategory GetTypeWithKilledDependencies(ICppResolvedExpression expr, CppTypeContext& tc);
    private static bool IsClionResolvable(CppQualType type);
    private static CppQualType GetMemberAccessLookupScopeType(CppTypeContext& typeContext, ICppFileResolveEntitiesCache cache, CppTypeAndCategory scope, CppMemberAccessType accessType);
    private static void ResolveMemberAccessMemberForScope(CppTypeContext& typeContext, ICppFileResolveEntitiesCache cache, CppTypeAndCategory scope, CppMemberAccessType accessType, CppQualifiedName memberName, ISet`1<ICppResolveEntity> result);
    private static bool HasFewUngroupedDeclaratorsWithBody(CppGroupedFunctionDeclaratorResolveEntity grouped);
    [CanBeNullAttribute]
private static ICppTemplateArgument GetParameterSubstitutionFromScope(ICppTemplateParameter param, ICppScopeResolveEntity depKillerScope, CppViewPos& vp);
    [CanBeNullAttribute]
private static ICppScopeResolveEntity FindScopeForDependencyKiller(ICppScopeResolveEntity scope);
    private static bool CreateSubstitutionForParameters(CppTemplateId tid, ICppTemplateArgument[] defaults, CppTypeContext& tc, CppSubstitutionContext subst, ICppScopeResolveEntity depKillerScope);
    private static ICppGroupedFunctionDeclaratorResolveEntity TryFindGenericLambdaInstantiation(ICppFunctionTemplateDeclaratorResolveEntity funcTemplate, CppSubstitutionContext subst, ICppScopeResolveEntity depKillerScope, CppTypeContext& tc);
    private static ICppGroupedFunctionDeclaratorResolveEntity InstantiateFunction(ICppGroupedFunctionDeclaratorResolveEntity func, CppTypeContext& tc, CppSubstitutionContext subst, ICppScopeResolveEntity depKillerScope);
    [CanBeNullAttribute]
private static ICppFunctionDeclaratorResolveEntity GetEnclosingFunction(ICppStatementResolveEntity statement);
    private static bool InstantiateEnclosingFunction(ICppStatementResolveEntity statement, CppTypeContext& tc, CppSubstitutionContext subst, ICppScopeResolveEntity depKillerScope);
    private static bool InstantiateClasses(ICppScopeResolveEntity ent, CppTypeContext& tc, CppSubstitutionContext subst, ICppScopeResolveEntity depKillerScope);
    [CompilerGeneratedAttribute]
internal static bool <GetClionTypeOf>g__InsideLambdaWhichCannotBeProcessed|9_0(ICppExpressionNode expr);
    [CompilerGeneratedAttribute]
internal static bool <TryFindGenericLambdaInstantiation>g__AreEqualUnqualifiedTypeArgs|26_1(ICppTemplateArgument x, ICppTemplateArgument y);
    [CompilerGeneratedAttribute]
internal static ICppGroupedFunctionDeclaratorResolveEntity <TryFindGenericLambdaInstantiation>g__ExtractTemplateArguments|26_0(ICppSubstitutionContext lambdaSubstitution, ICppGroupedFunctionDeclaratorResolveEntity spec, CppTemplateId templateName, CppSubstitutionContext subst, ICppScopeResolveEntity depKillerScope, CppTypeContext& tc);
}
public class JetBrains.ReSharper.Psi.Cpp.Lang.CppDeclarationPsiPresentationBuilder : ValueType {
    private CppElementFactory myElementFactory;
    [CanBeNullAttribute]
private CppLanguageDialect myDialect;
    private NestedDeclarator myDeclarator;
    private DeclarationSpecifiers myDeclSpecs;
    public CppDeclarationPsiPresentationBuilder(CppElementFactory ef, CppLanguageDialect dialect);
    public sealed virtual void Parenthesize();
    public sealed virtual void PrependCallingConvention(CppCallingConvention cc, bool wasPointer, bool wasMember);
    public sealed virtual void PrependToken(CppTokenNodeType tt);
    public sealed virtual void PrependCVQualifiers(CVQualifiers cv);
    public sealed virtual void PrependMemberPointerNameQualifier(Declaration type);
    public sealed virtual void PrependSpace();
    public sealed virtual void AppendArraySize(ICppExpressionNode arraySize);
    public sealed virtual void PrependGnuAttribute(string attrName, ICppExpressionNode argument);
    public sealed virtual void AppendFunctionParameters(IList`1<Declaration> parameters, CppEllipsisKind ellipsisKind, bool explicitThis, bool isTopLevelType, Qualifiers quals, CppRestrictionSpecifiers restrictSpecs, ITreeNode exceptionSpecification, TypeId trailingReturnType);
    public sealed virtual void AddPackExpansion();
    public sealed virtual void LearnDeclarationSpecifiers(ITreeNode type, CVQualifiers cvQuals, CppDeclSpecPlacement cvPlacement, CppClassTag clsTag, Signing signed, int shortLong);
    public sealed virtual void LearnInputQualifiers(InputQualifiers qualifiers);
    private static void AddDeclSpecNodeIfConditionHolds(bool cond, ITreeNode parent, ITreeNode& leftAnchor, ITreeNode child);
    public sealed virtual Declaration Finish(InputQualifiers qualifiers, bool putSpaceAfterPtrInDataMember, string declaratorNameForMarking, bool seenFunctionType, bool wasParenthesized);
}
public class JetBrains.ReSharper.Psi.Cpp.Lang.CppEqualityComparer : CppHashCodeExpressionVisitor {
    public static CppEqualityComparer Structural;
    public static CppEqualityComparer Semantical;
    public static CppEqualityComparer SemanticalIgnoringMagicType;
    protected HashCodeWithEqualityComparerVisitor myTypeHashCodeVisitor;
    protected bool ShouldCheckHashCodesForTypes { get; }
    public bool ShouldDropDecorations { get; }
    private static CppEqualityComparer();
    protected virtual bool get_ShouldCheckHashCodesForTypes();
    public virtual bool TypesAreEqual(CppQualType lhs, CppQualType rhs);
    public virtual bool TypesAreEqual(CppTypeAndCategory lhs, CppTypeAndCategory rhs);
    public virtual bool ExpressionsAreEqual(ICppExpression lhs, ICppExpression rhs);
    public virtual bool ArgumentListsAreEqual(ICppArgumentList lhs, ICppArgumentList rhs);
    public virtual bool ArgumentListsAreEqual(ICppExpression[] lArgs, ICppExpression[] rArgs);
    public virtual bool ResolveEntitiesAreEqual(ICppResolveEntity lhs, ICppResolveEntity rhs);
    public virtual bool LinkageEntitiesAreEqual(ICppLinkageEntity lhs, ICppLinkageEntity rhs);
    public virtual bool LinkageEntitiesAreEqual(ICppDependentLinkageEntity lhs, ICppDependentLinkageEntity rhs);
    public virtual bool SymbolsAreEqual(ICppSymbol lhs, ICppSymbol rhs);
    public virtual bool NamesAreEqual(CppQualifiedNamePart lhs, CppQualifiedNamePart rhs);
    public virtual bool QualifiedNamesAreEqual(CppQualifiedName lhs, CppQualifiedName rhs);
    public virtual bool UnknownInfosAreEqual(CppUnknownEntityInfo lhs, CppUnknownEntityInfo rhs);
    public virtual bool TemplateArgumentListsAreEqual(ICppTemplateArgument[] lhs, ICppTemplateArgument[] rhs);
    public virtual bool TemplateArgumentsAreEqual(ICppTemplateArgument lhs, ICppTemplateArgument rhs);
    public sealed virtual bool InitializersAreEqual(CppDeclaratorInitializer lhs, CppDeclaratorInitializer rhs);
    public virtual bool GenericConstraintsAreEqual(ICppGenericConstraint lhs, ICppGenericConstraint rhs);
    public virtual bool ParameterDeclaratorsAreEqual(CppParameterDeclaratorsData lhs, CppParameterDeclaratorsData rhs);
    public virtual bool AttributeListsAreEqual(CppAttributeList lhs, CppAttributeList rhs);
    public virtual bool AttributesAreEqual(ICppAttribute lhs, ICppAttribute rhs);
    public virtual bool TypesAreEqualIgnoringFunctionReturnType(CppQualType lhs, CppQualType rhs);
    public virtual int GetTemplateArgumentHashCode(ICppTemplateArgument arg);
    public virtual int GetQualTypeHashCode(CppQualType type);
    public virtual int GetResolveEntityHashCode(ICppResolveEntity ent);
    public virtual bool get_ShouldDropDecorations();
    public virtual bool ReApply(ICppSymbol lhs, ICppSymbol rhs);
    public virtual bool ReApply(ICppNoExceptSpecification lhs, ICppNoExceptSpecification rhs);
    public bool ValuesAreEqual(ICppValue lhs, ICppValue rhs);
    public bool EvalResultsAreEqual(ICppEvaluationResult lhs, ICppEvaluationResult rhs);
    public virtual bool ReApply(CppQualType lhs, CppQualType rhs);
    public virtual bool ReApply(ICppResolveEntity lhs, ICppResolveEntity rhs);
    public virtual bool ReApply(CppSymbolLocation lhs, CppSymbolLocation rhs);
    public virtual bool ReApply(CppTemplateTemplateArgument lhs, CppTemplateTemplateArgument rhs);
    public virtual bool ReApply(CppLookupFailureTemplateArgument lhs, CppLookupFailureTemplateArgument rhs);
    public virtual int ReApplyHashCode(ICppResolveEntity ent);
    public bool ReApply(ICppExpression lhs, ICppExpression rhs, CppEqualsExpressionVisitor vis);
    public bool ReApply(ICppTypeIdOrExpression lhs, ICppTypeIdOrExpression rhs, CppEqualsExpressionVisitor vis);
    public bool ReApply(CppUnknownEntityInfo lhs, CppUnknownEntityInfo rhs, CppEqualsUnknownInfoVisitor vis);
    public bool ReApply(CppQualifiedNamePart lhs, CppQualifiedNamePart rhs);
    private bool ReApply(ICppLinkageEntity lhs, ICppLinkageEntity rhs);
    private bool ReApply(ICppExpression[] left, ICppExpression[] right, CppEqualsExpressionVisitor vis);
}
public class JetBrains.ReSharper.Psi.Cpp.Lang.CppEqualsExpressionVisitor : object {
    private CppEqualityComparer myEngine;
    [CompilerGeneratedAttribute]
private ICppExpression <RightHandSide>k__BackingField;
    public ICppExpression RightHandSide { get; public set; }
    public CppEqualsExpressionVisitor(CppEqualityComparer engine, ICppExpression rhs);
    [CompilerGeneratedAttribute]
public ICppExpression get_RightHandSide();
    [CompilerGeneratedAttribute]
public void set_RightHandSide(ICppExpression value);
    public sealed virtual bool Visit(ICppEmptyExpression expr);
    public sealed virtual bool Visit(ICppResolvedLiteralExpression expr);
    public sealed virtual bool Visit(ICppUserDefinedLiteralExpression expr);
    public sealed virtual bool Visit(ICppResolvedUserDefinedLiteralExpression expr);
    public sealed virtual bool Visit(ICppThisExpression expr);
    public sealed virtual bool Visit(ICppResolvedThisExpression expr);
    public sealed virtual bool Visit(ICppParenExpression expr);
    public sealed virtual bool Visit(ICppBinaryExpression expr);
    public sealed virtual bool Visit(ICppResolvedBinaryExpression expr);
    public sealed virtual bool Visit(ICppUnaryExpression expr);
    public sealed virtual bool Visit(ICppResolvedUnaryExpression expr);
    public sealed virtual bool Visit(ICppPostfixExpression expr);
    public sealed virtual bool Visit(ICppResolvedPostfixExpression expr);
    public sealed virtual bool Visit(ICppConditionalExpression expr);
    public sealed virtual bool Visit(ICppResolvedConditionalExpression expr);
    public sealed virtual bool Visit(ICppQualifiedReferenceExpression expr);
    public sealed virtual bool Visit(ICppResolvedQualifiedReferenceExpression expr);
    public sealed virtual bool Visit(ICppLinkageQualifiedReferenceExpression expr);
    public sealed virtual bool Visit(ICppMemberAccessExpression expr);
    public sealed virtual bool Visit(ICppResolvedMemberAccessExpression expr);
    public sealed virtual bool Visit(ICppNewExpression expr);
    public sealed virtual bool Visit(ICppResolvedNewExpression expr);
    public sealed virtual bool Visit(ICppDeleteExpression expr);
    public sealed virtual bool Visit(ICppSubscriptExpression expr);
    public sealed virtual bool Visit(ICppResolvedSubscriptExpression expr);
    public sealed virtual bool Visit(ICppCallExpression expr);
    public sealed virtual bool Visit(ICppResolvedCallExpression expr);
    private bool HasDifferentCandidates(FrugalLocalList`1<ICppResolveEntity> a, FrugalLocalList`1<ICppResolveEntity> b);
    private bool HasUniqueCandidate(FrugalLocalList`1<ICppResolveEntity> a, FrugalLocalList`1<ICppResolveEntity> b);
    private bool CandidatesContains(FrugalLocalList`1<ICppResolveEntity> list, ICppResolveEntity candidate);
    public sealed virtual bool Visit(ICppCastExpression expr);
    public sealed virtual bool Visit(ICppResolvedCastExpression expr);
    public sealed virtual bool Visit(ICppSizeOfExpression expr);
    public sealed virtual bool Visit(ICppSizeOfEllipsisExpression expr);
    public sealed virtual bool Visit(ICppResolvedSizeOfExpression expr);
    public sealed virtual bool Visit(ICppResolvedSizeOfEllipsisExpression expr);
    public sealed virtual bool Visit(ICppAlignOfExpression expr);
    public sealed virtual bool Visit(ICppResolvedAlignOfExpression expr);
    public sealed virtual bool Visit(ICppTypeIdExpression expr);
    public sealed virtual bool Visit(ICppResolvedTypeIdExpression expr);
    public sealed virtual bool Visit(ICppNoExceptExpression expr);
    public sealed virtual bool Visit(ICppResolvedNoExceptExpression expr);
    public sealed virtual bool Visit(ICppSingleArgumentTypeTraitExpression expr);
    public sealed virtual bool Visit(ICppResolvedSingleArgumentTypeTraitExpression expr);
    public sealed virtual bool Visit(ICppDoubleArgumentTypeTraitExpression expr);
    public sealed virtual bool Visit(ICppResolvedDoubleArgumentTypeTraitExpression expr);
    public sealed virtual bool Visit(ICppMultiArgumentTypeTraitExpression expr);
    public sealed virtual bool Visit(ICppResolvedMultiArgumentTypeTraitExpression expr);
    public sealed virtual bool Visit(ICppMSUuidOfExpression expr);
    public sealed virtual bool Visit(ICppResolvedMSUuidOfExpression expr);
    public sealed virtual bool Visit(ICppMSEventHookExpression expr);
    public sealed virtual bool Visit(ICppResolvedMSEventHookExpression expr);
    public sealed virtual bool Visit(ICppMSNoopExpression expr);
    public sealed virtual bool Visit(ICppMSAssumeExpression expr);
    public sealed virtual bool Visit(ICppBuiltinAddressOfExpression expr);
    public sealed virtual bool Visit(ICppResolvedBuiltinAddressOfExpression expr);
    public sealed virtual bool Visit(ICppBuiltinOffsetOfExpression expr);
    public sealed virtual bool Visit(ICppResolvedBuiltinOffsetOfExpression expr);
    public sealed virtual bool Visit(ICppGnuBuiltinConstantPExpression expr);
    public sealed virtual bool Visit(ICppResolvedGnuBuiltinConstantPExpression expr);
    public sealed virtual bool Visit(ICppGNUAddressOfLabelExpression expr);
    public sealed virtual bool Visit(ICppResolvedGNUAddressOfLabelExpression expr);
    public sealed virtual bool Visit(ICppThrowExpression expr);
    public sealed virtual bool Visit(ICppBracedInitListExpression expr);
    public sealed virtual bool Visit(ICppResolvedBracedInitListExpression expr);
    public sealed virtual bool Visit(ICppBraceInitializedTemporaryExpression expr);
    public sealed virtual bool Visit(ICppResolvedBraceInitializedTemporaryExpression expr);
    public sealed virtual bool Visit(ICppLambdaExpression expr);
    public sealed virtual bool Visit(ICppReplacedLambdaExpression expr);
    public sealed virtual bool Visit(ICppGnuStatementExpression expr);
    public sealed virtual bool Visit(ICppReplacedGnuStatementExpression expr);
    public sealed virtual bool Visit(ICppRequiresExpression expr);
    public sealed virtual bool Visit(ICppReplacedRequiresExpression expr);
    public sealed virtual bool Visit(ICppLinkageRequiresExpression expr);
    public sealed virtual bool Visit(ICppCliMultiArgumentSubscriptExpression expr);
    public sealed virtual bool Visit(ICppResolvedCliMultiArgumentSubscriptExpression expr);
    public sealed virtual bool Visit(ICppCliTypeIdExpression expr);
    public sealed virtual bool Visit(ICppResolvedCliTypeIdExpression expr);
    public sealed virtual bool Visit(ICppPackExpansionExpression expr);
    public sealed virtual bool Visit(ICppResolvedPackExpansionExpression expr);
    public sealed virtual bool Visit(ICppFoldExpression expr);
    public sealed virtual bool Visit(ICppResolvedFoldExpression expr);
    public sealed virtual bool Visit(ICppCoAwaitExpression expr);
    public sealed virtual bool Visit(ICppResolvedCoAwaitExpression expr);
    public sealed virtual bool Visit(ICppCoYieldExpression expr);
    public sealed virtual bool Visit(ICppResolvedCoYieldExpression expr);
    public sealed virtual bool Visit(ICppDesignation expr);
    public sealed virtual bool Visit(ICppResolvedDesignation expr);
    public sealed virtual bool Visit(ICppC11GenericExpression expr);
    public sealed virtual bool Visit(ICppResolvedC11GenericExpression expr);
    private static CppQualType GetTypeForTypeNode(ICppTypeIdOrExpression typeNode);
    private static bool MultiArgumentTypeTraitExpressionsEqual(ICppMultiArgumentTypeTraitExpression lhs, ICppMultiArgumentTypeTraitExpression rhs, CppEqualityComparer engine);
    public bool ArgumentListsAreEqual(ICppArgumentList lhs, ICppArgumentList rhs);
    private bool ReApply(ICppExpression expr, ICppExpression newRhs);
    private bool ReApply(ICppTypeIdOrExpression lhs, ICppTypeIdOrExpression rhs);
    private bool LookupResultsAreEqual(CppLookupResult lhs, CppLookupResult rhs);
    private bool ResolveResultsAreEqual(CppResolveResult& lhs, CppResolveResult& rhs);
    private bool ResolveResultsAreEqual(CppNewExpressionResolveResult lhs, CppNewExpressionResolveResult rhs);
    private bool ReApply(ICppDesignator a, ICppDesignator b);
}
public class JetBrains.ReSharper.Psi.Cpp.Lang.CppEqualsNamePartVisitor : object {
    public static CppEqualsNamePartVisitor Instance;
    private static CppEqualsNamePartVisitor();
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppQualifiedId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppDestructorTag name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppOperatorId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppConversionId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppUserDefinedLiteralId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppAnonymousId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppDecltypeDestructorTag name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppDecltypeId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppTypeOfTypeId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppGlobalNamespaceId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppMSSuperId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppLambdaId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppConversionsPackId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppTemplateId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppSubstitutionId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppAnonymousLinkageId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppLinkageTemplateId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppResolvedStructuredBindingId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppUnresolvedStructuredBindingId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppCliSimpleTypeId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppCliFinalizerTag name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppModuleTemplateId name);
    public sealed virtual bool Visit(KeyValuePair`2<CppEqualityComparer, CppQualifiedNamePart> data, CppModuleSubstitutionId name);
}
public class JetBrains.ReSharper.Psi.Cpp.Lang.CppGetDependenciesConsumerWrapper : object {
    private ICppGetDependenciesConsumer myInner;
    public CppGetDependenciesConsumerWrapper(ICppGetDependenciesConsumer inner);
    public virtual bool ShouldVisitPackExpansions();
    public virtual bool ShouldVisitNonDeducedContext();
    public virtual bool ShouldVisitTemplateParents();
    public virtual bool ShouldVisitInnerTypeOfAlias();
    public sealed virtual bool ShouldVisitTemplateId();
    public virtual void AddTemplateParam(ICppTemplateParameter tag);
    public virtual void AddFunctionParam(ICppVariableDeclaratorResolveEntity param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Lang.CppGetDependenciesUtil : object {
    [ExtensionAttribute]
public static void GetTemplateArgumentDependencies(ICppTemplateArgument arg, ICppGetDependenciesConsumer consumer);
    [ExtensionAttribute]
public static void GetTemplateArgumentsDependencies(ICppTemplateArgument[] args, ICollection`1<CppParameter> output);
    [ExtensionAttribute]
public static void GetTypeDependencies(CppQualType type, ICppGetDependenciesConsumer consumer);
    [ExtensionAttribute]
public static void GetTypeDependencies(CppQualType type, ICollection`1<CppTemplateParameterTag> output);
    [ExtensionAttribute]
public static void GetTypeDependenciesForAssert(CppQualType type, ICollection`1<CppTemplateParameterTag> output);
    [ExtensionAttribute]
public static void GetUnexpandedPackDependencies(CppQualType qualType, ICollection`1<ICppTemplateParameterPack> output);
    [ExtensionAttribute]
public static void GetUnexpandedPackDependencies(ICppExpression expr, ICollection`1<ICppTemplateParameterPack> output);
    [ExtensionAttribute]
public static void GetUnexpandedPackDependencies(ICppTypeIdOrExpression e, ICollection`1<ICppTemplateParameterPack> output);
    [ExtensionAttribute]
public static void GetUnexpandedPackDependencies(ICppTemplateArgument arg, ICollection`1<ICppTemplateParameterPack> output);
    [ExtensionAttribute]
public static void GetUnexpandedPackDependencies(UsingDeclarationTargets args, ICollection`1<ICppTemplateParameterPack> output);
    [ExtensionAttribute]
public static void GetUnexpandedPackDependencies(CppCtorInitializerStatementResolveEntityBase ctorInit, ICollection`1<ICppTemplateParameterPack> output);
    [ExtensionAttribute]
public static bool IsDependentOnTagsForDeduction(CppQualType type, HashSet`1<CppTemplateParameterTag> tags);
    [ExtensionAttribute]
public static void GetTagsOfTemplateDeps(IEnumerable`1<CppParameter> deps, ICollection`1<CppTemplateParameterTag> output);
    [ExtensionAttribute]
public static void GetExpressionDependencies(ICppExpression expr, ICollection`1<CppTemplateParameterTag> output, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static void GetExpressionDependencies(ICppExpression expr, ICppGetDependenciesConsumer consumer);
    [ExtensionAttribute]
public static HashSet`1<CppParameter> GetExpressionDependencies(ICppExpression expr);
    [ExtensionAttribute]
public static HashSet`1<CppParameter> GetTypeDependencies(CppQualType type);
    private static bool ShouldVisitArraySizeOrNonTypeTemplateArgument(ICppExpression expr, ICppGetDependenciesConsumer consumer);
    private static void GetNamePartDependencies(CppQualifiedNamePart namePart, ICppGetDependenciesConsumer output);
    private static void GetQualifiedNameDependencies(CppQualifiedName name, ICppGetDependenciesConsumer output);
    private static void AddParametersFromParents(ICppResolveEntity t, ICppGetDependenciesConsumer output);
    private static void GetResolveEntityDependencies(ICppResolveEntity ent, ICppGetDependenciesConsumer consumer);
    private static void GetTemplateArgumentsDependencies(ICppTemplateArgument[] args, ICppGetDependenciesConsumer consumer);
    private static void GetUsingDeclarationTargetsDependencies(UsingDeclarationTargets args, ICppGetDependenciesConsumer consumer);
}
[ShellComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Cpp.Lang.CppHighlighterColorCache : HighlighterFontsAndColorsCache {
    public CppHighlighterColorCache(IHighlighterCustomization highlighterCustomization, ITheming theming, IThreading threading, ITextControlSchemeManager textControlSchemeManager, Lifetime lifetime);
    public JetRgbaColor GetColor(string highlighting);
    public TextStyle TextStyleForHighlightingId(string highlighting);
    public TextStyle TextStyleForKeyword();
    private static List`1<string> CppHighlightings();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Lang.CppParameter : ValueType {
    private ICppResolveEntity myParam;
    private CppParameter(ICppResolveEntity param);
    public static CppParameter CreateFromTemplateParam(ICppTemplateParameter param);
    public static CppParameter CreateFromFunctionParam(ICppVariableDeclaratorResolveEntity param);
    public ICppTemplateParameter AsTemplateParameter();
    public ICppVariableDeclaratorResolveEntity AsFunctionParameter();
    public sealed virtual bool Equals(CppParameter other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Lang.CppPsiPresenter : CppTypePresenterBase {
    [CompilerGeneratedAttribute]
private CppElementFactory <ElementFactory>k__BackingField;
    public CppElementFactory ElementFactory { get; }
    public CppPsiPresenter(CppElementFactory ef, CppPresentationParameters params, CppPresentationContext& context, Nullable`1& paramsContext);
    public static CppPsiPresenter Create(CppElementFactory ef, CppPresentationParameters params, CppPresentationContext& context, Nullable`1& paramsContext);
    public static CppPsiPresenter CreateFromPsiWithViewPos(ITreeNode node);
    public sealed virtual CppDeclarationPsiPresentationBuilder CreatePresentedDeclarationBuilder(int markingOffset, DeclaredElementPresenterMarking marking);
    public sealed virtual TypeId ConvertPresentedDeclarationToTypeId(Declaration declarator);
    public sealed virtual Declaration AddNameToPresentedDeclaration(Declaration declarator, string name);
    public sealed virtual Declaration AddNameAndEqInitializerToPresentedDeclaration(Declaration declarator, string name, ICppExpressionNode initializer);
    public sealed virtual ITreeNode CreatePresentedDeclarationSpecifierTypename(string presentedName, CppClassTag tag, bool wantsTypename);
    public sealed virtual ITreeNode CreatePresentedErrorType(string errorTypeText);
    public sealed virtual ITreeNode CreatePresentedExceptionSpecification(ICppExceptionSpecification exceptionSpecification);
    public sealed virtual ICppExpressionNode CreatePresentedExpressionFromString(string exprPresentation);
    public sealed virtual ITreeNode PresentUnresolvedType(string typeName);
    public virtual ICppPresenter GetTextPresenter();
    [CompilerGeneratedAttribute]
public CppElementFactory get_ElementFactory();
}
public class JetBrains.ReSharper.Psi.Cpp.Lang.CppQualifiedNameSymbolEqualityComparerEngine : CppEqualityComparer {
    public static CppQualifiedNameSymbolEqualityComparerEngine Instance;
    private static CppQualifiedNameSymbolEqualityComparerEngine();
    public virtual bool ReApply(ICppSymbol lhs, ICppSymbol rhs);
    public virtual bool ReApply(CppSymbolLocation lhs, CppSymbolLocation rhs);
    public virtual bool TypesAreEqual(CppQualType lhs, CppQualType rhs);
}
public class JetBrains.ReSharper.Psi.Cpp.Lang.CppSemanticalEqualityComparer : CppEqualityComparer {
    public bool ShouldDropDecorations { get; }
    public virtual bool get_ShouldDropDecorations();
    public virtual bool ReApply(ICppResolveEntity lhs, ICppResolveEntity rhs);
    protected virtual bool ReApplyToHeadOfDependentEntities(ICppDependentScopeLikeResolveEntity lhs, ICppDependentScopeLikeResolveEntity rhs);
    public virtual bool ReApply(CppTemplateTemplateArgument lhs, CppTemplateTemplateArgument rhs);
    public virtual bool ReApply(CppLookupFailureTemplateArgument lhs, CppLookupFailureTemplateArgument rhs);
    public virtual bool ReApply(ICppNoExceptSpecification a, ICppNoExceptSpecification b);
    public virtual int ReApplyHashCode(ICppResolveEntity ent);
    private bool CompareRequiresExpressions(ICppRequiresExpressionScopeResolveEntity lreq, ICppRequiresExpressionScopeResolveEntity rreq);
}
public class JetBrains.ReSharper.Psi.Cpp.Lang.CppSemanticalEqualityComparerDisallowingTemplateParameters : CppSemanticalEqualityComparer {
    public static CppEqualityComparer Instance;
    private static CppSemanticalEqualityComparerDisallowingTemplateParameters();
    public virtual bool ReApply(ICppResolveEntity lhs, ICppResolveEntity rhs);
}
public class JetBrains.ReSharper.Psi.Cpp.Lang.CppSemanticalEqualityComparerIgnoringDependentTemplateAliasTypes : CppSemanticalEqualityComparer {
    public static CppEqualityComparer Instance;
    private static CppSemanticalEqualityComparerIgnoringDependentTemplateAliasTypes();
    public virtual bool ReApply(CppQualType lhs, CppQualType rhs);
    protected virtual bool ReApplyToHeadOfDependentEntities(ICppDependentScopeLikeResolveEntity lhs, ICppDependentScopeLikeResolveEntity rhs);
    private static ICppScopeLikeResolveEntity Dealias(ICppDependentScopeLikeResolveEntity ent);
}
public class JetBrains.ReSharper.Psi.Cpp.Lang.CppSemanticalEqualityComparerIgnoringMagicTypes : CppSemanticalEqualityComparer {
    public virtual bool ReApply(CppQualType lhs, CppQualType rhs);
    private static CppClassTemplateResolveEntityPack TryGetPackOfTemplateClassOrSubstitution(CppQualType type);
    private static bool IsMagicTypeAndNotUndeterminedSpec(CppQualType lhs);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Lang.CppSubobject : ValueType {
    [CompilerGeneratedAttribute]
private ICppClassResolveEntity <VirtualRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private CppSubobjectPath <Path>k__BackingField;
    public ICppClassResolveEntity VirtualRoot { get; }
    public CppSubobjectPath Path { get; }
    public CppSubobject(ICppClassResolveEntity virtualRoot, CppSubobjectPath path);
    [CompilerGeneratedAttribute]
public ICppClassResolveEntity get_VirtualRoot();
    [CompilerGeneratedAttribute]
public CppSubobjectPath get_Path();
    public sealed virtual bool Equals(CppSubobject other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Lang.CppSubobjectPath : object {
    [CompilerGeneratedAttribute]
private ICppClassResolveEntity <Head>k__BackingField;
    [CompilerGeneratedAttribute]
private CppSubobjectPath <Tail>k__BackingField;
    public ICppClassResolveEntity Head { get; }
    public CppSubobjectPath Tail { get; }
    public CppSubobjectPath(ICppClassResolveEntity head, CppSubobjectPath tail);
    [CompilerGeneratedAttribute]
public ICppClassResolveEntity get_Head();
    [CompilerGeneratedAttribute]
public CppSubobjectPath get_Tail();
    public sealed virtual bool Equals(CppSubobjectPath other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    private static bool AreSubobjPathsEqual(CppSubobjectPath lhs, CppSubobjectPath rhs);
    internal static int CalculateSubobjPathHashCode(CppSubobjectPath p);
}
public class JetBrains.ReSharper.Psi.Cpp.Lang.CppSubstitutionDriver : object {
    private ICppSubstitutionContext mySubstitution;
    public CppTypeContext TypeContext;
    public ICppSubstitutionContext Substitution { get; }
    public CppSubstitutionDriver(ICppSubstitutionContext subst, CppTypeContext& tc);
    public ICppSubstitutionContext get_Substitution();
    public CppQualType SubstituteType(CppQualType type);
    public ValueTuple`2<CppList`1<CppQualType>, SubstitutionStatus> ExpandType(CppQualType type, bool checkSubstitutionFailure, bool deferUnknownTypePackArgs);
    public IList`1<CppQualType> SubstituteTypeList(IList`1<CppQualType> types);
    public CppQualType[] SubstituteTypeList(CppQualType[] types);
    public ICppResolvedExpression SubstituteExpression(ICppResolvedExpression expr);
    public ValueTuple`2<CppList`1<ICppResolvedExpression>, SubstitutionStatus> ExpandExpression(ICppResolvedExpression expr, bool checkSubstitutionFailure);
    public ICppTypeIdOrExpression SubstituteTypeIdOrExpression(ICppTypeIdOrExpression typeIdOrExpr);
    public CppList`1<ICppTypeIdOrExpression> ExpandTypeIdOrExpression(ICppTypeIdOrExpression typeIdOrExpr);
    public UsingDeclarationTargets SubstituteUsingDeclarationTargets(ICppClassResolveEntity containingClass, UsingDeclarationTargets targets);
    public CppList`1<UsingDeclarationTargets> ExpandUsingDeclarationTargets(ICppClassResolveEntity containingClass, UsingDeclarationTargets targets);
    public CppList`1<CppCtorInitializerStatementResolveEntityBase> ExpandCtorInitializerStatement(CppCtorInitializerStatementResolveEntityBase source, ICppScopeStatementResolveEntity parent);
    public ICppArgumentList SubstituteArgumentList(ICppArgumentList argList);
    public SubstitutionStatus SubstituteTemplateArgument(ICppTemplateArgument arg, CppList`1& result, bool checkSubstitutionFailure);
    public ICppTemplateArgument SubstituteSingletonTemplateArgument(ICppTemplateArgument arg);
    public CppList`1<ICppTemplateArgument> SubstituteTemplateArguments(ICppTemplateArgument[] args);
    public CppQualifiedNamePart SubstituteNamePart(CppQualifiedNamePart name);
    public CppQualifiedName SubstituteName(CppQualifiedName name);
    public CppDeclaratorInitializer SubstituteInitializer(CppDeclaratorInitializer initializer);
    private CppSmallArray`1<ICppExpression> Substitute(CppSmallArray`1<ICppExpression> source);
    public ICppResolveEntityParent SubstituteParent(ICppResolveEntityParent parent, ICppScopeResolveEntity lexicalParent);
    public void SetSubstitutionUnsafe(ICppSubstitutionContext ctx);
    private static void SubstituteInjectedClassNameTemplateArgument(CppSubstitutionDriver driver, CppInjectedClassNameTemplateArgument icnArg, CppList`1& result);
    private static void SubstituteExcessiveTemplateArgument(CppSubstitutionDriver driver, CppExcessiveTemplateArgument sarg, CppList`1& result);
    private static SubstitutionStatus SubstituteTemplateTemplateArgument(CppSubstitutionDriver driver, CppTemplateTemplateArgument templateArg, CppList`1& result, bool checkSubstitutionFailure);
    [CanBeNullAttribute]
private static ICppResolveEntity GetPackExpansionTemplateArgument(ICppTemplateArgument arg);
    private static CppResolvedSizeOfEllipsisExpression CreateSizeOfEllipsisExpression(ICppResolveEntity ent, CppViewPos& vp);
    private static void PlusAssign(ICppResolvedExpression& sum, CppViewPos& vp, ICppResolvedExpression addendum);
    private static SubstitutionStatus SubstituteTypeTemplateArgument(CppSubstitutionDriver driver, CppQualType t, ICppTemplateArgument arg, CppList`1& result, bool checkSubstitutionFailure);
    private static SubstitutionStatus SubstituteExpressionTemplateArgument(CppSubstitutionDriver driver, CppExpressionTemplateArgument arg, CppList`1& result, bool checkSubstitutionFailure);
    private static ICppTemplateArgument SubstituteTemplateTemplateArgumentImpl(CppSubstitutionDriver driver, CppTemplateTemplateArgument arg);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Lang.CppSubstitutionEx : object {
    [ExtensionAttribute]
public static ICppTemplateArgument DoSingletonSubstitution(ICppTemplateArgument arg, CppTypeContext& tc, CppSubstitutionContext subst);
    [ExtensionAttribute]
public static CppTemplateParametersBase DoSubstitution(CppTemplateParametersBase params, CppTypeContext& tc, ICppSubstitutionContext subst);
    [ExtensionAttribute]
public static CppQualifiedNamePart DoSubstitution(CppQualifiedNamePart name, CppTypeContext& tc, ICppSubstitutionContext subst);
    [ExtensionAttribute]
public static ICppResolveEntityParent DoSubstitution(ICppResolveEntityParent parent, ICppScopeResolveEntity lexical, CppTypeContext& tc, ICppSubstitutionContext subst);
    [ExtensionAttribute]
public static CppQualType SubstituteType(CppQualType type, ICppSubstitutionContext substitution, CppTypeContext& tc);
    [ExtensionAttribute]
public static ICppResolvedExpression SubstituteExpression(ICppResolvedExpression expr, ICppSubstitutionContext substitution, CppTypeContext& tc);
    [ExtensionAttribute]
public static ICppTemplateArgument[] SubstituteTemplateArguments(ICppTemplateArgument[] args, ICppSubstitutionContext substitution, CppTypeContext& tc);
    private static ICppTemplateArgument DoSubstitutionToDefaultTemplateArgument(ICppTemplateArgument arg, CppSubstitutionDriver driver);
    [ExtensionAttribute]
public static ICppTemplateParameter CreateTemplateParameterForSubstitution(ICppTemplateParameter par, CppSubstitutionDriver driver, bool dropDefault);
    [ExtensionAttribute]
public static ICppClassResolveEntity SubstituteLambdaClass(ICppClassResolveEntity lambdaClass, CppLambdaScopeResolveEntity lambdaScope, ICppScopeResolveEntity parent, ICppSubstitutionContext substitution, CppViewPos& viewPos);
    private static CppTemplateParametersBase DoSubstitutionToTemplateParameters(CppTemplateParametersBase params, CppSubstitutionDriver driver);
}
public class JetBrains.ReSharper.Psi.Cpp.Lang.CppSymbolEqualityComparerEngine : CppEqualityComparer {
    public static CppSymbolEqualityComparerEngine Instance;
    public bool ShouldDropDecorations { get; }
    private static CppSymbolEqualityComparerEngine();
    public virtual bool get_ShouldDropDecorations();
    public virtual bool ReApply(ICppSymbol lhs, ICppSymbol rhs);
}
public interface JetBrains.ReSharper.Psi.Cpp.Lang.ICppDeclaredElementLangInfoProvider {
    public abstract virtual LangInfo GetLangInfo(ICppDeclaredElement e, ITreeNode context);
}
public interface JetBrains.ReSharper.Psi.Cpp.Lang.ICppEqualityComparer {
    public bool ShouldDropDecorations { get; }
    public abstract virtual bool get_ShouldDropDecorations();
    public abstract virtual bool NamesAreEqual(CppQualifiedNamePart lhs, CppQualifiedNamePart rhs);
    public abstract virtual bool QualifiedNamesAreEqual(CppQualifiedName lhs, CppQualifiedName rhs);
    public abstract virtual bool SymbolsAreEqual(ICppSymbol lhs, ICppSymbol rhs);
    public abstract virtual bool ResolveEntitiesAreEqual(ICppResolveEntity lhs, ICppResolveEntity rhs);
    public abstract virtual bool TypesAreEqual(CppQualType lhs, CppQualType rhs);
    public abstract virtual bool TypesAreEqual(CppTypeAndCategory lhs, CppTypeAndCategory rhs);
    public abstract virtual bool TypesAreEqualIgnoringFunctionReturnType(CppQualType lhs, CppQualType rhs);
    public abstract virtual bool ExpressionsAreEqual(ICppExpression lhs, ICppExpression rhs);
    public abstract virtual bool TemplateArgumentsAreEqual(ICppTemplateArgument lhs, ICppTemplateArgument rhs);
    public abstract virtual bool TemplateArgumentListsAreEqual(ICppTemplateArgument[] lhs, ICppTemplateArgument[] rhs);
    public abstract virtual bool ParameterDeclaratorsAreEqual(CppParameterDeclaratorsData lhs, CppParameterDeclaratorsData rhs);
    public abstract virtual bool UnknownInfosAreEqual(CppUnknownEntityInfo lhs, CppUnknownEntityInfo rhs);
    public abstract virtual bool LinkageEntitiesAreEqual(ICppLinkageEntity lhs, ICppLinkageEntity rhs);
    public abstract virtual bool LinkageEntitiesAreEqual(ICppDependentLinkageEntity lhs, ICppDependentLinkageEntity rhs);
    public abstract virtual bool ArgumentListsAreEqual(ICppArgumentList lhs, ICppArgumentList rhs);
    public abstract virtual bool ArgumentListsAreEqual(ICppExpression[] lhs, ICppExpression[] rhs);
    public abstract virtual bool AttributesAreEqual(ICppAttribute lhs, ICppAttribute rhs);
    public abstract virtual bool AttributeListsAreEqual(CppAttributeList lhs, CppAttributeList rhs);
    public abstract virtual bool InitializersAreEqual(CppDeclaratorInitializer lhs, CppDeclaratorInitializer rhs);
    public abstract virtual bool GenericConstraintsAreEqual(ICppGenericConstraint lhs, ICppGenericConstraint rhs);
    public abstract virtual bool ReApply(ICppNoExceptSpecification lhs, ICppNoExceptSpecification rhs);
    public abstract virtual bool ReApply(ICppSymbol lhs, ICppSymbol rhs);
    public abstract virtual int GetQualTypeHashCode(CppQualType type);
    public abstract virtual int GetResolveEntityHashCode(ICppResolveEntity e);
    public abstract virtual int GetTemplateArgumentHashCode(ICppTemplateArgument arg);
}
public interface JetBrains.ReSharper.Psi.Cpp.Lang.ICppGetDependenciesConsumer {
    public abstract virtual bool ShouldVisitPackExpansions();
    public abstract virtual bool ShouldVisitNonDeducedContext();
    public abstract virtual bool ShouldVisitTemplateParents();
    public abstract virtual bool ShouldVisitInnerTypeOfAlias();
    public abstract virtual bool ShouldVisitTemplateId();
    public abstract virtual void AddTemplateParam(ICppTemplateParameter tag);
    public abstract virtual void AddFunctionParam(ICppVariableDeclaratorResolveEntity param);
}
internal class JetBrains.ReSharper.Psi.Cpp.Lang.RequiresExpressionItemEqualsVisitor : object {
    public ICppRequiresExpressionItem RightHandSide;
    private CppEqualityComparer myEngine;
    public RequiresExpressionItemEqualsVisitor(CppEqualityComparer engine);
    public sealed virtual bool Visit(ICppRequiresExpressionItemTypename lhs);
    public sealed virtual bool Visit(ICppRequiresExpressionItemSimple lhs);
    public sealed virtual bool Visit(ICppRequiresExpressionItemNested lhs);
    public sealed virtual bool Visit(ICppRequiresExpressionItemCompound lhs);
    public bool Compare(CppList`1<ICppRequiresExpressionItem> litems, CppList`1<ICppRequiresExpressionItem> ritems);
}
public enum JetBrains.ReSharper.Psi.Cpp.Language.Cpp__NullUnderlyingType : Enum {
    public byte value__;
    public static Cpp__NullUnderlyingType UNSUPPORTED;
    public static Cpp__NullUnderlyingType INT;
    public static Cpp__NullUnderlyingType LONG;
}
public enum JetBrains.ReSharper.Psi.Cpp.Language.CppABI : Enum {
    public int value__;
    public static CppABI MSVC;
    public static CppABI Itanium;
}
public enum JetBrains.ReSharper.Psi.Cpp.Language.CppAutoBehavior : Enum {
    public int value__;
    public static CppAutoBehavior TYPE_DEDUCTION;
    public static CppAutoBehavior STORAGE_SPECIFIER;
    public static CppAutoBehavior RESERVED;
}
public enum JetBrains.ReSharper.Psi.Cpp.Language.CppCallingConventionsInLambdaToFunctionPointerConversion : Enum {
    public byte value__;
    public static CppCallingConventionsInLambdaToFunctionPointerConversion DEFAULT;
    public static CppCallingConventionsInLambdaToFunctionPointerConversion CDECL_VECTORCALL;
    public static CppCallingConventionsInLambdaToFunctionPointerConversion CDECL_STDCALL_FASTCALL_VECTORCALL;
    public static CppCallingConventionsInLambdaToFunctionPointerConversion CDECL_STDCALL_FASTCALL_VECTORCALL_THISCALL;
}
public class JetBrains.ReSharper.Psi.Cpp.Language.CppClangOnWindowsToolset : CppMSVCDialect {
    public bool HasClangExtensions { get; }
    public bool HasGnuExtensions { get; }
    public bool HasGnuKeywords { get; }
    public bool HasGnuBuiltins { get; }
    public bool HasHasBuiltin { get; }
    public bool HasHasFeature { get; }
    public bool HasHasExtension { get; }
    public bool HasExperimentalLibrary { get; }
    public bool HasGCCAutoType { get; }
    public bool HasClangAtomicsBuiltins { get; }
    public bool HasAlternativeOperators { get; }
    public bool HasRangeForInitializers { get; }
    public bool HasDesignatedInitialization { get; }
    public bool AllowsSizeTLiterals { get; }
    public bool AllowNamespaceLevelInlineAsm { get; }
    public CppCallingConventionsInLambdaToFunctionPointerConversion LambdaCallingConventions { get; }
    public CppTypeInfoNamespace TypeInfoNamespace { get; }
    public CppClangOnWindowsToolset(bool isMachine64Bit, DefaultCallingConvention defaultCallingConvention, CppLanguageKind kind, CppLanguageStandard cppStandard, CLanguageStandard cStandard, bool conformanceMode, bool disableLanguageExtensions, bool hasCoroutines, bool builtinWchar);
    public virtual bool get_HasClangExtensions();
    public virtual bool get_HasGnuExtensions();
    public virtual bool get_HasGnuKeywords();
    public virtual bool get_HasGnuBuiltins();
    public virtual bool get_HasHasBuiltin();
    public virtual bool get_HasHasFeature();
    public virtual bool get_HasHasExtension();
    public virtual bool get_HasExperimentalLibrary();
    public virtual bool get_HasGCCAutoType();
    public virtual bool get_HasClangAtomicsBuiltins();
    public virtual bool get_HasAlternativeOperators();
    public virtual bool get_HasRangeForInitializers();
    public virtual bool get_HasDesignatedInitialization();
    public virtual bool get_AllowsSizeTLiterals();
    public virtual bool get_AllowNamespaceLevelInlineAsm();
    public virtual CppCallingConventionsInLambdaToFunctionPointerConversion get_LambdaCallingConventions();
    public virtual CppTypeInfoNamespace get_TypeInfoNamespace();
    public virtual bool HasTypeTrait(CppConfigurableTypeTrait kind);
    public virtual bool Equals(CppLanguageDialect other);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Language.CppCommentDeclaredElementUtil : object {
    public static ICollection`1<ICppSymbol> GetPossibleSymbols(ISolution solution, string name);
    [ExtensionAttribute]
public static ICollection`1<ICppSymbol> GetPossibleSymbols(CommentDeclaredElement element);
}
public enum JetBrains.ReSharper.Psi.Cpp.Language.CppConfigurableTypeTrait : Enum {
    public int value__;
    public static CppConfigurableTypeTrait IS_ARRAY;
    public static CppConfigurableTypeTrait IS_UNBOUNDED_ARRAY;
    public static CppConfigurableTypeTrait IS_FUNCTION;
    public static CppConfigurableTypeTrait IS_OBJECT;
    public static CppConfigurableTypeTrait IS_LITERAL;
    public static CppConfigurableTypeTrait IS_POINTER;
    public static CppConfigurableTypeTrait IS_MEMBER_POINTER;
    public static CppConfigurableTypeTrait IS_MEMBER_FUNCTION_POINTER;
    public static CppConfigurableTypeTrait IS_MEMBER_OBJECT_POINTER;
    public static CppConfigurableTypeTrait IS_REFERENCE;
    public static CppConfigurableTypeTrait IS_LVALUE_REFERENCE;
    public static CppConfigurableTypeTrait IS_RVALUE_REFERENCE;
    public static CppConfigurableTypeTrait IS_CONST;
    public static CppConfigurableTypeTrait IS_VOLATILE;
    public static CppConfigurableTypeTrait IS_NULLPTR;
    public static CppConfigurableTypeTrait IS_SCALAR;
    public static CppConfigurableTypeTrait IS_ARITHMETIC;
    public static CppConfigurableTypeTrait IS_COMPOUND;
    public static CppConfigurableTypeTrait IS_FUNDAMENTAL;
    public static CppConfigurableTypeTrait IS_COMPLETE_TYPE;
    public static CppConfigurableTypeTrait IS_SIGNED;
    public static CppConfigurableTypeTrait IS_UNSIGNED;
    public static CppConfigurableTypeTrait IS_VOID;
    public static CppConfigurableTypeTrait IS_INTEGRAL;
    public static CppConfigurableTypeTrait IS_FLOATING_POINT;
    public static CppConfigurableTypeTrait ADD_POINTER;
    public static CppConfigurableTypeTrait ADD_LVALUE_REFERENCE;
    public static CppConfigurableTypeTrait ADD_RVALUE_REFERENCE;
    public static CppConfigurableTypeTrait DECAY;
    public static CppConfigurableTypeTrait MAKE_SIGNED;
    public static CppConfigurableTypeTrait MAKE_UNSIGNED;
    public static CppConfigurableTypeTrait REMOVE_CONST;
    public static CppConfigurableTypeTrait REMOVE_VOLATILE;
    public static CppConfigurableTypeTrait REMOVE_CV;
    public static CppConfigurableTypeTrait REMOVE_CVREF;
    public static CppConfigurableTypeTrait REMOVE_REFERENCE;
    public static CppConfigurableTypeTrait REMOVE_POINTER;
    public static CppConfigurableTypeTrait REMOVE_EXTENT;
    public static CppConfigurableTypeTrait REMOVE_ALL_EXTENTS;
    public static CppConfigurableTypeTrait IS_CONVERTIBLE;
    public static CppConfigurableTypeTrait IS_NOTHROW_CONVERTIBLE;
    public static CppConfigurableTypeTrait IS_SAME;
    public static CppConfigurableTypeTrait SAME_AS;
    public static CppConfigurableTypeTrait MAKE_INTEGER_SEQ;
    public static CppConfigurableTypeTrait TYPE_PACK_ELEMENT;
    public static CppConfigurableTypeTrait INTEGER_PACK;
}
public enum JetBrains.ReSharper.Psi.Cpp.Language.CppDeclaratorType : Enum {
    public int value__;
    public static CppDeclaratorType DEFAULT;
    public static CppDeclaratorType TYPEDEF;
    public static CppDeclaratorType TYPE_ALIAS;
    public static CppDeclaratorType FUNCTION;
    public static CppDeclaratorType OPERATOR;
    public static CppDeclaratorType LITERAL_OPERATOR;
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Language.CppDeclaredElementBase : object {
    private IPsiServices myServices;
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    protected CppDeclaredElementBase(IPsiServices services);
    public virtual IPsiServices GetPsiServices();
    public virtual IList`1<IDeclaration> GetDeclarations();
    public abstract virtual IEnumerable`1<ICppSymbol> GetSymbols();
    public abstract virtual CppAccessibility GetAccessibility();
    public virtual Pair`2<VirtualFileSystemPath, TextRange> GetNavigationLocation();
    public virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public abstract virtual string get_ShortName();
    public virtual bool get_CaseSensitiveName();
    public abstract virtual DeclaredElementType GetElementType();
    public virtual XmlNode GetXMLDoc(bool inherit);
    public virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public abstract virtual bool IsValid();
    public virtual bool IsSynthetic();
    public virtual PsiLanguageType get_PresentationLanguage();
    public virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public abstract virtual Result Accept(ICppDeclaredElementVisitor`1<Result> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Language.CppDeclaredElementPresentationBuilder : ValueType {
    private DeclaredElementPresenterStyle myStyle;
    private CppNameAndTemplateParameters myElementName;
    private string myContainingTypeName;
    private string myContainingNamespaceName;
    private DeclaredElementType myElementType;
    private DeclaredElementType myContainingTypeType;
    private CppQualType myType;
    private IList`1<string> myCustomParameters;
    private CppAccessibility myAccessibility;
    public CppDeclaredElementPresentationBuilder(DeclaredElementPresenterStyle style);
    public void LearnElement(CppNameAndTemplateParameters name, DeclaredElementType type);
    public void LearnContainingType(string name, DeclaredElementType type);
    public void LearnContainingNamespace(string name);
    public void LearnType(CppQualType type);
    public void LearnCustomParameters(IList`1<string> params);
    public void LearnAccessibility(CppAccessibility accessibility);
    public string Build(DeclaredElementPresenterMarking& marking);
    private string PresentEntity(Nullable`1<CppNameAndTemplateParameters> name, TextRange& accessRightsRange, TextRange& entityKindRange, TextRange& nameRange, TextRange& typeRange, TextRange& parameterListRange, Parameter[]& parameterRanges, TextRange& typeParameterListRange, TextRange[]& typeParameterRanges, TextRange& containerNameRange, TextRange& containerRange);
    private string PresentNameWithType(Nullable`1<CppNameAndTemplateParameters> name, TextRange& nameRange, TextRange& typeRange, Parameter[]& parameterRanges, TextRange& typeParameterListRange, TextRange[]& typeParameterRanges);
    [NotNullAttribute]
private static string PresentParameters(IList`1<string> parameters, TextRange& parameterListRange, Parameter[]& parameterRanges);
    [NotNullAttribute]
private static string PresentAccessibility(CppAccessibility accessibility, TextRange& accessRightsRange);
    private static string PresentEntityKind(DeclaredElementType elementType, TextRange& entityKindRange);
    private Nullable`1<CppNameAndTemplateParameters> GetNameAccordingToStyle();
    private string PresentName(CppNameAndTemplateParameters elementName, TextRange& nameRange, TextRange& typeParameterListRange, TextRange[]& typeParameterRanges);
    private static string PresentTemplateParameters(CppNameAndTemplateParameters elementName, TextRange& typeParameterListRange, TextRange[]& typeParameterRanges);
    [NotNullAttribute]
private string PresentType(Parameter[]& parameterRanges, TextRange& parameterListRange, TextRange& typeRange);
    private string TryPresentContainer(TextRange& containerNameRange, TextRange& containerRange);
    private bool IsMember();
    private bool IsType();
    private bool IsNamespace();
    private CppNameAndTemplateParameters GetQualifiedName();
    private CppNameAndTemplateParameters GetNestedName();
    private static CppNameAndTemplateParameters Combine(string container, CppNameAndTemplateParameters name);
    private string GetContainerName(DeclaredElementType& containerType);
    private static void Shift(TextRange& range, int offset);
    private static void Shift(TextRange[] ranges, int offset);
    private static void Shift(Parameter[] parameters, int offset);
}
public class JetBrains.ReSharper.Psi.Cpp.Language.CppDeclaredElementPresenter : object {
    public static CppDeclaredElementPresenter Instance;
    private ICppPresenter myPresenter;
    public CppDeclaredElementPresenter(ICppPresenter presenter);
    private static CppDeclaredElementPresenter();
    public sealed virtual RichText Format(DeclaredElementPresenterStyle style, IDeclaredElement element, ISubstitution substitution, DeclaredElementPresenterMarking& marking);
    public sealed virtual string Format(ParameterKind parameterKind);
    public sealed virtual string Format(AccessRights accessRights);
    public sealed virtual string GetEntityKind(IDeclaredElement declaredElement);
    public string Format(DeclaredElementPresenterStyle style, IDeclaredElement element, ISubstitution substitution, PresentationOptions options, DeclaredElementPresenterMarking& marking);
}
public class JetBrains.ReSharper.Psi.Cpp.Language.CppDeclaredElementType : DeclaredElementType {
    private IconId myIcon;
    [CompilerGeneratedAttribute]
private string <PresentableName>k__BackingField;
    public string PresentableName { get; }
    protected IDeclaredElementPresenter DefaultPresenter { get; }
    public CppDeclaredElementType(string name, IconId icon);
    [CompilerGeneratedAttribute]
public virtual string get_PresentableName();
    protected virtual IDeclaredElementPresenter get_DefaultPresenter();
    public virtual IconId GetImage();
    public virtual bool IsPresentable(PsiLanguageType language);
    public static bool IsStructLike(DeclaredElementType type);
    public static bool IsType(DeclaredElementType type);
    public static bool IsFunction(DeclaredElementType type);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Language.CppDeclaredElementTypes : object {
    public static CppDeclaredElementType NAMESPACE;
    public static CppDeclaredElementType NAMESPACE_ALIAS;
    public static CppDeclaredElementType CLASS;
    public static CppDeclaredElementType STRUCT;
    public static CppDeclaredElementType __INTERFACE;
    public static CppDeclaredElementType ENUM;
    public static CppDeclaredElementType UNION;
    public static CppDeclaredElementType HLSL_BUFFER;
    public static CppDeclaredElementType LOCAL_VARIABLE;
    public static CppDeclaredElementType PARAMETER;
    public static CppDeclaredElementType GLOBAL_VARIABLE;
    public static CppDeclaredElementType STRUCT_FIELD;
    public static CppDeclaredElementType CLASS_FIELD;
    public static CppDeclaredElementType UNION_MEMBER;
    public static CppDeclaredElementType ENUMERATOR;
    public static CppDeclaredElementType TYPEDEF;
    public static CppDeclaredElementType TYPE_ALIAS;
    public static CppDeclaredElementType PROPERTY;
    public static CppDeclaredElementType EVENT;
    public static CppDeclaredElementType TEMPLATE_PARAMETER;
    public static CppDeclaredElementType DEPENDENT_NAME;
    public static CppDeclaredElementType USING_DECLARATION;
    public static CppDeclaredElementType CONSTRUCTOR;
    public static CppDeclaredElementType DESTRUCTOR;
    public static CppDeclaredElementType MEMBER_FUNCTION;
    public static CppDeclaredElementType GLOBAL_FUNCTION;
    public static CppDeclaredElementType MEMBER_OPERATOR;
    public static CppDeclaredElementType GLOBAL_OPERATOR;
    public static CppDeclaredElementType LITERAL_OPERATOR;
    public static CppDeclaredElementType CONVERSION_OPERATOR;
    public static CppDeclaredElementType COMPOUND_STATEMENT;
    public static CppDeclaredElementType REQUIRES_CLAUSE;
    public static CppDeclaredElementType PARAMETER_LIST;
    public static CppDeclaredElementType MACRO;
    public static CppDeclaredElementType MACRO_PARAMETER;
    public static CppDeclaredElementType HEADER;
    public static CppDeclaredElementType SOURCE;
    public static CppDeclaredElementType SHADER;
    public static CppDeclaredElementType SHADER_GLSL;
    public static CppDeclaredElementType CONCEPT;
    public static CppDeclaredElementType COMMENT_IDENTIFIER;
    public static CppDeclaredElementType MODULE;
    public static CppDeclaredElementType MODULE_PARTITION;
    private static CppDeclaredElementTypes();
    [ExtensionAttribute]
public static CppDeclaredElementType GetDeclaredElementTypeByClassKey(CppClassKey key);
    [ExtensionAttribute]
public static CppDeclaredElementType GetDeclaratorDeclaredElementType(CppDeclaredElementType parentType, CppDeclaratorType declaratorType);
    [ExtensionAttribute]
public static bool IsDeclaredElementWithoutReturnType(DeclaredElementType type);
}
public class JetBrains.ReSharper.Psi.Cpp.Language.CppDefaultLanguageDialect : CppLanguageDialectBase {
    public static CppDefaultLanguageDialect Instance;
    public CppLanguageKind LanguageKind { get; }
    public bool BuiltinWchar { get; }
    public bool BuiltinChar1632 { get; }
    public CppSizeTUnderlyingType SizeTUnderlyingType { get; }
    public CppCallingConvention DefaultCallingConvention { get; }
    public CppCallingConvention DefaultMemberCallingConvention { get; }
    public CppCallingConvention DefaultCtorDtorCallingConvention { get; }
    public CppCallingConventionsInLambdaToFunctionPointerConversion LambdaCallingConventions { get; }
    public CppAutoBehavior AutoBehavior { get; }
    public bool HasImplicitConstOnConstexprMemberFunctions { get; }
    public bool HasNullPtr { get; }
    public bool HasConstexpr { get; }
    public bool HasC23Bool { get; }
    public bool HasC23Typeof { get; }
    public bool HasC23Attributes { get; }
    public bool HasC23HasCAttribute { get; }
    public bool HasCpp14AutoWithListInitFix { get; }
    public bool IgnoreStdFastAndThiscall { get; }
    public bool HasNoexcept { get; }
    public bool NoexceptIsPartOfFunctionType { get; }
    public bool AllowsUserDefinedLiterals { get; }
    public bool AllowsSizeTLiterals { get; }
    public int SizeOfPointer { get; }
    public int SizeOfLong { get; }
    public int SizeOfWcharT { get; }
    public bool AllowsRefStructs { get; }
    public bool AllowsGenerics { get; }
    public bool HasExplicitConversionOperators { get; }
    public bool HasExplicitThisParameter { get; }
    public bool HasDelegatingConstructors { get; }
    public bool HasDefaultedAndDeletedFunctions { get; }
    public bool HasNestedNamespaces { get; }
    public bool HasCpp11StyleAttributes { get; }
    public bool HasOverride { get; }
    public bool HasExportKeyword { get; }
    public bool HasIfInitializers { get; }
    public bool HasRangeForInitializers { get; }
    public bool HasInlineVariables { get; }
    public bool HasConstexprIf { get; }
    public bool HasGuaranteedCopyElision { get; }
    public bool HasAggregatesWithBaseClasses { get; }
    public bool HasAggregateParenInit { get; }
    public bool ProhibitAggregatesWithUserDeclaredConstructors { get; }
    public bool HasCTAD { get; }
    public bool HasCTADForAggregatesAndTypeAliases { get; }
    public bool HasStructuredBindings { get; }
    public bool HasCoroutines { get; }
    public bool HasConcepts { get; }
    public bool HasModules { get; }
    public bool HasTrailingReturnTypeSyntax { get; }
    public bool HasThreeWayComparison { get; }
    public bool HasDefaultConstructibleAndAssignableStatelessLambdas { get; }
    public bool HasChar8 { get; }
    public bool HasConsteval { get; }
    public bool HasConstinit { get; }
    public bool HasUsingEnum { get; }
    public bool HasCpp20Attributes { get; }
    public bool HasCpp20StructuredBindings { get; }
    public bool HasObjectTemplateParameters { get; }
    public bool HasConstexprVoidFunctions { get; }
    public bool HasConstexprVirtualFunctions { get; }
    public bool HasDesignatedInitialization { get; }
    public bool HasMultidimensionalSubscriptOperator { get; }
    public bool HasCpp17Attributes { get; }
    public bool AllowBindingRValueToLValueReference { get; }
    public bool HasFamiliarTemplateSyntaxForGenericLambdas { get; }
    public bool LambdaIsImplicitlyConstexpr { get; }
    public bool HasCopyElisionInCopyInitDeclarator { get; }
    public CppTemplateFunctionDisambiguationRules TemplateFunctionsDisambiguationRules { get; }
    public bool RequiresParameterNameInFunctionDefinition { get; }
    public CppTypeInfoNamespace TypeInfoNamespace { get; }
    public bool HasMsKeywords { get; }
    public bool HasClangExtensions { get; }
    public bool HasGnuExtensions { get; }
    public bool HasGnuKeywords { get; }
    public bool HasGnuBuiltins { get; }
    public bool HasHasBuiltin { get; }
    public bool HasHasFeature { get; }
    public bool HasHasExtension { get; }
    public bool HasExperimentalLibrary { get; }
    public bool HasGCCAutoType { get; }
    public bool HasStringBuiltins { get; }
    public bool HasBuiltinIsConstantEvaluated { get; }
    public bool HasClangAtomicsBuiltins { get; }
    public bool HasAlternativeOperators { get; }
    public bool VariableDeclarationRulesAreC89Compatible { get; }
    public bool PreferCopyCtorOverUserDefined { get; }
    public bool HasMsProperties { get; }
    public CppStringLiteralToPointerConversion StringLiteralToPointerConversion { get; }
    public bool LongToIntIsNarrowingConversion { get; }
    public bool LongLongToLongIsNarrowingConversion { get; }
    public bool HasIfConsteval { get; }
    public bool HasCpp23Operators { get; }
    public bool HasC99Restrict { get; }
    public bool HasBuiltinSourceLocation { get; }
    public bool HasBuiltinBitCast { get; }
    public bool HasBuiltinLaunder { get; }
    public bool AllowNamespaceLevelInlineAsm { get; }
    public CppABI ABI { get; }
    private static CppDefaultLanguageDialect();
    public virtual CppLanguageKind get_LanguageKind();
    public virtual bool get_BuiltinWchar();
    public virtual bool get_BuiltinChar1632();
    public virtual CppSizeTUnderlyingType get_SizeTUnderlyingType();
    public virtual CppCallingConvention get_DefaultCallingConvention();
    public virtual CppCallingConvention get_DefaultMemberCallingConvention();
    public virtual CppCallingConvention get_DefaultCtorDtorCallingConvention();
    public virtual CppCallingConventionsInLambdaToFunctionPointerConversion get_LambdaCallingConventions();
    public virtual CppAutoBehavior get_AutoBehavior();
    public virtual bool get_HasImplicitConstOnConstexprMemberFunctions();
    public virtual bool get_HasNullPtr();
    public virtual bool get_HasConstexpr();
    public virtual bool get_HasC23Bool();
    public virtual bool get_HasC23Typeof();
    public virtual bool get_HasC23Attributes();
    public virtual bool get_HasC23HasCAttribute();
    public virtual bool get_HasCpp14AutoWithListInitFix();
    public virtual bool get_IgnoreStdFastAndThiscall();
    public virtual bool get_HasNoexcept();
    public virtual bool get_NoexceptIsPartOfFunctionType();
    public virtual bool get_AllowsUserDefinedLiterals();
    public virtual bool get_AllowsSizeTLiterals();
    public virtual int get_SizeOfPointer();
    public virtual int get_SizeOfLong();
    public virtual int get_SizeOfWcharT();
    public virtual bool get_AllowsRefStructs();
    public virtual bool get_AllowsGenerics();
    public virtual bool get_HasExplicitConversionOperators();
    public virtual bool get_HasExplicitThisParameter();
    public virtual bool get_HasDelegatingConstructors();
    public virtual bool get_HasDefaultedAndDeletedFunctions();
    public virtual bool get_HasNestedNamespaces();
    public virtual bool get_HasCpp11StyleAttributes();
    public virtual bool get_HasOverride();
    public virtual bool get_HasExportKeyword();
    public virtual bool get_HasIfInitializers();
    public virtual bool get_HasRangeForInitializers();
    public virtual bool get_HasInlineVariables();
    public virtual bool get_HasConstexprIf();
    public virtual bool get_HasGuaranteedCopyElision();
    public virtual bool get_HasAggregatesWithBaseClasses();
    public virtual bool get_HasAggregateParenInit();
    public virtual bool get_ProhibitAggregatesWithUserDeclaredConstructors();
    public virtual bool get_HasCTAD();
    public virtual bool get_HasCTADForAggregatesAndTypeAliases();
    public virtual bool get_HasStructuredBindings();
    public virtual bool get_HasCoroutines();
    public virtual bool get_HasConcepts();
    public virtual bool get_HasModules();
    public virtual bool get_HasTrailingReturnTypeSyntax();
    public virtual bool get_HasThreeWayComparison();
    public virtual bool get_HasDefaultConstructibleAndAssignableStatelessLambdas();
    public virtual bool get_HasChar8();
    public virtual bool get_HasConsteval();
    public virtual bool get_HasConstinit();
    public virtual bool get_HasUsingEnum();
    public virtual bool get_HasCpp20Attributes();
    public virtual bool get_HasCpp20StructuredBindings();
    public virtual bool get_HasObjectTemplateParameters();
    public virtual bool get_HasConstexprVoidFunctions();
    public virtual bool get_HasConstexprVirtualFunctions();
    public virtual bool get_HasDesignatedInitialization();
    public virtual bool get_HasMultidimensionalSubscriptOperator();
    public virtual bool get_HasCpp17Attributes();
    public virtual bool get_AllowBindingRValueToLValueReference();
    public virtual bool get_HasFamiliarTemplateSyntaxForGenericLambdas();
    public virtual bool get_LambdaIsImplicitlyConstexpr();
    public virtual bool get_HasCopyElisionInCopyInitDeclarator();
    public virtual CppTemplateFunctionDisambiguationRules get_TemplateFunctionsDisambiguationRules();
    public virtual bool get_RequiresParameterNameInFunctionDefinition();
    public virtual CppTypeInfoNamespace get_TypeInfoNamespace();
    public virtual bool get_HasMsKeywords();
    public virtual bool get_HasClangExtensions();
    public virtual bool get_HasGnuExtensions();
    public virtual bool get_HasGnuKeywords();
    public virtual bool get_HasGnuBuiltins();
    public virtual bool get_HasHasBuiltin();
    public virtual bool get_HasHasFeature();
    public virtual bool get_HasHasExtension();
    public virtual bool get_HasExperimentalLibrary();
    public virtual bool get_HasGCCAutoType();
    public virtual bool get_HasStringBuiltins();
    public virtual bool get_HasBuiltinIsConstantEvaluated();
    public virtual bool get_HasClangAtomicsBuiltins();
    public virtual bool get_HasAlternativeOperators();
    public virtual bool get_VariableDeclarationRulesAreC89Compatible();
    public virtual bool get_PreferCopyCtorOverUserDefined();
    public virtual bool get_HasMsProperties();
    public virtual CppStringLiteralToPointerConversion get_StringLiteralToPointerConversion();
    public virtual bool get_LongToIntIsNarrowingConversion();
    public virtual bool get_LongLongToLongIsNarrowingConversion();
    public virtual bool get_HasIfConsteval();
    public virtual bool get_HasCpp23Operators();
    public virtual bool get_HasC99Restrict();
    public virtual bool get_HasBuiltinSourceLocation();
    public virtual bool get_HasBuiltinBitCast();
    public virtual bool get_HasBuiltinLaunder();
    public virtual bool get_AllowNamespaceLevelInlineAsm();
    public virtual bool HasTypeTrait(CppConfigurableTypeTrait kind);
    public virtual CppABI get_ABI();
    public virtual bool Equals(CppLanguageDialect that);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Language.CppHLSLDialect : CppLanguageDialectBase {
    public static ImmutableArray`1<PragmaCommand> HlslPragmaCommands;
    private static IReadOnlyDictionary`2<string, PragmaCommand> ourPragmas;
    [CompilerGeneratedAttribute]
private CppLanguageKind <LanguageKind>k__BackingField;
    public CppLanguageKind LanguageKind { get; }
    public IReadOnlyDictionary`2<string, PragmaCommand> Pragmas { get; }
    public bool BuiltinWchar { get; }
    public bool BuiltinChar1632 { get; }
    public CppCallingConvention DefaultMemberCallingConvention { get; }
    public CppCallingConvention DefaultCtorDtorCallingConvention { get; }
    public CppCallingConventionsInLambdaToFunctionPointerConversion LambdaCallingConventions { get; }
    public CppAutoBehavior AutoBehavior { get; }
    public bool HasImplicitConstOnConstexprMemberFunctions { get; }
    public bool HasConstexpr { get; }
    public bool HasC23Bool { get; }
    public bool HasC23Typeof { get; }
    public bool HasC23Attributes { get; }
    public bool HasC23HasCAttribute { get; }
    public bool HasCpp14AutoWithListInitFix { get; }
    public bool HasNullPtr { get; }
    public bool HasNoexcept { get; }
    public bool NoexceptIsPartOfFunctionType { get; }
    public bool AllowsRefStructs { get; }
    public bool AllowsGenerics { get; }
    public bool AllowsUserDefinedLiterals { get; }
    public bool AllowsSizeTLiterals { get; }
    public bool HasExplicitConversionOperators { get; }
    public bool HasExplicitThisParameter { get; }
    public bool HasDefaultedAndDeletedFunctions { get; }
    public bool HasNestedNamespaces { get; }
    public bool HasOverride { get; }
    public bool HasExportKeyword { get; }
    public bool HasIfInitializers { get; }
    public bool HasRangeForInitializers { get; }
    public bool HasInlineVariables { get; }
    public bool HasConstexprIf { get; }
    public bool HasAggregateParenInit { get; }
    public bool HasCTAD { get; }
    public bool HasCTADForAggregatesAndTypeAliases { get; }
    public bool HasStructuredBindings { get; }
    public bool HasCoroutines { get; }
    public bool HasConcepts { get; }
    public bool HasModules { get; }
    public bool HasTrailingReturnTypeSyntax { get; }
    public bool HasDelegatingConstructors { get; }
    public bool HasGuaranteedCopyElision { get; }
    public bool ProhibitAggregatesWithUserDeclaredConstructors { get; }
    public bool HasAggregatesWithBaseClasses { get; }
    public bool VariableDeclarationRulesAreC89Compatible { get; }
    public bool PreferCopyCtorOverUserDefined { get; }
    public bool HasAlternativeOperators { get; }
    public bool HasThreeWayComparison { get; }
    public bool HasDefaultConstructibleAndAssignableStatelessLambdas { get; }
    public bool HasFamiliarTemplateSyntaxForGenericLambdas { get; }
    public bool LambdaIsImplicitlyConstexpr { get; }
    public bool HasChar8 { get; }
    public bool HasConsteval { get; }
    public bool HasConstinit { get; }
    public bool HasUsingEnum { get; }
    public bool HasCpp20Attributes { get; }
    public bool HasCpp20StructuredBindings { get; }
    public bool HasCpp17Attributes { get; }
    public bool HasObjectTemplateParameters { get; }
    public bool HasConstexprVoidFunctions { get; }
    public bool HasConstexprVirtualFunctions { get; }
    public bool HasDesignatedInitialization { get; }
    public bool HasMultidimensionalSubscriptOperator { get; }
    public bool AllowBindingRValueToLValueReference { get; }
    public CppTemplateFunctionDisambiguationRules TemplateFunctionsDisambiguationRules { get; }
    public bool HasCpp11StyleAttributes { get; }
    public bool HasMsKeywords { get; }
    public bool HasClangExtensions { get; }
    public bool HasGnuExtensions { get; }
    public bool HasGnuKeywords { get; }
    public bool HasGnuBuiltins { get; }
    public bool HasHasBuiltin { get; }
    public bool HasHasFeature { get; }
    public bool HasHasExtension { get; }
    public bool HasExperimentalLibrary { get; }
    public bool HasGCCAutoType { get; }
    public bool HasStringBuiltins { get; }
    public bool HasBuiltinIsConstantEvaluated { get; }
    public bool HasClangAtomicsBuiltins { get; }
    public bool HasMsProperties { get; }
    public CppTypeInfoNamespace TypeInfoNamespace { get; }
    public bool RequiresParameterNameInFunctionDefinition { get; }
    public CppStringLiteralToPointerConversion StringLiteralToPointerConversion { get; }
    public bool LongToIntIsNarrowingConversion { get; }
    public bool LongLongToLongIsNarrowingConversion { get; }
    public bool HasIfConsteval { get; }
    public bool HasCpp23Operators { get; }
    public bool HasC99Restrict { get; }
    public bool HasBuiltinSourceLocation { get; }
    public bool HasBuiltinBitCast { get; }
    public bool HasBuiltinLaunder { get; }
    public bool AllowNamespaceLevelInlineAsm { get; }
    public CppABI ABI { get; }
    public CppHLSLDialect(bool isMachine64Bit, CppLanguageKind languageKind);
    private static CppHLSLDialect();
    [CompilerGeneratedAttribute]
public virtual CppLanguageKind get_LanguageKind();
    public virtual IReadOnlyDictionary`2<string, PragmaCommand> get_Pragmas();
    public virtual bool get_BuiltinWchar();
    public virtual bool get_BuiltinChar1632();
    public virtual CppCallingConvention get_DefaultMemberCallingConvention();
    public virtual CppCallingConvention get_DefaultCtorDtorCallingConvention();
    public virtual CppCallingConventionsInLambdaToFunctionPointerConversion get_LambdaCallingConventions();
    public virtual CppAutoBehavior get_AutoBehavior();
    public virtual bool get_HasImplicitConstOnConstexprMemberFunctions();
    public virtual bool get_HasConstexpr();
    public virtual bool get_HasC23Bool();
    public virtual bool get_HasC23Typeof();
    public virtual bool get_HasC23Attributes();
    public virtual bool get_HasC23HasCAttribute();
    public virtual bool get_HasCpp14AutoWithListInitFix();
    public virtual bool get_HasNullPtr();
    public virtual bool get_HasNoexcept();
    public virtual bool get_NoexceptIsPartOfFunctionType();
    public virtual bool get_AllowsRefStructs();
    public virtual bool get_AllowsGenerics();
    public virtual bool get_AllowsUserDefinedLiterals();
    public virtual bool get_AllowsSizeTLiterals();
    public virtual bool get_HasExplicitConversionOperators();
    public virtual bool get_HasExplicitThisParameter();
    public virtual bool get_HasDefaultedAndDeletedFunctions();
    public virtual bool get_HasNestedNamespaces();
    public virtual bool get_HasOverride();
    public virtual bool get_HasExportKeyword();
    public virtual bool get_HasIfInitializers();
    public virtual bool get_HasRangeForInitializers();
    public virtual bool get_HasInlineVariables();
    public virtual bool get_HasConstexprIf();
    public virtual bool get_HasAggregateParenInit();
    public virtual bool get_HasCTAD();
    public virtual bool get_HasCTADForAggregatesAndTypeAliases();
    public virtual bool get_HasStructuredBindings();
    public virtual bool get_HasCoroutines();
    public virtual bool get_HasConcepts();
    public virtual bool get_HasModules();
    public virtual bool get_HasTrailingReturnTypeSyntax();
    public virtual bool get_HasDelegatingConstructors();
    public virtual bool get_HasGuaranteedCopyElision();
    public virtual bool get_ProhibitAggregatesWithUserDeclaredConstructors();
    public virtual bool get_HasAggregatesWithBaseClasses();
    public virtual bool get_VariableDeclarationRulesAreC89Compatible();
    public virtual bool get_PreferCopyCtorOverUserDefined();
    public virtual bool get_HasAlternativeOperators();
    public virtual bool get_HasThreeWayComparison();
    public virtual bool get_HasDefaultConstructibleAndAssignableStatelessLambdas();
    public virtual bool get_HasFamiliarTemplateSyntaxForGenericLambdas();
    public virtual bool get_LambdaIsImplicitlyConstexpr();
    public virtual bool get_HasChar8();
    public virtual bool get_HasConsteval();
    public virtual bool get_HasConstinit();
    public virtual bool get_HasUsingEnum();
    public virtual bool get_HasCpp20Attributes();
    public virtual bool get_HasCpp20StructuredBindings();
    public virtual bool get_HasCpp17Attributes();
    public virtual bool get_HasObjectTemplateParameters();
    public virtual bool get_HasConstexprVoidFunctions();
    public virtual bool get_HasConstexprVirtualFunctions();
    public virtual bool get_HasDesignatedInitialization();
    public virtual bool get_HasMultidimensionalSubscriptOperator();
    public virtual bool get_AllowBindingRValueToLValueReference();
    public virtual CppTemplateFunctionDisambiguationRules get_TemplateFunctionsDisambiguationRules();
    public virtual bool get_HasCpp11StyleAttributes();
    public virtual bool get_HasMsKeywords();
    public virtual bool get_HasClangExtensions();
    public virtual bool get_HasGnuExtensions();
    public virtual bool get_HasGnuKeywords();
    public virtual bool get_HasGnuBuiltins();
    public virtual bool get_HasHasBuiltin();
    public virtual bool get_HasHasFeature();
    public virtual bool get_HasHasExtension();
    public virtual bool get_HasExperimentalLibrary();
    public virtual bool get_HasGCCAutoType();
    public virtual bool get_HasStringBuiltins();
    public virtual bool get_HasBuiltinIsConstantEvaluated();
    public virtual bool get_HasClangAtomicsBuiltins();
    public virtual bool get_HasMsProperties();
    public virtual CppTypeInfoNamespace get_TypeInfoNamespace();
    public virtual bool get_RequiresParameterNameInFunctionDefinition();
    public virtual CppStringLiteralToPointerConversion get_StringLiteralToPointerConversion();
    public virtual bool get_LongToIntIsNarrowingConversion();
    public virtual bool get_LongLongToLongIsNarrowingConversion();
    public virtual bool get_HasIfConsteval();
    public virtual bool get_HasCpp23Operators();
    public virtual bool get_HasC99Restrict();
    public virtual bool get_HasBuiltinSourceLocation();
    public virtual bool get_HasBuiltinBitCast();
    public virtual bool get_HasBuiltinLaunder();
    public virtual bool get_AllowNamespaceLevelInlineAsm();
    public virtual CppABI get_ABI();
    public virtual bool HasTypeTrait(CppConfigurableTypeTrait kind);
}
[LanguageDefinitionAttribute("CPP")]
public class JetBrains.ReSharper.Psi.Cpp.Language.CppLanguage : UnmanagedKnownLanguage {
    public static string Name;
    public static string PresentableName;
    [CompilerGeneratedAttribute]
private static CppLanguage <Instance>k__BackingField;
    [CanBeNullAttribute]
[UsedImplicitlyAttribute]
public static CppLanguage Instance { get; public set; }
    public PsiLanguageCategories SupportedCategories { get; }
    protected CppLanguage(string name);
    protected CppLanguage(string name, string presentableName);
    [CompilerGeneratedAttribute]
public static CppLanguage get_Instance();
    [CompilerGeneratedAttribute]
public static void set_Instance(CppLanguage value);
    public virtual PsiLanguageCategories get_SupportedCategories();
}
public interface JetBrains.ReSharper.Psi.Cpp.Language.CppLanguageDialect {
    public CppLanguageKind LanguageKind { get; }
    public bool BuiltinWchar { get; }
    public bool BuiltinChar1632 { get; }
    public CppSizeTUnderlyingType SizeTUnderlyingType { get; }
    public Cpp__NullUnderlyingType __NullUnderlying { get; }
    public CppCallingConvention DefaultCallingConvention { get; }
    public CppCallingConvention DefaultMemberCallingConvention { get; }
    public CppCallingConvention DefaultCtorDtorCallingConvention { get; }
    public CppCallingConventionsInLambdaToFunctionPointerConversion LambdaCallingConventions { get; }
    public CppAutoBehavior AutoBehavior { get; }
    public bool HasConstexpr { get; }
    public bool HasC23Bool { get; }
    public bool HasC23Typeof { get; }
    public bool HasC23Attributes { get; }
    public bool HasC23HasCAttribute { get; }
    public bool HasCpp14AutoWithListInitFix { get; }
    public bool HasImplicitConstOnConstexprMemberFunctions { get; }
    public bool IgnoreStdFastAndThiscall { get; }
    public bool HasNullPtr { get; }
    public bool HasNoexcept { get; }
    public bool NoexceptIsPartOfFunctionType { get; }
    public int SizeOfPointer { get; }
    public int SizeOfLong { get; }
    public int SizeOfWcharT { get; }
    public bool AllowsRefStructs { get; }
    public bool AllowsGenerics { get; }
    public bool AllowsUserDefinedLiterals { get; }
    public bool AllowsSizeTLiterals { get; }
    public bool HasExplicitConversionOperators { get; }
    public bool HasExplicitThisParameter { get; }
    public bool HasDelegatingConstructors { get; }
    public bool HasDefaultedAndDeletedFunctions { get; }
    public bool HasNestedNamespaces { get; }
    public bool HasOverride { get; }
    public bool HasExportKeyword { get; }
    public bool HasIfInitializers { get; }
    public bool HasRangeForInitializers { get; }
    public bool HasInlineVariables { get; }
    public bool HasConstexprIf { get; }
    public bool HasGuaranteedCopyElision { get; }
    public bool HasCopyElisionInCopyInitDeclarator { get; }
    public bool HasAggregatesWithBaseClasses { get; }
    public bool HasAggregateParenInit { get; }
    public bool ProhibitAggregatesWithUserDeclaredConstructors { get; }
    public bool HasCTAD { get; }
    public bool HasCTADForAggregatesAndTypeAliases { get; }
    public bool HasStructuredBindings { get; }
    public bool HasCoroutines { get; }
    public bool HasConcepts { get; }
    public bool HasModules { get; }
    public bool HasTrailingReturnTypeSyntax { get; }
    public bool VariableDeclarationRulesAreC89Compatible { get; }
    public bool PreferCopyCtorOverUserDefined { get; }
    public bool HasAlternativeOperators { get; }
    public bool HasThreeWayComparison { get; }
    public bool HasDefaultConstructibleAndAssignableStatelessLambdas { get; }
    public bool HasChar8 { get; }
    public bool HasConsteval { get; }
    public bool HasConstinit { get; }
    public bool HasUsingEnum { get; }
    public bool HasCpp20Attributes { get; }
    public bool HasCpp20StructuredBindings { get; }
    public bool HasCpp17Attributes { get; }
    public bool AllowBindingRValueToLValueReference { get; }
    public bool HasFamiliarTemplateSyntaxForGenericLambdas { get; }
    public bool LambdaIsImplicitlyConstexpr { get; }
    public bool HasConstexprVoidFunctions { get; }
    public bool HasConstexprVirtualFunctions { get; }
    public bool HasDesignatedInitialization { get; }
    public bool HasMultidimensionalSubscriptOperator { get; }
    public CppTemplateFunctionDisambiguationRules TemplateFunctionsDisambiguationRules { get; }
    public bool HasObjectTemplateParameters { get; }
    public bool RequiresParameterNameInFunctionDefinition { get; }
    public bool HasCpp11StyleAttributes { get; }
    public bool HasClangExtensions { get; }
    public bool HasGnuExtensions { get; }
    public bool HasGnuKeywords { get; }
    public bool HasGCCAutoType { get; }
    public bool HasMsKeywords { get; }
    public bool HasGnuBuiltins { get; }
    public bool HasHasBuiltin { get; }
    public bool HasHasFeature { get; }
    public bool HasHasExtension { get; }
    public bool HasExperimentalLibrary { get; }
    public bool HasStringBuiltins { get; }
    public bool HasBuiltinIsConstantEvaluated { get; }
    public bool HasClangAtomicsBuiltins { get; }
    public bool IgnoreNonClassTypedefsInQualifierLookup { get; }
    public CppTypeInfoNamespace TypeInfoNamespace { get; }
    public bool HasMsProperties { get; }
    public CppStringLiteralToPointerConversion StringLiteralToPointerConversion { get; }
    public bool LongToIntIsNarrowingConversion { get; }
    public bool LongLongToLongIsNarrowingConversion { get; }
    public bool TreatErrorsInTemplatesAsWarnings { get; }
    public bool VCTraditionalPreprocessor { get; }
    public bool HasIfConsteval { get; }
    public bool HasCpp23Operators { get; }
    public bool HasC99Restrict { get; }
    public bool HasBuiltinSourceLocation { get; }
    public bool HasBuiltinBitCast { get; }
    public bool HasBuiltinLaunder { get; }
    public bool AllowNamespaceLevelInlineAsm { get; }
    public CppABI ABI { get; }
    public IReadOnlyDictionary`2<string, PragmaCommand> Pragmas { get; }
    public abstract virtual CppLanguageKind get_LanguageKind();
    public abstract virtual bool get_BuiltinWchar();
    public abstract virtual bool get_BuiltinChar1632();
    public abstract virtual CppSizeTUnderlyingType get_SizeTUnderlyingType();
    public abstract virtual Cpp__NullUnderlyingType get___NullUnderlying();
    public abstract virtual CppCallingConvention get_DefaultCallingConvention();
    public abstract virtual CppCallingConvention get_DefaultMemberCallingConvention();
    public abstract virtual CppCallingConvention get_DefaultCtorDtorCallingConvention();
    public abstract virtual CppCallingConventionsInLambdaToFunctionPointerConversion get_LambdaCallingConventions();
    public abstract virtual CppAutoBehavior get_AutoBehavior();
    public abstract virtual bool get_HasConstexpr();
    public abstract virtual bool get_HasC23Bool();
    public abstract virtual bool get_HasC23Typeof();
    public abstract virtual bool get_HasC23Attributes();
    public abstract virtual bool get_HasC23HasCAttribute();
    public abstract virtual bool get_HasCpp14AutoWithListInitFix();
    public abstract virtual bool get_HasImplicitConstOnConstexprMemberFunctions();
    public abstract virtual bool get_IgnoreStdFastAndThiscall();
    public abstract virtual bool get_HasNullPtr();
    public abstract virtual bool get_HasNoexcept();
    public abstract virtual bool get_NoexceptIsPartOfFunctionType();
    public abstract virtual int get_SizeOfPointer();
    public abstract virtual int get_SizeOfLong();
    public abstract virtual int get_SizeOfWcharT();
    public abstract virtual bool get_AllowsRefStructs();
    public abstract virtual bool get_AllowsGenerics();
    public abstract virtual bool get_AllowsUserDefinedLiterals();
    public abstract virtual bool get_AllowsSizeTLiterals();
    public abstract virtual bool get_HasExplicitConversionOperators();
    public abstract virtual bool get_HasExplicitThisParameter();
    public abstract virtual bool get_HasDelegatingConstructors();
    public abstract virtual bool get_HasDefaultedAndDeletedFunctions();
    public abstract virtual bool get_HasNestedNamespaces();
    public abstract virtual bool get_HasOverride();
    public abstract virtual bool get_HasExportKeyword();
    public abstract virtual bool get_HasIfInitializers();
    public abstract virtual bool get_HasRangeForInitializers();
    public abstract virtual bool get_HasInlineVariables();
    public abstract virtual bool get_HasConstexprIf();
    public abstract virtual bool get_HasGuaranteedCopyElision();
    public abstract virtual bool get_HasCopyElisionInCopyInitDeclarator();
    public abstract virtual bool get_HasAggregatesWithBaseClasses();
    public abstract virtual bool get_HasAggregateParenInit();
    public abstract virtual bool get_ProhibitAggregatesWithUserDeclaredConstructors();
    public abstract virtual bool get_HasCTAD();
    public abstract virtual bool get_HasCTADForAggregatesAndTypeAliases();
    public abstract virtual bool get_HasStructuredBindings();
    public abstract virtual bool get_HasCoroutines();
    public abstract virtual bool get_HasConcepts();
    public abstract virtual bool get_HasModules();
    public abstract virtual bool get_HasTrailingReturnTypeSyntax();
    public abstract virtual bool get_VariableDeclarationRulesAreC89Compatible();
    public abstract virtual bool get_PreferCopyCtorOverUserDefined();
    public abstract virtual bool get_HasAlternativeOperators();
    public abstract virtual bool get_HasThreeWayComparison();
    public abstract virtual bool get_HasDefaultConstructibleAndAssignableStatelessLambdas();
    public abstract virtual bool get_HasChar8();
    public abstract virtual bool get_HasConsteval();
    public abstract virtual bool get_HasConstinit();
    public abstract virtual bool get_HasUsingEnum();
    public abstract virtual bool get_HasCpp20Attributes();
    public abstract virtual bool get_HasCpp20StructuredBindings();
    public abstract virtual bool get_HasCpp17Attributes();
    public abstract virtual bool get_AllowBindingRValueToLValueReference();
    public abstract virtual bool get_HasFamiliarTemplateSyntaxForGenericLambdas();
    public abstract virtual bool get_LambdaIsImplicitlyConstexpr();
    public abstract virtual bool get_HasConstexprVoidFunctions();
    public abstract virtual bool get_HasConstexprVirtualFunctions();
    public abstract virtual bool get_HasDesignatedInitialization();
    public abstract virtual bool get_HasMultidimensionalSubscriptOperator();
    public abstract virtual CppTemplateFunctionDisambiguationRules get_TemplateFunctionsDisambiguationRules();
    public abstract virtual bool get_HasObjectTemplateParameters();
    public abstract virtual bool get_RequiresParameterNameInFunctionDefinition();
    public abstract virtual bool get_HasCpp11StyleAttributes();
    public abstract virtual bool get_HasClangExtensions();
    public abstract virtual bool get_HasGnuExtensions();
    public abstract virtual bool get_HasGnuKeywords();
    public abstract virtual bool get_HasGCCAutoType();
    public abstract virtual bool get_HasMsKeywords();
    public abstract virtual bool get_HasGnuBuiltins();
    public abstract virtual bool get_HasHasBuiltin();
    public abstract virtual bool get_HasHasFeature();
    public abstract virtual bool get_HasHasExtension();
    public abstract virtual bool get_HasExperimentalLibrary();
    public abstract virtual bool get_HasStringBuiltins();
    public abstract virtual bool get_HasBuiltinIsConstantEvaluated();
    public abstract virtual bool get_HasClangAtomicsBuiltins();
    public abstract virtual bool get_IgnoreNonClassTypedefsInQualifierLookup();
    public abstract virtual CppTypeInfoNamespace get_TypeInfoNamespace();
    public abstract virtual bool get_HasMsProperties();
    public abstract virtual CppStringLiteralToPointerConversion get_StringLiteralToPointerConversion();
    public abstract virtual bool get_LongToIntIsNarrowingConversion();
    public abstract virtual bool get_LongLongToLongIsNarrowingConversion();
    public abstract virtual bool get_TreatErrorsInTemplatesAsWarnings();
    public abstract virtual bool get_VCTraditionalPreprocessor();
    public abstract virtual bool get_HasIfConsteval();
    public abstract virtual bool get_HasCpp23Operators();
    public abstract virtual bool get_HasC99Restrict();
    public abstract virtual bool get_HasBuiltinSourceLocation();
    public abstract virtual bool get_HasBuiltinBitCast();
    public abstract virtual bool get_HasBuiltinLaunder();
    public abstract virtual bool get_AllowNamespaceLevelInlineAsm();
    public abstract virtual CppABI get_ABI();
    public abstract virtual bool HasTypeTrait(CppConfigurableTypeTrait kind);
    public abstract virtual IReadOnlyDictionary`2<string, PragmaCommand> get_Pragmas();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Language.CppLanguageDialectBase : object {
    public static PragmaCommand WarningPragmaCommand;
    public static PragmaCommand RegionPragmaCommand;
    public static PragmaCommand EndRegionPragmaCommand;
    public static PragmaCommand OncePragmaCommand;
    public static ImmutableArray`1<PragmaCommand> RegionPragmaCommands;
    private static IReadOnlyDictionary`2<string, PragmaCommand> ourPragmas;
    private CppCallingConvention myDefaultCallingConvention;
    protected bool myIsMachine64Bit;
    public IReadOnlyDictionary`2<string, PragmaCommand> Pragmas { get; }
    public CppLanguageKind LanguageKind { get; }
    public int SizeOfPointer { get; }
    public int SizeOfLong { get; }
    public int SizeOfWcharT { get; }
    public bool IgnoreStdFastAndThiscall { get; }
    public CppSizeTUnderlyingType SizeTUnderlyingType { get; }
    public Cpp__NullUnderlyingType __NullUnderlying { get; }
    public bool BuiltinWchar { get; }
    public bool BuiltinChar1632 { get; }
    public CppCallingConvention DefaultCallingConvention { get; }
    public CppCallingConvention DefaultMemberCallingConvention { get; }
    public CppCallingConvention DefaultCtorDtorCallingConvention { get; }
    public CppCallingConventionsInLambdaToFunctionPointerConversion LambdaCallingConventions { get; }
    public CppAutoBehavior AutoBehavior { get; }
    public bool HasConstexpr { get; }
    public bool HasC23Bool { get; }
    public bool HasC23Typeof { get; }
    public bool HasC23Attributes { get; }
    public bool HasC23HasCAttribute { get; }
    public bool HasCpp14AutoWithListInitFix { get; }
    public bool HasImplicitConstOnConstexprMemberFunctions { get; }
    public bool HasNullPtr { get; }
    public bool HasNoexcept { get; }
    public bool NoexceptIsPartOfFunctionType { get; }
    public bool AllowsRefStructs { get; }
    public bool AllowsGenerics { get; }
    public bool AllowsUserDefinedLiterals { get; }
    public bool AllowsSizeTLiterals { get; }
    public bool HasExplicitConversionOperators { get; }
    public bool HasExplicitThisParameter { get; }
    public bool HasDelegatingConstructors { get; }
    public bool HasDefaultedAndDeletedFunctions { get; }
    public bool HasNestedNamespaces { get; }
    public bool HasOverride { get; }
    public bool HasExportKeyword { get; }
    public bool HasIfInitializers { get; }
    public bool HasRangeForInitializers { get; }
    public bool HasInlineVariables { get; }
    public bool HasConstexprIf { get; }
    public bool HasGuaranteedCopyElision { get; }
    public bool HasCopyElisionInCopyInitDeclarator { get; }
    public bool HasAggregatesWithBaseClasses { get; }
    public bool HasAggregateParenInit { get; }
    public bool ProhibitAggregatesWithUserDeclaredConstructors { get; }
    public bool HasCTAD { get; }
    public bool HasStructuredBindings { get; }
    public bool HasCTADForAggregatesAndTypeAliases { get; }
    public bool HasCoroutines { get; }
    public bool HasConcepts { get; }
    public bool HasModules { get; }
    public bool HasTrailingReturnTypeSyntax { get; }
    public bool VariableDeclarationRulesAreC89Compatible { get; }
    public bool PreferCopyCtorOverUserDefined { get; }
    public bool HasAlternativeOperators { get; }
    public bool HasThreeWayComparison { get; }
    public bool HasDefaultConstructibleAndAssignableStatelessLambdas { get; }
    public bool HasChar8 { get; }
    public bool HasConsteval { get; }
    public bool HasConstinit { get; }
    public bool HasUsingEnum { get; }
    public bool HasCpp20Attributes { get; }
    public bool HasCpp20StructuredBindings { get; }
    public bool HasCpp17Attributes { get; }
    public bool AllowBindingRValueToLValueReference { get; }
    public bool HasFamiliarTemplateSyntaxForGenericLambdas { get; }
    public bool LambdaIsImplicitlyConstexpr { get; }
    public bool HasConstexprVoidFunctions { get; }
    public bool HasConstexprVirtualFunctions { get; }
    public bool HasDesignatedInitialization { get; }
    public bool HasMultidimensionalSubscriptOperator { get; }
    public CppTemplateFunctionDisambiguationRules TemplateFunctionsDisambiguationRules { get; }
    public bool HasObjectTemplateParameters { get; }
    public bool RequiresParameterNameInFunctionDefinition { get; }
    public bool HasCpp11StyleAttributes { get; }
    public bool HasMsKeywords { get; }
    public bool HasClangExtensions { get; }
    public bool HasGnuExtensions { get; }
    public bool HasGnuKeywords { get; }
    public bool HasGnuBuiltins { get; }
    public bool HasHasBuiltin { get; }
    public bool HasHasFeature { get; }
    public bool HasHasExtension { get; }
    public bool HasExperimentalLibrary { get; }
    public bool HasGCCAutoType { get; }
    public bool HasStringBuiltins { get; }
    public bool HasBuiltinIsConstantEvaluated { get; }
    public bool HasClangAtomicsBuiltins { get; }
    public bool IgnoreNonClassTypedefsInQualifierLookup { get; }
    public CppTypeInfoNamespace TypeInfoNamespace { get; }
    public bool HasMsProperties { get; }
    public CppStringLiteralToPointerConversion StringLiteralToPointerConversion { get; }
    public bool LongToIntIsNarrowingConversion { get; }
    public bool LongLongToLongIsNarrowingConversion { get; }
    public bool TreatErrorsInTemplatesAsWarnings { get; }
    public bool VCTraditionalPreprocessor { get; }
    public bool HasIfConsteval { get; }
    public bool HasCpp23Operators { get; }
    public bool HasC99Restrict { get; }
    public bool HasBuiltinSourceLocation { get; }
    public bool HasBuiltinBitCast { get; }
    public bool HasBuiltinLaunder { get; }
    public bool AllowNamespaceLevelInlineAsm { get; }
    public CppABI ABI { get; }
    protected CppLanguageDialectBase(bool isMachine64Bit, DefaultCallingConvention defaultCallingConvention);
    private static CppLanguageDialectBase();
    public virtual IReadOnlyDictionary`2<string, PragmaCommand> get_Pragmas();
    public abstract virtual CppLanguageKind get_LanguageKind();
    public virtual int get_SizeOfPointer();
    public virtual int get_SizeOfLong();
    public virtual int get_SizeOfWcharT();
    public virtual bool get_IgnoreStdFastAndThiscall();
    public virtual CppSizeTUnderlyingType get_SizeTUnderlyingType();
    public virtual Cpp__NullUnderlyingType get___NullUnderlying();
    public abstract virtual bool get_BuiltinWchar();
    public abstract virtual bool get_BuiltinChar1632();
    public virtual CppCallingConvention get_DefaultCallingConvention();
    public abstract virtual CppCallingConvention get_DefaultMemberCallingConvention();
    public abstract virtual CppCallingConvention get_DefaultCtorDtorCallingConvention();
    public abstract virtual CppCallingConventionsInLambdaToFunctionPointerConversion get_LambdaCallingConventions();
    public abstract virtual CppAutoBehavior get_AutoBehavior();
    public abstract virtual bool get_HasConstexpr();
    public abstract virtual bool get_HasC23Bool();
    public abstract virtual bool get_HasC23Typeof();
    public abstract virtual bool get_HasC23Attributes();
    public abstract virtual bool get_HasC23HasCAttribute();
    public abstract virtual bool get_HasCpp14AutoWithListInitFix();
    public abstract virtual bool get_HasImplicitConstOnConstexprMemberFunctions();
    public abstract virtual bool get_HasNullPtr();
    public abstract virtual bool get_HasNoexcept();
    public abstract virtual bool get_NoexceptIsPartOfFunctionType();
    public abstract virtual bool get_AllowsRefStructs();
    public abstract virtual bool get_AllowsGenerics();
    public abstract virtual bool get_AllowsUserDefinedLiterals();
    public abstract virtual bool get_AllowsSizeTLiterals();
    public abstract virtual bool get_HasExplicitConversionOperators();
    public abstract virtual bool get_HasExplicitThisParameter();
    public abstract virtual bool get_HasDelegatingConstructors();
    public abstract virtual bool get_HasDefaultedAndDeletedFunctions();
    public abstract virtual bool get_HasNestedNamespaces();
    public abstract virtual bool get_HasOverride();
    public abstract virtual bool get_HasExportKeyword();
    public abstract virtual bool get_HasIfInitializers();
    public abstract virtual bool get_HasRangeForInitializers();
    public abstract virtual bool get_HasInlineVariables();
    public abstract virtual bool get_HasConstexprIf();
    public abstract virtual bool get_HasGuaranteedCopyElision();
    public virtual bool get_HasCopyElisionInCopyInitDeclarator();
    public abstract virtual bool get_HasAggregatesWithBaseClasses();
    public abstract virtual bool get_HasAggregateParenInit();
    public abstract virtual bool get_ProhibitAggregatesWithUserDeclaredConstructors();
    public abstract virtual bool get_HasCTAD();
    public abstract virtual bool get_HasStructuredBindings();
    public abstract virtual bool get_HasCTADForAggregatesAndTypeAliases();
    public abstract virtual bool get_HasCoroutines();
    public abstract virtual bool get_HasConcepts();
    public abstract virtual bool get_HasModules();
    public abstract virtual bool get_HasTrailingReturnTypeSyntax();
    public abstract virtual bool get_VariableDeclarationRulesAreC89Compatible();
    public abstract virtual bool get_PreferCopyCtorOverUserDefined();
    public abstract virtual bool get_HasAlternativeOperators();
    public abstract virtual bool get_HasThreeWayComparison();
    public abstract virtual bool get_HasDefaultConstructibleAndAssignableStatelessLambdas();
    public abstract virtual bool get_HasChar8();
    public abstract virtual bool get_HasConsteval();
    public abstract virtual bool get_HasConstinit();
    public abstract virtual bool get_HasUsingEnum();
    public abstract virtual bool get_HasCpp20Attributes();
    public abstract virtual bool get_HasCpp20StructuredBindings();
    public abstract virtual bool get_HasCpp17Attributes();
    public abstract virtual bool get_AllowBindingRValueToLValueReference();
    public abstract virtual bool get_HasFamiliarTemplateSyntaxForGenericLambdas();
    public abstract virtual bool get_LambdaIsImplicitlyConstexpr();
    public abstract virtual bool get_HasConstexprVoidFunctions();
    public abstract virtual bool get_HasConstexprVirtualFunctions();
    public abstract virtual bool get_HasDesignatedInitialization();
    public abstract virtual bool get_HasMultidimensionalSubscriptOperator();
    public abstract virtual CppTemplateFunctionDisambiguationRules get_TemplateFunctionsDisambiguationRules();
    public abstract virtual bool get_HasObjectTemplateParameters();
    public abstract virtual bool get_RequiresParameterNameInFunctionDefinition();
    public abstract virtual bool get_HasCpp11StyleAttributes();
    public abstract virtual bool get_HasMsKeywords();
    public abstract virtual bool get_HasClangExtensions();
    public abstract virtual bool get_HasGnuExtensions();
    public abstract virtual bool get_HasGnuKeywords();
    public abstract virtual bool get_HasGnuBuiltins();
    public abstract virtual bool get_HasHasBuiltin();
    public abstract virtual bool get_HasHasFeature();
    public abstract virtual bool get_HasHasExtension();
    public abstract virtual bool get_HasExperimentalLibrary();
    public abstract virtual bool get_HasGCCAutoType();
    public abstract virtual bool get_HasStringBuiltins();
    public abstract virtual bool get_HasBuiltinIsConstantEvaluated();
    public abstract virtual bool get_HasClangAtomicsBuiltins();
    public virtual bool get_IgnoreNonClassTypedefsInQualifierLookup();
    public abstract virtual CppTypeInfoNamespace get_TypeInfoNamespace();
    public abstract virtual bool get_HasMsProperties();
    public abstract virtual CppStringLiteralToPointerConversion get_StringLiteralToPointerConversion();
    public abstract virtual bool get_LongToIntIsNarrowingConversion();
    public abstract virtual bool get_LongLongToLongIsNarrowingConversion();
    public virtual bool get_TreatErrorsInTemplatesAsWarnings();
    public virtual bool get_VCTraditionalPreprocessor();
    public abstract virtual bool get_HasIfConsteval();
    public abstract virtual bool get_HasCpp23Operators();
    public abstract virtual bool get_HasC99Restrict();
    public abstract virtual bool get_HasBuiltinSourceLocation();
    public abstract virtual bool get_HasBuiltinBitCast();
    public abstract virtual bool get_HasBuiltinLaunder();
    public abstract virtual bool get_AllowNamespaceLevelInlineAsm();
    public abstract virtual CppABI get_ABI();
    public abstract virtual bool HasTypeTrait(CppConfigurableTypeTrait kind);
    public virtual bool Equals(CppLanguageDialect other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal static void <ToString>g__DumpProperty|220_0(T param, string paramName, <>c__DisplayClass220_0& );
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Language.CppLanguageDialectUtil : object {
    [ExtensionAttribute]
public static CppLanguageDialect GetLanguageDialect(ICppResolveEntity ent);
    [ExtensionAttribute]
public static CppLanguageDialect GetLanguageDialect(ICppCompositeNode node);
    [ExtensionAttribute]
public static CppLanguageDialect GetLanguageDialect(CppViewPos& vp);
    [ExtensionAttribute]
public static bool IsC(CppLanguageDialect dialect);
    [ExtensionAttribute]
public static bool IsCpp(CppLanguageDialect dialect);
    [ExtensionAttribute]
public static bool IsHLSL(CppLanguageDialect dialect);
    [ExtensionAttribute]
public static bool IsLong64(CppLanguageDialect dialect);
    [ExtensionAttribute]
public static bool IsBlockShaders(CppLanguageDialect dialect, CppFileLocation file);
}
public enum JetBrains.ReSharper.Psi.Cpp.Language.CppLanguageKind : Enum {
    public byte value__;
    public static CppLanguageKind C;
    public static CppLanguageKind Cpp;
    public static CppLanguageKind CppCli;
    public static CppLanguageKind CppCx;
    public static CppLanguageKind HLSL;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Language.CppLanguageKindUtil : object {
    [ExtensionAttribute]
public static bool IsCppDialect(CppLanguageKind languageKind);
    [ExtensionAttribute]
public static bool IsHLSLDialect(CppLanguageKind languageKind);
}
public class JetBrains.ReSharper.Psi.Cpp.Language.CppLinkageEntityDeclaredElement : CppDeclaredElementBase {
    private ICppLinkageEntity myLinkageEntity;
    private CppGlobalSymbolCache myGlobalCache;
    public string ShortName { get; }
    public CppLinkageEntityDeclaredElement(IPsiServices services, ICppLinkageEntity linkageEntity);
    public virtual IEnumerable`1<ICppSymbol> GetSymbols();
    public virtual string get_ShortName();
    public virtual DeclaredElementType GetElementType();
    public virtual CppAccessibility GetAccessibility();
    public virtual bool IsValid();
    public sealed virtual CppNameAndTemplateParameters PresentName(bool withTemplateParameters);
    public sealed virtual string PresentContainingNamespace();
    public sealed virtual string PresentContainingType(CppDeclaredElementType& type);
    public sealed virtual CppQualType GetCppType();
    public virtual Result Accept(ICppDeclaredElementVisitor`1<Result> visitor);
    public static ICppLinkageEntity Unwrap(IDeclaredElement declEl);
    public static IList`1<IDeclaredElement> CreateWrappers(IPsiServices services, IEnumerable`1<ICppLinkageEntity> entities);
    public ICppLinkageEntity GetLinkageEntity();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Language.CppLinuxOrUnknownLanguageDialect : CppOrCDialectWithStandard {
    private bool myIsClang;
    public CppSizeTUnderlyingType SizeTUnderlyingType { get; }
    public int SizeOfLong { get; }
    public int SizeOfWcharT { get; }
    public CppAutoBehavior AutoBehavior { get; }
    public bool HasMsKeywords { get; }
    public bool HasClangExtensions { get; }
    public bool HasGnuExtensions { get; }
    public bool HasGnuKeywords { get; }
    public bool HasGnuBuiltins { get; }
    public bool HasHasBuiltin { get; }
    public bool HasHasFeature { get; }
    public bool HasHasExtension { get; }
    public bool HasExperimentalLibrary { get; }
    public bool HasGCCAutoType { get; }
    public bool HasClangAtomicsBuiltins { get; }
    public CppTypeInfoNamespace TypeInfoNamespace { get; }
    public bool BuiltinWchar { get; }
    public bool BuiltinChar1632 { get; }
    public bool HasCpp14AutoWithListInitFix { get; }
    public bool HasImplicitConstOnConstexprMemberFunctions { get; }
    public bool HasNullPtr { get; }
    public bool AllowsUserDefinedLiterals { get; }
    public bool AllowsSizeTLiterals { get; }
    public bool HasExplicitConversionOperators { get; }
    public bool HasDelegatingConstructors { get; }
    public bool HasDefaultedAndDeletedFunctions { get; }
    public bool HasOverride { get; }
    public bool VariableDeclarationRulesAreC89Compatible { get; }
    public bool PreferCopyCtorOverUserDefined { get; }
    public bool HasAlternativeOperators { get; }
    public bool AllowBindingRValueToLValueReference { get; }
    public bool HasStringBuiltins { get; }
    public bool HasCpp11StyleAttributes { get; }
    public bool HasRangeForInitializers { get; }
    public bool HasDesignatedInitialization { get; }
    public CppCallingConventionsInLambdaToFunctionPointerConversion LambdaCallingConventions { get; }
    public CppTemplateFunctionDisambiguationRules TemplateFunctionsDisambiguationRules { get; }
    public bool HasMsProperties { get; }
    public CppStringLiteralToPointerConversion StringLiteralToPointerConversion { get; }
    public bool LongToIntIsNarrowingConversion { get; }
    public bool LongLongToLongIsNarrowingConversion { get; }
    public CppABI ABI { get; }
    public bool HasBuiltinSourceLocation { get; }
    public bool AllowNamespaceLevelInlineAsm { get; }
    public CppLinuxOrUnknownLanguageDialect(bool isMachine64Bit, DefaultCallingConvention defaultCallingConvention, CppLanguageKind kind, CppLanguageStandard cppStandard, CLanguageStandard cStandard, bool isClang, bool builtinWchar);
    public virtual CppSizeTUnderlyingType get_SizeTUnderlyingType();
    public virtual int get_SizeOfLong();
    public virtual int get_SizeOfWcharT();
    public virtual CppAutoBehavior get_AutoBehavior();
    public virtual bool get_HasMsKeywords();
    public virtual bool get_HasClangExtensions();
    public virtual bool get_HasGnuExtensions();
    public virtual bool get_HasGnuKeywords();
    public virtual bool get_HasGnuBuiltins();
    public virtual bool get_HasHasBuiltin();
    public virtual bool get_HasHasFeature();
    public virtual bool get_HasHasExtension();
    public virtual bool get_HasExperimentalLibrary();
    public virtual bool get_HasGCCAutoType();
    public virtual bool get_HasClangAtomicsBuiltins();
    public virtual CppTypeInfoNamespace get_TypeInfoNamespace();
    public virtual bool get_BuiltinWchar();
    public virtual bool get_BuiltinChar1632();
    public virtual bool get_HasCpp14AutoWithListInitFix();
    public virtual bool get_HasImplicitConstOnConstexprMemberFunctions();
    public virtual bool get_HasNullPtr();
    public virtual bool get_AllowsUserDefinedLiterals();
    public virtual bool get_AllowsSizeTLiterals();
    public virtual bool get_HasExplicitConversionOperators();
    public virtual bool get_HasDelegatingConstructors();
    public virtual bool get_HasDefaultedAndDeletedFunctions();
    public virtual bool get_HasOverride();
    public virtual bool get_VariableDeclarationRulesAreC89Compatible();
    public virtual bool get_PreferCopyCtorOverUserDefined();
    public virtual bool get_HasAlternativeOperators();
    public virtual bool get_AllowBindingRValueToLValueReference();
    public virtual bool get_HasStringBuiltins();
    public virtual bool get_HasCpp11StyleAttributes();
    public virtual bool get_HasRangeForInitializers();
    public virtual bool get_HasDesignatedInitialization();
    public virtual CppCallingConventionsInLambdaToFunctionPointerConversion get_LambdaCallingConventions();
    public virtual CppTemplateFunctionDisambiguationRules get_TemplateFunctionsDisambiguationRules();
    public virtual bool get_HasMsProperties();
    public virtual CppStringLiteralToPointerConversion get_StringLiteralToPointerConversion();
    public virtual bool get_LongToIntIsNarrowingConversion();
    public virtual bool get_LongLongToLongIsNarrowingConversion();
    public virtual CppABI get_ABI();
    public virtual bool get_HasBuiltinSourceLocation();
    public virtual bool get_AllowNamespaceLevelInlineAsm();
    public virtual bool HasTypeTrait(CppConfigurableTypeTrait kind);
    public virtual bool Equals(CppLanguageDialect other);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Language.CppModuleDeclaredElement : CppDeclaredElementBase {
    [CompilerGeneratedAttribute]
private CppModuleId <ModuleId>k__BackingField;
    public CppModuleId ModuleId { get; }
    public string ShortName { get; }
    public CppModuleDeclaredElement(IPsiServices services, CppModuleId moduleId);
    [CompilerGeneratedAttribute]
public CppModuleId get_ModuleId();
    public virtual CppAccessibility GetAccessibility();
    public virtual Result Accept(ICppDeclaredElementVisitor`1<Result> visitor);
    public virtual bool IsValid();
    public virtual string get_ShortName();
    public virtual DeclaredElementType GetElementType();
    public virtual IEnumerable`1<ICppSymbol> GetSymbols();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Language.CppMSFSLanguageDialect : CppLinuxOrUnknownLanguageDialect {
    public CppSizeTUnderlyingType SizeTUnderlyingType { get; }
    public CppMSFSLanguageDialect(DefaultCallingConvention callingConvention, CppLanguageKind languageKind, CppLanguageStandard cppStandard, CLanguageStandard cStandard, bool builtinWchar);
    public virtual CppSizeTUnderlyingType get_SizeTUnderlyingType();
}
public class JetBrains.ReSharper.Psi.Cpp.Language.CppMSVCDialect : CppOrCDialectWithStandard {
    private bool myHasAlternativeOperators;
    private bool myHasCoroutines;
    private bool myPermissive;
    private bool myVCTraditionalPreprocessor;
    [CompilerGeneratedAttribute]
private PlatformToolsetVersion <ToolsetVersion>k__BackingField;
    public bool BuiltinChar1632 { get; }
    public CppAutoBehavior AutoBehavior { get; }
    public bool HasConstexpr { get; }
    public bool HasCpp14AutoWithListInitFix { get; }
    public bool HasImplicitConstOnConstexprMemberFunctions { get; }
    public bool HasNullPtr { get; }
    public bool HasNoexcept { get; }
    public bool AllowsUserDefinedLiterals { get; }
    public bool AllowsSizeTLiterals { get; }
    public bool HasExplicitConversionOperators { get; }
    public bool HasDelegatingConstructors { get; }
    public bool HasDefaultedAndDeletedFunctions { get; }
    public bool HasOverride { get; }
    public bool HasExportKeyword { get; }
    public bool HasConcepts { get; }
    public bool HasCoroutines { get; }
    public bool VariableDeclarationRulesAreC89Compatible { get; }
    public bool PreferCopyCtorOverUserDefined { get; }
    public bool HasCopyElisionInCopyInitDeclarator { get; }
    public bool HasAlternativeOperators { get; }
    public bool AllowBindingRValueToLValueReference { get; }
    public bool IgnoreNonClassTypedefsInQualifierLookup { get; }
    public bool HasCpp11StyleAttributes { get; }
    public bool HasMsKeywords { get; }
    public bool HasClangExtensions { get; }
    public bool HasGnuExtensions { get; }
    public bool HasGnuBuiltins { get; }
    public bool HasHasBuiltin { get; }
    public bool HasHasFeature { get; }
    public bool HasHasExtension { get; }
    public bool HasExperimentalLibrary { get; }
    public bool HasGCCAutoType { get; }
    public bool HasGnuKeywords { get; }
    public bool HasStringBuiltins { get; }
    public bool HasClangAtomicsBuiltins { get; }
    public CppTypeInfoNamespace TypeInfoNamespace { get; }
    public bool HasMsProperties { get; }
    public CppStringLiteralToPointerConversion StringLiteralToPointerConversion { get; }
    public bool LongToIntIsNarrowingConversion { get; }
    public bool LongLongToLongIsNarrowingConversion { get; }
    public PlatformToolsetVersion ToolsetVersion { get; }
    public CppABI ABI { get; }
    public bool VCTraditionalPreprocessor { get; }
    public bool HasBuiltinSourceLocation { get; }
    public bool AllowNamespaceLevelInlineAsm { get; }
    public bool TreatErrorsInTemplatesAsWarnings { get; }
    public CppMSVCDialect(bool isMachine64Bit, DefaultCallingConvention defaultCallingConvention, CppLanguageKind kind, CppLanguageStandard cppStandard, CLanguageStandard cStandard, PlatformToolsetVersion toolset, bool conformanceMode, bool conformantPreprocessor, bool disableLanguageExtensions, bool hasCoroutines, bool builtinWchar);
    public virtual bool get_BuiltinChar1632();
    public virtual CppAutoBehavior get_AutoBehavior();
    public virtual bool HasTypeTrait(CppConfigurableTypeTrait kind);
    public virtual bool get_HasConstexpr();
    public virtual bool get_HasCpp14AutoWithListInitFix();
    public virtual bool get_HasImplicitConstOnConstexprMemberFunctions();
    public virtual bool get_HasNullPtr();
    public virtual bool get_HasNoexcept();
    public virtual bool get_AllowsUserDefinedLiterals();
    public virtual bool get_AllowsSizeTLiterals();
    public virtual bool get_HasExplicitConversionOperators();
    public virtual bool get_HasDelegatingConstructors();
    public virtual bool get_HasDefaultedAndDeletedFunctions();
    public virtual bool get_HasOverride();
    public virtual bool get_HasExportKeyword();
    public virtual bool get_HasConcepts();
    public virtual bool get_HasCoroutines();
    public virtual bool get_VariableDeclarationRulesAreC89Compatible();
    public virtual bool get_PreferCopyCtorOverUserDefined();
    public virtual bool get_HasCopyElisionInCopyInitDeclarator();
    public virtual bool get_HasAlternativeOperators();
    public virtual bool get_AllowBindingRValueToLValueReference();
    public virtual bool get_IgnoreNonClassTypedefsInQualifierLookup();
    public virtual bool get_HasCpp11StyleAttributes();
    public virtual bool get_HasMsKeywords();
    public virtual bool get_HasClangExtensions();
    public virtual bool get_HasGnuExtensions();
    public virtual bool get_HasGnuBuiltins();
    public virtual bool get_HasHasBuiltin();
    public virtual bool get_HasHasFeature();
    public virtual bool get_HasHasExtension();
    public virtual bool get_HasExperimentalLibrary();
    public virtual bool get_HasGCCAutoType();
    public virtual bool get_HasGnuKeywords();
    public virtual bool get_HasStringBuiltins();
    public virtual bool get_HasClangAtomicsBuiltins();
    public virtual CppTypeInfoNamespace get_TypeInfoNamespace();
    public virtual bool get_HasMsProperties();
    public virtual CppStringLiteralToPointerConversion get_StringLiteralToPointerConversion();
    public virtual bool get_LongToIntIsNarrowingConversion();
    public virtual bool get_LongLongToLongIsNarrowingConversion();
    [CompilerGeneratedAttribute]
public PlatformToolsetVersion get_ToolsetVersion();
    public virtual CppABI get_ABI();
    public virtual bool get_VCTraditionalPreprocessor();
    public virtual bool get_HasBuiltinSourceLocation();
    public virtual bool get_AllowNamespaceLevelInlineAsm();
    public virtual bool Equals(CppLanguageDialect other);
    public virtual int GetHashCode();
    protected virtual bool isCppSince(CppLanguageStandard standard);
    protected virtual bool isCSince(CLanguageStandard standard);
    public void MakeCppCLI(bool v);
    public virtual bool get_TreatErrorsInTemplatesAsWarnings();
}
public class JetBrains.ReSharper.Psi.Cpp.Language.CppNameAndTemplateParameters : ValueType {
    public string Name;
    public String[] TemplateParameters;
    public string RequiresClause;
    public CppNameAndTemplateParameters(string name, String[] templateParameters);
    public bool IsEmpty();
    public string Present();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Language.CppOrCDialectBase : CppLanguageDialectBase {
    protected CppLanguageKind myKind;
    public CppLanguageKind LanguageKind { get; }
    public CppCallingConvention DefaultMemberCallingConvention { get; }
    public CppCallingConvention DefaultCtorDtorCallingConvention { get; }
    public bool RequiresParameterNameInFunctionDefinition { get; }
    public bool AllowsRefStructs { get; }
    public bool AllowsGenerics { get; }
    protected CppOrCDialectBase(bool isMachine64Bit, DefaultCallingConvention defaultCallingConvention, CppLanguageKind kind);
    public virtual CppLanguageKind get_LanguageKind();
    public virtual CppCallingConvention get_DefaultMemberCallingConvention();
    public virtual CppCallingConvention get_DefaultCtorDtorCallingConvention();
    public virtual bool get_RequiresParameterNameInFunctionDefinition();
    public virtual bool get_AllowsRefStructs();
    public virtual bool get_AllowsGenerics();
    protected bool isC();
    protected bool isCpp();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Language.CppOrCDialectWithStandard : CppOrCDialectBase {
    private bool myBuiltinWchar;
    protected CppLanguageStandard myCppStandard;
    protected CLanguageStandard myCStandard;
    public bool HasExportKeyword { get; }
    public bool BuiltinChar1632 { get; }
    public bool HasNullPtr { get; }
    public bool HasNoexcept { get; }
    public bool AllowsUserDefinedLiterals { get; }
    public bool AllowsSizeTLiterals { get; }
    public bool HasExplicitConversionOperators { get; }
    public bool HasExplicitThisParameter { get; }
    public bool HasDelegatingConstructors { get; }
    public bool HasDefaultedAndDeletedFunctions { get; }
    public bool HasOverride { get; }
    public bool HasCpp11StyleAttributes { get; }
    public bool HasConstexpr { get; }
    public bool HasC23Bool { get; }
    public bool HasC23Typeof { get; }
    public bool HasC23Attributes { get; }
    public bool HasC23HasCAttribute { get; }
    public bool HasImplicitConstOnConstexprMemberFunctions { get; }
    public bool HasCpp14AutoWithListInitFix { get; }
    public bool HasStringBuiltins { get; }
    public bool HasNestedNamespaces { get; }
    public bool HasIfInitializers { get; }
    public bool HasInlineVariables { get; }
    public bool HasConstexprIf { get; }
    public bool HasGuaranteedCopyElision { get; }
    public bool HasAggregatesWithBaseClasses { get; }
    public bool HasCTAD { get; }
    public bool HasStructuredBindings { get; }
    public bool HasCpp17Attributes { get; }
    public bool NoexceptIsPartOfFunctionType { get; }
    public bool LambdaIsImplicitlyConstexpr { get; }
    public bool HasRangeForInitializers { get; }
    public bool HasThreeWayComparison { get; }
    public bool HasDefaultConstructibleAndAssignableStatelessLambdas { get; }
    public bool ProhibitAggregatesWithUserDeclaredConstructors { get; }
    public bool HasAggregateParenInit { get; }
    public bool HasCTADForAggregatesAndTypeAliases { get; }
    public bool HasUsingEnum { get; }
    public bool HasConstinit { get; }
    public bool HasConsteval { get; }
    public bool HasCpp20StructuredBindings { get; }
    public bool HasCpp20Attributes { get; }
    public bool HasChar8 { get; }
    public bool HasFamiliarTemplateSyntaxForGenericLambdas { get; }
    public bool HasBuiltinIsConstantEvaluated { get; }
    public bool HasObjectTemplateParameters { get; }
    public bool HasConcepts { get; }
    public bool HasCoroutines { get; }
    public bool HasModules { get; }
    public bool HasTrailingReturnTypeSyntax { get; }
    public bool HasConstexprVoidFunctions { get; }
    public bool HasConstexprVirtualFunctions { get; }
    public bool HasDesignatedInitialization { get; }
    public bool HasMultidimensionalSubscriptOperator { get; }
    public bool HasIfConsteval { get; }
    public bool HasCpp23Operators { get; }
    public bool HasC99Restrict { get; }
    public bool HasBuiltinBitCast { get; }
    public bool HasBuiltinLaunder { get; }
    public CppTemplateFunctionDisambiguationRules TemplateFunctionsDisambiguationRules { get; }
    public CppAutoBehavior AutoBehavior { get; }
    public bool BuiltinWchar { get; }
    public CppCallingConventionsInLambdaToFunctionPointerConversion LambdaCallingConventions { get; }
    protected bool SinceCpp11 { get; }
    protected bool SinceCpp14 { get; }
    protected bool SinceCpp11UntilCpp14 { get; }
    protected bool SinceCpp17 { get; }
    protected bool SinceCpp20 { get; }
    protected bool SinceCpp23 { get; }
    protected bool SinceC99 { get; }
    protected bool SinceC23 { get; }
    protected CppOrCDialectWithStandard(bool isMachine64Bit, DefaultCallingConvention defaultCallingConvention, CppLanguageKind kind, CppLanguageStandard cppStandard, CLanguageStandard cStandard, bool builtinWchar);
    public virtual bool get_HasExportKeyword();
    public virtual bool get_BuiltinChar1632();
    public virtual bool get_HasNullPtr();
    public virtual bool get_HasNoexcept();
    public virtual bool get_AllowsUserDefinedLiterals();
    public virtual bool get_AllowsSizeTLiterals();
    public virtual bool get_HasExplicitConversionOperators();
    public virtual bool get_HasExplicitThisParameter();
    public virtual bool get_HasDelegatingConstructors();
    public virtual bool get_HasDefaultedAndDeletedFunctions();
    public virtual bool get_HasOverride();
    public virtual bool get_HasCpp11StyleAttributes();
    public virtual bool get_HasConstexpr();
    public virtual bool get_HasC23Bool();
    public virtual bool get_HasC23Typeof();
    public virtual bool get_HasC23Attributes();
    public virtual bool get_HasC23HasCAttribute();
    public virtual bool get_HasImplicitConstOnConstexprMemberFunctions();
    public virtual bool get_HasCpp14AutoWithListInitFix();
    public virtual bool get_HasStringBuiltins();
    public virtual bool get_HasNestedNamespaces();
    public virtual bool get_HasIfInitializers();
    public virtual bool get_HasInlineVariables();
    public virtual bool get_HasConstexprIf();
    public virtual bool get_HasGuaranteedCopyElision();
    public virtual bool get_HasAggregatesWithBaseClasses();
    public virtual bool get_HasCTAD();
    public virtual bool get_HasStructuredBindings();
    public virtual bool get_HasCpp17Attributes();
    public virtual bool get_NoexceptIsPartOfFunctionType();
    public virtual bool get_LambdaIsImplicitlyConstexpr();
    public virtual bool get_HasRangeForInitializers();
    public virtual bool get_HasThreeWayComparison();
    public virtual bool get_HasDefaultConstructibleAndAssignableStatelessLambdas();
    public virtual bool get_ProhibitAggregatesWithUserDeclaredConstructors();
    public virtual bool get_HasAggregateParenInit();
    public virtual bool get_HasCTADForAggregatesAndTypeAliases();
    public virtual bool get_HasUsingEnum();
    public virtual bool get_HasConstinit();
    public virtual bool get_HasConsteval();
    public virtual bool get_HasCpp20StructuredBindings();
    public virtual bool get_HasCpp20Attributes();
    public virtual bool get_HasChar8();
    public virtual bool get_HasFamiliarTemplateSyntaxForGenericLambdas();
    public virtual bool get_HasBuiltinIsConstantEvaluated();
    public virtual bool get_HasObjectTemplateParameters();
    public virtual bool get_HasConcepts();
    public virtual bool get_HasCoroutines();
    public virtual bool get_HasModules();
    public virtual bool get_HasTrailingReturnTypeSyntax();
    public virtual bool get_HasConstexprVoidFunctions();
    public virtual bool get_HasConstexprVirtualFunctions();
    public virtual bool get_HasDesignatedInitialization();
    public virtual bool get_HasMultidimensionalSubscriptOperator();
    public virtual bool get_HasIfConsteval();
    public virtual bool get_HasCpp23Operators();
    public virtual bool get_HasC99Restrict();
    public virtual bool get_HasBuiltinBitCast();
    public virtual bool get_HasBuiltinLaunder();
    public virtual CppTemplateFunctionDisambiguationRules get_TemplateFunctionsDisambiguationRules();
    public virtual CppAutoBehavior get_AutoBehavior();
    public virtual bool get_BuiltinWchar();
    public virtual CppCallingConventionsInLambdaToFunctionPointerConversion get_LambdaCallingConventions();
    public bool IsCppSince_Hack(CppLanguageStandard standard);
    protected bool get_SinceCpp11();
    protected bool get_SinceCpp14();
    protected bool get_SinceCpp11UntilCpp14();
    protected bool get_SinceCpp17();
    protected bool get_SinceCpp20();
    protected bool get_SinceCpp23();
    protected bool get_SinceC99();
    protected bool get_SinceC23();
    public virtual bool Equals(CppLanguageDialect other);
    public virtual int GetHashCode();
    protected virtual bool isCppSince(CppLanguageStandard standard);
    protected virtual bool isCSince(CLanguageStandard standard);
    protected bool SinceUntilCpp(CppLanguageStandard sinceStd, CppLanguageStandard untilStd);
}
public class JetBrains.ReSharper.Psi.Cpp.Language.CppParserSymbolDeclaredElement : CppDeclaredElementBase {
    private ICppParserSymbol mySymbol;
    public string ShortName { get; }
    public CppParserSymbolDeclaredElement(IPsiServices services, ICppParserSymbol symbol);
    public virtual IEnumerable`1<ICppSymbol> GetSymbols();
    public virtual CppAccessibility GetAccessibility();
    public virtual string get_ShortName();
    public virtual DeclaredElementType GetElementType();
    public virtual bool IsValid();
    public sealed virtual CppNameAndTemplateParameters PresentName(bool withTemplateParameters);
    public sealed virtual string PresentContainingNamespace();
    public sealed virtual string PresentContainingType(CppDeclaredElementType& type);
    public sealed virtual CppQualType GetCppType();
    public virtual Result Accept(ICppDeclaredElementVisitor`1<Result> visitor);
    public static ICppParserSymbol Unwrap(IDeclaredElement declEl);
    public ICppParserSymbol GetSymbol();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public CppNameAndTemplateParameters PresentName(bool withTemplateParameters, bool hideNameQualifier);
    private static CppNameAndTemplateParameters CreateNameAndTemplateParameters(ICppParserSymbol symbol, bool withTemplateParameters, bool hideNameQualifier);
}
public class JetBrains.ReSharper.Psi.Cpp.Language.CppPathDeclaredElement : PathDeclaredElement {
    private CppExternalModule myModule;
    private bool myDirectory;
    public bool IsDirectory { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public CppPathDeclaredElement(IPsiServices psiServices, VirtualFileSystemPath path, bool directory);
    public CppPathDeclaredElement(string shortName, IPsiServices psiServices, VirtualFileSystemPath path, bool directory);
    public virtual bool get_IsDirectory();
    public virtual PsiLanguageType get_PresentationLanguage();
    public virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public virtual DeclaredElementType GetElementType();
    public virtual string ToString();
    private IPsiSourceFile GetPsiSourceFile();
}
[DeclaredElementIconProviderAttribute("100", "16")]
internal class JetBrains.ReSharper.Psi.Cpp.Language.CppPathDeclaredElementImageProvider : object {
    private ProjectModelIcons myIcons;
    public CppPathDeclaredElementImageProvider(ProjectModelIcons icons);
    public virtual IconId GetImageId(IDeclaredElement declaredElement, PsiLanguageType languageType, Boolean& canApplyExtensions);
}
public class JetBrains.ReSharper.Psi.Cpp.Language.CppPathDeclaredElementPresenter : PathDeclaredElementPresenter {
    public static CppPathDeclaredElementPresenter Instance;
    private static CppPathDeclaredElementPresenter();
    protected virtual void FormatEntityKind(IDeclaredElement e, DeclaredElementPresenterStyle style, DeclaredElementPresenterMarking marking, StringBuilder builder);
}
public class JetBrains.ReSharper.Psi.Cpp.Language.CppPreprocessorDeclaredElement : CppDeclaredElementBase {
    private ICppPPSymbol mySymbol;
    private bool myIsInsideCodeFragment;
    public string ShortName { get; }
    public CppPreprocessorDeclaredElement(IPsiServices services, ICppPPSymbol symbol, bool isInsideCodeFragment);
    public virtual string get_ShortName();
    public ICppPPSymbol GetPPSymbol();
    public virtual IEnumerable`1<ICppSymbol> GetSymbols();
    public virtual CppAccessibility GetAccessibility();
    public virtual DeclaredElementType GetElementType();
    public virtual bool IsValid();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual Result Accept(ICppDeclaredElementVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Language.CppResolveEntityDeclaredElement : CppDeclaredElementBase {
    private ICppResolveEntity myEntity;
    public string ShortName { get; }
    public CppResolveEntityDeclaredElement(IPsiServices services, ICppResolveEntity entity);
    public virtual IEnumerable`1<ICppSymbol> GetSymbols();
    public virtual CppAccessibility GetAccessibility();
    public virtual string get_ShortName();
    public virtual DeclaredElementType GetElementType();
    public virtual bool IsValid();
    public sealed virtual CppNameAndTemplateParameters PresentName(bool withTemplateParameters);
    public sealed virtual string PresentContainingNamespace();
    public sealed virtual CppQualType GetCppType();
    public virtual Result Accept(ICppDeclaredElementVisitor`1<Result> visitor);
    public sealed virtual string PresentContainingType(CppDeclaredElementType& type);
    public static FrugalLocalList`1<ICppResolveEntity> Unwrap(IList`1<IDeclaredElement> declaredElements);
    public static ICppResolveEntity Unwrap(IDeclaredElement declEl);
    public static IList`1<IDeclaredElement> CreateWrappers(IPsiServices services, IEnumerable`1<ICppResolveEntity> entities);
    public ICppResolveEntity GetResolveEntity();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    private bool IsBlockShaderSpecificElement();
}
public enum JetBrains.ReSharper.Psi.Cpp.Language.CppSizeTUnderlyingType : Enum {
    public byte value__;
    public static CppSizeTUnderlyingType UNSIGNED;
    public static CppSizeTUnderlyingType UNSIGNED_LONG;
    public static CppSizeTUnderlyingType UNSIGNED_LONGLONG;
}
public enum JetBrains.ReSharper.Psi.Cpp.Language.CppStringLiteralToPointerConversion : Enum {
    public int value__;
    public static CppStringLiteralToPointerConversion Allowed;
    public static CppStringLiteralToPointerConversion Forbidden;
    public static CppStringLiteralToPointerConversion AllowedForVoidPtr;
}
public enum JetBrains.ReSharper.Psi.Cpp.Language.CppTemplateFunctionDisambiguationRules : Enum {
    public byte value__;
    public static CppTemplateFunctionDisambiguationRules Cpp98;
    public static CppTemplateFunctionDisambiguationRules Cpp20;
}
public enum JetBrains.ReSharper.Psi.Cpp.Language.CppTypeInfoNamespace : Enum {
    public byte value__;
    public static CppTypeInfoNamespace Global;
    public static CppTypeInfoNamespace Std;
}
public class JetBrains.ReSharper.Psi.Cpp.Language.CustomLanguageDialect : CppOrCDialectWithStandard {
    public RadLanguageDialect InnerDialect;
    public RadCompilerKind CompilerKind;
    private bool IsMSVCLikeCompiler { get; }
    public CppABI ABI { get; }
    public int SizeOfLong { get; }
    public int SizeOfWcharT { get; }
    public int SizeOfPointer { get; }
    public CppSizeTUnderlyingType SizeTUnderlyingType { get; }
    public bool HasMsProperties { get; }
    public bool LongToIntIsNarrowingConversion { get; }
    public bool LongLongToLongIsNarrowingConversion { get; }
    public CppStringLiteralToPointerConversion StringLiteralToPointerConversion { get; }
    public Cpp__NullUnderlyingType __NullUnderlying { get; }
    public CppTypeInfoNamespace TypeInfoNamespace { get; }
    public bool HasGnuBuiltins { get; }
    public bool HasHasBuiltin { get; }
    public bool HasHasFeature { get; }
    public bool HasHasExtension { get; }
    public bool HasExperimentalLibrary { get; }
    public bool HasClangExtensions { get; }
    public bool HasGnuExtensions { get; }
    public bool HasGCCAutoType { get; }
    public bool HasGnuKeywords { get; }
    public bool HasAlternativeOperators { get; }
    public bool HasMsKeywords { get; }
    public bool AllowBindingRValueToLValueReference { get; }
    public bool PreferCopyCtorOverUserDefined { get; }
    public bool BuiltinWchar { get; }
    public bool VCTraditionalPreprocessor { get; }
    public CppAutoBehavior AutoBehavior { get; }
    public CppTemplateFunctionDisambiguationRules TemplateFunctionsDisambiguationRules { get; }
    public bool HasCoroutines { get; }
    public bool HasConcepts { get; }
    public bool HasObjectTemplateParameters { get; }
    public bool HasBuiltinIsConstantEvaluated { get; }
    public bool HasChar8 { get; }
    public bool HasCpp20StructuredBindings { get; }
    public bool HasConsteval { get; }
    public bool HasConstinit { get; }
    public bool HasUsingEnum { get; }
    public bool HasCTADForAggregatesAndTypeAliases { get; }
    public bool HasAggregateParenInit { get; }
    public bool ProhibitAggregatesWithUserDeclaredConstructors { get; }
    public bool HasDefaultConstructibleAndAssignableStatelessLambdas { get; }
    public bool HasThreeWayComparison { get; }
    public bool HasRangeForInitializers { get; }
    public bool HasStructuredBindings { get; }
    public bool HasCTAD { get; }
    public bool HasAggregatesWithBaseClasses { get; }
    public bool HasGuaranteedCopyElision { get; }
    public bool HasConstexpr { get; }
    public bool HasConstexprIf { get; }
    public bool HasInlineVariables { get; }
    public bool HasIfInitializers { get; }
    public bool HasNestedNamespaces { get; }
    public bool HasStringBuiltins { get; }
    public bool HasCpp14AutoWithListInitFix { get; }
    public bool HasImplicitConstOnConstexprMemberFunctions { get; }
    public bool HasOverride { get; }
    public bool HasDefaultedAndDeletedFunctions { get; }
    public bool HasDelegatingConstructors { get; }
    public bool HasExplicitConversionOperators { get; }
    public bool HasExplicitThisParameter { get; }
    public bool AllowsUserDefinedLiterals { get; }
    public bool AllowsSizeTLiterals { get; }
    public bool HasNoexcept { get; }
    public bool HasNullPtr { get; }
    public bool BuiltinChar1632 { get; }
    public bool HasClangAtomicsBuiltins { get; }
    public bool VariableDeclarationRulesAreC89Compatible { get; }
    public bool HasBuiltinSourceLocation { get; }
    public bool HasBuiltinBitCast { get; }
    public bool HasDesignatedInitialization { get; }
    public bool AllowNamespaceLevelInlineAsm { get; }
    public CppCallingConventionsInLambdaToFunctionPointerConversion LambdaCallingConventions { get; }
    public CustomLanguageDialect(RadLanguageDialect dialect, CppLanguageKind kind, CppLanguageStandard cppStandard, CLanguageStandard cStandard, bool x64, RadCompilerKind compilerKind);
    protected bool Equals(CustomLanguageDialect other);
    public virtual bool Equals(object obj);
    internal CustomLanguageDialect CloneWithOtherLanguageKind(CppLanguageKind kind);
    private bool get_IsMSVCLikeCompiler();
    public virtual CppABI get_ABI();
    public virtual bool HasTypeTrait(CppConfigurableTypeTrait kind);
    public virtual int GetHashCode();
    public virtual int get_SizeOfLong();
    public virtual int get_SizeOfWcharT();
    public virtual int get_SizeOfPointer();
    public virtual CppSizeTUnderlyingType get_SizeTUnderlyingType();
    public virtual bool get_HasMsProperties();
    public virtual bool get_LongToIntIsNarrowingConversion();
    public virtual bool get_LongLongToLongIsNarrowingConversion();
    public virtual CppStringLiteralToPointerConversion get_StringLiteralToPointerConversion();
    public virtual Cpp__NullUnderlyingType get___NullUnderlying();
    public virtual CppTypeInfoNamespace get_TypeInfoNamespace();
    public virtual bool get_HasGnuBuiltins();
    public virtual bool get_HasHasBuiltin();
    public virtual bool get_HasHasFeature();
    public virtual bool get_HasHasExtension();
    public virtual bool get_HasExperimentalLibrary();
    public virtual bool get_HasClangExtensions();
    public virtual bool get_HasGnuExtensions();
    public virtual bool get_HasGCCAutoType();
    public virtual bool get_HasGnuKeywords();
    public virtual bool get_HasAlternativeOperators();
    public virtual bool get_HasMsKeywords();
    public virtual bool get_AllowBindingRValueToLValueReference();
    public virtual bool get_PreferCopyCtorOverUserDefined();
    public virtual bool get_BuiltinWchar();
    public virtual bool get_VCTraditionalPreprocessor();
    public virtual CppAutoBehavior get_AutoBehavior();
    public virtual CppTemplateFunctionDisambiguationRules get_TemplateFunctionsDisambiguationRules();
    public virtual bool get_HasCoroutines();
    public virtual bool get_HasConcepts();
    public virtual bool get_HasObjectTemplateParameters();
    public virtual bool get_HasBuiltinIsConstantEvaluated();
    public virtual bool get_HasChar8();
    public virtual bool get_HasCpp20StructuredBindings();
    public virtual bool get_HasConsteval();
    public virtual bool get_HasConstinit();
    public virtual bool get_HasUsingEnum();
    public virtual bool get_HasCTADForAggregatesAndTypeAliases();
    public virtual bool get_HasAggregateParenInit();
    public virtual bool get_ProhibitAggregatesWithUserDeclaredConstructors();
    public virtual bool get_HasDefaultConstructibleAndAssignableStatelessLambdas();
    public virtual bool get_HasThreeWayComparison();
    public virtual bool get_HasRangeForInitializers();
    public virtual bool get_HasStructuredBindings();
    public virtual bool get_HasCTAD();
    public virtual bool get_HasAggregatesWithBaseClasses();
    public virtual bool get_HasGuaranteedCopyElision();
    public virtual bool get_HasConstexpr();
    public virtual bool get_HasConstexprIf();
    public virtual bool get_HasInlineVariables();
    public virtual bool get_HasIfInitializers();
    public virtual bool get_HasNestedNamespaces();
    public virtual bool get_HasStringBuiltins();
    public virtual bool get_HasCpp14AutoWithListInitFix();
    public virtual bool get_HasImplicitConstOnConstexprMemberFunctions();
    public virtual bool get_HasOverride();
    public virtual bool get_HasDefaultedAndDeletedFunctions();
    public virtual bool get_HasDelegatingConstructors();
    public virtual bool get_HasExplicitConversionOperators();
    public virtual bool get_HasExplicitThisParameter();
    public virtual bool get_AllowsUserDefinedLiterals();
    public virtual bool get_AllowsSizeTLiterals();
    public virtual bool get_HasNoexcept();
    public virtual bool get_HasNullPtr();
    public virtual bool get_BuiltinChar1632();
    public virtual bool get_HasClangAtomicsBuiltins();
    public virtual bool get_VariableDeclarationRulesAreC89Compatible();
    public virtual bool get_HasBuiltinSourceLocation();
    public virtual bool get_HasBuiltinBitCast();
    public virtual bool get_HasDesignatedInitialization();
    public virtual bool get_AllowNamespaceLevelInlineAsm();
    public virtual CppCallingConventionsInLambdaToFunctionPointerConversion get_LambdaCallingConventions();
}
public interface JetBrains.ReSharper.Psi.Cpp.Language.ICppClrDeclaredElement {
    public abstract virtual ICppDeclaredElement GetInner();
}
public interface JetBrains.ReSharper.Psi.Cpp.Language.ICppDeclaredElement {
    public abstract virtual IEnumerable`1<ICppSymbol> GetSymbols();
    public abstract virtual CppAccessibility GetAccessibility();
    public abstract virtual Result Accept(ICppDeclaredElementVisitor`1<Result> visitor);
}
public interface JetBrains.ReSharper.Psi.Cpp.Language.ICppDeclaredElementVisitor`1 {
    public abstract virtual Result Visit(CppLinkageEntityDeclaredElement e);
    public abstract virtual Result Visit(CppParserSymbolDeclaredElement e);
    public abstract virtual Result Visit(CppPreprocessorDeclaredElement e);
    public abstract virtual Result Visit(CppResolveEntityDeclaredElement e);
    public abstract virtual Result Visit(ICppClrDeclaredElement e);
    public abstract virtual Result Visit(CppModuleDeclaredElement e);
}
public interface JetBrains.ReSharper.Psi.Cpp.Language.ICppEntityPresentationInfo {
    public abstract virtual CppNameAndTemplateParameters PresentName(bool withTemplateParameters);
    public abstract virtual string PresentContainingNamespace();
    public abstract virtual string PresentContainingType(CppDeclaredElementType& type);
    public abstract virtual CppQualType GetCppType();
}
public interface JetBrains.ReSharper.Psi.Cpp.Language.ICppTypedDeclaredElement {
}
public class JetBrains.ReSharper.Psi.Cpp.Language.PragmaCommand : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private PragmaCommandFlags <Flags>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Name { get; public set; }
    public PragmaCommandFlags Flags { get; public set; }
    public PragmaCommand(string Name, PragmaCommandFlags Flags);
    [CompilerGeneratedAttribute]
protected PragmaCommand(PragmaCommand original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public PragmaCommandFlags get_Flags();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Flags(PragmaCommandFlags value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(PragmaCommand left, PragmaCommand right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(PragmaCommand left, PragmaCommand right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(PragmaCommand other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual PragmaCommand <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Name, PragmaCommandFlags& Flags);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Language.PragmaCommandEx : object {
    [ExtensionAttribute]
public static PragmaCommand WithSuffix(PragmaCommand command, string suffix);
    public static PragmaCommand[] CreateArrayWithFlags(PragmaCommandFlags flags, String[] names);
    [ExtensionAttribute]
public static bool HasReference(PragmaCommand command);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Language.PragmaCommandFlags : Enum {
    public byte value__;
    public static PragmaCommandFlags None;
    public static PragmaCommandFlags HasRequiredArgs;
    public static PragmaCommandFlags HasOptionalArgs;
    public static PragmaCommandFlags HasRequiredSpec;
    public static PragmaCommandFlags HasOptionalSpec;
    public static PragmaCommandFlags HasFunctionReference;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Language.PragmaFlagsEx : object {
    [ExtensionAttribute]
public static bool IsParameterless(PragmaCommandFlags flags);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Lookup.AfterDotDetectorUnqualifiedNameLookup : ValueType {
    private ICppScopeResolveEntity myDotLeftHandSide;
    public AfterDotDetectorUnqualifiedNameLookup(ICppScopeResolveEntity dotLeftHandSide);
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter);
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Lookup.IUnqualifiedNameLookup.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Lookup.AfterDotUnqualifiedNameLookup : ValueType {
    private ICppScopeResolveEntity myDotLeftHandSide;
    private bool myAbortOnUnqual;
    public AfterDotUnqualifiedNameLookup(ICppScopeResolveEntity dotLeftHandSide, bool abortOnUnqual);
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter);
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Lookup.IUnqualifiedNameLookup.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter);
}
public enum JetBrains.ReSharper.Psi.Cpp.Lookup.Completion.CompletionType : Enum {
    public int value__;
    public static CompletionType EVERYTHING;
    public static CompletionType ONLY_TYPES_AND_NAMESPACES;
    public static CompletionType ONLY_CONCEPTS_AND_NAMESPACES;
    public static CompletionType ONLY_TYPES_AND_CONCEPTS_AND_NAMESPACES;
    public static CompletionType IN_BASE_CLAUSE;
    public static CompletionType IN_ENUM_BASE_CLAUSE;
    public static CompletionType ONLY_NAMESPACES;
    public static CompletionType ONLY_STRUCT_AND_SCOPES;
    public static CompletionType ONLY_ENUM_AND_SCOPES;
    public static CompletionType ONLY_UNION_AND_SCOPES;
    public static CompletionType NON_TYPEDEF_DECLARATORS;
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.Completion.CppCompletionUtil : object {
    public static CppCompletionRawResult CompleteMemInitializerName(CppViewPos& viewPos);
    public static CppCompletionRawResult CompleteUnqualified(CppViewPos& viewPos, CompletionType ctype, bool groupDeclarators);
    public static CppCompletionRawResult CompleteLambdaCapture(CppViewPos& viewPos);
    public static CppCompletionRawResult CompleteQualified(ICppScopeLikeResolveEntity lhs, CppTypeContext& tc, CompletionType ctype, bool groupDeclarators);
    public static CppCompletionRawResult CompleteQualifiedInUsingDeclaration(ICppScopeLikeResolveEntity qualifier, CppQualifiedNamePart lastQualifierPart, CppTypeContext& tc, bool groupDeclarators);
    public static CppCompletionRawResult CompleteAfterDot(ICppScopeLikeResolveEntity lhs, CppTypeContext& tc);
    private static bool IsConcept(ICppResolveEntity ent);
    private static bool IsTypeOrNamespace(ICppResolveEntity ent);
    private static bool IsConceptOrNamespace(ICppResolveEntity ent);
    private static bool IsTypeOrConceptOrNamespace(ICppResolveEntity ent);
    private static bool IsStructOrScope(ICppResolveEntity ent);
    private static bool IsEnumOrScope(ICppResolveEntity ent);
    private static bool IsEnumOrScopeC(ICppResolveEntity ent);
    private static bool IsUnionOrScope(ICppResolveEntity ent);
    private static bool IsUnionOrScopeC(ICppResolveEntity ent);
    private static bool HasNestedTypes(ICppClassResolveEntity clazz);
    private static bool IsOkForBaseClause(ICppResolveEntity ent);
    private static bool IsOkForEnumBaseClause(ICppResolveEntity ent);
    private static bool IsNonTypedefDeclarator(ICppResolveEntity ent);
    private static void AddTemplateParameter(ICppTemplateParameter param, PopulationContext context);
    private static void PopulateTableFromTemplateParameters(CppTemplateParametersBase params, PopulationContext context);
    private static void PopulateTableFromTemplateHeaders(CppTemplateHeaders& headers, PopulationContext context);
    private static void ProcessInjectedClassName(CppInjectedClassNameResolveEntity child, PopulationContext context);
    private static ICppResolveEntity GetDeclaratorPrimaryTemplateIfApplicable(ICppResolveEntity ent);
    private static void ProcessEntity(ICppResolveEntity child, PopulationContext context);
    private static void ProcessEntityOrPack(ICppResolveEntity ent, PopulationContext context, bool groupDeclarators);
    private static bool IsImportedFromModule(ICppResolveEntity ent);
    private static bool IsImportedFromModule(ICppClassResolveEntity clazz);
    private static bool IsImportedDeclaratorOrTemplate(ICppResolveEntity ent);
    private static bool IsImportedDeclarator(ICppGroupedDeclaratorResolveEntity decl);
    private static bool IsImportedDeclarator(ICppDeclaratorResolveEntity decl);
    private static CppRegularNormalFunctionModuleEntity GetImportedModuleEntity(ICppGroupedFunctionDeclaratorResolveEntity func);
    private static bool IsClr(ICppResolveEntity ent);
    private static bool GeneratedByReSharper(ICppResolveEntity ent);
    private static bool ShouldBeSkipped(ICppNamespaceModuleEntityChild ent, CppModuleImportingContext ctx);
    private static bool IsIncompleteButResolveEntityHasDefinition(CppClassOrEnumModuleEntity moduleEntity, CppModuleImportingContext ctx);
    private static bool IsBuiltinStdNamespace(CppNestedNamespaceModuleEntity ns);
    private static bool Matches(ICppNamespaceModuleEntityChild ent, CompletionType ctype);
    private static bool Matches(CppReExportedModuleEntity ent, CompletionType ctype);
    private static void PopulateTableFromNamespaceImpl(CppNamespaceResolveEntity ns, CppViewPos& viewPos, PopulationContext context, bool groupDeclarators, CompletionType ctype);
    private static void ProcessNamespaceModulePart(ModulePart part, CompletionType ctype, CppList`1& output);
    private static void AddNamespace(CppNamespaceResolveEntity nsEnt, PopulationContext context);
    private static void PopulateTableFromNamespaceWithoutLock(CppNamespaceResolveEntity ns, CppViewPos& viewPos, PopulationContext context, bool groupDeclarators, CompletionType ctype);
    private static void PopulateTableFromNamespace(CppNamespaceResolveEntity ns, CppViewPos& viewPos, PopulationContext context, bool groupDeclarators, CompletionType ctype);
    private static bool ClassMembersCouldBeUsedInCodeCompletion(ICppClassResolveEntity cent, CppViewPos& viewPos);
    private static void PopulateTableFromClassImpl(ICppClassResolveEntity cent, CppViewPos& viewPos, PopulationContext context);
    private static void PopulateTableFromClass(ICppClassResolveEntity cent, CppViewPos& viewPos, PopulationContext context);
    private static void PopulateTableFromGenericParameterImpl(ICppGenericParameter p, CppViewPos& viewPos, PopulationContext context);
    private static void PopulateTableFromGenericParameter(ICppGenericParameter p, CppViewPos& viewPos, PopulationContext context);
    private static void ProcessParameterList(ICppParameterListResolveEntity paramList, PopulationContext context);
    private static void PopulateTableFromScope(ICppScopeResolveEntity scope, CppViewPos& viewPos, PopulationContext context, bool groupDeclarators, CompletionType ctype);
    private static bool AllHaveSameParent(CppSmallList`1<ICppResolveEntity> entities);
    private static bool IsClassAndFunctionsOrVariables(CppSmallList`1<ICppResolveEntity> entities, bool groupDeclarators);
    private static bool HasClassConstructors(CppSmallList`1<ICppResolveEntity> entities);
    private static bool HandleDependentUsing(ICppResolveEntity e, DependentUsingType& dependentUsingType);
    private static void CreateDependentUsing(List`1<ICppResolveEntity> out, CppQualifiedNamePart name, DependentUsingType dependentUsingType, CompletionType ctype);
    private static NeedUnqualifiedLookupToDisambiguateResult NeedLookupToDisambiguateAndFilterUnqualified(PopulationContext context, CppSmallList`1<ICppResolveEntity> entities, CompletionType ctype, bool groupDeclarators);
    private static List`1<ICppResolveEntity> DisambiguateAndFilterUnqualified(PopulationContext context, CppViewPos& viewPos, CompletionType ctype, bool groupDeclarators);
    private static NeedQualifiedLookupToDisambiguateResult NeedLookupToDisambiguateAndFilterQualified(CppSmallList`1<ICppResolveEntity> entities);
    private static List`1<ICppResolveEntity> DisambiguateAndFilterAfterDot(PopulationContext context, Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>> entsByName, IEnumerable`1<ICppScopeLikeResolveEntity> lhsToTry, CppViewPos& viewPos, CompletionType ctype);
    private static IEnumerable`1<ICppScopeLikeResolveEntity> KillDependenciesForScope(ICppScopeLikeResolveEntity lhs, CppTypeContext& tc);
    private static void Complete(ICppClassResolveEntity clazz, CppViewPos& vp, PopulationContext context, HashSet`1<ICppScopeResolveEntity> currentClasses);
    private static CppCompletionRawResult CompleteQualifiedImpl(PopulationContext context, ICppScopeLikeResolveEntity lhs, CppTypeContext& tc, CompletionType ctype, bool groupDeclarators);
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.CppADLookup : object {
    public static CppLookupResult PerformADLAfterOrdinaryLookup(CppLookupResult ordinaryLookupResult, CppViewPos& scope, CppQualifiedName name, FrugalLocalList`1<CppQualType> argTypes);
    public static CppResolveResult PerformADLAfterResolve(CppResolveResult& rr, CppTypeContext& tc, CppQualifiedName name, IEnumerable`1<CppQualType> argTypes);
    public static bool FunctionCouldBeFoundByADL(ICppFunctionDeclaratorResolveEntity function);
    private static bool IsADLStopMember(ICppResolveEntity e);
    private static ADLAssocSet BuildAssocSet(FrugalLocalList`1<CppQualType> argTypes, CppViewPos& viewPos);
    private static ADLAssocSet BuildAssocSet(CppQualType[] argTypes, CppViewPos& viewPos);
    private static ADLAssocSet BuildAssocSet(IEnumerable`1<CppQualType> argTypes, CppViewPos& viewPos);
    private static FrugalLocalList`1<ICppResolveEntity> LookupCandidatesInAssocSet(FrugalLocalList`1<ICppResolveEntity> ordinaryLookupResult, ADLAssocSet set, CppViewPos& viewPos, CppQualifiedNamePart name);
}
internal static class JetBrains.ReSharper.Psi.Cpp.Lookup.CppClassifier : object {
    public static bool SymbolIsNotValidIdExpression(CppParsingBase`2<TTraits, TMarkerGuard> parsing, CppViewPos& scope, CppQualifiedName name);
    public static SymbolIsTypeResult SymbolIsType(CppParsingBase`2<TTraits, TMarkerGuard> parsing, CppViewPos& scope, CppQualifiedName name);
    public static SymbolIsTemplateResult SymbolIsTemplate(CppParsingBase`2<TTraits, TMarkerGuard> parsing, SymbolIsTemplateContext ctx, CppViewPos& viewPos, CppQualifiedName name);
    public static TriBool SymbolIsTemplateParameterPack(CppParsingBase`2<TTraits, TMarkerGuard> parsing, CppViewPos& viewPos, CppQualifiedName name);
    public static CppConceptDefinitionResolveEntity SymbolIsConcept(CppParsingBase`2<TTraits, TMarkerGuard> parsing, CppViewPos& viewPos, CppQualifiedName name);
    public static bool TypeContainsUnexpandedTemplateParameterPack(CppParsingBase`2<TTraits, TMarkerGuard> p, ICppDeclaratorBuilder declBuilder);
    public static bool HasClrSubscriptOperator(CppParsingBase`2<TTraits, TMarkerGuard> p, ICppExpression leftArg, CppViewPos& scope);
    private static CppLookupResult LookupAndPick(CppViewPos& viewPos, CppQualifiedName name, bool afterSubstitution);
    private static CppLookupResult LookupInScopeAndPick(ICppScopeLikeResolveEntity scope, CppViewPos& viewPos, CppQualifiedName name);
    private static bool IsTypeLike(ICppResolveEntity ent);
    private static bool AreAllTypeLike(FrugalLocalList`1<ICppResolveEntity> ents);
    private static bool AreAllTypeTemplates(FrugalLocalList`1<ICppResolveEntity> ents);
    private static SymbolIsTypeResult SymbolIsTypeImpl(LookupInfoAccumulator`2& acc, CppViewPos& scope, CppQualifiedName name);
    private static SymbolIsTemplateResult LookupResultIsTemplate(CppLookupResult pp, bool dependentScope, CppTemplateFunctionDisambiguationRules drules);
    private static SymbolIsTemplateResult SymbolIsTemplateImpl(CppParsingBase`2<TTraits, TMarkerGuard> parsing, LookupInfoAccumulator`2& acc, SymbolIsTemplateContext ctx, CppViewPos& viewPos, CppQualifiedName name);
    private static TriBool SymbolIsTemplateParameterPackImpl(CppParsingBase`2<TTraits, TMarkerGuard> parsing, LookupInfoAccumulator`2& acc, CppViewPos& viewPos, CppQualifiedName name);
    private static CppConceptDefinitionResolveEntity SymbolIsConceptImpl(LookupInfoAccumulator`2& acc, CppViewPos& scope, CppQualifiedName name);
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.CppClassMemberLookup : object {
    public static FrugalLocalList`1<ICppResolveEntity> Lookup(ICppClassResolveEntity ent, CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupPredicate predicate, bool forceHideByName);
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.CppCliClassTraversal : object {
    public static FrugalLocalList`1<ICppResolveEntity> Lookup(ICppClassResolveEntity ent, CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupPredicate filter, bool forceHideByName);
    public static FrugalLocalList`1<ICppResolveEntity> Lookup(ICppGenericParameter ent, CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupPredicate filter);
    private static void GoToClassBase(ICppClassResolveEntity& ent);
    private static CppAccessibility GetAllowedAccessibility(ICppClassResolveEntity klass, ICppClassResolveEntity lookupScope, CppViewPos& viewPos, bool forceHideByName);
    private static GoToInterfaceBaseResult GoToInterfaceBase(ICppClassOrGenericParameterResolveEntity& ent);
    private static bool CheckAccessibility(ICppResolveEntity e, CppAccessibility access);
    private static CopyFilteredResult CopyFiltered(FrugalLocalList`1& to, FrugalLocalList`1<ICppResolveEntity> from, CppViewPos& viewPos, CppAccessibility access, Boolean& hasAccessible, CppLookupPredicate filter);
    private static bool AddFiltered(FrugalLocalList`1& fromDerived, FrugalLocalList`1<ICppResolveEntity> fromBase, CppViewPos& viewPos, CppAccessibility access, Boolean& hasAccessible, CppLookupPredicate filter, FrugalLocalList`1& out, CopyFilteredResult mode, ICppResolvedTypeFactory tf);
    private static FrugalLocalList`1<ICppResolveEntity> QueryChildren(ICppClassResolveEntity cent, CppViewPos& viewPos, CppQualifiedNamePart name);
    private static FrugalLocalList`1<ICppResolveEntity> QueryChildren(ICppClassOrGenericParameterResolveEntity ent, CppViewPos& viewPos, CppQualifiedNamePart name);
    private static bool QueryBaseInterfaces(ICppClassResolveEntity ent, CppQualifiedNamePart name, CppViewPos& viewPos, CppLookupPredicate filter, FrugalLocalList`1& result);
    private static FrugalLocalList`1<ICppResolveEntity> LookupInClass(ICppClassResolveEntity ent, CppViewPos& viewPos, CppQualifiedNamePart name, ICppClassResolveEntity lookupScope, CppLookupPredicate filter, bool forceHideByName);
    private static void TopologicalSortRec(ICppClassOrGenericParameterResolveEntity ent, CppViewPos& viewPos, FrugalLocalList`1& out, HashSet`1<ICppClassOrGenericParameterResolveEntity> visited);
    private static FrugalLocalList`1<ICppClassOrGenericParameterResolveEntity> TopologicalSort(ICppClassOrGenericParameterResolveEntity ent, CppViewPos& viewPos);
    private static void AppendBases(ICppClassOrGenericParameterResolveEntity ent, CppViewPos& viewPos, HashSet`1<ICppClassOrGenericParameterResolveEntity> toVisit);
    private static FrugalLocalList`1<ICppResolveEntity> LookupInInterface(ICppClassOrGenericParameterResolveEntity ent, CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupPredicate filter, bool forceHideByName);
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.CppCompletionRawResult : ValueType {
    public List`1<ICppResolveEntity> Entities;
    public HashSet`1<ICppScopeResolveEntity> CurrentClassScopes;
    [CanBeNullAttribute]
public List`1<INamespace> ClrNamespaces;
    public CppList`1<CppNamespaceResolveEntity> GGDeclareHungarianNamespaces;
    public CppList`1<ICppNamespaceModuleEntityChild> ModuleEntities;
    public CppCompletionRawResult(List`1<ICppResolveEntity> entities, HashSet`1<ICppScopeResolveEntity> currentClassScopes);
    public CppCompletionRawResult(List`1<ICppResolveEntity> entities, HashSet`1<ICppScopeResolveEntity> currentClassScopes, List`1<INamespace> clrNamespaces, CppList`1<CppNamespaceResolveEntity> ggDeclareHungarianNamespaces, CppList`1<ICppNamespaceModuleEntityChild> moduleEntities);
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.CppCompletionResult : object {
    public static CppCompletionResult Empty;
    public EntityCollection Entities;
    public HashSet`1<ICppScopeResolveEntity> CurrentClassScopes;
    public Nullable`1<EntityCollection> PossibleMembers;
    public Nullable`1<CompleteDesignatedInitializationInfo> CompleteDesignatedInitialization;
    [CanBeNullAttribute]
public List`1<INamespace> ClrNamespaces;
    public CppList`1<CppNamespaceResolveEntity> GGDeclareHungarianNamespaces;
    public CppList`1<ICppNamespaceModuleEntityChild> ModuleEntities;
    [CanBeNullAttribute]
public List`1<ICppConceptDefinitionTemplateResolveEntity> QualifierConstraints;
    public CppCompletionResult(List`1<ICppResolveEntity> entities, HashSet`1<ICppScopeResolveEntity> currentClassScopes, List`1<INamespace> clrNamespaces, CppList`1<CppNamespaceResolveEntity> ggDeclareHungarianNamespaces, CppList`1<ICppNamespaceModuleEntityChild> moduleEntities);
    public CppCompletionResult(EntityCollection entities, HashSet`1<ICppScopeResolveEntity> currentClassScopes, List`1<ICppConceptDefinitionTemplateResolveEntity> qualifierConstraints);
    private static CppCompletionResult();
    public static CppCompletionResult FromRaw(CppCompletionRawResult r);
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.CppDeclarationState : ValueType {
    private State myState;
    private CppSubobjectPath mySubobjectPath;
    private FrugalLocalHashSet`1<ICppClassResolveEntity> myDeclarations;
    public CppDeclarationState(ICppClassResolveEntity declaration, bool isVirtualBase);
    private void MergeStateImpl(ICppClassResolveEntity declaration, CppDeclarationState other);
    public void MergeOtherState(CppDeclarationState other);
    public void MergeBaseState(ICppClassResolveEntity derived, CppDeclarationState other);
    public bool FoundInOneClass();
    public State GetState();
    public ICppClassResolveEntity Declaration();
    public FrugalLocalHashSet`1<ICppClassResolveEntity> Declarations();
    public CppSubobjectPath SingleSubobjectPath();
}
public static class JetBrains.ReSharper.Psi.Cpp.Lookup.CppGenericLookup : object {
    public static CppLookupResult ScopeNameLookup(CppViewPos& scope, UnqualifiedNameLookup unqualifiedNameLookup, CppQualifiedName name, bool forceHideByName);
    public static CppLookupResult ScopeNameLookup(CppViewPos& scope, UnqualifiedNameLookup unqualifiedNameLookup, CppQualifiedName name);
    public static FrugalLocalList`1<ICppResolveEntity> GenericLookup(CppViewPos& scope, CppQualifiedName name, UnqualifiedNameLookup unqualifiedNameLookup, CppLookupFilter filter, bool forceHideByName);
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.CppHideBySignature : object {
    public static bool IsSimilar(ICppGroupedFunctionDeclaratorResolveEntity fromBase, ICppGroupedFunctionDeclaratorResolveEntity fromDerived, ICppResolvedTypeFactory tf);
    public static bool IsSimilar(ICppFunctionTemplateDeclaratorResolveEntity fromBase, ICppFunctionTemplateDeclaratorResolveEntity fromDerived, ICppResolvedTypeFactory tf);
    private static bool IsSimilarImpl(ICppGroupedFunctionDeclaratorResolveEntity fromBase, ICppGroupedFunctionDeclaratorResolveEntity fromDerived, ICppResolvedTypeFactory tf, CppEqualityComparer comparer);
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.CppLookup : object {
    public static CppLookupResult SimpleLookup(CppViewPos& scope, CppQualifiedName name, CppClassTag tag);
    public static CppLookupResult LookupTemplateArgument(CppViewPos& scope, CppQualifiedName name);
    public static CppLookupResult ScopeNameLookup(CppViewPos& scope, CppQualifiedName name);
    public static CppLookupResult DestructorScopeNameLookup(CppViewPos& scope, CppQualifiedName name);
    public static CppLookupResult NamespaceNameLookup(CppViewPos& scope, CppQualifiedName name);
    public static CppLookupResult BaseTypeLookup(CppViewPos& scope, CppQualifiedName name);
    public static CppLookupResult UsingDeclarationTargetsLookup(ICppClassResolveEntity parent, CppViewPos& scope, CppQualifiedName name, bool hadTypenameKeyword, Boolean& resultIsConstructors);
    public static CppLookupResult UsingDeclarationTargetsLookupAfterColonColon(ICppClassResolveEntity parent, CppViewPos& scope, ICppScopeLikeResolveEntity qualifier, CppQualifiedNamePart name, bool hadTypenameKeyword, bool requireConstructors, Boolean& resultIsConstructors);
    public static CppLookupResult UsingEnumDeclarationTargetsLookup(CppViewPos& scope, CppQualifiedName name);
    public static CppLookupResult LookupOperatorIgnoringMembers(CppViewPos& scope, CppOperatorKind op);
    public static CppLookupResult CxxCliOverrideSpecifierTargetLookup(CppViewPos& scope, CppQualifiedName name);
    public static CppLookupResult CxxCliOverrideSpecifierTargetLookupInScope(CppViewPos& scope, ICppScopeLikeResolveEntity pp, CppQualifiedNamePart name);
    public static CppLookupResult ConceptDeclarationLookup(CppViewPos& scope, CppQualifiedName name);
    public static CppLookupResult LookupScopeNameAfterDot(ICppScopeResolveEntity ent, CppViewPos& viewPos, CppQualifiedName name);
    public static CppLookupResult LookupDestrutorScopeNameAfterDot(ICppScopeResolveEntity ent, CppViewPos& scope, CppQualifiedName name);
    public static CppLookupResult LookupDependentNameAfterDot(CppViewPos& viewPos, CppQualifiedName name);
    public static CppLookupResult LookupNameAfterDot(ICppScopeResolveEntity ent, CppViewPos& viewPos, CppQualifiedName name, bool returnMsvcCompatibleConstructors);
    public static CppLookupResult LookupNameAfterDot(ICppScopeResolveEntity ent, CppViewPos& viewPos, CppQualifiedName name, CppLookupResult& cachedUnqualResult, bool returnMsvcCompatibleConstructors);
    public static CppLookupResult LookupNameAfterDot(ICppGenericParameter ent, CppViewPos& viewPos, CppQualifiedName name);
    public static CppLookupResult LookupMemInitializerId(ICppClassResolveEntity ent, CppViewPos& viewPos, CppQualifiedName name);
    public static CppLookupResult LookupInClass(ICppScopeLikeResolveEntity ent, CppViewPos& viewPos, CppQualifiedName name);
    public static CppLookupResult LookupInClassWithCustomFilter(ICppScopeLikeResolveEntity ent, CppViewPos& viewPos, CppQualifiedName name, CppLookupFilter filter, bool ignoreDependencies);
    private static CppLookupResult LookupDestructor(ICppScopeLikeResolveEntity ent, CppViewPos& viewPos, CppQualifiedName name, CppDestructorTag dtorName);
    public static CppLookupResult ReLookupDependentNameFromCurrentInstantiation(ICppResolveEntity fromResolveResult, CppViewPos& viewPos);
    private static CppLookupResult LookupDestructorNamePart(ICppScopeLikeResolveEntity scope, CppViewPos& viewPos, CppQualifiedNamePart name);
    private static CppLookupResult CombineDestructorNamePartLookupResults(CppLookupResult inClass, CppLookupResult inViewPosScope);
    private static CppLookupResult LookupDestructorOrFinalizer(ICppDeclaratorResolveEntityPack pack, CppViewPos& vp);
    public static CppLookupResult LookupDestructorOfType(CppQualType type, CppViewPos& vp, bool forceBuiltin);
    private static CppLookupResult LookupFinalizerOfType(CppQualType type, CppViewPos& vp);
    public static string PrettyPrintLookupError(CppViewPos& viewPos, CppQualifiedName name);
    public static string PrettyPrintLookupError(ICppResolveEntity cent, CppQualifiedName name);
    private static FrugalLocalList`1<ICppResolveEntity> FilterIncorrectUsingDeclarationForClass(FrugalLocalList`1<ICppResolveEntity> candidates, ICppClassResolveEntity udParent, CppViewPos& viewPos);
    public static FrugalLocalList`1<ICppResolveEntity> FindFunctionsByArgTypes(FrugalLocalList`1<ICppResolveEntity> candidates, IList`1<CppQualType> argtypes, ICppResolvedTypeFactory tf);
    private static FrugalLocalList`1<ICppResolveEntity> FilterIncorrectUsingDeclarationForNamespace(FrugalLocalList`1<ICppResolveEntity> candidates);
    private static CppLookupResult SimpleLookup(CppViewPos& scope, CppQualifiedName name, CppClassTag tag, bool replaceInjectedClassName);
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.CppLookupDef : object {
    public static LookupScopeForDefinitionResult LookupScopeForDefinition(CppViewPos& viewPos, CppQualifiedName name, CppScopeLookupTemplateParametersContext& templCtx, bool allowDependent, bool isExplicitInstantiation);
    private static void AddMapping(Dictionary`2& fp, ICppResolveEntity key, CppTemplateParametersBase value);
    private static ICppResolveEntity PickSpecialization(CppClassTemplateResolveEntityPack pack, CppViewPos& viewPos, ICppTemplateArgument[] args, CppTemplateParametersBase templParams);
    private static LookupScopeForDefinitionResult LookupSubstitutionId(CppViewPos& viewPos, CppQualifiedName name, CppScopeLookupTemplateParametersContext& templCtx, bool allowDependent);
    private static LookupScopeForDefinitionResult LookupNotSubstitutionId(CppViewPos& viewPos, CppQualifiedName name, CppScopeLookupTemplateParametersContext& templCtx, bool allowDependent);
    private static LookupScopeForDefinitionResult LookupId(CppViewPos& viewPos, CppQualifiedName name, CppScopeLookupTemplateParametersContext& templCtx, bool allowDependent);
    private static LookupScopeForDefinitionResult LookupScopeForExplicitInstantiation(CppViewPos& viewPos, CppQualifiedName name);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Lookup.CppLookupFilter : ValueType {
    private CppLookupPredicate myFunc;
    private bool myHadTypenameKeyword;
    [DebuggerStepThroughAttribute]
public CppLookupFilter(CppLookupPredicate func);
    [DebuggerStepThroughAttribute]
public CppLookupFilter(CppLookupPredicate func, bool hadTypenameKeyword);
    [DebuggerStepThroughAttribute]
public CppLookupPredicate GetFunc();
    public bool HadTypenameKeyword();
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.CppLookupInNamespace : object {
    public static FrugalLocalList`1<ICppResolveEntity> ChildByNameWithUsingDeclarations(ICppScopeResolveEntity scope, CppViewPos& viewPos, CppQualifiedNamePart name, bool includeReachableButNotVisibleClasses);
    public static FrugalLocalList`1<ICppResolveEntity> ChildByNameWithUsingDeclarationsAndInlineNamespaces(ICppScopeResolveEntity scope, CppViewPos& viewPos, CppQualifiedNamePart name, bool includeEntitiesFromGlobalModule);
    public static IEnumerable`1<ICppResolveEntity> ChildByNameWithUsingDeclarationsAndDirectives(ICppScopeResolveEntity scope, CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupPredicate predicate);
    private static void BuildInlineNamespaceChilds(CppNamespaceResolveEntity scope, CppViewPos& viewPos, CppQualifiedNamePart name, FrugalLocalHashSet`1& output, bool includeReachableButNotVisibleClasses);
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.CppLookupOps : object {
    public static CppNamespaceResolveEntity LookupNamespaceAndNavigate(CppViewPos& viewPos, CppQualifiedName name);
}
public enum JetBrains.ReSharper.Psi.Cpp.Lookup.CppLookupPredicate : Enum {
    public int value__;
    public static CppLookupPredicate DEFAULT;
    public static CppLookupPredicate SUITS_FOR_SUBSTITUTION;
    public static CppLookupPredicate TYPE_OR_TEMPLATE;
    public static CppLookupPredicate QUALIFIER;
    public static CppLookupPredicate NAMESPACE;
    public static CppLookupPredicate USING_DECLARATION_TARGET;
    public static CppLookupPredicate CLI_OVERRIDE_SPECIFIER_TARGET;
    public static CppLookupPredicate OPERATOR_IGNORING_MEMBERS;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Lookup.CppLookupPredicates : object {
    public static CppLookupPredicate TagIs(CppClassTag tag, bool afterSubstitution);
    public static CppLookupPredicate IsType(bool afterSubstitution);
    public static CppLookupPredicate CanBeQualifer(bool afterSubstitution);
    public static CppLookupPredicate SuitsForSubstitution();
    public static CppLookupPredicate IsNamespace();
    public static CppLookupPredicate IsUsingDeclarationTarget();
    public static CppLookupPredicate IsClassMemberDeclaratorOrTemplateDeclarator();
    [ExtensionAttribute]
public static bool Matches(ICppResolveEntity ent, CppViewPos& viewPos, CppLookupPredicate pred);
    private static bool IsOperatorIgnoringMembers(ICppResolveEntity ent, CppViewPos& viewPos);
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.CppLookupResult : ValueType {
    public Status status;
    private FrugalLocalList`1<ICppResolveEntity> myEntities;
    private CppLookupResult(Status status, FrugalLocalList`1<ICppResolveEntity> entities);
    public ICppResolveEntity GetAnyIfOk();
    public FrugalLocalList`1<ICppResolveEntity> GetCandidatesIfOk();
    public FrugalLocalList`1<ICppResolveEntity> GetCandidates();
    public static CppLookupResult Ok(ICppResolveEntity ent);
    public static CppLookupResult Ok(FrugalLocalList`1<ICppResolveEntity> candidates);
    public static CppLookupResult Ok(IEnumerable`1<ICppResolveEntity> candidates);
    public static CppLookupResult ResolveError();
    public static CppLookupResult ResolveError(FrugalLocalList`1<ICppResolveEntity> candidates);
    public static CppLookupResult ResolveError(IEnumerable`1<ICppResolveEntity> candidates);
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.CppLookupSetCache2 : object {
    private Dictionary`2<ICppClassResolveEntity, CppVisibilitySet2> myVisibilitySetCache;
    private Dictionary`2<ICppClassResolveEntity, CppSuppressedVBasesSet2> mySuppressedVBasesCache;
    private ILookupClassFilter myPred;
    private CppViewPos myViewPos;
    [DebuggerStepThroughAttribute]
public CppLookupSetCache2(CppViewPos& viewPos, ILookupClassFilter pred);
    public CppVisibilitySet2 BuildVisibilitySetForClass(ICppClassResolveEntity cent, bool isVirtualBase);
    public CppSuppressedVBasesSet2 BuildSuppressedVBasesSetForClass(ICppClassResolveEntity cent);
    public CppViewPos ViewPos();
    public bool IsSuited(ICppClassResolveEntity cent);
    public static FrugalLocalList`1<ICppResolveEntity> Lookup(ICppClassResolveEntity ent, CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupPredicate predicate);
    public static IEnumerable`1<ICppResolveEntity> LookupConversions(ICppClassResolveEntity ent, CppViewPos& viewPos, CppQualifiedNamePart name);
    public static SubobjectType FindSubobjectType(ICppClassResolveEntity derived, ICppClassResolveEntity base, CppViewPos& viewPos);
    public static Nullable`1<CppSubobject> TryFindSingleSubobject(ICppClassResolveEntity derived, ICppClassResolveEntity base, CppViewPos& viewPos);
    public static Nullable`1<CppSubobject> TryFindSingleSubobjectOfMember(ICppClassResolveEntity cls, ICppResolveEntity memberScope, ICppResolveEntity member, CppViewPos& viewPos);
    private CppDeclarationState DoLookup(ICppClassResolveEntity startEntity);
    private static void CheckNamePart(CppQualifiedNamePart namePart);
    private static ICppClassResolveEntity ExtractFurthestVirtualBases(LocalHashSet`1& vbases);
    private static CppSubobject AppendSubobjects(CppSubobject lhs, CppSubobject rhs);
}
public static class JetBrains.ReSharper.Psi.Cpp.Lookup.CppLookupUtil : object {
    public static CppLookupResult LookupOperatorNew(CppViewPos& scope, CppQualType qualType, bool onlyGlobal);
    public static CppLookupResult LookupOperator(CppTypeContext& tc, CppOperatorKind kind, ReadOnlySpan`1<ICppExpression> args, bool lookupOnlyMembers);
    public static CppLookupResult LookupDefaultProperties(CppTypeContext& tc, ICppResolvedExpression ref);
    public static CppLookupResult LookupDefaultProperties(CppTypeContext& tc, CppQualType qualType);
    public static bool LookupResultIsDependent(CppLookupResult lr);
    public static ICppTemplateParameter GetTemplateParameterByTag(CppTemplateParameterTag tag, CppViewPos& viewPos);
    public static CppTemplateParametersBase GetTemplateParameters(ICppResolveEntity e, Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> mapping);
    public static FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> LookupResultToCandidatesSet(CppLookupResult lookupRes);
    public static ICppScopeLikeResolveEntity LookupResultToScope(CppLookupResult pp, CppViewPos& vp);
    private static void AddFunctionCandidateTypes(FrugalLocalList`1& types, ICppExpression arg, CppTypeContext& tc);
    private static FrugalLocalList`1<CppQualType> GetArgTypes(ReadOnlySpan`1<ICppExpression> args, CppTypeContext& tc);
    private static ICppTemplateParameter FindParamByTagInTemplateParameters(CppTemplateParametersSlice& params, CppTemplateParameterTag tag);
    private static ICppTemplateParameter FindParamByTagInTemplateParametersList(CppTemplateHeaders& headers, CppTemplateParameterTag tag);
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.CppPrincipalResolveEntityPicker : object {
    public static CppLookupResult Pick(FrugalLocalList`1<ICppResolveEntity> ents, CppClassTag tag, bool isSubstitution, bool matchGenerics, CppViewPos& viewPos, ICppTemplateArgument[] args);
    public static CppLookupResult PickAndSubstitute(FrugalLocalList`1<ICppResolveEntity> ents, CppClassTag tag, bool isSubstitution, CppViewPos& viewPos, ICppTemplateArgument[] args);
    public static CppLookupResult PickAndSubstituteDontReplaceInjectedClassName(FrugalLocalList`1<ICppResolveEntity> ents, CppClassTag tag, bool isSubstitution, CppViewPos& viewPos, ICppTemplateArgument[] args);
    public static CppLookupResult ReplaceInjectedClassNames(CppLookupResult pp);
    private static bool InSameNamespace(ICppResolveEntity a, ICppResolveEntity b);
    private static bool AllInSameNamespace(ICppResolveEntity a, FrugalLocalList`1<ICppResolveEntity> b);
    private static bool AreOverloadedFunctions(FrugalLocalList`1& ents);
    private static bool AreInjectionsOfTheSameTemplate(FrugalLocalList`1& ents, bool isSubstitution);
    private static bool AreInjectedClassNamesAndSomethingElse(FrugalLocalList`1<ICppResolveEntity> ents);
    private static void DropInjectedClassNames(FrugalLocalList`1& ents);
    private static bool AreClassAndSomethingFromTheSameNamespace(FrugalLocalList`1& ents);
    private static bool AreClassAndTypedefsTakeClass(FrugalLocalList`1& ents);
    private static bool AreClassAndTypedefs(FrugalLocalList`1& ents);
    private static bool AreClassAndSomething(FrugalLocalList`1& ents);
    private static bool AreCliProperties(FrugalLocalList`1<ICppResolveEntity> ents);
    private static bool AreMultipleGenericClasses(FrugalLocalList`1& ents, CppViewPos& viewPos, ICppTemplateArgument[] args, bool findSingleResult);
    private static bool AreAliasesOfTheSameNamespace(FrugalLocalList`1& ents, CppViewPos& viewPos);
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.CppResolveEntityPickers : object {
    public static CppLookupResult PickAll(FrugalLocalList`1<ICppResolveEntity> candidates);
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.CppSuppressedVBasesSet2 : object {
    public LocalHashSet`1<ICppClassResolveEntity> myVirtualBases;
    public static CppSuppressedVBasesSet2 BuildForClass(ICppClassResolveEntity cent, CppLookupSetCache2 cache);
}
public static class JetBrains.ReSharper.Psi.Cpp.Lookup.CppUserDefinedLiteralLookup : object {
    public static CppLookupResult UserDefinedLiteralOperatorLookup(CppViewPos& scope, string name, ICppUserDefinedLiteralValue literal);
    private static FrugalLocalList`1<ICppResolveEntity> PickUserDefinedLiteralTemplate(FrugalLocalList`1<ICppResolveEntity> candidates, string text, CppViewPos& view);
    private static FrugalLocalList`1<ICppResolveEntity> PickUserDefinedLiteralStringTemplate(FrugalLocalList`1<ICppResolveEntity> candidates, CppUserDefinedLiteralStringValue literal, CppViewPos& view);
    private static FrugalLocalList`1<ICppResolveEntity> PickGnuExtensionUserDefinedLiteralStringTemplate(FrugalLocalList`1<ICppResolveEntity> candidates, CppUserDefinedLiteralStringValue literal, CppViewPos& view);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Lookup.CppViewPosUtil : object {
    public static FrugalLocalList`1<ICppResolveEntity> ChildByName(ICppScopeResolveEntity scope, CppViewPos& viewPos, CppQualifiedNamePart name, bool includeReachableButNotVisibleClasses);
    public static FrugalLocalList`1<ICppResolveEntity> ChildByName(ICppClassResolveEntity clazz, CppViewPos& viewPos, CppQualifiedNamePart name);
    public static IEnumerable`1<ICppDeclaratorOrTemplateDeclaratorPack> QueryConversions(ICppClassResolveEntity cent, CppViewPos& viewPos);
    public static IEnumerable`1<ICppDeclaratorOrTemplateDeclaratorPack> QueryConversionsByName(ICppClassResolveEntity cent, CppViewPos& viewPos, CppQualifiedNamePart name);
    [ExtensionAttribute]
public static CppViewPos ViewPosWhereClassIsComplete(ICppClassResolveEntity clazz);
    private static void BuildAllImmediateChildren(FrugalLocalList`1& result, ICppScopeResolveEntity scope, CppQualifiedNamePart name, CppLocationAnchor anchorForViewPos, bool includeReachableButNotVisibleClasses);
    private static void BuildAllChildren(FrugalLocalList`1& result, ICppScopeResolveEntity scope, CppQualifiedNamePart name, CppViewPos& viewPos, CppLocationAnchor anchorForViewPos, bool includeReachableButNotVisibleClasses);
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.CppVisibilitySet2 : object {
    public CppDeclarationState myDeclState;
    public LocalHashSet`1<ICppClassResolveEntity> myVirtualBases;
    public CppVisibilitySet2(ICppClassResolveEntity declaration, bool isVirtualBase);
    public static CppVisibilitySet2 BuildForClass(ICppClassResolveEntity cent, bool isVirtualBase, CppLookupSetCache2 cache);
    public void MergeBaseSet(ICppClassResolveEntity cls, CppVisibilitySet2 rhs);
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.FreeStandingUnqualifiedNameLookup : ValueType {
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter);
    public static FrugalLocalList`1<ICppResolveEntity> LookupCommonCase(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter);
    private static FrugalLocalList`1<ICppResolveEntity> LookupDecltype(CppDecltypeId declTypeId, CppViewPos& viewPos, CppLookupPredicate pred);
    private static FrugalLocalList`1<ICppResolveEntity> LookupTypeof(CppTypeOfTypeId typeOfTypeId, CppViewPos& viewPos, CppLookupPredicate pred);
    private static FrugalLocalList`1<ICppResolveEntity> LookupMSSuper(CppViewPos& viewPos, CppLookupPredicate pred);
    private static FrugalLocalList`1<ICppResolveEntity> LookupSimpleTypeId(CppCliSimpleTypeId cliSimpleTypeId, CppViewPos& viewPos, CppLookupPredicate pred);
    public FrugalLocalList`1<ICppResolveEntity> DoLookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter);
    private static void UsingDirectiveTransitiveClosure(ICppScopeResolveEntity lookupCurrent, ICppScopeResolveEntity current, CppViewPos& viewPos, CommonParentToNominatedMap& commonParentToNominated, CppSmallSet`1& seenSet);
    private static void UsingDirectiveTransitiveClosureForNamespace(ICppScopeResolveEntity lookupCurrent, CppNamespaceResolveEntity current, CppViewPos& viewPos, CommonParentToNominatedMap& commonParentToNominated, CppSmallSet`1& seenSet);
    private static void UsingDirectiveTransitiveClosure(ICppScopeResolveEntity lookupCurrent, CppNamespaceResolveEntity current, CppViewPos& viewPos, CommonParentToNominatedMap& commonParentToNominated, CppSmallSet`1& seenSet);
    private static void ComposeUnqualifiedNameLookupResult(ICppScopeResolveEntity scope, CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupPredicate filter, FrugalLocalHashSet`1& result);
    private static FrugalLocalList`1<ICppResolveEntity> ComposeUnqualifiedNameLookupResult(ICppScopeResolveEntity scope, CppList`1<ICppScopeResolveEntity> extraScopes, CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter);
    private static FrugalLocalList`1<ICppResolveEntity> LookupInTemplateParametersList(CppTemplateHeaders& headers, CppQualifiedNamePart name);
    private static ICppClassResolveEntity GetSuperClass(CppViewPos& viewPos);
    private static FrugalLocalList`1<ICppResolveEntity> LookupInNamespace(CppNamespaceResolveEntity ns, UnqualifiedNameLookupContext& ctx, CppQualifiedNamePart name, CppLookupFilter filter);
    private static FrugalLocalList`1<ICppResolveEntity> LookupBuiltinCLIType(CppBuiltinsRefs builtins, CppQualifiedNamePart name, CppViewPos& viewPos, CppLookupPredicate pred);
    private static FrugalLocalList`1<ICppResolveEntity> FindInPack(CppBuiltinsRefs builtins, CppViewPos& viewPos, CppLookupPredicate pred, ICppDeclaratorResolveEntityPack pack);
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Lookup.IUnqualifiedNameLookup.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter);
}
public interface JetBrains.ReSharper.Psi.Cpp.Lookup.ILookupClassFilter {
    public abstract virtual bool Apply(ICppClassResolveEntity ent, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Lookup.InClassUnqualifiedNameLookup : ValueType {
    [CompilerGeneratedAttribute]
private ICppScopeLikeResolveEntity <dotLeftHandSide>P;
    [CompilerGeneratedAttribute]
private bool <ignoreDependencies>P;
    public InClassUnqualifiedNameLookup(ICppScopeLikeResolveEntity dotLeftHandSide, bool ignoreDependencies);
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter);
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Lookup.IUnqualifiedNameLookup.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter);
}
public interface JetBrains.ReSharper.Psi.Cpp.Lookup.IUnqualifiedNameLookup {
    public abstract virtual FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter);
}
public class JetBrains.ReSharper.Psi.Cpp.Lookup.LookupScopeForDefinitionResult : ValueType {
    public ICppScopeLikeResolveEntity scope;
    public Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> fp;
    public CppLookupResult lookupResult;
    public LookupScopeForDefinitionResult(ICppScopeLikeResolveEntity scope, Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> fp);
}
public enum JetBrains.ReSharper.Psi.Cpp.Lookup.SymbolIsTemplateResult : Enum {
    public int value__;
    public static SymbolIsTemplateResult SURELY_FALSE;
    public static SymbolIsTemplateResult SURELY_TRUE;
    public static SymbolIsTemplateResult PRESUMABLY_FALSE_BUT_NEED_A_CHECK;
    public static SymbolIsTemplateResult PRESUMABLY_TRUE_BUT_NEED_A_CHECK;
}
public enum JetBrains.ReSharper.Psi.Cpp.Lookup.SymbolIsTypeResult : Enum {
    public int value__;
    public static SymbolIsTypeResult FALSE;
    public static SymbolIsTypeResult TRUE;
    public static SymbolIsTypeResult DEPENDENT;
    public static SymbolIsTypeResult UNRESOLVED;
}
[CppCompilationPropertiesProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.Cpp.Nintendo.NintendoCompilationPropertiesProvider : object {
    private static string NX64;
    private static string NX32;
    private static bool IsNintendoPlatform(string platformName);
    public sealed virtual CppCompilationProperties GetCompilationProperties(IProject project, IProjectFile projectFile, CppFileLocation rootFile, CppGlobalSymbolCache globalCache, CppIntelliSenseInfo intelliSenseInfo);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppAggregateInitializationConversionItem : CppAggregateInitializationDataItem {
    [CompilerGeneratedAttribute]
private CppImplicitConversionSequence <ImplicitConversionSequence>k__BackingField;
    public bool IsFailure { get; }
    public CppImplicitConversionSequence ImplicitConversionSequence { get; }
    public CppAggregateInitializationConversionItem(CppImplicitConversionSequence convSequence, CppList`1<InitStackElement> initStack, CppQualType targetType);
    public bool get_IsFailure();
    [CompilerGeneratedAttribute]
public CppImplicitConversionSequence get_ImplicitConversionSequence();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Overload.CppAggregateInitializationDataItem : object {
    [CompilerGeneratedAttribute]
private CppList`1<InitStackElement> <InitializationStack>k__BackingField;
    [CompilerGeneratedAttribute]
private CppQualType <TargetType>k__BackingField;
    public CppList`1<InitStackElement> InitializationStack { get; }
    public CppQualType TargetType { get; }
    protected CppAggregateInitializationDataItem(CppList`1<InitStackElement> initStack, CppQualType targetType);
    [CompilerGeneratedAttribute]
public CppList`1<InitStackElement> get_InitializationStack();
    [CompilerGeneratedAttribute]
public CppQualType get_TargetType();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppAggregateInitializationDesignatorItem : object {
    [CompilerGeneratedAttribute]
private ICppDesignator <Designator>k__BackingField;
    [CompilerGeneratedAttribute]
private CppQualType <ScopeType>k__BackingField;
    [CompilerGeneratedAttribute]
private CppResolveResult <ResolveResult>k__BackingField;
    public ICppDesignator Designator { get; }
    public CppQualType ScopeType { get; }
    public CppResolveResult ResolveResult { get; }
    public CppAggregateInitializationDesignatorItem(ICppDesignator designator, CppQualType scopeType, CppResolveResult& result);
    [CompilerGeneratedAttribute]
public ICppDesignator get_Designator();
    [CompilerGeneratedAttribute]
public CppQualType get_ScopeType();
    [CompilerGeneratedAttribute]
public CppResolveResult get_ResolveResult();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppAggregateInitializationExpressionItem : CppAggregateInitializationDataItem {
    [CompilerGeneratedAttribute]
private ICppExpression <Argument>k__BackingField;
    public ICppExpression Argument { get; }
    public CppAggregateInitializationExpressionItem(ICppExpression argument, CppList`1<InitStackElement> initStack, CppQualType targetType);
    [CompilerGeneratedAttribute]
public ICppExpression get_Argument();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppAggregateInitializationExpressionPackItem : CppAggregateInitializationDataItem {
    [CompilerGeneratedAttribute]
private ICppExpression[] <Arguments>k__BackingField;
    [CanBeNullAttribute]
public ICppExpression[] Arguments { get; }
    public CppAggregateInitializationExpressionPackItem(ICppExpression[] argument, CppList`1<InitStackElement> initStack, CppQualType targetType);
    [CompilerGeneratedAttribute]
public ICppExpression[] get_Arguments();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppAggregateInitializationInfo : object {
    private Status myStatus;
    [CompilerGeneratedAttribute]
private CppQualType <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ICppAggregateInitializationInfoItem> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ICppExpression> <ExcessiveInitializers>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InitializedElements>k__BackingField;
    public CppQualType TargetType { get; }
    public List`1<ICppAggregateInitializationInfoItem> Items { get; }
    public bool IsFailure { get; }
    [CanBeNullAttribute]
public List`1<ICppExpression> ExcessiveInitializers { get; }
    public int InitializedElements { get; }
    public CppAggregateInitializationInfo(CppQualType targetType, List`1<ICppAggregateInitializationInfoItem> conversions, int initializedElements, List`1<ICppExpression> excessiveInitializers, Status status);
    [CompilerGeneratedAttribute]
public CppQualType get_TargetType();
    [CompilerGeneratedAttribute]
public List`1<ICppAggregateInitializationInfoItem> get_Items();
    public bool get_IsFailure();
    [CompilerGeneratedAttribute]
public List`1<ICppExpression> get_ExcessiveInitializers();
    [CompilerGeneratedAttribute]
public int get_InitializedElements();
    public Status GetStatus();
}
public static class JetBrains.ReSharper.Psi.Cpp.Overload.CppAggregateInitializationUtil : object {
    public static CppAggregateInitializationInfo DoAggregateInit(CppQualType targetType, ICppExpression[] arguments, CppArgumentListKind kind, CppTypeContext& tc, ICppOverloadingInfoAggregator overloadingInfoAggregator);
    public static CppAggregateInitializationInfo DoAggregateInit(CppQualType targetType, ICppArgumentList argList, CppTypeContext& tc, ICppOverloadingInfoAggregator overloadingInfoAggregator);
    public static CppAggregateInitializationInfo DoAggregateInit(CppQualType targetType, ICppExpression[] arguments, CppArgumentListKind kind, CppTypeContext& tc);
    public static CppAggregateInitializationInfo DoAggregateInitForCTAD(ICppClassResolveEntity aggregateClass, ICppExpression[] arguments, CppArgumentListKind kind, CppTypeContext& tc);
    public static bool CanBeAggregateParenInit(InitDeclarator initDeclarator, CppTypeContext& tc);
    public static bool CanBeAggregateParenInit(InitDeclarator initDeclarator, CppTypeContext& tc, CppQualType& targetType);
    public static CppImplicitConversionSequence TryDoAggregateParenInit(InitDeclarator initDeclarator, ICppOverloadingInfoAggregator aggregator, CppTypeContext& tc);
    public static bool CanBeAggregateParenInit(MemInitializer memInit, CppTypeContext& tc);
    public static bool CanBeAggregateParenInit(MemInitializer memInit, CppTypeContext& tc, CppQualType& targetType);
    public static CppImplicitConversionSequence TryDoAggregateParenInit(MemInitializer memInit, ICppOverloadingInfoAggregator aggregator, CppTypeContext& tc);
    public static bool CanBeAggregateParenInit(ICppCallExpression callExpr, CppTypeContext& tc);
    public static bool CanBeAggregateParenInit(ICppCallExpression callExpr, CppTypeContext& tc, CppQualType& targetType);
    public static CppImplicitConversionSequence TryDoAggregateParenInit(ICppCallExpression callExpr, ICppOverloadingInfoAggregator aggregator, CppTypeContext& tc);
    public static bool CanBeAggregateParenInit(ICppTypeIdOrExpression callee, ICppExpression[] arguments, CppTypeContext& tc, CppQualType& targetType);
    public static CppImplicitConversionSequence TryDoAggregateParenInit(ICppTypeIdOrExpression callee, ICppExpression[] arguments, ICppOverloadingInfoAggregator aggregator, CppTypeContext& tc);
    public static bool CanBeAggregateParenInit(ICppNewExpression newExpr, CppTypeContext& tc);
    public static bool CanBeAggregateParenInit(ICppNewExpression newExpr, CppTypeContext& tc, CppQualType& targetType);
    public static CppImplicitConversionSequence TryDoAggregateParenInit(ICppNewExpression newExpr, ICppOverloadingInfoAggregator aggregator, CppTypeContext& tc);
    public static CppImplicitConversionSequence TryDoAggregateInitInStaticCast(ICppExpression argument, CppQualType targetType, CppTypeContext& tc);
    public static bool IsAggregateParenInitConversion(CppImplicitConversionSequence seq);
    private static CppImplicitConversionSequence DoAggregateParenInit(CppQualType targetType, ICppExpression[] arguments, ICppOverloadingInfoAggregator aggregator, CppTypeContext& tc);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppAmbiguousConversionSequence : CppImplicitConversionSequence {
    private ReferenceFlag myTargetReferenceFlag;
    [CompilerGeneratedAttribute]
private CppQualType <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private CppOverloadingRunInfo <AmbiguousConversionOverloadingInfo>k__BackingField;
    public CppQualType TargetType { get; }
    public CppOverloadingRunInfo AmbiguousConversionOverloadingInfo { get; }
    public int Rank { get; }
    public ReferenceFlag TargetReferenceFlag { get; }
    public CppAmbiguousConversionSequence(ICppResolvedExpression from, CppOverloadingRunInfo info, CppQualType targetType);
    [CompilerGeneratedAttribute]
public CppQualType get_TargetType();
    [CompilerGeneratedAttribute]
public CppOverloadingRunInfo get_AmbiguousConversionOverloadingInfo();
    public virtual int get_Rank();
    public virtual ReferenceFlag get_TargetReferenceFlag();
    public virtual TResult Accept(ICppImplicitConversionSequenceVisitor`1<TResult> vis);
    public void SetReferenceBindingFlag(ReferenceFlag flag);
    public virtual CppImplicitConversionSequence Clone();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppBadConversionSequence : CppImplicitConversionSequence {
    public FailureStatus Failure;
    private ReferenceFlag myTargetReferenceFlag;
    [CompilerGeneratedAttribute]
private CppQualType <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private CppQualType <TargetType>k__BackingField;
    public CppQualType SourceType { get; }
    public CppQualType TargetType { get; }
    public int Rank { get; }
    public ReferenceFlag TargetReferenceFlag { get; }
    public CppBadConversionSequence(FailureStatus failure, ReferenceFlag targetReferenceFlag, CppQualType sourceT, CppQualType targetT, ICppResolvedExpression from);
    [CompilerGeneratedAttribute]
public CppQualType get_SourceType();
    [CompilerGeneratedAttribute]
public CppQualType get_TargetType();
    public virtual int get_Rank();
    public virtual ReferenceFlag get_TargetReferenceFlag();
    public virtual TResult Accept(ICppImplicitConversionSequenceVisitor`1<TResult> vis);
    public void SetReferenceBindingFlag(ReferenceFlag flag);
    public virtual CppImplicitConversionSequence Clone();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppBadConversionSequenceForMsRefBindExtension : CppBadConversionSequence {
    [CompilerGeneratedAttribute]
private CppStandardConversionSequence <ExtendedConversionSequence>k__BackingField;
    public CppStandardConversionSequence ExtendedConversionSequence { get; }
    public CppBadConversionSequenceForMsRefBindExtension(FailureStatus failure, ReferenceFlag targetReferenceFlag, CppQualType sourceT, CppQualType targetT, ICppResolvedExpression from, CppStandardConversionSequence extSeq);
    [CompilerGeneratedAttribute]
public CppStandardConversionSequence get_ExtendedConversionSequence();
    public virtual CppImplicitConversionSequence Clone();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppBadUserDefinedConversionSequence : CppBadConversionSequence {
    [CompilerGeneratedAttribute]
private CppOverloadingRunInfo <ConvertingFunctionOverloadingInfo>k__BackingField;
    public CppOverloadingRunInfo ConvertingFunctionOverloadingInfo { get; }
    public CppBadUserDefinedConversionSequence(FailureStatus failure, CppQualType sourceT, CppQualType targetT, CppOverloadingRunInfo convertingFunctionOverloadingInfo, ICppResolvedExpression from);
    [CompilerGeneratedAttribute]
public CppOverloadingRunInfo get_ConvertingFunctionOverloadingInfo();
    public virtual CppImplicitConversionSequence Clone();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppBracedInitTemporaryCaller : object {
    [CompilerGeneratedAttribute]
private BraceInitializedTemporary <BracedInitNode>k__BackingField;
    public BraceInitializedTemporary BracedInitNode { get; }
    public CppBracedInitTemporaryCaller(BraceInitializedTemporary node);
    public sealed virtual TResult Accept(ICppOverloadContextCallerVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public BraceInitializedTemporary get_BracedInitNode();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppBuiltinOperatorCallOverloadContext : CppCommonDataOverloadContext {
    private CppOperatorKind myOperatorKind;
    private CppQualType myBuiltinType;
    public CppBuiltinOperatorCallOverloadContext(CppTypeContext& tc, ICppExpression[] args, CppOperatorKind opKind, CppQualType buitinFunctionType);
    public virtual CppSmallList`1<CppOverloadingCandidate> BuildOverloadSet(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> _, CppOverloadSetBuilderParams builderParams);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppBuiltinOperatorOverloadingCandidate : CppOverloadingCandidate {
    private CppQualType myFuncType;
    [CompilerGeneratedAttribute]
private CppOperatorKind <OperatorKind>k__BackingField;
    public CppOperatorKind OperatorKind { get; }
    public CppQualType VerboseFunctionTypeWithoutSubstitution { get; }
    public string DbgDescription { get; }
    public CppBuiltinOperatorOverloadingCandidate(CppOperatorKind opKind, CppQualType funcType, int explicitArgCount, ICppOverloadingInfoAggregator expTypeConsumer);
    [CompilerGeneratedAttribute]
public CppOperatorKind get_OperatorKind();
    public virtual CppQualType get_VerboseFunctionTypeWithoutSubstitution();
    public string get_DbgDescription();
    public virtual CppQualType GetFunctionType(ICppResolvedTypeFactory tf);
    public virtual CppRestrictionSpecifiers GetFunctionRestrictionSpecifiers();
    public virtual int GetParameterCount();
    public virtual bool HasAnyEllipsis();
    public CppQualType GetFunctionType();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppCallToMemberAccessCaller : object {
    [CompilerGeneratedAttribute]
private ICppResolvedMemberAccessExpression <MemberAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppCallExpression <CallNode>k__BackingField;
    public ICppResolvedMemberAccessExpression MemberAccess { get; }
    public ICppCallExpression CallNode { get; }
    public CppCallToMemberAccessCaller(ICppResolvedMemberAccessExpression node, ICppCallExpression call);
    public sealed virtual TResult Accept(ICppOverloadContextCallerVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public ICppResolvedMemberAccessExpression get_MemberAccess();
    [CompilerGeneratedAttribute]
public ICppCallExpression get_CallNode();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppCallToObjectCaller : object {
    [CompilerGeneratedAttribute]
private ICppCallExpression <CallNode>k__BackingField;
    public ICppCallExpression CallNode { get; }
    public CppCallToObjectCaller(ICppCallExpression node);
    public sealed virtual TResult Accept(ICppOverloadContextCallerVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public ICppCallExpression get_CallNode();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppCallToQualifiedReferenceCaller : object {
    [CompilerGeneratedAttribute]
private ICppResolvedQualifiedReferenceExpression <ReferenceNode>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppCallExpression <CallNode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResolveCallsUsingOnlyADLLookup>k__BackingField;
    public ICppResolvedQualifiedReferenceExpression ReferenceNode { get; }
    public ICppCallExpression CallNode { get; }
    public bool ResolveCallsUsingOnlyADLLookup { get; }
    public CppCallToQualifiedReferenceCaller(ICppResolvedQualifiedReferenceExpression node, ICppCallExpression call);
    public CppCallToQualifiedReferenceCaller(ICppResolvedQualifiedReferenceExpression node, ICppCallExpression call, bool resolveCallsUsingOnlyADLLookup);
    public sealed virtual TResult Accept(ICppOverloadContextCallerVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public ICppResolvedQualifiedReferenceExpression get_ReferenceNode();
    [CompilerGeneratedAttribute]
public ICppCallExpression get_CallNode();
    [CompilerGeneratedAttribute]
public bool get_ResolveCallsUsingOnlyADLLookup();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppCallToTypeCaller : object {
    [CompilerGeneratedAttribute]
private ICppCallExpression <CallNode>k__BackingField;
    public ICppCallExpression CallNode { get; }
    public CppCallToTypeCaller(ICppCallExpression node);
    public sealed virtual TResult Accept(ICppOverloadContextCallerVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public ICppCallExpression get_CallNode();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Overload.CppCastConversion : object {
    [CompilerGeneratedAttribute]
private CppQualType <FromType>k__BackingField;
    [CompilerGeneratedAttribute]
private CppQualType <ToType>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppExpression <SourceExpression>k__BackingField;
    public CppQualType FromType { get; private set; }
    public CppQualType ToType { get; private set; }
    public ICppExpression SourceExpression { get; }
    public CppCastConversion(ICppExpression sourceExpression, CppQualType fromType, CppQualType toType);
    [CompilerGeneratedAttribute]
public CppQualType get_FromType();
    [CompilerGeneratedAttribute]
private void set_FromType(CppQualType value);
    [CompilerGeneratedAttribute]
public CppQualType get_ToType();
    [CompilerGeneratedAttribute]
private void set_ToType(CppQualType value);
    [CompilerGeneratedAttribute]
public ICppExpression get_SourceExpression();
    public abstract virtual bool IsFailure();
    public void ReplaceTargetTypes(CppQualType fromType, CppQualType toType);
}
public static class JetBrains.ReSharper.Psi.Cpp.Overload.CppCastConversionUtil : object {
    public static CppStaticCastConversion BuildStaticCastConversion(ICppResolvedExpression from, CppQualType toT, CppTypeContext& typeContext);
    public static CppDynamicCastConversion BuildDynamicCastConversion(ICppResolvedExpression from, CppQualType toT, CppTypeContext& typeContext);
    public static CppConstCastConversion BuildConstCastConversion(ICppResolvedExpression from, CppQualType toT, CppTypeContext& typeContext);
    public static CppReinterpretCastConversion BuildReinterpretCastConversion(ICppResolvedExpression from, CppQualType toT, CppTypeContext& typeContext);
    public static CppCastConversion BuildSafeCastConversion(ICppResolvedExpression from, CppQualType toT, CppTypeContext& typeContext);
    public static CppCastConversion BuildCStyleCastConversion(ICppResolvedExpression from, CppQualType toT, CppTypeContext& typeContext);
    public static CppCastConversion BuildFunctionStyleCastConversion(ICppResolvedExpression from, CppQualType toT, CppTypeContext& typeContext);
    private static bool IsIllformedStandardConversion(CppStandardConversionSequence convSeq);
    private static bool IsWrongConversionSequenceKind(CppImplicitConversionKind kind);
    private static bool ContainsWrongConversions(CppStandardConversionSequence convSeq);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppClassMethodCallOverloadContext : CppFunctionCallOverloadContext {
    [CompilerGeneratedAttribute]
private ICppResolvedExpression <ObjectArgument>k__BackingField;
    public ICppResolvedExpression ObjectArgument { get; }
    public CppClassMethodCallOverloadContext(CppTypeContext& tc, ICppExpression[] args, ICppTemplateArgument[] templArgs, ICppResolvedExpression objArgNode);
    [CompilerGeneratedAttribute]
public ICppResolvedExpression get_ObjectArgument();
    public virtual CppSmallList`1<CppOverloadingCandidate> BuildOverloadSet(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> candidates, CppOverloadSetBuilderParams builderParams);
    public virtual CppSmallList`1<CppOverloadingCandidate> BuildOverloadSetForParameterInfo(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> candidates, CppOverloadSetBuilderParams builderParams);
    private static bool ContainsBuiltinDestructor(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> candidates);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppCliParameterArrayConversionSequence : CppImplicitConversionSequence {
    [CompilerGeneratedAttribute]
private CppImplicitConversionSequence <Inner>k__BackingField;
    public int Rank { get; }
    public ReferenceFlag TargetReferenceFlag { get; }
    public CppImplicitConversionSequence Inner { get; }
    public CppCliParameterArrayConversionSequence(CppImplicitConversionSequence inner);
    public virtual int get_Rank();
    public virtual ReferenceFlag get_TargetReferenceFlag();
    [CompilerGeneratedAttribute]
public CppImplicitConversionSequence get_Inner();
    public static CppImplicitConversionSequence Wrap(CppImplicitConversionSequence inner);
    public virtual TResult Accept(ICppImplicitConversionSequenceVisitor`1<TResult> vis);
    public virtual CppImplicitConversionSequence Clone();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppCollectingErroneousSubstitutionsConsumer : CppEmptyTemplateDeductionErrorConsumer {
    private OneToListMap`2<ICppTemplateParameter, ICppTemplateArgument> myAllSubstitutions;
    public OneToListMap`2<ICppTemplateParameter, ICppTemplateArgument> Substitutions { get; }
    public virtual OneToListMap`2<ICppTemplateParameter, ICppTemplateArgument> get_Substitutions();
    public virtual void LearnFirstDeducedArg(ICppTemplateParameter param, ICppTemplateArgument arg);
    public virtual void LearnMultipleDeducedArgs(ICppTemplateParameter param, ICppTemplateArgument firstDeduced, ICppTemplateArgument newDeduced);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Overload.CppCommonDataOverloadContext : object {
    private CppTypeContext myTypeContext;
    [CompilerGeneratedAttribute]
private ICppExpression[] <ActualArguments>k__BackingField;
    [IsReadOnlyAttribute]
public CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) TypeContext { get; }
    public ICppExpression[] ActualArguments { get; }
    public CppCommonDataOverloadContext(CppTypeContext& tc, ICppExpression[] arguments);
    public sealed virtual CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) get_TypeContext();
    [CompilerGeneratedAttribute]
public sealed virtual ICppExpression[] get_ActualArguments();
    public abstract virtual CppSmallList`1<CppOverloadingCandidate> BuildOverloadSet(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> candidates, CppOverloadSetBuilderParams builderParams);
    public virtual CppSmallList`1<CppOverloadingCandidate> BuildOverloadSetForParameterInfo(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> candidates, CppOverloadSetBuilderParams builderParams);
    public sealed virtual void ResetTypeFactory(ICppResolvedTypeFactory tf);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppCompareConversionEngine : ValueType {
    private ICppResolvedTypeFactory myTypeFactory;
    private CppViewPos myViewPos;
    public CppCompareConversionEngine(CppTypeContext& tc);
    public CppPartialOrderingResult IsBetterImplicitConversion(CppImplicitConversionSequence lhs, CppImplicitConversionSequence rhs);
    public CppPartialOrderingResult IsBetterStandardConversion(CppStandardConversionSequence lhs, CppStandardConversionSequence rhs);
    public bool IsBetterReferenceBinding(CppReferenceBindingInfo lhs, CppReferenceBindingInfo rhs);
    private CppPartialOrderingResult IsBetterAsSubsequence(CppStandardConversionSequence lhs, CppStandardConversionSequence rhs);
    private CppPartialOrderingResult IsBetterAsDerivedToBase(CppStandardConversionSequence lhs, CppStandardConversionSequence rhs);
    private CppPartialOrderingResult IsBetterAsQualificationConversion(CppStandardConversionSequence lhs, CppStandardConversionSequence rhs);
    private CppPartialOrderingResult IsBetterImplicitConversionDontCheckListInit(CppImplicitConversionSequence lhs, CppImplicitConversionSequence rhs);
    public static bool IsLongToIntConversion(CppStandardConversionSequence seq);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppConstCastBadConversion : CppConstCastConversion {
    [CompilerGeneratedAttribute]
private FailureKind <Failure>k__BackingField;
    public FailureKind Failure { get; }
    public CppConstCastBadConversion(ICppExpression sourceExpr, CppQualType fromType, CppQualType toType, FailureKind failure);
    [CompilerGeneratedAttribute]
public FailureKind get_Failure();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Overload.CppConstCastConversion : CppCastConversion {
    [CompilerGeneratedAttribute]
private ConversionKind <Kind>k__BackingField;
    public ConversionKind Kind { get; }
    protected CppConstCastConversion(ICppExpression sourceExpr, CppQualType fromType, CppQualType toType, ConversionKind kind);
    [CompilerGeneratedAttribute]
public ConversionKind get_Kind();
    public virtual bool IsFailure();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppConstCastSucceededConversion : CppConstCastConversion {
    public CppConstCastSucceededConversion(ICppExpression sourceExpr, CppQualType from, CppQualType to);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppConstraintComparisonEngine : ValueType {
    private Dictionary`2<AtomKey, Atom> myAtomMap;
    private CppConstraintComparisonEngine(CtorTag tag);
    public static CppConstraintComparisonEngine Create();
    public PartialOrderingResult Compare(CppTemplateParametersBase leftDecl, List`1<ICppResolvedExpression> left, CppTemplateParametersBase rightDecl, List`1<ICppResolvedExpression> right, CppTypeContext& typeCtx);
    public PartialOrderingResult Compare(ICppGroupedFunctionDeclaratorResolveEntity leftDecl, ICppResolvedExpression left, ICppGroupedFunctionDeclaratorResolveEntity rightDecl, ICppResolvedExpression right, CppTypeContext& typeCtx);
    private static bool Intersects(InnerClause a, InnerClause b);
    private static InnerClause Merge(InnerClause a, InnerClause b);
    private static NormalForm NewNormalForm();
    private static PartialOrderingResult Compare(NormalFormPair leftNormal, NormalFormPair rightNormal);
    private Atom InternAtom(ICppResolvedExpression expr, object owning_decl);
    private NormalFormPair Normalize(ICppResolvedExpression expr, object owning_decl, CppTypeContext& tc, CppSubstitutionDriver driver);
    private NormalFormPair Normalize(List`1<ICppResolvedExpression> exprs, object owning_decl, CppSubstitutionContext subst, CppTypeContext& tc);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppConstructorCallOverloadContext : CppFunctionCallOverloadContext {
    public CppConstructorCallOverloadContext(CppTypeContext& tc, ICppExpression[] args);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppConversionFunctionOverloadingCandidate : CppMemberFunctionOverloadingCandidate {
    public CppStandardConversionSequence FinalConversion;
    public CppConversionFunctionOverloadingCandidate(ICppGroupedFunctionDeclaratorResolveEntity conversionFunc, CppStandardConversionSequence finalConversion, int explicitArgCount, ICppOverloadingInfoAggregator infoAggregator);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppConversionHelper : ValueType {
    public CppTypeContext TypeContext;
    private CppConversionParameters myParams;
    private ICppOverloadingInfoAggregatorFactory myInfoAggregatorFactory;
    public ICppResolvedTypeFactory TypeFactory { get; }
    public CppViewPos ViewPos { get; }
    public CppConversionParameters ConversionParameters { get; }
    public CppConversionHelper(CppTypeContext& typeContext, CppConversionParameters params, ICppOverloadingInfoAggregatorFactory infoAggregatorFactory);
    public CppConversionHelper(CppTypeContext& typeContext, CppConversionParameters params);
    public CppImplicitConversionSequence TryFromStandardConversion(CppExpressionInfo from, CppQualType toT);
    public CppImplicitConversionSequence FromReferenceInitialization(CppExpressionInfo from, CppQualType toT);
    public CppImplicitConversionSequence FromCopyInitialization(ICppResolvedExpression from, CppQualType toT);
    public CppImplicitConversionSequence FromCopyInitialization(CppExpressionInfo from, CppQualType toT);
    public CppImplicitConversionSequence FromDirectInitialization(CppExpressionInfo from, CppQualType toT);
    public CppImplicitConversionSequence FromListInitialization(ICppExpression[] args, CppExpressionInfo fromInfo, CppQualType toT, bool isDirectInit);
    public CppImplicitConversionSequence FromObjectArgumentInitialization(CppExpressionInfo objArgNode, ICppGroupedFunctionDeclaratorResolveEntity methodDecl, CppQualType objClassT, bool allowCliHandle);
    public CppImplicitConversionSequence FromContextualBoolConversion(ICppResolvedExpression from);
    public CppImplicitConversionSequence FromContextualBoolConversion(CppExpressionInfo from);
    public CppTernaryOperatorConversionResult ForTernaryOperator(CppExpressionInfo left, CppExpressionInfo right);
    public ICppResolvedTypeFactory get_TypeFactory();
    public CppViewPos get_ViewPos();
    public CppConversionParameters get_ConversionParameters();
    [CanBeNullAttribute]
public CppImplicitConversionSequence GetNarrowingConversion(CppImplicitConversionSequence conv);
    private CppImplicitConversionSequence CheckIntToEnumDirectInit(ICppResolvedExpression from, CppQualType toT);
    private CppImplicitConversionSequence FromUserDefinedConversion(CppExpressionInfo from, CppQualType toT, bool isDirectInit, bool isListInit);
    private CppOverloadingRunInfo DoOverloadResolutionForUserDefinedConversions(CppExpressionInfo from, CppQualType toT, bool isDirectInit, bool isListInit, CppImplicitConversionSequence& seq);
    private CppTypeAndCategory CppTypeOf(ICppResolvedExpression expr);
    private CppImplicitConversionSequence TryFromUserDefinedConversionToReferenceType(CppQualType toT, CppExpressionInfo initExpr, ICppClassResolveEntity classEnt, bool allowRvalues, bool allowExplicit, bool isDirectInit);
    private CppImplicitConversionSequence FromReferenceInitializationImpl(CppExpressionInfo from, CppQualType toT, bool isDirectInit);
    private CppImplicitConversionSequence FromCopyInitializationImpl(CppExpressionInfo from, CppQualType toT, bool isDirectInit);
    private CppImplicitConversionSequence FromImplicitConversion(CppExpressionInfo from, CppQualType toT, bool isDirectInit);
    private bool IsTransparentUnion(ICppClassResolveEntity union);
    private bool HasTransparentUnionAttribute(ICppClassResolveEntity union);
    private bool LanguageIsC();
    private bool LanguageIsCLI();
    private bool LanguageIsHLSL();
    private CppGlobalNamespaceResolveEntity GetGlobalNamespace();
    public static bool IsDeprecatedStringLiteralToPtrConversion(CppExpressionInfo from, CppQualType toT, ICppResolvedTypeFactory tf, bool reinterpretCast);
    private static CppImplicitConversionSequence SetRefBindingFlagForFailedConversion(CppImplicitConversionSequence seq, ReferenceFlag targetFlag);
    private static CppNumericTypeKind AdjustCharTypeKind(CppNumericTypeKind k);
    private static bool AreEqualCharTypesForStringInit(CppQualType fromType, CppQualType toType);
    private static bool AreCompatibleArraySize(ICppExpression fromSizeExpr, ICppExpression toSizeExpr, CppTypeContext& tc);
    private static bool BindsDirectly(CppImplicitConversionSequence ics);
    private static bool BindsDirectlyToLvalue(CppImplicitConversionSequence ics);
    private static bool IsPointerToChar(CppTypeAndCategory tc, ICppResolvedTypeFactory tf);
    private static bool IsCandidateExpressionForDeprecatedCharPtrConversion(ICppExpression expression, ICppResolvedTypeFactory tf);
    private static bool IsExpressionForDeprecatedCharPtrConversion(ICppResolvedExpression expression, ICppResolvedTypeFactory tf);
    private static bool IsExpressionForDeprecatedCharPtrConversion(CppExpressionInfo info, ICppResolvedTypeFactory tf);
    private static CppNumericTypeKind AdjustCharTypeKindForDeprecatedStringLiteralToCharPtrConversion(CppNumericTypeKind k);
    private static bool AreEqualCharTypesForDeprecatedStringLiteralToCharPtrConversion(CppQualType lhs, CppQualType rhs);
    [CanBeNullAttribute]
private static CppStandardConversionSequence TryCreateIdentityConversionSequence(CppQualType fromT, CppQualType toT, ICppResolvedExpression from, bool isDirectInit, CppViewPos& viewPos);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppConversionParameters : ValueType {
    public bool SuppressUserConversions;
    public bool AllowExplicitConversions;
    public bool InOverloadResolution;
    public bool InInitDeclarator;
    public bool InReturnStatement;
    public CastKind Cast;
    public ConversionKind Kind;
    public bool InAnyCast { get; }
    public bool InCStyleCast { get; }
    public bool InInverseCast { get; }
    public static CppConversionParameters DefaultParams { get; }
    public static CppConversionParameters ForFunctionReturn { get; }
    public static CppConversionParameters ForDirectInitDecl { get; }
    public static CppConversionParameters ForCopyInitDecl { get; }
    public static CppConversionParameters ForContextualBoolConversion { get; }
    public static CppConversionParameters ForConvertedConstantExpression { get; }
    private CppConversionParameters(bool suppressUserConversions, bool allowExplicit, bool inOverloadResolution, CastKind cast, bool inInitDeclarator, bool inReturnStatement, ConversionKind kind);
    public bool get_InAnyCast();
    public bool get_InCStyleCast();
    public bool get_InInverseCast();
    public static CppConversionParameters get_DefaultParams();
    public static CppConversionParameters get_ForFunctionReturn();
    public static CppConversionParameters get_ForDirectInitDecl();
    public static CppConversionParameters get_ForCopyInitDecl();
    public static CppConversionParameters get_ForContextualBoolConversion();
    public static CppConversionParameters get_ForConvertedConstantExpression();
    public CppConversionParameters WithSupressUserConversions(bool value);
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(CppConversionParameters other);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Overload.CppConversionSequencesUtil : object {
    [ExtensionAttribute]
public static Nullable`1<CppQualType> TryRecoverTargetType(CppImplicitConversionSequence seq);
    public static CppImplicitConversionSequence RecoverForMsExtensions(CppImplicitConversionSequence seq);
    [ExtensionAttribute]
public static bool IsFailureConversion(CppImplicitConversionSequence conv);
    [ExtensionAttribute]
public static bool IsUnknownConversion(CppImplicitConversionSequence conv);
    [ExtensionAttribute]
public static bool IsSpecialNonFailureConversion(CppImplicitConversionSequence conv);
    [ExtensionAttribute]
public static CppImplicitConversionRank GetStandardConversionRank(CppStandardConversionSequence stdSeq);
    public static void MakeMax(CppStandardConversionPart conversion, CppImplicitConversionRank& result);
    [ExtensionAttribute]
public static bool IsIdentityConversion(CppStandardConversionSequence seq);
    [ExtensionAttribute]
public static bool IsDerivedToBaseConversion(CppStandardConversionSequence seq);
    [ExtensionAttribute]
public static bool IsPointerToBoolStandardConversion(CppStandardConversionSequence seq);
    [ExtensionAttribute]
public static bool IsPointerToVoidPtrStandardConversion(CppStandardConversionSequence seq);
    [ExtensionAttribute]
public static bool IsWrapperForSpecialConversion(CppStandardConversionSequence seq);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Overload.CppConversionsUtil : object {
    [ExtensionAttribute]
public static CppImplicitConversionSequence DoConversion(CppExpressionInfo from, CppQualType to, CppConversionParameters convParams, CppTypeContext& tc, ICppOverloadingInfoAggregatorFactory overloadingInfoAggregatorFactory);
    [ExtensionAttribute]
public static CppImplicitConversionSequence DoConversion(CppExpressionInfo from, CppQualType to, CppConversionParameters convParams, CppTypeContext& tc);
    [ExtensionAttribute]
private static bool IsConvertibleTo(CppExpressionInfo from, CppQualType type, CppConversionParameters convParams, CppTypeContext& tc, bool checkNothrow, bool treatMsBindRefExtensionAsError);
    [ExtensionAttribute]
public static bool IsConvertibleTo(CppExpressionInfo from, CppQualType type, CppConversionParameters convParams, CppTypeContext& tc);
    [ExtensionAttribute]
public static bool IsNothrowConvertibleTo(CppExpressionInfo from, CppQualType type, CppConversionParameters convParams, CppTypeContext& tc);
    public static HlslVectorInitializationResult TryHlslVectorInitialization(CppQualType targetType, ICppArgumentList args, CppTypeContext& tc);
    [ExtensionAttribute]
public static void TraverseConversion(CppImplicitConversionSequence conv, ICppConversionVisitor vis);
    [ExtensionAttribute]
public static void TraverseOverloadingRun(CppOverloadingRunInfo info, ICppConversionVisitor vis);
    [ExtensionAttribute]
public static void TraverseCastConversion(CppCastConversion castConv, ICppConversionVisitor vis);
    [ExtensionAttribute]
public static bool IsFailureConversionOrUsageOfDeletedFunction(CppImplicitConversionSequence conv);
    public static Nullable`1<CppOverloadingRunInfo> ResolveCopyConstructorIfRequired(CppStandardConversionSequence seq, CppTypeContext& tc, CppExpressionInfo from, ICppOverloadingInfoAggregatorFactory expTypeFactory);
    [ExtensionAttribute]
public static bool IsNarrowingConversion(CppExpressionInfo from, CppQualType to, CppConversionParameters convParams, CppTypeContext& tc);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Overload.CppDeduceFromListEngine`2 : object {
    public abstract virtual ICppTemplateSubstitutionConsumer GetTemplateSubstitutionConsumer();
    public abstract virtual bool ExpandParamAndDeduceEmptySubstitution(TParam param);
    public abstract virtual bool ExpandParamAndDeduce(int argIndex, TParam param, TArg arg);
    public abstract virtual bool IsPackExpansion(TParam param);
    public abstract virtual bool IsNullablePackExpansion(TParam param);
    public abstract virtual TParam DropPackExpansion(TParam param);
    public abstract virtual bool Deduce(int argIndex, TParam param, TArg arg);
    public virtual DeductionStatus<TParam, TArg> ProcessLastUnmatchedArgument(TArg arg);
    public abstract virtual HashSet`1<ICppTemplateParameterPack> GetUnexpandedPackDependencies(TParam paramType);
    public DeductionStatus<TParam, TArg> RunDeduction(ReadOnlySpan`1<TParam> paramTypes, ReadOnlySpan`1<TArg> argTypes, bool treatMissingArgumentsAsUnknown, int firstDefaultedArg);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Overload.CppDeduceTemplateArgumentsUtil : object {
    public static CppTemplateArgumentDeductionResult DeduceAutoType(CppQualType paramT, ICppResolvedExpression autoInitializer, CppTypeContext& tc, bool isStructuredBindingDeclaration);
    public static CppTemplateArgumentDeductionResult DeduceTemplateArgumentsForClassSpecialization(CppTemplateParametersBase templParams, ICppTemplateArgument[] paramArgs, ICppTemplateArgument[] argArgs, CppViewPos& viewPos);
    public static CppTemplateArgumentDeductionResult DeduceTemplateArgumentsForAddressOfTemplateFunction(ICppFunctionTemplateDeclaratorResolveEntity func, ICppTemplateArgument[] explicitArgs, CppQualType funcType, CppQualType targetType, CppTypeContext& tc);
    private static ParamCount GetMinMaxParamCount(CppQualType functionType);
    [ExtensionAttribute]
public static CppTemplateFunctionCallArgumentDeductionResult DeduceTemplateArgumentsForCall(ICppFunctionTemplateDeclaratorResolveEntity function, CppTypeContext& tc, ICppTemplateFunctionCallDeductionErrorConsumer errorConsumer);
    [ExtensionAttribute]
public static CppTemplateFunctionCallArgumentDeductionResult DeduceTemplateArgumentsForCall(ICppFunctionTemplateLikeDeducibleResolveEntity function, ICppTemplateArgument[] explicitArgs, ReadOnlySpan`1<ICppExpression> args, ICppResolvedExpression explicitThis, CppTypeContext& tc, ICppTemplateFunctionCallDeductionErrorConsumer errorConsumer, bool treatMissingArgumentsAsUnknown, bool shouldDeduceFromDependentArguments);
    public static CppTemplateArgumentDeductionResult DeduceTemplateArgumentsForClassSpecialization(CppTemplateParametersBase templParams, ICppTemplateArgument[] paramArgs, ICppTemplateArgument[] argArgs, CppViewPos& viewPos, ICppTemplateDeductionErrorConsumer errorConsumer);
    public static CppTemplateArgumentDeductionResult DeduceTemplateArgumentsForConversion(CppTemplateParametersBase templParams, ICppFunctionTemplateDeclaratorResolveEntity convFunction, CppExpressionInfo from, CppQualType convFunctionType, CppQualType targetType, ICppResolvedExpression explicitExpr, CppTypeContext& tc, ICppTemplateDeductionErrorConsumer errorConsumer);
    public static bool DeduceTemplateArgumentsFromType(CppQualType paramT, CppQualType argT, CppTypeDeductionOptions options, ICppTemplateSubstitutionConsumer consumer, CppTypeContext& tc);
    public static bool DeduceTemplateArgumentsFromTemplateArguments(ICppTemplateArgument[] paramArgs, ICppTemplateArgument[] argArgs, ICppTemplateSubstitutionConsumer consumer, CppTypeContext& tc);
    public static CppTemplateArgumentDeductionResult DeduceConversionId(CppTemplateParametersBase templParams, ICppTemplateArgument[] defaults, CppQualType paramT, CppQualType argT, CppTypeContext& tc);
    public static CppTemplateArgumentDeductionResult DeduceAutoType(CppQualType paramT, ICppResolvedExpression autoInitializer, CppTypeContext& tc);
    private static CppQualType GetInitListAutoType(CppTypeContext& tc);
    private static CppQualType GetFunctionTypeForOverloadedTypeDeduction(ICppDeclaratorResolveEntity declEnt, ICppResolvedTypeFactory tf);
    private static bool DeduceFromConversionReturnType(CppQualType argType, CppQualType paramType, ICppTemplateSubstitutionConsumer consumer, CppTypeContext& tc);
    private static void SubstituteParameterListIfNeeded(CppSubstitutionContext& ctx, CppTypeContext& tc, ICppFunctionTemplateLikeDeducibleResolveEntity func);
    private static CppSubstitutionContext RepackSubstitutionContext(CppSubstitutionContext ctx, CppTemplateParametersBase params, CppTypeContext& tc, ICppFunctionTemplateLikeDeducibleResolveEntity func, Boolean& wasRepacked);
    private static void CoerceRvalueRefsToLvalueRefsIfTopLevel(CppQualType& paramType, CppQualType argType, CppTypeDeductionOptions opts);
    private static bool DeduceTemplateParametersFromPartialSpecExprArg(ICppResolvedExpression parSpecExprArg, ICppResolvedExpression exprArg, ICppTemplateSubstitutionConsumer consumer);
    private static bool DeduceTemplateParametersFromPartialSpecTypeArg(CppQualType parSpecTypeArg, CppQualType typeArg, ICppTemplateSubstitutionConsumer consumer, CppTypeContext& tc);
    private static bool DoTemplateParameterMatch(ICppTemplateParameter one, ICppTemplateParameter other);
    private static bool DoTemplateParametersMatch(CppTemplateParametersBase ones, CppTemplateParametersBase others);
    private static bool DoTemplateTemplateArgumentMatchTemplateTemplateParameter(ICppTemplateTemplateArgument arg, ICppTemplateTemplateParameterOrPack par);
    private static bool DeduceTemplateArgumentsFromTypeImpl(CppQualType paramT, CppQualType argT, CppTypeDeductionOptions options, ICppTemplateSubstitutionConsumer consumer, CppTypeContext& tc, bool needDealias);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppDetectMultipleHitConsumer : object {
    private ICppTemplateSubstitutionConsumer myInnerConsumer;
    private CompactMap`2<ICppTemplateParameter, ICppTemplateArgument> mySubstitution;
    private ICppTemplateArgument myAutoSubstitution;
    private CppTypeContext myTypeContext;
    [CompilerGeneratedAttribute]
private bool <HadMultipleHits>k__BackingField;
    public bool HadMultipleHits { get; private set; }
    public CppDetectMultipleHitConsumer(ICppTemplateSubstitutionConsumer c, CppTypeContext& tc);
    [CompilerGeneratedAttribute]
public bool get_HadMultipleHits();
    [CompilerGeneratedAttribute]
private void set_HadMultipleHits(bool value);
    public sealed virtual bool ShouldMatchMagicArgumentTypesWithAnything();
    public sealed virtual bool ShouldDeduceFromDependentArguments();
    public sealed virtual bool ShouldSubstituteAuto();
    public sealed virtual bool ShouldSubstitute(ICppTemplateParameter param);
    public sealed virtual bool DependentExpressionTemplateParameterIsAllowed();
    public sealed virtual CppSubstitutionResult LearnSubstitution(ICppTemplateParameter param, ICppTemplateArgument argument);
    public sealed virtual CppSubstitutionResult LearnSubstitutionSanitized(ICppTemplateParameter param, ICppTemplateArgument argument);
    public sealed virtual void LearnAutoSubstitution(ICppTemplateArgument argument);
    public sealed virtual IEnumerable`1<ICppTemplateParameter> GetTargetParameters();
    public sealed virtual void StartVariadic(int expansionLength, HashSet`1<ICppTemplateParameterPack> expansionParameters);
    public sealed virtual void SetVariadicIndex(int index, HashSet`1<ICppTemplateParameterPack> expansionParameters);
    public sealed virtual void FinishVariadic(HashSet`1<ICppTemplateParameterPack> expansionParameters);
    public sealed virtual ICppTemplateDeductionErrorConsumer GetErrorConsumer();
    public void PushSubstitutionsToInnerConsumer();
    public ICollection`1<ICppTemplateParameter> GetDeducedTemplateParameters();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppDynamicCastBadConversion : CppDynamicCastConversion {
    [CompilerGeneratedAttribute]
private FailureKind <Failure>k__BackingField;
    public FailureKind Failure { get; }
    public CppDynamicCastBadConversion(ICppExpression sourceExpr, CppQualType fromType, CppQualType toType, FailureKind failure);
    [CompilerGeneratedAttribute]
public FailureKind get_Failure();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Overload.CppDynamicCastConversion : CppCastConversion {
    [CompilerGeneratedAttribute]
private ConversionKind <Kind>k__BackingField;
    public ConversionKind Kind { get; }
    protected CppDynamicCastConversion(ICppExpression sourceExpr, CppQualType fromType, CppQualType toType, ConversionKind kind);
    [CompilerGeneratedAttribute]
public ConversionKind get_Kind();
    public virtual bool IsFailure();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppDynamicCastRuntimeConversion : CppDynamicCastConversion {
    public CppDynamicCastRuntimeConversion(ICppExpression sourceExpr, CppQualType fromType, CppQualType toType);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppEllipsisConversionSequence : CppImplicitConversionSequence {
    public int Rank { get; }
    public ReferenceFlag TargetReferenceFlag { get; }
    public CppEllipsisConversionSequence(ICppResolvedExpression from);
    public virtual int get_Rank();
    public virtual ReferenceFlag get_TargetReferenceFlag();
    public virtual TResult Accept(ICppImplicitConversionSequenceVisitor`1<TResult> vis);
    public virtual CppImplicitConversionSequence Clone();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppEmptyConversionSequence : CppImplicitConversionSequence {
    public int Rank { get; }
    public ReferenceFlag TargetReferenceFlag { get; }
    public CppEmptyConversionSequence(ICppResolvedExpression from);
    public virtual int get_Rank();
    public virtual ReferenceFlag get_TargetReferenceFlag();
    public virtual TResult Accept(ICppImplicitConversionSequenceVisitor`1<TResult> vis);
    public virtual CppImplicitConversionSequence Clone();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppEmptyInfoAggregatorFactory : object {
    public static CppEmptyInfoAggregatorFactory Instance;
    private static CppEmptyInfoAggregatorFactory();
    public sealed virtual ICppOverloadingInfoAggregator Create();
    public sealed virtual ICppResolvedTypeFactory RefineTypeFactory(ICppResolvedTypeFactory tf);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppEmptyTemplateDeductionErrorConsumer : object {
    public static CppEmptyTemplateDeductionErrorConsumer Instance;
    private static CppEmptyTemplateDeductionErrorConsumer();
    public virtual void LearnFirstDeducedArg(ICppTemplateParameter param, ICppTemplateArgument arg);
    public virtual void LearnMultipleDeducedArgs(ICppTemplateParameter param, ICppTemplateArgument firstDeduced, ICppTemplateArgument newDeduced);
    public virtual void LearnTypeMismatchError(int argIndex, CppQualType paramType, ICppResolvedExpression arg);
    public virtual void LearnNondeducedParameters(CppList`1<ICppTemplateParameter> params);
    public virtual void LearnMismatchedParameterArgumentPair(ICppTemplateParameter par, ICppTemplateArgument arg);
    public virtual void LearnTooManyExplicitArguments(ICppTemplateArgument firstExcessArgument);
    public virtual void LearnSubstitutionFailureError();
    public virtual void LearnConstraintNotSatisfiedError(ICppResolvedExpression e, CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) typeContext);
    public virtual void LearnDefaultTemplateArgumentSubstitutionFailed(ICppTemplateParameter p, ICppTemplateArgument a, CppSubstitutionContext sc, CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc);
    public virtual void LearnTypeOfExpressionTemplateParameterSubstitutionFailed(CppQualType t, CppSubstitutionContext sc, CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc);
    public virtual void LearnFunctionTypeSubstitutionFailed(CppQualType original, CppQualType substituted, CppSubstitutionContext sc, CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc);
    public virtual void LearnTemplateParametersDeducedFromOverloadedType(ICppResolvedQualifiedReferenceExpression e, ICollection`1<ICppTemplateParameter> params);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppFunctionCallOverloadContext : CppCommonDataOverloadContext {
    [CompilerGeneratedAttribute]
private ICppTemplateArgument[] <TemplateArgs>k__BackingField;
    public ICppTemplateArgument[] TemplateArgs { get; }
    public CppFunctionCallOverloadContext(CppTypeContext& tc, ICppExpression[] args, ICppTemplateArgument[] templArgs);
    public virtual CppSmallList`1<CppOverloadingCandidate> BuildOverloadSet(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> candidates, CppOverloadSetBuilderParams builderParams);
    public virtual CppSmallList`1<CppOverloadingCandidate> BuildOverloadSetForParameterInfo(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> candidates, CppOverloadSetBuilderParams builderParams);
    [CompilerGeneratedAttribute]
public ICppTemplateArgument[] get_TemplateArgs();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Overload.CppGenericErrorHandlingSubstitutionConsumer`1 : CppLearnSubstitutionConsumer {
    private TErrorConsumer myErrorConsumer;
    public bool ExplicitArgSubstitutionFailed { get; }
    public TErrorConsumer ErrorConsumer { get; }
    protected CppGenericErrorHandlingSubstitutionConsumer`1(CppTemplateParametersBase templParams, CppTypeContext& tc, TErrorConsumer errorConsumer);
    public bool get_ExplicitArgSubstitutionFailed();
    public TErrorConsumer get_ErrorConsumer();
    public virtual ICppTemplateDeductionErrorConsumer GetErrorConsumer();
    public virtual CppTemplateArgumentDeductionResult ComposeResult(ICppTemplateArgument[] defaults, bool treatMissingArgumentsAsUnknown);
    protected virtual void SubstituteExplicitArgsIntoCurrentSubstitution(CppSubstitutionContext ctx);
    protected virtual void OnLearnedIncompatibleSubstitution(ICppTemplateParameter param, ICppTemplateArgument currentArg, ICppTemplateArgument newArg);
    protected virtual void OnLearnedFirstSubstitution(ICppTemplateParameter param, ICppTemplateArgument arg);
    protected virtual void OnLearnedParametersWithoutSubstitution(CppList`1<ICppTemplateParameter> params);
    protected virtual void OnLearnedMismatchedTemplateParameterArgumentPair(ICppTemplateParameter par, ICppTemplateArgument arg);
    protected virtual void OnLearnedTooExplicitManyArguments(ICppTemplateArgument firstExcessArgument);
    protected virtual void OnLearnedDefaultTemplateArgumentSubstitutionFailed(ICppTemplateParameter param, ICppTemplateArgument arg);
    protected virtual void OnLearnedExplicitArgs();
    protected virtual void OnLearnedSubstitutionFailureArgument();
    private bool TypeOfExpressionTemplateParameterHasFailureFailure(CppTemplateParametersBase params);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppHLSLScalarToStructConversion : CppCastConversion {
    public CppHLSLScalarToStructConversion(ICppExpression sourceExpr, CppQualType fromType, CppQualType toType);
    public virtual bool IsFailure();
}
public enum JetBrains.ReSharper.Psi.Cpp.Overload.CppImplicitConversionKind : Enum {
    public int value__;
    public static CppImplicitConversionKind Identity;
    public static CppImplicitConversionKind LvalueToRvalue;
    public static CppImplicitConversionKind ArrayToPointer;
    public static CppImplicitConversionKind FunctionToPointer;
    public static CppImplicitConversionKind Qualification;
    public static CppImplicitConversionKind CliStringLiteralConversion;
    public static CppImplicitConversionKind IntegralPromotion;
    public static CppImplicitConversionKind FloatingPromotion;
    public static CppImplicitConversionKind CliBoxingConversion;
    public static CppImplicitConversionKind CliClrcallConversion;
    public static CppImplicitConversionKind IntegralConversion;
    public static CppImplicitConversionKind FloatingConversion;
    public static CppImplicitConversionKind FloatingIntegral;
    public static CppImplicitConversionKind CliHandleConversion;
    public static CppImplicitConversionKind PointerConversion;
    public static CppImplicitConversionKind PointerMember;
    public static CppImplicitConversionKind BooleanConversion;
    public static CppImplicitConversionKind DerivedToBase;
    public static CppImplicitConversionKind HlslExtensionConversion;
    public static CppImplicitConversionKind HlslTruncationConversion;
    public static CppImplicitConversionKind HlslQualification;
    public static CppImplicitConversionKind Max;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Overload.CppImplicitConversionKindUtil : object {
    [ExtensionAttribute]
public static CppImplicitConversionRank GetConversionRankByKind(CppImplicitConversionKind Kind);
}
public enum JetBrains.ReSharper.Psi.Cpp.Overload.CppImplicitConversionRank : Enum {
    public int value__;
    public static CppImplicitConversionRank ExactMatch;
    public static CppImplicitConversionRank Promotion;
    public static CppImplicitConversionRank Conversion;
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Overload.CppImplicitConversionSequence : object {
    public static int StandardConversionRank;
    public static int UserDefinedConversionRank;
    public static int CppImplicitConversionKind_BitSize;
    public static int CppImplicitConversionKind_BitMask;
    private CppInitializationInfo myAttachedInfo;
    [CompilerGeneratedAttribute]
private ICppResolvedExpression <FromExpression>k__BackingField;
    public ICppResolvedExpression FromExpression { get; }
    [CanBeNullAttribute]
public CppListInitializationInfo ListInitInfo { get; }
    [CanBeNullAttribute]
public CppAggregateInitializationInfo AggregateInitInfo { get; }
    public bool IsReferenceBinding { get; }
    public int Rank { get; }
    public ReferenceFlag TargetReferenceFlag { get; }
    private static CppImplicitConversionSequence();
    protected CppImplicitConversionSequence(ICppResolvedExpression from);
    [CompilerGeneratedAttribute]
public ICppResolvedExpression get_FromExpression();
    public CppListInitializationInfo get_ListInitInfo();
    public CppAggregateInitializationInfo get_AggregateInitInfo();
    public bool get_IsReferenceBinding();
    public abstract virtual int get_Rank();
    public abstract virtual ReferenceFlag get_TargetReferenceFlag();
    public abstract virtual TResult Accept(ICppImplicitConversionSequenceVisitor`1<TResult> vis);
    public CppImplicitConversionSequence CloneAndAttachInfo(CppInitializationInfo attachedInfo);
    public abstract virtual CppImplicitConversionSequence Clone();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppInitDeclaratorCaller : object {
    [CompilerGeneratedAttribute]
private InitDeclarator <InitDecl>k__BackingField;
    public InitDeclarator InitDecl { get; }
    public CppInitDeclaratorCaller(InitDeclarator initDecl);
    public sealed virtual TResult Accept(ICppOverloadContextCallerVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public InitDeclarator get_InitDecl();
}
public interface JetBrains.ReSharper.Psi.Cpp.Overload.CppInitializationInfo {
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppIsBetterCandidateResult : ValueType {
    public bool IsBetter;
    public bool HadBetterConversion;
    public CppIsBetterCandidateResult(bool isBetter, bool hadBetterConversion);
    public static CppIsBetterCandidateResult IsBetterCandidate(CppOverloadingCandidate lhs, CppOverloadingCandidate rhs, bool userDefinedConversion, bool recoverForMsExtensions, CppTypeContext& tc);
    private static bool IsSameParameterTypes(ICppGroupedFunctionDeclaratorResolveEntity lhs, ICppGroupedFunctionDeclaratorResolveEntity rhs, CppTypeContext& tc);
    private static bool IsSameParameterTypes(ICppGroupedFunctionDeclaratorResolveEntity lhs, ICppGroupedFunctionDeclaratorResolveEntity rhs, CppTypeContext& tc, int numParamsToCheck);
    private static int GetElementsNumber(CppQualType type);
    private static CppNumericTypeKind GetElementKind(CppQualType t);
    private static CppNumericTypeKind GetCombinedKind(CppNumericTypeKind left, CppNumericTypeKind right, CppLanguageDialect dialect);
    private static bool IsHlslCast(CppNumericTypeKind leftKind, CppNumericTypeKind rightKind, CppLanguageDialect dialect);
    private static ulong HlslOverloadingScoreFunction(CppStandardConversionSequence seq, CppLanguageDialect dialect);
    private static ulong ComputeHlslOverloadingScore(CppImplicitConversionSequence seq, CppLanguageDialect dialect);
    private static ulong ComputeHlslOverloadingScore(CppOverloadingCandidate candidate, int numArgs, CppLanguageDialect dialect);
    private static bool HaveSameParameterTypes(ICppGroupedFunctionDeclaratorResolveEntity lhs, ICppGroupedFunctionDeclaratorResolveEntity rhs, CppTypeContext& tc);
    [CompilerGeneratedAttribute]
internal static void <HlslOverloadingScoreFunction>g__ScoreCond|10_0(int shift, bool cond, <>c__DisplayClass10_0& );
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppLearnAutoSubstitutionConsumer : CppLearnSubstitutionConsumer {
    public CppLearnAutoSubstitutionConsumer(CppTypeContext& tc);
    public virtual bool ShouldSubstituteAuto();
    protected virtual void Substitute(CppSubstitutionContext ctx);
    protected virtual bool HasFailedSubstitutions(CppSubstitutionContext ctx);
    public virtual ICppTemplateDeductionErrorConsumer GetErrorConsumer();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Overload.CppLearnSubstitutionConsumer : object {
    protected CppSubstitutionContext myExplicitArgumentsSubstitution;
    protected bool myExplicitArgSubstitutionFailed;
    protected CppTypeContext myTypeContext;
    private CppList`1<SubstitutionStackElement> mySubstitutionStack;
    private SubstitutionStackElement myTop;
    private List`1<CppSubstitutionContext> myConsumedSubstitutions;
    private CppTemplateParametersBase myTemplateParameters;
    private bool myDefaultArgsSubstitutionFailed;
    [CompilerGeneratedAttribute]
private bool <Failed>k__BackingField;
    public bool Failed { get; private set; }
    protected CppSubstitutionContext CurrentSubstitution { get; }
    protected CppLearnSubstitutionConsumer(CppTemplateParametersBase templParams, CppTypeContext& tc);
    [CompilerGeneratedAttribute]
public bool get_Failed();
    [CompilerGeneratedAttribute]
private void set_Failed(bool value);
    protected CppSubstitutionContext get_CurrentSubstitution();
    public virtual bool ShouldMatchMagicArgumentTypesWithAnything();
    public virtual bool ShouldDeduceFromDependentArguments();
    public virtual bool DependentExpressionTemplateParameterIsAllowed();
    public virtual bool ShouldSubstitute(ICppTemplateParameter param);
    public virtual bool ShouldSubstituteAuto();
    public virtual void LearnAutoSubstitution(ICppTemplateArgument argument);
    public virtual CppSubstitutionResult LearnSubstitution(ICppTemplateParameter param, ICppTemplateArgument argument);
    public virtual CppSubstitutionResult LearnSubstitutionSanitized(ICppTemplateParameter param, ICppTemplateArgument argument);
    public abstract virtual ICppTemplateDeductionErrorConsumer GetErrorConsumer();
    public virtual IEnumerable`1<ICppTemplateParameter> GetTargetParameters();
    public sealed virtual void StartVariadic(int expansionLength, HashSet`1<ICppTemplateParameterPack> expansionParameters);
    public sealed virtual void SetVariadicIndex(int index, HashSet`1<ICppTemplateParameterPack> expansionParameters);
    public sealed virtual void FinishVariadic(HashSet`1<ICppTemplateParameterPack> expansionParameters);
    public CppSubstitutionResult LearnSubstitutionInternal(ICppTemplateParameter param, ICppTemplateArgument argument, CppSubstitutionContext target);
    public CppTemplateArgumentDeductionResult ComposeResult(ICppTemplateArgument[] defaults);
    public virtual CppTemplateArgumentDeductionResult ComposeResult(ICppTemplateArgument[] defaults, bool treatMissingArgumentsAsUnknown);
    private bool NotAllParamsHaveSubstitution(CppSubstitutionContext coalesced, bool treatMissingArgumentsAsUnknown);
    private bool HasSubstitutionFailureInDeduction(CppSubstitutionContext coalesced);
    protected virtual ICppTemplateArgument CreateUnknownTemplateArgument(ICppTemplateParameter param);
    public CppTemplateParametersBase GetTemplateParameters();
    public void LearnExplicitArgs(ICppTemplateArgument[] args);
    protected virtual void OnLearnedExplicitArgs();
    protected virtual void OnLearnedIncompatibleSubstitution(ICppTemplateParameter param, ICppTemplateArgument currentArg, ICppTemplateArgument newArg);
    protected virtual void OnLearnedFirstSubstitution(ICppTemplateParameter param, ICppTemplateArgument arg);
    protected virtual void OnLearnedParametersWithoutSubstitution(CppList`1<ICppTemplateParameter> params);
    protected virtual void OnLearnedMismatchedTemplateParameterArgumentPair(ICppTemplateParameter par, ICppTemplateArgument arg);
    protected virtual void OnLearnedTooExplicitManyArguments(ICppTemplateArgument firstExcessArgument);
    protected virtual void OnLearnedDefaultTemplateArgumentSubstitutionFailed(ICppTemplateParameter param, ICppTemplateArgument arg);
    protected virtual void OnLearnedSubstitutionFailureArgument();
    protected abstract virtual void Substitute(CppSubstitutionContext ctx);
    protected abstract virtual bool HasFailedSubstitutions(CppSubstitutionContext ctx);
    [CanBeNullAttribute]
protected virtual ICppResolvedExpression CheckConstraintsAndSubstitute(CppSubstitutionContext ctx, CppList`1<int> defaultedTemplateArgs);
    protected void Fail();
    private ICppTemplateArgument SubstituteDefault(ICppTemplateArgument default_, int index);
    private void PushEmptyPackSubstitutionsIfAny(CppSubstitutionContext ctx);
    protected bool CheckAllParametersHaveSubstitution(CppSubstitutionContext ctx);
    private ICppTemplateParameter FindParameterByTag(CppTemplateParameterTag tag);
    private void CoalesceWith(CppSubstitutionContext other);
    private ValueTuple`2<CppSubstitutionContext, CppList`1<int>> Coalesce(ICppTemplateArgument[] defaultArguments);
    private ValueTuple`3<CppList`1<ICppTemplateParameter>, bool, CppList`1<int>> FindNonDeducedParameters(ICppTemplateArgument[] defaultArguments);
    protected bool Do(ICppTemplateArgument target, ICppTemplateArgument arg);
    private void HandleResubstitution(CppTemplateParameterTag tag, ICppTemplateArgument oldArg, ICppTemplateArgument newArgument);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppListInitializationInfo : object {
    [CompilerGeneratedAttribute]
private bool <IsStdInitListElementConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private FrugalLocalList`1<CppImplicitConversionSequence> <InitListConversions>k__BackingField;
    public bool IsStdInitListElementConversion { get; }
    public FrugalLocalList`1<CppImplicitConversionSequence> InitListConversions { get; }
    public CppListInitializationInfo(bool isStdInitListElementConversion, FrugalLocalList`1<CppImplicitConversionSequence> initListConversions);
    [CompilerGeneratedAttribute]
public bool get_IsStdInitListElementConversion();
    [CompilerGeneratedAttribute]
public FrugalLocalList`1<CppImplicitConversionSequence> get_InitListConversions();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppMemberFunctionOverloadingCandidate : CppOrdinaryOverloadingCandidate {
    [CompilerGeneratedAttribute]
private bool <IgnoreObjectArgument>k__BackingField;
    public bool IgnoreObjectArgument { get; }
    public int ExplicitCallArgumentsForHighlighting { get; }
    protected CppMemberFunctionOverloadingCandidate(ICppGroupedFunctionDeclaratorResolveEntity func, bool ignoreObjectArg, int explicitArgCount, ICppOverloadingInfoAggregator infoAggregator, CppOperatorRewriteKind rewriteKind);
    [CompilerGeneratedAttribute]
public bool get_IgnoreObjectArgument();
    public virtual int get_ExplicitCallArgumentsForHighlighting();
    public static CppMemberFunctionOverloadingCandidate Create(ICppGroupedFunctionDeclaratorResolveEntity func, bool ignoreObjectArg, int explicitArgCount, ICppOverloadingInfoAggregator infoAggregator, CppOperatorRewriteKind rewriteKind);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppMemInitializerCaller : object {
    [CompilerGeneratedAttribute]
private MemInitializer <MemInit>k__BackingField;
    public MemInitializer MemInit { get; }
    public CppMemInitializerCaller(MemInitializer node);
    public sealed virtual TResult Accept(ICppOverloadContextCallerVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public MemInitializer get_MemInit();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Overload.CppNarrowingConversionUtil : object {
    [ExtensionAttribute]
public static bool IsNarrowingConversionWithoutLiteralCheck(CppStandardConversionSequence seq, CppLanguageDialect dialect);
    [ExtensionAttribute]
public static TriBool IsNarrowingConversion(CppStandardConversionSequence seq, CppTypeContext& tc);
    private static TriBool IsConvertibleLiteral(CppStandardConversionSequence seq, CppTypeContext& tc);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppNewExpressionCaller : object {
    [CompilerGeneratedAttribute]
private ICppNewExpression <NewExpr>k__BackingField;
    public ICppNewExpression NewExpr { get; }
    public CppNewExpressionCaller(ICppNewExpression newExpr);
    public sealed virtual TResult Accept(ICppOverloadContextCallerVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public ICppNewExpression get_NewExpr();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppNewOperatorCaller : object {
    [CompilerGeneratedAttribute]
private ICppNewExpression <NewExpr>k__BackingField;
    public ICppNewExpression NewExpr { get; }
    public CppNewOperatorCaller(ICppNewExpression expr);
    public sealed virtual TResult Accept(ICppOverloadContextCallerVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public ICppNewExpression get_NewExpr();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOperatorCallOverloadContext : CppCommonDataOverloadContext {
    private CppOperatorKind myOperatorKind;
    private bool myAllowRewrittenCandidates;
    private ICppFunctionOrTemplateDeclaratorResolveEntity myCandidateToSkip;
    private FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> myFirstLookupPhaseCandidates;
    public CppOperatorCallOverloadContext(CppTypeContext& tc, ICppExpression[] args, CppOperatorKind opKind);
    public CppOperatorCallOverloadContext(CppTypeContext& tc, ICppExpression[] args, CppOperatorKind opKind, bool allowRewrittenCandidates, ICppFunctionOrTemplateDeclaratorResolveEntity candidateToSkip, FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> firstLookupPhaseCandidates);
    public virtual CppSmallList`1<CppOverloadingCandidate> BuildOverloadSet(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> candidates, CppOverloadSetBuilderParams builderParams);
    private bool BuildBuiltinCandidates();
    public virtual CppSmallList`1<CppOverloadingCandidate> BuildOverloadSetForParameterInfo(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> candidates, CppOverloadSetBuilderParams builderParams);
    public CppOperatorKind GetOperatorKind();
    private void PatchSetOfCandidates(FrugalLocalList`1& candidates);
}
public enum JetBrains.ReSharper.Psi.Cpp.Overload.CppOperatorRewriteKind : Enum {
    public byte value__;
    public static CppOperatorRewriteKind None;
    public static CppOperatorRewriteKind DifferentOperator;
    public static CppOperatorRewriteKind ReversedArguments;
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOpParensOverloadContext : CppCommonDataOverloadContext {
    private ICppClassResolveEntity myCalledClassEnt;
    private ICppResolvedExpression myObjectArgNode;
    public CppOpParensOverloadContext(CppTypeContext& tc, ICppExpression[] args, ICppClassResolveEntity calledClassEnt, ICppResolvedExpression objArgNode);
    public virtual CppSmallList`1<CppOverloadingCandidate> BuildOverloadSet(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> candidates, CppOverloadSetBuilderParams builderParams);
    public virtual CppSmallList`1<CppOverloadingCandidate> BuildOverloadSetForParameterInfo(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> candidates, CppOverloadSetBuilderParams builderParams);
    private static bool ExistsConversionFromNonLambda(IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity> conversions);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOrdinaryOverloadingCandidate : CppOverloadingCandidate {
    [CompilerGeneratedAttribute]
private ICppGroupedFunctionDeclaratorResolveEntity <Function>k__BackingField;
    [CompilerGeneratedAttribute]
private CppOperatorRewriteKind <OperatorRewriteKind>k__BackingField;
    public CppQualType VerboseFunctionTypeWithoutSubstitution { get; }
    public ICppGroupedFunctionDeclaratorResolveEntity Function { get; }
    public CppOperatorRewriteKind OperatorRewriteKind { get; }
    public string DbgDescription { get; }
    public CppOrdinaryOverloadingCandidate(ICppGroupedFunctionDeclaratorResolveEntity func, int explicitArgCount, ICppOverloadingInfoAggregator infoAggregator, CppOperatorRewriteKind rewriteKind);
    public virtual CppQualType get_VerboseFunctionTypeWithoutSubstitution();
    [CompilerGeneratedAttribute]
public ICppGroupedFunctionDeclaratorResolveEntity get_Function();
    [CompilerGeneratedAttribute]
public virtual CppOperatorRewriteKind get_OperatorRewriteKind();
    public string get_DbgDescription();
    public virtual CppQualType GetFunctionType(ICppResolvedTypeFactory tf);
    public virtual CppRestrictionSpecifiers GetFunctionRestrictionSpecifiers();
    public virtual int GetParameterCount();
    public virtual bool HasAnyEllipsis();
    public ICppGroupedFunctionDeclaratorResolveEntity InstantiateBodyAndGetFunction(CppViewPos& vp);
    private CppFunctionType GetTypeWithUndefinedReturnTypeAndCallingConvention();
    private CppQualType GetQualTypeWithUndefinedReturnTypeAndCallingConvention();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadContextExpressionUtil : object {
    [ExtensionAttribute]
public static CppOverloadContextWithCaller GetOverloadContext(BinaryExpression binExpr, CppTypeContext& tc);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller TryGetOverloadContext(ICppCallExpression expr, CppTypeContext& tc);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller TryGetOverloadContext(ICppNewExpression expr, CppTypeContext& tc);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller TryGetOverloadContext(BraceInitializedTemporary expr, CppTypeContext& tc);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller GetOverloadContext(UnaryExpression expr, CppTypeContext& tc);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller GetOverloadContext(PostfixExpression postfixExpr, CppTypeContext& tc);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller GetOverloadContext(SubscriptExpression subscriptExpr, CppTypeContext& tc);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller GetSubscriptOperatorOverloadContext(ICppResolvedExpression left, CppSmallArray`1<ICppExpression> indices, CppTypeContext& tc);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller TryGetOverloadContext(ICppCliMultiArgumentSubscriptExpression subscriptExpr, CppTypeContext& tc);
    private static CppOverloadContextWithCaller TryGetContextForCall(ICppCallExpression expr, CppTypeContext& tc);
    private static CppOverloadContextWithCaller TryGetContextForCallToReference(ICppCallExpression expr, ICppResolvedQualifiedReferenceExpression invokedRef, CppTypeContext& tc);
    private static CppOverloadContextWithCaller TryGetContextForCallToMemberAccessExpr(ICppCallExpression expr, ICppResolvedMemberAccessExpression invokedMemAccess, CppTypeContext& tc);
    private static bool IsStandardResolveResult(CppResolveResult& rr);
    private static CppOverloadContextWithCaller TryGetContextForCallToObject(ICppCallExpression expr, CppTypeContext& tc);
    private static CppOverloadContextWithCaller GetContextForPropertySubscript(TSubscriptExpression expr, ICppAnyResolvedReferenceExpression ref, CppTypeContext& tc);
    private static ICppExpression[] GetIndexArguments(ICppAnySubscriptExpression expr);
    internal static CppOverloadContextWithCaller TryGetOverloadContextNonProperty(ICppAnySubscriptExpression subscriptExpr, CppTypeContext& tc);
    private static CppOverloadContextWithCaller TryGetContextForDefaultMultiargPropertySubscript(ICppCliMultiArgumentSubscriptExpression expr, CppTypeContext& tc);
    private static CppOverloadContextWithCaller GetOverloadContextNonProperty(SubscriptExpression subscriptExpr, CppTypeContext& tc);
    [CanBeNullAttribute]
private static ICppAnyResolvedReferenceExpression GetPropertySubscriptRef(ICppAnySubscriptExpression subscriptExpr);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadContextUtil : object {
    [ExtensionAttribute]
public static CppResolveResult ResolveContextWithCaller(ICppOverloadContext context, ICppOverloadContextCaller caller);
    [ExtensionAttribute]
public static CppResolveResult ResolveContextWithCallerWithoutMsExtensions(ICppOverloadContext context, ICppOverloadContextCaller caller);
    private static CppResolveResult ResolveContextWithCallerImpl(ICppOverloadContext context, ICppOverloadContextCaller caller, Func`4<CppSmallList`1<CppOverloadingCandidate>, bool, CppTypeContext, CppOverloadingResolutionResult> resolver);
    [ExtensionAttribute]
public static CppOverloadingRunInfo RunContextWithCaller(CppOverloadContextWithCaller context, CppOverloadSetBuilderParams builderParams);
    [ExtensionAttribute]
public static CppOverloadingRunInfo RunContextWithCaller(ICppOverloadContext context, ICppOverloadContextCaller caller, CppOverloadSetBuilderParams builderParams);
    [ExtensionAttribute]
public static CppSmallList`1<CppOverloadingCandidate> BuildDefaultOverloadSet(ICppOverloadContext context, ICppOverloadContextCaller caller, CppOverloadSetBuilderParams builderParams);
    [ExtensionAttribute]
public static FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> GetDefaultCandidates(ICppOverloadContext context, ICppOverloadContextCaller caller);
    [ExtensionAttribute]
public static HlslOverloadingCandidate GetHlslCandidate(ICppOverloadContext context, ICppOverloadContextCaller caller, ICppOverloadingInfoAggregatorFactory infoAggregatorFactory);
    public static bool ShouldPerformADLOnCall(ICppCallExpression call, CppQualifiedName name);
    private static List`1<CppQualType> GetArgTypesOverloadContext(ICppExpression[] args, ICppResolvedTypeFactory tf);
    private static void ApplyContextDependentBuiltinFallback(CppOverloadingResolutionResult& res, ICppOverloadContext context, FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> candidates, CppOverloadSetBuilderParams params);
    private static bool CheckOverloadContextFallback(CppOverloadingResolutionResult res, ICppOverloadContext& context, ICppOverloadContextCaller& caller);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadContextWithCaller : ValueType {
    [CompilerGeneratedAttribute]
private ICppOverloadContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppOverloadContextCaller <Caller>k__BackingField;
    public ICppOverloadContext Context { get; public set; }
    public ICppOverloadContextCaller Caller { get; public set; }
    public CppOverloadContextWithCaller(ICppOverloadContext Context, ICppOverloadContextCaller Caller);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ICppOverloadContext get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(ICppOverloadContext value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ICppOverloadContextCaller get_Caller();
    [CompilerGeneratedAttribute]
public void set_Caller(ICppOverloadContextCaller value);
    public bool IsValid();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CppOverloadContextWithCaller left, CppOverloadContextWithCaller right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CppOverloadContextWithCaller left, CppOverloadContextWithCaller right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CppOverloadContextWithCaller other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(ICppOverloadContext& Context, ICppOverloadContextCaller& Caller);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadedBinaryOperatorCaller : CppOverloadedOperatorCaller {
    [CompilerGeneratedAttribute]
private BinaryExpression <BinExpr>k__BackingField;
    [CompilerGeneratedAttribute]
private CppOperatorKind <OperatorKind>k__BackingField;
    [CanBeNullAttribute]
public BinaryExpression BinExpr { get; }
    public bool LookupOnlyMembers { get; }
    public CppOperatorKind OperatorKind { get; }
    public CppOverloadedBinaryOperatorCaller(BinaryExpression binExpr);
    public CppOverloadedBinaryOperatorCaller(CppOperatorKind kind);
    public virtual TResult Accept(ICppOverloadContextCallerVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public BinaryExpression get_BinExpr();
    public virtual bool get_LookupOnlyMembers();
    [CompilerGeneratedAttribute]
public virtual CppOperatorKind get_OperatorKind();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadedCoAwaitCaller : CppOverloadedOperatorCaller {
    public static CppOverloadedCoAwaitCaller Instance;
    public bool LookupOnlyMembers { get; }
    public CppOperatorKind OperatorKind { get; }
    private static CppOverloadedCoAwaitCaller();
    public virtual TResult Accept(ICppOverloadContextCallerVisitor`1<TResult> visitor);
    public virtual bool get_LookupOnlyMembers();
    public virtual CppOperatorKind get_OperatorKind();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadedCoYieldCaller : CppOverloadedOperatorCaller {
    public static CppOverloadedCoYieldCaller Instance;
    public bool LookupOnlyMembers { get; }
    public CppOperatorKind OperatorKind { get; }
    private static CppOverloadedCoYieldCaller();
    public virtual TResult Accept(ICppOverloadContextCallerVisitor`1<TResult> visitor);
    public virtual bool get_LookupOnlyMembers();
    public virtual CppOperatorKind get_OperatorKind();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadedOperatorCaller : object {
    public bool LookupOnlyMembers { get; }
    public CppOperatorKind OperatorKind { get; }
    public abstract virtual TResult Accept(ICppOverloadContextCallerVisitor`1<TResult> visitor);
    public abstract virtual bool get_LookupOnlyMembers();
    public abstract virtual CppOperatorKind get_OperatorKind();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadedPostfixUnaryOperatorCaller : CppOverloadedOperatorCaller {
    [CompilerGeneratedAttribute]
private PostfixExpression <PostfixExpr>k__BackingField;
    [CompilerGeneratedAttribute]
private CppOperatorKind <OperatorKind>k__BackingField;
    [CanBeNullAttribute]
public PostfixExpression PostfixExpr { get; }
    public bool LookupOnlyMembers { get; }
    public CppOperatorKind OperatorKind { get; }
    public CppOverloadedPostfixUnaryOperatorCaller(PostfixExpression postfixExpr);
    public CppOverloadedPostfixUnaryOperatorCaller(CppOperatorKind kind);
    public virtual TResult Accept(ICppOverloadContextCallerVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public PostfixExpression get_PostfixExpr();
    public virtual bool get_LookupOnlyMembers();
    [CompilerGeneratedAttribute]
public virtual CppOperatorKind get_OperatorKind();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadedPropertySubscriptCaller : object {
    [CompilerGeneratedAttribute]
private ICppAnySubscriptExpression <SubscriptExpr>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppAnyResolvedReferenceExpression <ReferenceExpr>k__BackingField;
    public ICppAnySubscriptExpression SubscriptExpr { get; }
    public ICppAnyResolvedReferenceExpression ReferenceExpr { get; }
    public CppOverloadedPropertySubscriptCaller(ICppAnySubscriptExpression subscriptExpr, ICppAnyResolvedReferenceExpression refExpr);
    public sealed virtual TResult Accept(ICppOverloadContextCallerVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public ICppAnySubscriptExpression get_SubscriptExpr();
    [CompilerGeneratedAttribute]
public ICppAnyResolvedReferenceExpression get_ReferenceExpr();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadedSubscriptOperatorCaller : CppOverloadedOperatorCaller {
    private ICppResolvedExpression myLeftArgument;
    [CompilerGeneratedAttribute]
private SubscriptExpression <SubscriptExpr>k__BackingField;
    [CanBeNullAttribute]
public SubscriptExpression SubscriptExpr { get; }
    public bool LookupOnlyMembers { get; }
    public CppOperatorKind OperatorKind { get; }
    public CppOverloadedSubscriptOperatorCaller(SubscriptExpression subscriptExpr);
    public CppOverloadedSubscriptOperatorCaller(ICppSubscriptExpression subscriptExpr);
    public CppOverloadedSubscriptOperatorCaller(ICppResolvedExpression left);
    public virtual TResult Accept(ICppOverloadContextCallerVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public SubscriptExpression get_SubscriptExpr();
    public ICppResolvedExpression GetLeftArgument();
    public virtual bool get_LookupOnlyMembers();
    public virtual CppOperatorKind get_OperatorKind();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadedUnaryOperatorCaller : CppOverloadedOperatorCaller {
    [CompilerGeneratedAttribute]
private UnaryExpression <UnaryExpr>k__BackingField;
    [CompilerGeneratedAttribute]
private CppOperatorKind <OperatorKind>k__BackingField;
    [CanBeNullAttribute]
public UnaryExpression UnaryExpr { get; }
    public bool LookupOnlyMembers { get; }
    public CppOperatorKind OperatorKind { get; }
    public CppOverloadedUnaryOperatorCaller(UnaryExpression unExpr);
    public CppOverloadedUnaryOperatorCaller(CppOperatorKind kind);
    public virtual TResult Accept(ICppOverloadContextCallerVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public UnaryExpression get_UnaryExpr();
    public virtual bool get_LookupOnlyMembers();
    [CompilerGeneratedAttribute]
public virtual CppOperatorKind get_OperatorKind();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingCandidate : object {
    [CompilerGeneratedAttribute]
private bool <IsDoubleFailureWithBadConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppOverloadingInfoAggregator <InfoAggregator>k__BackingField;
    [CompilerGeneratedAttribute]
private FailureKind <Failure>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppResolvedExpression <FailedConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private CppTypeContext <ConstraintTypeContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ViableWithMsExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private CppImplicitConversionSequence[] <Conversions>k__BackingField;
    [CompilerGeneratedAttribute]
private CliVarargState <HasCliParameterArray>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExplicitCallArguments>k__BackingField;
    public CppQualType VerboseFunctionTypeWithoutSubstitution { get; }
    public bool IsDoubleFailureWithBadConversion { get; private set; }
    public ICppOverloadingInfoAggregator InfoAggregator { get; }
    public FailureKind Failure { get; private set; }
    public ICppResolvedExpression FailedConstraint { get; private set; }
    public CppTypeContext ConstraintTypeContext { get; private set; }
    public bool ViableWithMsExtension { get; private set; }
    public CppImplicitConversionSequence[] Conversions { get; public set; }
    public bool Viable { get; }
    public CliVarargState HasCliParameterArray { get; public set; }
    public int ExplicitCallArguments { get; }
    public int ExplicitCallArgumentsForHighlighting { get; }
    public CppOperatorRewriteKind OperatorRewriteKind { get; }
    public bool IsReversed { get; }
    protected CppOverloadingCandidate(int explicitArgumentsCount, ICppOverloadingInfoAggregator expTypeConsumer);
    public abstract virtual CppQualType get_VerboseFunctionTypeWithoutSubstitution();
    [CompilerGeneratedAttribute]
public bool get_IsDoubleFailureWithBadConversion();
    [CompilerGeneratedAttribute]
private void set_IsDoubleFailureWithBadConversion(bool value);
    [CompilerGeneratedAttribute]
public ICppOverloadingInfoAggregator get_InfoAggregator();
    [CompilerGeneratedAttribute]
public FailureKind get_Failure();
    [CompilerGeneratedAttribute]
private void set_Failure(FailureKind value);
    [CompilerGeneratedAttribute]
public ICppResolvedExpression get_FailedConstraint();
    [CompilerGeneratedAttribute]
private void set_FailedConstraint(ICppResolvedExpression value);
    [CompilerGeneratedAttribute]
public CppTypeContext get_ConstraintTypeContext();
    [CompilerGeneratedAttribute]
private void set_ConstraintTypeContext(CppTypeContext value);
    [CompilerGeneratedAttribute]
public bool get_ViableWithMsExtension();
    [CompilerGeneratedAttribute]
private void set_ViableWithMsExtension(bool value);
    [CompilerGeneratedAttribute]
public CppImplicitConversionSequence[] get_Conversions();
    [CompilerGeneratedAttribute]
public void set_Conversions(CppImplicitConversionSequence[] value);
    public bool get_Viable();
    [CompilerGeneratedAttribute]
public CliVarargState get_HasCliParameterArray();
    [CompilerGeneratedAttribute]
public void set_HasCliParameterArray(CliVarargState value);
    [CompilerGeneratedAttribute]
public int get_ExplicitCallArguments();
    public virtual int get_ExplicitCallArgumentsForHighlighting();
    public virtual CppOperatorRewriteKind get_OperatorRewriteKind();
    public bool get_IsReversed();
    public void FailWith(FailureKind kind, bool viableWithMsExtension);
    public void FailWith(FailureKind kind, bool viableWithMsExtension, ICppResolvedExpression constraint, CppTypeContext& typeContext);
    public abstract virtual CppQualType GetFunctionType(ICppResolvedTypeFactory tf);
    public abstract virtual CppRestrictionSpecifiers GetFunctionRestrictionSpecifiers();
    public abstract virtual int GetParameterCount();
    public abstract virtual bool HasAnyEllipsis();
    public int GetConversionIndex(int idx);
    public void SetConversion(int idx, CppImplicitConversionSequence conv);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingCandidateBuilder : ValueType {
    private CppOverloadingCandidateBuilderParameters myBuilderParameters;
    private ICppTemplateArgument[] myTemplateArgs;
    public CppTypeContext TypeContext;
    [CompilerGeneratedAttribute]
private ICppOverloadingInfoAggregatorFactory <ExpTypeConsumerFactory>k__BackingField;
    public CppOverloadingCandidateBuilderParameters BuilderParameters { get; }
    public ICppOverloadingInfoAggregatorFactory ExpTypeConsumerFactory { get; }
    public CppOverloadingCandidateBuilder(CppOverloadingCandidateBuilderParameters builderParams, ICppTemplateArgument[] explicitArgs, ICppOverloadingInfoAggregatorFactory infoAggFactory, CppTypeContext& tc);
    public CppOverloadingCandidateBuilderParameters get_BuilderParameters();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ICppOverloadingInfoAggregatorFactory get_ExpTypeConsumerFactory();
    public void ResetParameters(CppOverloadingCandidateBuilderParameters newParams);
    public CppOrdinaryOverloadingCandidate BuildOrdinaryCandidate(ICppFunctionOrFunctionTemplateLikeDeducibleResolveEntity candidate, ReadOnlySpan`1<ICppExpression> args, bool skipTemplatesByArgsCount, CppOperatorRewriteKind rewriteKind);
    private CppOrdinaryOverloadingCandidate FailOrdinaryCandidate(ICppGroupedFunctionDeclaratorResolveEntity primaryTemplate, int explicitArgCount, ICppOverloadingInfoAggregator infoAggregator, FailureKind reason, CppOperatorRewriteKind rewriteKind, ICppResolvedExpression constraint);
    private static void EnsureDelayedDeclaratorsForFunctionAreMerged(ICppFunctionTemplateDeclaratorResolveEntity funcTemplate, CppViewPos& vp);
    public CppOrdinaryOverloadingCandidate BuildNonMemberIncDecCandidate(ICppFunctionOrFunctionTemplateLikeDeducibleResolveEntity candidate, ReadOnlySpan`1<ICppExpression> args);
    private static bool IsBadOrAmbiguousImplicitConversion(CppImplicitConversionSequence conversion);
    public CppOverloadingCandidate BuildConversionCandidate(ICppFunctionOrTemplateDeclaratorResolveEntity candidate, CppExpressionInfo from, CppQualType toT, bool contextualToBool);
    public CppOverloadingCandidate BuildConstructorCandidateForConversion(ICppFunctionOrTemplateDeclaratorResolveEntity candidate, ReadOnlySpan`1<ICppExpression> args, CppQualType toT, bool isBracedListCtorCall, bool isDirectInit);
    public CppOverloadingCandidate BuildMemberFunctionCandidate(ICppFunctionOrTemplateDeclaratorResolveEntity methodEnt, CppExpressionInfo objArg, ReadOnlySpan`1<ICppExpression> args, int explicitCallArgsCount, bool isOperatorCall, bool skipTemplatesByArgsCount, CppOperatorRewriteKind rewriteKind);
    private CppOverloadingCandidate FailMemberFunctionCandidate(ICppGroupedFunctionDeclaratorResolveEntity primaryTemplate, int explicitArgCount, ICppOverloadingInfoAggregator infoAggregator, FailureKind reason, CppOperatorRewriteKind rewriteKind, ICppResolvedExpression constraint);
    public CppOverloadingCandidate BuildSurrogateCandidate(ICppGroupedFunctionDeclaratorResolveEntity convEnt, ICppResolvedExpression objArgNode, ReadOnlySpan`1<ICppExpression> args);
    public CppOverloadingCandidate BuildBuiltinCandidate(CppOperatorKind opKind, CppQualType resultT, CppQualType[] paramTypes, ReadOnlySpan`1<ICppExpression> args, bool isAssignmentOperator, int numContextualBoolArguments);
    public CppConversionHelper CreateCppConversionHelper(CppConversionParameters params);
    private CppOrdinaryOverloadingCandidate BuildOrdinaryCandidateWithCustomInfo(ICppGroupedFunctionDeclaratorResolveEntity candidate, ReadOnlySpan`1<ICppExpression> args, ICppOverloadingInfoAggregator info, CppOperatorRewriteKind rewriteKind, CppImplicitConversionSequence[] conversions);
    private CppMemberFunctionOverloadingCandidate BuildMemberFunctionCandidateWithCustomInfo(ICppGroupedFunctionDeclaratorResolveEntity methodEnt, CppExpressionInfo objArg, ReadOnlySpan`1<ICppExpression> args, int explicitCallArgsCount, ICppOverloadingInfoAggregator info, bool isOperatorCall, CppOperatorRewriteKind rewriteKind);
    private CppOverloadingCandidate BuildConversionCandidateWithCustomInfo(ICppGroupedFunctionDeclaratorResolveEntity funcDecl, CppExpressionInfo from, CppQualType toT, bool contextualToBool);
    private CppOverloadingCandidate CreateBadOrTrivialConversion(ICppGroupedFunctionDeclaratorResolveEntity funcDecl, CppExpressionInfo from, CppQualType toT, FailureKind failureKind, CppImplicitConversionSequence[] conversions);
    private bool CheckRequiresClause(ICppGroupedFunctionDeclaratorResolveEntity spec, ICppResolvedExpression& clause);
    private bool DeduceAndPickSpecialization(ICppFunctionTemplateLikeDeducibleResolveEntity candidate, ReadOnlySpan`1<ICppExpression> args, ICppResolvedExpression explicitThis, ICppOverloadingInfoAggregator infoAggregator, ICppGroupedFunctionDeclaratorResolveEntity& spec);
    private bool DeduceAndPickSpecializationForConversion(ICppFunctionTemplateDeclaratorResolveEntity candidate, CppExpressionInfo from, CppQualType targetT, ICppOverloadingInfoAggregator infoAggregator, ICppGroupedFunctionDeclaratorResolveEntity& spec);
    private CppImplicitConversionSequence BuildConversionForSingleArgument(ICppOverloadingInfoAggregator infoAggregator, ICppResolvedExpression arg, CppQualType paramType);
    private void BuildConversionsForArguments(CppOverloadingCandidate newCandidate, CppQualType funcType, ReadOnlySpan`1<ICppExpression> args, int paramCount, int conversionStartIndex, int paramStartIndex);
    private bool FailCandidateBadConversion(CppOverloadingCandidate newCandidate, CppImplicitConversionSequence conversion);
    private bool CheckCandidateArgsNumberAndAmpSpecifier(CppOverloadingCandidate newCandidate, int argsSize, int paramCount, int paramStartIndex);
    private static int GetMinArgCount(CppOverloadingCandidate cand, int paramCount);
    private CppConversionHelper CreateCppConversionHelper();
    private bool IsCliStaticOperator(ICppGroupedFunctionDeclaratorResolveEntity func);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingCandidateBuilderParameters : ValueType {
    public bool SuppressUserConversions;
    public bool AllowExplicitConversions;
    public bool BuildConversionsForAllArguments;
    public bool TreatMissingArgumentsAsUnknown;
    public bool DeduceFromDependentCallArguments;
    public CppOverloadingCandidateBuilderParameters(bool treatMissingArgumentsAsUnknown, bool buildConvsForAllArgs, bool deduceFromDependentCallArgs, CppConversionParameters convParams);
    public CppConversionParameters GetParametersForConversions();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingCandidateForBuiltinPropertyAccess : CppMemberFunctionOverloadingCandidate {
    public ICppCxxCliPropertyDeclaratorResolveEntity Property { get; }
    public CppOverloadingCandidateForBuiltinPropertyAccess(CppBuiltinOperatorResolveEntityForPropertyAccess propAccess, bool ignoreObjectArg, int explicitArgCount, ICppOverloadingInfoAggregator infoAggregator, CppOperatorRewriteKind rewriteKind);
    public ICppCxxCliPropertyDeclaratorResolveEntity get_Property();
    public virtual int GetParameterCount();
    public virtual bool HasAnyEllipsis();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingCandidateUtil : object {
    [ExtensionAttribute]
public static bool ObjectConversionIsFailure(CppOverloadingCandidate c);
    [ExtensionAttribute]
public static int GetFirstFailedActualArgConversionIndex(CppOverloadingCandidate candidate);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppGroupedFunctionDeclaratorResolveEntity GetCalledFunction(CppOverloadingCandidate c, CppViewPos& vp);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppGroupedFunctionDeclaratorResolveEntity GetCalledFunction(CppOverloadingCandidate c);
    [ExtensionAttribute]
public static bool HasUnknownConversions(CppOverloadingCandidate c);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingCollectionBuilder : ValueType {
    private CppOverloadingCandidateBuilder myCandidateBuilder;
    public CppOverloadingCollectionBuilder(CppTypeContext tc, ICppTemplateArgument[] templArgs, CppOverloadingCandidateBuilderParameters params, ICppOverloadingInfoAggregatorFactory infoAggregatorFactory);
    public CppSmallList`1<CppOverloadingCandidate> BuildForFunctionCall(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> entities, ReadOnlySpan`1<ICppExpression> args, bool skipTemplatesByArgsCount);
    public CppSmallList`1<CppOverloadingCandidate> BuildForMemberFunctionCall(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> entities, ICppResolvedExpression objArgNode, ReadOnlySpan`1<ICppExpression> args, bool skipTemplatesByArgsCount);
    public CppSmallList`1<CppOverloadingCandidate> BuildForOperatorCall(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> entities, ReadOnlySpan`1<ICppExpression> args, CppOperatorKind opKind, bool buildBuiltinCandidates, bool allowRewrittenCandidates);
    private void AddRewrittenCandidates(CppSmallList`1& result, ReadOnlySpan`1<ICppExpression> args, CppOperatorKind opKind);
    public CppSmallList`1<CppOverloadingCandidate> BuildForCallToObject(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> methodEntities, ICppClassResolveEntity calledClassEnt, ICppResolvedExpression objArgNode, ReadOnlySpan`1<ICppExpression> args, bool buildSurrogateCandidates, bool skipTemplatesByArgsCount);
    public CppSmallList`1<CppOverloadingCandidate> BuildForUserDefinedConversion(CppExpressionInfo from, bool isInsideDirectInit, bool isInsideInitDeclarator, bool forceAllowExplicitConversions, CppQualType toT, CastKind cast, bool contextualToBool);
    private static bool IsExplicitFunctionCandidate(CppOverloadingCandidate candidate);
    public CppSmallList`1<CppOverloadingCandidate> BuildForUserDefinedConversionOnlyInitList(ICppResolvedExpression from, bool isInsideDirectInit, bool forceAllowExplicitConversions, CppQualType toT, ICppClassResolveEntity clazz);
    public CppSmallList`1<CppOverloadingCandidate> BuildForUserDefinedConversionToReferenceType(CppQualType toT, CppExpressionInfo initExpr, ICppClassResolveEntity classEnt, bool allowRvalues, bool allowExplicit);
    public CppSmallList`1<CppOverloadingCandidate> BuildForSingleBuiltinCandidate(CppQualType builtinFunctionType, ReadOnlySpan`1<ICppExpression> args, CppOperatorKind opKind);
    public CppSmallList`1<CppOverloadingCandidate> BuildForCTAD(CppList`1<ICppDeductionGuide> entities, ICppExpression[] args, bool initializerList, bool skipTemplatesByArgsCount);
    [DebuggerStepThroughAttribute]
public ICppResolvedTypeFactory GetTypeFactory();
    [DebuggerStepThroughAttribute]
public CppViewPos GetViewPos();
    private void AddBuiltinOperatorCandidates(CppSmallList`1& result, CppOperatorKind opKind, ReadOnlySpan`1<ICppExpression> args);
    private void AddOpParenSurrogateCandidates(CppSmallList`1& output, ICppClassResolveEntity objEnt, ICppResolvedExpression objArgNode, ReadOnlySpan`1<ICppExpression> args);
    private static ICppGroupedFunctionDeclaratorResolveEntity GetFunctionOrPrimaryTemplate(ICppFunctionOrTemplateDeclaratorResolveEntity ent);
    private void AddOperatorCallCandidates(CppSmallList`1& result, FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> entities, ReadOnlySpan`1<ICppExpression> args, CppOperatorKind opKind, CppOperatorRewriteKind rewriteKind);
    private static int PartitionTemplateAndNonTemplateCandidates(FrugalLocalList`1& candidates);
    private static bool IsPerfectCandidate(CppOverloadingCandidate candidate);
    [CanBeNullAttribute]
private CppOverloadingCandidate CreateOperatorCallCandidate(ReadOnlySpan`1<ICppExpression> args, CppOperatorKind opKind, CppOperatorRewriteKind rewriteKind, ICppFunctionOrTemplateDeclaratorResolveEntity ent, bool isNonTemplateFunction, ICppGroupedFunctionDeclaratorResolveEntity funcDecl, ICppResolvedTypeFactory typeFactory, CppExpressionInfo objArg, ReadOnlySpan`1<ICppExpression> slicedArgs, bool hasArgWithClassType, ICppClassResolveEntity lhsEnum, ICppClassResolveEntity rhsEnum);
    private static bool HasArgWithClassType(ReadOnlySpan`1<ICppExpression> args, ICppResolvedTypeFactory tf, ICppClassResolveEntity& lhsEnum, ICppClassResolveEntity& rhsEnum);
    private static bool HasParamWithEnumType(CppQualType funcType, ICppClassResolveEntity lhsEnum, ICppClassResolveEntity rhsEnum);
    private static bool ShouldAddReversedMemberCandidate(ICppGroupedFunctionDeclaratorResolveEntity ent, ICppResolvedTypeFactory typeFactory);
    private static bool ShouldAddReversedNonMemberCandidate(ICppGroupedFunctionDeclaratorResolveEntity ent, ICppResolvedTypeFactory typeFactory);
    private TriBool IsExplicit(ICppFunctionOrTemplateDeclaratorResolveEntity func, ICppGroupedFunctionDeclaratorResolveEntity primaryDecl);
    [CompilerGeneratedAttribute]
internal static bool <IsPerfectCandidate>g__IsPerfectArgumentConversion|20_0(CppImplicitConversionSequence conversion);
}
public enum JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingConversionBehaviour : Enum {
    public int value__;
    public static CppOverloadingConversionBehaviour UseStandardConversion;
    public static CppOverloadingConversionBehaviour UseSpecialConversion;
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingResolutionResult : ValueType {
    public CppOverloadingCandidate BestCandidate;
    public CppOverloadingResultStatus Status;
    public bool HadUnknownTypeConversionsInViableCandidates;
    public bool HadBetterConversion;
    public bool UsedBuiltinFallback;
    public CppOverloadingResolutionResult(CppOverloadingResultStatus status, CppOverloadingCandidate bestCandidate, bool hadUnknownTypeConversionsInViableCandidates);
}
public enum JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingResultStatus : Enum {
    public byte value__;
    public static CppOverloadingResultStatus Success;
    public static CppOverloadingResultStatus NoViableFunction;
    public static CppOverloadingResultStatus Ambiguous;
    public static CppOverloadingResultStatus CopyElided;
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingRunInfo : ValueType {
    public CppSmallList`1<CppOverloadingCandidate> OverloadCollection;
    public CppOverloadingResolutionResult Result;
    public CppOverloadingRunInfo(CppSmallList`1<CppOverloadingCandidate> set, CppOverloadingResolutionResult result);
}
public static class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadResolutionUtil : object {
    public static CppSmallList`1<CppOverloadingCandidate> BuildFunctionCallCandidateSet(ICppTemplateArgument[] templArgs, FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> entities, ReadOnlySpan`1<ICppExpression> args, bool treatMissingArgumentsAsUnknown, bool buildConvForAllArgs, bool deduceFromDependentCallArgs, ICppOverloadingInfoAggregatorFactory expTypeFactory, CppTypeContext& tc, bool skipTemplatesByArgsCount);
    public static CppSmallList`1<CppOverloadingCandidate> BuildClassMemberCandidateSet(ICppTemplateArgument[] templArgs, FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> entities, ReadOnlySpan`1<ICppExpression> args, ICppResolvedExpression objArgNode, bool treatMissingArgumentsAsUnknown, bool buildConvForAllArgs, bool deduceFromDependentCallArgs, ICppOverloadingInfoAggregatorFactory expTypeFactory, CppTypeContext& tc, bool skipTemplatesByArgsCount);
    public static CppSmallList`1<CppOverloadingCandidate> BuildOperatorsCandidateSet(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> entities, ReadOnlySpan`1<ICppExpression> args, CppOperatorKind opKind, bool buildConvForAllArgs, bool deduceFromDependentCallArgs, ICppOverloadingInfoAggregatorFactory expTypeFactory, CppTypeContext& tc, bool buildBuiltinCandidates, bool allowRewrittenCandidates);
    public static CppSmallList`1<CppOverloadingCandidate> BuildOpParenCandidateSet(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> methodEntities, ICppClassResolveEntity calledClassEnt, ICppResolvedExpression objArgNode, ReadOnlySpan`1<ICppExpression> args, bool buildConvForAllArgs, bool deduceFromDependentCallArgs, ICppOverloadingInfoAggregatorFactory expTypeFactory, CppTypeContext& tc, bool buildSurrogateCandidates, bool skipTemplatesByArgsCount);
    public static CppSmallList`1<CppOverloadingCandidate> BuildOperatorsCandidateSet(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> entities, ICppExpression[] args, CppOperatorKind opKind, bool buildConvForAllArgs, bool deduceFromDependentCallArgs, ICppOverloadingInfoAggregatorFactory expTypeFactory, CppTypeContext& tc);
    public static CppOverloadingResolutionResult ResolveOverloads(CppSmallList`1<CppOverloadingCandidate> set, CppTypeContext& tc);
    public static CppOverloadingResolutionResult ResolveOverloads(CppSmallList`1<CppOverloadingCandidate> set, bool userDefinedConversion, CppTypeContext tc);
    public static CppOverloadingResolutionResult ResolveOverloadsWithoutMsExtensions(CppSmallList`1<CppOverloadingCandidate> set, bool userDefinedConversion, CppTypeContext tc);
    public static CppConversionParameters ConversionParametersForOverloadResolution(bool supressUserConversions, bool allowExplicit);
    private static CppOverloadingResolutionResult ResolveOverloadsImpl(CppSmallList`1<CppOverloadingCandidate> set, bool userDefinedConversion, bool recoverForMsExtensions, CppTypeContext& tc);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadSetBuilderParams : ValueType {
    public bool TreatMissingArgumentsAsUnknown;
    public bool BuildConvForAllArgs;
    public bool DeduceFromDependentCallArgs;
    public ICppOverloadingInfoAggregatorFactory InfoAggregatorFactory;
    public static CppOverloadSetBuilderParams ForResolve { get; }
    public CppOverloadSetBuilderParams(bool buildConvForAllArgs);
    public CppOverloadSetBuilderParams(bool buildConvForAllArgs, ICppOverloadingInfoAggregatorFactory infoAggregatorFactory);
    public static CppOverloadSetBuilderParams get_ForResolve();
    public CppOverloadSetBuilderParams WithTreatMissingArgumentsAsUnknown(bool treatMissingArgumentsAsUnknown);
    public CppOverloadSetBuilderParams WithDeduceFromDependentCallArgs(bool deduceFromDependentCallArgs);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CppOverloadSetBuilderParams left, CppOverloadSetBuilderParams right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CppOverloadSetBuilderParams left, CppOverloadSetBuilderParams right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CppOverloadSetBuilderParams other);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadTemplateUtil : object {
    public static PartialOrderingResult IsMoreSpecialized(ICppFunctionTemplateDeclaratorResolveEntity left, ICppFunctionTemplateDeclaratorResolveEntity right, PartialOrderingArguments args, CppTypeContext& tc, bool reversed);
    public static PartialOrderingResult IsMoreSpecialized(ICppFunctionTemplateDeclaratorResolveEntity left, ICppFunctionTemplateDeclaratorResolveEntity right, PartialOrderingArguments args, CppTypeContext& tc);
    public static PartialOrderingResult IsMoreSpecialized(ICppTemplateDeductionGuide left, ICppTemplateDeductionGuide right, int explicitArgsCounts, CppTypeContext& tc);
    public static ICppGroupedFunctionDeclaratorResolveEntity PickMostSpecializedFunction(CppList`1<ICppGroupedFunctionDeclaratorResolveEntity> candidates, CppTypeContext& tc);
    public static ICppClassResolveEntity PickMostSpecializedClass(List`1<ICppClassResolveEntity> declarations, CppViewPos& viewPos);
    public static ICppGroupedVariableDeclaratorResolveEntity PickMostSpecializedVariable(List`1<ICppGroupedVariableDeclaratorResolveEntity> declarations, CppViewPos& viewPos);
    public static CppList`1<ICppGroupedFunctionDeclaratorResolveEntity> DeduceAndPickFunctionSpecializations(FrugalLocalList`1<ICppResolveEntity> candidates, CppQualType targetT, ICppTemplateArgument[] explicitArgs, CppTypeContext& tc);
    public static ICppGroupedFunctionDeclaratorResolveEntity DeduceAndPickFunctionSpecialization(ICppFunctionTemplateDeclaratorResolveEntity templ, CppQualType targetType, ICppTemplateArgument[] explicitArgs, CppTypeContext& tc);
    public static bool PushEmptySubstitutionsForParameterPacksIn(ICppTemplateArgument t, ICppTemplateSubstitutionConsumer consumer);
    public static bool PushEmptySubstitutionsForParameterPacksIn(CppQualType t, ICppTemplateSubstitutionConsumer consumer);
    public static bool PushEmptySubstitutionsForParameterPacksIn(ICppExpression e, ICppTemplateSubstitutionConsumer consumer);
    public static TResolveEntity PickMostSpecializedByName(List`1<TResolveEntity> declarations, CppViewPos& viewPos);
    private static PartialOrderingResult IsMoreSpecializedImpl(ArraySegment`1<CppQualType> leftTypes, CppTemplateParametersBase leftParams0, ICppResolvedExpression leftRequires, ArraySegment`1<CppQualType> rightTypes, CppTemplateParametersBase rightParams0, ICppResolvedExpression rightRequires, CppTypeDeductionOptions options, CppTypeContext& tc);
    private static PartialOrderingResult IsMoreSpecializedImpl(ICppTemplateArgument[] leftTypes, CppTemplateParametersBase leftParams0, ICppTemplateArgument[] rightTypes, CppTemplateParametersBase rightParams0, CppViewPos& viewPos);
    private static PartialOrderingResult IsMoreSpecializedImpl(PartialOrderingStatus leftToRight, CppLearnSubstitutionConsumer leftToRightConsumer, PartialOrderingStatus rightToLeft, CppLearnSubstitutionConsumer rightToLeftConsumer, CppTemplateParametersBase leftParams0, ICppResolvedExpression leftRequires, CppTemplateParametersBase rightParams0, ICppResolvedExpression rightRequires, CppTypeContext& tc);
    private static bool IsMoreSpecializedCandidate(PartialOrderingStatus left, PartialOrderingStatus other);
    private static CppTemplateParametersBase GetTemplateParametersSafe(ICppResolveEntity decl);
    private static ICppTemplateArgument[] GetTemplateArgumentsSafe(CppQualifiedNamePart templateName);
    private static CppTypePartialOrderingResult DeduceTemplateArgumentsForPartialOrdering(CppQualType paramT, CppQualType argT, CppTypeDeductionOptions opts, ICppTemplateSubstitutionConsumer consumer, CppTypeContext& tc);
    private static ICollection`1<CppTemplateParameterTag> GetDependenciesOfDeductionParams(IList`1<CppQualType> types);
    private static ICollection`1<CppTemplateParameterTag> GetDependenciesOfDeductionParams(ICppTemplateArgument[] templateArgs);
    private static CppTemplateParametersBase GetTemplateParametersForPartialOrdering(CppTemplateParametersBase all, ICollection`1<CppTemplateParameterTag> dependenciesSet);
    private static PartialOrderingStatus DeduceForPartialOrdering(ReadOnlySpan`1<CppQualType> paramTypes, ReadOnlySpan`1<CppQualType> argTypes, ICppTemplateSubstitutionConsumer consumer, CppTypeDeductionOptions options, CppTypeContext& tc);
    private static PartialOrderingStatus DeduceForPartialOrdering(ICppTemplateArgument[] paramArgs, ICppTemplateArgument[] argArgs, CppPartialOrderingOnTemplateArgsListSubstitutionConsumer consumer, CppTypeContext& tc);
    private static ArraySegment`1<CppQualType> GetTypesForCallPartialOrdering(CppQualType[] paramTypes, int explicitArgCount);
    private static CppPartialOrderingListSubstitutionConsumer CreatePartialOrderingResultConsumer(CppTemplateParametersBase params, IList`1<CppQualType> types, CppTypeContext& tc);
    private static CppPartialOrderingOnTemplateArgsListSubstitutionConsumer CreatePartialOrderingResultConsumer(CppTemplateParametersBase params, ICppTemplateArgument[] templateArgs, CppTypeContext& tc);
    private static bool PushEmptySubstitutionsForParameterPacksInImpl(JetHashSet`1<ICppTemplateParameterPack> unexpanded, ICppTemplateSubstitutionConsumer consumer);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppReferenceBindingInfo : ValueType {
    public static int BitSize;
    public static int BitMask;
    private int myFlags;
    public ReferenceBindingKind Kind { get; }
    public bool IsDirectBinding { get; }
    public bool IsBindingToNonRefQualifiedObjectArg { get; }
    public bool IsLvalueReference { get; }
    public ReferenceBindingTarget BindingTarget { get; }
    public CppReferenceBindingInfo(int rawFlags);
    public CppReferenceBindingInfo(ReferenceBindingKind kind, bool isLvalueRef, ReferenceBindingTarget bindingTarget);
    public ReferenceBindingKind get_Kind();
    public bool get_IsDirectBinding();
    public bool get_IsBindingToNonRefQualifiedObjectArg();
    public bool get_IsLvalueReference();
    public ReferenceBindingTarget get_BindingTarget();
    public int GetRawFlags();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppReinterpretCastBadConversion : CppReinterpretCastConversion {
    [CompilerGeneratedAttribute]
private FailureKind <Failure>k__BackingField;
    public FailureKind Failure { get; }
    public CppReinterpretCastBadConversion(ICppExpression sourceExpr, CppQualType fromType, CppQualType toType, FailureKind failure);
    [CompilerGeneratedAttribute]
public FailureKind get_Failure();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Overload.CppReinterpretCastConversion : CppCastConversion {
    [CompilerGeneratedAttribute]
private ConversionKind <Kind>k__BackingField;
    public ConversionKind Kind { get; }
    protected CppReinterpretCastConversion(ICppExpression sourceExpr, CppQualType fromType, CppQualType toType, ConversionKind kind);
    [CompilerGeneratedAttribute]
public ConversionKind get_Kind();
    public virtual bool IsFailure();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppReinterpretCastSucceededConversion : CppReinterpretCastConversion {
    public CppReinterpretCastSucceededConversion(ICppExpression sourceExpr, CppQualType from, CppQualType to);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppSpecialMatchConversion : CppImplicitConversionSequence {
    public int Rank { get; }
    public ReferenceFlag TargetReferenceFlag { get; }
    public CppSpecialMatchConversion(ICppResolvedExpression from);
    public virtual int get_Rank();
    public virtual ReferenceFlag get_TargetReferenceFlag();
    public virtual TResult Accept(ICppImplicitConversionSequenceVisitor`1<TResult> vis);
    public virtual CppImplicitConversionSequence Clone();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppStandardConversionPart : ValueType {
    [CompilerGeneratedAttribute]
private CppQualType <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private CppImplicitConversionKind <Kind>k__BackingField;
    public CppQualType TargetType { get; }
    public CppImplicitConversionKind Kind { get; }
    public CppStandardConversionPart(CppQualType target, CppImplicitConversionKind kind);
    [CompilerGeneratedAttribute]
public CppQualType get_TargetType();
    [CompilerGeneratedAttribute]
public CppImplicitConversionKind get_Kind();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppStandardConversionSequence : CppImplicitConversionSequence {
    private CppQualType myFirstTargetType;
    private CppQualType mySecondTargetType;
    private CppQualType myThirdTargetType;
    private int myFlags;
    [CompilerGeneratedAttribute]
private CppImplicitConversionSequence <SpecialConversionSequence>k__BackingField;
    [CompilerGeneratedAttribute]
private CppQualType <SourceType>k__BackingField;
    public CppStandardConversionPart First { get; }
    public CppStandardConversionPart Second { get; }
    public CppStandardConversionPart Third { get; }
    public CppImplicitConversionSequence SpecialConversionSequence { get; }
    public CppReferenceBindingInfo BindingInfo { get; public set; }
    public bool IsDeprecatedCharPtrConv { get; }
    public bool IsDirectInit { get; }
    public CppQualType SourceType { get; }
    public int Rank { get; }
    public ReferenceFlag TargetReferenceFlag { get; }
    private static CppStandardConversionSequence();
    private CppStandardConversionSequence(ICppResolvedExpression from, CppQualType sourceType, CppStandardConversionPart first, CppStandardConversionPart second, CppStandardConversionPart third, CppReferenceBindingInfo refBinding, bool isDeprecatedCharPtrConv, bool isDirectInitialization, CppImplicitConversionSequence wrappedSpecialConv);
    public CppStandardConversionPart get_First();
    public CppStandardConversionPart get_Second();
    public CppStandardConversionPart get_Third();
    [CompilerGeneratedAttribute]
public CppImplicitConversionSequence get_SpecialConversionSequence();
    public CppReferenceBindingInfo get_BindingInfo();
    public void set_BindingInfo(CppReferenceBindingInfo value);
    public bool get_IsDeprecatedCharPtrConv();
    public bool get_IsDirectInit();
    [CompilerGeneratedAttribute]
public CppQualType get_SourceType();
    public virtual int get_Rank();
    public virtual ReferenceFlag get_TargetReferenceFlag();
    private static CppStandardConversionSequence CreateIdentityConversionSequence(CppQualType type, ICppResolvedExpression from, bool isDeprecatedCharPtrConv, bool isDirectInitialization, CppImplicitConversionSequence specialSeq);
    public static CppStandardConversionSequence CreateIdentityConversionSequence(CppQualType type, ICppResolvedExpression from, bool isDirectInitialization);
    public static CppStandardConversionSequence CreateDerivedToBaseConversion(ICppResolvedExpression from, CppQualType sourceType, CppQualType toT, bool isDirectInitialization);
    public static CppStandardConversionSequence CreateConversion(ICppResolvedExpression from, CppQualType source, CppStandardConversionPart first, CppStandardConversionPart second, CppStandardConversionPart third, bool isDirectInitialization);
    public static CppStandardConversionSequence CreateConversion(ICppResolvedExpression from, CppQualType source, CppStandardConversionPart first, CppStandardConversionPart second, CppStandardConversionPart third, CppReferenceBindingInfo bindingInfo, bool isDirectInitialization);
    public static CppStandardConversionSequence CreateDeprecatedStringLiteralConversion(ICppResolvedExpression from, CppQualType sourceType, CppQualType intermediateType, CppQualType targetType, CppImplicitConversionKind firstKind);
    public static CppStandardConversionSequence CreateDirectReferenceBinding(ICppResolvedExpression from, CppQualType target, CppQualType source, bool derivedToBase, bool isRValRef, CppValueCategory initCategory);
    public static CppStandardConversionSequence CreateWrappingConversion(CppImplicitConversionSequence specialConvSeq, CppQualType toT, bool isDirectInitialization);
    public virtual TResult Accept(ICppImplicitConversionSequenceVisitor`1<TResult> vis);
    public virtual CppImplicitConversionSequence Clone();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppStaticCastBadConversion : CppStaticCastConversion {
    [CompilerGeneratedAttribute]
private FailureKind <Failure>k__BackingField;
    public FailureKind Failure { get; }
    public CppStaticCastBadConversion(ICppExpression sourceExpr, CppQualType fromType, CppQualType toType, FailureKind failure);
    [CompilerGeneratedAttribute]
public FailureKind get_Failure();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Overload.CppStaticCastConversion : CppCastConversion {
    [CompilerGeneratedAttribute]
private ConversionKind <Kind>k__BackingField;
    public ConversionKind Kind { get; }
    protected CppStaticCastConversion(ICppExpression sourceExpr, CppQualType fromType, CppQualType toType, ConversionKind kind);
    [CompilerGeneratedAttribute]
public ConversionKind get_Kind();
    public virtual bool IsFailure();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppStaticCastExtendedConversion : CppStaticCastConversion {
    [CompilerGeneratedAttribute]
private ExtendedConversionKind <ExtendedKind>k__BackingField;
    public ExtendedConversionKind ExtendedKind { get; }
    public CppStaticCastExtendedConversion(ICppExpression sourceExpr, CppQualType fromT, CppQualType toT, ExtendedConversionKind type);
    [CompilerGeneratedAttribute]
public ExtendedConversionKind get_ExtendedKind();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppStaticCastImplicitConversion : CppStaticCastConversion {
    [CompilerGeneratedAttribute]
private CppImplicitConversionSequence <ConversionSequence>k__BackingField;
    public CppImplicitConversionSequence ConversionSequence { get; }
    public CppStaticCastImplicitConversion(ICppExpression sourceExpr, CppQualType fromT, CppQualType toT, CppImplicitConversionSequence convSeq);
    [CompilerGeneratedAttribute]
public CppImplicitConversionSequence get_ConversionSequence();
}
public static class JetBrains.ReSharper.Psi.Cpp.Overload.CppSubstitutionConsumerUtil : object {
    public static bool IsSubstitutionFailureTemplateParameterInDeduction(ICppTemplateParameter param, CppSubstitutionContext subst, CppTypeContext& tc);
    public static bool IsUnknownSubstitutionTemplateArgument(ICppTemplateArgument arg);
    public static bool IsMatchingParameterArgumentPair(ICppTemplateParameter par, ICppTemplateArgument arg);
    public static bool DoArgumentPacksMatch(ICppTemplateArgumentPack one, ICppTemplateArgumentPack other, bool ignoreMagicType);
    public static bool DoArgumentsMatch(ICppTemplateArgument one, ICppTemplateArgument other, bool ignoreMagicType);
    public static bool IsNewArgumentForParameterOk(ICppTemplateArgument oldArgument, ICppTemplateArgument newArgument, bool ignoreMagicType);
    public static bool IsNewArgumentPackForParameterOk(ICppTemplateArgumentPack oldArgument, ICppTemplateArgumentPack newArgument);
}
public enum JetBrains.ReSharper.Psi.Cpp.Overload.CppSubstitutionResult : Enum {
    public int value__;
    public static CppSubstitutionResult Ok;
    public static CppSubstitutionResult Fail;
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppSurrogateOverloadingCandidate : CppOverloadingCandidate {
    [CompilerGeneratedAttribute]
private ICppGroupedFunctionDeclaratorResolveEntity <ConversionFunc>k__BackingField;
    public ICppGroupedFunctionDeclaratorResolveEntity ConversionFunc { get; }
    public CppQualType VerboseFunctionTypeWithoutSubstitution { get; }
    public CppSurrogateOverloadingCandidate(ICppGroupedFunctionDeclaratorResolveEntity conversionFunc, int explicitArgCount, ICppOverloadingInfoAggregator infoAggregator);
    [CompilerGeneratedAttribute]
public ICppGroupedFunctionDeclaratorResolveEntity get_ConversionFunc();
    public virtual CppQualType get_VerboseFunctionTypeWithoutSubstitution();
    public virtual CppQualType GetFunctionType(ICppResolvedTypeFactory tf);
    public virtual CppRestrictionSpecifiers GetFunctionRestrictionSpecifiers();
    public virtual int GetParameterCount();
    public virtual bool HasAnyEllipsis();
    private CppQualType AdjustType(CppQualType ret);
    private CppQualType GetFunctionType();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppTemplateArgumentDeductionResult : ValueType {
    public Status ResultStatus;
    public Failure FailureReason;
    public CppSubstitutionContext Substitution;
    public ICppResolvedExpression FailedConstraint;
    private CppTemplateArgumentDeductionResult(Status status, Failure failureReason, CppSubstitutionContext substitution);
    public static CppTemplateArgumentDeductionResult Succeeded(CppSubstitutionContext subst);
    public static CppTemplateArgumentDeductionResult Failed(Failure failureReason);
    public static CppTemplateArgumentDeductionResult FailedWithConstraint(ICppResolvedExpression constraint);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppTemplateFunctionCallArgumentDeductionResult : ValueType {
    public Status Status;
    public CppPickFunctionSpecializationResult PickedSpecialization;
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppTernaryOperatorConversionResult : ValueType {
    public bool CanConvert;
    public bool ConversionIsAmbiguous;
    public CppTypeAndCategory TargetT;
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Overload.CppTypeDeductionOptions : Enum {
    public int value__;
    public static CppTypeDeductionOptions None;
    public static CppTypeDeductionOptions DeducedTypeCanBeMoreQualified;
    public static CppTypeDeductionOptions DeducedTypeCanBeDerivedClass;
    public static CppTypeDeductionOptions SeeThoughMoreQualifiedPointers;
    public static CppTypeDeductionOptions TransformTopLevelFunctionParameters;
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppTypeListSubstitutionConsumer`1 : CppGenericErrorHandlingSubstitutionConsumer`1<TErrorConsumer> {
    private IList`1<CppQualType> myTypes;
    protected CppTypeListSubstitutionConsumer`1(CppTemplateParametersBase templParams, IList`1<CppQualType> types, CppTypeContext& tc, TErrorConsumer errorConsumer);
    public CppTypeListSubstitutionConsumer`1(CppTemplateParametersBase templParams, CppQualType type, CppTypeContext& tc, TErrorConsumer errorConsumer);
    protected virtual void Substitute(CppSubstitutionContext ctx);
    protected virtual bool HasFailedSubstitutions(CppSubstitutionContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppTypeListWithExplicitExpressionSubstitutionConsumer : CppTypeListSubstitutionConsumer`1<ICppTemplateDeductionErrorConsumer> {
    private ICppResolvedExpression myExplicitExpression;
    public CppTypeListWithExplicitExpressionSubstitutionConsumer(CppTemplateParametersBase templParams, CppQualType type, ICppResolvedExpression explicitExpr, CppTypeContext& tc, ICppTemplateDeductionErrorConsumer errorConsumer);
    protected virtual void Substitute(CppSubstitutionContext ctx);
    protected virtual bool HasFailedSubstitutions(CppSubstitutionContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppUnknownTypeCastConversion : CppCastConversion {
    public CppUnknownTypeCastConversion(ICppExpression sourceExpr, CppQualType fromType, CppQualType toType);
    public virtual bool IsFailure();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppUnknownTypeConversion : CppImplicitConversionSequence {
    public int Rank { get; }
    public ReferenceFlag TargetReferenceFlag { get; }
    public CppUnknownTypeConversion(ICppResolvedExpression from);
    public virtual int get_Rank();
    public virtual ReferenceFlag get_TargetReferenceFlag();
    public virtual TResult Accept(ICppImplicitConversionSequenceVisitor`1<TResult> vis);
    public virtual CppImplicitConversionSequence Clone();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.CppUserDefinedConversionSequence : CppImplicitConversionSequence {
    private CppOverloadingRunInfo myConvertingFunctionOverloadingInfo;
    private bool myHasConvertingFunctionOverloadingInfo;
    [CompilerGeneratedAttribute]
private CppImplicitConversionSequence <InitialConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private CppStandardConversionSequence <FinalConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppGroupedFunctionDeclaratorResolveEntity <ConvertingFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDirectInit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsListInit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsContextualBoolConversion>k__BackingField;
    public CppImplicitConversionSequence InitialConversion { get; }
    public CppStandardConversionSequence FinalConversion { get; }
    [CanBeNullAttribute]
public ICppGroupedFunctionDeclaratorResolveEntity ConvertingFunction { get; }
    public Nullable`1<CppOverloadingRunInfo> ConvertingFunctionOverloadingInfo { get; }
    public bool IsDirectInit { get; }
    public bool IsListInit { get; }
    public bool IsContextualBoolConversion { get; }
    public int Rank { get; }
    public ReferenceFlag TargetReferenceFlag { get; }
    public CppUserDefinedConversionSequence(ICppResolvedExpression expr, CppImplicitConversionSequence initialConv, CppStandardConversionSequence finalConversion, ICppGroupedFunctionDeclaratorResolveEntity convertingFunction);
    public CppUserDefinedConversionSequence(ICppResolvedExpression expr, CppImplicitConversionSequence initialConv, CppStandardConversionSequence finalConversion, ICppGroupedFunctionDeclaratorResolveEntity convertingFunction, CppOverloadingRunInfo convertingFunctionOverloadingInfo, bool isDirectInit, bool isListInit, bool isContextualBoolConversion);
    private CppUserDefinedConversionSequence(ICppResolvedExpression expr, CppImplicitConversionSequence initialConv, CppStandardConversionSequence finalConversion, ICppGroupedFunctionDeclaratorResolveEntity convertingFunction, CppOverloadingRunInfo convertingFunctionOverloadingInfo, bool hasConvertingFunctionOverloadingInfo, bool isDirectInit, bool isListInit, bool isContextualBoolConversion);
    [CompilerGeneratedAttribute]
public CppImplicitConversionSequence get_InitialConversion();
    [CompilerGeneratedAttribute]
public CppStandardConversionSequence get_FinalConversion();
    [CompilerGeneratedAttribute]
public ICppGroupedFunctionDeclaratorResolveEntity get_ConvertingFunction();
    public Nullable`1<CppOverloadingRunInfo> get_ConvertingFunctionOverloadingInfo();
    [CompilerGeneratedAttribute]
public bool get_IsDirectInit();
    [CompilerGeneratedAttribute]
public bool get_IsListInit();
    [CompilerGeneratedAttribute]
public bool get_IsContextualBoolConversion();
    public virtual int get_Rank();
    public virtual ReferenceFlag get_TargetReferenceFlag();
    public virtual TResult Accept(ICppImplicitConversionSequenceVisitor`1<TResult> vis);
    public virtual CppImplicitConversionSequence Clone();
}
public class JetBrains.ReSharper.Psi.Cpp.Overload.HlslOverloadingCandidate : CppOverloadingCandidate {
    private HlslBuiltinFunctionResolveEntity myEntity;
    private CppQualType[] myParamTypes;
    [CompilerGeneratedAttribute]
private CppQualType <VerboseFunctionTypeWithoutSubstitution>k__BackingField;
    public CppQualifiedNamePart Name { get; }
    public CppQualType VerboseFunctionTypeWithoutSubstitution { get; }
    public HlslOverloadingCandidate(HlslBuiltinFunctionResolveEntity ent, CppQualType returnType, CppQualType[] paramsTypes, CppImplicitConversionSequence[] conversions, ICppOverloadingInfoAggregator expTypeConsumer, ICppResolvedTypeFactory tf);
    public CppQualifiedNamePart get_Name();
    [CompilerGeneratedAttribute]
public virtual CppQualType get_VerboseFunctionTypeWithoutSubstitution();
    public virtual CppQualType GetFunctionType(ICppResolvedTypeFactory tf);
    public virtual CppRestrictionSpecifiers GetFunctionRestrictionSpecifiers();
    public virtual int GetParameterCount();
    public virtual bool HasAnyEllipsis();
}
public interface JetBrains.ReSharper.Psi.Cpp.Overload.ICppAggregateInitializationInfoItem {
}
public interface JetBrains.ReSharper.Psi.Cpp.Overload.ICppAutoSubstitutionConsumer {
    public abstract virtual bool ShouldSubstituteAuto();
    public abstract virtual void LearnAutoSubstitution(ICppTemplateArgument argument);
}
public interface JetBrains.ReSharper.Psi.Cpp.Overload.ICppImplicitConversionSequenceVisitor`1 {
    public abstract virtual TResult Visit(CppStandardConversionSequence seq);
    public abstract virtual TResult Visit(CppUserDefinedConversionSequence seq);
    public abstract virtual TResult Visit(CppAmbiguousConversionSequence seq);
    public abstract virtual TResult Visit(CppEmptyConversionSequence seq);
    public abstract virtual TResult Visit(CppBadConversionSequence seq);
    public abstract virtual TResult Visit(CppEllipsisConversionSequence seq);
    public abstract virtual TResult Visit(CppSpecialMatchConversion seq);
    public abstract virtual TResult Visit(CppUnknownTypeConversion seq);
    public abstract virtual TResult Visit(CppCliParameterArrayConversionSequence seq);
}
public interface JetBrains.ReSharper.Psi.Cpp.Overload.ICppOverloadContext {
    public ICppExpression[] ActualArguments { get; }
    [IsReadOnlyAttribute]
public CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) TypeContext { get; }
    public abstract virtual CppSmallList`1<CppOverloadingCandidate> BuildOverloadSet(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> candidates, CppOverloadSetBuilderParams builderParams);
    public abstract virtual CppSmallList`1<CppOverloadingCandidate> BuildOverloadSetForParameterInfo(FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> candidates, CppOverloadSetBuilderParams builderParams);
    public abstract virtual ICppExpression[] get_ActualArguments();
    public abstract virtual CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) get_TypeContext();
    public abstract virtual void ResetTypeFactory(ICppResolvedTypeFactory tf);
}
public interface JetBrains.ReSharper.Psi.Cpp.Overload.ICppOverloadContextCaller {
    public abstract virtual TResult Accept(ICppOverloadContextCallerVisitor`1<TResult> visitor);
}
public interface JetBrains.ReSharper.Psi.Cpp.Overload.ICppOverloadContextCallerVisitor`1 {
    public abstract virtual TResult Visit(CppCallToQualifiedReferenceCaller caller);
    public abstract virtual TResult Visit(CppCallToMemberAccessCaller caller);
    public abstract virtual TResult Visit(CppCallToObjectCaller caller);
    public abstract virtual TResult Visit(CppBracedInitTemporaryCaller caller);
    public abstract virtual TResult Visit(CppCallToTypeCaller caller);
    public abstract virtual TResult Visit(CppOverloadedBinaryOperatorCaller caller);
    public abstract virtual TResult Visit(CppOverloadedUnaryOperatorCaller caller);
    public abstract virtual TResult Visit(CppOverloadedPostfixUnaryOperatorCaller caller);
    public abstract virtual TResult Visit(CppInitDeclaratorCaller caller);
    public abstract virtual TResult Visit(CppNewExpressionCaller caller);
    public abstract virtual TResult Visit(CppMemInitializerCaller caller);
    public abstract virtual TResult Visit(CppOverloadedSubscriptOperatorCaller caller);
    public abstract virtual TResult Visit(CppOverloadedPropertySubscriptCaller caller);
    public abstract virtual TResult Visit(CppOverloadedCoAwaitCaller caller);
    public abstract virtual TResult Visit(CppOverloadedCoYieldCaller caller);
    public abstract virtual TResult Visit(CppNewOperatorCaller caller);
}
public interface JetBrains.ReSharper.Psi.Cpp.Overload.ICppOverloadingInfoAggregator {
    public abstract virtual ICppTemplateFunctionCallDeductionErrorConsumer GetDeductionErrorConsumer();
    public abstract virtual CppOverloadingConversionBehaviour LearnFunctionArgumentConversion(ICppExpression node, CppQualType paramType, CppConversionHelper convHelper);
    public abstract virtual void LearnEllipsisConversion(ICppExpression node);
}
public interface JetBrains.ReSharper.Psi.Cpp.Overload.ICppOverloadingInfoAggregatorFactory {
    public abstract virtual ICppOverloadingInfoAggregator Create();
    public abstract virtual ICppResolvedTypeFactory RefineTypeFactory(ICppResolvedTypeFactory tf);
}
public interface JetBrains.ReSharper.Psi.Cpp.Overload.ICppTemplateDeductionErrorConsumer {
    public abstract virtual void LearnFirstDeducedArg(ICppTemplateParameter param, ICppTemplateArgument arg);
    public abstract virtual void LearnMultipleDeducedArgs(ICppTemplateParameter param, ICppTemplateArgument firstDeduced, ICppTemplateArgument newDeduced);
    public abstract virtual void LearnNondeducedParameters(CppList`1<ICppTemplateParameter> params);
    public abstract virtual void LearnMismatchedParameterArgumentPair(ICppTemplateParameter par, ICppTemplateArgument arg);
    public abstract virtual void LearnTooManyExplicitArguments(ICppTemplateArgument firstExcessArgument);
    public abstract virtual void LearnDefaultTemplateArgumentSubstitutionFailed(ICppTemplateParameter param, ICppTemplateArgument arg, CppSubstitutionContext sc, CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc);
    public abstract virtual void LearnTypeOfExpressionTemplateParameterSubstitutionFailed(CppQualType t, CppSubstitutionContext sc, CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc);
    public abstract virtual void LearnSubstitutionFailureError();
    public abstract virtual void LearnConstraintNotSatisfiedError(ICppResolvedExpression constraint, CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) typeContext);
    public abstract virtual void LearnTemplateParametersDeducedFromOverloadedType(ICppResolvedQualifiedReferenceExpression e, ICollection`1<ICppTemplateParameter> params);
}
public interface JetBrains.ReSharper.Psi.Cpp.Overload.ICppTemplateDeductionErrors {
    public OneToListMap`2<ICppTemplateParameter, ICppTemplateArgument> Substitutions { get; }
    public abstract virtual OneToListMap`2<ICppTemplateParameter, ICppTemplateArgument> get_Substitutions();
}
public interface JetBrains.ReSharper.Psi.Cpp.Overload.ICppTemplateFunctionCallDeductionErrorConsumer {
    public abstract virtual void LearnTypeMismatchError(int argIndex, CppQualType paramType, ICppResolvedExpression arg);
    public abstract virtual void LearnFunctionTypeSubstitutionFailed(CppQualType original, CppQualType substituted, CppSubstitutionContext substCtx, CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) typeCtx);
}
public interface JetBrains.ReSharper.Psi.Cpp.Overload.ICppTemplateParameterSubstitutionConsumer {
    public abstract virtual bool ShouldSubstitute(ICppTemplateParameter param);
    public abstract virtual CppSubstitutionResult LearnSubstitution(ICppTemplateParameter param, ICppTemplateArgument argument);
    public abstract virtual CppSubstitutionResult LearnSubstitutionSanitized(ICppTemplateParameter param, ICppTemplateArgument argument);
}
public interface JetBrains.ReSharper.Psi.Cpp.Overload.ICppTemplateSubstitutionConsumer {
    public abstract virtual bool ShouldMatchMagicArgumentTypesWithAnything();
    public abstract virtual bool ShouldDeduceFromDependentArguments();
    public abstract virtual bool DependentExpressionTemplateParameterIsAllowed();
    public abstract virtual IEnumerable`1<ICppTemplateParameter> GetTargetParameters();
    public abstract virtual void StartVariadic(int expansionLength, HashSet`1<ICppTemplateParameterPack> expansionParameters);
    public abstract virtual void SetVariadicIndex(int index, HashSet`1<ICppTemplateParameterPack> expansionParameters);
    public abstract virtual void FinishVariadic(HashSet`1<ICppTemplateParameterPack> expansionParameters);
    public abstract virtual ICppTemplateDeductionErrorConsumer GetErrorConsumer();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Parsing.AttributeSeqPrefix : ValueType {
    public bool HadAttributes;
    public int TextOffset;
    public int OffsetInSubstitution;
    public AttributeSeqPrefix(bool hadAttributes, CppComplexOffset complexOffset);
    public static AttributeSeqPrefix MakeEmpty();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppCachingKeywordResolvingLexer : CachingLexer {
    private ReusableBufferRange myReusableBufferRange;
    [CompilerGeneratedAttribute]
private CppTokenNodeTypeTraits <Traits>k__BackingField;
    public TokenNodeType AdjustedTokenType { get; }
    public CppTokenNodeTypeTraits Traits { get; }
    public CppCachingKeywordResolvingLexer(CachingLexer lexer, CppLanguageDialect dialect);
    public TokenNodeType get_AdjustedTokenType();
    [CompilerGeneratedAttribute]
public CppTokenNodeTypeTraits get_Traits();
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.CppCachingTokenCursor : object {
    private CppParsing0 myOwner;
    private TokenNodeType myTokenType;
    private CppComplexOffset myTokenOffset;
    private int myTokenIndex;
    private bool myValid;
    public CppCachingTokenCursor(CppParsing0 owner);
    public TokenNodeType TokenType();
    public string TokenText();
    public int TokenIndex();
    public CppComplexOffset NavigationOffset();
    public TokenNodeType TokenType(bool unwrap);
    public void Peek();
    public void Reset();
    public bool Valid();
}
public static class JetBrains.ReSharper.Psi.Cpp.Parsing.CppCannotParseFile : object {
    private static Key`1<Boxed`1<CppCannotParseFileReason>> ourInstance;
    private static CppCannotParseFile();
    public static void MarkAsNotParsed(IPsiSourceFile sourceFile, CppCannotParseFileReason reason);
    public static Nullable`1<CppCannotParseFileReason> GetNotParsedReason(IPsiSourceFile sourceFile);
    public static void RemoveReason(IPsiSourceFile sourceFile);
}
public enum JetBrains.ReSharper.Psi.Cpp.Parsing.CppCannotParseFileReason : Enum {
    public int value__;
    public static CppCannotParseFileReason InternalError;
    public static CppCannotParseFileReason SharedProject;
    public static CppCannotParseFileReason GeneratedCode;
    public static CppCannotParseFileReason NotSupportedDialect;
    public static CppCannotParseFileReason InlineInclude;
    public static CppCannotParseFileReason UnsuitableProjectFile;
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppCommentTokenNode : CppGenericTokenNode {
    public CppCommentType CommentType { get; }
    public string CommentText { get; }
    public CppCommentTokenNode(CppCommentTokenNodeType type, string text);
    public CppCommentType get_CommentType();
    private int GetStartCommentBorderLength();
    private int GetEndCommentBorderLength();
    public sealed virtual string get_CommentText();
    public sealed virtual TreeTextRange GetCommentRange();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppCommentTokenNodeType : CppGenericTokenNodeType {
    public CppCommentTokenNodeType(string s, CppTokenKind kind, string repr);
    public virtual LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
}
public enum JetBrains.ReSharper.Psi.Cpp.Parsing.CppCommentType : Enum {
    public int value__;
    public static CppCommentType END_OF_LINE_COMMENT;
    public static CppCommentType MULTILINE_COMMENT;
    public static CppCommentType WTF_COMMENT;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Parsing.CppCompositeNodeFactory : object {
    [ExtensionAttribute]
public static CompositeElement CreateNode(CppCompositeNodeType nodeType, object userData);
    public static ITreeNode CopyNodeAsEmpty(ITreeNode source);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppCompositeNodeType : CompositeNodeWithArgumentType {
    public CppCompositeNodeType(string name);
    public virtual CompositeElement Create(object userData);
    public virtual CompositeElement Create();
    private CompositeElement CreateImpl(object userData);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppCompositeNodeTypes : object {
    public static CppCompositeNodeType RECOVERY_JUNK;
    public static CppCompositeNodeType RECOVERY_JUNK_STUB;
    public static CppCompositeNodeType FILE;
    public static CppCompositeNodeType CODE_FRAGMENT;
    public static CppCompositeNodeType CHAMELEON_COMPOUND_STATEMENT;
    public static CppCompositeNodeType CHAMELEON_FUNCTION_TRY_BLOCK;
    public static CppCompositeNodeType CHAMELEON_CTOR_BLOCK;
    public static CppCompositeNodeType DIRECTIVE;
    public static CppCompositeNodeType DEFINED_DIRECTIVE;
    public static CppCompositeNodeType MACRO_PARAMETER;
    public static CppCompositeNodeType MACRO_PARAMETER_LIST;
    public static CppCompositeNodeType MACRO_BODY;
    public static CppCompositeNodeType MACRO_DEFINITION;
    public static CppCompositeNodeType MACRO_UNDEFINITION;
    public static CppCompositeNodeType IMPORT_DIRECTIVE;
    public static CppCompositeNodeType MS_IMPORT_DIRECTIVE;
    public static CppCompositeNodeType MACRO_CALL;
    public static CppCompositeNodeType MACRO_REF;
    public static CppCompositeNodeType MACRO_ARGUMENT;
    public static CppCompositeNodeType MACRO_ARGUMENT_LIST;
    public static CppCompositeNodeType PP_PRAGMA_DIRECTIVE;
    public static CppCompositeNodeType MODULE_DIRECTIVE;
    public static CppCompositeNodeType CPP20_IMPORT_HEADER_UNIT_DIRECTIVE;
    public static CppCompositeNodeType CPP20_IMPORT_MODULE_DIRECTIVE;
    public static CppCompositeNodeType MODULE_NAME;
    public static CppCompositeNodeType MODULE_NAME_QUALIFIER;
    public static CppCompositeNodeType EMPTY_DECLARATION;
    public static CppCompositeNodeType SIMPLE_DECLARATION;
    public static CppCompositeNodeType DEFAULT_SPECIFIER;
    public static CppCompositeNodeType DELETE_SPECIFIER;
    public static CppCompositeNodeType DECLARATION;
    public static CppCompositeNodeType DECLARATION_SPECIFIERS;
    public static CppCompositeNodeType ENUM_BASE;
    public static CppCompositeNodeType NESTED_DECLARATOR;
    public static CppCompositeNodeType DECLARATOR_QUALIFIED_NAME;
    public static CppCompositeNodeType ABSTRACT_DECLARATOR_NAME;
    public static CppCompositeNodeType DECLARATOR;
    public static CppCompositeNodeType ABSTRACT_DECLARATOR;
    public static CppCompositeNodeType INIT_DECLARATOR;
    public static CppCompositeNodeType ARRAY_SIZE_SPECIFIER;
    public static CppCompositeNodeType PARAMETERS_AND_QUALIFIERS;
    public static CppCompositeNodeType KNR_STYLE_PARAMETER_DECLARATIONS;
    public static CppCompositeNodeType PURE_SPECIFIER;
    public static CppCompositeNodeType AMP_RESTRICTION_SPECIFIER;
    public static CppCompositeNodeType DYNAMIC_EXCEPTION_SPECIFICATION;
    public static CppCompositeNodeType NOEXCEPT_SPECIFICATION;
    public static CppCompositeNodeType TRAILING_RETURN_TYPE;
    public static CppCompositeNodeType BRACED_INIT_LIST;
    public static CppCompositeNodeType SUBSCRIPT_DESIGNATOR;
    public static CppCompositeNodeType MEMBER_ACCESS_DESIGNATOR;
    public static CppCompositeNodeType DESIGNATION;
    public static CppCompositeNodeType FUNCTION_ARGUMENT_LIST;
    public static CppCompositeNodeType CUDA_ARGUMENT_LIST;
    public static CppCompositeNodeType BITFIELD_DECLARATOR;
    public static CppCompositeNodeType INIT_BITFIELD_DECLARATOR;
    public static CppCompositeNodeType CXXCLI_DELEGATE_DECLARATOR;
    public static CppCompositeNodeType CXXCLI_PROPERTY_OR_EVENT_DECLARATOR;
    public static CppCompositeNodeType CXXCLI_PROPERTY_INDEXES;
    public static CppCompositeNodeType CXXCLI_OVERRIDE_SPECIFIER;
    public static CppCompositeNodeType CXXCLI_PROPERTY_DECLARATION;
    public static CppCompositeNodeType CXXCLI_EVENT_DECLARATION;
    public static CppCompositeNodeType CONCEPT_DEFINITION;
    public static CppCompositeNodeType CONCEPT_QUALIFIED_NAME;
    public static CppCompositeNodeType CLASS_SPECIFIER;
    public static CppCompositeNodeType FWD_CLASS_SPECIFIER;
    public static CppCompositeNodeType ENUM_SPECIFIER;
    public static CppCompositeNodeType FWD_ENUM_SPECIFIER;
    public static CppCompositeNodeType ELABORATED_TYPE_SPECIFIER;
    public static CppCompositeNodeType ACCESS_SPECIFIER;
    public static CppCompositeNodeType BASE_CLAUSE;
    public static CppCompositeNodeType BASE_SPECIFIER;
    public static CppCompositeNodeType EXPLICIT_SPECIFIER;
    public static CppCompositeNodeType ENUM_UNDERLYING_TYPE_CLAUSE;
    public static CppCompositeNodeType ENUMERATOR;
    public static CppCompositeNodeType NAMESPACE_DEFINITION;
    public static CppCompositeNodeType NAMESPACE_DEFINITION_NAME;
    public static CppCompositeNodeType NAMESPACE_DEFINITION_NAME_QUALIFIER;
    public static CppCompositeNodeType NAMESPACE_ALIAS_DEFINITION;
    public static CppCompositeNodeType USING_DECLARATION;
    public static CppCompositeNodeType USING_DECLARATOR;
    public static CppCompositeNodeType USING_DIRECTIVE;
    public static CppCompositeNodeType USING_ENUM_DECLARATION;
    public static CppCompositeNodeType ALIAS_DECLARATION;
    public static CppCompositeNodeType LINKAGE_SPECIFICATION;
    public static CppCompositeNodeType ALIAS_DECLARATION_NAME;
    public static CppCompositeNodeType CLASS_QUALIFIED_NAME;
    public static CppCompositeNodeType QUALIFIED_REFERENCE;
    public static CppCompositeNodeType QUALIFIED_TEMPLATE_REFERENCE;
    public static CppCompositeNodeType QUALIFIED_TYPENAME_REFERENCE;
    public static CppCompositeNodeType QUALIFIED_NAMESPACE_REFERENCE;
    public static CppCompositeNodeType QUALIFIED_USING_DECLARATION_TARGET_REFERENCE;
    public static CppCompositeNodeType QUALIFIED_USING_ENUM_DECLARATION_TARGET_REFERENCE;
    public static CppCompositeNodeType QUALIFIED_BASE_TYPE_REFERENCE;
    public static CppCompositeNodeType QUALIFIED_CXXCLI_OVERRIDE_TARGET_REFERENCE;
    public static CppCompositeNodeType QUALIFIED_CONCEPT_REFERENCE;
    public static CppCompositeNodeType MS_IF_EXISTS_REFERENCE;
    public static CppCompositeNodeType DECLARATION_SPECIFIER_TYPENAME;
    public static CppCompositeNodeType NAME_QUALIFIER;
    public static CppCompositeNodeType OPERATOR_FUNCTION_ID;
    public static CppCompositeNodeType TYPE_ID;
    public static CppCompositeNodeType TEMPLATE_ARGUMENT_LIST;
    public static CppCompositeNodeType MS_IDENTIFIER;
    public static CppCompositeNodeType BUILTIN_TYPE_TRAIT;
    public static CppCompositeNodeType STRUCTURED_BINDING_IDENTIFIER;
    public static CppCompositeNodeType STRUCTURED_BINDING_IDENTIFIER_LIST;
    public static CppCompositeNodeType TEMPLATE_DECLARATION;
    public static CppCompositeNodeType TYPE_PARAMETER;
    public static CppCompositeNodeType NON_TYPE_PARAMETER;
    public static CppCompositeNodeType TEMPLATE_TEMPLATE_PARAMETER;
    public static CppCompositeNodeType CONCEPT_PARAMETER;
    public static CppCompositeNodeType EXPLICIT_INSTANTIATION;
    public static CppCompositeNodeType EXPORT_DECLARATION;
    public static CppCompositeNodeType GENERIC_CONSTRAINT;
    public static CppCompositeNodeType SIMPLE_GENERIC_CONSTRAINT_ITEM;
    public static CppCompositeNodeType BASE_TYPE_GENERIC_CONSTRAINT_ITEM;
    public static CppCompositeNodeType FUNCTION_TRY_BLOCK;
    public static CppCompositeNodeType CTOR_BLOCK;
    public static CppCompositeNodeType CTOR_INITIALIZER;
    public static CppCompositeNodeType MEM_INITIALIZER;
    public static CppCompositeNodeType MEM_INITIALIZER_NAME;
    public static CppCompositeNodeType STATIC_ASSERT_DECLARATION;
    public static CppCompositeNodeType DECLTYPE_SPECIFIER;
    public static CppCompositeNodeType DECLTYPE_AUTO_SPECIFIER;
    public static CppCompositeNodeType CONCEPT_AUTO_SPECIFIER;
    public static CppCompositeNodeType COMPOUND_STATEMENT;
    public static CppCompositeNodeType FUNCTION_BODY;
    public static CppCompositeNodeType EMPTY_STATEMENT;
    public static CppCompositeNodeType DECLARATION_STATEMENT;
    public static CppCompositeNodeType EXPRESSION_STATEMENT;
    public static CppCompositeNodeType LABELED_STATEMENT;
    public static CppCompositeNodeType CASE_STATEMENT;
    public static CppCompositeNodeType DEFAULT_STATEMENT;
    public static CppCompositeNodeType GNU_CASE_RANGE;
    public static CppCompositeNodeType IF_STATEMENT;
    public static CppCompositeNodeType WHILE_STATEMENT;
    public static CppCompositeNodeType DO_STATEMENT;
    public static CppCompositeNodeType DO_STATEMENT_BODY;
    public static CppCompositeNodeType SWITCH_STATEMENT;
    public static CppCompositeNodeType FOR_STATEMENT;
    public static CppCompositeNodeType RANGE_BASED_FOR_STATEMENT;
    public static CppCompositeNodeType RANGE_BASED_CO_AWAIT_FOR_STATEMENT;
    public static CppCompositeNodeType MS_FOREACH_STATEMENT;
    public static CppCompositeNodeType GOTO_STATEMENT;
    public static CppCompositeNodeType GNU_COMPUTED_GOTO_STATEMENT;
    public static CppCompositeNodeType CONTINUE_STATEMENT;
    public static CppCompositeNodeType BREAK_STATEMENT;
    public static CppCompositeNodeType DISCARD_STATEMENT;
    public static CppCompositeNodeType RETURN_STATEMENT;
    public static CppCompositeNodeType CO_RETURN_STATEMENT;
    public static CppCompositeNodeType MS_LEAVE_STATEMENT;
    public static CppCompositeNodeType TRY_STATEMENT;
    public static CppCompositeNodeType CATCH_SECTION;
    public static CppCompositeNodeType MS_IF_EXISTS_TOP_LEVEL;
    public static CppCompositeNodeType MS_IF_EXISTS_CLASS_MEMBER;
    public static CppCompositeNodeType MS_IF_EXISTS_STATEMENT;
    public static CppCompositeNodeType MS_IF_EXISTS_EXPRESSION;
    public static CppCompositeNodeType MS_IF_EXISTS_ARGUMENT_CLAUSE;
    public static CppCompositeNodeType MS_IF_EXISTS_BLOCK_BRACES;
    public static CppCompositeNodeType ASM_DEFINITION;
    public static CppCompositeNodeType EMPTY_EXPRESSION;
    public static CppCompositeNodeType LITERAL_EXPRESSION;
    public static CppCompositeNodeType USER_DEFINED_LITERAL_EXPRESSION;
    public static CppCompositeNodeType THIS_EXPRESSION;
    public static CppCompositeNodeType CAST_EXPRESSION;
    public static CppCompositeNodeType TYPEID_EXPRESSION;
    public static CppCompositeNodeType PAREN_EXPRESSION;
    public static CppCompositeNodeType SIZEOF_EXPRESSION;
    public static CppCompositeNodeType SIZEOF_ELLIPSIS_EXPRESSION;
    public static CppCompositeNodeType ALIGNOF_EXPRESSION;
    public static CppCompositeNodeType NOEXCEPT_EXPRESSION;
    public static CppCompositeNodeType THROW_EXPRESSION;
    public static CppCompositeNodeType UNARY_EXPRESSION;
    public static CppCompositeNodeType POSTFIX_EXPRESSION;
    public static CppCompositeNodeType BINARY_EXPRESSION;
    public static CppCompositeNodeType FOLD_EXPRESSION;
    public static CppCompositeNodeType CONDITIONAL_EXPRESSION;
    public static CppCompositeNodeType MEMBER_ACCESS_EXPRESSION;
    public static CppCompositeNodeType SUBSCRIPT_EXPRESSION;
    public static CppCompositeNodeType CALL_EXPRESSION;
    public static CppCompositeNodeType BRACE_INITIALIZED_TEMPORARY;
    public static CppCompositeNodeType MS_NOOP_EXPRESSION;
    public static CppCompositeNodeType MS_ASSUME_EXPRESSION;
    public static CppCompositeNodeType COMPOUND_STATEMENT_EXPRESSION;
    public static CppCompositeNodeType PACK_EXPANSION_EXPRESSION;
    public static CppCompositeNodeType LAMBDA_EXPRESSION;
    public static CppCompositeNodeType LAMBDA_INTRODUCER;
    public static CppCompositeNodeType LAMBDA_CAPTURE;
    public static CppCompositeNodeType LAMBDA_CAPTURE_NAME;
    public static CppCompositeNodeType LAMBDA_DECLARATOR;
    public static CppCompositeNodeType REQUIRES_CLAUSE;
    public static CppCompositeNodeType REQUIRES_EXPRESSION;
    public static CppCompositeNodeType REQUIRES_EXPRESSION_BODY;
    public static CppCompositeNodeType REQUIRES_EXPRESSION_ITEM;
    public static CppCompositeNodeType CLI_MULTI_ARGUMENT_SUBSCRIPT_EXPRESSION;
    public static CppCompositeNodeType CLI_TYPEID_EXPRESSION;
    public static CppCompositeNodeType CPP_NEW_EXPRESSION;
    public static CppCompositeNodeType CPP_DELETE_EXPRESSION;
    public static CppCompositeNodeType C11_GENERIC_EXPRESSION;
    public static CppCompositeNodeType C11_GENERIC_EXPRESSION_CLAUSE;
    public static CppCompositeNodeType ALIGNMENT_SPECIFIER;
    public static CppCompositeNodeType ATTRIBUTE_LIST;
    public static CppCompositeNodeType GNU_STYLE_ATTRIBUTE_LIST;
    public static CppCompositeNodeType ATTRIBUTE;
    public static CppCompositeNodeType CONTRACT_ATTRIBUTE;
    public static CppCompositeNodeType MS_DECL_SPEC;
    public static CppCompositeNodeType MS_ATTRIBUTES;
    public static CppCompositeNodeType GNU_ADDRESS_OF_LABEL_EXPRESSION;
    public static CppCompositeNodeType SINGLE_ARGUMENT_TYPE_TRAIT_EXPRESSION;
    public static CppCompositeNodeType DOUBLE_ARGUMENT_TYPE_TRAIT_EXPRESSION;
    public static CppCompositeNodeType MULTI_ARGUMENT_TYPE_TRAIT_EXPRESSION;
    public static CppCompositeNodeType MS_UUIDOF_EXPRESSION;
    public static CppCompositeNodeType MS_EVENT_HOOK_EXPRESSION;
    public static CppCompositeNodeType MS_ASM_DEFINITION;
    public static CppCompositeNodeType MS_ASM_COMMENT;
    public static CppCompositeNodeType GNU_ASM_DEFINITION;
    public static CppCompositeNodeType GNU_ASM_OPERAND_LIST;
    public static CppCompositeNodeType GNU_ASM_CLOBBERS_LIST;
    public static CppCompositeNodeType GNU_ASM_GOTO_LABELS_LIST;
    public static CppCompositeNodeType MS_LPREFIXED_LITERAL;
    public static CppCompositeNodeType BUILTIN_ADDRESSOF_EXPRESSION;
    public static CppCompositeNodeType BUILTIN_OFFSETOF_EXPRESSION;
    public static CppCompositeNodeType GNU_BUILTIN_CONSTANT_P_EXPRESSION;
    public static CppCompositeNodeType GNU_BUILTIN_CHOOSE_EXPR_EXPRESSION;
    public static CppCompositeNodeType OFFSETOF_MEMBER_REFERENCE_DESIGNATOR;
    public static CppCompositeNodeType PRAGMA_DIRECTIVE;
    public static CppCompositeNodeType PRAGMA_PARAMETER_REFERENCE;
    public static CppCompositeNodeType UNPARSED_TEXT;
    public static CppCompositeNodeType CO_YIELD_EXPRESSION;
    public static CppCompositeNodeType CO_AWAIT_EXPRESSION;
    public static CppCompositeNodeType DOXYGEN_COMMENT;
    public static CppCompositeNodeType DOXYGEN_COMMENT_PREFIX;
    public static CppCompositeNodeType DOXYGEN_COMMENT_BODY;
    public static CppCompositeNodeType DOXYGEN_COMMAND;
    public static CppCompositeNodeType DOXYGEN_PAIRED_COMMAND;
    public static CppCompositeNodeType DOXYGEN_PAIRED_COMMAND_BODY;
    public static CppCompositeNodeType DOXYGEN_CMD;
    public static CppCompositeNodeType DOXYGEN_WORD;
    public static CppCompositeNodeType DOXYGEN_QUOTED_STRING;
    public static CppCompositeNodeType DOXYGEN_LINE;
    public static CppCompositeNodeType DOXYGEN_PARAGRAPH;
    public static CppCompositeNodeType DOXYGEN_PARAM_REF;
    public static CppCompositeNodeType DOXYGEN_TPARAM_REF;
    public static CppCompositeNodeType DOXYGEN_FILE_REF;
    public static CppCompositeNodeType DOXYGEN_BRACKETED_LIST;
    public static CppCompositeNodeType DOXYGEN_QUALIFIED_REFERENCE;
    public static CppCompositeNodeType DOXYGEN_NAME_QUALIFIER;
    public static CppCompositeNodeType DOXYGEN_DECLARATION;
    public static CppCompositeNodeType DOXYGEN_DECLARATOR;
    public static CppCompositeNodeType DOXYGEN_DECLARATION_SPECIFIERS;
    public static CppCompositeNodeType DOXYGEN_DECLARATION_SPECIFIER_TYPENAME;
    public static CppCompositeNodeType DOXYGEN_DECLARATOR_QUALIFIED_NAME;
    public static CppCompositeNodeType DOXYGEN_PARAMETERS_AND_QUALIFIERS;
    public static CppCompositeNodeType DOXYGEN_HTML_TAG;
    public static CppCompositeNodeType DOXYGEN_HTML_ATTRIBUTE;
    public static CppCompositeNodeType DOXYGEN_HTML_PAIRED_COMMAND;
    public static CppCompositeNodeType DOXYGEN_HTML_PAIRED_COMMAND_BODY;
    public static CppCompositeNodeType DOXYGEN_LIST;
    public static CppCompositeNodeType DOXYGEN_LIST_ITEM;
    public static CppCompositeNodeType DOXYGEN_LIST_ITEM_MARKER;
    public static CppCompositeNodeType DOXYGEN_LIST_ITEM_BODY;
    public static CppCompositeNodeType UE4_GENERATED_BODY;
    public static CppCompositeNodeType GG_DECLARE_HUNGARIAN;
    public static CppCompositeNodeType UE4_METADATA;
    public static CppCompositeNodeType UE4_METADATA_SPECIFIER;
    public static CppCompositeNodeType UE4_METADATA_SPECIFIER_KEY;
    public static CppCompositeNodeType UE4_METADATA_SPECIFIER_VALUE;
    public static CppCompositeNodeType HLSL_VECTOR_TYPE_SPECIFIER;
    public static CppCompositeNodeType HLSL_MATRIX_TYPE_SPECIFIER;
    public static CppCompositeNodeType HLSL_BUFFER_TYPE_SPECIFIER;
    public static CppCompositeNodeType HLSL_TRAILING_SEMANTIC;
    public static CppCompositeNodeType HLSL_TRAILING_REGISTER;
    public static CppCompositeNodeType HLSL_TRAILING_PACKOFFSET;
    public static CppCompositeNodeType HLSL_SHADER_CONSTANTS_BUFFER;
    public static CppCompositeNodeType HLSL_ATTRIBUTES;
    public static NodeTypeSet RECOVERY_JUNK_SS;
    public static NodeTypeSet RECOVERY_JUNK_STUB_SS;
    public static NodeTypeSet FILE_SS;
    public static NodeTypeSet CODE_FRAGMENT_SS;
    public static NodeTypeSet CHAMELEON_COMPOUND_STATEMENT_SS;
    public static NodeTypeSet CHAMELEON_FUNCTION_TRY_BLOCK_SS;
    public static NodeTypeSet CHAMELEON_CTOR_BLOCK_SS;
    public static NodeTypeSet DIRECTIVE_SS;
    public static NodeTypeSet DEFINED_DIRECTIVE_SS;
    public static NodeTypeSet MACRO_PARAMETER_SS;
    public static NodeTypeSet MACRO_PARAMETER_LIST_SS;
    public static NodeTypeSet MACRO_BODY_SS;
    public static NodeTypeSet MACRO_DEFINITION_SS;
    public static NodeTypeSet MACRO_UNDEFINITION_SS;
    public static NodeTypeSet IMPORT_DIRECTIVE_SS;
    public static NodeTypeSet MS_IMPORT_DIRECTIVE_SS;
    public static NodeTypeSet MACRO_CALL_SS;
    public static NodeTypeSet MACRO_REF_SS;
    public static NodeTypeSet MACRO_ARGUMENT_SS;
    public static NodeTypeSet MACRO_ARGUMENT_LIST_SS;
    public static NodeTypeSet PP_PRAGMA_DIRECTIVE_SS;
    public static NodeTypeSet MODULE_DIRECTIVE_SS;
    public static NodeTypeSet CPP20_IMPORT_HEADER_UNIT_DIRECTIVE_SS;
    public static NodeTypeSet CPP20_IMPORT_MODULE_DIRECTIVE_SS;
    public static NodeTypeSet MODULE_NAME_SS;
    public static NodeTypeSet MODULE_NAME_QUALIFIER_SS;
    public static NodeTypeSet EMPTY_DECLARATION_SS;
    public static NodeTypeSet SIMPLE_DECLARATION_SS;
    public static NodeTypeSet DEFAULT_SPECIFIER_SS;
    public static NodeTypeSet DELETE_SPECIFIER_SS;
    public static NodeTypeSet DECLARATION_SS;
    public static NodeTypeSet DECLARATION_SPECIFIERS_SS;
    public static NodeTypeSet ENUM_BASE_SS;
    public static NodeTypeSet NESTED_DECLARATOR_SS;
    public static NodeTypeSet DECLARATOR_QUALIFIED_NAME_SS;
    public static NodeTypeSet ABSTRACT_DECLARATOR_NAME_SS;
    public static NodeTypeSet DECLARATOR_SS;
    public static NodeTypeSet ABSTRACT_DECLARATOR_SS;
    public static NodeTypeSet INIT_DECLARATOR_SS;
    public static NodeTypeSet ARRAY_SIZE_SPECIFIER_SS;
    public static NodeTypeSet PARAMETERS_AND_QUALIFIERS_SS;
    public static NodeTypeSet KNR_STYLE_PARAMETER_DECLARATIONS_SS;
    public static NodeTypeSet PURE_SPECIFIER_SS;
    public static NodeTypeSet AMP_RESTRICTION_SPECIFIER_SS;
    public static NodeTypeSet DYNAMIC_EXCEPTION_SPECIFICATION_SS;
    public static NodeTypeSet NOEXCEPT_SPECIFICATION_SS;
    public static NodeTypeSet TRAILING_RETURN_TYPE_SS;
    public static NodeTypeSet BRACED_INIT_LIST_SS;
    public static NodeTypeSet SUBSCRIPT_DESIGNATOR_SS;
    public static NodeTypeSet MEMBER_ACCESS_DESIGNATOR_SS;
    public static NodeTypeSet DESIGNATION_SS;
    public static NodeTypeSet FUNCTION_ARGUMENT_LIST_SS;
    public static NodeTypeSet CUDA_ARGUMENT_LIST_SS;
    public static NodeTypeSet BITFIELD_DECLARATOR_SS;
    public static NodeTypeSet INIT_BITFIELD_DECLARATOR_SS;
    public static NodeTypeSet CXXCLI_DELEGATE_DECLARATOR_SS;
    public static NodeTypeSet CXXCLI_PROPERTY_OR_EVENT_DECLARATOR_SS;
    public static NodeTypeSet CXXCLI_PROPERTY_INDEXES_SS;
    public static NodeTypeSet CXXCLI_OVERRIDE_SPECIFIER_SS;
    public static NodeTypeSet CXXCLI_PROPERTY_DECLARATION_SS;
    public static NodeTypeSet CXXCLI_EVENT_DECLARATION_SS;
    public static NodeTypeSet CONCEPT_DEFINITION_SS;
    public static NodeTypeSet CONCEPT_QUALIFIED_NAME_SS;
    public static NodeTypeSet CLASS_SPECIFIER_SS;
    public static NodeTypeSet FWD_CLASS_SPECIFIER_SS;
    public static NodeTypeSet ENUM_SPECIFIER_SS;
    public static NodeTypeSet FWD_ENUM_SPECIFIER_SS;
    public static NodeTypeSet ELABORATED_TYPE_SPECIFIER_SS;
    public static NodeTypeSet ACCESS_SPECIFIER_SS;
    public static NodeTypeSet BASE_CLAUSE_SS;
    public static NodeTypeSet BASE_SPECIFIER_SS;
    public static NodeTypeSet EXPLICIT_SPECIFIER_SS;
    public static NodeTypeSet ENUM_UNDERLYING_TYPE_CLAUSE_SS;
    public static NodeTypeSet ENUMERATOR_SS;
    public static NodeTypeSet NAMESPACE_DEFINITION_SS;
    public static NodeTypeSet NAMESPACE_DEFINITION_NAME_SS;
    public static NodeTypeSet NAMESPACE_DEFINITION_NAME_QUALIFIER_SS;
    public static NodeTypeSet NAMESPACE_ALIAS_DEFINITION_SS;
    public static NodeTypeSet USING_DECLARATION_SS;
    public static NodeTypeSet USING_DECLARATOR_SS;
    public static NodeTypeSet USING_DIRECTIVE_SS;
    public static NodeTypeSet USING_ENUM_DECLARATION_SS;
    public static NodeTypeSet ALIAS_DECLARATION_SS;
    public static NodeTypeSet LINKAGE_SPECIFICATION_SS;
    public static NodeTypeSet ALIAS_DECLARATION_NAME_SS;
    public static NodeTypeSet CLASS_QUALIFIED_NAME_SS;
    public static NodeTypeSet QUALIFIED_REFERENCE_SS;
    public static NodeTypeSet QUALIFIED_TEMPLATE_REFERENCE_SS;
    public static NodeTypeSet QUALIFIED_TYPENAME_REFERENCE_SS;
    public static NodeTypeSet QUALIFIED_NAMESPACE_REFERENCE_SS;
    public static NodeTypeSet QUALIFIED_USING_DECLARATION_TARGET_REFERENCE_SS;
    public static NodeTypeSet QUALIFIED_USING_ENUM_DECLARATION_TARGET_REFERENCE_SS;
    public static NodeTypeSet QUALIFIED_BASE_TYPE_REFERENCE_SS;
    public static NodeTypeSet QUALIFIED_CXXCLI_OVERRIDE_TARGET_REFERENCE_SS;
    public static NodeTypeSet QUALIFIED_CONCEPT_REFERENCE_SS;
    public static NodeTypeSet MS_IF_EXISTS_REFERENCE_SS;
    public static NodeTypeSet DECLARATION_SPECIFIER_TYPENAME_SS;
    public static NodeTypeSet NAME_QUALIFIER_SS;
    public static NodeTypeSet OPERATOR_FUNCTION_ID_SS;
    public static NodeTypeSet TYPE_ID_SS;
    public static NodeTypeSet TEMPLATE_ARGUMENT_LIST_SS;
    public static NodeTypeSet MS_IDENTIFIER_SS;
    public static NodeTypeSet STRUCTURED_BINDING_IDENTIFIER_SS;
    public static NodeTypeSet STRUCTURED_BINDING_IDENTIFIER_LIST_SS;
    public static NodeTypeSet TEMPLATE_DECLARATION_SS;
    public static NodeTypeSet TYPE_PARAMETER_SS;
    public static NodeTypeSet NON_TYPE_PARAMETER_SS;
    public static NodeTypeSet TEMPLATE_TEMPLATE_PARAMETER_SS;
    public static NodeTypeSet CONCEPT_PARAMETER_SS;
    public static NodeTypeSet EXPLICIT_INSTANTIATION_SS;
    public static NodeTypeSet GENERIC_CONSTRAINT_SS;
    public static NodeTypeSet SIMPLE_GENERIC_CONSTRAINT_ITEM_SS;
    public static NodeTypeSet BASE_TYPE_GENERIC_CONSTRAINT_ITEM_SS;
    public static NodeTypeSet FUNCTION_TRY_BLOCK_SS;
    public static NodeTypeSet CTOR_BLOCK_SS;
    public static NodeTypeSet CTOR_INITIALIZER_SS;
    public static NodeTypeSet MEM_INITIALIZER_SS;
    public static NodeTypeSet MEM_INITIALIZER_NAME_SS;
    public static NodeTypeSet STATIC_ASSERT_DECLARATION_SS;
    public static NodeTypeSet DECLTYPE_SPECIFIER_SS;
    public static NodeTypeSet DECLTYPE_AUTO_SPECIFIER_SS;
    public static NodeTypeSet CONCEPT_AUTO_SPECIFIER_SS;
    public static NodeTypeSet COMPOUND_STATEMENT_SS;
    public static NodeTypeSet FUNCTION_BODY_SS;
    public static NodeTypeSet EMPTY_STATEMENT_SS;
    public static NodeTypeSet DECLARATION_STATEMENT_SS;
    public static NodeTypeSet EXPRESSION_STATEMENT_SS;
    public static NodeTypeSet LABELED_STATEMENT_SS;
    public static NodeTypeSet CASE_STATEMENT_SS;
    public static NodeTypeSet DEFAULT_STATEMENT_SS;
    public static NodeTypeSet IF_STATEMENT_SS;
    public static NodeTypeSet WHILE_STATEMENT_SS;
    public static NodeTypeSet DO_STATEMENT_SS;
    public static NodeTypeSet DO_STATEMENT_BODY_SS;
    public static NodeTypeSet SWITCH_STATEMENT_SS;
    public static NodeTypeSet FOR_STATEMENT_SS;
    public static NodeTypeSet RANGE_BASED_FOR_STATEMENT_SS;
    public static NodeTypeSet RANGE_BASED_CO_AWAIT_FOR_STATEMENT_SS;
    public static NodeTypeSet MS_FOREACH_STATEMENT_SS;
    public static NodeTypeSet GOTO_STATEMENT_SS;
    public static NodeTypeSet CONTINUE_STATEMENT_SS;
    public static NodeTypeSet BREAK_STATEMENT_SS;
    public static NodeTypeSet DISCARD_STATEMENT_SS;
    public static NodeTypeSet RETURN_STATEMENT_SS;
    public static NodeTypeSet CO_RETURN_STATEMENT_SS;
    public static NodeTypeSet MS_LEAVE_STATEMENT_SS;
    public static NodeTypeSet TRY_STATEMENT_SS;
    public static NodeTypeSet CATCH_SECTION_SS;
    public static NodeTypeSet MS_IF_EXISTS_TOP_LEVEL_SS;
    public static NodeTypeSet MS_IF_EXISTS_CLASS_MEMBER_SS;
    public static NodeTypeSet MS_IF_EXISTS_STATEMENT_SS;
    public static NodeTypeSet MS_IF_EXISTS_EXPRESSION_SS;
    public static NodeTypeSet MS_IF_EXISTS_ARGUMENT_CLAUSE_SS;
    public static NodeTypeSet MS_IF_EXISTS_BLOCK_BRACES_SS;
    public static NodeTypeSet ASM_DEFINITION_SS;
    public static NodeTypeSet EMPTY_EXPRESSION_SS;
    public static NodeTypeSet LITERAL_EXPRESSION_SS;
    public static NodeTypeSet USER_DEFINED_LITERAL_EXPRESSION_SS;
    public static NodeTypeSet THIS_EXPRESSION_SS;
    public static NodeTypeSet CAST_EXPRESSION_SS;
    public static NodeTypeSet TYPEID_EXPRESSION_SS;
    public static NodeTypeSet PAREN_EXPRESSION_SS;
    public static NodeTypeSet SIZEOF_EXPRESSION_SS;
    public static NodeTypeSet SIZEOF_ELLIPSIS_EXPRESSION_SS;
    public static NodeTypeSet ALIGNOF_EXPRESSION_SS;
    public static NodeTypeSet NOEXCEPT_EXPRESSION_SS;
    public static NodeTypeSet THROW_EXPRESSION_SS;
    public static NodeTypeSet UNARY_EXPRESSION_SS;
    public static NodeTypeSet POSTFIX_EXPRESSION_SS;
    public static NodeTypeSet BINARY_EXPRESSION_SS;
    public static NodeTypeSet FOLD_EXPRESSION_SS;
    public static NodeTypeSet CONDITIONAL_EXPRESSION_SS;
    public static NodeTypeSet MEMBER_ACCESS_EXPRESSION_SS;
    public static NodeTypeSet SUBSCRIPT_EXPRESSION_SS;
    public static NodeTypeSet CALL_EXPRESSION_SS;
    public static NodeTypeSet BRACE_INITIALIZED_TEMPORARY_SS;
    public static NodeTypeSet MS_NOOP_EXPRESSION_SS;
    public static NodeTypeSet MS_ASSUME_EXPRESSION_SS;
    public static NodeTypeSet COMPOUND_STATEMENT_EXPRESSION_SS;
    public static NodeTypeSet PACK_EXPANSION_EXPRESSION_SS;
    public static NodeTypeSet LAMBDA_EXPRESSION_SS;
    public static NodeTypeSet LAMBDA_INTRODUCER_SS;
    public static NodeTypeSet LAMBDA_CAPTURE_SS;
    public static NodeTypeSet LAMBDA_CAPTURE_NAME_SS;
    public static NodeTypeSet LAMBDA_DECLARATOR_SS;
    public static NodeTypeSet REQUIRES_CLAUSE_SS;
    public static NodeTypeSet REQUIRES_EXPRESSION_SS;
    public static NodeTypeSet REQUIRES_EXPRESSION_BODY_SS;
    public static NodeTypeSet REQUIRES_EXPRESSION_ITEM_SS;
    public static NodeTypeSet CLI_MULTI_ARGUMENT_SUBSCRIPT_EXPRESSION_SS;
    public static NodeTypeSet CLI_TYPEID_EXPRESSION_SS;
    public static NodeTypeSet CPP_NEW_EXPRESSION_SS;
    public static NodeTypeSet CPP_DELETE_EXPRESSION_SS;
    public static NodeTypeSet C11_GENERIC_EXPRESSION_SS;
    public static NodeTypeSet C11_GENERIC_EXPRESSION_CLAUSE_SS;
    public static NodeTypeSet ALIGNMENT_SPECIFIER_SS;
    public static NodeTypeSet ATTRIBUTE_LIST_SS;
    public static NodeTypeSet GNU_STYLE_ATTRIBUTE_LIST_SS;
    public static NodeTypeSet MS_DECL_SPEC_SS;
    public static NodeTypeSet MS_ATTRIBUTES_SS;
    public static NodeTypeSet SINGLE_ARGUMENT_TYPE_TRAIT_EXPRESSION_SS;
    public static NodeTypeSet DOUBLE_ARGUMENT_TYPE_TRAIT_EXPRESSION_SS;
    public static NodeTypeSet MULTI_ARGUMENT_TYPE_TRAIT_EXPRESSION_SS;
    public static NodeTypeSet MS_UUIDOF_EXPRESSION_SS;
    public static NodeTypeSet MS_EVENT_HOOK_EXPRESSION_SS;
    public static NodeTypeSet MS_ASM_DEFINITION_SS;
    public static NodeTypeSet MS_ASM_COMMENT_SS;
    public static NodeTypeSet GNU_ASM_DEFINITION_SS;
    public static NodeTypeSet GNU_ASM_OPERAND_LIST_SS;
    public static NodeTypeSet GNU_ASM_CLOBBERS_LIST_SS;
    public static NodeTypeSet GNU_ASM_GOTO_LABELS_LIST_SS;
    public static NodeTypeSet MS_LPREFIXED_LITERAL_SS;
    public static NodeTypeSet BUILTIN_ADDRESSOF_EXPRESSION_SS;
    public static NodeTypeSet BUILTIN_OFFSETOF_EXPRESSION_SS;
    public static NodeTypeSet GNU_BUILTIN_CONSTANT_P_EXPRESSION_SS;
    public static NodeTypeSet GNU_BUILTIN_CHOOSE_EXPR_EXPRESSION_SS;
    public static NodeTypeSet OFFSETOF_MEMBER_REFERENCE_DESIGNATOR_SS;
    public static NodeTypeSet PRAGMA_DIRECTIVE_SS;
    public static NodeTypeSet UNPARSED_TEXT_SS;
    public static NodeTypeSet CO_YIELD_EXPRESSION_SS;
    public static NodeTypeSet CO_AWAIT_EXPRESSION_SS;
    public static NodeTypeSet DOXYGEN_COMMENT_SS;
    public static NodeTypeSet DOXYGEN_COMMENT_PREFIX_SS;
    public static NodeTypeSet DOXYGEN_COMMENT_BODY_SS;
    public static NodeTypeSet DOXYGEN_COMMAND_SS;
    public static NodeTypeSet DOXYGEN_PAIRED_COMMAND_SS;
    public static NodeTypeSet DOXYGEN_PAIRED_COMMAND_BODY_SS;
    public static NodeTypeSet DOXYGEN_CMD_SS;
    public static NodeTypeSet DOXYGEN_WORD_SS;
    public static NodeTypeSet DOXYGEN_QUOTED_STRING_SS;
    public static NodeTypeSet DOXYGEN_LINE_SS;
    public static NodeTypeSet DOXYGEN_PARAGRAPH_SS;
    public static NodeTypeSet DOXYGEN_PARAM_REF_SS;
    public static NodeTypeSet DOXYGEN_TPARAM_REF_SS;
    public static NodeTypeSet DOXYGEN_FILE_REF_SS;
    public static NodeTypeSet DOXYGEN_BRACKETED_LIST_SS;
    public static NodeTypeSet DOXYGEN_QUALIFIED_REFERENCE_SS;
    public static NodeTypeSet DOXYGEN_NAME_QUALIFIER_SS;
    public static NodeTypeSet DOXYGEN_DECLARATION_SS;
    public static NodeTypeSet DOXYGEN_DECLARATOR_SS;
    public static NodeTypeSet DOXYGEN_DECLARATION_SPECIFIERS_SS;
    public static NodeTypeSet DOXYGEN_DECLARATION_SPECIFIER_TYPENAME_SS;
    public static NodeTypeSet DOXYGEN_DECLARATOR_QUALIFIED_NAME_SS;
    public static NodeTypeSet DOXYGEN_PARAMETERS_AND_QUALIFIERS_SS;
    public static NodeTypeSet DOXYGEN_HTML_TAG_SS;
    public static NodeTypeSet DOXYGEN_HTML_ATTRIBUTE_SS;
    public static NodeTypeSet DOXYGEN_HTML_PAIRED_COMMAND_SS;
    public static NodeTypeSet DOXYGEN_HTML_PAIRED_COMMAND_BODY_SS;
    public static NodeTypeSet DOXYGEN_LIST_SS;
    public static NodeTypeSet DOXYGEN_LIST_ITEM_SS;
    public static NodeTypeSet DOXYGEN_LIST_ITEM_MARKER_SS;
    public static NodeTypeSet DOXYGEN_LIST_ITEM_BODY_SS;
    public static NodeTypeSet UE4_GENERATED_BODY_SS;
    public static NodeTypeSet UE4_METADATA_SS;
    public static NodeTypeSet UE4_METADATA_SPECIFIER_SS;
    public static NodeTypeSet UE4_METADATA_SPECIFIER_KEY_SS;
    public static NodeTypeSet UE4_METADATA_SPECIFIER_VALUE_SS;
    public static NodeTypeSet HLSL_VECTOR_TYPE_SPECIFIER_SS;
    public static NodeTypeSet HLSL_MATRIX_TYPE_SPECIFIER_SS;
    public static NodeTypeSet HLSL_BUFFER_TYPE_SPECIFIER_SS;
    public static NodeTypeSet HLSL_TRAILING_SEMANTIC_SS;
    public static NodeTypeSet HLSL_TRAILING_REGISTER_SS;
    public static NodeTypeSet HLSL_TRAILING_PACKOFFSET_SS;
    public static NodeTypeSet HLSL_SHADER_CONSTANTS_BUFFER_SS;
    public static NodeTypeSet HLSL_ATTRIBUTES_SS;
    public static NodeTypeSet ALL_LITERAL_EXPRESSIONS;
    public static NodeTypeSet EXPRESSIONS;
    public static NodeTypeSet EXPRESSIONS_ARGUMENT_LISTS;
    public static NodeTypeSet ARGUMENT_LISTS;
    public static NodeTypeSet EXPRESSIONS_OR_TYPE_ID;
    public static NodeTypeSet EXPRESSIONS_OR_DECLARATION;
    public static NodeTypeSet ALL_FOR_STATEMENTS;
    public static NodeTypeSet STATEMENTS;
    public static NodeTypeSet CONTINUABLE_STATEMENTS;
    public static NodeTypeSet BREAKABLE_STATEMENTS;
    public static NodeTypeSet SYMBOLS_WITH_USERDATA;
    public static NodeTypeSet PP_DIRECTIVES;
    public static NodeTypeSet CLASS_SPECIFIERS;
    public static NodeTypeSet NESTED_DECLARATIONS;
    public static NodeTypeSet TOPLEVEL_DECLARATIONS;
    public static NodeTypeSet TEMPLATE_PARAMETERS;
    public static NodeTypeSet IDENTIFIERS;
    public static NodeTypeSet TYPENAME_SPECIFIERS;
    public static NodeTypeSet TYPENAME_OR_STRUCT_SPECIFIERS;
    public static NodeTypeSet DOXYGEN_COMMENTS;
    public static NodeTypeSet UE4_ITEMS;
    public static NodeTypeSet PHANTOM_NODES;
    public static NodeTypeSet DECLARATION_TRAILING_NODES;
    public static NodeTypeSet NAME_PARTS;
    public static NodeTypeSet NAME_PARTS_NAV;
    public static NodeTypeSet DESIGNATORS;
    public static NodeTypeSet DECLARATION_SPECIFIERS_TYPE_NODES;
    public static NodeTypeSet DECLARATION_SPECIFIERS_TYPE_AND_CV_NODES;
    public static NodeTypeSet DECLARATION_SPECIFIERS_CHILDREN_EXCEPT_TYPE_AND_CV_NODES;
    public static NodeTypeSet DECLARATION_SPECIFIERS_NODE_CHILDREN;
    public static NodeTypeSet DECLARATOR_PREFIX_NODES;
    public static NodeTypeSet DECLARATOR_SUFFIX_NODES;
    public static NodeTypeSet EXCEPTION_SPECIFICATIONS;
    public static NodeTypeSet UDL_LITERALS;
    public static NodeTypeSet GENERIC_CONSTRAINT_ITEMS;
    public static NodeTypeSet ASM_DEFINITIONS;
    public static NodeTypeSet LABEL_LIKE_STATEMENTS;
    private static CppCompositeNodeTypes();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppDirectiveTokenNodeType : CppGenericTokenNodeType {
    public CppDirectiveTokenNodeType(string s, CppTokenKind kind, string text);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppDoxygenCommentTokenNode : CppGenericTokenNode {
    public CppDoxygenCommentTokenNode(CppDoxygenCommentTokenNodeType type, string text);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppDoxygenCommentTokenNodeType : CppGenericTokenNodeType {
    public CppDoxygenCommentTokenNodeType(string s, CppTokenKind kind, string repr);
    public virtual LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppDoxygenParser : object {
    private IPsiSourceFile mySourceFile;
    private ILexer myLexer;
    private IPsiModule myModule;
    public CppDoxygenParser(IPsiSourceFile sourceFile, ILexer lexer, IPsiModule module);
    public sealed virtual IFile ParseFile();
    public static bool IsDoxygen(IBuffer buffer);
    public static CppDoxygenCommentNode Parse(ILexer lexer, ISolution solution);
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.CppDoxygenParsing : CppParsingWithTraits`2<CppDoxygenParsingTraits, MarkerGuard`1<CppDoxygenParsingTraits>> {
    public CppDoxygenParsing(CppPsiBuilder psiBuilder);
    private void AdvanceLexer();
    public CppDoxygenCommentNode ParseDoxygen();
    private bool TryParseDoxygenNonSectioningCommand(FrugalLocalList`1& openCommands);
    private string ParseDoxygenCommandName(string stopperCommandName);
    private void ParseDoxygenCommandBody(string commandName, FrugalLocalList`1& openCommands);
    private void ParseDoxygenWord(ArgRefType refType);
    private void ParseDoxygenQuotedString();
    private void ParseDoxygenLine(FrugalLocalList`1& openCommands);
    private void ParseDoxygenParagraph(FrugalLocalList`1& openCommands);
    private void ParseDoxygenCommaSeparatedList(ArgRefType refType);
    private void ParseDoxygenBracketedCommaSeparatedList(ArgRefType refType);
    private void ParseDoxygenBracedWord(ArgRefType refType);
    private ParseHtmlTagResult TryParseHtmlTag();
    private bool TryParseHtmlAttribute();
    private void ParseHtmlPairedCommandBody(string name, FrugalLocalList`1& openCommands);
    private void ParseDoxygenList(int indent, FrugalLocalList`1& openCommands);
    private void ParseDoxygenListItem(int indent, FrugalLocalList`1& openCommands);
    private void ParseDoxygenListItemMarker();
    private bool TryParseDoxygenSimpleList(FrugalLocalList`1& openCommands);
    private void ParseDoxygenNameQualifier();
    private void ParseDoxygenQualifiedReference(ArgRefType refType);
    private void DoxygenWarning(string message);
    private void AdvanceToEnd(FrugalLocalList`1& openCommands, int skipNewLineCount);
    internal void SkipDoxygenWs(int skipNewLineCount);
    private int EatNewlineAndIndent(int newLineCount);
    private bool IsBreakingDoxygenCommand(string name, FrugalLocalList`1& openCommands);
    private CppCompositeNodeType DoxygenNodeTypeOrDefault(ArgRefType refType, CppCompositeNodeType defaultNodeType);
    private bool IsDoxygenWordPart(TokenNodeType token);
    private bool IsDoxygenPrefix(TokenNodeType token);
    private bool IsDoxygenCommandPrefix(TokenNodeType token);
    private bool IsListMarker();
    private bool IsSimpleTypeSpecifier(TokenNodeType token);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.CppDoxygenParsingTraits : ValueType {
    private CppPsiBuilder myPsiBuilder;
    [CompilerGeneratedAttribute]
private CppDoxygenParsing <Parser>k__BackingField;
    public CppDoxygenParsing Parser { get; }
    public CppDoxygenParsingTraits(CppDoxygenParsing parser, CppPsiBuilder psiBuilder);
    [CompilerGeneratedAttribute]
public CppDoxygenParsing get_Parser();
    public sealed virtual MarkerGuard`1<CppDoxygenParsingTraits> CreateMarkerGuard(LightweightRollbackT _);
    public sealed virtual MarkerGuard`1<CppDoxygenParsingTraits> CreateMarkerGuard(RollbackT _);
    public sealed virtual MarkerGuard`1<CppDoxygenParsingTraits> CreateMarkerGuard(DropT _);
    public sealed virtual MarkerGuard`1<CppDoxygenParsingTraits> CreateMarkerGuard(NodeType type, bool beforeWs, bool allowEmpty, object userData);
    public sealed virtual MarkerGuard`1<CppDoxygenParsingTraits> CreateMarkerGuard(PrecedeCurrentT _, RollbackT __);
    public sealed virtual MarkerGuard`1<CppDoxygenParsingTraits> CreateMarkerGuard(PrecedeCurrentT _, DropT __);
    public sealed virtual MarkerGuard`1<CppDoxygenParsingTraits> CreateMarkerGuard(PrecedeCurrentT _, NodeType type, bool beforeWs, bool allowEmpty);
    public CppDoxygenCommentNode BuildTree();
    public sealed virtual void AdvanceLexer();
    public sealed virtual void BaseAdvance();
    public sealed virtual void Advance();
    public sealed virtual void ResetTokenCursor();
    public sealed virtual bool IsEmpty(int arg);
    public sealed virtual void Done(int arg0, NodeType arg1, object arg2);
    public sealed virtual void DoneBeforeWhitespaces(int arg0, NodeType arg1, object arg2);
    public sealed virtual void RollbackTo(int arg);
    public sealed virtual void Drop(int arg);
    public sealed virtual void RawAlter(TokenNodeType tokenType, int count);
    public sealed virtual void FetchAll();
    public sealed virtual void Error(string message);
    public sealed virtual void ErrorBeforeWhitespaces(string message);
    public sealed virtual void Error(int mark, string message);
    public sealed virtual int Mark();
    public sealed virtual int PrecedeCurrent();
    public sealed virtual int GetCurrentNonCommentLexeme();
    public sealed virtual void ResetCurrentLexeme(int current, int currentNc);
    public sealed virtual int RawCurrentLexeme();
    public sealed virtual int BaseCurrentLexeme();
    public sealed virtual int CurrentLexeme();
    public sealed virtual bool HasNewLineBefore(int pos);
    public sealed virtual void SkipWs();
    public sealed virtual void SkipDirectives(bool stopByMacroCalls);
    public sealed virtual void SkipNonMeaningful();
    public sealed virtual TokenNodeType RawTt(bool unwrap);
    public sealed virtual TokenNodeType BaseTt(bool unwrap);
    public sealed virtual TokenNodeType Tt(bool unwrap);
    public sealed virtual string GetTokenText(int index);
    public sealed virtual string RawTokenText();
    public sealed virtual string BaseTokenText();
    public sealed virtual string TokenText();
    public sealed virtual CppComplexOffset RawNavigationOffset();
    public sealed virtual CppComplexOffset BaseNavigationOffset();
    public sealed virtual CppComplexOffset NavigationOffset();
    public sealed virtual void BaseResync();
    public sealed virtual void Resync();
    public sealed virtual void EnablePreprocessor2Detection(bool val);
    public sealed virtual void AddUdlNameToWordIndex(string name);
    public sealed virtual TokenNodeType TryUnwrap(TokenNodeType tt);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppEmulatedParserCrashException : Exception {
    public string Message { get; }
    public virtual string get_Message();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppExpandDisabledNodeType : CppTokenNodeType {
    public TokenNodeType myDelegate;
    public TokenNodeType Delegate { get; }
    public string TokenRepresentation { get; }
    public bool IsWhitespace { get; }
    public bool IsComment { get; }
    public CppExpandDisabledNodeType(TokenNodeType _delegate);
    public TokenNodeType get_Delegate();
    public virtual string get_TokenRepresentation();
    public virtual bool get_IsWhitespace();
    public virtual bool get_IsComment();
    public virtual LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppExpressionParser : object {
    private ISolution mySolution;
    private IPsiServices myPsiServices;
    private IDocument myDocument;
    public CppExpressionParser(ISolution solution, IDocument document);
    public sealed virtual IFile ParseFile();
    private ICppStatement CreateStatementInContext(IFile file, int offset, string text);
    private IFile GetContextFile(VirtualFileSystemPath path);
    private static ValueTuple`2<VirtualFileSystemPath, int> ExtractContextPosition(IBuffer buffer);
    private static void ParseBeginningOfComment(IBuffer buffer, Int32& pos, int end);
    private static VirtualFileSystemPath ExtractFilename(CppLexer lexer);
    private static int ExtractFileOffset(ILexer lexer);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppExtractModuleNameResult : ValueType {
    public StatusType Status;
    public bool Exported;
    public string ModuleName;
    public string PartitionName;
    public static CppExtractModuleNameResult BuildFor(string buffer);
    public static string TryParseModuleName(string name);
    public static bool IsModuleName(string name);
    public static string TryParseModulePartitionName(string name);
    public static bool IsModulePartitionName(string name);
    private static string ParseName(CppInnerLexer& contentLexer);
    private static void SkipWs(CppInnerLexer& contentLexer);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Parsing.CppForeignTokenNode : CppTokenNodeBase {
    protected CppWrapperTokenNodeType myType;
    public NodeType NodeType { get; }
    public CppWrapperTokenNodeType ForeignNodeType { get; }
    protected CppForeignTokenNode(CppWrapperTokenNodeType type);
    public virtual NodeType get_NodeType();
    private static TokenNodeType DropExpandDisabled(TokenNodeType tokenNodeType);
    public CppWrapperTokenNodeType get_ForeignNodeType();
    public virtual int GetTextLength();
    public virtual string GetText();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppFromIncludingTokenNode : CppForeignTokenNode {
    public CppFromIncludingTokenNodeType ForeignNodeType { get; }
    public CppFromIncludingTokenNode(CppFromIncludingTokenNodeType type);
    public CppFromIncludingTokenNodeType get_ForeignNodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppFromIncludingTokenNodeType : CppWrapperTokenNodeTypeWithText {
    public CppFromIncludingTokenNodeType(TokenNodeType _delegate, string tokenText, int offsetInSubstitution);
    public virtual LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
    public virtual string ToString();
    public virtual TokenNodeType CloneWithNewTokenType(TokenNodeType newTerminal, string text);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppFromMacroArgumentExpansionTokenNodeType : CppWrapperTokenNodeType {
    [CompilerGeneratedAttribute]
private bool <VariableArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private PPPhase <ExpansionPhase>k__BackingField;
    public bool VariableArgument { get; public set; }
    public PPPhase ExpansionPhase { get; public set; }
    public CppFromMacroArgumentExpansionTokenNodeType(TokenNodeType _delegate, short macroLevel, bool vaarg);
    public CppFromMacroArgumentExpansionTokenNodeType(TokenNodeType _delegate, short macroLevel, bool vaarg, PPPhase expansionPhase);
    [CompilerGeneratedAttribute]
public bool get_VariableArgument();
    [CompilerGeneratedAttribute]
public void set_VariableArgument(bool value);
    [CompilerGeneratedAttribute]
public PPPhase get_ExpansionPhase();
    [CompilerGeneratedAttribute]
public void set_ExpansionPhase(PPPhase value);
    public virtual TokenNodeType CloneWithNewTokenType(TokenNodeType newTerminal, string text);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppFromMacroCallTokenType : CppWrapperTokenNodeType {
    [CompilerGeneratedAttribute]
private bool <ExpandedOnPrescan>k__BackingField;
    [CompilerGeneratedAttribute]
private CppPPDefineSymbol <SpawnedMacroReference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStripped>k__BackingField;
    public bool IsParam { get; }
    public bool IsRoot { get; }
    public bool ExpandedOnPrescan { get; public set; }
    public CppPPDefineSymbol SpawnedMacroReference { get; public set; }
    public bool IsStripped { get; public set; }
    public CppFromMacroCallTokenType(TokenNodeType _delegate, short macroLevel);
    public CppFromMacroCallTokenType(TokenNodeType _delegate, short macroLevel, bool expandedOnPrescan, bool stripped, CppPPDefineSymbol spawnedMacroReference);
    public virtual bool get_IsParam();
    public virtual bool get_IsRoot();
    [CompilerGeneratedAttribute]
public bool get_ExpandedOnPrescan();
    [CompilerGeneratedAttribute]
public void set_ExpandedOnPrescan(bool value);
    [CompilerGeneratedAttribute]
public CppPPDefineSymbol get_SpawnedMacroReference();
    [CompilerGeneratedAttribute]
public void set_SpawnedMacroReference(CppPPDefineSymbol value);
    [CompilerGeneratedAttribute]
public bool get_IsStripped();
    [CompilerGeneratedAttribute]
public void set_IsStripped(bool value);
    public virtual LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
    public virtual string ToString();
    public virtual TokenNodeType CloneWithNewTokenType(TokenNodeType newTerminal, string text);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppFromMacroReferenceTokenType : CppFromMacroCallTokenType {
    [CompilerGeneratedAttribute]
private CppPPDefineSymbol <MacroSymbol>k__BackingField;
    public CppPPDefineSymbol MacroSymbol { get; }
    public bool IsParam { get; }
    public bool IsRoot { get; }
    public CppFromMacroReferenceTokenType(TokenNodeType _delegate, CppPPDefineSymbol macro, short macroLevel);
    [CompilerGeneratedAttribute]
public CppPPDefineSymbol get_MacroSymbol();
    public virtual bool get_IsParam();
    public virtual bool get_IsRoot();
    public virtual TokenNodeType CloneWithNewTokenType(TokenNodeType newTerminal, string text);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppFromSubstitutionTokenNode : CppForeignTokenNode {
    private static ITokenNode Uninitialized;
    private ITokenNode myPrototypeMacroArgumentCache;
    public CppFromSubstitutionTokenNodeType ForeignNodeType { get; }
    private static CppFromSubstitutionTokenNode();
    public CppFromSubstitutionTokenNode(CppFromSubstitutionTokenNodeType type);
    protected virtual TreeElement DeepClone(TreeNodeCopyContext context);
    public CppFromSubstitutionTokenNodeType get_ForeignNodeType();
    public ITokenNode FindPrototypeMacroArgumentToken();
    public MacroCall FindDirectPrototypeMacro();
    public MacroCall FindDirectPrototypeMacro(bool allowNull);
    public static bool DelegateFromMacroCall(CppFromSubstitutionTokenNode token);
    public MacroCall FindPrototypeMacro();
    public MacroCall FindPrototypeMacro(bool allowNull);
    public void ClearCache();
    private ITokenNode FindPrototypeMacroArgumentTokenWithoutCache();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppFromSubstitutionTokenNodeType : CppWrapperTokenNodeTypeWithText {
    private MacroArgumentInfo myMacroArgumentInfo;
    public short ArgumentIndex { get; public set; }
    public short ArgumentTokenIndex { get; public set; }
    public short ArgumentMacroLevel { get; }
    public MacroArgumentInfo ArgumentInfo { get; public set; }
    public CppFromSubstitutionTokenNodeType(TokenNodeType _delegate, string tokenText, MacroArgumentInfo argumentInfo, int offsetInSubstitution, short macroLevel);
    public short get_ArgumentIndex();
    public void set_ArgumentIndex(short value);
    public short get_ArgumentTokenIndex();
    public void set_ArgumentTokenIndex(short value);
    public short get_ArgumentMacroLevel();
    public MacroArgumentInfo get_ArgumentInfo();
    public void set_ArgumentInfo(MacroArgumentInfo value);
    public void Init(TokenNodeType _delegate, string tokenText, MacroArgumentInfo argumentInfo, int offsetInSubstitution, short macroLevel);
    public virtual LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
    public virtual string ToString();
    public CppFromSubstitutionTokenNodeType ShallowClone();
    public virtual TokenNodeType CloneWithNewTokenType(TokenNodeType newTerminal, string text);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppGenericKeywordTokenNode : CppGenericTokenNode {
    public CppGenericKeywordTokenNode(CppGenericTokenNodeType nodeType);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppGenericTokenNode : CppTokenNodeBase {
    private string myText;
    private CppGenericTokenNodeType myType;
    public NodeType NodeType { get; }
    public CppGenericTokenNode(CppGenericTokenNodeType type, string text);
    public virtual NodeType get_NodeType();
    public virtual string ToString();
    public virtual string GetText();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppGenericTokenNodeType : CppTokenNodeType {
    [CompilerGeneratedAttribute]
private string <TokenRepresentation>k__BackingField;
    public string TokenRepresentation { get; }
    public CppGenericTokenNodeType(string s, CppTokenKind kind, string repr);
    [CompilerGeneratedAttribute]
public virtual string get_TokenRepresentation();
    public virtual LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppHashedIdentifierTokenNode : CppTokenNodeBase {
    private string myText;
    public NodeType NodeType { get; }
    public string Name { get; }
    public CppHashedIdentifierTokenNode(string text);
    public virtual NodeType get_NodeType();
    public virtual string GetText();
    public sealed virtual string get_Name();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppIdentifierTokenNode : CppTokenNodeBase {
    private string myText;
    public NodeType NodeType { get; }
    public string Name { get; }
    internal CppIdentifierTokenNode(string text);
    public virtual NodeType get_NodeType();
    public virtual string GetText();
    public sealed virtual string get_Name();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppInnerLexer : ValueType {
    private static UInt32 FNV1A_OFFSET;
    private static UInt32 FNV1A_PRIME;
    private static UInt32 FNV1A_IMPORT;
    private static UInt32 FNV1A_MODULE;
    private static UInt32 FNV1A_EXPORT;
    private int myCurrentLine;
    private CppTokenKind myCurrentToken;
    private CppLexerDirectiveState myCurrentState;
    private bool myDoxygenMode;
    private bool myAtStartOfLine;
    public int TokenStart;
    public int TokenEnd;
    public int EOFPos;
    public string Buffer;
    [CompilerGeneratedAttribute]
private bool <LexDirectives>k__BackingField;
    public CppTokenKind TokenType { get; }
    public int Line { get; public set; }
    public UInt32 LexerStateEx { get; }
    public TokenPosition CurrentPosition { get; public set; }
    public bool LexDirectives { get; public set; }
    public CppInnerLexer(string buffer);
    public void Start();
    public void Start(int startOffset, int endOffset);
    public void Start(int startOffset, int endOffset, UInt32 state);
    public void Advance();
    public CppTokenKind get_TokenType();
    public int get_Line();
    public void set_Line(int value);
    public UInt32 get_LexerStateEx();
    public TokenPosition get_CurrentPosition();
    public void set_CurrentPosition(TokenPosition value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_LexDirectives();
    [CompilerGeneratedAttribute]
public void set_LexDirectives(bool value);
    public void SetDoxygenMode();
    public static bool CompareBufferText(string buffer, TextRange range, string str);
    private static bool CompareBufferText(string buffer, int startOffset, int length, string str);
    private static bool CompareBufferText(string buffer, int startOffset, string str);
    private void LocateToken();
    private TokenNextStep ContinueIdentifier(char firstChar);
    private TokenNextStep ContinueNumericLiteral();
    private TokenNextStep ContinueStringLiteral();
    private TokenNextStep ContinueCharLiteral();
    private static bool IS_ALPHA(char val);
    private static bool IS_DIGIT(char val);
    private static bool IN_RANGE(char val, char low, char high);
    private bool IsIdentifierHead(char c);
    private static bool IsIdentifierTrail(char c);
    private static bool IsNumeralTrail(char c);
    private static bool IsWhitespace(char c);
    private static bool IsNewLineStart(char c);
    private bool IsLastToken(string directiveName);
    private StringPrefixType ClassifyStringPrefix();
    private bool IsValidCharLiteralPrefix();
    private void SkipWs(Char& c);
    private void SkipDirectiveBody();
    private void SkipMultilineComment();
    private void SkipSingleLineComment();
    private void SkipLFIfPresent();
    private bool TryLexNewLineEscape();
    private void LexRawStringLiteral();
    private bool IsDoxygenSingleLineComment(bool onlyPostComment);
    private void SkipDoxygenSingleLineComment();
    private bool IsSingleCharNewLine(char c);
    private DoxygenLineContinuatorType SkipDoxygenNewLineContinuatorIfPresent();
    private Nullable`1<DoxygenLineContinuatorType> TrySkipDoxygenNewLineContinuator();
    private static bool IsExtendedIdentifierChar(char c);
    private static bool IsDisallowedInitiallyExtendedIdentifierChar(char c);
    private bool IsCpp20ImportDirective();
    private bool IsCpp20ImportDirectiveNoRollback();
    private bool IsCpp20ModuleDirective();
    private bool IsCpp20ModuleDirectiveNoRollback();
    private ExportDirectiveType IsCpp20ExportDirective();
    private bool IsDoxygenCharLiteral();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppKeywordResolvingLexer : object {
    private CppLexer myLexer;
    private CppTokenNodeTypeTraits myTraits;
    private ReusableBufferRange myReusableBufferRange;
    private object JetBrains.ReSharper.Psi.Parsing.ILexer.CurrentPosition { get; private set; }
    public TokenNodeType TokenType { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public IBuffer Buffer { get; }
    public CppKeywordResolvingLexer(CppLexer lexer, CppLanguageDialect dialect);
    public sealed virtual void Start();
    public sealed virtual void Advance();
    private sealed virtual override object JetBrains.ReSharper.Psi.Parsing.ILexer.get_CurrentPosition();
    private sealed virtual override void JetBrains.ReSharper.Psi.Parsing.ILexer.set_CurrentPosition(object value);
    public sealed virtual TokenNodeType get_TokenType();
    public sealed virtual int get_TokenStart();
    public sealed virtual int get_TokenEnd();
    public sealed virtual IBuffer get_Buffer();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppKeywordTokenNodeType : CppSingletonTokenNodeType {
    public bool IsKeyword { get; }
    public CppKeywordTokenNodeType(string s, CppTokenKind kind, string text);
    public virtual bool get_IsKeyword();
    public virtual LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppLazyCachingLexer : object {
    private CppInnerLexer myInner;
    private IBuffer myBuffer;
    private IArrayOfTokens myCache;
    private TokenNodeType myCurrentTokenType;
    private int myCurrentTokenStart;
    private int myCurrentTokenEnd;
    private UInt32 myCurrentLexerState;
    private int myCurrentTokenIndex;
    private bool myCurrentTokenPropertiesCached;
    private object JetBrains.ReSharper.Psi.Parsing.ILexer.CurrentPosition { get; private set; }
    public int CurrentPosition { get; public set; }
    public TokenNodeType TokenType { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public IBuffer Buffer { get; }
    unknown bool LexDirectives {public set; }
    public int Line { get; }
    public UInt32 LexerStateEx { get; }
    public int EOFPos { get; }
    public TokenBuffer TokenBuffer { get; }
    public IArrayOfTokens ArrayOfTokens { get; }
    private CppLazyCachingLexer(IBuffer buffer, IArrayOfTokens tokenBuffer);
    private CppLazyCachingLexer(IBuffer buffer, IArrayOfTokens tokenBuffer, int startingFromLine);
    public sealed virtual void Start();
    public sealed virtual void Advance();
    public sealed virtual void SetPositionAndAdvance(int tokenNum);
    private sealed virtual override object JetBrains.ReSharper.Psi.Parsing.ILexer.get_CurrentPosition();
    private sealed virtual override void JetBrains.ReSharper.Psi.Parsing.ILexer.set_CurrentPosition(object value);
    public sealed virtual int get_CurrentPosition();
    public sealed virtual void set_CurrentPosition(int value);
    public sealed virtual TokenNodeType get_TokenType();
    public sealed virtual int get_TokenStart();
    public sealed virtual int get_TokenEnd();
    public sealed virtual IBuffer get_Buffer();
    public void set_LexDirectives(bool value);
    public sealed virtual int get_Line();
    public sealed virtual UInt32 get_LexerStateEx();
    public int get_EOFPos();
    public sealed virtual TokenBuffer get_TokenBuffer();
    public IArrayOfTokens get_ArrayOfTokens();
    public static CppLazyCachingLexer Create(IBuffer buffer, IArrayOfTokens tokenBuffer);
    public static CppLazyCachingLexer Create(IBuffer buffer, IArrayOfTokens tokenBuffer, int startingFromLine);
    private void AdvanceInner();
    private void Imbue();
    private void ResetState();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppLexer : object {
    private CppInnerLexer myInner;
    private IBuffer myBuffer;
    private object JetBrains.ReSharper.Psi.Parsing.ILexer.CurrentPosition { get; private set; }
    public TokenPosition CurrentPosition { get; public set; }
    public TokenNodeType TokenType { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public IBuffer Buffer { get; }
    unknown bool LexDirectives {public set; }
    public int Line { get; }
    public UInt32 LexerStateEx { get; }
    public int EOFPos { get; }
    public int LexemIndent { get; }
    private CppLexer(IBuffer buffer);
    public sealed virtual void Start();
    public void Start(int startOffset, int endOffset);
    public sealed virtual void Start(int startOffset, int endOffset, UInt32 state);
    public sealed virtual void Advance();
    private sealed virtual override object JetBrains.ReSharper.Psi.Parsing.ILexer.get_CurrentPosition();
    private sealed virtual override void JetBrains.ReSharper.Psi.Parsing.ILexer.set_CurrentPosition(object value);
    public sealed virtual TokenPosition get_CurrentPosition();
    public sealed virtual void set_CurrentPosition(TokenPosition value);
    public sealed virtual TokenNodeType get_TokenType();
    public sealed virtual int get_TokenStart();
    public sealed virtual int get_TokenEnd();
    public sealed virtual IBuffer get_Buffer();
    public void set_LexDirectives(bool value);
    public sealed virtual int get_Line();
    public sealed virtual UInt32 get_LexerStateEx();
    public sealed virtual int get_EOFPos();
    public sealed virtual int get_LexemIndent();
    public static CppLexer Create(IBuffer buffer);
    public static CppLexer Create(string s);
    public static CppLexer Create(CppDocumentBuffer docBuffer);
    public static CppLexer CreateDoxygenLexer(IBuffer buffer);
}
public enum JetBrains.ReSharper.Psi.Cpp.Parsing.CppLexerDirectiveState : Enum {
    public int value__;
    public static CppLexerDirectiveState NORMAL_STATE;
    public static CppLexerDirectiveState DIRECTIVE;
    public static CppLexerDirectiveState CODE_DIRECTIVE;
    public static CppLexerDirectiveState INCLUDE_DIRECTIVE;
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppLexerState : ValueType {
    private static int INNER_LEXER_LINE_LEN;
    private static int INNER_LEXER_AT_START_OF_LINE_LEN;
    private static int INNER_LEXER_STATE_LEN;
    private static int INNER_LEXER_LINE_OFFSET;
    private static int INNER_LEXER_AT_START_OF_LINE_OFFSET;
    private static int INNER_LEXER_STATE_OFFSET;
    private static int INNER_LEXER_LINE_MASK;
    private static int INNER_LEXER_AT_START_OF_LINE_MASK;
    private static int INNER_LEXER_STATE_MASK;
    public UInt32 Value;
    public CppLexerState(CppLexerDirectiveState directiveState, bool newLine, int line);
    public CppLexerDirectiveState GetDirectiveState();
    public bool GetAtStartOfLine();
    public int GetLine();
    private static UInt32 Pack(CppLexerDirectiveState directiveState, bool newLine, int line);
}
public static class JetBrains.ReSharper.Psi.Cpp.Parsing.CppLexerUtil : object {
    public static bool IsIdentifier(string str, CppLanguageDialect dialect);
    public static string ExtractIdentifierFromHashed(string hashed);
    public static TokenBuffer ResolveKeywordsInTokenBuffer(TokenBuffer tokenBuffer, CppLanguageDialect dialect);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppMacroArgumentTokenNodeType : CppWrapperTokenNodeType {
    [CompilerGeneratedAttribute]
private CppFromMacroCallTokenType <Ancestor>k__BackingField;
    [CompilerGeneratedAttribute]
private short <ArgumentIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private short <ArgumentTokenIndex>k__BackingField;
    public CppFromMacroCallTokenType Ancestor { get; public set; }
    public short ArgumentIndex { get; }
    public short ArgumentTokenIndex { get; }
    public CppMacroArgumentTokenNodeType(TokenNodeType _delegate, CppFromMacroCallTokenType ancestor, short macroLevel, short argumentIndex, short tokenIndex);
    [CompilerGeneratedAttribute]
public CppFromMacroCallTokenType get_Ancestor();
    [CompilerGeneratedAttribute]
public void set_Ancestor(CppFromMacroCallTokenType value);
    [CompilerGeneratedAttribute]
public short get_ArgumentIndex();
    [CompilerGeneratedAttribute]
public short get_ArgumentTokenIndex();
    public virtual TokenNodeType CloneWithNewTokenType(TokenNodeType newTerminal, string text);
}
public enum JetBrains.ReSharper.Psi.Cpp.Parsing.CppMinimalSeparator : Enum {
    public int value__;
    public static CppMinimalSeparator NOT_REQUIRED;
    public static CppMinimalSeparator SPACE;
    public static CppMinimalSeparator NEW_LINE;
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppMinimalSeparatorUtils : object {
    public static CppMinimalSeparator GetMinimalSeparator(TokenNodeType leftToken, TokenNodeType rightToken);
    private static bool TokensNeedSeparator(TokenNodeType leftToken, TokenNodeType rightToken);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppNodeTypeCounter : object {
    private static int ourTokenTypeCounter;
    private static CppNodeTypeCounter();
    public static int IncIndex();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppNonExpandingReferenceTokenType : CppWrapperTokenNodeType {
    [CompilerGeneratedAttribute]
private CppPPDefineSymbol <MacroSymbol>k__BackingField;
    public CppPPDefineSymbol MacroSymbol { get; }
    public CppNonExpandingReferenceTokenType(TokenNodeType _delegate, CppPPDefineSymbol macro, short macroLevel);
    [CompilerGeneratedAttribute]
public CppPPDefineSymbol get_MacroSymbol();
    public virtual LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
    public virtual string ToString();
    public virtual TokenNodeType CloneWithNewTokenType(TokenNodeType newTerminal, string text);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppParser : object {
    private static NodeTypeSet TOP_LEVEL_DECLARATION_SS;
    private CppCachingLexer myLexer;
    private CppInclusionContext myInclusionContext;
    private IPsiSourceFile mySourceFile;
    private CppFileLocation mySourceFileLocation;
    private CppSymbolTypeIntern myTypeIntern;
    private CppGlobalSymbolCache myGlobalCache;
    private IPsiModule myModule;
    public CppParser(CppSymbolTypeIntern intern, CppGlobalSymbolCache cache, IPsiSourceFile sourceFile, CppFileLocation sourceFileLocation, ILexer lexer, CppInclusionContext context, IPsiModule module);
    private static CppParser();
    public sealed virtual IFile ParseFile();
    public CppFile ParseCppFile(bool registerSymbolTable);
    public CppFile ParseCppFileForProfilingInfo();
    public CppFile ParseFileInTheAir();
    public CppUnparsedTextNode ParseUnparsedTextNode(IPsiModule module);
    public CppCodeFragment ParseTopLevelCodeFragmentInEmptyContext(IPsiModule module);
    public CppCodeFragment ParseTopLevelCodeFragment(IPsiModule module);
    public CppCodeFragment ParseTopLevelCodeFragment(IPsiModule module, ITreeNode pivot);
    public ICppExpressionNode ParseExpressionWithPreprocessing(ICppCompositeNode context);
    public ICppExpressionNode ParseExpressionWithoutPreprocessing(ICppCompositeNode context);
    public bool TryParseFunctionArgumentListWithoutPreprocessingInDetectionMode(ICppCompositeNode context);
    public ICppStatement ParseStatementWithoutPreprocessing(ITreeNode context);
    public ICppStatement ParseStatementWithPreprocessingInEmptyContext(ITreeNode pivot);
    public CppCodeFragment ParseCodeFragmentWithPreprocessing(ITreeNode pivot);
    public ICppStatement ParseStatementWithPreprocessing(ITreeNode pivot);
    public ICppTopLevelDeclarationNode ParseTopLevelDeclarationWithoutPreprocessing(ITreeNode context);
    public ICppTopLevelDeclarationNode ParseTopLevelDeclarationWithoutPreprocessingInEmptyContext(ITreeNode pivot);
    public ICppTopLevelDeclarationNode ParseTopLevelDeclarationWithPreprocessingInEmptyContext(ITreeNode pivot);
    public ICppTopLevelDeclarationNode ParseTopLevelDeclarationWithPreprocessing(ITreeNode pivot);
    public ICppTopLevelDeclarationNode ParseTopLevelDeclarationWithPreprocessing(ITreeNode pivot, CppViewPos& viewPos);
    public IPsiModule GetModule();
    private CppFile ParseFileDummyOrAfterCrash(bool dummy);
    private static CppCodeFragment ParseCodeFragmentFromPsiBuilderInContext(Action`2<CppParsing0, ICppScopeStatementBuilder> parseFunction, ITreeNode context, CppViewPos& originalView, CppPsiBuilder builder, List`1<ICppSymbol> preprocessorSymbols, Nullable`1<UInt32> pragmaPack);
    private static TTreeNode ParseSomethingFromPsiBuilderInContext(Action`2<CppParsing0, ICppScopeStatementBuilder> parseFunction, ITreeNode context, CppViewPos& originalView, CppPsiBuilder builder, List`1<ICppSymbol> preprocessorSymbols, Nullable`1<UInt32> pragmaPack, NodeTypeSet resultTypes);
    private ICppStatement ParseStatementWithPreprocessingInContext(CppInclusionContext context, ITreeNode pivot);
    private ICppTopLevelDeclarationNode ParseTopLevelDeclarationWithPreprocessingInContext(CppInclusionContext context, ITreeNode pivot);
    public ICppTopLevelDeclarationNode ParseTopLevelDeclarationWithPreprocessingInContext(CppInclusionContext context, ITreeNode pivot, CppViewPos& view);
    private CppCodeFragment ParseTopLevelCodeFragmentImpl(IPsiModule module, CppInclusionContext ctx);
    private CppCodeFragment ParseTopLevelCodeFragmentImpl(IPsiModule module, CppInclusionContext ctx, ITreeNode pivot);
    public TQualifiedReference ParseQualifiedReferenceWithoutPreprocessing(ICppCompositeNode context, NodeType nodeType);
    public static ICppPPValue EvaluatePreprocessorConditionalExpression(ILazyCachingLexer lexer);
    public static ICppPPValue EvaluatePreprocessorConditionalExpression(CppPreprocessor2 lexer);
    private static ICppCompositeNode ParseFunctionOrCtorBodyFromPsiBuilderInContext(FunctionBodyType bodyType, ICppCompositeNode context, CppViewPos& view, CppPsiBuilder builder, List`1<ICppSymbol> preprocessorSymbols, Nullable`1<UInt32> pragmaPack);
    public static ICppStatement ParseFunctionBodyFromPsiBuilderInContext(ICppCompositeNode context, CppViewPos& view, CppPsiBuilder builder, List`1<ICppSymbol> preprocessorSymbols, Nullable`1<UInt32> pragmaPack);
    public static CtorBlock ParseCtorBlockFromPsiBuilderInContext(ICppCompositeNode context, CppViewPos& view, CppPsiBuilder builder, List`1<ICppSymbol> preprocessorSymbols, Nullable`1<UInt32> pragmaPack);
    public static FunctionTryBlock ParseFunctionTryBlockFromPsiBuilderInContext(ICppCompositeNode context, CppViewPos& view, CppPsiBuilder builder, List`1<ICppSymbol> preprocessorSymbols, Nullable`1<UInt32> pragmaPack);
    public static ICppTopLevelDeclarationNode ParseTopLevelDeclarationFromPsiBuilderInContext(ITreeNode context, CppViewPos& view, CppPsiBuilder builder);
    public static ICppTopLevelDeclarationNode ParseTopLevelDeclarationFromPsiBuilderInContext(ITreeNode context, CppViewPos& view, CppPsiBuilder builder, CppPreprocessor preprocessor);
    public static Cpp20ImportHeaderUnitDirective ParseCpp20ImportHeaderUnitDirectiveFromPsiBuilderInContext(Cpp20ImportHeaderUnitDirective context, CppPsiBuilder builder, CppPreprocessor pp, CppFile file);
    public static Cpp20ImportModuleDirective ParseCpp20ImportModuleDirectiveFromPsiBuilderInContext(Cpp20ImportModuleDirective context, CppPsiBuilder builder, CppPreprocessor pp, CppFile file);
    public static MemInitializer ParseMemInitializer(MemInitializer context, CppPsiBuilder builder);
    private static ICppStatement ParseStatementFromPsiBuilderInContext(ITreeNode context, CppViewPos& view, CppPsiBuilder builder, List`1<ICppSymbol> preprocessorSymbols);
    public static void CheckSymbols(CppFile file);
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.CppParserBaseTokenSequence : ValueType {
    public sealed virtual TokenNodeType Tt(CppParsingBase`2<TTraits, TMarkerGuard> parsing);
    public sealed virtual void Advance(CppParsingBase`2<TTraits, TMarkerGuard> parsing);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppParserProfilingInfo : object {
    private int myStartLexeme;
    private int myLastLexeme;
    private CppParserProfilingInfoEntry[] myProfilingEntries;
    public CppParserProfilingInfo(int start, int count);
    public CppParserProfilingInfoEntry& Get(int i);
    public void Accommodate(int i);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppParserProfilingInfoEntry : ValueType {
    public int myNumberOfPasses;
    public Int32[] myDetectors;
    public List`1<string> myLookups;
    public void Pass();
    public void Detect(DetectorId id);
    public void Lookup(string lookup);
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.CppParserTokenSequence : ValueType {
    public sealed virtual TokenNodeType Tt(CppParsingBase`2<TTraits, TMarkerGuard> parsing);
    public sealed virtual void Advance(CppParsingBase`2<TTraits, TMarkerGuard> parsing);
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.CppParsing0 : CppParsingBase`2<CppPsiParsingTraits, MarkerGuard`1<CppPsiParsingTraits>> {
    private CppPsiBuilder myPsiBuilder;
    public CppParsing0(CppPsiBuilder psiBuilder, CppPreprocessor preprocessor, CppFileSymbolsCache cache, bool rememberPPUsagesInChameleons, bool collectProfilingInfo);
    public Range DeriveChameleonRange(int start, int end);
    public TreeElement CreateTree();
    public ILazyCachingLexer GetLexer();
    public CppFileSymbolsCache GetFileSymbolsCache();
    public virtual void ParseFunctionBody(ICppFunctionDeclaratorBuilder funcBuilder, int startLexeme, bool isConstructor, Nullable`1<UInt32> pragmaPack);
    public virtual void ParseFunctionBody(ICppFunctionDeclaratorBuilder funcBuilder, object payload);
    public virtual object CreateDeferredFunctionBodyParsingData(ICppFunctionDeclaratorBuilder builder, int startLexeme, bool isConstructor, Nullable`1<UInt32> pragmaPack);
    public virtual void ParseChameleon(CompositeNodeType chameleonType, TChameleonParser& parse, ICppFunctionDeclaratorBuilder funcBuilder);
    public virtual void LearnFunctionBodyChameleon(ICppFunctionDeclaratorBuilder funcBuilder);
    public virtual void LearnCtorBlockWithoutBody(ICppFunctionDeclaratorBuilder funcBuilder);
    public void ParseStatementFragment(ICppScopeStatementBuilder ssBuilder);
    public void ParseFunctionTryBlock(CppFunctionBodyBuilder csBuilder);
    public void ParseCtorBlock(CppFunctionBodyBuilder csBuilder);
    public void ParseBaseQualifiedReferenceFragment(TemplateArgumentListParseType templateArgumentListParseType, bool mayStartWithTemplateOrTilde, bool mayStartWithTypename, NodeType type, ICppBuilder context);
    private void ParseFunctionBody(ICppFunctionDeclaratorBuilder funcBuilder, CppChameleonStatementInfo info);
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.CppParsing1 : CppPreprocessor2ParsingBase {
    public CppParsing1(CppPreprocessor2 preprocessor, CppFileSymbolsCache cache, bool rememberPPUsagesInChameleons);
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.CppParsing2 : CppPSIFreeParsingBase {
    public CppParsing2(ILazyCachingLexer lexer, bool rememberPPUsagesInChameleons);
    public virtual bool IsCStyleCastNotExpression(bool greaterIsOperator);
}
internal abstract class JetBrains.ReSharper.Psi.Cpp.Parsing.CppParsingBase`2 : CppParsingWithTraits`2<TTraits, TMarkerGuard> {
    private static UInt32 CHECK_FOR_INTERRUPT_INTERVAL;
    private ICppPreprocessor myPreprocessor;
    private ICppFileSymbolsCache mySymBuilder;
    private CppLanguageDialect myLanguage;
    private ICppBuilder myCurrentBuilder;
    protected bool myChameleonMode;
    protected List`1<ICppSymbol> myPPSymbolInsideChameleon;
    protected bool myRememberPPUsagesInChameleons;
    private bool myDisableUnknownTokenError;
    private bool myDisableSyntaxDetectors;
    private CppParserProfilingInfo myProfilingInfo;
    private UInt32 myCheckForInterruptCount;
    private CppBuilderPool myBuilderPool;
    public CppExpressionParsing`9<TTraits, TMarkerGuard, CppTwinExpressionBuilder, CppTwinQualifiedNameBuilder, CppTwinDoubleArgumentTypeTraitExpressionBuilder, CppTwinMultiArgumentTypeTraitExpressionBuilder, CppTwinBuiltinOffsetOfBuilder, CppTwinFunctionArgumentListBuilder, CppTwinNewExpressionBuilder, CppTwinDesignatorBuilder, CppTwinC11GenericExpressionBuilder> TwinExpressionParsing;
    public CppExpressionParsing`9<TTraits, TMarkerGuard, CppExpressionBuilder, CppQualifiedNameBuilder, CppDoubleArgumentTypeTraitExpressionBuilder, CppMultiArgumentTypeTraitExpressionBuilder, CppBuiltinOffsetOfBuilder, CppFunctionArgumentListBuilder, CppNewExpressionBuilder, CppDesignatorBuilder, CppC11GenericExpressionBuilder> ExpressionParsing;
    public CppExpressionParsing`9<TTraits, TMarkerGuard, CppPPExpressionEvaluator, CppQualifiedNameBuilder, CppPPDoubleArgumentTypeTraitExpressionBuilder, CppPPMultiArgumentTypeTraitExpressionBuilder, CppPPBuiltinOffsetOfBuilder, CppPPFunctionArgumentListBuilder, CppPPNewExpressionBuilder, CppPPDesignatorBuilder, CppPPC11GenericExpressionBuilder> PPExpressionParsing;
    protected CppParsingBase`2(ICppPreprocessor preprocessor, ICppFileSymbolsCache cache, bool rememberPPUsagesInChameleons, bool collectProfilingInfo);
    public void EnterScope(CppScopeDescription desc);
    public void ExitScope();
    public bool RequiresNamed(DeclaratorParseType parseType);
    public bool AllowsNamed(DeclaratorParseType parseType);
    public bool DisallowsArray(DeclaratorParseType parseType);
    public bool DisallowsParenInit(DeclaratorParseType parseType);
    public bool DisallowsFunction(DeclaratorParseType parseType);
    public bool AllowsPackExpansion(DeclaratorParseType parseType);
    public bool AllowsStructuredBinding(DeclaratorParseType parseType);
    public bool AllowsTrailingReturnTypeEvenWithoutAuto(DeclaratorParseType parseType);
    public bool CanHaveUnresolvedMacrosInDeclarationSpecifiers(DeclaratorParseType initParseType);
    public bool AllowsDeclarationSpecifiers(DeclaratorParseType initParseType);
    public bool AllowsBitfields(DeclaratorParseType initParseType);
    public bool AllowsVirtualOrPureSpecifiers(DeclaratorParseType initParseType);
    public bool FunctionMayHaveInitializer(DeclaratorParseType initParseType);
    public bool AllowsAssignment(DeclaratorParseType initParseType);
    public bool RequiresAssignment(DeclaratorParseType initParseType);
    public bool RequiresAssignmentOrColonOrIn(DeclaratorParseType initParseType);
    public bool AllowsParenInitializer(DeclaratorParseType initParseType);
    public bool AllowsBraceInitializer(DeclaratorParseType initParseType);
    public bool AllowsImplicitInt(DeclaratorParseType initParseType);
    public TemplateArgumentListParseType ToTemplateArgumentListParseType(DeclaratorParseType initParseType);
    public string UserFriendlyExpectedName(DeclaratorParseType initParseType);
    public bool CanDisambiguatesAsExpression(DeclaratorParseType initParseType);
    public NodeType NodeTypeForDeclarator(ICppDeclaratorBuilder declaratorBuilder, DeclaratorParseType initParseType);
    public DeclaratorParseType TopLevelDeclarationParseTypeToInitDeclaratorParseType(TopLevelDeclarationParseType parseType);
    public TopLevelDeclarationParseType AddTemplateToTopLevelDeclarationParseType(TopLevelDeclarationParseType parseType);
    public bool IsStatement(TopLevelDeclarationParseType parseType);
    public bool AllowsNamespaces(TopLevelDeclarationParseType parseType);
    public bool AllowsOnlyFunctions(TopLevelDeclarationParseType parseType);
    public bool AllowsNamespaceDefinition(TopLevelDeclarationParseType parseType);
    public DeclaratorParseResult BoolToDeclaratorParseResult(bool success);
    public bool DeclaratorParseResultToBool(DeclaratorParseResult result);
    public ICppFileSymbolsCache GetFileSymbolsCache();
    public CppSymbolTypeIntern GetTypeIntern();
    public ICppDeclarationBuilder CreateDeclarationBuilder(ICppBuilder parent);
    public void EnablePreprocessorDetectionForDeclaration(ICppDeclarationBuilder declBuilder);
    public void DisableDeclarationRollback(ICppDeclarationBuilder declBuilder);
    public void DisablePreprocessorDetectionForDeclaration(ICppDeclarationBuilder declBuilder);
    public CppLanguageDialect GetDialect();
    public CppLanguageKind GetLanguageKind();
    public CppBuilderPool GetBuilderPool();
    public CppParserProfilingInfo GetProfilingInfo();
    [CanBeNullAttribute]
protected ICppPreprocessor GetPreprocessor();
    private Nullable`1<UInt32> GetCurrentPragmaPack();
    public RollbackDetectionModeGuard`2<TTraits, TMarkerGuard> CreateRollbackDetectionModeGuard(bool resetCursor);
    public StandStillGuard`2<TTraits, TMarkerGuard> CreateStandStillGuard();
    public void SetDetectionMode(bool val);
    public CppSymbolLocation TokenLocation();
    public CppSymbolLocation TokenLocation(AttributeSeqPrefix& asp);
    public TokenNodeType NextTt();
    public TokenNodeType NextTtNoSkip();
    public bool Eof();
    public bool ExpectToken(TokenNodeType token, string resourceName);
    private void CheckForInterrupt();
    public void CheckForInterruptAndMarkPassInProfilingInfo();
    public void SkipWsImpl();
    public void SkipDirectivesImpl(bool stopByMacroCalls);
    public void RawAlter(TokenNodeType tokenType, int count);
    public void BaseAlter(TokenNodeType tokenType, int count);
    public void Alter(TokenNodeType tokenType, int count);
    public void GetOrResetTerminalTtAndAlter(TokenNodeType newTerminal, string text, int count);
    public string BaseTokenText();
    public bool ParseLoop(TElementParser& ep, TokenNodeType separator, TIsTerminal isTerminal, TIsSignificant isSignif, string errorResourceName, bool allowTrailingSeparator, bool allowEof, bool allowEmpty);
    public abstract virtual void ParseFunctionBody(ICppFunctionDeclaratorBuilder funcBuilder, int startLexeme, bool isConstructor, Nullable`1<UInt32> pragmaPack);
    public abstract virtual void ParseFunctionBody(ICppFunctionDeclaratorBuilder funcBuilder, object payload);
    public abstract virtual object CreateDeferredFunctionBodyParsingData(ICppFunctionDeclaratorBuilder builder, int startLexeme, bool isConstructor, Nullable`1<UInt32> pragmaPack);
    public abstract virtual void ParseChameleon(CompositeNodeType chameleonType, TChameleonParser& parse, ICppFunctionDeclaratorBuilder funcBuilder);
    public abstract virtual void LearnFunctionBodyChameleon(ICppFunctionDeclaratorBuilder funcBuilder);
    public abstract virtual void LearnCtorBlockWithoutBody(ICppFunctionDeclaratorBuilder funcBuilder);
    internal SkipCtorInitializerElement<TTraits, TMarkerGuard> CreateSkipCtorInitializerElement(ICppFunctionDeclaratorBuilder declaratorBuilder);
    public bool IsAttributeSpecifier();
    public bool IsGnuAttributeSpecifier();
    private static bool IsGnuAttributeSpecifier(TokenNodeType tt);
    public ParseAttributeSpecifierResult<TTraits, TMarkerGuard> ParseAttributeSpecifierSeq(ICppAttributeListBuilder builder, AllowedAttributeTypes allowed, ICppBuilder declBuilder, ICppCallingConventionBuilder ccBuilder, bool skipAlignas);
    public ParseAttributeSpecifierResult<TTraits, TMarkerGuard> ParseSingleAttributeSpecifier(ICppAttributeListBuilder builder, AllowedAttributeTypes allowed, ICppBuilder declBuilder, ICppCallingConventionBuilder ccBuilder, bool skipAlignas);
    private ParseAttributeSpecifierResult<TTraits, TMarkerGuard> ParseGnuStyleAttributeList(ICppAttributeListBuilder builder, ICppCallingConventionBuilder ccBuilder, ICppBuilder parentBuilder);
    public bool ParseAlignmentSpecifier(ICppAttributeListBuilder builder, ICppBuilder declBuilder);
    private bool ParseCpp11AttributeList(ICppAttributeListBuilder builder, string attrNamespace, ICppBuilder parentBuilder);
    private bool ParseGnuAttributeList(ICppAttributeListBuilder builder, ICppCallingConventionBuilder ccBuilder, ICppBuilder parentBuilder);
    private void ParseAttribute(ICppAttributeListBuilder builder, ICppCallingConventionBuilder ccBuilder, string attrNamespace, ICppBuilder parentBuilder, AttributeListStyle style);
    private bool ParseAttributeStringLiteralArgument(ICppBuilder parentBuilder, CppStringLiteralValue& value);
    private bool ParseAttributeExpressionArgument(ICppBuilder parentBuilder, ICppExpression& unresolved, ICppExpression& replaced);
    private bool ParseAttributeIdentifierArgument(String& identifier);
    public string ParseAttributeNamePart();
    public void ParseContractLevel(TokenNodeType tt);
    public void ParseContractConditionExpression(ICppBuilder parentBuilder);
    private bool IsGTGT();
    private bool IsGTGTNotFollowedByGT();
    private bool IsGTNotFollowedByGTGT();
    private bool IsGTFollowedByLiteral();
    private void ParseGTGT();
    private bool IsGTGTEQ();
    private void ParseGTGTEQ();
    private bool IsLTEQGT();
    private void ParseLTEQGT();
    private TokenNodeType GetOrResetTerminalTt(TokenNodeType prevTerminal, TokenNodeType newTerminal, string text);
    private static bool IsSimpleTypeSpecifier(TokenNodeType token);
    private static bool IsHLSLTypeSpecifier(TokenNodeType token);
    private static bool IsHlslSimpleTypeSpecifier(TokenNodeType token);
    private static bool IsStorageClassSpecifier(TokenNodeType token);
    private static bool IsFunctionSpecifier(TokenNodeType token);
    private static bool IsDeclSpecifier(TokenNodeType token);
    private static bool IsCVQualifier(TokenNodeType token);
    private static bool IsArraySizeQualifier(TokenNodeType token);
    private bool IsQualifiedNamePrefix(TokenNodeType token);
    private bool IsQualifiedTypenamePrefix(TokenNodeType token);
    private bool IsComplexSafeCast(TokenNodeType token);
    private bool IsPtrOrRef(TokenNodeType token);
    private static bool IsDeclaratorsPtr(TokenNodeType token);
    private static bool IsRef(TokenNodeType token);
    private bool IsClassSpecifier(TokenNodeType token);
    private bool IsVirtualSpecifier(TokenNodeType tt);
    private bool IsDeclspecKeyword(TokenNodeType token);
    private bool IsMSAsmKeyword(TokenNodeType token);
    private bool IsDeclarationTerminal(ICppDeclarationBuilder declBuilder);
    private static bool IsBeginOfDeclarationTrailing(TokenNodeType token);
    private static bool IsAlignOfKeyword(TokenNodeType token);
    private bool IsDecltypeAuto();
    private bool IsColonOrIn();
    private static bool IsTypeOfKeyword(TokenNodeType token);
    private void EatGlobalIncludes(bool makePreprocessorSnapshot, bool makeResolveEntitiesSnapshot);
    private static void ProcessFile(ICppPreprocessor preprocessor, CppPPIncludeSymbol include);
    private void ParseTopLevelScopeImpl(ICppBuilder parentBuilder, IEnumerator`1<CppScopeDescription> namespaceEnumerator, bool makeSnapshot, bool insideExportBlock);
    public void ParseTopLevelScope(ICppBuilder builder, bool makeSnapshot);
    public void ParseTopLevelScope(ICppBuilder builder, bool makeSnapshot, CppComplexOffset skipDummyBlockCommentForReparseOffset);
    public void ParseTopLevelScopeFragment(ICppBuilder parentBuilder);
    public void ParseDummyTextFragment();
    public void ParseExpressionFragment(ICppBuilder context);
    public bool TryParseFunctionArgumentListInDetectionMode(ICppBuilder context);
    public void ParseAfterCrash();
    public void ParseDummy();
    public void ParseRecoveryJunkUntilEof();
    public CppList`1<KeyValuePair`2<CppJournal, string>> JournalTesting_ParseTopLevel();
    public static NodeType ClassNameNodeType(CppClassBuilder classBuilder);
    public static NodeType ClassNodeType(CppClassBuilder classBuilder);
    private static bool IsScopeComplete(ICppScopeLikeResolveEntity ent, CppViewPos& viewPos);
    private static bool IsInsideFunctionBody(ICppResolveEntity entity);
    private static CppParserSymbol ExtractDeclarationSymbolIfAny(ICppDeclarationBuilder builder);
    private bool QualifiedReferenceResultIsType(ICppBuilder declarationBuilder, CppTwinQualifiedNameBuilder nameBuilder, ParseQualifiedReferenceResult parseResult);
    public void ParseTopLevelDeclarationOrShowError(bool allowOmittingType, TopLevelDeclarationParseType parseType, string errorResourceName, ICppDeclarationBuilder declBuilder);
    public void ParseTopLevelDeclarationOrShowError(bool allowOmittingType, TopLevelDeclarationParseType parseType, string msg, ICppDeclarationBuilder declBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    private static bool HasExportingNamespaceParent(ICppBuilder builder);
    public bool ParseTopLevelDeclaration(bool allowOmittingType, TopLevelDeclarationParseType parseType, ICppDeclarationBuilder declBuilder, bool makeSnapshot);
    private bool ParseTopLevelDeclarationAfterExport(bool allowOmittingType, TopLevelDeclarationParseType parseType, ICppDeclarationBuilder declBuilder, bool makeSnapshot, TMarkerGuard& mk);
    public bool ParseTopLevelDeclaration(bool allowOmittingType, TopLevelDeclarationParseType parseType, ICppDeclarationBuilder declBuilder, bool makeSnapshot, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public void CreateBuilderAndParseDeclarationTrailing(ICppDeclarationBuilder declBuilder);
    public void ParseDeclarationTrailing(ICppFunctionDeclaratorBuilder declaratorBuilder);
    public bool ParseBlockDeclaration(ICppBuilder parentBuilder, TopLevelDeclarationParseType parseType, AttributeSeqPrefix& asp, TMarkerGuard& mk, bool export);
    public bool ParseStatementBlockDeclaration(ICppScopeStatementBuilder ssBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public bool ParseTopLevelSimpleDeclaration(TopLevelDeclarationParseType parseType, ICppDeclarationBuilder declBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public bool ParseDeclaration(TopLevelDeclarationParseType parseType, ICppDeclarationBuilder declBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public bool IsDeclarationWithOmittedSpecifiers(ICppDeclarationBuilder declBuilder);
    public bool IsStatementNotDeclarator();
    public bool IsDeclaratorPrefix();
    public DeclaratorParseResult ParseDeclaratorsInDeclaration(TopLevelDeclarationParseType parseType, ICppDeclarationBuilder declBuilder, bool hadClassSpecifier);
    public ParseDeclarationWithSpecifiersGreedyResult ParseDeclarationWithSpecifiersGreedy(TopLevelDeclarationParseType parseType, ICppDeclarationBuilder declBuilder, DeclarationSpecifiersResolveType resolveName, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public bool ParseDeclarationWithSpecifiersNotGreedy(TopLevelDeclarationParseType parseType, ICppDeclarationBuilder declBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public void SkipLoneTypenameKeyword(Boolean& invalid);
    public ParseDeclarationSpecifiersResult ParseDeclarationSpecifiers(bool ignoreId, bool assumeIdWasBefore, bool allowsSpecifiers, bool allowsClassBody, bool detectMissingSemicolonAfterClassSpecifier, bool recoverSuperfluousSemicolonAfterClassHead, bool allowLiteralOrInitOnly, ICppDeclarationBuilder declBuilder, TemplateArgumentListParseType templateArgumentListParseType, DeclarationSpecifiersResolveType resolveName, NodeType nodeType, TSpecifierChecker checker);
    public ParseDeclarationSpecifiersResult ParseDeclarationSpecifiers(bool ignoreId, bool assumeIdWasBefore, bool allowsSpecifiers, bool allowsClassBody, bool detectMissingSemicolonAfterClassSpecifier, bool recoverSuperfluousSemicolonAfterClassHead, bool allowLiteralOrInitOnly, ICppDeclarationBuilder declBuilder, TemplateArgumentListParseType templateArgumentListParseType, DeclarationSpecifiersResolveType resolveName, NodeType nodeType);
    public ParseDeclarationSpecifiersResult ParseDeclarationSpecifiers1(bool ignoreId, bool assumeIdWasBefore, bool allowsSpecifiers, bool allowsClassBody, bool detectMissingSemicolonAfterClassSpecifier, bool recoverSuperfluousSemicolonAfterClassHead, bool allowLiteralOrInitOnly, ICppDeclarationBuilder declBuilder, TemplateArgumentListParseType templateArgumentListParseType, DeclarationSpecifiersResolveType resolveName, TSpecifierChecker checker);
    private bool IsBuiltinTypeTrait(TokenNodeType tt);
    private Nullable`1<ValueTuple`2<CppFwdClassSymbol, ICppClassResolveEntity>> CreateClassFromName(CppQualifiedName unresolvedName, CppComplexOffset nameLocation, bool isFriend, ICppBuilder builder);
    private ValueTuple`2<CppFwdClassSymbol, ICppClassResolveEntity> CreateClassFromName(ICppBuilder builder, CppComplexOffset nameLocation, CppViewPos viewPos, bool isFriend, CppQualifiedId qualifiedId);
    private CppFwdClassSymbol CreateClassSymbolFromName(CppComplexOffset nameLocation, bool isFriend, CppQualifiedName unresolvedName, CppClassKey key, CppAttributeList attributes);
    private void LearnQualifiedName(ICppDeclarationBuilder declBuilder, CppQualifiedName unresolvedName, CppQualifiedName replacedName, CppComplexOffset nameLocation);
    public void ParseHlslVectorTypeSpecifier(TokenNodeType tt, ICppDeclarationBuilder declBuilder);
    public void ParseHlslBufferSpecifier(ICppDeclarationBuilder declBuilder);
    public DetectDeclarationSpecifierFollowResult DetectUnresolvedDeclarationSpecifierFollow(TypeType typeType);
    public bool ShouldIgnoreResolvedDeclarationSpecifier();
    public DeclaratorParseResult ParseInitDeclarator(bool greaterIsOperator, DeclaratorParseType initParseType, ICppDeclarationBuilder declBuilder);
    public bool IsBitfieldDeclarator(ICppDeclarationBuilder declBuilder);
    public bool ParseBitfieldDeclarator(ICppDeclaratorBuilder declaratorBuilder);
    public bool IsBraceDeclaratorInitializer(DeclaratorParseType initParseType);
    public bool DefinitelyIsNotAValidBraceInitializer();
    public bool ParseHlslDeclaratorTrailing();
    public DeclaratorParseResult ParseDeclarator(DeclaratorParseType parseType, bool nested, ICppInnerDeclaratorBuilder declaratorBuilder);
    public void ParseDeclaratorPtrSeq(ICppInnerDeclaratorBuilder innerDeclaratorBuilder);
    public void ParseGnuAsmAndAttributes(ICppDeclaratorBuilder declaratorBuilder);
    public void ParseDeclaratorAttributes(ICppDeclarationBuilder declBuilder);
    public DeclaratorParseResult ParseDirectDeclarator(DeclaratorParseType parseType, bool nested, ICppInnerDeclaratorBuilder innerDeclaratorBuilder);
    public bool IsParameterDeclarationClauseNotDeclaratorOrInitializer(ParametersAmbiguityAlternatives alternatives, ICppBuilder builder);
    public TriBool IsParameterDeclarationClauseNotDeclaratorOrInitializerQuickCheck(ParametersAmbiguityAlternatives alternatives, ICppBuilder parentBuilder);
    public bool IsParameterDeclarationClauseNotDeclaratorOrInitializerFullCheck(ICppBuilder builder);
    public bool ParseFunctionDeclarator(DeclaratorParseType parseType, ICppInnerDeclaratorBuilder declaratorBuilder);
    public bool ParseParameterDeclarationClause(ICppParameterListBuilder plistBuilder);
    public bool IsFunctionWithTailingParameterDeclarations(ICppDeclarationBuilder declBuilder);
    public void ParseKnRParameterDeclarations(ICppParameterListBuilder plistBuilder);
    public void ParseCVQualifiers(CppCVQualifiersBuilder& cvQualBuilder);
    public void ParseCVQualifiers(ICppFunctionParameterListBuilder plistBuilder);
    public void ParseRefQualifier(ICppFunctionParameterListBuilder plistBuilder);
    public void ParseRestrictionSpecifiers(ICppParameterListBuilder plistBuilder);
    public void ParseRestrictionSpecifier(CppRestrictionSpecifiersBuilder& builder);
    public void ParseExceptionSpecification(ICppParameterListBuilder plistBuilder);
    public void ParseDynamicExceptionSpecification(ICppParameterListBuilder plistBuilder);
    public void ParseNoExceptSpecification(ICppParameterListBuilder plistBuilder);
    public bool ParseTrailingReturnType(ICppParameterListBuilder plistBuilder);
    public bool IsCxxCliPropertyOrEvent();
    public void ParseCxxCliPropertyOrEvent(ICppDeclarationBuilder currentBuilder);
    public bool ParseCxxCliPropertyIndexes(CppCxxCliPropertyIndexesBuilder indexBuilder);
    private bool IsAccessSpecifierInCodeFragment(ICppDeclarationBuilder declBuilder);
    public bool IsCxxCliDelegate();
    public void ParseCxxCliDelegate(ICppDeclarationBuilder declBuilder);
    public void ParseHlslShaderConstantsBuffer(AttributeSeqPrefix& asp, TMarkerGuard& mk, ICppDeclarationBuilder declBuilder);
    public bool IsConceptDefinition(ICppDeclarationBuilder declBuilder);
    public bool ParseConceptDefinition(ICppDeclarationBuilder declBuilder, TopLevelDeclarationParseType parseType, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public void ParseWhileCondition(CppWhileStatementBuilder statementBuilder);
    public void ParseSelectionCondition(ICppBuilder statementBuilder, CppIfStatementBuilder ifStatementBuilder);
    public bool IsDeclarationConditionNotExpression(ICppBuilder builder);
    public bool IsDeclarationConditionNotExpressionFullCheck(ICppBuilder builder);
    public bool IsDeclarationWithImplicitIntType(DeclaratorParseType initParseType, ICppDeclarationBuilder declBuilder);
    public bool ParseTrivialDeclaration(NodeType type, bool greaterIsOperator, DeclaratorParseType initParseType, bool resolveName, bool parseAttributeSpecifier, ICppBuilder parentBuilder);
    public bool ParseTrivialDeclarationWithBuilder(NodeType type, bool greaterIsOperator, bool allowsClassBody, DeclaratorParseType initParseType, bool resolveName, ICppDeclarationBuilder declBuilder);
    public bool ParseTrivialDeclarationWithBuilder(NodeType type, bool greaterIsOperator, bool allowsClassBody, DeclaratorParseType initParseType, bool resolveName, ICppDeclarationBuilder declBuilder, TMarkerGuard& mk);
    public bool ContinueParsingTrivialDeclarationAfterQualifiedReference(bool greaterIsOperator, bool allowsClassBody, DeclaratorParseType initParseType, bool resolveName, ICppDeclarationBuilder declBuilder);
    public void ParseVirtualSpecifierSeq(ICppDeclaratorBuilder declaratorBuilder);
    public bool IsPureSpecifier();
    public void ParsePureSpecifier();
    public bool IsCxxCliOverrideSpecifier();
    public void ParseCxxCliOverrideSpecifier(ICppDeclaratorBuilder declaratorBuilder);
    public bool IsErroneouslyEmptyParameterDeclaration(TokenNodeType tt);
    public void ParseNameQualifierWithBuilder(CppTwinQualifiedNameBuilder& nameBuilder, ICppDeclarationBuilder declBuilder);
    public bool IsNameQualifierPtr(ICppDeclarationBuilder declBuilder);
    public bool IsMSCallingConventionPtr(ICppDeclarationBuilder builder);
    public void ParseClassAttributes(ICppDeclarationBuilder declBuilder, CppClassBuilder classBuilder, ICppAttributeListBuilder builder);
    public bool IsFinalClassVirtSpecifier(bool recoverSuperfluousSemicolon, CppClassVirtualSpecifiers& classVirtualSpecifiers);
    public void AnalyzeClassVirtSpecifiers(bool recoverSuperfluousSemicolon, bool allowsBody, Boolean& superfluousSemicolon, Boolean& hasBaseClause, Boolean& hasBody, Boolean& hasSemicolon, CppClassVirtualSpecifiers& classVirtualSpecifiers);
    public void ParseClassSpecifier(bool recoverSuperfluousSemicolon, bool allowsBody, ICppDeclarationBuilder declBuilder, Boolean& wasClassBody);
    public bool IsSuperfluousIdentifierBeforeClassName(ICppDeclarationBuilder declBuilder);
    public void ParseClassKey(CppClassKeyBuilder& keyBuilder);
    public void ParseBaseClause(CppClassBuilder classBuilder, ICppDeclarationBuilder declBuilder);
    public void ParseEnumBaseClause(CppClassBuilder classBuilder, ICppDeclarationBuilder parentDeclBuilder);
    public void ParseCXXMemberSpecification(CppClassBuilder classBuilder);
    public void ParseMemberList(TBuilderWithAccessibility classBodyBuilder);
    public bool ParseEnumerator(CppEnumBodyBuilder enumBuilder);
    public bool IsValidAfterTypeSpecifier(ICppDeclarationBuilder declBuilder);
    public void ParseNamespace(TopLevelDeclarationParseType parseType, ICppBuilder parentBuilder, bool export);
    public void ParseNamespaceName(CppNamespaceBuilder& nsBuilder, TMarkerGuard& mk, Boolean& hadQualifier, bool allowsNamespaceDefinition);
    public int EnterNamespace(ICppNamespaceSymbol sym);
    public void ExitNamespace(int depth);
    public void ParseUsingDirectiveOrDeclaration(ICppDeclarationBuilder declBuilder);
    public void ParseUsingDirective(CppUsingsBuilder& builder);
    public CppUsingEnumDeclarationData ParseUsingEnumDeclaration(CppUsingsBuilder& builder);
    public bool IsAliasDeclaration(ICppDeclarationBuilder builder);
    public NodeType ParseUsingDeclaration(CppUsingsBuilder& builder);
    public void ParseAliasDeclaration(ICppDeclarationBuilder declBuilder);
    public void ParseAliasDeclaration(CppUsingsBuilder& builder);
    public void ParseUsingDeclarator(CppUsingsBuilder builder);
    public void ParseLinkage(ICppDeclarationBuilder parentBuilder, TopLevelDeclarationParseType parseType, bool makeSnapshot);
    public void ParseMsIfExistsTopLevel(ICppDeclarationBuilder parentBuilder);
    public void ParseCtorInitializer(ICppBuilder context, CppFunctionBodyBuilder bodyBuilder);
    public void ParseMemInitializer(ICppBuilder context, CppFunctionBodyBuilder bodyBuilder);
    private bool EatExpansion();
    public void ParseFunctionBodyInner(ICppFunctionDeclaratorBuilder funcBuilder, bool isConstructor);
    public void ParseChameleonCtorBlock(ICppFunctionDeclaratorBuilder declaratorBuilder, bool learnParsing);
    public void ParseChameleonFunctionTryBlock(ICppFunctionDeclaratorBuilder builder);
    public void ParseMsDeclSpec(ICppDeclarationBuilder declBuilder, ICppAttributeListBuilder attrListBuilder, Boolean& wasAttribute);
    private static bool IsCudaDeclspec(string tok);
    private static bool IsCudaLaunchBounds(string tok);
    public void ParseMsAttributes(bool allowOmittingType, TopLevelDeclarationParseType parseType, ICppDeclarationBuilder declBuilder, AttributeSeqPrefix& aspParent, TMarkerGuard& mkParent);
    public void ParseValidParenthesisSequence();
    public bool ContinueParsingValidParenthesisSequence(TokenNodeType leftTt);
    public bool IsValidParenthesisSequenceNotContaining(TokenNodeType needle, TokenNodeType needle2);
    public void ParseBracesSequenceWithoutRBrace();
    public void ParseBracesSequence();
    public void ParseStaticAssertDeclaration(ICppBuilder parentBuilder);
    public bool ParseDecltypeId(TQualifiedNameBuilder& nameBuilder, ICppBuilder parentBuilder, bool destructor);
    public CppOperatorKind ParseBinaryOperator(bool greaterIsOperator);
    public OperatorPrecedence BinaryOperatorPrecedence(CppOperatorKind kind);
    public bool IsBeginOfExpression(TokenNodeType token);
    public DeclarationAndExpressionPrefixType ClassifyDeclarationAndExpressionPrefix();
    public void SkipBinaryOperator(CppOperatorKind opKind);
    public bool IsTwoConsecutiveQualifiedNames(SymbolIsTemplateContext ctx);
    public bool IsRequiresExpression();
    public bool ParseLambdaIntroducer(CppLambdaBuilder lambdaBuilder);
    public void ParseLambdaCapture(CppLambdaBuilder lambdaBuilder);
    public void ParseLambdaCaptureName(CppLambdaBuilder lambdaBuilder, bool ref, bool pack);
    public void ParseLambdaDeclarator(ICppLambdaParameterListBuilder plistBuilder, ICppAttributeListBuilder attrBuilder);
    public virtual bool IsCStyleCastNotExpression(bool greaterIsOperator);
    public bool IsCStyleCastNotExpressionFullCheck(bool greaterIsOperator);
    public bool IsDesignatedInitializer(TokenNodeType tt);
    public void ParseRequiresExpressionItem(CppRequiresExpressionBuilder requiresBuilder);
    public bool IsSizeOfTypeIdNotExpressionFullCheck(bool greaterIsOperator);
    public bool IsSizeOfTypeIdNotExpressionInContextOf(bool greaterIsOperator, ICppBuilder context);
    public bool IsSizeOfTypeIdNotExpression(bool greaterIsOperator);
    public void ExpectStringLiteralGroup(TStringLiteralBuilder& builder, ICppBuilder parentBuilder);
    public void ParseStringLiteralGroup(TStringLiteralBuilder& builder, ICppBuilder parentBuilder);
    public bool ParseIdPart(bool declaratorName, TemplateArgumentListParseType templateArgumentListParseType, bool mayStartWithTemplate, bool mayStartWithTilde, TQualifiedNameBuilder& nameBuilder, SymbolIsTemplateContext ctx, CppComplexOffset& navigationOffset, ICppBuilder parentBuilder);
    public void ParseIdentifier();
    public bool IsIdentifier(TokenNodeType tt);
    public string IdentifierText();
    public bool ParseTemplateArgumentListIfNeeded(bool isTemplate, TemplateArgumentListParseType templateArgumentListParseType, TQualifiedNameBuilder& nameBuilder, SymbolIsTemplateContext ctx, ICppBuilder parentBuilder);
    public bool CanBeTemplateArgumentListByBody(ICppBuilder builder);
    public bool CanBeTemplateArgumentListByTrailing();
    public bool CanNotBeTemplateArgumentList();
    public bool ParseId(bool declaratorName, TemplateArgumentListParseType templateArgumentListParseType, bool mayStartWithTemplate, bool mayStartWithTilde, TQualifiedNameBuilder& nameBuilder, SymbolIsTemplateContext ctx, CppComplexOffset& navigationOffset, ICppBuilder parentBuilder);
    public ParseQualifiedReferenceResult ParseQualifiedReference(TemplateArgumentListParseType templateArgumentListParseType, bool mayStartWithTemplateOrTilde, bool mayStartWithTypename, NodeType type, TQualifiedNameBuilder& nameBuilder, ICppBuilder parentBuilder);
    public ParseQualifiedReferenceResult ParseQualifiedReference(TemplateArgumentListParseType templateArgumentListParseType, bool mayStartWithTemplateOrTilde, bool mayStartWithTypename, NodeType type, TQualifiedNameBuilder& nameBuilder, SymbolIsTemplateContext ctx, ICppBuilder parentBuilder);
    public ParseQualifiedReferenceResult ParseQualifiedReference1(TemplateArgumentListParseType templateArgumentListParseType, bool mayStartWithTemplateOrTilde, bool mayStartWithTypename, TQualifiedNameBuilder& nameBuilder, SymbolIsTemplateContext ctx, ICppBuilder parentBuilder);
    public bool ParseTemplateArgumentList(TQualifiedNameBuilder& nameBuilder, ICppBuilder parentBuilder);
    public bool ParseIdentifierOrOperatorFunctionId(bool declaratorName, TQualifiedNameBuilder& nameBuilder, ICppBuilder parentBuilder);
    public bool ParseIdentifier(TQualifiedNameBuilder& nameBuilder);
    public ParensForFunctionCallOperatorInDeclaratorType<TTraits, TMarkerGuard> ClassifyParensForFunctionCallOperatorInDeclarator();
    public void ParseOperatorFunctionId(bool declaratorName, TQualifiedNameBuilder& nameBuilder, ICppBuilder parentBuilder);
    public void ParsePPMacroCall();
    public bool ParsePPDirective();
    public bool ParsePPMacroCallArgument(int macroLevel);
    public void ParsePPPragma();
    private void ParsePragmaPack(CppPragmaPackState& pragmaPack, List`1<ICppSymbol> symbolsOutput, CppComplexOffset symbolOffset);
    public void ParseMsPragma();
    public void SkipDirectiveBody();
    public void ParseCpp20ImportDirective();
    public void ParseCpp20ModuleDirective();
    public bool ParseModuleName();
    public void ParseAttributesBeforeStatement(CppAttributeListBuilder& attrsBuilder, CppComplexOffset& complexOffset, Boolean& hadAttributes, ICppBuilder parentBuilder);
    public bool IsBeginOfStatement();
    private void ParseStatementOrCreateEmptyStatement(ICppScopeStatementBuilder ssBuilder);
    public void ParseStatementOrShowError(ICppScopeStatementBuilder ssBuilder);
    private static bool IsInsideCodeFragment(ICppResolveEntity entity);
    public void ParseStatementOrShowError(ICppScopeStatementBuilder ssBuilder, CppAttributeListBuilder parsedAttributes, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public void ParseStatement(ICppScopeStatementBuilder ssBuilder);
    private static void ErrorIfHadAttributes(AttributeSeqPrefix& asp, TMarkerGuard& mk, string keyword);
    public void ParseStatement(ICppScopeStatementBuilder ssBuilder, CppAttributeListBuilder parsedAttributes, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public void ParseCXXCatchBlock(ICppScopeStatementBuilder parentBuilder);
    public void ParseCompoundStatement(ICppBuilder parentBuilder);
    public void ParseCompoundStatement(ICppBuilder parentBuilder, bool addFunctionBodyBuiltinEntities, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public void ParseCompoundStatementWithBuilder(ICppScopeStatementBuilder ssBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk, object nodeUserData);
    public void ParseCompoundStatementWithBuilder(bool addFunctionBodyBuiltinEntities, ICppScopeStatementBuilder ssBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk, NodeType nodeType, object nodeUserData);
    public void ParseLoopBody(CppLoopStatementBuilder`2<TSymbol, TResolveEntity> loopBuilder, CppSymbolLocation loopLocation);
    public void ParseChameleonCompoundStatement(ICppFunctionDeclaratorBuilder builder);
    public void ParseIfStatement(ICppScopeStatementBuilder ssBuilder, AttributeSeqPrefix& aspParent, TMarkerGuard& mkParent);
    private bool IsConstevalAfterLpar();
    private bool ParseConstevalOrIfCondition(CppIfStatementBuilder ifBuilder);
    public void ParseWhileStatement(ICppScopeStatementBuilder ssBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public void ParseDoStatement(ICppScopeStatementBuilder ssBuilder, AttributeSeqPrefix& aspParent, TMarkerGuard& mkParent);
    public void ParseSwitchStatement(ICppScopeStatementBuilder ssBuilder, AttributeSeqPrefix& aspParent, TMarkerGuard& mkParent);
    public void ParseForStatement(ICppScopeStatementBuilder ssBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public bool ParseForStatementClause(CppForStatementBuilder forStmtBuilder, bool hadCoAwait);
    public void ParseForRangeExpression(ICppDeclarationBuilder declBuilder, CppForStatementBuilder forStmtBuilder);
    public void ParseMSForStatement(CppForStatementBuilder forBuilder, CppSymbolLocation forLocation);
    public bool IsLabeledStatement();
    public void ParseGotoStatement(ICppScopeStatementBuilder ssBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public void ParseBreakStatement(ICppScopeStatementBuilder ssBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public void ParseContinueStatement(ICppScopeStatementBuilder ssBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public void ParseHlslDiscardStatement(ICppScopeStatementBuilder ssBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public void ParseReturnStatement(ICppScopeStatementBuilder ssBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public void ParseCoReturnStatement(ICppScopeStatementBuilder ssBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public void ParseMSLeaveStatement();
    public void ParseLabeledStatement(ICppScopeStatementBuilder ssBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public void ParseDefaultStatement(ICppScopeStatementBuilder ssBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public bool IsDeclarationStatementNotExpression(ICppBuilder builder, bool requireSemicolon);
    public bool IsPtrAnonDeclarator(ICppDeclarationBuilder declBuilder);
    public TriBool IsDeclarationNotExpressionQuickCheck(DeclarationNotExpressionParseType parseType, ICppBuilder parentBuilder);
    public TriBool IsDeclarationNotExpressionQuickCheckAfterQualifiedName(DeclarationNotExpressionParseType parseType, DeclaratorParseType initParseType, CppTwinQualifiedNameBuilder nameBuilder, ParseQualifiedReferenceResult nameParsingResult, ICppBuilder parentBuilder);
    public TriBool IsDeclarationNotExpressionAfterDeclarationSpecifiersQuickCheck(DeclarationNotExpressionParseType parseType, ParseDeclarationSpecifiersResult declSpecResult, CppNullDeclarationBuilder declBuilder);
    public bool IsDeclarationStatementNotExpressionFullCheck(ICppBuilder parentBuilder, bool requireSemicolon);
    public bool ParseDeclarationStatement(ICppScopeStatementBuilder ssBuilder, CppAttributeListBuilder parsedAttributes, AttributeSeqPrefix asp, TMarkerGuard& mk);
    public bool ParseExpressionStatement(AttributeSeqPrefix& asp, TMarkerGuard& mk, ICppScopeStatementBuilder ssBuilder);
    public void ParseCXXTryBlock(ICppScopeStatementBuilder parentBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public void ParseMsTryBlock(ICppScopeStatementBuilder parentBuilder);
    public void ParseMsExceptBlock(ICppScopeStatementBuilder parentBuilder);
    public void ParseMsFinallyBlock(ICppScopeStatementBuilder parentBuilder);
    public bool IsCxxCliFinallyBlock();
    public void ParseCxxCliFinallyBlock(ICppScopeStatementBuilder parentBuilder);
    public void ParseMsIfExistsArgumentClause(ICppBuilder parentBuilder);
    public void ParseMsIfExistsStatement(ICppScopeStatementBuilder ssBuilder);
    public void ParseTopLevelGnuAsmDefinition(ICppBuilder parentBuilder);
    public void ParseGGDeclareHungarian(ICppDeclarationBuilder parentBuilder);
    public void ParseAsmDefinition(ICppScopeStatementBuilder ssBuilder);
    public void ParseMSAsmDefinition(ICppScopeStatementBuilder ssBuilder);
    public void ParseMSAsmCompoundStatement(ICppScopeStatementBuilder ssBuilder);
    public void ParseMSAsmComment();
    public void ParseGnuAsmDefinition(TMarkerGuard& asmStatement, ICppScopeStatementBuilder ssBuilder);
    public bool IsGnuAsmQualifier();
    public bool ParseGnuAsmQualifiers();
    public void ParseGnuAsmOperands(ICppBuilder parentBuilder);
    public void ParseGnuAsmClobbers();
    public void ParseGnuAsmGotoLabels();
    public void SkipTillEoln();
    public CaseStatementKind ParseCaseStatement(ICppScopeStatementBuilder ssBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public void ParseTemplateDeclarationOrSpecialization(TopLevelDeclarationParseType parseType, ICppDeclarationBuilder declBuilder);
    public void ParseGenericDeclarationOrSpecialization(TopLevelDeclarationParseType parseType, ICppDeclarationBuilder declBuilder);
    public void ParseExplicitInstantiation(TopLevelDeclarationParseType parseType, ICppDeclarationBuilder declBuilder, AttributeSeqPrefix& asp, TMarkerGuard& mk);
    public void ParseTemplateParameters(TTemplateHeaderBuilder builder);
    public void ParseTemplateParametersWithRequiresClause(TTemplateHeaderBuilder builder);
    public void ParseGenericParameters(CppTemplateHeaderBuilder builder);
    public TemplateParameterType<TTraits, TMarkerGuard> ClassifyTemplateParameter(ICppBuilder parentBuilder);
    public void ParseTypeTemplateParameter(TTypeParameterBuilder builder);
    public void ParseTemplateTemplateParameter(ICppTemplateTemplateParameterBuilder`1<TTemplateHeaderBuilder> builder);
    public void ParseConstrainedTypeTemplateParameter(ICppTemplateHeaderBuilder`4<TTypeParameterBuilder, TNonTypeParameterBuilder, TTemplateTemplateParameterBuilder, TConceptParameterBuilder> headerBuilder);
    public void ParseGenericParameter(CppGenericParameterBuilder builder);
    public void ParseGenericConstraintClause(WhereClauseBuilder whereClauseBuilder);
    public bool TryParseSimpleGenericConstraintItem(CppGenericConstraintClauseBuilder genericConstraintClauseBuilder);
    public void ParseGenericConstraintItem(CppGenericConstraintClauseBuilder genericConstraintClauseBuilder);
    public bool ParseTypeId(DeclaratorParseType initParseType, bool resolveName);
    public bool IsTypeIdInParenNotFunctionArgumentList();
    public bool IsTypeIdNotExpression(TParseFollows parseFollows);
    public bool IsTypeIdNotExpressionFullCheck(TParseFollows parseFollows);
    public bool IsTypeIdNotExpressionAfterQualifiedReferenceFullCheck(TParseFollows parseFollows, ICppBuilder builder);
    public bool IsUE4Attribute(TokenNodeType token);
    public bool IsUE4ClassAttribute(TokenNodeType token);
    public bool IsUE4AttributeSpecifierKey(TokenNodeType token);
    public bool IsUE4AttributeSpecifierValue(TokenNodeType token);
    public bool IsUE4AttributeSpecifierSequencedValue(TokenNodeType token);
    public bool ParseUE4Attributes(ICppAttributeListBuilder builder);
    public bool ParseUE4AttributeSpecifier(CppUE4AttributeBuilder attributeBuilder);
    public bool ParseUE4AttributeSpecifierSequencedValue(CppUE4AttributeBuilder attributeBuilder, string specifierKey);
    public bool ParseUE4AttributeSpecifierMeta(CppUE4AttributeBuilder attributeBuilder);
    public string ParseUE4AttributeSpecifierValue(CppCompositeNodeType nodeType);
    [CompilerGeneratedAttribute]
private void <ParseDeclarationTrailing>g__ParseLBrace|203_0(<>c__DisplayClass203_0& );
    [CompilerGeneratedAttribute]
private bool <ParseTemplateArgumentList>g__Impl|361_0(TTemplateArgumentsBuilder templArgsBuilder, <>c__DisplayClass361_0`1& );
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppParsingInfra : object {
    internal static OperatorPrecedence GetMinPrecedenceByExpressionParseType(ExpressionParseType parseType);
}
internal abstract class JetBrains.ReSharper.Psi.Cpp.Parsing.CppParsingWithTraits`2 : CppParsingInfra {
    protected TTraits myTraits;
    protected bool myDetectionMode;
    public TMarkerGuard CreateMarkerGuard(LightweightRollbackT _);
    public TMarkerGuard CreateMarkerGuard(RollbackT _);
    public TMarkerGuard CreateMarkerGuard(DropT _);
    public TMarkerGuard CreateMarkerGuard(NodeType type, bool beforeWs, bool allowEmpty, object userData);
    public TMarkerGuard CreateMarkerGuard(PrecedeCurrentT _, RollbackT __);
    public TMarkerGuard CreateMarkerGuard(PrecedeCurrentT _, DropT __);
    public TMarkerGuard CreateMarkerGuard(PrecedeCurrentT _, NodeType type, bool beforeWs, bool allowEmpty);
    public void EnablePreprocessor2Detection(bool value);
    public void AddUdlNameToWordIndex(string suffix);
    public void BaseAdvance();
    public void Advance();
    public void ResetTokenCursor();
    public bool IsEmpty(int marker);
    public void Done(int marker, NodeType type, object userData);
    public void DoneBeforeWhitespaces(int marker, NodeType type, object userData);
    public void RollbackTo(int mark);
    public void Drop(int mark);
    public int RawCurrentLexeme();
    public int BaseCurrentLexeme();
    public int CurrentLexeme();
    public void Error(string message);
    public void ErrorBeforeWhitespaces(string message);
    public void Error(int mark, string message);
    public bool HasNewLineBefore(int pos);
    public void SkipWs();
    public void SkipDirectives(bool stopByMacroCalls);
    public void SkipNonMeaningful();
    public TokenNodeType TryUnwrap(TokenNodeType tt);
    public TokenNodeType RawTt(bool unwrap);
    public TokenNodeType BaseTt(bool unwrap);
    public TokenNodeType Tt(bool unwrap);
    public T BaseTt(bool unwrap);
    public string GetTokenText(int index);
    public string RawTokenText();
    public string TokenText();
    public CppComplexOffset RawNavigationOffset();
    public CppComplexOffset BaseNavigationOffset();
    public CppComplexOffset NavigationOffset();
    public void BaseResync();
    public void Resync();
    public int Mark();
    public int PrecedeCurrent();
    public int GetCurrentNonCommentLexeme();
    public void ResetCurrentLexeme(int cur, int curNc);
    public bool GetDetectionMode();
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.CppParsingWoPreprocessor : CppPSIFreeParsingBase {
    public CppParsingWoPreprocessor(ILazyCachingLexer lexer, ICppFileSymbolsCache cache);
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.CppPreprocessor2Parsing2 : CppPreprocessor2ParsingBase {
    public CppPreprocessor2Parsing2(CppPreprocessor2 preprocessor, bool rememberPPUsagesInChameleons);
    public virtual void ParseFunctionBody(ICppFunctionDeclaratorBuilder _, int startLexeme, bool isConstructor, Nullable`1<UInt32> pragmaPack);
    public virtual object CreateDeferredFunctionBodyParsingData(ICppFunctionDeclaratorBuilder _, int startLexeme, bool isConstructor, Nullable`1<UInt32> pragmaPack);
    public virtual void ParseFunctionBody(ICppFunctionDeclaratorBuilder _, object payload);
    public virtual void LearnFunctionBodyChameleon(ICppFunctionDeclaratorBuilder _);
    public virtual void LearnCtorBlockWithoutBody(ICppFunctionDeclaratorBuilder _);
    public virtual bool IsCStyleCastNotExpression(bool greaterIsOperator);
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.CppPreprocessor2ParsingBase : CppParsingBase`2<CppPreprocessor2Traits, LightweightMarkerGuard`1<CppPreprocessor2Traits>> {
    private CppPreprocessor2 myPreprocessor;
    public CppPreprocessor2ParsingBase(CppPreprocessor2 preprocessor, ICppFileSymbolsCache cache, bool rememberPPUsagesInChameleons);
    public virtual void ParseFunctionBody(ICppFunctionDeclaratorBuilder funcBuilder, int startLexeme, bool isConstructor, Nullable`1<UInt32> pragmaPack);
    public virtual object CreateDeferredFunctionBodyParsingData(ICppFunctionDeclaratorBuilder declaratorBuilder, int startLexeme, bool isConstructor, Nullable`1<UInt32> pragmaPack);
    public virtual void ParseFunctionBody(ICppFunctionDeclaratorBuilder funcBuilder, object payload);
    public virtual void ParseChameleon(CompositeNodeType chameleonType, TChameleonParser& parse, ICppFunctionDeclaratorBuilder funcBuilder);
    public virtual void LearnFunctionBodyChameleon(ICppFunctionDeclaratorBuilder _);
    public virtual void LearnCtorBlockWithoutBody(ICppFunctionDeclaratorBuilder _);
    private void ParseFunctionBody(ICppFunctionDeclaratorBuilder funcBuilder, int startLexeme, CppViewPos& context, bool isConstructor, Nullable`1<UInt32> pragmaPack);
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.CppPreprocessor2Traits : ValueType {
    private Cursor myRawCursor;
    private Cursor myBaseCursor;
    private Cursor myStandardCursor;
    private CppPreprocessor2 myPreprocessor;
    private CurrentMode myCurrentMode;
    [CompilerGeneratedAttribute]
private CppParsingBase`2<CppPreprocessor2Traits, LightweightMarkerGuard`1<CppPreprocessor2Traits>> <Parser>k__BackingField;
    public CppParsingBase`2<CppPreprocessor2Traits, LightweightMarkerGuard`1<CppPreprocessor2Traits>> Parser { get; public set; }
    public CppPreprocessor2Traits(CppParsingBase`2<CppPreprocessor2Traits, LightweightMarkerGuard`1<CppPreprocessor2Traits>> parsing, CppPreprocessor2 preprocessor);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CppParsingBase`2<CppPreprocessor2Traits, LightweightMarkerGuard`1<CppPreprocessor2Traits>> get_Parser();
    [CompilerGeneratedAttribute]
public void set_Parser(CppParsingBase`2<CppPreprocessor2Traits, LightweightMarkerGuard`1<CppPreprocessor2Traits>> value);
    public sealed virtual LightweightMarkerGuard`1<CppPreprocessor2Traits> CreateMarkerGuard(LightweightRollbackT _);
    public sealed virtual LightweightMarkerGuard`1<CppPreprocessor2Traits> CreateMarkerGuard(RollbackT _);
    public sealed virtual LightweightMarkerGuard`1<CppPreprocessor2Traits> CreateMarkerGuard(DropT _);
    public sealed virtual LightweightMarkerGuard`1<CppPreprocessor2Traits> CreateMarkerGuard(NodeType type, bool beforeWs, bool allowEmpty, object userData);
    public sealed virtual LightweightMarkerGuard`1<CppPreprocessor2Traits> CreateMarkerGuard(PrecedeCurrentT _, RollbackT __);
    public sealed virtual LightweightMarkerGuard`1<CppPreprocessor2Traits> CreateMarkerGuard(PrecedeCurrentT _, DropT __);
    public sealed virtual LightweightMarkerGuard`1<CppPreprocessor2Traits> CreateMarkerGuard(PrecedeCurrentT _, NodeType type, bool beforeWs, bool allowEmpty);
    private void CheckInvariant();
    public sealed virtual void AdvanceLexer();
    public sealed virtual void BaseAdvance();
    public sealed virtual void Advance();
    public sealed virtual void ResetTokenCursor();
    public sealed virtual bool IsEmpty(int marker);
    public sealed virtual void Done(int marker, NodeType type, object userData);
    public sealed virtual void DoneBeforeWhitespaces(int marker, NodeType type, object userData);
    public sealed virtual void RollbackTo(int mark);
    public sealed virtual void Drop(int mark);
    public sealed virtual void RawAlter(TokenNodeType tokenType, int count);
    public sealed virtual void Error(string message);
    public sealed virtual void ErrorBeforeWhitespaces(string message);
    public sealed virtual void Error(int mark, string message);
    public sealed virtual int Mark();
    public sealed virtual int PrecedeCurrent();
    public sealed virtual int GetCurrentNonCommentLexeme();
    public sealed virtual void ResetCurrentLexeme(int cur, int curNc);
    public sealed virtual int RawCurrentLexeme();
    public sealed virtual int BaseCurrentLexeme();
    public sealed virtual int CurrentLexeme();
    public void SkipWsImpl();
    public sealed virtual void SkipWs();
    public sealed virtual void SkipDirectives(bool stopByMacroCalls);
    public void SkipDirectivesImpl();
    public sealed virtual void SkipNonMeaningful();
    public sealed virtual TokenNodeType RawTt(bool unwrap);
    public sealed virtual TokenNodeType BaseTt(bool unwrap);
    public sealed virtual TokenNodeType Tt(bool unwrap);
    public sealed virtual string GetTokenText(int index);
    private CppTokenKind BaseTtInner();
    public sealed virtual string RawTokenText();
    public sealed virtual string BaseTokenText();
    public sealed virtual string TokenText();
    public sealed virtual CppComplexOffset RawNavigationOffset();
    public sealed virtual CppComplexOffset BaseNavigationOffset();
    public sealed virtual CppComplexOffset NavigationOffset();
    public void RawFetch();
    public void BaseFetch();
    public void Fetch();
    public sealed virtual void FetchAll();
    public sealed virtual void BaseResync();
    public sealed virtual void Resync();
    public sealed virtual void EnablePreprocessor2Detection(bool value);
    public sealed virtual void AddUdlNameToWordIndex(string suffix);
    public sealed virtual bool HasNewLineBefore(int pos);
    public sealed virtual TokenNodeType TryUnwrap(TokenNodeType tt);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppPsiBuilder : object {
    private ILazyCachingLexer myLexer;
    private List`1<Marker> myProduction;
    private ITokenIntern myTokenIntern;
    private TokenBuffer myTokenBuffer;
    private IArrayOfTokens myArrayOfTokens;
    private int myCurrentLexeme;
    private TokenNodeType myCurrentTokenType;
    private int myNonCommentLexeme;
    private int myLexemeCount;
    private bool myParseWholeFile;
    public CppPsiBuilder(ILazyCachingLexer lexer, ITokenIntern tokenIntern, List`1<Marker> production);
    public CppPsiBuilder(Range range, ITokenIntern tokenIntern, List`1<Marker> production);
    public CompositeElement BuildTree();
    public ILazyCachingLexer GetLexer();
    [CanBeNullAttribute]
public TokenNodeType GetTokenType(int lookahead);
    public string GetTokenTextIntern();
    public string GetTokenTextIntern(int index);
    public int GetTokenOffset();
    public TokenNodeType GetTokenType();
    public int GetCurrentLexeme();
    public int GetCurrentNonCommentLexeme();
    public void ResetCurrentLexeme(int currentLexeme, int currentNonCommentLexeme);
    public bool Eof();
    public int GetLexemeCount();
    public TokenNodeType AdvanceLexer();
    public int Mark();
    public void AlterToken(TokenNodeType newTokenNodeType, int count);
    public int PrecedeCurrent();
    public void RollbackTo(int marker);
    public void Drop(int marker);
    public void Done(int marker, NodeType type, object userData);
    public void DoneBeforeWhitespaces(int marker, NodeType type, object userData);
    public void Error(int marker, string message);
    public void Error(string message);
    public void ErrorBeforeWhitespaces(string message);
    public bool IsEmpty(int markerIdx);
    public object GetLastNodeUserData(int lexemeIndex);
    public void ReplaceChameleon(CppPsiBuilder other, int lexemeIndex, object expectedUserData);
    private void Init();
    private void PrepareLightTree();
    private void AddChild(int node, int child);
    private void Bind(int pRootMarker, CompositeElement rootNode);
    private void InsertLeaves(Int32& curToken, int lastIdx, CompositeElement curNode);
    private LeafElementBase CreateToken(Token token);
    private void UpdateMyCurrentTokenType();
    private void RewindNonCommentLexeme();
    private void DoneImpl(int marker, NodeType type, MarkerType doneMarkerType, object userData);
    private static CompositeElement CreateCompositeElement(Marker item);
    private static bool IsMeaninglessToken(TokenNodeType tt);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Parsing.CppPsiBuilderUtil : object {
    [ExtensionAttribute]
public static TokenNodeType GetRawNodeType(CppPsiBuilder builder);
    [ExtensionAttribute]
public static TokenNodeType GetRawNodeType(ILexer lexer);
    public static CppTokenKind GetRawNodeType(CppPreprocessor2 lexer);
    [ExtensionAttribute]
public static TokenNodeType TryUnwrapFromPreprocessor(TokenNodeType tt);
    [ExtensionAttribute]
public static string GetNodeText(CppPsiBuilder builder);
    [ExtensionAttribute]
public static CppComplexOffset GetNodeOffset(CppPsiBuilder builder);
    [ExtensionAttribute]
public static CppComplexOffset GetNodeOffset(ILexer lexer);
    public static CppComplexOffset GetNodeOffset(CppPreprocessor2 lexer);
    [ExtensionAttribute]
public static bool HasNewLineBefore(ILazyCachingLexer lexer, int pos);
    public static CppPsiBuilder CreatePsiBuilder(ILazyCachingLexer lexer, Lifetime lifetime, CppGlobalSymbolCache cache);
    public static CppPsiBuilder CreatePsiBuilder(ILazyCachingLexer lexer, Lifetime lifetime, ITokenIntern intern, CppGlobalSymbolCache cache);
    public static CppPsiBuilder CreatePsiBuilder(Range range, Lifetime lifetime, CppGlobalSymbolCache cache);
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.CppPSIFreeParsingBase : CppParsingBase`2<CppPsiFreeParsingTraits, LightweightMarkerGuard`1<CppPsiFreeParsingTraits>> {
    public CppPSIFreeParsingBase(ILazyCachingLexer lexer, ICppPreprocessor preprocessor, ICppFileSymbolsCache cache, bool rememberPPUsagesInChameleons);
    public virtual void ParseFunctionBody(ICppFunctionDeclaratorBuilder _, int startLexeme, bool isConstructor, Nullable`1<UInt32> pragmaPack);
    public virtual object CreateDeferredFunctionBodyParsingData(ICppFunctionDeclaratorBuilder _, int startLexeme, bool isConstructor, Nullable`1<UInt32> pragmaPack);
    public virtual void ParseFunctionBody(ICppFunctionDeclaratorBuilder _, object payload);
    public virtual void ParseChameleon(CompositeNodeType chameleonType, TChameleonParser& parse, ICppFunctionDeclaratorBuilder funcBuilder);
    public virtual void LearnFunctionBodyChameleon(ICppFunctionDeclaratorBuilder _);
    public virtual void LearnCtorBlockWithoutBody(ICppFunctionDeclaratorBuilder _);
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.CppPsiFreeParsingTraits : ValueType {
    private CppPSIFreeTokenCursor myTokenCursor;
    private Cursor myRawCursor;
    private Cursor myBaseCursor;
    private Cursor myStandardCursor;
    private ILazyCachingLexer myLexer;
    [CompilerGeneratedAttribute]
private CppParsingBase`2<CppPsiFreeParsingTraits, LightweightMarkerGuard`1<CppPsiFreeParsingTraits>> <Parser>k__BackingField;
    public CppParsingBase`2<CppPsiFreeParsingTraits, LightweightMarkerGuard`1<CppPsiFreeParsingTraits>> Parser { get; public set; }
    public CppPsiFreeParsingTraits(CppParsingBase`2<CppPsiFreeParsingTraits, LightweightMarkerGuard`1<CppPsiFreeParsingTraits>> parsing, ILazyCachingLexer lexer);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CppParsingBase`2<CppPsiFreeParsingTraits, LightweightMarkerGuard`1<CppPsiFreeParsingTraits>> get_Parser();
    [CompilerGeneratedAttribute]
public void set_Parser(CppParsingBase`2<CppPsiFreeParsingTraits, LightweightMarkerGuard`1<CppPsiFreeParsingTraits>> value);
    public sealed virtual LightweightMarkerGuard`1<CppPsiFreeParsingTraits> CreateMarkerGuard(LightweightRollbackT _);
    public sealed virtual LightweightMarkerGuard`1<CppPsiFreeParsingTraits> CreateMarkerGuard(RollbackT _);
    public sealed virtual LightweightMarkerGuard`1<CppPsiFreeParsingTraits> CreateMarkerGuard(DropT _);
    public sealed virtual LightweightMarkerGuard`1<CppPsiFreeParsingTraits> CreateMarkerGuard(NodeType type, bool beforeWs, bool allowEmpty, object userData);
    public sealed virtual LightweightMarkerGuard`1<CppPsiFreeParsingTraits> CreateMarkerGuard(PrecedeCurrentT _, RollbackT __);
    public sealed virtual LightweightMarkerGuard`1<CppPsiFreeParsingTraits> CreateMarkerGuard(PrecedeCurrentT _, DropT __);
    public sealed virtual LightweightMarkerGuard`1<CppPsiFreeParsingTraits> CreateMarkerGuard(PrecedeCurrentT _, NodeType type, bool beforeWs, bool allowEmpty);
    public sealed virtual void AdvanceLexer();
    public sealed virtual void BaseAdvance();
    public sealed virtual void Advance();
    public sealed virtual void ResetTokenCursor();
    public sealed virtual bool IsEmpty(int marker);
    public sealed virtual void Done(int marker, NodeType type, object userData);
    public sealed virtual void DoneBeforeWhitespaces(int marker, NodeType type, object userData);
    public sealed virtual void RollbackTo(int mark);
    public sealed virtual void Drop(int mark);
    public sealed virtual void RawAlter(TokenNodeType tokenType, int count);
    public sealed virtual void Error(string message);
    public sealed virtual void ErrorBeforeWhitespaces(string message);
    public sealed virtual void Error(int mark, string message);
    public sealed virtual int Mark();
    public sealed virtual int PrecedeCurrent();
    public sealed virtual int GetCurrentNonCommentLexeme();
    public sealed virtual void ResetCurrentLexeme(int cur, int cur_nc);
    public sealed virtual int RawCurrentLexeme();
    public sealed virtual int BaseCurrentLexeme();
    public sealed virtual int CurrentLexeme();
    public sealed virtual bool HasNewLineBefore(int pos);
    public sealed virtual void SkipWs();
    public sealed virtual void SkipDirectives(bool stopByMacroCalls);
    public sealed virtual void SkipNonMeaningful();
    public sealed virtual TokenNodeType RawTt(bool unwrap);
    public sealed virtual TokenNodeType BaseTt(bool unwrap);
    public sealed virtual TokenNodeType Tt(bool unwrap);
    public sealed virtual string RawTokenText();
    public sealed virtual string BaseTokenText();
    public sealed virtual string TokenText();
    public sealed virtual CppComplexOffset RawNavigationOffset();
    public sealed virtual CppComplexOffset BaseNavigationOffset();
    public sealed virtual CppComplexOffset NavigationOffset();
    public void RawFetch();
    public void BaseFetch();
    public void Fetch();
    public sealed virtual void FetchAll();
    public sealed virtual void BaseResync();
    public sealed virtual void Resync();
    public sealed virtual void EnablePreprocessor2Detection(bool _);
    public sealed virtual void AddUdlNameToWordIndex(string _);
    public sealed virtual TokenNodeType TryUnwrap(TokenNodeType tt);
    private TokenNodeType UnwrapIfNeeded(bool unwrap, TokenNodeType tt);
    public sealed virtual string GetTokenText(int index);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.CppPsiParsingTraits : ValueType {
    private CppPsiBuilder myPsiBuilder;
    private CppCachingTokenCursor myCachingTokenCursor;
    [CompilerGeneratedAttribute]
private CppParsingBase`2<CppPsiParsingTraits, MarkerGuard`1<CppPsiParsingTraits>> <Parser>k__BackingField;
    public CppParsingBase`2<CppPsiParsingTraits, MarkerGuard`1<CppPsiParsingTraits>> Parser { get; }
    public CppPsiParsingTraits(CppParsingBase`2<CppPsiParsingTraits, MarkerGuard`1<CppPsiParsingTraits>> parsing, CppPsiBuilder psiBuilder, CppCachingTokenCursor cachingTokenCursor);
    [CompilerGeneratedAttribute]
public CppParsingBase`2<CppPsiParsingTraits, MarkerGuard`1<CppPsiParsingTraits>> get_Parser();
    public sealed virtual MarkerGuard`1<CppPsiParsingTraits> CreateMarkerGuard(LightweightRollbackT _);
    public sealed virtual MarkerGuard`1<CppPsiParsingTraits> CreateMarkerGuard(RollbackT _);
    public sealed virtual MarkerGuard`1<CppPsiParsingTraits> CreateMarkerGuard(DropT _);
    public sealed virtual MarkerGuard`1<CppPsiParsingTraits> CreateMarkerGuard(NodeType type, bool beforeWs, bool allowEmpty, object userData);
    public sealed virtual MarkerGuard`1<CppPsiParsingTraits> CreateMarkerGuard(PrecedeCurrentT _, RollbackT __);
    public sealed virtual MarkerGuard`1<CppPsiParsingTraits> CreateMarkerGuard(PrecedeCurrentT _, DropT __);
    public sealed virtual MarkerGuard`1<CppPsiParsingTraits> CreateMarkerGuard(PrecedeCurrentT _, NodeType type, bool beforeWs, bool allowEmpty);
    public sealed virtual void AdvanceLexer();
    public sealed virtual void BaseAdvance();
    public sealed virtual void Advance();
    public sealed virtual void ResetTokenCursor();
    public sealed virtual bool IsEmpty(int marker);
    public sealed virtual void Done(int marker, NodeType type, object userData);
    public sealed virtual void DoneBeforeWhitespaces(int marker, NodeType type, object userData);
    public sealed virtual void RollbackTo(int mark);
    public sealed virtual void Drop(int mark);
    public sealed virtual void RawAlter(TokenNodeType tokenType, int count);
    public sealed virtual void FetchAll();
    public sealed virtual void Error(string message);
    public sealed virtual void ErrorBeforeWhitespaces(string message);
    public sealed virtual void Error(int mark, string message);
    public sealed virtual int Mark();
    public sealed virtual int PrecedeCurrent();
    public sealed virtual int GetCurrentNonCommentLexeme();
    public sealed virtual void ResetCurrentLexeme(int current, int currentNc);
    public sealed virtual int RawCurrentLexeme();
    public sealed virtual int BaseCurrentLexeme();
    public sealed virtual int CurrentLexeme();
    public sealed virtual bool HasNewLineBefore(int pos);
    public sealed virtual void SkipWs();
    public sealed virtual void SkipDirectives(bool stopByMacroCalls);
    public sealed virtual void SkipNonMeaningful();
    public sealed virtual TokenNodeType RawTt(bool unwrap);
    public sealed virtual TokenNodeType BaseTt(bool unwrap);
    public sealed virtual TokenNodeType Tt(bool unwrap);
    public sealed virtual string GetTokenText(int index);
    public sealed virtual string RawTokenText();
    public sealed virtual string BaseTokenText();
    public sealed virtual string TokenText();
    public sealed virtual CppComplexOffset RawNavigationOffset();
    public sealed virtual CppComplexOffset BaseNavigationOffset();
    public sealed virtual CppComplexOffset NavigationOffset();
    public sealed virtual void BaseResync();
    public sealed virtual void Resync();
    public sealed virtual void EnablePreprocessor2Detection(bool val);
    public sealed virtual void AddUdlNameToWordIndex(string name);
    public sealed virtual TokenNodeType TryUnwrap(TokenNodeType tt);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppPunctuatorTokenNodeType : CppSingletonTokenNodeType {
    public CppPunctuatorTokenNodeType(string s, CppTokenKind kind, string text);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppPunctuatorWithAlternativeTextTokenNodeType : CppPunctuatorTokenNodeType {
    [CompilerGeneratedAttribute]
private string <AlternativeTokenRepresentation>k__BackingField;
    public string AlternativeTokenRepresentation { get; }
    public CppPunctuatorWithAlternativeTextTokenNodeType(string s, CppTokenKind kind, string text, string alternativeText);
    [CompilerGeneratedAttribute]
public string get_AlternativeTokenRepresentation();
    public virtual LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Parsing.CppSingletonTokenNodeType : CppGenericTokenNodeType {
    protected CppSingletonTokenNodeType(string s, CppTokenKind kind, string text);
    public virtual LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppStaticWhitespaceRepresentationTokenNodeType : CppGenericTokenNodeType {
    public CppStaticWhitespaceRepresentationTokenNodeType(string s, CppTokenKind kind, string repr);
    public virtual LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
    private static bool IsAllEqualTo(IBuffer buf, int start, int end, char c);
}
public enum JetBrains.ReSharper.Psi.Cpp.Parsing.CppTokenKind : Enum {
    public short value__;
    public static CppTokenKind INVALID;
    public static CppTokenKind EOF;
    public static CppTokenKind WHITE_SPACE;
    public static CppTokenKind NEW_LINE;
    public static CppTokenKind UNKNOWN_TOKEN;
    public static CppTokenKind CLOSED_CHAMELEON_TOKEN;
    public static CppTokenKind __IDENTIFIER_KEYWORD;
    public static CppTokenKind IDENTIFIER;
    public static CppTokenKind CONCEPT_KEYWORD;
    public static CppTokenKind REQUIRES_KEYWORD;
    public static CppTokenKind __IS_SIGNED;
    public static CppTokenKind __ADD_POINTER;
    public static CppTokenKind __ADD_LVALUE_REFERENCE;
    public static CppTokenKind __ADD_RVALUE_REFERENCE;
    public static CppTokenKind __DECAY;
    public static CppTokenKind __MAKE_SIGNED;
    public static CppTokenKind __MAKE_UNSIGNED;
    public static CppTokenKind __REMOVE_CONST;
    public static CppTokenKind __REMOVE_VOLATILE;
    public static CppTokenKind __REMOVE_CV;
    public static CppTokenKind __REMOVE_CVREF;
    public static CppTokenKind __REMOVE_REFERENCE;
    public static CppTokenKind __REMOVE_POINTER;
    public static CppTokenKind __REMOVE_EXTENT;
    public static CppTokenKind __REMOVE_ALL_EXTENTS;
    public static CppTokenKind EXPAND_DISABLED_IDENTIFIER;
    public static CppTokenKind HASHED_IDENTIFIER;
    public static CppTokenKind DIRECTIVE_CONTENT;
    public static CppTokenKind CODE_DIRECTIVE_CONTENT;
    public static CppTokenKind INCLUDE_DIRECTIVE_CONTENT;
    public static CppTokenKind END_OF_DIRECTIVE_CONTENT;
    public static CppTokenKind IF_DIRECTIVE;
    public static CppTokenKind IFDEF_DIRECTIVE;
    public static CppTokenKind IFNDEF_DIRECTIVE;
    public static CppTokenKind ELIF_DIRECTIVE;
    public static CppTokenKind ELIFDEF_DIRECTIVE;
    public static CppTokenKind ELIFNDEF_DIRECTIVE;
    public static CppTokenKind ELSE_DIRECTIVE;
    public static CppTokenKind ENDIF_DIRECTIVE;
    public static CppTokenKind INCLUDE_DIRECTIVE;
    public static CppTokenKind INCLUDE_NEXT_DIRECTIVE;
    public static CppTokenKind INCLUDE_WITH_PRAGMAS_DIRECTIVE;
    public static CppTokenKind IMPORT_DIRECTIVE;
    public static CppTokenKind DEFINE_DIRECTIVE;
    public static CppTokenKind UNDEF_DIRECTIVE;
    public static CppTokenKind LINE_DIRECTIVE;
    public static CppTokenKind ERROR_DIRECTIVE;
    public static CppTokenKind WARNING_DIRECTIVE;
    public static CppTokenKind PRAGMA_DIRECTIVE;
    public static CppTokenKind CPP20_IMPORT_DIRECTIVE;
    public static CppTokenKind CPP20_MODULE_DIRECTIVE;
    public static CppTokenKind EMPTY_DIRECTIVE;
    public static CppTokenKind UNKNOWN_DIRECTIVE;
    public static CppTokenKind EOL_ESCAPE;
    public static CppTokenKind NUMERIC_LITERAL;
    public static CppTokenKind CHARACTER_LITERAL;
    public static CppTokenKind STRING_LITERAL;
    public static CppTokenKind FAKE_TRUE;
    public static CppTokenKind FAKE_FALSE;
    public static CppTokenKind RETRY;
    public static CppTokenKind DOXYGEN_EOL_COMMENT_PREFIX;
    public static CppTokenKind DOXYGEN_MULTILINE_COMMENT_PREFIX;
    public static CppTokenKind DOXYGEN_MULTILINE_COMMENT_POSTFIX;
    public static CppTokenKind DOXYGEN_QUOTE;
    public static CppTokenKind AT;
    public static CppTokenKind BLOCK_COMMENT;
    public static CppTokenKind UNFINISHED_BLOCK_COMMENT;
    public static CppTokenKind GENERATED_COMMENT;
    public static CppTokenKind EOL_COMMENT;
    public static CppTokenKind DOXYGEN_EOL_COMMENT_BLOCK;
    public static CppTokenKind CONDITIONALLY_NOT_COMPILED_CODE;
    public static CppTokenKind AUTO_KEYWORD;
    public static CppTokenKind BREAK_KEYWORD;
    public static CppTokenKind CASE_KEYWORD;
    public static CppTokenKind CHAR_KEYWORD;
    public static CppTokenKind CONST_KEYWORD;
    public static CppTokenKind CONTINUE_KEYWORD;
    public static CppTokenKind DEFAULT_KEYWORD;
    public static CppTokenKind DO_KEYWORD;
    public static CppTokenKind DOUBLE_KEYWORD;
    public static CppTokenKind ELSE_KEYWORD;
    public static CppTokenKind ENUM_KEYWORD;
    public static CppTokenKind EXTERN_KEYWORD;
    public static CppTokenKind FLOAT_KEYWORD;
    public static CppTokenKind FOR_KEYWORD;
    public static CppTokenKind GOTO_KEYWORD;
    public static CppTokenKind IF_KEYWORD;
    public static CppTokenKind INLINE_KEYWORD;
    public static CppTokenKind INT_KEYWORD;
    public static CppTokenKind LONG_KEYWORD;
    public static CppTokenKind REGISTER_KEYWORD;
    public static CppTokenKind RESTRICT_KEYWORD;
    public static CppTokenKind RETURN_KEYWORD;
    public static CppTokenKind SHORT_KEYWORD;
    public static CppTokenKind SIGNED_KEYWORD;
    public static CppTokenKind SIZEOF_KEYWORD;
    public static CppTokenKind STATIC_KEYWORD;
    public static CppTokenKind STRUCT_KEYWORD;
    public static CppTokenKind SWITCH_KEYWORD;
    public static CppTokenKind TYPEDEF_KEYWORD;
    public static CppTokenKind UNION_KEYWORD;
    public static CppTokenKind UNSIGNED_KEYWORD;
    public static CppTokenKind VOID_KEYWORD;
    public static CppTokenKind VOLATILE_KEYWORD;
    public static CppTokenKind WHILE_KEYWORD;
    public static CppTokenKind C11_ALIGNAS_KEYWORD;
    public static CppTokenKind C11_ALIGNOF_KEYWORD;
    public static CppTokenKind C11_ATOMIC_KEYWORD;
    public static CppTokenKind C11_BOOL_KEYWORD;
    public static CppTokenKind C11_COMPLEX_KEYWORD;
    public static CppTokenKind C11_GENERIC_KEYWORD;
    public static CppTokenKind C11_IMAGINARY_KEYWORD;
    public static CppTokenKind C11_NORETURN_KEYWORD;
    public static CppTokenKind C11_STATIC_ASSERT_KEYWORD;
    public static CppTokenKind C11_THREAD_LOCAL_KEYWORD;
    public static CppTokenKind ASM_KEYWORD;
    public static CppTokenKind BOOL_KEYWORD;
    public static CppTokenKind CATCH_KEYWORD;
    public static CppTokenKind CLASS_KEYWORD;
    public static CppTokenKind CONST_CAST_KEYWORD;
    public static CppTokenKind DELETE_KEYWORD;
    public static CppTokenKind DYNAMIC_CAST_KEYWORD;
    public static CppTokenKind EXPLICIT_KEYWORD;
    public static CppTokenKind EXPORT_KEYWORD;
    public static CppTokenKind FALSE_KEYWORD;
    public static CppTokenKind FRIEND_KEYWORD;
    public static CppTokenKind MUTABLE_KEYWORD;
    public static CppTokenKind NAMESPACE_KEYWORD;
    public static CppTokenKind NEW_KEYWORD;
    public static CppTokenKind OPERATOR_KEYWORD;
    public static CppTokenKind PRIVATE_KEYWORD;
    public static CppTokenKind PUBLIC_KEYWORD;
    public static CppTokenKind PROTECTED_KEYWORD;
    public static CppTokenKind REINTERPRET_CAST_KEYWORD;
    public static CppTokenKind STATIC_CAST_KEYWORD;
    public static CppTokenKind TEMPLATE_KEYWORD;
    public static CppTokenKind THIS_KEYWORD;
    public static CppTokenKind THROW_KEYWORD;
    public static CppTokenKind TRUE_KEYWORD;
    public static CppTokenKind TRY_KEYWORD;
    public static CppTokenKind TYPENAME_KEYWORD;
    public static CppTokenKind TYPEID_KEYWORD;
    public static CppTokenKind USING_KEYWORD;
    public static CppTokenKind VIRTUAL_KEYWORD;
    public static CppTokenKind WCHAR_T_KEYWORD;
    public static CppTokenKind __FUNCTION__KEYWORD;
    public static CppTokenKind __FUNCSIG__KEYWORD;
    public static CppTokenKind __FUNCDNAME__KEYWORD;
    public static CppTokenKind __PRETTY_FUNCTION__KEYWORD;
    public static CppTokenKind ALIGNAS_KEYWORD;
    public static CppTokenKind ALIGNOF_KEYWORD;
    public static CppTokenKind CHAR8_T_KEYWORD;
    public static CppTokenKind CHAR16_T_KEYWORD;
    public static CppTokenKind CHAR32_T_KEYWORD;
    public static CppTokenKind CONSTEXPR_KEYWORD;
    public static CppTokenKind CONSTEVAL_KEYWORD;
    public static CppTokenKind CONSTINIT_KEYWORD;
    public static CppTokenKind DECLTYPE_KEYWORD;
    public static CppTokenKind NOEXCEPT_KEYWORD;
    public static CppTokenKind NULLPTR_KEYWORD;
    public static CppTokenKind STATIC_ASSERT_KEYWORD;
    public static CppTokenKind THREAD_LOCAL_KEYWORD;
    public static CppTokenKind FINAL_KEYWORD;
    public static CppTokenKind OVERRIDE_KEYWORD;
    public static CppTokenKind IMPORT_KEYWORD;
    public static CppTokenKind MODULE_KEYWORD;
    public static CppTokenKind CXXCLI_GENERIC_KEYWORD;
    public static CppTokenKind CXXCLI_WHERE_KEYWORD;
    public static CppTokenKind CXXCLI_REF_KEYWORD;
    public static CppTokenKind CXXCLI_VALUE_KEYWORD;
    public static CppTokenKind CXXCLI_INTERFACE_KEYWORD;
    public static CppTokenKind CXXCLI_GCNEW_KEYWORD;
    public static CppTokenKind CXXCLI_SAFE_CAST_KEYWORD;
    public static CppTokenKind CXXCLI_INITONLY_KEYWORD;
    public static CppTokenKind CXXCLI_LITERAL_KEYWORD;
    public static CppTokenKind CXXCLI_INTERNAL_KEYWORD;
    public static CppTokenKind CXXCLI_PROPERTY_KEYWORD;
    public static CppTokenKind CXXCLI_EVENT_KEYWORD;
    public static CppTokenKind CXXCLI_DELEGATE_KEYWORD;
    public static CppTokenKind CXXCLI_FINALLY_KEYWORD;
    public static CppTokenKind __HAS_ASSIGN;
    public static CppTokenKind __HAS_COPY;
    public static CppTokenKind __HAS_FINALIZER;
    public static CppTokenKind __HAS_NOTHROW_ASSIGN;
    public static CppTokenKind __HAS_NOTHROW_CONSTRUCTOR;
    public static CppTokenKind __HAS_NOTHROW_COPY;
    public static CppTokenKind __HAS_TRIVIAL_ASSIGN;
    public static CppTokenKind __HAS_TRIVIAL_CONSTRUCTOR;
    public static CppTokenKind __HAS_TRIVIAL_COPY;
    public static CppTokenKind __HAS_TRIVIAL_DESTRUCTOR;
    public static CppTokenKind __HAS_USER_DESTRUCTOR;
    public static CppTokenKind __HAS_VIRTUAL_DESTRUCTOR;
    public static CppTokenKind __IS_ABSTRACT;
    public static CppTokenKind __IS_AGGREGATE;
    public static CppTokenKind __IS_ASSIGNABLE;
    public static CppTokenKind __IS_BASE_OF;
    public static CppTokenKind __IS_CLASS;
    public static CppTokenKind __IS_CONVERTIBLE_TO;
    public static CppTokenKind __IS_DELEGATE;
    public static CppTokenKind __IS_EMPTY;
    public static CppTokenKind __IS_ENUM;
    public static CppTokenKind __IS_FINAL;
    public static CppTokenKind __IS_INTERFACE_CLASS;
    public static CppTokenKind __IS_POD;
    public static CppTokenKind __IS_POLYMORPHIC;
    public static CppTokenKind __IS_REF_ARRAY;
    public static CppTokenKind __IS_REF_CLASS;
    public static CppTokenKind __IS_SEALED;
    public static CppTokenKind __IS_SIMPLE_VALUE_CLASS;
    public static CppTokenKind __IS_UNION;
    public static CppTokenKind __IS_VALUE_CLASS;
    public static CppTokenKind __IS_STANDARD_LAYOUT;
    public static CppTokenKind __IS_LITERAL;
    public static CppTokenKind __IS_LITERAL_TYPE;
    public static CppTokenKind __IS_TRIVIAL;
    public static CppTokenKind __HAS_TRIVIAL_MOVE_CONSTRUCTOR;
    public static CppTokenKind __HAS_TRIVIAL_MOVE_ASSIGN;
    public static CppTokenKind __HAS_NOTHROW_MOVE_ASSIGN;
    public static CppTokenKind __IS_TRIVIALLY_COPYABLE;
    public static CppTokenKind __IS_CONSTRUCTIBLE;
    public static CppTokenKind __IS_DESTRUCTIBLE;
    public static CppTokenKind __IS_TRIVIALLY_CONSTRUCTIBLE;
    public static CppTokenKind __IS_TRIVIALLY_ASSIGNABLE;
    public static CppTokenKind __IS_NOTHROW_CONSTRUCTIBLE;
    public static CppTokenKind __IS_NOTHROW_ASSIGNABLE;
    public static CppTokenKind __IS_NOTHROW_DESTRUCTIBLE;
    public static CppTokenKind __IS_TRIVIALLY_DESTRUCTIBLE;
    public static CppTokenKind __HAS_UNIQUE_OBJECT_REPRSENTATIONS;
    public static CppTokenKind __IS_SAME;
    public static CppTokenKind __IS_SAME_AS;
    public static CppTokenKind __IS_LAYOUT_COMPATIBLE;
    public static CppTokenKind __IS_POINTER_INTERCONVERTIBLE_BASE_OF;
    public static CppTokenKind __REFERENCE_CONSTRUCTS_FROM_TEMPORARY;
    public static CppTokenKind __REFERENCE_CONVERTS_FROM_TEMPORARY;
    public static CppTokenKind __IS_CONVERTIBLE;
    public static CppTokenKind __IS_NOTHROW_CONVERTIBLE;
    public static CppTokenKind CO_RETURN_KEYWORD;
    public static CppTokenKind CO_AWAIT_KEYWORD;
    public static CppTokenKind CO_YIELD_KEYWORD;
    public static CppTokenKind __IS_FUNCTION;
    public static CppTokenKind __IS_OBJECT;
    public static CppTokenKind __IS_ARRAY;
    public static CppTokenKind __IS_UNBOUNDED_ARRAY;
    public static CppTokenKind __IS_POINTER;
    public static CppTokenKind __IS_MEMBER_POINTER;
    public static CppTokenKind __IS_MEMBER_FUNCTION_POINTER;
    public static CppTokenKind __IS_MEMBER_OBJECT_POINTER;
    public static CppTokenKind __IS_REFERENCE;
    public static CppTokenKind __IS_LVALUE_REFERENCE;
    public static CppTokenKind __IS_RVALUE_REFERENCE;
    public static CppTokenKind __IS_CONST;
    public static CppTokenKind __IS_VOLATILE;
    public static CppTokenKind __IS_NULLPTR;
    public static CppTokenKind __IS_SCALAR;
    public static CppTokenKind __IS_ARITHMETIC;
    public static CppTokenKind __IS_COMPOUND;
    public static CppTokenKind __IS_FUNDAMENTAL;
    public static CppTokenKind __IS_COMPLETE_TYPE;
    public static CppTokenKind __IS_UNSIGNED;
    public static CppTokenKind __IS_VOID;
    public static CppTokenKind __IS_INTEGRAL;
    public static CppTokenKind __IS_FLOATING_POINT;
    public static CppTokenKind _DECL_SPEC_KEYWORD;
    public static CppTokenKind __DECL_SPEC_KEYWORD;
    public static CppTokenKind _CDECL_KEYWORD;
    public static CppTokenKind __CDECL_KEYWORD;
    public static CppTokenKind __CLRCALL_KEYWORD;
    public static CppTokenKind _STDCALL_KEYWORD;
    public static CppTokenKind __STDCALL_KEYWORD;
    public static CppTokenKind _FASTCALL_KEYWORD;
    public static CppTokenKind __FASTCALL_KEYWORD;
    public static CppTokenKind _THISCALL_KEYWORD;
    public static CppTokenKind __THISCALL_KEYWORD;
    public static CppTokenKind _VECTORCALL_KEYWORD;
    public static CppTokenKind __VECTORCALL_KEYWORD;
    public static CppTokenKind _FORCEINLINE_KEYWORD;
    public static CppTokenKind __FORCEINLINE_KEYWORD;
    public static CppTokenKind _UNALIGNED_KEYWORD;
    public static CppTokenKind __UNALIGNED_KEYWORD;
    public static CppTokenKind __UNDERLYING_TYPE;
    public static CppTokenKind SEALED_KEYWORD;
    public static CppTokenKind ABSTRACT_KEYWORD;
    public static CppTokenKind TILE_STATIC_KEYWORD;
    public static CppTokenKind HALF_KEYWORD;
    public static CppTokenKind VECTOR_KEYWORD;
    public static CppTokenKind MATRIX_KEYWORD;
    public static CppTokenKind STRING_KEYWORD;
    public static CppTokenKind SNORM_KEYWORD;
    public static CppTokenKind UNORM_KEYWORD;
    public static CppTokenKind SAMPLER1D_KEYWORD;
    public static CppTokenKind SAMPLER2D_KEYWORD;
    public static CppTokenKind SAMPLER3D_KEYWORD;
    public static CppTokenKind SAMPLERCUBE_KEYWORD;
    public static CppTokenKind SAMPLERSTATE_KEYWORD;
    public static CppTokenKind SAMPLER_COMPARISON_STATE_KEYWORD;
    public static CppTokenKind DISCARD_KEYWORD;
    public static CppTokenKind PACKOFFSET_KEYWORD;
    public static CppTokenKind IN_KEYWORD;
    public static CppTokenKind OUT_KEYWORD;
    public static CppTokenKind INOUT_KEYWORD;
    public static CppTokenKind PRECISE_KEYWORD;
    public static CppTokenKind SHARED_KEYWORD;
    public static CppTokenKind GROUPSHARED_KEYWORD;
    public static CppTokenKind UNIFORM_KEYWORD;
    public static CppTokenKind ROW_MAJOR_KEYWORD;
    public static CppTokenKind COLUMN_MAJOR_KEYWORD;
    public static CppTokenKind LINEAR_KEYWORD;
    public static CppTokenKind CENTROID_KEYWORD;
    public static CppTokenKind NOINTERPOLATION_KEYWORD;
    public static CppTokenKind NOPERSPECTIVE_KEYWORD;
    public static CppTokenKind SAMPLE_KEYWORD;
    public static CppTokenKind POINT_KEYWORD;
    public static CppTokenKind LINE_KEYWORD;
    public static CppTokenKind TRIANGLE_KEYWORD;
    public static CppTokenKind LINEADJ_KEYWORD;
    public static CppTokenKind TRIANGLEADJ_KEYWORD;
    public static CppTokenKind CBUFFER_KEYWORD;
    public static CppTokenKind TBUFFER_KEYWORD;
    public static CppTokenKind CONSTANT_BUFFER_KEYWORD;
    public static CppTokenKind TEXTURE_BUFFER_KEYWORD;
    public static CppTokenKind BS_IMPORTS_KEYWORD;
    public static CppTokenKind BS_BLOCK_KEYWORD;
    public static CppTokenKind BS_INTERFACE_KEYWORD;
    public static CppTokenKind BS_FUNCTION_KEYWORD;
    public static CppTokenKind BS_STRUCT_KEYWORD;
    public static CppTokenKind BS_INCLUDES_KEYWORD;
    public static CppTokenKind BS_RESOURCE_KEYWORD;
    public static CppTokenKind BS_BLOCK_SHADER_INTERFACE_KEYWORD;
    public static CppTokenKind BS_CUSTOMIZATION_POINT_KEYWORD;
    public static CppTokenKind BS_REGISTER_TEMPLATE_WITH_INTERFACE_KEYWORD;
    public static CppTokenKind BS_KEYWORDS_KEYWORD;
    public static CppTokenKind BS_BLOCK_SHADER_KEYWORD;
    public static CppTokenKind BS_IMPLEMENTS_KEYWORD;
    public static CppTokenKind BS_IMPLEMENTATION_KEYWORD;
    public static CppTokenKind BS_TEMPLATE_KEYWORD;
    public static CppTokenKind BS_PASS_KEYWORD;
    public static CppTokenKind BS_PRAGMAS_KEYWORD;
    public static CppTokenKind BS_VERTEX_STAGE_KEYWORD;
    public static CppTokenKind BS_FRAGMENT_STAGE_KEYWORD;
    public static CppTokenKind BS_HULL_MAPPING_STAGE_KEYWORD;
    public static CppTokenKind BS_HULL_POST_STAGE_KEYWORD;
    public static CppTokenKind BS_HULL_CONSTANT_STAGE_KEYWORD;
    public static CppTokenKind BS_DOMAIN_MAPPING_STAGE_KEYWORD;
    public static CppTokenKind BS_DOMAIN_POST_STAGE_KEYWORD;
    public static CppTokenKind BS_SETUP_KEYWORD;
    public static CppTokenKind BS_TAGS_KEYWORD;
    public static CppTokenKind BS_DEFAULT_KEYWORD;
    public static CppTokenKind BS_DISCARD_KEYWORD;
    public static CppTokenKind BS_EXTENDS_KEYWORD;
    public static CppTokenKind BS_RENDER_STATES_KEYWORD;
    public static CppTokenKind __PRAGMA_KEYWORD;
    public static CppTokenKind __NULLPTR_KEYWORD;
    public static CppTokenKind __NULL_KEYWORD;
    public static CppTokenKind __AUTO_TYPE_KEYWORD;
    public static CppTokenKind _PTR64_KEYWORD;
    public static CppTokenKind __PTR64_KEYWORD;
    public static CppTokenKind _PTR32_KEYWORD;
    public static CppTokenKind __PTR32_KEYWORD;
    public static CppTokenKind _SPTR_KEYWORD;
    public static CppTokenKind __SPTR_KEYWORD;
    public static CppTokenKind _UPTR_KEYWORD;
    public static CppTokenKind __UPTR_KEYWORD;
    public static CppTokenKind _W64_KEYWORD;
    public static CppTokenKind __W64_KEYWORD;
    public static CppTokenKind _UUIDOF_KEYWORD;
    public static CppTokenKind __UUIDOF_KEYWORD;
    public static CppTokenKind _ALIGNOF_KEYWORD;
    public static CppTokenKind __ALIGNOF_KEYWORD;
    public static CppTokenKind __ALIGNOF___KEYWORD;
    public static CppTokenKind TYPEOF_KEYWORD;
    public static CppTokenKind TYPEOF_UNQUAL_KEYWORD;
    public static CppTokenKind __TYPEOF_KEYWORD;
    public static CppTokenKind __TYPEOF___KEYWORD;
    public static CppTokenKind __TYPEOF_UNQUAL___KEYWORD;
    public static CppTokenKind __BUILTIN_ALIGNOF_KEYWORD;
    public static CppTokenKind __BUILTIN_ADDRESSOF_KEYWORD;
    public static CppTokenKind __BUILTIN_OFFSETOF_KEYWORD;
    public static CppTokenKind __BUILTIN_CONSTANT_P_KEYWORD;
    public static CppTokenKind __BUILTIN_TYPES_COMPATIBLE_P_KEYWORD;
    public static CppTokenKind __BUILTIN_CHOOSE_EXPR_KEYWORD;
    public static CppTokenKind _TRY_KEYWORD;
    public static CppTokenKind __TRY_KEYWORD;
    public static CppTokenKind _EXCEPT_KEYWORD;
    public static CppTokenKind __EXCEPT_KEYWORD;
    public static CppTokenKind _FINALLY_KEYWORD;
    public static CppTokenKind __FINALLY_KEYWORD;
    public static CppTokenKind _LEAVE_KEYWORD;
    public static CppTokenKind __LEAVE_KEYWORD;
    public static CppTokenKind _ASM_KEYWORD;
    public static CppTokenKind __ASM_KEYWORD;
    public static CppTokenKind __ASM___KEYWORD;
    public static CppTokenKind _INLINE_KEYWORD;
    public static CppTokenKind __INLINE_KEYWORD;
    public static CppTokenKind __INLINE___KEYWORD;
    public static CppTokenKind _RESTRICT_KEYWORD;
    public static CppTokenKind __RESTRICT_KEYWORD;
    public static CppTokenKind __RESTRICT___KEYWORD;
    public static CppTokenKind __INTERFACE_KEYWORD;
    public static CppTokenKind INTERFACE_KEYWORD;
    public static CppTokenKind __WCHAR_T_KEYWORD;
    public static CppTokenKind _INT8_KEYWORD;
    public static CppTokenKind __INT8_KEYWORD;
    public static CppTokenKind _INT16_KEYWORD;
    public static CppTokenKind __INT16_KEYWORD;
    public static CppTokenKind _INT32_KEYWORD;
    public static CppTokenKind __INT32_KEYWORD;
    public static CppTokenKind _INT64_KEYWORD;
    public static CppTokenKind __INT64_KEYWORD;
    public static CppTokenKind __INT128_KEYWORD;
    public static CppTokenKind __INT128_T_KEYWORD;
    public static CppTokenKind __UINT128_T_KEYWORD;
    public static CppTokenKind __IF_EXIST_KEYWORD;
    public static CppTokenKind __IF_NOT_EXIST_KEYWORD;
    public static CppTokenKind __NOOP_KEYWORD;
    public static CppTokenKind _ASSUME_KEYWORD;
    public static CppTokenKind __ASSUME_KEYWORD;
    public static CppTokenKind __LPREFIX_KEYWORD;
    public static CppTokenKind __SUPER_KEYWORD;
    public static CppTokenKind __EVENT_KEYWORD;
    public static CppTokenKind __RAISE_KEYWORD;
    public static CppTokenKind __HOOK_KEYWORD;
    public static CppTokenKind __UNHOOK_KEYWORD;
    public static CppTokenKind _SINGLE_INHERITANCE;
    public static CppTokenKind __SINGLE_INHERITANCE;
    public static CppTokenKind _MULTIPLE_INHERITANCE;
    public static CppTokenKind __MULTIPLE_INHERITANCE;
    public static CppTokenKind _VIRTUAL_INHERITANCE;
    public static CppTokenKind __VIRTUAL_INHERITANCE;
    public static CppTokenKind __ATTRIBUTE_KEYWORD;
    public static CppTokenKind __ATTRIBUTE___KEYWORD;
    public static CppTokenKind __RESHARPER_UNKNOWN_TYPE;
    public static CppTokenKind __RESHARPER_DISABLE_SYNTAX_DETECTORS;
    public static CppTokenKind __RESHARPER_ENABLE_SYNTAX_DETECTORS;
    public static CppTokenKind __RESHARPER_UE4_UCLASS;
    public static CppTokenKind __RESHARPER_UE4_USTRUCT;
    public static CppTokenKind __RESHARPER_UE4_UENUM;
    public static CppTokenKind __RESHARPER_UE4_UINTERFACE;
    public static CppTokenKind __RESHARPER_UE4_GENERATED_BODY;
    public static CppTokenKind __RESHARPER_UE4_GENERATED_BODY_LEGACY;
    public static CppTokenKind __RESHARPER_UE4_UFUNCTION;
    public static CppTokenKind __RESHARPER_UE4_UPROPERTY;
    public static CppTokenKind __RESHARPER_UE4_RIGVM_METHOD;
    public static CppTokenKind __RESHARPER_GG_DECLARE_HUNGARIAN;
    public static CppTokenKind LBRACKET;
    public static CppTokenKind RBRACKET;
    public static CppTokenKind LBRACE;
    public static CppTokenKind RBRACE;
    public static CppTokenKind LPAR;
    public static CppTokenKind RPAR;
    public static CppTokenKind DOT;
    public static CppTokenKind DEREF;
    public static CppTokenKind DOTMUL;
    public static CppTokenKind DEREFMUL;
    public static CppTokenKind PLUSPLUS;
    public static CppTokenKind MINUSMINUS;
    public static CppTokenKind AND;
    public static CppTokenKind MUL;
    public static CppTokenKind PLUS;
    public static CppTokenKind MINUS;
    public static CppTokenKind TILDE;
    public static CppTokenKind EXCL;
    public static CppTokenKind DIV;
    public static CppTokenKind PERC;
    public static CppTokenKind LTLT;
    public static CppTokenKind GTGT;
    public static CppTokenKind LT;
    public static CppTokenKind GT;
    public static CppTokenKind LTEQ;
    public static CppTokenKind GTEQ;
    public static CppTokenKind EQEQ;
    public static CppTokenKind LTEQGT;
    public static CppTokenKind EXCLEQ;
    public static CppTokenKind XOR;
    public static CppTokenKind OR;
    public static CppTokenKind ANDAND;
    public static CppTokenKind OROR;
    public static CppTokenKind QUEST;
    public static CppTokenKind COLON;
    public static CppTokenKind COLON2X;
    public static CppTokenKind SEMICOLON;
    public static CppTokenKind ELLIPSIS;
    public static CppTokenKind EQ;
    public static CppTokenKind MULTEQ;
    public static CppTokenKind DIVEQ;
    public static CppTokenKind PERCEQ;
    public static CppTokenKind PLUSEQ;
    public static CppTokenKind MINUSEQ;
    public static CppTokenKind LTLTEQ;
    public static CppTokenKind GTGTEQ;
    public static CppTokenKind ANDEQ;
    public static CppTokenKind XOREQ;
    public static CppTokenKind OREQ;
    public static CppTokenKind COMMA;
    public static CppTokenKind HASH;
    public static CppTokenKind HASHHASH;
    public static CppTokenKind HASHAT;
    public static CppTokenKind BACKSLASH;
    public static CppTokenKind AND_KEYWORD;
    public static CppTokenKind TILDE_KEYWORD;
    public static CppTokenKind EXCL_KEYWORD;
    public static CppTokenKind EXCLEQ_KEYWORD;
    public static CppTokenKind XOR_KEYWORD;
    public static CppTokenKind OR_KEYWORD;
    public static CppTokenKind ANDAND_KEYWORD;
    public static CppTokenKind OROR_KEYWORD;
    public static CppTokenKind ANDEQ_KEYWORD;
    public static CppTokenKind XOREQ_KEYWORD;
    public static CppTokenKind OREQ_KEYWORD;
    public static CppTokenKind _NUMBER_OF_ELEMENTS_;
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Parsing.CppTokenNodeBase : LeafElementBase {
    public PsiLanguageType Language { get; }
    public virtual TokenNodeType GetTokenType();
    public virtual StringBuilder GetText(StringBuilder to);
    public virtual IBuffer GetTextAsBuffer();
    public virtual int GetTextLength();
    public virtual PsiLanguageType get_Language();
    public virtual bool IsFiltered();
    public virtual TResult Accept(CppTreeNodeVisitor`1<TResult> visitor);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Parsing.CppTokenNodeType : TokenNodeType {
    private static CppTokenNodeType[] ourTokenByIndex;
    public bool IsWhitespace { get; }
    public bool IsComment { get; }
    public bool IsStringLiteral { get; }
    public bool IsConstantLiteral { get; }
    public bool IsIdentifier { get; }
    public bool IsKeyword { get; }
    protected CppTokenNodeType(string s, CppTokenKind kind);
    private static CppTokenNodeType();
    public virtual bool get_IsWhitespace();
    public virtual bool get_IsComment();
    public virtual bool get_IsStringLiteral();
    public virtual bool get_IsConstantLiteral();
    public virtual bool get_IsIdentifier();
    public virtual bool get_IsKeyword();
    private static int GetIndex(CppTokenKind kind);
    public CppTokenKind Kind();
    public static CppTokenNodeType Get(CppTokenKind kind);
    public virtual LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppTokenNodeTypes : object {
    public static CppGenericTokenNodeType UNKNOWN_TOKEN;
    public static CppGenericTokenNodeType CLOSED_CHAMELEON_TOKEN;
    public static CppGenericTokenNodeType IDENTIFIER;
    public static CppGenericTokenNodeType EXPAND_DISABLED_IDENTIFIER;
    public static CppGenericTokenNodeType HASHED_IDENTIFIER;
    public static CppGenericTokenNodeType DIRECTIVE_CONTENT;
    public static CppGenericTokenNodeType CODE_DIRECTIVE_CONTENT;
    public static CppGenericTokenNodeType INCLUDE_DIRECTIVE_CONTENT;
    public static CppGenericTokenNodeType END_OF_DIRECTIVE_CONTENT;
    public static CppDirectiveTokenNodeType IF_DIRECTIVE;
    public static CppDirectiveTokenNodeType IFDEF_DIRECTIVE;
    public static CppDirectiveTokenNodeType IFNDEF_DIRECTIVE;
    public static CppDirectiveTokenNodeType ELIF_DIRECTIVE;
    public static CppDirectiveTokenNodeType ELIFDEF_DIRECTIVE;
    public static CppDirectiveTokenNodeType ELIFNDEF_DIRECTIVE;
    public static CppDirectiveTokenNodeType ELSE_DIRECTIVE;
    public static CppDirectiveTokenNodeType ENDIF_DIRECTIVE;
    public static CppDirectiveTokenNodeType INCLUDE_DIRECTIVE;
    public static CppDirectiveTokenNodeType INCLUDE_NEXT_DIRECTIVE;
    public static CppDirectiveTokenNodeType INCLUDE_WITH_PRAGMAS_DIRECTIVE;
    public static CppDirectiveTokenNodeType IMPORT_DIRECTIVE;
    public static CppDirectiveTokenNodeType DEFINE_DIRECTIVE;
    public static CppDirectiveTokenNodeType UNDEF_DIRECTIVE;
    public static CppDirectiveTokenNodeType LINE_DIRECTIVE;
    public static CppDirectiveTokenNodeType ERROR_DIRECTIVE;
    public static CppDirectiveTokenNodeType WARNING_DIRECTIVE;
    public static CppDirectiveTokenNodeType PRAGMA_DIRECTIVE;
    public static CppDirectiveTokenNodeType CPP20_IMPORT_DIRECTIVE;
    public static CppDirectiveTokenNodeType CPP20_MODULE_DIRECTIVE;
    public static CppGenericTokenNodeType EMPTY_DIRECTIVE;
    public static CppGenericTokenNodeType UNKNOWN_DIRECTIVE;
    public static NodeTypeSet INCLUDE_DIRECTIVES;
    public static NodeTypeSet ELIF_DIRECTIVES;
    public static NodeTypeSet IF_DIRECTIVES;
    public static NodeTypeSet ELSE_DIRECTIVES;
    public static NodeTypeSet BRANCHING_DIRECTIVES;
    public static NodeTypeSet DIRECTIVES;
    public static CppGenericTokenNodeType EOL_ESCAPE;
    public static CppStaticWhitespaceRepresentationTokenNodeType WHITE_SPACE;
    public static CppStaticWhitespaceRepresentationTokenNodeType NEW_LINE;
    public static CppGenericTokenNodeType NUMERIC_LITERAL;
    public static CppGenericTokenNodeType CHARACTER_LITERAL;
    public static CppGenericTokenNodeType STRING_LITERAL;
    public static CppGenericTokenNodeType FAKE_TRUE;
    public static CppGenericTokenNodeType FAKE_FALSE;
    public static CppGenericTokenNodeType RETRY;
    public static CppDoxygenCommentTokenNodeType DOXYGEN_EOL_COMMENT_PREFIX;
    public static CppDoxygenCommentTokenNodeType DOXYGEN_MULTILINE_COMMENT_PREFIX;
    public static CppDoxygenCommentTokenNodeType DOXYGEN_MULTILINE_COMMENT_POSTFIX;
    public static CppDoxygenCommentTokenNodeType DOXYGEN_QUOTE;
    public static CppPunctuatorTokenNodeType AT;
    public static CppCommentTokenNodeType BLOCK_COMMENT;
    public static CppCommentTokenNodeType UNFINISHED_BLOCK_COMMENT;
    public static CppCommentTokenNodeType GENERATED_COMMENT;
    public static CppCommentTokenNodeType EOL_COMMENT;
    public static CppCommentTokenNodeType DOXYGEN_EOL_COMMENT_BLOCK;
    public static CppGenericTokenNodeType CONDITIONALLY_NOT_COMPILED_CODE;
    public static TokenNodeType MODIFICATION_UTIL_MARKER;
    public static CppKeywordTokenNodeType AUTO_KEYWORD;
    public static CppKeywordTokenNodeType BREAK_KEYWORD;
    public static CppKeywordTokenNodeType CASE_KEYWORD;
    public static CppKeywordTokenNodeType CHAR_KEYWORD;
    public static CppKeywordTokenNodeType CONST_KEYWORD;
    public static CppKeywordTokenNodeType CONTINUE_KEYWORD;
    public static CppKeywordTokenNodeType DEFAULT_KEYWORD;
    public static CppKeywordTokenNodeType DO_KEYWORD;
    public static CppKeywordTokenNodeType DOUBLE_KEYWORD;
    public static CppKeywordTokenNodeType ELSE_KEYWORD;
    public static CppKeywordTokenNodeType ENUM_KEYWORD;
    public static CppKeywordTokenNodeType EXTERN_KEYWORD;
    public static CppKeywordTokenNodeType FLOAT_KEYWORD;
    public static CppKeywordTokenNodeType FOR_KEYWORD;
    public static CppKeywordTokenNodeType GOTO_KEYWORD;
    public static CppKeywordTokenNodeType IF_KEYWORD;
    public static CppKeywordTokenNodeType INLINE_KEYWORD;
    public static CppKeywordTokenNodeType INT_KEYWORD;
    public static CppKeywordTokenNodeType LONG_KEYWORD;
    public static CppKeywordTokenNodeType REGISTER_KEYWORD;
    public static CppKeywordTokenNodeType RESTRICT_KEYWORD;
    public static CppKeywordTokenNodeType RETURN_KEYWORD;
    public static CppKeywordTokenNodeType SHORT_KEYWORD;
    public static CppKeywordTokenNodeType SIGNED_KEYWORD;
    public static CppKeywordTokenNodeType SIZEOF_KEYWORD;
    public static CppKeywordTokenNodeType STATIC_KEYWORD;
    public static CppKeywordTokenNodeType STRUCT_KEYWORD;
    public static CppKeywordTokenNodeType SWITCH_KEYWORD;
    public static CppKeywordTokenNodeType TYPEDEF_KEYWORD;
    public static CppKeywordTokenNodeType UNION_KEYWORD;
    public static CppKeywordTokenNodeType UNSIGNED_KEYWORD;
    public static CppKeywordTokenNodeType VOID_KEYWORD;
    public static CppKeywordTokenNodeType VOLATILE_KEYWORD;
    public static CppKeywordTokenNodeType WHILE_KEYWORD;
    public static CppKeywordTokenNodeType C11_ALIGNAS_KEYWORD;
    public static CppKeywordTokenNodeType C11_ALIGNOF_KEYWORD;
    public static CppKeywordTokenNodeType C11_ATOMIC_KEYWORD;
    public static CppKeywordTokenNodeType C11_BOOL_KEYWORD;
    public static CppKeywordTokenNodeType C11_COMPLEX_KEYWORD;
    public static CppKeywordTokenNodeType C11_GENERIC_KEYWORD;
    public static CppKeywordTokenNodeType C11_IMAGINARY_KEYWORD;
    public static CppKeywordTokenNodeType C11_NORETURN_KEYWORD;
    public static CppKeywordTokenNodeType C11_STATIC_ASSERT_KEYWORD;
    public static CppKeywordTokenNodeType C11_THREAD_LOCAL_KEYWORD;
    public static CppKeywordTokenNodeType ASM_KEYWORD;
    public static CppKeywordTokenNodeType BOOL_KEYWORD;
    public static CppKeywordTokenNodeType CATCH_KEYWORD;
    public static CppKeywordTokenNodeType CLASS_KEYWORD;
    public static CppKeywordTokenNodeType CONST_CAST_KEYWORD;
    public static CppKeywordTokenNodeType DELETE_KEYWORD;
    public static CppKeywordTokenNodeType DYNAMIC_CAST_KEYWORD;
    public static CppKeywordTokenNodeType EXPLICIT_KEYWORD;
    public static CppKeywordTokenNodeType EXPORT_KEYWORD;
    public static CppKeywordTokenNodeType IMPORT_KEYWORD;
    public static CppKeywordTokenNodeType MODULE_KEYWORD;
    public static CppKeywordTokenNodeType FALSE_KEYWORD;
    public static CppKeywordTokenNodeType FRIEND_KEYWORD;
    public static CppKeywordTokenNodeType MUTABLE_KEYWORD;
    public static CppKeywordTokenNodeType NAMESPACE_KEYWORD;
    public static CppKeywordTokenNodeType NEW_KEYWORD;
    public static CppKeywordTokenNodeType OPERATOR_KEYWORD;
    public static CppKeywordTokenNodeType PRIVATE_KEYWORD;
    public static CppKeywordTokenNodeType PUBLIC_KEYWORD;
    public static CppKeywordTokenNodeType PROTECTED_KEYWORD;
    public static CppKeywordTokenNodeType REINTERPRET_CAST_KEYWORD;
    public static CppKeywordTokenNodeType STATIC_CAST_KEYWORD;
    public static CppKeywordTokenNodeType TEMPLATE_KEYWORD;
    public static CppKeywordTokenNodeType THIS_KEYWORD;
    public static CppKeywordTokenNodeType THROW_KEYWORD;
    public static CppKeywordTokenNodeType TRUE_KEYWORD;
    public static CppKeywordTokenNodeType TRY_KEYWORD;
    public static CppKeywordTokenNodeType TYPENAME_KEYWORD;
    public static CppKeywordTokenNodeType TYPEID_KEYWORD;
    public static CppKeywordTokenNodeType USING_KEYWORD;
    public static CppKeywordTokenNodeType VIRTUAL_KEYWORD;
    public static CppKeywordTokenNodeType WCHAR_T_KEYWORD;
    public static CppKeywordTokenNodeType __FUNCTION__KEYWORD;
    public static CppKeywordTokenNodeType __FUNCSIG__KEYWORD;
    public static CppKeywordTokenNodeType __FUNCDNAME__KEYWORD;
    public static CppKeywordTokenNodeType __PRETTY_FUNCTION__KEYWORD;
    public static CppKeywordTokenNodeType ALIGNAS_KEYWORD;
    public static CppKeywordTokenNodeType ALIGNOF_KEYWORD;
    public static CppKeywordTokenNodeType CHAR8_T_KEYWORD;
    public static CppKeywordTokenNodeType CHAR16_T_KEYWORD;
    public static CppKeywordTokenNodeType CHAR32_T_KEYWORD;
    public static CppKeywordTokenNodeType CONSTEXPR_KEYWORD;
    public static CppKeywordTokenNodeType CONSTEVAL_KEYWORD;
    public static CppKeywordTokenNodeType CONSTINIT_KEYWORD;
    public static CppKeywordTokenNodeType DECLTYPE_KEYWORD;
    public static CppKeywordTokenNodeType NOEXCEPT_KEYWORD;
    public static CppKeywordTokenNodeType NULLPTR_KEYWORD;
    public static CppKeywordTokenNodeType STATIC_ASSERT_KEYWORD;
    public static CppKeywordTokenNodeType THREAD_LOCAL_KEYWORD;
    public static CppKeywordTokenNodeType FINAL_KEYWORD;
    public static CppKeywordTokenNodeType OVERRIDE_KEYWORD;
    public static CppKeywordTokenNodeType CONCEPT_KEYWORD;
    public static CppKeywordTokenNodeType REQUIRES_KEYWORD;
    public static CppKeywordTokenNodeType CXXCLI_GENERIC_KEYWORD;
    public static CppKeywordTokenNodeType CXXCLI_WHERE_KEYWORD;
    public static CppKeywordTokenNodeType CXXCLI_REF_KEYWORD;
    public static CppKeywordTokenNodeType CXXCLI_VALUE_KEYWORD;
    public static CppKeywordTokenNodeType CXXCLI_INTERFACE_KEYWORD;
    public static CppKeywordTokenNodeType CXXCLI_GCNEW_KEYWORD;
    public static CppKeywordTokenNodeType CXXCLI_SAFE_CAST_KEYWORD;
    public static CppKeywordTokenNodeType CXXCLI_INITONLY_KEYWORD;
    public static CppKeywordTokenNodeType CXXCLI_LITERAL_KEYWORD;
    public static CppKeywordTokenNodeType CXXCLI_INTERNAL_KEYWORD;
    public static CppKeywordTokenNodeType CXXCLI_PROPERTY_KEYWORD;
    public static CppKeywordTokenNodeType CXXCLI_EVENT_KEYWORD;
    public static CppKeywordTokenNodeType CXXCLI_DELEGATE_KEYWORD;
    public static CppKeywordTokenNodeType CXXCLI_FINALLY_KEYWORD;
    public static CppKeywordTokenNodeType __HAS_ASSIGN;
    public static CppKeywordTokenNodeType __HAS_COPY;
    public static CppKeywordTokenNodeType __HAS_FINALIZER;
    public static CppKeywordTokenNodeType __HAS_NOTHROW_ASSIGN;
    public static CppKeywordTokenNodeType __HAS_NOTHROW_CONSTRUCTOR;
    public static CppKeywordTokenNodeType __HAS_NOTHROW_COPY;
    public static CppKeywordTokenNodeType __HAS_TRIVIAL_ASSIGN;
    public static CppKeywordTokenNodeType __HAS_TRIVIAL_CONSTRUCTOR;
    public static CppKeywordTokenNodeType __HAS_TRIVIAL_COPY;
    public static CppKeywordTokenNodeType __HAS_TRIVIAL_DESTRUCTOR;
    public static CppKeywordTokenNodeType __HAS_USER_DESTRUCTOR;
    public static CppKeywordTokenNodeType __HAS_VIRTUAL_DESTRUCTOR;
    public static CppKeywordTokenNodeType __IS_ABSTRACT;
    public static CppKeywordTokenNodeType __IS_AGGREGATE;
    public static CppKeywordTokenNodeType __IS_ASSIGNABLE;
    public static CppKeywordTokenNodeType __IS_BASE_OF;
    public static CppKeywordTokenNodeType __IS_CLASS;
    public static CppKeywordTokenNodeType __IS_CONVERTIBLE_TO;
    public static CppKeywordTokenNodeType __IS_DELEGATE;
    public static CppKeywordTokenNodeType __IS_EMPTY;
    public static CppKeywordTokenNodeType __IS_ENUM;
    public static CppKeywordTokenNodeType __IS_FINAL;
    public static CppKeywordTokenNodeType __IS_INTERFACE_CLASS;
    public static CppKeywordTokenNodeType __IS_POD;
    public static CppKeywordTokenNodeType __IS_POLYMORPHIC;
    public static CppKeywordTokenNodeType __IS_REF_ARRAY;
    public static CppKeywordTokenNodeType __IS_REF_CLASS;
    public static CppKeywordTokenNodeType __IS_SEALED;
    public static CppKeywordTokenNodeType __IS_SIMPLE_VALUE_CLASS;
    public static CppKeywordTokenNodeType __IS_UNION;
    public static CppKeywordTokenNodeType __IS_VALUE_CLASS;
    public static CppKeywordTokenNodeType __IS_STANDARD_LAYOUT;
    public static CppKeywordTokenNodeType __IS_LITERAL;
    public static CppKeywordTokenNodeType __IS_LITERAL_TYPE;
    public static CppKeywordTokenNodeType __IS_TRIVIAL;
    public static CppKeywordTokenNodeType __HAS_TRIVIAL_MOVE_CONSTRUCTOR;
    public static CppKeywordTokenNodeType __HAS_TRIVIAL_MOVE_ASSIGN;
    public static CppKeywordTokenNodeType __HAS_NOTHROW_MOVE_ASSIGN;
    public static CppKeywordTokenNodeType __IS_TRIVIALLY_COPYABLE;
    public static CppKeywordTokenNodeType __IS_CONSTRUCTIBLE;
    public static CppKeywordTokenNodeType __IS_DESTRUCTIBLE;
    public static CppKeywordTokenNodeType __IS_TRIVIALLY_CONSTRUCTIBLE;
    public static CppKeywordTokenNodeType __IS_TRIVIALLY_ASSIGNABLE;
    public static CppKeywordTokenNodeType __IS_NOTHROW_CONSTRUCTIBLE;
    public static CppKeywordTokenNodeType __IS_NOTHROW_ASSIGNABLE;
    public static CppKeywordTokenNodeType __IS_NOTHROW_DESTRUCTIBLE;
    public static CppKeywordTokenNodeType __IS_TRIVIALLY_DESTRUCTIBLE;
    public static CppKeywordTokenNodeType __HAS_UNIQUE_OBJECT_REPRSENTATIONS;
    public static CppKeywordTokenNodeType __IS_FUNCTION;
    public static CppKeywordTokenNodeType __IS_OBJECT;
    public static CppKeywordTokenNodeType __IS_ARRAY;
    public static CppKeywordTokenNodeType __IS_UNBOUNDED_ARRAY;
    public static CppKeywordTokenNodeType __IS_POINTER;
    public static CppKeywordTokenNodeType __IS_MEMBER_POINTER;
    public static CppKeywordTokenNodeType __IS_MEMBER_FUNCTION_POINTER;
    public static CppKeywordTokenNodeType __IS_MEMBER_OBJECT_POINTER;
    public static CppKeywordTokenNodeType __IS_REFERENCE;
    public static CppKeywordTokenNodeType __IS_LVALUE_REFERENCE;
    public static CppKeywordTokenNodeType __IS_RVALUE_REFERENCE;
    public static CppKeywordTokenNodeType __IS_CONST;
    public static CppKeywordTokenNodeType __IS_VOLATILE;
    public static CppKeywordTokenNodeType __IS_NULLPTR;
    public static CppKeywordTokenNodeType __IS_SCALAR;
    public static CppKeywordTokenNodeType __IS_ARITHMETIC;
    public static CppKeywordTokenNodeType __IS_COMPOUND;
    public static CppKeywordTokenNodeType __IS_FUNDAMENTAL;
    public static CppKeywordTokenNodeType __IS_COMPLETE_TYPE;
    public static CppKeywordTokenNodeType __IS_SIGNED;
    public static CppKeywordTokenNodeType __IS_UNSIGNED;
    public static CppKeywordTokenNodeType __IS_VOID;
    public static CppKeywordTokenNodeType __IS_INTEGRAL;
    public static CppKeywordTokenNodeType __IS_FLOATING_POINT;
    public static CppKeywordTokenNodeType __ADD_POINTER;
    public static CppKeywordTokenNodeType __ADD_LVALUE_REFERENCE;
    public static CppKeywordTokenNodeType __ADD_RVALUE_REFERENCE;
    public static CppKeywordTokenNodeType __DECAY;
    public static CppKeywordTokenNodeType __MAKE_SIGNED;
    public static CppKeywordTokenNodeType __MAKE_UNSIGNED;
    public static CppKeywordTokenNodeType __REMOVE_CONST;
    public static CppKeywordTokenNodeType __REMOVE_VOLATILE;
    public static CppKeywordTokenNodeType __REMOVE_CV;
    public static CppKeywordTokenNodeType __REMOVE_CVREF;
    public static CppKeywordTokenNodeType __REMOVE_REFERENCE;
    public static CppKeywordTokenNodeType __REMOVE_POINTER;
    public static CppKeywordTokenNodeType __REMOVE_EXTENT;
    public static CppKeywordTokenNodeType __REMOVE_ALL_EXTENTS;
    public static CppKeywordTokenNodeType __IS_SAME;
    public static CppKeywordTokenNodeType __IS_SAME_AS;
    public static CppKeywordTokenNodeType __IS_LAYOUT_COMPATIBLE;
    public static CppKeywordTokenNodeType __IS_POINTER_INTERCONVERTIBLE_BASE_OF;
    public static CppKeywordTokenNodeType __REFERENCE_CONSTRUCTS_FROM_TEMPORARY;
    public static CppKeywordTokenNodeType __REFERENCE_CONVERTS_FROM_TEMPORARY;
    public static CppKeywordTokenNodeType __IS_CONVERTIBLE;
    public static CppKeywordTokenNodeType __IS_NOTHROW_CONVERTIBLE;
    public static CppKeywordTokenNodeType CO_RETURN_KEYWORD;
    public static CppKeywordTokenNodeType CO_AWAIT_KEYWORD;
    public static CppKeywordTokenNodeType CO_YIELD_KEYWORD;
    public static CppKeywordTokenNodeType _DECL_SPEC_KEYWORD;
    public static CppKeywordTokenNodeType __DECL_SPEC_KEYWORD;
    public static CppKeywordTokenNodeType _CDECL_KEYWORD;
    public static CppKeywordTokenNodeType __CDECL_KEYWORD;
    public static CppKeywordTokenNodeType __CLRCALL_KEYWORD;
    public static CppKeywordTokenNodeType _STDCALL_KEYWORD;
    public static CppKeywordTokenNodeType __STDCALL_KEYWORD;
    public static CppKeywordTokenNodeType _FASTCALL_KEYWORD;
    public static CppKeywordTokenNodeType __FASTCALL_KEYWORD;
    public static CppKeywordTokenNodeType _THISCALL_KEYWORD;
    public static CppKeywordTokenNodeType __THISCALL_KEYWORD;
    public static CppKeywordTokenNodeType _VECTORCALL_KEYWORD;
    public static CppKeywordTokenNodeType __VECTORCALL_KEYWORD;
    public static CppKeywordTokenNodeType _FORCEINLINE_KEYWORD;
    public static CppKeywordTokenNodeType __FORCEINLINE_KEYWORD;
    public static CppKeywordTokenNodeType _UNALIGNED_KEYWORD;
    public static CppKeywordTokenNodeType __UNALIGNED_KEYWORD;
    public static CppKeywordTokenNodeType __UNDERLYING_TYPE;
    public static CppKeywordTokenNodeType SEALED_KEYWORD;
    public static CppKeywordTokenNodeType ABSTRACT_KEYWORD;
    public static CppKeywordTokenNodeType TILE_STATIC_KEYWORD;
    public static CppKeywordTokenNodeType HALF_KEYWORD;
    public static CppKeywordTokenNodeType VECTOR_KEYWORD;
    public static CppKeywordTokenNodeType MATRIX_KEYWORD;
    public static CppKeywordTokenNodeType STRING_KEYWORD;
    public static CppKeywordTokenNodeType SNORM_KEYWORD;
    public static CppKeywordTokenNodeType UNORM_KEYWORD;
    public static CppKeywordTokenNodeType SAMPLER1D_KEYWORD;
    public static CppKeywordTokenNodeType SAMPLER2D_KEYWORD;
    public static CppKeywordTokenNodeType SAMPLER3D_KEYWORD;
    public static CppKeywordTokenNodeType SAMPLERCUBE_KEYWORD;
    public static CppKeywordTokenNodeType SAMPLERSTATE_KEYWORD;
    public static CppKeywordTokenNodeType SAMPLER_COMPARISON_STATE_KEYWORD;
    public static CppKeywordTokenNodeType DISCARD_KEYWORD;
    public static CppKeywordTokenNodeType PACKOFFSET_KEYWORD;
    public static CppKeywordTokenNodeType IN_KEYWORD;
    public static CppKeywordTokenNodeType OUT_KEYWORD;
    public static CppKeywordTokenNodeType INOUT_KEYWORD;
    public static CppKeywordTokenNodeType PRECISE_KEYWORD;
    public static CppKeywordTokenNodeType SHARED_KEYWORD;
    public static CppKeywordTokenNodeType GROUPSHARED_KEYWORD;
    public static CppKeywordTokenNodeType UNIFORM_KEYWORD;
    public static CppKeywordTokenNodeType ROW_MAJOR_KEYWORD;
    public static CppKeywordTokenNodeType COLUMN_MAJOR_KEYWORD;
    public static CppKeywordTokenNodeType LINEAR_KEYWORD;
    public static CppKeywordTokenNodeType CENTROID_KEYWORD;
    public static CppKeywordTokenNodeType NOINTERPOLATION_KEYWORD;
    public static CppKeywordTokenNodeType NOPERSPECTIVE_KEYWORD;
    public static CppKeywordTokenNodeType SAMPLE_KEYWORD;
    public static CppKeywordTokenNodeType POINT_KEYWORD;
    public static CppKeywordTokenNodeType LINE_KEYWORD;
    public static CppKeywordTokenNodeType TRIANGLE_KEYWORD;
    public static CppKeywordTokenNodeType LINEADJ_KEYWORD;
    public static CppKeywordTokenNodeType TRIANGLEADJ_KEYWORD;
    public static CppKeywordTokenNodeType CBUFFER_KEYWORD;
    public static CppKeywordTokenNodeType TBUFFER_KEYWORD;
    public static CppKeywordTokenNodeType CONSTANT_BUFFER_KEYWORD;
    public static CppKeywordTokenNodeType TEXTURE_BUFFER_KEYWORD;
    public static CppKeywordTokenNodeType __PRAGMA_KEYWORD;
    public static CppKeywordTokenNodeType __NULLPTR_KEYWORD;
    public static CppKeywordTokenNodeType __NULL_KEYWORD;
    public static CppKeywordTokenNodeType __AUTO_TYPE_KEYWORD;
    public static CppKeywordTokenNodeType _PTR64_KEYWORD;
    public static CppKeywordTokenNodeType __PTR64_KEYWORD;
    public static CppKeywordTokenNodeType _PTR32_KEYWORD;
    public static CppKeywordTokenNodeType __PTR32_KEYWORD;
    public static CppKeywordTokenNodeType _SPTR_KEYWORD;
    public static CppKeywordTokenNodeType __SPTR_KEYWORD;
    public static CppKeywordTokenNodeType _UPTR_KEYWORD;
    public static CppKeywordTokenNodeType __UPTR_KEYWORD;
    public static CppKeywordTokenNodeType _W64_KEYWORD;
    public static CppKeywordTokenNodeType __W64_KEYWORD;
    public static CppKeywordTokenNodeType _UUIDOF_KEYWORD;
    public static CppKeywordTokenNodeType __UUIDOF_KEYWORD;
    public static CppKeywordTokenNodeType _ALIGNOF_KEYWORD;
    public static CppKeywordTokenNodeType __ALIGNOF_KEYWORD;
    public static CppKeywordTokenNodeType __ALIGNOF___KEYWORD;
    public static CppKeywordTokenNodeType TYPEOF_KEYWORD;
    public static CppKeywordTokenNodeType TYPEOF_UNQUAL_KEYWORD;
    public static CppKeywordTokenNodeType __TYPEOF_KEYWORD;
    public static CppKeywordTokenNodeType __TYPEOF___KEYWORD;
    public static CppKeywordTokenNodeType __TYPEOF_UNQUAL___KEYWORD;
    public static CppKeywordTokenNodeType __BUILTIN_ALIGNOF_KEYWORD;
    public static CppKeywordTokenNodeType __BUILTIN_ADDRESSOF_KEYWORD;
    public static CppKeywordTokenNodeType __BUILTIN_OFFSETOF_KEYWORD;
    public static CppKeywordTokenNodeType __BUILTIN_CONSTANT_P_KEYWORD;
    public static CppKeywordTokenNodeType __BUILTIN_CHOOSE_EXPR_KEYWORD;
    public static CppKeywordTokenNodeType __BUILTIN_TYPES_COMPATIBLE_P_KEYWORD;
    public static CppKeywordTokenNodeType _TRY_KEYWORD;
    public static CppKeywordTokenNodeType __TRY_KEYWORD;
    public static CppKeywordTokenNodeType _EXCEPT_KEYWORD;
    public static CppKeywordTokenNodeType __EXCEPT_KEYWORD;
    public static CppKeywordTokenNodeType _FINALLY_KEYWORD;
    public static CppKeywordTokenNodeType __FINALLY_KEYWORD;
    public static CppKeywordTokenNodeType _LEAVE_KEYWORD;
    public static CppKeywordTokenNodeType __LEAVE_KEYWORD;
    public static CppKeywordTokenNodeType __IDENTIFIER_KEYWORD;
    public static CppKeywordTokenNodeType _ASM_KEYWORD;
    public static CppKeywordTokenNodeType __ASM_KEYWORD;
    public static CppKeywordTokenNodeType __ASM___KEYWORD;
    public static CppKeywordTokenNodeType _INLINE_KEYWORD;
    public static CppKeywordTokenNodeType __INLINE_KEYWORD;
    public static CppKeywordTokenNodeType __INLINE___KEYWORD;
    public static CppKeywordTokenNodeType _RESTRICT_KEYWORD;
    public static CppKeywordTokenNodeType __RESTRICT_KEYWORD;
    public static CppKeywordTokenNodeType __RESTRICT___KEYWORD;
    public static CppKeywordTokenNodeType __INTERFACE_KEYWORD;
    public static CppKeywordTokenNodeType HLSL_INTERFACE_KEYWORD;
    public static CppKeywordTokenNodeType __WCHAR_T_KEYWORD;
    public static CppKeywordTokenNodeType _INT8_KEYWORD;
    public static CppKeywordTokenNodeType __INT8_KEYWORD;
    public static CppKeywordTokenNodeType _INT16_KEYWORD;
    public static CppKeywordTokenNodeType __INT16_KEYWORD;
    public static CppKeywordTokenNodeType _INT32_KEYWORD;
    public static CppKeywordTokenNodeType __INT32_KEYWORD;
    public static CppKeywordTokenNodeType _INT64_KEYWORD;
    public static CppKeywordTokenNodeType __INT64_KEYWORD;
    public static CppKeywordTokenNodeType __INT128_KEYWORD;
    public static CppKeywordTokenNodeType __INT128_T_KEYWORD;
    public static CppKeywordTokenNodeType __UINT128_T_KEYWORD;
    public static CppKeywordTokenNodeType __IF_EXIST_KEYWORD;
    public static CppKeywordTokenNodeType __IF_NOT_EXIST_KEYWORD;
    public static CppKeywordTokenNodeType __NOOP_KEYWORD;
    public static CppKeywordTokenNodeType _ASSUME_KEYWORD;
    public static CppKeywordTokenNodeType __ASSUME_KEYWORD;
    public static CppKeywordTokenNodeType __LPREFIX_KEYWORD;
    public static CppKeywordTokenNodeType __SUPER_KEYWORD;
    public static CppKeywordTokenNodeType __EVENT_KEYWORD;
    public static CppKeywordTokenNodeType __RAISE_KEYWORD;
    public static CppKeywordTokenNodeType __HOOK_KEYWORD;
    public static CppKeywordTokenNodeType __UNHOOK_KEYWORD;
    public static CppKeywordTokenNodeType _SINGLE_INHERITANCE;
    public static CppKeywordTokenNodeType __SINGLE_INHERITANCE;
    public static CppKeywordTokenNodeType _MULTIPLE_INHERITANCE;
    public static CppKeywordTokenNodeType __MULTIPLE_INHERITANCE;
    public static CppKeywordTokenNodeType _VIRTUAL_INHERITANCE;
    public static CppKeywordTokenNodeType __VIRTUAL_INHERITANCE;
    public static CppKeywordTokenNodeType __ATTRIBUTE_KEYWORD;
    public static CppKeywordTokenNodeType __ATTRIBUTE___KEYWORD;
    public static CppKeywordTokenNodeType __RESHARPER_UNKNOWN_TYPE;
    public static CppKeywordTokenNodeType __RESHARPER_DISABLE_SYNTAX_DETECTORS;
    public static CppKeywordTokenNodeType __RESHARPER_ENABLE_SYNTAX_DETECTORS;
    public static CppKeywordTokenNodeType __RESHARPER_UE4_UCLASS;
    public static CppKeywordTokenNodeType __RESHARPER_UE4_USTRUCT;
    public static CppKeywordTokenNodeType __RESHARPER_UE4_UENUM;
    public static CppKeywordTokenNodeType __RESHARPER_UE4_UINTERFACE;
    public static CppKeywordTokenNodeType __RESHARPER_UE4_GENERATED_BODY;
    public static CppKeywordTokenNodeType __RESHARPER_UE4_GENERATED_BODY_LEGACY;
    public static CppKeywordTokenNodeType __RESHARPER_UE4_UFUNCTION;
    public static CppKeywordTokenNodeType __RESHARPER_UE4_UPROPERTY;
    public static CppKeywordTokenNodeType __RESHARPER_UE4_RIGVM_METHOD;
    public static CppKeywordTokenNodeType __RESHARPER_GG_DECLARE_HUNGARIAN;
    public static CppPunctuatorTokenNodeType LBRACKET;
    public static CppPunctuatorTokenNodeType RBRACKET;
    public static CppPunctuatorTokenNodeType LBRACE;
    public static CppPunctuatorTokenNodeType RBRACE;
    public static CppPunctuatorTokenNodeType LPAR;
    public static CppPunctuatorTokenNodeType RPAR;
    public static CppPunctuatorTokenNodeType DOT;
    public static CppPunctuatorTokenNodeType DEREF;
    public static CppPunctuatorTokenNodeType DOTMUL;
    public static CppPunctuatorTokenNodeType DEREFMUL;
    public static CppPunctuatorTokenNodeType PLUSPLUS;
    public static CppPunctuatorTokenNodeType MINUSMINUS;
    public static CppPunctuatorWithAlternativeTextTokenNodeType AND;
    public static CppPunctuatorTokenNodeType MUL;
    public static CppPunctuatorTokenNodeType PLUS;
    public static CppPunctuatorTokenNodeType MINUS;
    public static CppPunctuatorWithAlternativeTextTokenNodeType TILDE;
    public static CppPunctuatorWithAlternativeTextTokenNodeType EXCL;
    public static CppPunctuatorTokenNodeType DIV;
    public static CppPunctuatorTokenNodeType PERC;
    public static CppPunctuatorTokenNodeType LTLT;
    public static CppPunctuatorTokenNodeType GTGT;
    public static CppPunctuatorTokenNodeType LT;
    public static CppPunctuatorTokenNodeType GT;
    public static CppPunctuatorTokenNodeType LTEQ;
    public static CppPunctuatorTokenNodeType GTEQ;
    public static CppPunctuatorTokenNodeType EQEQ;
    public static CppPunctuatorTokenNodeType LTEQGT;
    public static CppPunctuatorWithAlternativeTextTokenNodeType EXCLEQ;
    public static CppPunctuatorWithAlternativeTextTokenNodeType XOR;
    public static CppPunctuatorWithAlternativeTextTokenNodeType OR;
    public static CppPunctuatorWithAlternativeTextTokenNodeType ANDAND;
    public static CppPunctuatorWithAlternativeTextTokenNodeType OROR;
    public static CppPunctuatorTokenNodeType QUEST;
    public static CppPunctuatorTokenNodeType COLON;
    public static CppPunctuatorTokenNodeType COLON2X;
    public static CppPunctuatorTokenNodeType SEMICOLON;
    public static CppPunctuatorTokenNodeType ELLIPSIS;
    public static CppPunctuatorTokenNodeType EQ;
    public static CppPunctuatorTokenNodeType MULTEQ;
    public static CppPunctuatorTokenNodeType DIVEQ;
    public static CppPunctuatorTokenNodeType PERCEQ;
    public static CppPunctuatorTokenNodeType PLUSEQ;
    public static CppPunctuatorTokenNodeType MINUSEQ;
    public static CppPunctuatorTokenNodeType LTLTEQ;
    public static CppPunctuatorTokenNodeType GTGTEQ;
    public static CppPunctuatorWithAlternativeTextTokenNodeType ANDEQ;
    public static CppPunctuatorWithAlternativeTextTokenNodeType XOREQ;
    public static CppPunctuatorWithAlternativeTextTokenNodeType OREQ;
    public static CppPunctuatorTokenNodeType COMMA;
    public static CppPunctuatorTokenNodeType HASH;
    public static CppPunctuatorTokenNodeType HASHHASH;
    public static CppPunctuatorTokenNodeType HASHAT;
    public static CppPunctuatorTokenNodeType BACKSLASH;
    public static CppKeywordTokenNodeType AND_KEYWORD;
    public static CppKeywordTokenNodeType TILDE_KEYWORD;
    public static CppKeywordTokenNodeType EXCL_KEYWORD;
    public static CppKeywordTokenNodeType EXCLEQ_KEYWORD;
    public static CppKeywordTokenNodeType XOR_KEYWORD;
    public static CppKeywordTokenNodeType OR_KEYWORD;
    public static CppKeywordTokenNodeType ANDAND_KEYWORD;
    public static CppKeywordTokenNodeType OROR_KEYWORD;
    public static CppKeywordTokenNodeType ANDEQ_KEYWORD;
    public static CppKeywordTokenNodeType XOREQ_KEYWORD;
    public static CppKeywordTokenNodeType OREQ_KEYWORD;
    public static NodeTypeSet LITERALS;
    public static NodeTypeSet WHITESPACES;
    public static NodeTypeSet COMMENTS;
    public static NodeTypeSet WHITESPACES_AND_COMMENTS_WITHOUT_NOT_COMPILED_CODE;
    public static NodeTypeSet WHITESPACES_AND_COMMENTS;
    public static NodeTypeSet DOXYGEN_PREFIX_TOKENS;
    public static NodeTypeSet DOXYGEN_COMMENT_DELIMITER_TOKENS;
    public static NodeTypeSet DOXYGEN_TOKENS;
    public static NodeTypeSet ASSIGNMENT_OPERATIONS;
    public static NodeTypeSet ALL_OPERATORS;
    public static NodeTypeSet BOOLEAN_KEYWORDS;
    public static NodeTypeSet FUNCTION_KEYWORDS;
    public static NodeTypeSet C_PLAIN_KEYWORDS;
    public static NodeTypeSet C_11_KEYWORDS;
    public static NodeTypeSet CPP_KEYWORDS;
    public static NodeTypeSet COROUTINE_KEYWORDS;
    public static NodeTypeSet CONCEPT_KEYWORDS;
    public static NodeTypeSet CXXCLI_KEYWORDS;
    public static NodeTypeSet CXXCLI_WEAK_KEYWORDS;
    public static NodeTypeSet MS_CALLING_CONVENTION_KEYWORDS;
    public static NodeTypeSet HLSL_INPUT_MODIFIERS_KEYWORDS;
    public static NodeTypeSet HLSL_STORAGE_CLASS_MODIFIERS_KEYWORDS;
    public static NodeTypeSet HLSL_INTERPOLATION_MODIFIERS_KEYWORDS;
    public static NodeTypeSet HLSL_TYPE_MODIFIERS;
    public static NodeTypeSet HLSL_SAMPLERS_KEYWORDS;
    public static NodeTypeSet HLSL_GEOMETRY_SHADER_OBJECT_PRIMITIVE_TYPE_KEYWORDS;
    public static NodeTypeSet HLSL_DECLARATION_SPECIFIERS;
    public static NodeTypeSet HLSL_KEYWORDS;
    public static NodeTypeSet GNU_AND_MS_KEYWORDS;
    public static NodeTypeSet MS_BASIC_KEYWORDS;
    public static NodeTypeSet GNU_KEYWORDS;
    public static NodeTypeSet GNU_EXTENSION_KEYWORDS;
    public static NodeTypeSet INLINE_KEYWORDS;
    public static NodeTypeSet STORAGE_CLASS_SPECIFIERS;
    public static NodeTypeSet FUNCTION_SPECIFIERS;
    public static NodeTypeSet DECLARATION_SPECIFIERS;
    public static NodeTypeSet MS_INHERITANCE_KEYWORDS;
    public static NodeTypeSet SINGLE_ARGUMENT_TYPE_TRAIT_KEYWORDS;
    public static NodeTypeSet DOUBLE_ARGUMENT_TYPE_TRAIT_KEYWORDS;
    public static NodeTypeSet MULTI_ARGUMENT_TYPE_TRAIT_KEYWORDS;
    public static NodeTypeSet BUILTIN_TYPE_TRAIT_KEYWORDS;
    public static NodeTypeSet RESHARPER_KEYWORDS;
    public static NodeTypeSet ALTERNATIVE_OPERATOR_KEYWORDS;
    public static NodeTypeSet CLANG_EXTENSION_KEYWORDS;
    public static NodeTypeSet ALL_KEYWORDS;
    public static NodeTypeSet CONTEXTUAL_KEYWORDS;
    public static NodeTypeSet CAST_KEYWORDS;
    public static NodeTypeSet UNARY_OPERATORS;
    public static NodeTypeSet POSTFIX_OPERATORS;
    public static NodeTypeSet BINARY_OPERATORS;
    public static NodeTypeSet BINARY_ASSIGNMENT_OPERATORS;
    public static NodeTypeSet BINARY_NON_ASSIGNMENT_OPERATORS;
    public static NodeTypeSet OPERATOR_FUNC_ID_OPERATORS;
    public static NodeTypeSet PTRS_CV_QUALIFIERS;
    public static NodeTypeSet CV_QUALIFIERS;
    public static NodeTypeSet ARRAY_SIZE_QUALIFIERS;
    public static NodeTypeSet REF_QUALIFIERS;
    public static NodeTypeSet CVREF_QUALIFIERS;
    public static NodeTypeSet HLSL_SIMPLE_TYPE_SPECIFIERS;
    public static NodeTypeSet HLSL_TYPE_SPECIFIERS;
    public static NodeTypeSet SIMPLE_TYPE_SPECIFIERS;
    public static NodeTypeSet VIRTUAL_SPECIFIERS;
    public static NodeTypeSet ACCESS_SPECIFIERS;
    public static NodeTypeSet DECLARATORS_PTRS;
    public static NodeTypeSet CONTAINING_TEXT;
    public static NodeTypeSet EXPRESSION_OPERATOR_NOT_PTR_DECLARATOR;
    public static NodeTypeSet HLSL_BUFFERS_KEYWORDS;
    public static NodeTypeSet DECLTYPE_LIKE_KEYWORDS;
    public static NodeTypeSet IGNORED_IN_DECLSPEC_EXCEPT_LITERAL;
    private static CppTokenNodeTypes();
    public static bool IsIncludeDirective(CppTokenKind tt);
    public static bool IsPtrOrRef(NodeType tt, bool cli);
    public static TokenNodeType Unwrap(TokenNodeType tt);
    public static bool IsFilteredTokenType(TokenNodeType tt);
    public static bool IsDirectiveContent(TokenNodeType tt);
    public static void InitStaticFields();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppTokenNodeTypeTraits : object {
    private static Regex FLOAT_LITERAL;
    private static Regex FLOAT_LITERAL_UDL;
    private static Regex FLOAT_LITERAL_HLSL;
    private static Regex CHARACTER_LITERAL_UDL;
    private static Regex STRING_LITERAL_UDL;
    private static ConcurrentDictionary`2<CppLanguageDialect, CppTokenNodeTypeTraits> ourInstances;
    private NodeTypeSet myAllKeywords;
    private LexerDictionary`1<CppTokenNodeType> myKeywords;
    private static ValueTuple`2[] ourTokenToTypeTraitMap;
    private static CppTokenNodeTypeTraits();
    private CppTokenNodeTypeTraits(CppLanguageDialect dialect);
    public static bool IsValidFloatLiteral(string r, CppLanguageDialect dialect);
    public static bool IsValidUserDefinedFloatLiteral(string r, Int32& suffixPosition);
    public static bool IsFloatLikeLiteral(string r);
    public static bool IsUserDefinedCharacterLiteral(string r, Int32& suffixPosition);
    public static bool IsUserDefinedStringLiteral(string r, Int32& suffixPosition);
    public static CppTokenNodeTypeTraits Create(CppLanguageDialect dialect);
    public NodeTypeSet AllKeywords();
    public CppTokenNodeType GetKeywordByName(string name);
    public bool HasKeyword(string name);
    public CppTokenNodeType GetKeywordByBufferRange(ReusableBufferRange reusableBuffer, IBuffer buffer, int start, int end);
    public static bool IsValidIdentifier(string s);
    public static bool IsValidIntegerLiteral(string r, CppLanguageDialect dialect);
    public static bool IsIntegerLikeLiteral(string r, CppLanguageDialect dialect);
    public static bool IsRawStringLiteral(string s);
    public static bool IsThisLikeKeyword(string name);
    public static bool IsThisLikeKeyword(NodeType nodeType);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppWrapperTokenNodeType : CppTokenNodeType {
    private TokenNodeType myDelegate;
    [CompilerGeneratedAttribute]
private short <MacroLevel>k__BackingField;
    public short MacroLevel { get; private set; }
    public string TokenRepresentation { get; }
    public bool IsWhitespace { get; }
    public bool IsComment { get; }
    public TokenNodeType Delegate { get; }
    public CppWrapperTokenNodeType(TokenNodeType _delegate, short macroLevel);
    [CompilerGeneratedAttribute]
public short get_MacroLevel();
    [CompilerGeneratedAttribute]
private void set_MacroLevel(short value);
    public virtual string get_TokenRepresentation();
    public virtual bool get_IsWhitespace();
    public virtual bool get_IsComment();
    public virtual TokenNodeType get_Delegate();
    public void Init(TokenNodeType _delegate, short macroLevel);
    public void ResetDelegate(TokenNodeType newDelegate);
    public void ResetDelegateThrough(TokenNodeType newDelegate);
    public void ResetMacroLevel(short newLevel);
    public static CppFromMacroCallTokenType CameFromMacroCall(TokenNodeType tt);
    public static CppFromMacroArgumentExpansionTokenNodeType CameFromMacroArgumentExpansion(TokenNodeType tt);
    public static CppMacroArgumentTokenNodeType CameFromMacroArgument(TokenNodeType tt);
    public static CppFromSubstitutionTokenNodeType CameFromMacroSubstitution(TokenNodeType tt);
    public static TokenNodeType UnwrapIfCameFromMacroArgumentExpansion(TokenNodeType tt);
    public static TokenNodeType UnwrapIfCameFromMacroArgument(TokenNodeType tt);
    public static TokenNodeType UnwrapAnyMacroArgumentWrapper(TokenNodeType tt);
    public static TokenNodeType Unwrap(TokenNodeType tt);
    public static TokenNodeType Unwrap(TokenNodeType tt, Int32& level);
    public virtual TokenNodeType CloneWithNewTokenType(TokenNodeType newTerminal, string text);
    public static TokenNodeType GetOrResetTerminalTokenType(TokenNodeType prevTerminal, TokenNodeType newTerminal, string text);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.CppWrapperTokenNodeTypeWithText : CppWrapperTokenNodeType {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OffsetInSubstitution>k__BackingField;
    public string Value { get; private set; }
    public int OffsetInSubstitution { get; private set; }
    public CppWrapperTokenNodeTypeWithText(TokenNodeType _delegate, string text, int offsetInSubstitution, short macroLevel);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    [CompilerGeneratedAttribute]
public int get_OffsetInSubstitution();
    [CompilerGeneratedAttribute]
private void set_OffsetInSubstitution(int value);
    public void Init(TokenNodeType _delegate, string text, int offsetInSubstitution, short macroLevel);
    public void ResetValue(string value);
    public void PlungeIntoSubstitution(int offset);
    public virtual TokenNodeType CloneWithNewTokenType(TokenNodeType newTerminal, string text);
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.DeclarationSpecifiersEmptyChecker : ValueType {
    public sealed virtual string Invoke(ICppDeclarationBuilder declBuilder, TokenNodeType tt);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.DetectionModeGuard`2 : ValueType {
    private CppParsingBase`2<TTraits, TMarkerGuard> myOwner;
    private bool myOldDetectionMode;
    public DetectionModeGuard`2(CppParsingBase`2<TTraits, TMarkerGuard> owner);
    public sealed virtual void Dispose();
}
public enum JetBrains.ReSharper.Psi.Cpp.Parsing.DetectorId : Enum {
    public int value__;
    public static DetectorId DeclarationWithOmittedSpecifiers;
    public static DetectorId ParameterDeclarationClauseNotDeclaratorOrInitializer;
    public static DetectorId DeclarationConditionNotExpression;
    public static DetectorId DeclarationConditionNotExpressionFull;
    public static DetectorId DeclarationStatementNotExpression;
    public static DetectorId DeclarationStatementNotExpressionFull;
    public static DetectorId CStyleCastNotExpression;
    public static DetectorId CStyleCastNotExpressionFull;
    public static DetectorId SizeOfTypeIdNotExpression;
    public static DetectorId SizeOfTypeIdNotExpressionFull;
    public static DetectorId TypeIdInParenNotFunctionArgumentList;
    public static DetectorId TypeIdNotExpression;
    public static DetectorId TypeIdNotExpressionFull;
    public static DetectorId NameQualifierPtr;
    public static DetectorId MSCallingConventionPtr;
    public static DetectorId Max;
}
public interface JetBrains.ReSharper.Psi.Cpp.Parsing.IChameleonParser {
    public abstract virtual void Invoke();
}
public interface JetBrains.ReSharper.Psi.Cpp.Parsing.ICppCachingLexer {
}
public interface JetBrains.ReSharper.Psi.Cpp.Parsing.ICppLexer {
}
public interface JetBrains.ReSharper.Psi.Cpp.Parsing.ICppLineCountingLexer {
    public int Line { get; }
    public abstract virtual int get_Line();
}
internal interface JetBrains.ReSharper.Psi.Cpp.Parsing.ICppParserTokenSequence {
    public abstract virtual TokenNodeType Tt(CppParsingBase`2<TTraits, TMarkerGuard> parsing);
    public abstract virtual void Advance(CppParsingBase`2<TTraits, TMarkerGuard> parsing);
}
public interface JetBrains.ReSharper.Psi.Cpp.Parsing.ICppWrapperTokenNodeType {
    public TokenNodeType Delegate { get; }
    public abstract virtual TokenNodeType get_Delegate();
}
internal interface JetBrains.ReSharper.Psi.Cpp.Parsing.IMarkerGuard`2 {
    public abstract virtual void PrecedeCurrentWithDrop(CppParsingWithTraits`2<TTraits, TSelf> pp);
    public abstract virtual void PrecedeCurrent(CppParsingWithTraits`2<TTraits, TSelf> pp, NodeType type, bool beforeWs, bool allowEmpty, object userData);
    public abstract virtual void Imbue(RollbackT _);
    public abstract virtual void Imbue(DropT _);
    public abstract virtual void Imbue(NodeType type, bool beforeWs, bool allowEmpty, object userData);
    public abstract virtual void Close();
    public abstract virtual void Close(RollbackT _);
    public abstract virtual void Close(DropT _);
    public abstract virtual void Close(NodeType type, bool beforeWs, bool allowEmpty, object userData);
    public abstract virtual bool IsClosed();
}
internal interface JetBrains.ReSharper.Psi.Cpp.Parsing.IParsingTraits`2 {
    public abstract virtual TMarkerGuard CreateMarkerGuard(LightweightRollbackT _);
    public abstract virtual TMarkerGuard CreateMarkerGuard(RollbackT _);
    public abstract virtual TMarkerGuard CreateMarkerGuard(DropT _);
    public abstract virtual TMarkerGuard CreateMarkerGuard(NodeType type, bool beforeWs, bool allowEmpty, object userData);
    public abstract virtual TMarkerGuard CreateMarkerGuard(PrecedeCurrentT _, RollbackT __);
    public abstract virtual TMarkerGuard CreateMarkerGuard(PrecedeCurrentT _, DropT __);
    public abstract virtual TMarkerGuard CreateMarkerGuard(PrecedeCurrentT _, NodeType type, bool beforeWs, bool allowEmpty);
    public abstract virtual void AdvanceLexer();
    public abstract virtual void BaseAdvance();
    public abstract virtual void Advance();
    public abstract virtual void ResetTokenCursor();
    public abstract virtual bool IsEmpty(int marker);
    public abstract virtual void Done(int marker, NodeType type, object userData);
    public abstract virtual void DoneBeforeWhitespaces(int marker, NodeType type, object userData);
    public abstract virtual void RollbackTo(int mark);
    public abstract virtual void Drop(int mark);
    public abstract virtual void RawAlter(TokenNodeType tokenType, int count);
    public abstract virtual void FetchAll();
    public abstract virtual void Error(string message);
    public abstract virtual void ErrorBeforeWhitespaces(string message);
    public abstract virtual void Error(int mark, string message);
    public abstract virtual int Mark();
    public abstract virtual int PrecedeCurrent();
    public abstract virtual int GetCurrentNonCommentLexeme();
    public abstract virtual void ResetCurrentLexeme(int current, int currentNc);
    public abstract virtual int RawCurrentLexeme();
    public abstract virtual int BaseCurrentLexeme();
    public abstract virtual int CurrentLexeme();
    public abstract virtual bool HasNewLineBefore(int pos);
    public abstract virtual void SkipWs();
    public abstract virtual void SkipDirectives(bool stopByMacroCalls);
    public abstract virtual void SkipNonMeaningful();
    public abstract virtual TokenNodeType RawTt(bool unwrap);
    public abstract virtual TokenNodeType BaseTt(bool unwrap);
    public abstract virtual TokenNodeType Tt(bool unwrap);
    public abstract virtual string GetTokenText(int index);
    public abstract virtual string RawTokenText();
    public abstract virtual string BaseTokenText();
    public abstract virtual string TokenText();
    public abstract virtual CppComplexOffset RawNavigationOffset();
    public abstract virtual CppComplexOffset BaseNavigationOffset();
    public abstract virtual CppComplexOffset NavigationOffset();
    public abstract virtual void BaseResync();
    public abstract virtual void Resync();
    public abstract virtual void EnablePreprocessor2Detection(bool val);
    public abstract virtual void AddUdlNameToWordIndex(string name);
    public abstract virtual TokenNodeType TryUnwrap(TokenNodeType tt);
}
public interface JetBrains.ReSharper.Psi.Cpp.Parsing.ITokenChecker {
    public abstract virtual string Invoke(ICppDeclarationBuilder declBuilder, TokenNodeType tt);
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.LightweightMarkerGuard`1 : ValueType {
    private CppParsingWithTraits`2<TTraits, LightweightMarkerGuard`1<TTraits>> myParser;
    private Action myAction;
    private int myStartLexeme;
    private int myStartNonCommentLexeme;
    public LightweightMarkerGuard`1(CppParsingWithTraits`2<TTraits, LightweightMarkerGuard`1<TTraits>> pp, LightweightRollbackT _);
    public LightweightMarkerGuard`1(CppParsingWithTraits`2<TTraits, LightweightMarkerGuard`1<TTraits>> pp, RollbackT _);
    public LightweightMarkerGuard`1(CppParsingWithTraits`2<TTraits, LightweightMarkerGuard`1<TTraits>> pp, DropT _);
    public LightweightMarkerGuard`1(CppParsingWithTraits`2<TTraits, LightweightMarkerGuard`1<TTraits>> pp, NodeType type, bool beforeWs, bool allowEmpty);
    public LightweightMarkerGuard`1(CppParsingWithTraits`2<TTraits, LightweightMarkerGuard`1<TTraits>> pp, NodeType type, bool beforeWs, bool allowEmpty, object userData);
    public LightweightMarkerGuard`1(CppParsingWithTraits`2<TTraits, LightweightMarkerGuard`1<TTraits>> pp, NodeType type, bool beforeWs, bool allowEmpty, int userData);
    public LightweightMarkerGuard`1(CppParsingWithTraits`2<TTraits, LightweightMarkerGuard`1<TTraits>> pp, PrecedeCurrentT _, RollbackT __);
    public LightweightMarkerGuard`1(CppParsingWithTraits`2<TTraits, LightweightMarkerGuard`1<TTraits>> pp, PrecedeCurrentT _, DropT __);
    public LightweightMarkerGuard`1(CppParsingWithTraits`2<TTraits, LightweightMarkerGuard`1<TTraits>> pp, PrecedeCurrentT _, NodeType type, bool beforeWs, bool allowEmpty);
    public sealed virtual void PrecedeCurrentWithDrop(CppParsingWithTraits`2<TTraits, LightweightMarkerGuard`1<TTraits>> pp);
    public sealed virtual void PrecedeCurrent(CppParsingWithTraits`2<TTraits, LightweightMarkerGuard`1<TTraits>> pp, NodeType type, bool beforeWs, bool allowEmpty, object userData);
    public sealed virtual void Imbue(RollbackT _);
    public sealed virtual void Imbue(DropT _);
    public sealed virtual void Imbue(NodeType type, bool beforeWs, bool allowEmpty, object userData);
    public sealed virtual void Close();
    public sealed virtual void Close(RollbackT _);
    public sealed virtual void Close(DropT _);
    public sealed virtual void Close(NodeType type, bool beforeWs, bool allowEmpty, object userData);
    public sealed virtual bool IsClosed();
    public sealed virtual void Dispose();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.MacroArgumentInfo : ValueType {
    public static MacroArgumentInfo Empty;
    public short Index;
    public short TokenIndex;
    public short MacroLevel;
    public MacroArgumentInfo(short index, short tokenIndex, short macroLevel);
    private static MacroArgumentInfo();
    public virtual bool Equals(object rhs);
    public bool Equals(MacroArgumentInfo info);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.MarkerGuard`1 : ValueType {
    public static int INVALID_MARKER;
    private CppParsingWithTraits`2<TTraits, MarkerGuard`1<TTraits>> myParser;
    private Action myAction;
    private NodeType myType;
    private object myUserData;
    private bool myBeforeWs;
    private bool myAllowEmpty;
    private bool myDetectionMode;
    private int myStart;
    private int myStartLexeme;
    private int myStartNonCommentLexeme;
    public MarkerGuard`1(CppParsingWithTraits`2<TTraits, MarkerGuard`1<TTraits>> pp, LightweightRollbackT _);
    public MarkerGuard`1(CppParsingWithTraits`2<TTraits, MarkerGuard`1<TTraits>> pp, RollbackT _);
    public MarkerGuard`1(CppParsingWithTraits`2<TTraits, MarkerGuard`1<TTraits>> pp, DropT _);
    public MarkerGuard`1(CppParsingWithTraits`2<TTraits, MarkerGuard`1<TTraits>> pp, NodeType type, bool beforeWs, bool allowEmpty, object userData);
    public MarkerGuard`1(CppParsingWithTraits`2<TTraits, MarkerGuard`1<TTraits>> pp, PrecedeCurrentT _, RollbackT __);
    public MarkerGuard`1(CppParsingWithTraits`2<TTraits, MarkerGuard`1<TTraits>> pp, PrecedeCurrentT _, DropT __);
    public MarkerGuard`1(CppParsingWithTraits`2<TTraits, MarkerGuard`1<TTraits>> pp, PrecedeCurrentT _, NodeType type, bool beforeWs, bool allowEmpty);
    public sealed virtual void PrecedeCurrentWithDrop(CppParsingWithTraits`2<TTraits, MarkerGuard`1<TTraits>> pp);
    public sealed virtual void PrecedeCurrent(CppParsingWithTraits`2<TTraits, MarkerGuard`1<TTraits>> pp, NodeType type, bool beforeWs, bool allowEmpty, object userData);
    public sealed virtual void Imbue(RollbackT _);
    public sealed virtual void Imbue(DropT _);
    public sealed virtual void Imbue(NodeType type, bool beforeWs, bool allowEmpty, object userData);
    public sealed virtual void Close();
    public sealed virtual void Close(RollbackT _);
    public sealed virtual void Close(DropT _);
    public sealed virtual void Close(NodeType type, bool beforeWs, bool allowEmpty, object userData);
    public sealed virtual bool IsClosed();
    private void Prologue();
    private static bool ShouldStartWithMeaningfulToken(NodeType type);
    public sealed virtual void Dispose();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.MarkerGuardInfra : ValueType {
    public static LightweightRollbackT LightweightRollback;
    public static RollbackT Rollback;
    public static DropT Drop;
    public static PrecedeCurrentT PrecedeCurrent;
}
internal enum JetBrains.ReSharper.Psi.Cpp.Parsing.OperatorPrecedence : Enum {
    public int value__;
    public static OperatorPrecedence Unknown;
    public static OperatorPrecedence Comma;
    public static OperatorPrecedence Assignment;
    public static OperatorPrecedence Conditional;
    public static OperatorPrecedence LogicalOr;
    public static OperatorPrecedence LogicalAnd;
    public static OperatorPrecedence InclusiveOr;
    public static OperatorPrecedence ExclusiveOr;
    public static OperatorPrecedence And;
    public static OperatorPrecedence Equality;
    public static OperatorPrecedence Relational;
    public static OperatorPrecedence ThreeWayComparison;
    public static OperatorPrecedence Shift;
    public static OperatorPrecedence Additive;
    public static OperatorPrecedence Multiplicative;
    public static OperatorPrecedence PointerToMember;
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.ParseChameleonCompoundStatementElement`2 : ValueType {
    private CppParsingBase`2<TTraits, TMarkerGuard> myParsing;
    [CompilerGeneratedAttribute]
private bool <IsExited>k__BackingField;
    public bool IsExited { get; private set; }
    public ParseChameleonCompoundStatementElement`2(CppParsingBase`2<TTraits, TMarkerGuard> parsing);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsExited();
    [CompilerGeneratedAttribute]
private void set_IsExited(bool value);
    public sealed virtual void Invoke();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.ParseHtmlTagResult : object {
    public string Name;
    public bool IsClosing;
    public bool IsSelfClosing;
    public bool IsComment;
    public ParseHtmlTagResult(string name, bool isClosing, bool isSelfClosing, bool isComment);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.ParseKnRParameterDeclaration`2 : ValueType {
    private CppParsingBase`2<TTraits, TMarkerGuard> myParsing;
    private ICppParameterListBuilder myPlistBuilder;
    public ParseKnRParameterDeclaration`2(CppParsingBase`2<TTraits, TMarkerGuard> parsing, ICppParameterListBuilder plistBuilder);
    public bool Invoke();
}
public enum JetBrains.ReSharper.Psi.Cpp.Parsing.PPPhase : Enum {
    public byte value__;
    public static PPPhase Prescan;
    public static PPPhase Scan;
}
public static class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CoWDictionary : object {
    public static CoWDictionary`2<TKey, TValue> CreateUnique(Dictionary`2<TKey, TValue> underlyingDict);
    public static CoWDictionary`2<TKey, TValue> CreateShared(Dictionary`2<TKey, TValue> underlyingDict);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CoWDictionary`2 : ValueType {
    private Dictionary`2<TKey, TValue> myUnderlyingDict;
    private Owning myOwning;
    unknown TValue Item {public set; }
    public ValueCollection<TKey, TValue> Values { get; }
    public CoWDictionary`2(Dictionary`2<TKey, TValue> underlyingDict, Owning owning);
    public Dictionary`2<TKey, TValue> Copy();
    public void Add(TKey key, TValue value);
    public void Remove(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public ValueCollection<TKey, TValue> get_Values();
    private void CopyIfNeeded();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppArrayOfTokensPool : AbstractObjectPoolWithSubPools`1<PooledPackedArrayOfTokens> {
    private int myDefaultCapacity;
    private PackedTokensPagesPool myPagesPool;
    public CppArrayOfTokensPool(PackedTokensPagesPool pagesPool, int capacityOfArrayOfTokens);
    protected virtual PooledPackedArrayOfTokens CreateObject();
    protected virtual void ClearObject(PooledPackedArrayOfTokens t);
    protected virtual void InitObject(PooledPackedArrayOfTokens t);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppBothAnchors : ValueType {
    public CppPPLocationAnchor PPAnchor;
    public CppLocationAnchor SymbolAnchor;
    public CppBothAnchors(CppPPLocationAnchor ppAnchor, CppLocationAnchor symAnchor);
    public virtual string ToString();
}
public static class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppBuiltinMacros : object {
    public static CppPPDefineSymbol COUNTER;
    public static CppPPDefineSymbol DATE;
    public static CppPPDefineSymbol FILE;
    public static CppPPDefineSymbol HAS_C_ATTRIBUTE;
    public static CppPPDefineSymbol HAS_CPP_ATTRIBUTE;
    public static CppPPDefineSymbol HAS_INCLUDE;
    public static CppPPDefineSymbol LINE;
    public static CppPPDefineSymbol TIME;
    public static CppPPDefineSymbol TIMESTAMP;
    public static CppPPDefineSymbol FILE_NAME;
    public static CppPPDefineSymbol HAS_ATTRIBUTE;
    public static CppPPDefineSymbol HAS_BUILTIN;
    public static CppPPDefineSymbol HAS_EXTENSION;
    public static CppPPDefineSymbol HAS_FEATURE;
    public static CppPPDefineSymbol HAS_INCLUDE_NEXT;
    private static CppBuiltinMacros();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppCachingLexer : CachingLexer {
    public int Line { get; }
    public CppCachingLexer(TokenBuffer tokenBuffer);
    public sealed virtual int get_Line();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("Name = {Name}")]
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppDefineKey : ValueType {
    public string Name;
    public int HashCode;
    public CppDefineKey(string name);
    public CppDefineKey(string name, int hashCode);
    public sealed virtual bool Equals(CppDefineKey other);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppDefineSymbolMapPool : AutoClearingThreadSafeObjectPool`1<Dictionary`2<CppDefineKey, DefineData>> {
    public static int CheckPeriod;
    public CppDefineSymbolMapPool(Lifetime lifetime);
    protected virtual Dictionary`2<CppDefineKey, DefineData> CreateObject();
    protected virtual void ClearObject(Dictionary`2<CppDefineKey, DefineData> defines);
    protected virtual void InitObject(Dictionary`2<CppDefineKey, DefineData> defines);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppFileAnchorsRange : ValueType {
    private CppBothAnchors myStart;
    private CppNonSortedRangeIndex myParentIndex;
    [CompilerGeneratedAttribute]
private CppBothAnchors <End>k__BackingField;
    [CompilerGeneratedAttribute]
private CppFileLocation <File>k__BackingField;
    [CompilerGeneratedAttribute]
private CppSortedRangeIndex <SortedIndex>k__BackingField;
    public CppBothAnchors Start { get; }
    public CppBothAnchors End { get; private set; }
    public CppFileLocation File { get; }
    public CppSortedRangeIndex SortedIndex { get; private set; }
    public CppFileAnchorsRange(CppBothAnchors start, CppFileLocation file, CppNonSortedRangeIndex parentIndexIndex);
    public CppBothAnchors get_Start();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CppBothAnchors get_End();
    [CompilerGeneratedAttribute]
private void set_End(CppBothAnchors value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CppFileLocation get_File();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CppSortedRangeIndex get_SortedIndex();
    [CompilerGeneratedAttribute]
private void set_SortedIndex(CppSortedRangeIndex value);
    public Nullable`1<CppFileAnchorsRange> GetParentRange(CppFileAnchorsTracker tracker);
    public CppSortedRangeIndex GetParentSortedIndex(CppFileAnchorsTracker tracker);
    public void LearnEndAnchors(CppBothAnchors end, CppSortedRangeIndex sortedIndex);
    public sealed virtual int CompareTo(CppFileAnchorsRange rhs);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppFileAnchorsTracker : object {
    private static Func`2<CppFileAnchorsRange, CppAnchorRange`1<CppLocationAnchor>> getLocationRange;
    private static Func`2<CppFileAnchorsRange, CppAnchorRange`1<CppPPLocationAnchor>> getPPRange;
    private ChunkList`1<CppFileAnchorsRange> myFileRanges;
    private Dictionary`2<CppFileLocation, CppNonSortedRangeIndex> myFileToFirstIndex;
    private List`1<CppPushIncludeData> myPushedIncludes;
    private List`1<CppNonSortedRangeIndex> mySortedIndicies;
    private CppNonSortedRangeIndex myCurrentIndex;
    public IList`1<CppFileAnchorsRange> NonsortedRanges { get; }
    public CppSortedRangesView SortedRanges { get; }
    public CppNonSortedRangeIndex CurrentFileIndex { get; }
    private CppFileAnchorsTracker(Dictionary`2<CppFileLocation, CppNonSortedRangeIndex> fileToFirstIndex, ChunkList`1<CppFileAnchorsRange> files, List`1<CppPushIncludeData> pushedIncludes, List`1<CppNonSortedRangeIndex> sortedIndicies, CppNonSortedRangeIndex currentIndex);
    private static CppFileAnchorsTracker();
    public IList`1<CppFileAnchorsRange> get_NonsortedRanges();
    public CppSortedRangesView get_SortedRanges();
    public sealed virtual void ProcessGuardedPragmaOnceFile(CppFileLocation file, ICppFileResolveEntitiesCache resolveCache);
    public sealed virtual void ProcessRecursiveInclude(CppFileLocation file, ICppFileResolveEntitiesCache resolveCache);
    public sealed virtual void PushInclude(CppFileLocation file, ICppFileResolveEntitiesCache resolveCache);
    public sealed virtual void PopInclude(ICppFileResolveEntitiesCache resolveCache);
    public sealed virtual ICppFileAnchorsTracker CreateSnapshot();
    public sealed virtual CppNonSortedRangeIndex get_CurrentFileIndex();
    public CppFileAnchorsTracker CreateSnapshotForUnusedIncludes(ICppFileResolveEntitiesCache resolveCache);
    public CppSortedRangeIndex GetFirstOccurrenceSortedIndex(CppFileLocation file);
    public virtual string ToString();
    private void PopIncludeImpl(CppPPLocationAnchor ppAnchor, CppLocationAnchor symbolAnchor);
    private void PopAllIncludes(ICppFileResolveEntitiesCache resolveCache);
    public static CppSortedRangeIndex BinarySearchInFileAnchors(IList`1<CppFileAnchorsRange> list, CppPPLocationAnchor target, IComparer`1<CppAnchorRange`1<CppPPLocationAnchor>> comparer);
    public static CppSortedRangeIndex BinarySearchInFileAnchors(IList`1<CppFileAnchorsRange> list, CppLocationAnchor target, IComparer`1<CppAnchorRange`1<CppLocationAnchor>> comparer);
    public static CppSortedRangeIndex FindContainingRange(CppFileAnchorsTracker rangesTracker, CppLocationAnchor point);
    public static CppSortedRangeIndex FindContainingRange(CppFileAnchorsTracker rangesTracker, CppPPLocationAnchor point);
    private static int UpperBound(IList`1<TItem> list, TTarget target, Func`2<TItem, TTarget> converter, IComparer`1<TTarget> comparer);
    private static int BinarySearchInFileAnchorsImpl(IList`1<CppFileAnchorsRange> list, CppAnchorRange`1<TAnchor> target, Func`2<CppFileAnchorsRange, CppAnchorRange`1<TAnchor>> getRange, IComparer`1<CppAnchorRange`1<TAnchor>> comparer);
    private static int FindContainingRangeImpl(CppFileAnchorsTracker rangesTracker, TAnchor point, Func`2<CppFileAnchorsRange, CppAnchorRange`1<TAnchor>> getRange);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppHeaderSearchPaths : ValueType {
    public List`1<VirtualFileSystemPath> IncludePaths;
    public List`1<VirtualFileSystemPath> FrameworkPaths;
    public CppHeaderSearchPaths(List`1<VirtualFileSystemPath> includePaths, List`1<VirtualFileSystemPath> frameworkPaths);
    public List`1<VirtualFileSystemPath> GetAllFilesystemPaths();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppIncludeDirectiveContent : ValueType {
    private string myPath;
    private Kind myKind;
    public CppIncludeDirectiveContent(string path, Kind kind);
    public string GetPath();
    public Kind GetKind();
    public sealed virtual bool Equals(CppIncludeDirectiveContent other);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CppIncludeDirectiveContent Parse(string directiveContent);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppIncludeDirectiveResolver : object {
    private static int MAX_PATH_LEN;
    [ThreadStaticAttribute]
private static Char[] ourTempBuffer;
    private static Char[] TempBuffer { get; }
    private static Char[] get_TempBuffer();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppIncludeDirectiveResolver/<ResolveIncludeNext>d__4")]
public static IEnumerable`1<CppIncludePathWithSearchPath> ResolveIncludeNext(string pathSpec, CppInclusionContext context, bool resolveFiles);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppIncludeDirectiveResolver/<ResolveAngleBracketInclude>d__5")]
public static IEnumerable`1<CppIncludePathWithSearchPath> ResolveAngleBracketInclude(string pathSpec, CppInclusionContext context, bool useCachedIncludePaths, bool resolveFiles);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppIncludeDirectiveResolver/<ProcessSearchPaths>d__6")]
private static IEnumerable`1<CppIncludePathWithSearchPath> ProcessSearchPaths(string pathSpec, IList`1<VirtualFileSystemPath> includePaths, bool resolveFiles);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppIncludeDirectiveResolver/<ResolveQuotedInclude>d__7")]
public static IEnumerable`1<CppIncludePathWithSearchPath> ResolveQuotedInclude(string pathSpec, CppInclusionContext context, bool useCachedIncludePaths, bool resolveFiles);
    public static CppFileLocation ResolveIncludeDirectiveInContext(CppIncludeDirectiveContent directiveContent, CppInclusionContext context, bool isIncludeNext, String& fileName, Boolean& isPchInclude, VirtualFileSystemPath& includeSearchPath);
    public static CppFileLocation ResolvePchFileIncludeIgnoringInclusionStatus(string name, CppInclusionContext context);
    public static CppFileLocation ResolvePchFileInclude(string name, CppInclusionContext context);
    [CanBeNullAttribute]
private static VirtualFileSystemPath GetCandidatePath(string pathSpec, VirtualFileSystemPath includePath, Char[] buffer, bool resolveFiles);
    public static UInt32 GetFileAttributesW(Char* lpFileName);
    private static Nullable`1<bool> IsDirectory(Char* buffer);
    private static string TransformSpecialIncludePath(CppInclusionContext context, string path);
    [CanBeNullAttribute]
private static VirtualFileSystemPath GetSpecialPath(string pathSpec, CppInclusionContext context);
    private static bool Exists(VirtualFileSystemPath path, bool fileExpected);
    private static int IndexOfFirstSlashOrBackSlash(string s);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppIncludePath : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFile>k__BackingField;
    public string Name { get; }
    public VirtualFileSystemPath Path { get; }
    public bool IsFile { get; }
    public CppIncludePath(string name, VirtualFileSystemPath path, bool isFile);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_Path();
    [CompilerGeneratedAttribute]
public bool get_IsFile();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppIncludePathsBroker : object {
    private Action`1<FileSystemChangeDelta> myCallback;
    private HashSet`1<VirtualFileSystemPath> myCollectedIncludePaths;
    private IFileSystemTracker myFileSystemTracker;
    private Lifetime myLifetime;
    private object myLocker;
    private CppObjectIntern`1<string> myStringIntern;
    private HashSet`1<VirtualFileSystemPath> myTracedIncludePaths;
    private CompactOneToListMap`2<string, VirtualFileSystemPath> myIncludePathsMap;
    public CppIncludePathsBroker(CppObjectIntern`1<string> stringIntern, Lifetime lifetime, IFileSystemTracker fst);
    public CompactOneToListMap`2<string, VirtualFileSystemPath> GetIncludePathsMap(IList`1<VirtualFileSystemPath> includePaths);
    public IList`1<VirtualFileSystemPath> GetIncludePathsFor(CompactOneToListMap`2<string, VirtualFileSystemPath> includePathMap, IList`1<VirtualFileSystemPath> includePaths, string filename);
    public void Invalidate();
    private void Trace(VirtualFileSystemPath path);
    private static IList`1<VirtualFileSystemPath> GetIncludePathsForImpl(CompactOneToListMap`2<string, VirtualFileSystemPath> includePathMap, IList`1<VirtualFileSystemPath> includePaths, string filename);
    public static IList`1<VirtualFileSystemPath> Intersect(IList`1<VirtualFileSystemPath> first, IList`1<VirtualFileSystemPath> second);
    public static void ProcessIncludePath(CppObjectIntern`1<string> stringIntern, VirtualFileSystemPath includePath, CompactOneToListMap`2<string, VirtualFileSystemPath> accumulator);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppIncludePathWithSearchPath : ValueType {
    public VirtualFileSystemPath IncludePath;
    public VirtualFileSystemPath SearchPath;
    [CanBeNullAttribute]
public VirtualFileSystemPath SearchPathOrigin;
    public CppIncludePathWithSearchPath(VirtualFileSystemPath includePath, VirtualFileSystemPath searchPath, VirtualFileSystemPath pathOrigin);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppInclusionContext : object {
    protected static int BIG_AOT_DEFAULT_CAPACITY;
    protected static int SMALL_AOT_DEFAULT_CAPACITY;
    protected static int SMALL_TB_DEFAULT_CAPACITY;
    protected static int PRESUB_BUFFER_DEFAULT_CAPACITY;
    protected Lifetime myLifetime;
    protected CppFileLocation myBaseFile;
    protected CppFileContextSignatureBuilder myContextSignature;
    protected int myDefinesHashCode;
    protected Dictionary`2<CppIncludeDirectiveContent, CppIncludeDirectiveContent> myIncludeAliases;
    [NotNullAttribute]
protected Marker myMarker;
    protected CppInclusionContext myParent;
    protected Dictionary`2<string, CppPushPopMacroState> myPushPopMacroState;
    protected CppRootInclusionContext myRoot;
    public CppFileLocation BaseFile { get; }
    public IProject BaseProject { get; }
    public CppInclusionContext ParentContext { get; }
    public CppRootInclusionContext RootContext { get; }
    public Lifetime Lifetime { get; }
    protected CppInclusionContext(CppFileLocation baseFile, Lifetime lifetime);
    public CppInclusionContext(CppInclusionContext parent, CppFileLocation baseFile, Lifetime lifetime);
    internal CppInclusionContext(CppInclusionContextSnapshot snapshot, ICppRootFileResolveEntitiesCache resolveCache, bool withFileAnchorsTracker);
    private static CppInclusionContext();
    public CppFileLocation get_BaseFile();
    public IProject get_BaseProject();
    public CppInclusionContext get_ParentContext();
    public CppRootInclusionContext get_RootContext();
    public Lifetime get_Lifetime();
    private static int GetHashCode(CppDefineKey key, CppPPDefineSymbol macro);
    protected void ProcessDefineImpl(CppPPDefineSymbol symbol, CppNonSortedRangeIndex index);
    protected void ProcessDefineImpl(CppPPDefineSymbol symbol, CppDefineKey name, CppNonSortedRangeIndex index);
    protected void ProcessUndefImpl(CppDefineKey name, CppNonSortedRangeIndex index);
    protected void ProcessPragmaPushMacroImpl(string name, CppPPDefineSymbolWithAnchor symbolAndAnchor);
    protected void ProcessPragmaPushMacroImpl(string name, CppNonSortedRangeIndex fileIndex);
    protected void ProcessPragmaPopMacroImpl(string name, CppNonSortedRangeIndex fileIndex);
    protected void ProcessPragmaPopMacroImpl(string name, CppPPDefineSymbolWithAnchor symbolAndAnchor);
    private static Marker FindInclusionContextCommonParent(Marker a, Marker b);
    protected void AddToSignature(CppPPDefineSymbol define, CppDefineKey key, Marker definitionMarker);
    protected void AddDefinedOrNotToSignature(CppDefineKey name, bool isDefined, Marker definitionMarker);
    protected void LogIncludeDirectiveResolveFailure(CppIncludeDirectiveContent directiveContent, bool isIncludeNext);
    public bool IsConformingTable(CppFileSymbolTable table, CppFileContextSignature contextSignature);
    public bool IsConformingForPragmaPops(string name, List`1<int> hashes);
    public CppFileLocation ResolveIncludeDirective(CppIncludeDirectiveContent directiveContent, bool isIncludeNext, String& fileName, Boolean& isPchInclude, VirtualFileSystemPath& searchPath);
    public bool IsDefined(CppDefineKey name, bool notify);
    public CppPPDefineSymbol GetDefinition(CppDefineKey name);
    public CppPPDefineSymbol GetDefinitionAndMarkAsUsed(CppDefineKey key);
    public void ProcessDefine(CppPPDefineSymbol macro);
    public void ProcessUndef(string name);
    public void ProcessPragmaPushMacro(string name);
    public void ProcessPragmaPopMacro(string name);
    public void ProcessIncludeAlias(CppIncludeDirectiveContent aliasName, CppIncludeDirectiveContent targetName);
    public bool IsIncludeAlias(CppIncludeDirectiveContent aliasName);
    public void PushInclude(CppFileLocation include, VirtualFileSystemPath includeSearchPath, bool localInclude);
    public void PopInclude(bool localInclude);
    public bool IsRecursiveInclude(CppFileLocation file);
    public List`1<CppFileLocation> GetIncludes();
    public void PushMacroSymbolsToParent();
    public void SetContextSignatureBuilder(CppFileContextSignatureBuilder builder);
    public virtual CppInclusionContextSnapshot CreateSnapshot();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppInclusionContextResult : ValueType {
    public Status status;
    [CanBeNullAttribute]
public CppInclusionContext value;
    private CppInclusionContextResult(Status status, CppInclusionContext value);
    public bool IsOk();
    public static CppInclusionContextResult Ok(CppInclusionContext value);
    public static CppInclusionContextResult Fail(Status status);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppInclusionContextSnapshot : object {
    internal Lifetime Lifetime;
    internal CppFileLocation BaseFile;
    internal Marker Marker;
    internal int DefinesHashCode;
    internal CppInclusionContextSnapshot Parent;
    internal ValueTuple`2[] PushPopMacroState;
    internal KeyValuePair`2[] IncludeAliases;
    public CppInclusionContextSnapshot(CppFileLocation baseFile, Lifetime lifetime, Marker marker, int definesHashCode, CppInclusionContextSnapshot parent, Dictionary`2<string, CppPushPopMacroState> pushPopMacroState, Dictionary`2<CppIncludeDirectiveContent, CppIncludeDirectiveContent> includeAliases);
    public virtual CppInclusionContext CreateNewContext(ICppRootFileResolveEntitiesCache resolveCache, bool withFileAnchorsTracker);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppInclusionContextUtil : object {
    [ExtensionAttribute]
public static CppFileLocation GetRootBaseFile(CppInclusionContext context);
    public static CppInclusionContext CreateInclusionContext(CppGlobalSymbolCache globalCache, CppFileLocation fileLocation, IProjectFile projectFile, Lifetime lifetime);
    public static CppInclusionContextResult CreateInclusionContext(CppGlobalSymbolCache globalCache, CppFileLocation rootFile, IProjectFile projectFile, FileProcessingOptions options, long cacheVersion, Lifetime lifetime);
    public static CppInclusionContextResult CreateInclusionContextAndInitialize(CppCompilationProperties props, IProject project, IProjectFile projectFile, CppGlobalSymbolCache globalCache, CppFileLocation rootFile, FileProcessingOptions options, long cacheVersion, Lifetime lifetime);
    [ExtensionAttribute]
public static HashSet`1<CppFileLocation> CollectIncludedFiles(CppInclusionContext inclusionContext);
    [ExtensionAttribute]
public static HashSet`1<VirtualFileSystemPath> CollectIncludedFilePaths(CppInclusionContext inclusionContext);
    public static IModuleReferenceResolveContext GetCompilationContext(ICppCompositeNode node);
    public static bool ClrCacheIsReady(CppGlobalSymbolCache symbolCache);
    public static ISymbolScope CalculateClrScope(IProject project, IPsiModule module, CppFileLocation file);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppLexerBuilder : object {
    private IArrayOfTokens myTokens;
    private ThinArrayBuffer myBuffer;
    private ReusableBufferRange myReusableBuffer;
    public int Count { get; }
    public bool IsEmpty { get; }
    public IArrayOfTokens Tokens { get; }
    public IBuffer Buffer { get; }
    public CppLexerBuilder(IArrayOfTokens tokenBuffer, ThinArrayBuffer buffer);
    public void AppendConcat(string nextTokenText, TokenNodeType nextTokenType, CppTokenNodeTypeTraits traits);
    public void AppendConcat(ILexer lexer, CppTokenNodeTypeTraits traits);
    public void AppendConcat(CachingLexer lexer, int start, int end, CppTokenNodeTypeTraits traits);
    public void Append(string token, TokenNodeType tt);
    public void Append(ILexer lexer, TokenNodeType tt);
    public void Append(CppSingletonTokenNodeType tt);
    public void Append(CachingLexer lexer, int start, int end);
    public void AppendBatch(ILexer lexer);
    public void AppendBatch(DelegatingSubLexer lexer);
    public void RemoveComma(int lowerBound);
    public void RemoveComma();
    private static string ConcatTokenText(string left, string right);
    public int FindComma(int lowerBound);
    public Token GetToken(int tokenIndex);
    public int get_Count();
    public bool get_IsEmpty();
    public IArrayOfTokens get_Tokens();
    public IBuffer get_Buffer();
    public CachingLexer CreateLexer(ITokenIntern intern);
    public TokenBuffer CreateTokenBuffer();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppMacroArgumentLexer : DelegatingSubLexer {
    private CppMacroArgumentTokenNodeType myCachedTokenType;
    private short myArgumentIndex;
    private short myCurrentTokenIndex;
    private short myTokenIndexOffset;
    private short myMacroLevel;
    private int myRawStartPosition;
    private int myRawEndPosition;
    public TokenNodeType TokenType { get; }
    public int CurrentPosition { get; public set; }
    public int CurrentTokenIndex { get; }
    public int Line { get; }
    public short MacroLevel { get; }
    public short ArgumentIndex { get; }
    private CppMacroArgumentLexer(TokenBuffer buffer, int start, int rawStart, int end, int rawEnd, short argumentIndex, short tokenIndex, short macroLevel);
    public virtual TokenNodeType get_TokenType();
    public virtual void Start();
    public virtual void Advance();
    public virtual int get_CurrentPosition();
    public virtual void set_CurrentPosition(int value);
    public int get_CurrentTokenIndex();
    public sealed virtual int get_Line();
    public bool MergeWith(CppMacroArgumentLexer lexer);
    public short get_MacroLevel();
    public short get_ArgumentIndex();
    public static CppMacroArgumentLexer Create(TokenBuffer buffer, int start, int rawStart, int end, int rawEnd, short argumentIndex, short macroLevel);
    public static CppMacroArgumentLexer SliceFrom(ILazyCachingLexer lexer, int start, int rawStart, int end, int rawEnd, short argumentIndex, short tokenIndexOffset, short macroLevel);
    public static CppMacroArgumentLexer SafeSliceFrom(ILazyCachingLexer lexer, int start, int rawStart, int end, int rawEnd, short argumentIndex, short tokenIndexOffset, short macroLevel);
    private void AdvanceNotIncrement();
    private void ResetCachedTokenType(CppMacroArgumentTokenNodeType tt);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppMacroArgumentsBuilder : ValueType {
    private CppPreprocessor myExpansionContext;
    private ObjectSubPool`1<PooledPackedArrayOfTokens> myAOTPool;
    private ObjectSubPool`1<PooledThinArrayBuffer> myTBPool;
    private IDictionary`2<string, ArgumentInfo> mySubstitutions;
    public CppPreprocessor ExpansionContext { get; }
    public ObjectSubPool`1<PooledPackedArrayOfTokens> TokensPool { get; }
    public ObjectSubPool`1<PooledThinArrayBuffer> BuffersPool { get; }
    private bool MSVCMode { get; }
    public CppMacroArgumentsBuilder(CppPreprocessor expansionContext, ObjectSubPool`1<PooledPackedArrayOfTokens> AOTPool, ObjectSubPool`1<PooledThinArrayBuffer> TBPool);
    public ArgumentInfo GetSubstitutionFor(string name);
    public void CachePreprocessedArgument(string name, CppLexerBuilder result);
    public bool BuildFor(CppPPDefineSymbol macro);
    public CppPreprocessor get_ExpansionContext();
    public ObjectSubPool`1<PooledPackedArrayOfTokens> get_TokensPool();
    public ObjectSubPool`1<PooledThinArrayBuffer> get_BuffersPool();
    private Nullable`1<CppList`1<CppMacroArgumentLexer>> BuildArguments(int paramCount);
    private static void TrimEdgingFilteredTokens(TokenBuffer buffer, Int32& start, Int32& end);
    private static bool IsTokenWhitespaceOrComment(TokenNodeType tt);
    private bool get_MSVCMode();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppMacroPreSubstitution : object {
    public List`1<Pair`2<int, PastingInfo>> myParameterPointers;
    public TokenBuffer myTokens;
    public CppMacroPreSubstitution(TokenBuffer tokens, List`1<Pair`2<int, PastingInfo>> parameterPointers);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppMacroPreSubstitution2 : object {
    public IBuffer myBuffer;
    public CppList`1<Pair`2<int, PastingInfo>> myParameterPointers;
    public IArrayOfTokens myTokens;
    public CppMacroPreSubstitution2(IBuffer buffer, IArrayOfTokens arrayOfTokens, CppList`1<Pair`2<int, PastingInfo>> parameterPointers);
    public void CheckInvariant();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppNonSortedRangeIndex : ValueType {
    public static CppNonSortedRangeIndex InvalidIndex;
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    public CppNonSortedRangeIndex(int value);
    private static CppNonSortedRangeIndex();
    [CompilerGeneratedAttribute]
public int get_Value();
    public bool IsValid();
    public sealed virtual bool Equals(CppNonSortedRangeIndex other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppNullFileAnchorsTracker : object {
    public static CppNullFileAnchorsTracker Instance;
    public CppNonSortedRangeIndex CurrentFileIndex { get; }
    private static CppNullFileAnchorsTracker();
    public sealed virtual void ProcessGuardedPragmaOnceFile(CppFileLocation file, ICppFileResolveEntitiesCache resolveCache);
    public sealed virtual void ProcessRecursiveInclude(CppFileLocation file, ICppFileResolveEntitiesCache resolveCache);
    public sealed virtual void PushInclude(CppFileLocation file, ICppFileResolveEntitiesCache resolveCache);
    public sealed virtual void PopInclude(ICppFileResolveEntitiesCache resolveCache);
    public sealed virtual ICppFileAnchorsTracker CreateSnapshot();
    public sealed virtual CppNonSortedRangeIndex get_CurrentFileIndex();
}
public enum JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPchInclusionStatus : Enum {
    public int value__;
    public static CppPchInclusionStatus Included;
    public static CppPchInclusionStatus IncludedByForceInclude;
    public static CppPchInclusionStatus NotIncluded;
    public static CppPchInclusionStatus ToBeIncluded;
    public static CppPchInclusionStatus Unknown;
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPPDefineSymbolWithAnchor : ValueType {
    public CppPPDefineSymbol Symbol;
    public CppNonSortedRangeIndex TargetFileIndex;
    public CppPPDefineSymbolWithAnchor(CppPPDefineSymbol symbol, CppNonSortedRangeIndex targetFileIndex);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPPUsageGraph : object {
    private OneToSetMap`2<CppSortedRangeIndex, CppSortedRangeIndex> myUsedSortedFiles;
    public CppPPUsageGraph(OneToSetMap`2<CppSortedRangeIndex, CppSortedRangeIndex> map);
    public ICollection`1<CppSortedRangeIndex> GetUsedFiles(CppSortedRangeIndex sortedFileIndex);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPPUsagesCollection : object {
    private ICppRootFileResolveEntitiesCache myRootCache;
    private OneToSetMap`2<CppNonSortedRangeIndex, CppNonSortedRangeIndex> myUsedFiles;
    public CppPPUsagesCollection(ICppRootFileResolveEntitiesCache rootCache);
    public void AddUsage(CppNonSortedRangeIndex sourceFile, CppNonSortedRangeIndex targetFile);
    public CppPPUsageGraph CreateUsageGraph(CppFileAnchorsTracker tracker, CppSortedRangeIndex currentFileSortedIndex, IEnumerable`1<CppNonSortedRangeIndex> chameleonTargets);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPragmaPackState : ValueType {
    private CppList`1<Nullable`1<UInt32>> myStack;
    private Nullable`1<UInt32> myValue;
    public Nullable`1<UInt32> CurrentValue { get; }
    public CppPragmaPackState(Snapshot snapshot);
    public CppPragmaPackState(Nullable`1<UInt32> value);
    public Nullable`1<UInt32> get_CurrentValue();
    public void Add(Nullable`1<UInt32> value);
    public void Push(Nullable`1<UInt32> value);
    public void Pop();
    public Snapshot CreateSnapshot();
}
public enum JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPragmaWarningMode : Enum {
    public int value__;
    public static CppPragmaWarningMode Default;
    public static CppPragmaWarningMode Disable;
    public static CppPragmaWarningMode Error;
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPreprocessor : object {
    public static int MC_WRAPPERS_MACRO_LEVEL_THRESHOLD;
    private ILexer`1<int> myLexer;
    private ReusableBufferRange myReusableBuffer;
    private CppPreprocessor myParent;
    private string myExpandingMacro;
    private Stack`1<ConditionState> myConditionState;
    private CppPreprocessor myParentForExpanding;
    private CppComplexOffset myStartOffset;
    private List`1<ICppSymbol> myPreprocessorSymbols;
    private bool myWasPragmaOnce;
    private bool myIncludesUEGeneratedHeader;
    private CppFileFlavour myFlavour;
    private int myLine;
    private int myCounter;
    private ITokenProcessor myProcessingChain;
    private CppPPScratchpad myScratchpad;
    private CppScratchpadSavedPos myScratchpadWindowStart;
    [CompilerGeneratedAttribute]
private PPOperatingMode <OperatingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private CppInclusionContext <State>k__BackingField;
    [CompilerGeneratedAttribute]
private FileProcessingOptions <FileProcessingOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private CppTokenNodeTypeTraits <TokenTraits>k__BackingField;
    [CompilerGeneratedAttribute]
private ITokenIntern <TokenIntern>k__BackingField;
    [CompilerGeneratedAttribute]
private short <MacroLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private PPPhase <Phase>k__BackingField;
    private bool ShouldEvalDefinedFunction { get; private set; }
    private bool ShouldAddTokensFromDirective { get; private set; }
    private bool ShouldProcessDirectives { get; }
    private bool AllowGlobalIncludes { get; }
    public PPOperatingMode OperatingMode { get; private set; }
    public IBuffer Buffer { get; }
    public CppInclusionContext State { get; }
    public FileProcessingOptions FileProcessingOptions { get; }
    public CppTokenNodeTypeTraits TokenTraits { get; }
    public ITokenIntern TokenIntern { get; }
    public short MacroLevel { get; }
    public int Line { get; }
    public PPPhase Phase { get; }
    public bool ShouldMimicMSVC { get; }
    public bool IsInsidePrescan { get; }
    private bool HaveScratchpad { get; }
    private int ScratchpadTextLength { get; }
    private CppPreprocessor(ILexer`1<int> lexer, CppInclusionContext state, FileProcessingOptions options, ITokenIntern tokenIntern, IArrayOfTokens tokenBuffer, PPOperatingMode operatingMode, PPPhase phase, bool includesUEGeneratedHeader);
    private CppPreprocessor(ILexer`1<int> lexer, CppPreprocessor parent, PPOperatingMode operatingMode, IArrayOfTokens tokenBuffer, PPPhase phase, bool orphan, int startingFromLine, short macroLevel);
    private CppPreprocessor(ILexer`1<int> lexer, CppPreprocessor parent, PPOperatingMode operatingMode, CppPPScratchpad scratchpad, ITokenProcessor processingChain, PPPhase phase, bool orphan, int startingFromLine, short macroLevel);
    private static bool ShouldBeProcessedAsZero(TokenNodeType tt, CppTokenNodeTypeTraits traits);
    private void ProcessIfElIfDirective();
    private void ProcessDefinedOperator();
    private void ProcessHasInclude(CppMacroArgumentsBuilder args, int onLine, bool isIncludeNext);
    private void ProcessHasBuiltinOrFeatureOrExtension(CppMacroArgumentsBuilder args, int onLine, Func`4<string, CppTokenNodeTypeTraits, CppRootInclusionContext, bool> conditionCalculator);
    private void ProcessHasAttribute(CppMacroArgumentsBuilder args, int onLine, CppPPDefineSymbol macro);
    private static bool IsIdentifierOrKeyword(TokenNodeType tok);
    private static Nullable`1<CppAttributeName> ParseCppAttributeName(ILexer lexer);
    private bool IsInterfaceFollowedByStructOrClass();
    private void ProcessUndefineDirective();
    private void ProcessDefineDirective();
    private void ProcessIncludeDirective();
    private string ParseIncludeDirective(ILexer lexer, int offset, bool addTokens);
    private void ProcessImportDirective();
    private CppPPIncludeSymbol ProcessLocalIncludeDirective(CppFileLocation file, VirtualFileSystemPath includeSearchPath, string fileName, CppComplexOffset complexOffset, string output, bool isPchInclude, bool isIncludeNext);
    private static CppPPUndefSymbol ParseFromDirectiveContent(IBuffer content, int startOffset, int endOffset, CppFileLocation file, CppComplexOffset offset);
    private void ProcessIdentifier();
    public IEnumerable`1<Token> EnumerateTokens();
    public ILazyCachingLexer CreatePreprocessingLexer();
    private bool ProcessMacroSubstitution(CppPPDefineSymbol macro);
    private static CachingLexer ApplyMacroToArguments(CppMacroPreSubstitution preSubstitution, CppMacroArgumentsBuilder& args, int onLine);
    private static string Charize(ILexer stream);
    private static string Stringize(ILexer stream);
    private static PlacemarkerTokens SubstituteRecursive(CppLexerBuilder output, CppMacroPreSubstitution subst, CppMacroArgumentsBuilder& args, int onLine, int firstParameterPointerIndex, int firstPreSubstitutionIndex, int lastParameterPointerIndex, int lastPreSubstitutionTokenIndex);
    private static ILexer`1<int> PreprocessMacroArgument(ArgumentInfo ainfo, string name, CppMacroArgumentsBuilder args, int onLine);
    private static CppMacroPreSubstitution CalculatePresubstitution(CppPPDefineSymbol macro, CppInclusionContext ctx, CppMacroArgumentsBuilder& args);
    private static int StartVaOpt(CppLexerBuilder preSubstituted, CppLazyCachingLexer lexer, PastingInfo& pi, CppList`1& indicesOfUnterminatedVaOpts, int paramPointerIndex);
    private static void EndVaOpt(int preSubstEndPos, List`1<Pair`2<int, PastingInfo>> paramPointers, int parameterPointerIndex, bool stickedRight);
    private static string GetTokenText(CppLazyCachingLexer lexer);
    private bool get_ShouldEvalDefinedFunction();
    private void set_ShouldEvalDefinedFunction(bool value);
    private bool get_ShouldAddTokensFromDirective();
    private void set_ShouldAddTokensFromDirective(bool value);
    private bool get_ShouldProcessDirectives();
    private bool get_AllowGlobalIncludes();
    public static CppPreprocessor Inherit(ILexer`1<int> lexer, CppPreprocessor parent, PPOperatingMode operatingMode, PPPhase phase, bool orphan, IArrayOfTokens tokenBuffer);
    public static CppPreprocessor CreateChained(ILexer`1<int> lexer, CppPreprocessor parent, PPOperatingMode operatingMode, PPPhase phase, bool orphan, int startingFromLine, IArrayOfTokens tokenBuffer);
    public static CppPreprocessor Create(ILexer`1<int> lexer, CppInclusionContext state, FileProcessingOptions options, bool allowGlobalIncludes, bool backedByDocument, Lifetime lifetime);
    public static CppPreprocessor Create(ILexer`1<int> lexer, CppInclusionContext state, FileProcessingOptions options, bool allowGlobalIncludes, bool backedByDocument, ITokenIntern intern, IArrayOfTokens tokenBuffer, bool includesUEGeneratedHeader);
    public static CppPreprocessor CreateForFormattingOptions(ILexer`1<int> lexer, CppInclusionContext state, ITokenIntern intern, IArrayOfTokens tokenBuffer);
    private void InitPreprocessor();
    public void IgnoreBaseLexerInsertDummyTokenUntil(int offset);
    [CompilerGeneratedAttribute]
public PPOperatingMode get_OperatingMode();
    [CompilerGeneratedAttribute]
private void set_OperatingMode(PPOperatingMode value);
    public IBuffer get_Buffer();
    [CompilerGeneratedAttribute]
public sealed virtual CppInclusionContext get_State();
    [CompilerGeneratedAttribute]
public sealed virtual FileProcessingOptions get_FileProcessingOptions();
    [CompilerGeneratedAttribute]
public CppTokenNodeTypeTraits get_TokenTraits();
    public sealed virtual List`1<ICppSymbol> GetPreprocessorSymbols();
    [CompilerGeneratedAttribute]
public ITokenIntern get_TokenIntern();
    public sealed virtual bool HadPragmaOnce();
    public sealed virtual bool IncludesUEGeneratedHeader();
    [CompilerGeneratedAttribute]
public short get_MacroLevel();
    public int get_Line();
    [CompilerGeneratedAttribute]
public PPPhase get_Phase();
    public bool get_ShouldMimicMSVC();
    public bool IsMacroExpanding(string id);
    public bool get_IsInsidePrescan();
    public sealed virtual CppList`1& GetScopes();
    public void PushTokenProcessor(ITokenProcessor p);
    public ITokenProcessor PopTokenProcessor();
    private static CppPreprocessor CreateChained(ILexer`1<int> lexer, CppPreprocessor parent, PPOperatingMode operatingMode, PPPhase phase, bool orphan, int startingFromLine);
    public void PreprocessUpToEnd(ITokenProcessor processor);
    private void ProcessSingleToken();
    private string ParseIncludeAliasFilename(CppLexer subLexer, string pragmaText, int offset, Boolean& isQuoted);
    private void ParseIncludeAliasContent(CppLexer lexer, string pragmaText, int offset);
    private void ParsePragmaPackContent(CppLexer lexer, int offset);
    private bool TryParseUIntArgument(CppLexer& lexer, int offset, UInt32& result);
    private void ParsePragmaWarningContext(CppLexer lexer, int offset);
    private void ProcessPragmaDirective();
    private void ProcessCpp20ImportDirective();
    private string ParseCpp20ModuleName();
    private CppModuleId ParseCpp20ModuleIdInModuleDeclaration();
    private CppModuleId ParseCpp20ModuleIdInImportDeclaration();
    private void ProcessCpp20ModuleDirective();
    private CppComplexOffset GetCurrentPosition(bool macroSymbolPosition, ILexer lexer);
    private CppComplexOffset GetCurrentPosition(bool macroSymbolPosition);
    private bool AtDirectiveContent();
    private void ConsumeTokenFromSubLexer(ICppLexer subLexer, int offset);
    private void ConsumeTokensFromSubLexerWhileFiltered(CppLexer subLexer, int offset);
    private void ConsumeTokensFromSubLexerUntilNull(ICppLexer subLexer, int offset);
    private void ConsumeTokenFromSubLexer(TokenNodeType tokenType, ILexer subLexer, int offset);
    private void AppendPreprocessingResult(TokenNodeType tokenType, int tokenStart, int tokenEnd, UInt32 lexerState);
    private void AppendEndOfDirectiveContentToken();
    private void TrySkipLiteralWithSuffix(ILexer`1<int> lexer, TokenNodeType tt);
    private void AdvanceAs(ILexer`1<int> lexer, TokenNodeType tt);
    private void PushScratchpad(CppPPScratchpad scratchpad);
    private bool get_HaveScratchpad();
    private int get_ScratchpadTextLength();
    private bool ShouldBeUndefined(string macro);
    private void SkipDirectiveWithContent();
    private void AddTokensFromDirective(bool wrapMacroRef);
    private void SkipWhitespaces(ILexer`1<int> lexer);
    private void SkipWhitespacesWoNewLine();
    private void SkipMacroReferenceToken(CppPPDefineSymbol macro);
    private bool CanBeModuleDirective();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPreprocessor2 : object {
    private static int HAS_NEW_LINE_BEFORE;
    private static int DISABLED;
    private static int TOKEN_END_MASK;
    private static StringBuffer EMPTY_BUFFER;
    private static StringBuffer SPACE_BUFFER;
    private CppTokenArrayPool myTokenArrayPool;
    private CppList`1<ICppSequencer> mySeqs;
    private HashSet`1<string> myDisabledMacros;
    private CppInclusionContext myState;
    private CppFileFlavour myFileFlavour;
    private bool myEnableUdl;
    private bool myEnableGnuBuiltins;
    private bool myVCTraditionalPreprocessor;
    private CppTokenNodeTypeTraits myTokenTypeTraits;
    private ITokenIntern myTokenIntern;
    private CppList`1<CppPreprocessedToken> myResultTokens;
    private bool myAllowGlobalIncludes;
    private IntSet myWords;
    private int myResultTokensBase;
    private CppFunctionLikeMacroExpansionSequencer myAlternateResultTokens;
    private List`1<ICppSymbol> myPreprocessorSymbols;
    private CppList`1<CppScopeDescription> myCurrentScopes;
    private bool myPreprocessingOfDirective;
    private int myInterruptionCounter;
    private bool myPreprocessingOfMacroArg;
    private CppList`1<CppToken> myRawMacroArgs;
    private TokenPosition mySavedLexerPosition;
    private int myMacroArgsRollbackPosition;
    private int myCurrentPosition;
    private int myMainFilePosForExpansion;
    private int myOffsetInExpansion;
    private int myMainFileStartOffset;
    private bool myHadPragmaOnce;
    private bool myIncludesUEGeneratedHeader;
    private int myCounterValue;
    private int myDetectionMode;
    private bool myMacroArgumentHadWhitespace;
    private int myNextTokenFlags;
    private int myFileTextSignatureHash;
    private ReusableBufferRange myReusableBufferRange;
    [CompilerGeneratedAttribute]
private FileProcessingOptions <FileProcessingOptions>k__BackingField;
    public CppInclusionContext State { get; }
    public FileProcessingOptions FileProcessingOptions { get; }
    public int CurrentPosition { get; public set; }
    public CppTokenKind TokenType { get; }
    public CppPreprocessor2(CppDocumentBuffer docBuffer, CppInclusionContext state, FileProcessingOptions options, ITokenIntern tokenIntern, IntSet words, bool allowGlobalIncludes);
    private static CppPreprocessor2();
    public static IntSet CreateWordSet();
    public void EnableDetection(bool val);
    public sealed virtual CppList`1& GetScopes();
    public sealed virtual CppInclusionContext get_State();
    [CompilerGeneratedAttribute]
public sealed virtual FileProcessingOptions get_FileProcessingOptions();
    public sealed virtual List`1<ICppSymbol> GetPreprocessorSymbols();
    public sealed virtual bool HadPragmaOnce();
    public sealed virtual bool IncludesUEGeneratedHeader();
    public void AddUdlNameToWordIndex(string suffix);
    public void Start();
    public void SetPositionAndAdvance(int tokenNum);
    public void SetPositionAndAdvanceTrimmable(int tokenNum);
    public void Advance();
    public int get_CurrentPosition();
    public void set_CurrentPosition(int value);
    public CppTokenKind get_TokenType();
    public int GetCurrentTokenCount();
    public string GetTokenText(int tokenIndex);
    public bool HasNewLineBefore(int tokenIndex);
    public CppComplexOffset GetTokenOffset();
    private CppPreprocessedToken GetRawPreprocessedToken(int tokenIndex);
    public IntSet GetWords();
    public int GetFileTextSignatureHash();
    private void AssertMainFilePosForExpansionInvariant();
    private int GetMainFilePosForExpansion();
    private void PopSequencer(ICppSequencer seq);
    private void StoreResultToken(CppToken tok);
    private CppPreprocessedToken ConvertToken(CppToken& tok);
    private void FillResult();
    private void ExpandMacro(CppToken macroNameTok, CppPPDefineSymbol sym);
    private void ExpandObjectLikeMacro(CppToken macroNameTok, CppPPDefineSymbol sym);
    private void ExpandFunctionLikeMacro(CppToken macroNameTok, CppPPDefineSymbol sym);
    private void PreprocessMacroArgument(CppTokenVectorEofSequencer in, CppFunctionLikeMacroExpansionSequencer out);
    private void SaveLexerPosition();
    private int RestoreLexerPosition();
    private void DiscardSavedLexerPosition();
    private void ExpandDefined(CppToken& tok);
    private void ExpandHasInclude(CppToken tok, CppFunctionLikeMacroExpansionSequencer seq, bool isIncludeNext);
    private void ExpandHasBuiltin(CppFunctionLikeMacroExpansionSequencer seq);
    private void ExpandHasCppAttribute(CppFunctionLikeMacroExpansionSequencer seq, CppPPDefineSymbol sym);
    private CppAttributeName ParseCppAttributeName(CppFunctionLikeMacroExpansionSequencer seq);
    private void ExpandHasFeature(CppFunctionLikeMacroExpansionSequencer seq);
    private string GetSingleIdentifierText(CppFunctionLikeMacroExpansionSequencer seq);
    private void ExpandLine();
    private void ExpandCounter();
    private void ExpandFile();
    private void ExpandDate();
    private void ExpandTime();
    private void ExpandTimestamp();
    private void SkipWs(CppToken& tok);
    private CppIncludeDirectiveContent ParseHasIncludeFilename(CppFunctionLikeMacroExpansionSequencer seq);
    private bool IsDefined(CppDefineKey key);
    private bool ShouldBeUndefined(string macroName);
    private static bool IsWhitespace(CppTokenKind tt);
    private static bool IsIdentifier(CppTokenKind tt);
    private static void DisableToken(CppToken& tok);
    private int CurrentLineNumber();
    private bool IsInterfaceFollowedByStructOrClass();
    private static CppTokenOrigin DirectiveOrigin(bool localInclude);
    private static CppIncludeDirectiveContent GetTextInsideQuotes(IBuffer buffer, int start, int end, ITokenIntern intern);
    private static CppIncludeDirectiveContent GetTextInsideAngles(IBuffer buffer, int start, int end, ITokenIntern intern);
    private static int ParameterIndex(CppPPDefineSymbol macro, string name);
    private static int NumberOfParameters(CppPPDefineSymbol macro);
    private CppMacroPreSubstitution2 CalculatePresubstitution(CppPPDefineSymbol macro, CppInclusionContext ctx, CppTokenNodeTypeTraits traits, ITokenIntern tokenIntern, bool emptyVaArgs);
    private static int StartVaOpt(CppLexerBuilder preSubstituted, CppInnerLexer& lexer, PastingInfo& pi, CppList`1& indicesOfUnterminatedVaOpts, int paramPointerIndex);
    private static void EndVaOpt(int preSubstEndPos, CppList`1& paramPointers, int parameterPointerIndex, bool stickedRight);
    private static string GetTokenText(ITokenIntern tokenIntern, CppTokenKind tt, StringBuffer buffer, CppInnerLexer lexer);
    private bool CanBeModuleDirective();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPreprocessorSymbols : ValueType {
    private ICppSymbol[] mySymbols;
    private int myCurrentSymbol;
    public CppPreprocessorSymbols(ICppSymbol[] symbols);
    public ICppSymbol PopSymbol();
    public ICppSymbol PopSymbolBeforeOffset(CppComplexOffset offset);
}
public static class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPreprocessorUtil : object {
    public static bool IsBoostPPVariadicsMSVC(string macroName);
    public static bool IsBoostPPCatI(string macroName);
    public static bool ShouldBeUndefined(CppFileFlavour fileFlavour, string macroName);
    public static int GetInitialCounterValue(CppInclusionContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPushPopMacroState : object {
    public CppList`1<CppPPDefineSymbolWithAnchor> LocalPushOperations;
    public CppList`1<CppPPDefineSymbolWithAnchor> ParentPopOperations;
    public CppPushPopMacroState(CppPushPopMacroState other);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppRootInclusionContext : CppInclusionContext {
    private ILogger myLogger;
    private Dictionary`2<CppPPDefineSymbol, CppMacroPreSubstitution> myPreSubstituted;
    private Dictionary`2<CppPPDefineSymbol, PreSubstited2> myPreSubstituted2;
    private ICollection`1<CppNonSortedRangeIndex> myChameleonUsagesCollector;
    private CoWDictionary`2<CppDefineKey, DefineData> myDefines;
    private Dictionary`2<CppDefineKey, UndefData> myUndefs;
    private List`1<int> myDefinesHashCodes;
    private HashSet`1<CppFileLocation> myIncludedPragmaOnceFiles;
    private HashSet`1<CppFileLocation> myParentIncludedPragmaOnceFiles;
    private CompactOneToListMap`2<string, VirtualFileSystemPath> myIncludePathsMap;
    private List`1<CppFileLocation> myIncludes;
    private List`1<VirtualFileSystemPath> myIncludeSearchPaths;
    private CountingSet`1<CppFileLocation> myIncludesSet;
    private bool myInsideChameleon;
    private HashSet`1<CppFileLocation> myModulesBeingImported;
    public CppPragmaPackState PragmaPackState;
    [CanBeNullAttribute]
private IntSet myPragmaWarningAsError;
    [CanBeNullAttribute]
private IntSet myPragmaWarningDisabled;
    [CompilerGeneratedAttribute]
private CppLanguageDialect <LanguageDialect>k__BackingField;
    [CompilerGeneratedAttribute]
private CppCompilationProperties <CompilationProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CacheVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private CppGlobalSymbolCache <GlobalCache>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppRootFileResolveEntitiesCache <ResolveCache>k__BackingField;
    [CompilerGeneratedAttribute]
private CppPchInclusionStatus <PchInclusionStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<CppFileSymbolTable> <ProcessedSymbolTables>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CppScopeDescription> <NamespaceContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppFileAnchorsTracker <FileAnchorsTracker>k__BackingField;
    [CompilerGeneratedAttribute]
private CppArrayOfTokensPool <PoolForBigArrays>k__BackingField;
    [CompilerGeneratedAttribute]
private CppArrayOfTokensPool <PoolForSmallArrays>k__BackingField;
    [CompilerGeneratedAttribute]
private CppThinArrayBuffersPool <PoolForBuffers>k__BackingField;
    [CompilerGeneratedAttribute]
private IProject <BaseProject>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFile <BaseProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBaseFileExcludedFromBuild>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBaseFileSourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHeaderUnitRoot>k__BackingField;
    private HashSet`1<CppImportModuleDirectiveSymbol> myNotImportedNamedModules;
    private HashSet`1<CppImportHeaderUnitDirectiveSymbol> myNotImportedHeaderUnits;
    public CppLanguageDialect LanguageDialect { get; }
    public CppCompilationProperties CompilationProperties { get; }
    public long CacheVersion { get; }
    public CppGlobalSymbolCache GlobalCache { get; }
    public ICppRootFileResolveEntitiesCache ResolveCache { get; private set; }
    public CppPchInclusionStatus PchInclusionStatus { get; public set; }
    public HashSet`1<CppFileSymbolTable> ProcessedSymbolTables { get; }
    public List`1<CppScopeDescription> NamespaceContext { get; }
    public ICppFileAnchorsTracker FileAnchorsTracker { get; }
    public CppArrayOfTokensPool PoolForBigArrays { get; }
    public CppArrayOfTokensPool PoolForSmallArrays { get; }
    public CppThinArrayBuffersPool PoolForBuffers { get; }
    public IEnumerable`1<CppPPDefineSymbol> AllDefines { get; }
    public IEnumerable`1<CppDefineKey> AllUndefs { get; }
    public IProject BaseProject { get; }
    [CanBeNullAttribute]
public IProjectFile BaseProjectFile { get; }
    public bool IsBaseFileExcludedFromBuild { get; }
    public bool IsBaseFileSourceFile { get; }
    public bool IsHeaderUnitRoot { get; public set; }
    public HashSet`1<CppFileLocation> ModulesBeingImported { get; public set; }
    private CppRootInclusionContext(CppCompilationProperties compilationProperties, CppGlobalSymbolCache globalCache, CppFileLocation baseFile, IProject project, IProjectFile baseProjectFile, CppLanguageDialect dialect, CompactOneToListMap`2<string, VirtualFileSystemPath> includePathsMap, long cacheVersion, bool collectPPUsages, Lifetime lifetime, CoWDictionary`2<CppDefineKey, DefineData> defines);
    private CppRootInclusionContext(CppCompilationProperties compilationProperties, CppGlobalSymbolCache globalCache, CppFileLocation baseFile, IProject project, IProjectFile baseProjectFile, CppLanguageDialect dialect, CompactOneToListMap`2<string, VirtualFileSystemPath> includePathsMap, long cacheVersion, bool collectPPUsages, Lifetime lifetime);
    internal CppRootInclusionContext(CppRootInclusionContextSnapshot snapshot, ICppRootFileResolveEntitiesCache resolveCache, bool withFileAnchorsTracker);
    [CompilerGeneratedAttribute]
public CppLanguageDialect get_LanguageDialect();
    [CompilerGeneratedAttribute]
public CppCompilationProperties get_CompilationProperties();
    [CompilerGeneratedAttribute]
public long get_CacheVersion();
    [CompilerGeneratedAttribute]
public CppGlobalSymbolCache get_GlobalCache();
    [CompilerGeneratedAttribute]
public ICppRootFileResolveEntitiesCache get_ResolveCache();
    [CompilerGeneratedAttribute]
private void set_ResolveCache(ICppRootFileResolveEntitiesCache value);
    [CompilerGeneratedAttribute]
public CppPchInclusionStatus get_PchInclusionStatus();
    [CompilerGeneratedAttribute]
public void set_PchInclusionStatus(CppPchInclusionStatus value);
    [CompilerGeneratedAttribute]
public HashSet`1<CppFileSymbolTable> get_ProcessedSymbolTables();
    [CompilerGeneratedAttribute]
public List`1<CppScopeDescription> get_NamespaceContext();
    [CompilerGeneratedAttribute]
public ICppFileAnchorsTracker get_FileAnchorsTracker();
    [CompilerGeneratedAttribute]
public CppArrayOfTokensPool get_PoolForBigArrays();
    [CompilerGeneratedAttribute]
public CppArrayOfTokensPool get_PoolForSmallArrays();
    [CompilerGeneratedAttribute]
public CppThinArrayBuffersPool get_PoolForBuffers();
    public IEnumerable`1<CppPPDefineSymbol> get_AllDefines();
    public IEnumerable`1<CppDefineKey> get_AllUndefs();
    [CompilerGeneratedAttribute]
public IProject get_BaseProject();
    [CompilerGeneratedAttribute]
public IProjectFile get_BaseProjectFile();
    [CompilerGeneratedAttribute]
public bool get_IsBaseFileExcludedFromBuild();
    [CompilerGeneratedAttribute]
public bool get_IsBaseFileSourceFile();
    [CompilerGeneratedAttribute]
public bool get_IsHeaderUnitRoot();
    [CompilerGeneratedAttribute]
public void set_IsHeaderUnitRoot(bool value);
    public HashSet`1<CppFileLocation> get_ModulesBeingImported();
    public void set_ModulesBeingImported(HashSet`1<CppFileLocation> value);
    public void RegisterNotImportedNamedModule(CppImportModuleDirectiveSymbol symbol);
    public void RegisterNotImportedHeaderUnit(CppImportHeaderUnitDirectiveSymbol symbol);
    public ValueTuple`2<CppList`1<CppImportHeaderUnitDirectiveSymbol>, CppList`1<CppImportModuleDirectiveSymbol>> CollectImportSymbols();
    public void PushNamespace(CppScopeDescription scope);
    public void PopNamespace();
    public void AddPragmaWarning(int code, CppPragmaWarningMode mode);
    public bool TreatWarningAsError(int code);
    public bool WarningIsDisabled(int code);
    public void RawPushInclude(CppFileLocation file, VirtualFileSystemPath includeSearchPath, bool localInclude, CppInclusionContext origin, int definesHashCode);
    public void RawPopInclude(bool localInclude, CppInclusionContext origin);
    public bool RawIsRecursiveInclude(CppFileLocation file, int definesHashCode);
    public List`1<CppFileLocation> GetRawIncludes();
    public VirtualFileSystemPath GetSearchPathOfLastInclude();
    public CppMacroPreSubstitution GetPreSubstitutedFor(CppPPDefineSymbol s);
    public CppMacroPreSubstitution PutPreSubstitutedFor(CppPPDefineSymbol s, CppMacroPreSubstitution pre);
    public CppMacroPreSubstitution2 GetPreSubstitutedFor2(CppPPDefineSymbol s, bool emptyVaArgs);
    public void PutPreSubstitutedFor2(CppPPDefineSymbol s, CppMacroPreSubstitution2 pre, bool emptyVaArgs);
    public void ClearAllPreSubstituted();
    public ILogger GetLogger();
    public IList`1<VirtualFileSystemPath> CachedIncludePathsFor(string name);
    public IList`1<VirtualFileSystemPath> IncludePathsFor(string name);
    public bool IsDefined(CppDefineKey name, bool notify, Marker& marker);
    public CppPPDefineSymbol GetDefinition(CppDefineKey name, bool notify, Marker& marker);
    public void AddDefine(CppDefineKey name, CppNonSortedRangeIndex targetFileIndex, Marker marker, CppPPDefineSymbol symbol);
    public void AddUndef(CppDefineKey name, CppNonSortedRangeIndex targetFileIndex, Marker marker);
    public void RemoveDefine(CppDefineKey name);
    public bool RemoveUndef(CppDefineKey name);
    public void MarkIncludedPragmaOnceFile(CppFileLocation file);
    public bool IsIncludedPragmaOnceFile(CppFileLocation file);
    public HashSet`1<CppFileLocation> CopyIncludedPragmaOnceFiles();
    public void MarkAnchorUsed(CppNonSortedRangeIndex targetIndex, bool notify);
    public void OnStartChameleon(ICollection`1<CppNonSortedRangeIndex> chameleonUsagesCollector);
    public void OnEndChameleon();
    public virtual CppInclusionContextSnapshot CreateSnapshot();
    [CanBeNullAttribute]
public Int32[] CopyPragmaWarningAsErrors();
    [CanBeNullAttribute]
public Int32[] CopyPragmaWarningDisabled();
    private static Int32[] ToArray(IntSet set);
    private static CountingSet`1<T> CopyCountingSet(CountingSet`1<T> source);
    public static CppRootInclusionContext Create(CppCompilationProperties props, IProject project, IProjectFile baseProjectFile, CppGlobalSymbolCache globalCache, CppFileLocation baseFile, CppFileLocation sourceFile, CppLanguageDialect dialect, long cacheVersion, bool allowPendingActions, bool collectPPUsages, Lifetime lifetime, ISymbolScope clrSymbolScope);
    public static CppRootInclusionContext Create_ForLexerTest(CppCompilationProperties props, IProject project, IProjectFile baseProjectFile, CppGlobalSymbolCache globalCache, CppFileLocation baseFile, CppFileLocation sourceFile, CppLanguageDialect dialect, long cacheVersion, bool allowPendingActions, bool collectPPUsages, Lifetime lifetime, ISymbolScope clrSymbolScope);
    private CppFileResolveEntitiesCache CreateResolveCache(bool allowPendingActions, bool collectPPUsages, CppFileLocation sourceFile, ISymbolScope clrSymbolScope);
    public static CppRootInclusionContext CreateEmptyContext(CppGlobalSymbolCache globalCache, IPsiModule module, CppLanguageDialect dialect);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertNotInsideChameleon();
    private IList`1<VirtualFileSystemPath> IncludePathsFor(string name, bool returnCachedMap);
    [CompilerGeneratedAttribute]
internal static IntSet <.ctor>g__ToSet|120_0(Int32[] array);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppRootInclusionContextSnapshot : CppInclusionContextSnapshot {
    internal ISymbolScope ClrScope;
    internal CppLanguageDialect LanguageDialect;
    internal CppCompilationProperties CompilationProperties;
    internal CppGlobalSymbolCache GlobalCache;
    internal long CacheVersion;
    internal CppPchInclusionStatus PchInclusionStatus;
    internal CppFileSymbolTable[] ProcessedSymbolTables;
    internal IProject BaseProject;
    internal IProjectFile BaseProjectFile;
    internal Dictionary`2<CppDefineKey, DefineData> Defines;
    internal KeyValuePair`2[] Undefs;
    internal CppFileLocation[] IncludedPragmaOnceFiles;
    internal HashSet`1<CppFileLocation> ParentIncludedPragmaOnceFiles;
    internal CppFileLocation[] Includes;
    internal CountingSet`1<CppFileLocation> IncludesSet;
    internal Int32[] DefinesHashCodes;
    internal CompactOneToListMap`2<string, VirtualFileSystemPath> IncludePathsMap;
    internal VirtualFileSystemPath[] IncludeSearchPaths;
    internal CppScopeDescription[] NamespaceContext;
    internal ICppFileAnchorsTracker FileAnchorsTracker;
    internal Snapshot PragmaPack;
    internal Int32[] PragmaWarningAsErrors;
    internal Int32[] PragmaWarningDisabled;
    public CppRootInclusionContextSnapshot(CppFileLocation baseFile, Lifetime lifetime, Marker marker, int definesHashCode, Dictionary`2<string, CppPushPopMacroState> pushPopMacroState, Dictionary`2<CppIncludeDirectiveContent, CppIncludeDirectiveContent> includeAliases);
    public virtual CppInclusionContext CreateNewContext(ICppRootFileResolveEntitiesCache resolveCache, bool withFileAnchorsTracker);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppScopeDescription : ValueType {
    [CompilerGeneratedAttribute]
private CppScopeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exported>k__BackingField;
    public CppScopeKind Kind { get; public set; }
    public CppQualifiedNamePart Name { get; public set; }
    public bool Exported { get; public set; }
    public CppScopeDescription(CppScopeKind Kind, CppQualifiedNamePart Name, bool Exported);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CppScopeKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(CppScopeKind value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CppQualifiedNamePart get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(CppQualifiedNamePart value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_Exported();
    [CompilerGeneratedAttribute]
public void set_Exported(bool value);
    public static bool IsLocalScope(CppList`1<CppScopeDescription> stack);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CppScopeDescription left, CppScopeDescription right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CppScopeDescription left, CppScopeDescription right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CppScopeDescription other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(CppScopeKind& Kind, CppQualifiedNamePart& Name, Boolean& Exported);
}
public enum JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppScopeKind : Enum {
    public byte value__;
    public static CppScopeKind LinkageSpec;
    public static CppScopeKind ExportBlock;
    public static CppScopeKind Namespace;
    public static CppScopeKind Local;
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppSortedRangeIndex : ValueType {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    public CppSortedRangeIndex(int value);
    [CompilerGeneratedAttribute]
public int get_Value();
    public bool IsValid();
    public sealed virtual bool Equals(CppSortedRangeIndex other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppSortedRangesView : ValueType {
    private IList`1<CppFileAnchorsRange> myList;
    private IList`1<CppNonSortedRangeIndex> mySortedIndicies;
    public CppFileAnchorsRange Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public CppSortedRangesView(IList`1<CppFileAnchorsRange> list, IList`1<CppNonSortedRangeIndex> sortedIndicies);
    public sealed virtual CppFileAnchorsRange get_Item(int index);
    public sealed virtual void set_Item(int index, CppFileAnchorsRange value);
    public sealed virtual bool Contains(CppFileAnchorsRange item);
    public sealed virtual int IndexOf(CppFileAnchorsRange item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(CppFileAnchorsRange range);
    public sealed virtual void Insert(int index, CppFileAnchorsRange range);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool Remove(CppFileAnchorsRange range);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(CppFileAnchorsRange[] arr, int i);
    public sealed virtual IEnumerator`1<CppFileAnchorsRange> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppThinArrayBuffersPool : AbstractObjectPoolWithSubPools`1<PooledThinArrayBuffer> {
    private CharArrayBuffersPool myBufferPool;
    private int myDefaultCapacity;
    public CppThinArrayBuffersPool(CharArrayBuffersPool bufferPool, int capacityOfArrayOfTokens);
    protected virtual PooledThinArrayBuffer CreateObject();
    protected virtual void ClearObject(PooledThinArrayBuffer t);
    protected virtual void InitObject(PooledThinArrayBuffer t);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppUndefMapPool : AutoClearingThreadSafeObjectPool`1<Dictionary`2<CppDefineKey, UndefData>> {
    public static int CheckPeriod;
    public CppUndefMapPool(Lifetime lifetime);
    protected virtual Dictionary`2<CppDefineKey, UndefData> CreateObject();
    protected virtual void ClearObject(Dictionary`2<CppDefineKey, UndefData> undefs);
    protected virtual void InitObject(Dictionary`2<CppDefineKey, UndefData> undefs);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.DelegatingSubLexer : object {
    protected CachingLexer myInnerLexer;
    protected TokenBuffer myTokenBuffer;
    protected IBuffer myProjection;
    protected int myStartTextOffset;
    protected int myEndTextOffset;
    protected int myStartPosition;
    protected int myEndPosition;
    protected bool myExhausted;
    private object JetBrains.ReSharper.Psi.Parsing.ILexer.CurrentPosition { get; private set; }
    public int CurrentPosition { get; public set; }
    public TokenNodeType TokenType { get; }
    public IBuffer Buffer { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public UInt32 LexerStateEx { get; }
    public CachingLexer InnerLexer { get; }
    public int StartPosition { get; }
    public int EndPosition { get; }
    public TokenBuffer TokenBuffer { get; }
    public DelegatingSubLexer(TokenBuffer tokenBuffer, int start, int end);
    public virtual void Start();
    public virtual void Advance();
    public virtual void SetPositionAndAdvance(int tokenNum);
    private sealed virtual override object JetBrains.ReSharper.Psi.Parsing.ILexer.get_CurrentPosition();
    private sealed virtual override void JetBrains.ReSharper.Psi.Parsing.ILexer.set_CurrentPosition(object value);
    public virtual int get_CurrentPosition();
    public virtual void set_CurrentPosition(int value);
    public virtual TokenNodeType get_TokenType();
    public virtual IBuffer get_Buffer();
    public virtual int get_TokenStart();
    public virtual int get_TokenEnd();
    public virtual UInt32 get_LexerStateEx();
    public virtual bool MergeWith(DelegatingSubLexer lexer);
    public void ResetStartPosition(int startPosition);
    public void ResetEndPosition(int endPosition);
    public CachingLexer get_InnerLexer();
    public int get_StartPosition();
    public int get_EndPosition();
    public virtual TokenBuffer get_TokenBuffer();
    public static DelegatingSubLexer Create(ILexer`1<int> lexer, int start, int end);
    protected void CheckWhetherExhausted();
}
public interface JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.ICppFileAnchorsTracker {
    public CppNonSortedRangeIndex CurrentFileIndex { get; }
    public abstract virtual CppNonSortedRangeIndex get_CurrentFileIndex();
    public abstract virtual void ProcessGuardedPragmaOnceFile(CppFileLocation file, ICppFileResolveEntitiesCache resolveCache);
    public abstract virtual void ProcessRecursiveInclude(CppFileLocation file, ICppFileResolveEntitiesCache resolveCache);
    public abstract virtual void PushInclude(CppFileLocation file, ICppFileResolveEntitiesCache resolveCache);
    public abstract virtual void PopInclude(ICppFileResolveEntitiesCache resolveCache);
    public abstract virtual ICppFileAnchorsTracker CreateSnapshot();
}
public interface JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.ICppPreprocessor {
    public CppInclusionContext State { get; }
    public FileProcessingOptions FileProcessingOptions { get; }
    public abstract virtual CppInclusionContext get_State();
    public abstract virtual FileProcessingOptions get_FileProcessingOptions();
    public abstract virtual List`1<ICppSymbol> GetPreprocessorSymbols();
    public abstract virtual bool HadPragmaOnce();
    public abstract virtual bool IncludesUEGeneratedHeader();
    public abstract virtual CppList`1& GetScopes();
}
public interface JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.IGameEngineIncludeDirectiveProvider {
    public bool Active { get; }
    public abstract virtual bool get_Active();
    public abstract virtual IEnumerable`1<CppIncludePath> ProvideIncludePaths(ICppFileReference& modreq(System.Runtime.InteropServices.InAttribute) reference);
}
public interface JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.IInclusionContextProvider {
    public abstract virtual CppInclusionContextResult CreateInclusionContextResult(CppGlobalSymbolCache cache, CppFileLocation rootFile, FileProcessingOptions options, long cacheVersion, Lifetime lifetime);
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.PooledPackedArrayOfTokens : PackedArrayOfTokensBase {
    private PackedTokensPagesPool myPackedTokensPagesPool;
    public PooledPackedArrayOfTokens(PackedTokensPagesPool pagesPool, int capacity);
    public virtual void Clear();
    protected virtual void ProvideSpaceFor(int nItems);
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.PreSubstited2 : ValueType {
    public CppMacroPreSubstitution2 ForNonEmptyVaArgs;
    public CppMacroPreSubstitution2 ForEmptyVaArgs;
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.PsiBuilderWarningElement : CompositeElement {
    public static CompositeNodeWithArgumentType NODE_TYPE;
    private string myErrorDescription;
    public string ErrorDescription { get; }
    public PsiLanguageType Language { get; }
    public NodeType NodeType { get; }
    public PsiBuilderWarningElement(string errorDescription);
    private static PsiBuilderWarningElement();
    public sealed virtual string get_ErrorDescription();
    public virtual PsiLanguageType get_Language();
    public virtual NodeType get_NodeType();
    public virtual bool IsFiltered();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.RollbackDetectionModeGuard`2 : ValueType {
    private DetectionModeGuard`2<TTraits, TMarkerGuard> myDetectionModeGuard;
    private TMarkerGuard myMarkerGuard;
    private CppParsingBase`2<TTraits, TMarkerGuard> myOwner;
    private bool myResetCursor;
    public RollbackDetectionModeGuard`2(CppParsingBase`2<TTraits, TMarkerGuard> pp, bool resetCursor);
    public sealed virtual void Dispose();
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.SkipCtorBlockElement`2 : ValueType {
    private CppParsingBase`2<TTraits, TMarkerGuard> myParsing;
    private ICppFunctionDeclaratorBuilder myDeclaratorBuilder;
    private bool myLearnParsing;
    [CompilerGeneratedAttribute]
private bool <IsExited>k__BackingField;
    public bool IsExited { get; private set; }
    public SkipCtorBlockElement`2(CppParsingBase`2<TTraits, TMarkerGuard> parsing, ICppFunctionDeclaratorBuilder declaratorBuilder, bool learnParsing);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsExited();
    [CompilerGeneratedAttribute]
private void set_IsExited(bool value);
    public sealed virtual void Invoke();
}
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.SkipFunctionTryBlockElement`2 : ValueType {
    private CppParsingBase`2<TTraits, TMarkerGuard> myParsing;
    private ICppFunctionDeclaratorBuilder myBuilder;
    [CompilerGeneratedAttribute]
private bool <IsExited>k__BackingField;
    public bool IsExited { get; private set; }
    public SkipFunctionTryBlockElement`2(CppParsingBase`2<TTraits, TMarkerGuard> parsing, ICppFunctionDeclaratorBuilder builder);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsExited();
    [CompilerGeneratedAttribute]
private void set_IsExited(bool value);
    public sealed virtual void Invoke();
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.StandStillGuard`2 : ValueType {
    private CppParsingBase`2<TTraits, TMarkerGuard> myParsing;
    private int myOldPos;
    public bool IsStandStill { get; }
    public StandStillGuard`2(CppParsingBase`2<TTraits, TMarkerGuard> parsing);
    public bool get_IsStandStill();
    public void AdvanceIfStandStill(string errorResourceName);
    public void AdvanceIfStandStill();
}
public class JetBrains.ReSharper.Psi.Cpp.Parsing.TokenPosition : ValueType {
    public CppTokenKind CurrTokenType;
    public int YyBufferIndex;
    public int YyBufferStart;
    public int YyBufferEnd;
    public CppLexerState YyLexicalState;
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Parsing.TrivialDeclarationSpecifierChecker : ValueType {
    private DeclaratorParseType myType;
    public TrivialDeclarationSpecifierChecker(DeclaratorParseType type);
    private static string SpecsToString(CppDeclarationSpecifiers specs, bool isExplicit);
    public sealed virtual string Invoke(ICppDeclarationBuilder declBuilder, TokenNodeType tt);
}
public class JetBrains.ReSharper.Psi.Cpp.Presentation.CppColorizedPresenter : CppPresenter {
    public bool HasStyling { get; }
    public CppColorizedPresenter(CppPresentationParameters params, CppPresentationContext& context);
    public static CppColorizedPresenter FromPsi(ITreeNode context);
    public sealed virtual bool get_HasStyling();
    public sealed virtual string PresentValue(ICppValue value);
    public sealed virtual string PresentQualifiedNameOfTypeImpl(CppQualifiedNameWithTag typeName, CppQualType presentedType);
    public sealed virtual string PresentQualifiedNameOfResolveEntity(CppQualifiedName typeName, ICppResolveEntity entity);
    public virtual string GetAttributeByEntity(ICppResolveEntity entity);
    public virtual string AsStyled(string str, string attributeId, JetFontStyles style);
    public virtual void ToRichText(string str, CppHighlighterColorCache colorCache, RichText result, JetFontStyles fontStyle, EffectStyle effect, TextRange[] rangesToRemap);
    [CanBeNullAttribute]
public static ICppResolveEntity GetResolveEntity(CppQualType type);
    private void PresentQualifiedNameOfResolveEntity(CppQualifiedName typeName, ICppResolveEntity entity, StringBuilder output);
    private void PresentQualifier(CppQualifiedName qualifier, ICppResolveEntity entity, StringBuilder output);
    [CanBeNullAttribute]
private static string PresentChar(byte b);
    [CanBeNullAttribute]
private static string PresentWChar(char c);
    [CanBeNullAttribute]
private static string PresentChar32(UInt32 c);
    private static CppQualifiedName Patch(CppQualifiedName qualName, CppQualifiedName original);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
internal static CppNamespaceResolveEntity <PresentQualifier>g__SkipInlineNamespaces|12_0(CppNamespaceResolveEntity ns, CppQualifiedNamePart name);
}
public static class JetBrains.ReSharper.Psi.Cpp.Presentation.CppColorizedPresenterUtil : object {
    public static string MakeStyled(string str, string attributeId, JetFontStyles style);
    public static void ToRichText(string str, CppHighlighterColorCache colorCache, JetFontStyles fontStyle, EffectStyle effect, RichText result, TextRange[] rangesToRemap);
    public static string ClearStyling(string str);
    public static int GetLengthWithoutStyling(string str);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Presentation.CppColorizedPresenterUtil/<ParseString>d__5")]
private static IEnumerable`1<ParsedPart> ParseString(string str);
    private static void AppendFontStyle(JetFontStyles fontStyle, StringBuilder result);
    private static Nullable`1<JetFontStyles> ReadFontStyle(char c);
    private static TextStyle MakeTextStyle(JetFontStyles fs, string highlighting, CppHighlighterColorCache colorCache);
    [CompilerGeneratedAttribute]
internal static List`1<ValueTuple`2<int, int>> <ToRichText>g__BuildMapping|1_2(IEnumerable`1<int> offsets);
    [CompilerGeneratedAttribute]
internal static Nullable`1<T> <ToRichText>g__TryGet|1_3(List`1<T> list, int index);
    [CompilerGeneratedAttribute]
internal static TextRange <ToRichText>g__WithStartOffset|1_4(TextRange range, int newStartOffset);
    [CompilerGeneratedAttribute]
internal static TextRange <ToRichText>g__WithEndOffset|1_5(TextRange range, int newEndOffset);
}
public class JetBrains.ReSharper.Psi.Cpp.Presentation.CppDeclarationStringPresentationBuilder : ValueType {
    private CppPresentedDeclarationSpecifiers myPresentedDeclarationSpecs;
    private string myPrefixStr;
    private bool myIsPackExpansion;
    private StringBuilder mySuffixSb;
    private ICppPresenter myPresenter;
    private DeclaredElementPresenterMarking myMarking;
    private int myMarkingOffset;
    private Parameter[] myParameterMarking;
    public bool IsPackExpansion { get; }
    public CppDeclarationStringPresentationBuilder(ICppPresenter presenter, int markingOffset, DeclaredElementPresenterMarking marking);
    public sealed virtual void Parenthesize();
    public sealed virtual void PrependCallingConvention(CppCallingConvention cc, bool wasPointer, bool wasMember);
    public sealed virtual void PrependToken(CppTokenNodeType tt);
    public sealed virtual void PrependCVQualifiers(CVQualifiers cv);
    public sealed virtual void PrependMemberPointerNameQualifier(CppPresentedDeclarator type);
    public sealed virtual void PrependSpace();
    public sealed virtual void AppendArraySize(string arraySize);
    public sealed virtual void PrependGnuAttribute(string attrName, string argument);
    public void AppendFunctionParametersInParentheses(IList`1<string> parameters, CppEllipsisKind ellipsisKind, bool explicitThis, bool isTopLevelType, Parameter[] paramMarkings);
    public sealed virtual void AppendFunctionParameters(IList`1<string> parameters, CppEllipsisKind ellipsisKind, bool explicitThis, bool isTopLevelType, Qualifiers quals, CppRestrictionSpecifiers restrictSpecs, string exceptionSpecification, string trailingReturnType);
    public sealed virtual void AddPackExpansion();
    public sealed virtual void LearnDeclarationSpecifiers(string type, CVQualifiers cvQuals, CppDeclSpecPlacement cvPlacement, CppClassTag clsTag, Signing signed, int shortLong);
    public sealed virtual void LearnInputQualifiers(InputQualifiers qualifiers);
    public sealed virtual CppPresentedDeclarator Finish(InputQualifiers qualifiers, bool putSpaceAfterPtr, string declaratorNameForMarking, bool seenFunctionType, bool wasParenthesized);
    public CppPresentedDeclarationSpecifiers GetDeclSpecs();
    public string GetDeclaratorPrefix();
    public string GetPrefix();
    public int GetPrefixLength();
    public string GetSuffix();
    public bool get_IsPackExpansion();
    public void UpdateMarkingForDeclarationName(string declarationName, bool needSpaceBeforeName);
    public string GetResult();
    private Parameter[] ComposeUpdatedParameterRanges(int lenBetweenPrefixAndSuffix);
    private void PrependToPrefix(string str);
}
public static class JetBrains.ReSharper.Psi.Cpp.Presentation.CppHighlightingAttributeIds : object {
    public static string CPP_NAMESPACE_ATTRIBUTE;
    public static string CPP_CLASS_ATTRIBUTE;
    public static string CPP_STRUCT_ATTRIBUTE;
    public static string CPP_ENUM_ATTRIBUTE;
    public static string CPP_UNION_ATTRIBUTE;
    public static string CPP_LOCAL_VARIABLE_ATTRIBUTE;
    public static string CPP_PARAMETER_VARIABLE_ATTRIBUTE;
    public static string CPP_GLOBAL_VARIABLE_ATTRIBUTE;
    public static string CPP_STRUCT_FIELD_ATTRIBUTE;
    public static string CPP_CLASS_FIELD_ATTRIBUTE;
    public static string CPP_STATIC_FIELD_ATTRIBUTE;
    public static string CPP_UNION_MEMBER_ATTRIBUTE;
    public static string CPP_ENUMERATOR_ATTRIBUTE;
    public static string CPP_TYPEDEF_ATTRIBUTE;
    public static string CPP_GLOBAL_FUNCTION_ATTRIBUTE;
    public static string CPP_GLOBAL_FUNCTION_USAGE_ATTRIBUTE;
    public static string CPP_MEMBER_FUNCTION_ATTRIBUTE;
    public static string CPP_MEMBER_FUNCTION_USAGE_ATTRIBUTE;
    public static string CPP_STATIC_MEMBER_FUNCTION_ATTRIBUTE;
    public static string CPP_STATIC_MEMBER_FUNCTION_USAGE_ATTRIBUTE;
    public static string CPP_OVERLOADED_OPERATOR_ATTRIBUTE;
    public static string CPP_TEMPLATE_PARAMETER_ATTRIBUTE;
    public static string CPP_NON_TYPE_TEMPLATE_PARAMETER_ATTRIBUTE;
    public static string CPP_DEPENDENT_NAME_ATTRIBUTE;
    public static string CPP_MACRO_NAME_ATTRIBUTE;
    public static string CPP_PREPROCESSOR_INACTIVE_BRANCH_ATTRIBUTE;
    public static string CPP_MACRO_PARAMETER_ATTRIBUTE;
    public static string CPP_UE4_REFLECTION_SPECIFIER_NAME_ATTRIBUTE;
    public static string CPP_DEDUCTION_GUIDE_ATTRIBUTE;
    public static string CPP_CONCEPT_ATTRIBUTE;
    public static string CPP_MODULE_ATTRIBUTE;
    public static string CPP_CLASS_IS_INHERITED_ATTRIBUTE;
    public static string CPP_DECLARATOR_IS_INHERITED_ATTRIBUTE;
    public static string CPP_DECLARATOR_OVERRIDES_ATTRIBUTE;
    public static string CPP_DECLARATOR_HIDES_ATTRIBUTE;
    public static string CPP_DECLARATOR_IMPLEMENTS_ATTRIBUTE;
    public static string CPP_DECLARATION_DEFINITION_ATTRIBUTE;
    public static string CPP_SPECIALIZATIONS_ATTRIBUTE;
    public static string CPP_DECLARATION_HIDES_LOCAL_ATTRIBUTE;
    public static string CPP_TEMPLATE_PARAMETER_SHADOWING_ATTRIBUTE;
    public static string CPP_MISMATCHED_CLASS_TAGS_ATTRIBUTE;
    public static string CPP_REDEFINITION_ATTRIBUTE;
    public static string CPP_MAIN_RUNNER_ATTRIBUTE;
    public static string CPP_DOXYGEN_COMMAND;
    public static string CPP_DOXYGEN_COMMAND_VALUE;
    public static string CPP_DOXYGEN_COMMENT;
    public static string CPP_LINE_COMMENT;
    public static string CPP_BLOCK_COMMENT;
    public static string CPP_STRING_LITERAL;
    public static string CPP_RAW_STRING_LITERAL;
    public static string CPP_INTEGER_LITERAL;
    public static string CPP_FLOAT_LITERAL;
    public static string CPP_CHARACTER_LITERAL;
    public static string CPP_KEYWORD;
    public static string CPP_THIS_KEYWORD;
    public static string CPP_DIRECTIVE;
    public static string CPP_VALID_STRING_ESCAPE;
    public static string CPP_INVALID_STRING_ESCAPE;
    public static string CPP_DOT;
    public static string CPP_COMMA;
    public static string CPP_SEMICOLON;
    public static string CPP_PARENTHESES;
    public static string CPP_BRACKETS;
    public static string CPP_BRACES;
    public static string CPP_OPERATOR_SIGN;
    public static string CPP_HEADER_PATH;
}
public class JetBrains.ReSharper.Psi.Cpp.Presentation.CppNamePartPresenter : object {
    public static CppNamePartPresenter Instance;
    private static CppNamePartPresenter();
    public sealed virtual string Visit(ICppPresenter data, CppQualifiedId name);
    public sealed virtual string Visit(ICppPresenter data, CppDestructorTag name);
    public sealed virtual string Visit(ICppPresenter data, CppOperatorId name);
    public sealed virtual string Visit(ICppPresenter data, CppConversionId name);
    public sealed virtual string Visit(ICppPresenter data, CppUserDefinedLiteralId name);
    public sealed virtual string Visit(ICppPresenter data, CppAnonymousId name);
    public sealed virtual string Visit(ICppPresenter data, CppDecltypeDestructorTag name);
    public sealed virtual string Visit(ICppPresenter data, CppDecltypeId name);
    public sealed virtual string Visit(ICppPresenter data, CppTypeOfTypeId name);
    public sealed virtual string Visit(ICppPresenter data, CppGlobalNamespaceId _);
    public sealed virtual string Visit(ICppPresenter data, CppMSSuperId name);
    public sealed virtual string Visit(ICppPresenter data, CppLambdaId name);
    public sealed virtual string Visit(ICppPresenter data, CppConversionsPackId name);
    public sealed virtual string Visit(ICppPresenter data, CppTemplateId name);
    public sealed virtual string Visit(ICppPresenter data, CppSubstitutionId name);
    public sealed virtual string Visit(ICppPresenter data, CppAnonymousLinkageId name);
    public sealed virtual string Visit(ICppPresenter data, CppLinkageTemplateId name);
    public sealed virtual string Visit(ICppPresenter data, CppResolvedStructuredBindingId name);
    public sealed virtual string Visit(ICppPresenter data, CppUnresolvedStructuredBindingId name);
    public sealed virtual string Visit(ICppPresenter data, CppCliSimpleTypeId name);
    public sealed virtual string Visit(ICppPresenter data, CppCliFinalizerTag name);
    public sealed virtual string Visit(ICppPresenter data, CppModuleTemplateId name);
    public sealed virtual string Visit(ICppPresenter data, CppModuleSubstitutionId name);
    private string ReApply(ICppPresenter data, CppQualifiedNamePart name);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Presentation.CppPPPresenterUtil : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Presentation.CppPPPresenterUtil/<GetMacroBodyHighlighters>d__0")]
public static IEnumerable`1<ValueTuple`3<ITreeNode, string, int>> GetMacroBodyHighlighters(MacroDefinition macroDef, CppInclusionContext inclusionContext);
    private static ISet`1<string> GetMacroParameterNames(MacroDefinition definition);
    private static bool TokenIsMacroReference(ITreeNode token, CppInclusionContext inclusionContext);
    [ExtensionAttribute]
public static void PresentMacroParameterSymbol(ICppPrettyPrinter presenter, CppPPMacroParameterSymbol parameter, StringBuilder header, bool presentElementTypeInParens);
    [ExtensionAttribute]
public static CppPresentedDefineSymbol PresentDefineSymbol(ICppPrettyPrinter presenter, CppPPDefineSymbol define, IPsiServices psiServices, ITreeNode context);
    [ExtensionAttribute]
private static CppPresentedDefineSymbol PresentRawSubstitution(ICppPrettyPrinter presenter, CppPPDefineSymbol defineSymbol, bool showBody);
    [ExtensionAttribute]
private static Nullable`1<CppPresentedDefineSymbol> PresentColorizedMacroBody(ICppPrettyPrinter presenter, CppPPDefineSymbol define, IPsiServices psiServices, ITreeNode context);
    private static MacroDefinition CreateMacroDefinition(CppElementFactory ef, CppPPDefineSymbol define);
    private static ValueTuple`2<string, TextRange[]> PresentParameters(ICppPrettyPrinter presenter, CppPPDefineSymbol defineSymbol);
    private static ValueTuple`2<string, TextRange[]> PresentParameters(ICppPrettyPrinter presenter, MacroDefinition macroDef);
    private static ValueTuple`2<string, TextRange[]> PresentParameters(ICppPrettyPrinter presenter, IEnumerable`1<string> paramNames);
    [NotNullAttribute]
private static List`1<string> PresentBody(ICppPrettyPrinter presenter, MacroDefinition macroDef, CppInclusionContext inclusionContext);
    private static void ReformatBody(IList`1<string> body);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Presentation.CppPPPresenterUtil/<PresentBodyImpl>d__13")]
[NotNullAttribute]
private static IEnumerable`1<string> PresentBodyImpl(ICppPrettyPrinter presenter, MacroDefinition macroDef, CppInclusionContext inclusionContext);
    [NotNullAttribute]
public static string PresentUnknownNode(ICppPrettyPrinter presenter, CppFromSubstitutionTokenNode token, CppLanguageDialect dialect);
    [NotNullAttribute]
private static string PresentUnknownNode(ICppPrettyPrinter presenter, ITreeNode node, string text, CppLanguageDialect dialect);
    private static string PresentMacroName(ICppPrettyPrinter presenter, string name);
    [CompilerGeneratedAttribute]
internal static IPsiModule <PresentColorizedMacroBody>g__TryGetPsiModule|6_0(CppSymbolLocation location, IPsiServices psiServices);
    [CompilerGeneratedAttribute]
internal static int <ReformatBody>g__GetWhitespacePrefixLength|12_0(string s);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Presentation.CppPPPresenterUtil/<<ReformatBody>g__GetNonEmptyLineIndices|12_1>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<int> <ReformatBody>g__GetNonEmptyLineIndices|12_1(IList`1<string> lines);
    [CompilerGeneratedAttribute]
internal static string <PresentBodyImpl>g__TrimResult|13_0(StringBuilder line);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Presentation.CppPresentationContext : ValueType {
    public static CppPresentationContext Empty;
    [CanBeNullAttribute]
public ITreeNode TreeNode;
    public Nullable`1<CppViewPos> ViewPos;
    [CanBeNullAttribute]
public CppLanguageDialect LanguageDialect { get; }
    public CppPresentationContext(ITreeNode treeNode, Nullable`1& viewPos);
    public CppPresentationContext(Nullable`1& viewPos);
    private static CppPresentationContext();
    public static CppPresentationContext FromPsiWithViewPos(ITreeNode context);
    public static CppPresentationContext FromPsiWithoutViewPos(ITreeNode context);
    public CppLanguageDialect get_LanguageDialect();
}
public class JetBrains.ReSharper.Psi.Cpp.Presentation.CppPresentationParameters : ValueType {
    public static int DEFAULT_MAX_PRESENTED_SEQUENCE_LENGTH;
    public static int DEFAULT_MAX_PRESENTED_OBJECT_MEMBERS_COUNT;
    public static int DEFAULT_MAX_PRESENTED_STRING_LITERAL_LENGTH;
    public static CppPresentationParameters Default;
    public static CppPresentationParameters ForDebug;
    public CppPresentationUserSettings UserSettings;
    public bool ShortenTemplateArgumentLists;
    public bool ShortenSizeOfArgument;
    public bool ShortenAlignOfArgument;
    public bool ShortenFunctionParameters;
    public bool ShortenNoExceptSpecification;
    public bool OmitNamespaceQualifiers;
    public bool ShowConceptsBeforeNamesInTemplateParameterList;
    public bool AddWellKnownOrAssociatedTypeSynonyms;
    public bool DropRsCppInternalNames;
    public int MaxPresentedSequenceLength;
    public int MaxPresentedObjectMembersCount;
    public int MaxPresentedStringLiteralLength;
    public CppPresentationParameters(CppPresentationUserSettings settings);
    private static CppPresentationParameters();
    public static CppPresentationParameters FromPsi(ITreeNode psi);
}
public class JetBrains.ReSharper.Psi.Cpp.Presentation.CppPresentationUserSettings : object {
    public static CppPresentationUserSettings Default;
    public static CppPresentationUserSettings ForDebug;
    [CompilerGeneratedAttribute]
private bool <PutCvQualsBeforeTypename>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PutConstBeforeVolatile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PutSpaceBeforePtrInDataMember>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PutSpaceAfterPtrInDataMember>k__BackingField;
    public bool PutCvQualsBeforeTypename { get; }
    public bool PutConstBeforeVolatile { get; }
    public bool PutSpaceBeforePtrInDataMember { get; }
    public bool PutSpaceAfterPtrInDataMember { get; }
    public CppPresentationUserSettings(bool cvBeforeTypename, bool constBeforeVolatile, bool spaceBeforePtrInDataMember, bool spaceAfterPtrInDataMember);
    private static CppPresentationUserSettings();
    [CompilerGeneratedAttribute]
public bool get_PutCvQualsBeforeTypename();
    [CompilerGeneratedAttribute]
public bool get_PutConstBeforeVolatile();
    [CompilerGeneratedAttribute]
public bool get_PutSpaceBeforePtrInDataMember();
    [CompilerGeneratedAttribute]
public bool get_PutSpaceAfterPtrInDataMember();
    public static CppPresentationUserSettings FromSettings(ISolution solution, IContextBoundSettingsStore store);
    public static CppPresentationUserSettings FromPsi(ITreeNode node);
    public static CppPresentationUserSettings FromPsiSourceFile(IPsiSourceFile file);
}
public class JetBrains.ReSharper.Psi.Cpp.Presentation.CppPresentedDeclarationSpecifiers : ValueType {
    public CppDeclSpecPlacement Placement;
    public string Typename;
    public CVQualifiers Qualifiers;
    public CppClassTag ClassTag;
    public Signing Signing;
    public int ShortLong;
    private ICppPresenter myPresenter;
    public CppPresentedDeclarationSpecifiers(string type, CVQualifiers quals, CppDeclSpecPlacement placement, CppClassTag tag, Signing signing, int shortLong, ICppPresenter presenter);
    public string PresentSpecs();
    public sealed virtual bool Equals(CppPresentedDeclarationSpecifiers other);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Presentation.CppPresentedDeclarator : ValueType {
    public CppPresentedDeclarationSpecifiers DeclarationSpecifiers;
    public string DeclaratorPrefix;
    public string DeclaratorSuffix;
    public bool ContainsFunctionTypePresentation;
    public bool WasParenthesized;
    public bool NeedSpaceBeforeName;
    public bool IsPackExpansion;
    public CppPresentedDeclarator(CppPresentedDeclarationSpecifiers declSpecs, string declaratorPrefix, string suffix, bool containsFunctionTypePresentation, bool wasParenthesized, bool needSpaceBeforeName, bool isPackExpansion);
    public string PresentTypeId();
    public string PresentDeclarator();
    public string PresentDeclarator(string name);
    public string PresentDeclSpecsAndPrefix();
    public string PresentDeclSpecsAndPrefix(string name);
    public TextRange PresentDeclarator(string name, StringBuilder sb);
    public TextRange PresentDeclSpecsAndPrefix(string name, StringBuilder sb);
}
public class JetBrains.ReSharper.Psi.Cpp.Presentation.CppPresentedDefineSymbol : ValueType {
    [NotNullAttribute]
public string Name;
    public Nullable`1<ValueTuple`2<string, TextRange[]>> ParamList;
    [CanBeNullAttribute]
public List`1<string> Body;
    [NotNullAttribute]
public string Kind;
    public string NameWithParams { get; }
    public string get_NameWithParams();
}
public class JetBrains.ReSharper.Psi.Cpp.Presentation.CppPresenter : CppTypePresenterBase {
    public static ICppPresenter Default;
    public static ICppPresenter ForDebug;
    private HashSet`1<ICppClassResolveEntity> myPresentingLambdas;
    public bool HasStyling { get; }
    public string NewLine { get; }
    public CppPresenter(CppPresentationParameters params, CppPresentationContext& context);
    public CppPresenter(CppPresentationParameters params, CppPresentationContext& context, CppSuggestedScopesCollection suggestedScopes);
    private static CppPresenter();
    public static CppPresenter CreateFromPsiWithViewPos(ITreeNode node);
    public static CppPresenter CreateFromPsiWithViewPos(ITreeNode node, CppViewPos& vp);
    public static CppPresenter CreateFromPsiWithoutViewPos(ITreeNode node);
    public virtual bool get_HasStyling();
    public virtual string get_NewLine();
    public virtual string AsStyled(string str, string attributeId, JetFontStyles style);
    public virtual string AsResolveEntityName(string name, ICppResolveEntity linkedEntity, string attributeId, JetFontStyles style);
    public virtual void ToRichText(string str, CppHighlighterColorCache colorCache, RichText result, JetFontStyles fontStyle, EffectStyle effect, TextRange[] rangesToRemap);
    public virtual string GetAttributeByEntity(ICppResolveEntity _);
    public virtual string EscapeText(string s);
    public sealed virtual CppDeclarationStringPresentationBuilder CreatePresentedDeclarationBuilder(int markingOffset, DeclaredElementPresenterMarking marking);
    public sealed virtual string ConvertPresentedDeclarationToTypeId(CppPresentedDeclarator declarator);
    public sealed virtual string AddNameToPresentedDeclaration(CppPresentedDeclarator declarator, string name);
    public sealed virtual string AddNameAndEqInitializerToPresentedDeclaration(CppPresentedDeclarator declarator, string name, string initializer);
    public sealed virtual string CreatePresentedDeclarationSpecifierTypename(string presentedName, CppClassTag tag, bool wantsTypename);
    public sealed virtual string CreatePresentedErrorType(string errorTypeText);
    public sealed virtual string CreatePresentedExceptionSpecification(ICppExceptionSpecification exceptionSpecification);
    public sealed virtual string CreatePresentedExpressionFromString(string exprPresentation);
    public sealed virtual string PresentUnresolvedType(string typeName);
    public sealed virtual ICppPresenter GetTextPresenter();
    public virtual string PresentNamePartImpl(CppQualifiedNamePart namePart);
    public virtual string PresentValue(ICppValue value);
    public static CppQualifiedName GetScopeName(CppQualType scopeType);
    public void SetMainScopeType(CppQualType scopeType);
    public virtual string PresentQualifiedNameOfTypeImpl(CppQualifiedNameWithTag name, CppQualType presentedType);
    public virtual string PresentQualifiedNameOfResolveEntity(CppQualifiedName name, ICppResolveEntity entity);
    public sealed virtual HashSet`1<ICppClassResolveEntity> GetPresentingLambdasCache();
}
public class JetBrains.ReSharper.Psi.Cpp.Presentation.CppPresenterCheckingBadPresentation : CppPresenter {
    private bool myShouldMarkUnderscoreNamesAsBad;
    [CompilerGeneratedAttribute]
private bool <SeenBadNames>k__BackingField;
    public bool SeenBadNames { get; private set; }
    public CppPresenterCheckingBadPresentation(CppPresentationParameters params);
    public virtual string PresentQualifiedNameOfTypeImpl(CppQualifiedNameWithTag name, CppQualType presentedType);
    public virtual string PresentNamePartImpl(CppQualifiedNamePart namePart);
    public virtual string PresentQualifiedNameOfResolveEntity(CppQualifiedName name, ICppResolveEntity entity);
    [CompilerGeneratedAttribute]
public bool get_SeenBadNames();
    [CompilerGeneratedAttribute]
private void set_SeenBadNames(bool value);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Presentation.CppPresenterUtil : object {
    [ExtensionAttribute]
private static void AppendTemplateList(ICppPresenter presenter, IEnumerable`1<string> elements, StringBuilder output);
    [ExtensionAttribute]
[NotNullAttribute]
private static string JoinTemplateList(ICppPresenter presenter, IEnumerable`1<string> elements);
    [ExtensionAttribute]
private static void JoinTemplateList(ICppPresenter presenter, IEnumerable`1<string> elements, StringBuilder output);
    [ExtensionAttribute]
public static string PresentTemplateArgument(ICppPresenter presenter, ICppTemplateArgument arg);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Presentation.CppPresenterUtil/<PresentTemplateArgumentsImpl>d__4")]
[ExtensionAttribute]
private static IEnumerable`1<string> PresentTemplateArgumentsImpl(ICppPresenter presenter, ICppTemplateArgument[] args);
    [ExtensionAttribute]
public static void PresentTemplateArguments(ICppPresenter presenter, ICppTemplateArgument[] args, StringBuilder output);
    [ExtensionAttribute]
public static string PresentTemplateArguments(ICppPresenter presenter, ICppTemplateArgument[] args);
    [ExtensionAttribute]
public static string PresentTemplateTemplateArgument(ICppPresenter presenter, CppTemplateTemplateArgument templArg);
    [ExtensionAttribute]
public static string PresentTemplateArgumentWithKind(ICppPresenter presenter, ICppTemplateArgument arg);
    [ExtensionAttribute]
private static string PresentTypeTemplateParameter(ICppPresenter presenter, ICppTypeTemplateParameterOrPackOrGenericParameter param, string name);
    [ExtensionAttribute]
private static string PresentConceptTemplateParameter(ICppPresenter presenter, ICppConceptTemplateParameter param, string name);
    [ExtensionAttribute]
private static string PresentNonTypeTemplateParameter(ICppPresenter presenter, ICppExpressionTemplateParameterOrPack param, string name);
    [ExtensionAttribute]
private static string PresentTemplateTemplateParameter(ICppPresenter presenter, ICppTemplateTemplateParameterOrPack param, string name);
    [ExtensionAttribute]
public static string PresentTemplateParameterDeclaration(ICppPresenter presenter, ICppTemplateParameter param, string name);
    [ExtensionAttribute]
public static string PresentTemplateParameterDeclaration(ICppPresenter presenter, ICppTemplateParameter param);
    [ExtensionAttribute]
public static string PresentTemplateParameterDeclarations(ICppPresenter presenter, CppTemplateParametersBase parameters);
    [ExtensionAttribute]
private static string PresentConceptName(ICppPresenter presenter, ICppTemplateParameter param);
    [ExtensionAttribute]
private static string PresentTemplateParameterNameImpl(ICppPresenter presenter, ICppTemplateParameter param, bool handlePacks, bool showConceptName);
    [ExtensionAttribute]
public static string PresentTemplateParameterName(ICppPresenter presenter, ICppTemplateParameter param);
    [ExtensionAttribute]
[CanBeNullAttribute]
private static IEnumerable`1<string> PresentTemplateParameterNamesImpl(ICppPresenter presenter, CppTemplateParametersBase params, bool handlePacks, bool showConceptNames);
    [ExtensionAttribute]
public static void PresentTemplateParameterNames(ICppPresenter presenter, CppTemplateParametersBase params, StringBuilder output);
    [ExtensionAttribute]
private static string PresentTemplateParameterWithSubstitutions(ICppPresenter presenter, ICppTemplateParameter param, IEnumerable`1<ICppTemplateArgument> values);
    [ExtensionAttribute]
public static string PresentTemplateParametersWithSubstitutions(ICppPresenter presenter, IEnumerable`1<ValueTuple`2<ICppTemplateParameter, IEnumerable`1<ICppTemplateArgument>>> templateParams);
    public static string GetTemplateParameterKind(ICppResolveEntity param);
    [ExtensionAttribute]
public static string PresentLinkageTemplateParameterName(ICppPresenter presenter, ICppLinkageTemplateParameter param);
    [ExtensionAttribute]
private static IEnumerable`1<string> PresentLinkageTemplateParameterNamesImpl(ICppPresenter presenter, IEnumerable`1<ICppLinkageTemplateParameter> parameters);
    [ExtensionAttribute]
public static string PresentLinkageTemplateParameterNames(ICppPresenter presenter, ICppLinkageTemplateParameter[] parameters);
    [ExtensionAttribute]
public static string PresentLinkageTemplateParameterNameAndHandlePacks(ICppPresenter presenter, ICppLinkageTemplateParameter param);
    [ExtensionAttribute]
public static IEnumerable`1<string> PresentLinkageTemplateArgumentsImpl(ICppPresenter presenter, ICppLinkageTemplateArgument[] args);
    [ExtensionAttribute]
public static string PresentLinkageTemplateArguments(ICppPresenter presenter, ICppLinkageTemplateArgument[] args);
    [ExtensionAttribute]
public static string PresentLinkageTemplateArgument(ICppPresenter presenter, ICppLinkageTemplateArgument arg);
    [ExtensionAttribute]
public static string PresentLinkageTemplateArgumentAndHandlePacks(ICppPresenter presenter, ICppLinkageTemplateArgument arg);
    [ExtensionAttribute]
[CanBeNullAttribute]
private static IEnumerable`1<string> PresentTemplateIdArgumentsImpl(ICppPresenter presenter, CppTemplateId templateId);
    [ExtensionAttribute]
public static void PresentTemplateIdArguments(ICppPresenter presenter, CppTemplateId templateId, StringBuilder output);
    [ExtensionAttribute]
public static string PresentTemplateIdArguments(ICppPresenter presenter, CppTemplateId templateId);
    [ExtensionAttribute]
public static String[] PresentTemplateIdParametersAsArray(ICppPresenter presenter, CppTemplateId templateId);
    [ExtensionAttribute]
private static IEnumerable`1<string> PresentLinkageTemplateIdParametersImpl(ICppPresenter presenter, CppLinkageTemplateId name);
    [ExtensionAttribute]
public static void PresentLinkageTemplateIdParameters(ICppPresenter presenter, CppLinkageTemplateId name, StringBuilder output);
    [ExtensionAttribute]
public static string PresentLinkageTemplateIdParameters(ICppPresenter presenter, CppLinkageTemplateId name);
    [ExtensionAttribute]
public static String[] PresentLinkageTemplateIdParametersAsArray(ICppPresenter presenter, CppLinkageTemplateId name);
    [ExtensionAttribute]
public static string PresentEmphasizedType(ICppPresenter presenter, CppQualType qualType);
    [ExtensionAttribute]
public static string PresentEmphasizedKeyword(ICppPresenter presenter, string keyword);
    [ExtensionAttribute]
public static string PresentEmphasizedThisLikeKeyword(ICppPresenter presenter, string keyword);
    [ExtensionAttribute]
public static string PresentEmphasizedExpression(ICppPresenter presenter, ICppExpression expr);
    [ExtensionAttribute]
public static string PresentNamespaceName(ICppPresenter presenter, CppQualifiedNamePart name);
    [ExtensionAttribute]
public static string PresentMacroName(ICppPresenter presenter, string name);
    [ExtensionAttribute]
public static string PresentUESpecifier(ICppPresenter presenter, string name);
    [ExtensionAttribute]
public static string PresentQualifiers(ICppPresenter presenter, Qualifiers quals);
    [ExtensionAttribute]
public static string PresentCVQualifiers(ICppPresenter presenter, CVQualifiers quals);
    [ExtensionAttribute]
public static string PresentRefFlag(ICppPresenter presenter, ReferenceFlag refFlag);
    [ExtensionAttribute]
public static string PresentFuncRefQualifier(ICppPresenter presenter, FuncRefQualifier refQual);
    [ExtensionAttribute]
public static string PresentCallingConvention(ICppPresenter presenter, CppCallingConvention cc);
    [ExtensionAttribute]
public static string PresentOperatorKind(ICppPresenter presenter, CppOperatorKind operatorKind);
    [ExtensionAttribute]
public static string PresentExceptionSpecification(ICppPresenter presenter, ICppExceptionSpecification exceptionSpecification);
    [ExtensionAttribute]
public static void AppendCVQualifiers(ICppPresenter presenter, CVQualifiers quals, StringBuilder result);
    [ExtensionAttribute]
public static void AppendDeclarationSpecifiersPrefix(ICppPresenter presenter, CppDeclarationSpecifiers specifiers, StringBuilder output);
    [ExtensionAttribute]
public static string PresentArgumentList(ICppPresenter presenter, ICppArgumentList argList);
    [ExtensionAttribute]
public static string PresentArgumentList(ICppPresenter presenter, ICppExpression[] args, CppArgumentListKind kind);
    private static string GetNumericKindName(CppLanguageDialect dialect, CppNumericTypeKind kind);
    [ExtensionAttribute]
public static string PresentHlslVector(ICppPresenter presenter, HlslVectorType t);
    [ExtensionAttribute]
public static string PresentHlslMatrix(ICppPresenter presenter, HlslMatrixType t);
    [ExtensionAttribute]
public static string PresentNullPointerValue(ICppPresenter presenter);
    [ExtensionAttribute]
public static string PresentNamePart(ICppPresenter presenter, ICppResolveEntity entity, JetFontStyles style);
    [ExtensionAttribute]
public static string PresentNamePart(ICppPresenter presenter, CppQualifiedNamePart customName, ICppResolveEntity entity);
    [ExtensionAttribute]
public static string PresentNamePart(ICppPresenter presenter, CppQualifiedNamePart name, string attributeId, ICppResolveEntity linkedEntity, JetFontStyles style);
    [ExtensionAttribute]
public static void PresentNamePart(ICppPresenter presenter, CppQualifiedNamePart name, StringBuilder output, string attributeId, ICppResolveEntity linkedEntity, JetFontStyles style);
    [ExtensionAttribute]
public static string PresentNamePartWithoutLink(ICppPresenter presenter, ICppResolveEntity entity, JetFontStyles style);
    [ExtensionAttribute]
public static string PresentNamePartWithKind(ICppPresenter presenter, ICppResolveEntity entity);
    [ExtensionAttribute]
public static string PresentToken(ICppPresenter presenter, TokenNodeType tt);
    [ExtensionAttribute]
public static string PresentClassKey(ICppPresenter presenter, CppClassKey key);
    [ExtensionAttribute]
public static string PresentClassTag(ICppPresenter presenter, CppClassTag tag);
    [ExtensionAttribute]
public static string PresentTemplateParameterKey(ICppPresenter presenter, CppTypeTemplateParameterKey key);
    [ExtensionAttribute]
private static string PresentLambdaSignature(ICppPresenter presenter, ICppClassResolveEntity lambda, ISet`1<ICppClassResolveEntity> presentingLambdas);
    [ExtensionAttribute]
public static string PresentLambdaClass(ICppPresenter presenter, ICppClassResolveEntity lambda);
    [ExtensionAttribute]
public static void PresentLambdaClass(ICppPresenter presenter, ICppClassResolveEntity lambda, StringBuilder result);
    [ExtensionAttribute]
public static string PresentResolveEntityName(ICppPresenter presenter, ICppResolveEntity ent, bool dropGlobal);
    [ExtensionAttribute]
public static string PresentQualifiedName(ICppPresenter presenter, CppQualifiedName name);
    [ExtensionAttribute]
public static void PresentQualifiedName(ICppPresenter presenter, CppQualifiedName name, StringBuilder output);
    [ExtensionAttribute]
public static string PresentResolvedReferenceForExpressionWithHint(ICppPresenter presenter, CppResolveResult& rr, CppQualifiedName hint, Func`3<CppQualifiedName, CppViewPos, CppResolveResult> resolver);
    [ExtensionAttribute]
public static string WithEntityKind(ICppPresenter presenter, string name, ICppResolveEntity entity);
    [ExtensionAttribute]
public static string WithEntityKind(ICppPresenter presenter, string name, ICppLinkageEntity entity);
    public static string RawPresentNameWithKind(string kind, string name);
    [ExtensionAttribute]
public static string PresentQualifiedName(ICppPresenter presenter, ICppResolveEntity entity);
    [ExtensionAttribute]
public static string PresentQualifiedNameWithKind(ICppPresenter presenter, ICppResolveEntity entity);
    [ExtensionAttribute]
public static string PresentDeclaratorWithQualifiedName(ICppPresenter presenter, ICppDeclaratorResolveEntity entity);
    [ExtensionAttribute]
public static string PresentDeclaratorWithQualifiedNameAndKind(ICppPresenter presenter, ICppDeclaratorResolveEntity entity);
    [ExtensionAttribute]
public static string PresentResolveEntity(ICppPresenter presenter, ICppResolveEntity entity);
    [ExtensionAttribute]
public static string PresentResolveEntityWithKind(ICppPresenter presenter, ICppResolveEntity entity);
    [ExtensionAttribute]
public static string PresentResolveEntityWithContainer(ICppPresenter presenter, ICppResolveEntity entity);
    [ExtensionAttribute]
public static string PresentResolveEntityWithKindAndContainer(ICppPresenter presenter, ICppResolveEntity entity);
    [ExtensionAttribute]
public static string PresentLinkageEntity(ICppPresenter presenter, ICppLinkageEntity ent);
    [ExtensionAttribute]
public static string PresentLinkageEntityWithType(ICppPresenter presenter, ICppLinkageEntity ent);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppResolveEntity GetPrimaryEntityForPresentation(ICppResolveEntity entity);
    [CanBeNullAttribute]
private static ICppResolveEntity Clarify(ICppResolveEntity resolveEntity);
    [ExtensionAttribute]
public static string PresentFunctionParametersTypes(ICppPresenter presenter, CppQualType[] params, CppEllipsisKind ellipsisKind, bool explicitThis, bool showDefaultArguments);
    [ExtensionAttribute]
public static string PresentFunctionParametersTypes(ICppPresenter presenter, CppQualType[] params, CppEllipsisKind ellipsisKind, bool explicitThis, bool showDefaultArguments, int markingOffset, Parameter[]& parametersMarking);
    private static string PresentResolveEntityImpl(ICppPresenter presenter, ICppResolveEntity entity, bool withKind, bool withContainer);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string PresentGeneratedResolveEntityType(ICppPresenter presenter, ICppDeclaratorResolveEntity declarator);
    [ExtensionAttribute]
public static string PresentParameterList(ICppPresenter presenter, ICppParameterListResolveEntity paramList);
    [ExtensionAttribute]
public static string PresentUnknownToken(ICppPresenter presenter, ITokenNode token);
    [CanBeNullAttribute]
public static string GetAttributeByEntity(ICppResolveEntity entity, DeclaredElementType type, bool isUsageForDaemon);
    public static void AppendElementTypePrefix(StringBuilder result, string elementType, bool presentInParens);
    [CompilerGeneratedAttribute]
internal static ICppPresenter <PresentNamePart>g__GetNonStylingPresenter|65_0(ICppPresenter presenter);
    [CompilerGeneratedAttribute]
internal static void <PresentQualifiedName>g__PresentNamePartOfQualifiedName|77_0(ICppPresenter presenter, CppQualifiedNamePart name, StringBuilder output);
}
public class JetBrains.ReSharper.Psi.Cpp.Presentation.CppPresentExpressionVisitor : object {
    protected ICppPresenter myPresenter;
    public CppPresentExpressionVisitor(ICppPresenter presenter);
    public virtual string ReApply(ICppExpression expr);
    public string ReApply(ICppTypeIdOrExpression typeOrExpr);
    public virtual string Visit(ICppEmptyExpression expr);
    public virtual string Visit(ICppResolvedLiteralExpression expr);
    public virtual string Visit(ICppUserDefinedLiteralExpression expr);
    public virtual string Visit(ICppResolvedUserDefinedLiteralExpression expr);
    public virtual string Visit(ICppThisExpression expr);
    public virtual string Visit(ICppResolvedThisExpression expr);
    public virtual string Visit(ICppParenExpression expr);
    public virtual string Visit(ICppBinaryExpression expr);
    public virtual string Visit(ICppResolvedBinaryExpression expr);
    public virtual string Visit(ICppUnaryExpression expr);
    public virtual string Visit(ICppResolvedUnaryExpression expr);
    public virtual string Visit(ICppPostfixExpression expr);
    public virtual string Visit(ICppResolvedPostfixExpression expr);
    public virtual string Visit(ICppConditionalExpression expr);
    public virtual string Visit(ICppResolvedConditionalExpression expr);
    public virtual string Visit(ICppQualifiedReferenceExpression expr);
    public virtual string Visit(ICppResolvedQualifiedReferenceExpression expr);
    private static CppResolveResult ResolveQualifiedReferenceForPresenter(CppQualifiedName name, CppViewPos vp);
    public virtual string Visit(ICppLinkageQualifiedReferenceExpression expr);
    public virtual string Visit(ICppMemberAccessExpression expr);
    private static CppResolveResult ResolveMemberAccessForPresenter(ICppResolvedMemberAccessExpression expr, CppQualifiedName name, CppViewPos& vp);
    public virtual string Visit(ICppResolvedMemberAccessExpression expr);
    public virtual string Visit(ICppNewExpression expr);
    public virtual string Visit(ICppResolvedNewExpression expr);
    public virtual string Visit(ICppDeleteExpression expr);
    public virtual string Visit(ICppSubscriptExpression expr);
    public virtual string Visit(ICppResolvedSubscriptExpression expr);
    public virtual string Visit(ICppCallExpression expr);
    public virtual string Visit(ICppResolvedCallExpression expr);
    public virtual string Visit(ICppCastExpression expr);
    public virtual string Visit(ICppResolvedCastExpression expr);
    public string PresentSizeOfArgument(ICppTypeIdOrExpression arg);
    public virtual string Visit(ICppSizeOfExpression expr);
    public virtual string Visit(ICppResolvedSizeOfExpression expr);
    public virtual string Visit(ICppSizeOfEllipsisExpression expr);
    public virtual string Visit(ICppResolvedSizeOfEllipsisExpression expr);
    public string PresentAlignOfArgument(ICppTypeIdOrExpression arg);
    public virtual string Visit(ICppAlignOfExpression expr);
    public virtual string Visit(ICppResolvedAlignOfExpression expr);
    public virtual string Visit(ICppTypeIdExpression expr);
    public virtual string Visit(ICppResolvedTypeIdExpression expr);
    public virtual string Visit(ICppNoExceptExpression expr);
    public virtual string Visit(ICppResolvedNoExceptExpression expr);
    public virtual string Visit(ICppSingleArgumentTypeTraitExpression expr);
    public virtual string Visit(ICppResolvedSingleArgumentTypeTraitExpression expr);
    public virtual string Visit(ICppDoubleArgumentTypeTraitExpression expr);
    public virtual string Visit(ICppResolvedDoubleArgumentTypeTraitExpression expr);
    public virtual string Visit(ICppMultiArgumentTypeTraitExpression expr);
    public virtual string Visit(ICppResolvedMultiArgumentTypeTraitExpression expr);
    public virtual string Visit(ICppMSUuidOfExpression expr);
    public virtual string Visit(ICppResolvedMSUuidOfExpression expr);
    public virtual string Visit(ICppMSEventHookExpression expr);
    public virtual string Visit(ICppResolvedMSEventHookExpression expr);
    public virtual string Visit(ICppMSNoopExpression expr);
    public virtual string Visit(ICppMSAssumeExpression expr);
    public virtual string Visit(ICppBuiltinAddressOfExpression expr);
    public virtual string Visit(ICppResolvedBuiltinAddressOfExpression expr);
    public virtual string Visit(ICppGnuBuiltinConstantPExpression expr);
    public virtual string Visit(ICppResolvedGnuBuiltinConstantPExpression expr);
    public virtual string Visit(ICppGNUAddressOfLabelExpression expr);
    public virtual string Visit(ICppResolvedGNUAddressOfLabelExpression expr);
    public virtual string Visit(ICppBuiltinOffsetOfExpression expr);
    public virtual string Visit(ICppResolvedBuiltinOffsetOfExpression expr);
    public virtual string Visit(ICppThrowExpression expr);
    public virtual string Visit(ICppBracedInitListExpression expr);
    public virtual string Visit(ICppResolvedBracedInitListExpression expr);
    public virtual string Visit(ICppBraceInitializedTemporaryExpression expr);
    public virtual string Visit(ICppResolvedBraceInitializedTemporaryExpression expr);
    public virtual string Visit(ICppLambdaExpression expr);
    public virtual string Visit(ICppReplacedLambdaExpression expr);
    public virtual string Visit(ICppGnuStatementExpression expr);
    public virtual string Visit(ICppReplacedGnuStatementExpression expr);
    public virtual string Visit(ICppRequiresExpression expr);
    public virtual string Visit(ICppReplacedRequiresExpression expr);
    public virtual string Visit(ICppRequiresExpressionItemTypename item);
    public virtual string Visit(ICppRequiresExpressionItemSimple item);
    public virtual string Visit(ICppRequiresExpressionItemNested item);
    public virtual string Visit(ICppRequiresExpressionItemCompound item);
    public virtual string Visit(ICppLinkageRequiresExpression expr);
    public virtual string Visit(ICppCliMultiArgumentSubscriptExpression expr);
    public virtual string Visit(ICppResolvedCliMultiArgumentSubscriptExpression expr);
    public virtual string Visit(ICppCliTypeIdExpression expr);
    public virtual string Visit(ICppResolvedCliTypeIdExpression expr);
    public virtual string Visit(ICppPackExpansionExpression expr);
    public virtual string Visit(ICppResolvedPackExpansionExpression expr);
    public virtual string Visit(ICppFoldExpression expr);
    public virtual string Visit(ICppResolvedFoldExpression expr);
    public virtual string Visit(ICppCoAwaitExpression expr);
    public virtual string Visit(ICppResolvedCoAwaitExpression expr);
    public virtual string Visit(ICppCoYieldExpression expr);
    public virtual string Visit(ICppResolvedCoYieldExpression expr);
    public virtual string Visit(ICppC11GenericExpression expr);
    public virtual string Visit(ICppResolvedC11GenericExpression expr);
    public virtual string Visit(ICppDesignation designation);
    public virtual string Visit(ICppResolvedDesignation designation);
    public virtual string Visit(ICppMemberAccessDesignator memAccess);
    public virtual string Visit(ICppSubscriptDesignator subscript);
    private string PresentKeyword(string keyword);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Presentation.CppPrettyPrinterUtil : object {
    [ExtensionAttribute]
public static string Emphasize(ICppPrettyPrinter presenter, string str);
    [ExtensionAttribute]
public static string AsItalic(ICppPrettyPrinter presenter, string str);
    [ExtensionAttribute]
public static string AsBold(ICppPrettyPrinter presenter, string str);
    [ExtensionAttribute]
public static string AsStyled(ICppPrettyPrinter presenter, string str, JetFontStyles style);
    [ExtensionAttribute]
public static string AsStyled(ICppPrettyPrinter presenter, string str, string attributeId);
    private static string AsNumericLiteral(ICppPrettyPrinter presenter, string str, string attributeId);
    [ExtensionAttribute]
public static string PresentNumericIntegerLiteral(ICppPrettyPrinter presenter, int i);
    [ExtensionAttribute]
public static string AsNumericIntegerLiteral(ICppPrettyPrinter presenter, string str);
    [ExtensionAttribute]
public static string AsNumericFloatLiteral(ICppPrettyPrinter presenter, string str);
    [ExtensionAttribute]
public static string AsStringLiteral(ICppPrettyPrinter presenter, string str);
    [ExtensionAttribute]
public static string AsCharacterLiteral(ICppPrettyPrinter presenter, string str);
    [ExtensionAttribute]
public static string AsTypeTemplateParameter(ICppPrettyPrinter presenter, string param);
    [ExtensionAttribute]
public static string AsNonTypeTemplateParameter(ICppPrettyPrinter presenter, string param);
    [ExtensionAttribute]
public static string AsFunctionParameterName(ICppPrettyPrinter presenter, string param);
    [ExtensionAttribute]
public static string AsTypedefName(ICppPrettyPrinter presenter, string name);
    [ExtensionAttribute]
public static string AsNamespaceName(ICppPrettyPrinter presenter, string name);
    [ExtensionAttribute]
public static string AsStructName(ICppPrettyPrinter presenter, string name);
    [ExtensionAttribute]
public static string AsClassName(ICppPrettyPrinter presenter, string name);
    [ExtensionAttribute]
public static string AsStructField(ICppPrettyPrinter presenter, string name);
    [ExtensionAttribute]
public static string AsKeyword(ICppPrettyPrinter printer, string keyword);
    [ExtensionAttribute]
public static string AsThisLikeKeyword(ICppPrettyPrinter printer, string keyword);
    [ExtensionAttribute]
public static string AsFormatStringItem(ICppPrettyPrinter printer, string str);
    [ExtensionAttribute]
public static string AsLineComment(ICppPrettyPrinter printer, string str);
    [ExtensionAttribute]
public static string AsBlockComment(ICppPrettyPrinter printer, string str);
    [ExtensionAttribute]
public static string PresentKeyword(ICppPrettyPrinter printer, string keyword);
    [ExtensionAttribute]
public static string PresentThisLikeKeyword(ICppPrettyPrinter printer, string keyword);
    [ExtensionAttribute]
public static RichText ToRichText(ICppPrettyPrinter printer, string s, CppHighlighterColorCache colorCache, TextRange[] rangesToRemap);
    [ExtensionAttribute]
public static RichText ToRichText(ICppPrettyPrinter printer, string s, ITreeNode context);
}
public class JetBrains.ReSharper.Psi.Cpp.Presentation.CppResolveEntityPresenterParams : ValueType {
    public ICppResolveEntity ResolveEntity;
    public CppQualType EntityType;
    public Nullable`1<CppViewPos> ViewPos;
    public CppResolveEntityPresenterParams(ICppResolveEntity resolveEntity, CppQualType entityType, Nullable`1& viewPos);
    public static CppResolveEntityPresenterParams Create(ICppResolveEntity entity);
    public CppPresentationParameters PresentationParameters();
    [CanBeNullAttribute]
public ICppResolveEntity EntityParent();
    private static CppViewPos GetViewPos(ICppResolveEntity ent);
    [CanBeNullAttribute]
private static CppModuleImportingContext GetImportContext(ICppResolveEntity ent);
}
public class JetBrains.ReSharper.Psi.Cpp.Presentation.CppResolveEntityRichPresenter : object {
    private static Dictionary`2<string, string> ourUESpecifierCanonicalName;
    private ICppPresenter myImpl;
    private ICppResolveEntity myEntity;
    private CppQualType myEntityType;
    private CppQualifiedNamePart myEntityName;
    private CppDeclaredElementType myDeclaredElementType;
    private Nullable`1<CppViewPos> myViewPos;
    [CanBeNullAttribute]
private ICppResolveEntity myEntityParent;
    private static CppResolveEntityRichPresenter();
    public CppResolveEntityRichPresenter(ICppResolveEntity entity);
    public CppResolveEntityRichPresenter(ICppResolveEntity entity, ICppPresenter presenter);
    public CppResolveEntityRichPresenter(CppResolveEntityPresenterParams params, ICppPresenter impl);
    public string GetHeader(bool presentElementTypeInParens);
    public string GetHeader(bool presentElementTypeInParens, DeclaredElementPresenterMarking marking);
    [CanBeNullAttribute]
private string GetEntityKindAsKeyword();
    [CanBeNullAttribute]
private static string GetEntityKindAsKeyword(ICppClassOrUndeterminedSpecializationResolveEntity clazz);
    public string GetHeaderWithoutKind();
    [CanBeNullAttribute]
public string GetContainer();
    [CanBeNullAttribute]
public string GetValue(ICppResolveEntity entity);
    private static CppQualType GetTypeAliasForPresentation(ICppResolveEntity entity);
    [CanBeNullAttribute]
public static ICppValue GetValueForPresentation(ICppResolveEntity entity);
    public string PresentConversionOperator();
    private string PresentOperator(CppOperatorId operatorId);
    private void PresentDeductionGuide(StringBuilder result, DeclaredElementPresenterMarking marking);
    private void PresentResolveEntity(StringBuilder result, DeclaredElementPresenterMarking marking);
    private void PresentTemplateHeader(StringBuilder output);
    private void AppendTemplateParameters(StringBuilder output);
    private void AppendNameAndTemplateParameters(StringBuilder output);
    private void AppendFunctionSignature(StringBuilder output);
    private string PresentContainingType(ICppClassOrUndeterminedSpecializationResolveEntity clazz);
    private bool AppendUEType(ICppResolveEntity entity, StringBuilder result);
    private string EnclosingClass(ICppClassOrUndeterminedSpecializationResolveEntity clazz);
    [CanBeNullAttribute]
private string EnclosingNamespace(CppNamespaceResolveEntity ns);
    private string EntityName();
    private void PresentDeclaratorPrefix(CppDeclarationSpecifiers specifiers, StringBuilder output);
    private bool PresentDeclaratorSuffix(ICppDeclaratorResolveEntity declarator, StringBuilder output);
    private bool PresentGeneratedKind(ICppDeclaratorResolveEntity declarator, StringBuilder output);
    private bool PresentTrailingKind(ICppDeclaratorResolveEntity declarator, StringBuilder result);
    private void PresentInitializer(CppDeclaratorInitializer initializer, StringBuilder result);
    [CanBeNullAttribute]
private string PresentTypeAlias(CppQualType targetType);
    private void PresentLambdaSignature(ICppGroupedFunctionDeclaratorResolveEntity parenOp, StringBuilder output);
    private bool IsLambdaParenOperator();
    private bool IsDeductionGuide();
    [CanBeNullAttribute]
private static ICppDeclaratorResolveEntityPack GetFunctorOverloads(ICppClassResolveEntity clazz, CppViewPos& vp);
    private static string PresentDeclaredElementType(DeclaredElementType type, ICppResolveEntity entity);
    private static CppQualType ChangeRestrictionSpecifiers(CppFunctionType function, CppRestrictionSpecifiers restrictionSpecifiers);
    private static void UpdateMarking(DeclaredElementPresenterMarking marking, CppPresentedDeclarator declarator, int startOffset);
    private static bool NoBases(ICppClassResolveEntity clazz);
    private static bool NoFields(ICppClassResolveEntity clazz);
    [NotNullAttribute]
private static ICppGroupedFunctionDeclaratorResolveEntity GetFunctionOrPrimaryTemplate(ICppResolveEntity entity);
    [CanBeNullAttribute]
private static ICppTemplateArgument[] GetUEDelegateArguments(CppQualType varType, ICppClassResolveEntity clazz, String& delegateKind);
    private static Nullable`1<UEDelegateSignature> GetUEDelegateSignature(CppQualType varType, ICppClassResolveEntity clazz);
    [CompilerGeneratedAttribute]
internal static void <EnclosingNamespace>g__DoPresent|32_0(CppNamespaceResolveEntity ns, StringBuilder output, ICppPresenter presenter);
}
public class JetBrains.ReSharper.Psi.Cpp.Presentation.CppSuggestedScopesCollection : object {
    private List`1<CppQualifiedName> myScopeNames;
    private Dictionary`2<ICppResolveEntity, CppQualifiedName> myCachedEntityNames;
    private CppQualifiedName myMainScopeName;
    public CppQualifiedName MainScopeName { get; public set; }
    public CppQualifiedName get_MainScopeName();
    public void set_MainScopeName(CppQualifiedName value);
    public void PushScope(ICppTypePresenterBase presenter, CppQualType scopeType);
    public void PopScope();
    public CppQualifiedName TryFindNameForType(ICppTypePresenterBase presenter, CppQualifiedName nameSuggestion, CppQualType type);
    public CppQualifiedName TryFindNameForType(ICppTypePresenterBase presenter, CppQualifiedNamePart namePart, CppQualType type);
    public Dictionary`2<ICppResolveEntity, CppQualifiedName> GetKnownNames();
    public void ExtractEntityNamesFromTemplateArguments(CppQualifiedName qualName);
    private void ExtractEntityNamesFromTemplateArguments(CppQualifiedNamePart name);
    private static bool Contains(CppQualifiedNamePart name, ICppClassResolveEntity clazz);
    private static bool Contains(CppQualifiedName name, ICppClassResolveEntity clazz);
    private static bool StartsWithGlobalNamespace(CppQualifiedName qualifiedName);
}
public class JetBrains.ReSharper.Psi.Cpp.Presentation.CppTypePresentationParameters : ValueType {
    public string DeclaratorNameForMarking;
    public bool HideFunctionReturnType;
    public bool ShowFunctionDefaultArguments;
    public DeclaredElementPresenterMarking OutputMarking;
    public CppCallingConvention TopLevelDefaultCallingConvention;
    public static CppTypePresentationParameters GetDefault();
    public CppTypePresentationParameters SetHideFunctionReturnType(bool hide);
    public CppTypePresentationParameters SetShowFunctionDefaultArguments(bool show);
    public CppTypePresentationParameters SetOutputMarking(DeclaredElementPresenterMarking outputMarking);
    public CppTypePresentationParameters SetOutputMarking(DeclaredElementPresenterMarking outputMarking, string declaratorNameForMarking);
    public CppTypePresentationParameters SetTopLevelCallingConvention(CppCallingConvention cc);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Presentation.CppTypePresenterBase : object {
    protected CppPresentationParameters myParameters;
    protected CppPresentationContext myContext;
    protected Nullable`1<CppPresentationContext> myParamsContext;
    protected CppSuggestedScopesCollection mySuggestedScopes;
    protected HashSet`1<CppTypedefType> myVisitedTypedefs;
    public CppPresentationParameters& Params { get; }
    [IsReadOnlyAttribute]
public CppPresentationContext& modreq(System.Runtime.InteropServices.InAttribute) Context { get; }
    [IsReadOnlyAttribute]
public Nullable`1& modreq(System.Runtime.InteropServices.InAttribute) ParameterContext { get; }
    public CppSuggestedScopesCollection SuggestedScopes { get; }
    public HashSet`1<CppTypedefType> VisitedTypedefs { get; }
    protected CppTypePresenterBase(CppPresentationParameters& params, CppPresentationContext& context, CppSuggestedScopesCollection suggestedScopes, Nullable`1& paramsContext);
    public abstract virtual ICppPresenter GetTextPresenter();
    public virtual ICppTypePresenterBase DoCloneWithParams(CppPresentationParameters& modreq(System.Runtime.InteropServices.InAttribute) params, CppPresentationContext& modreq(System.Runtime.InteropServices.InAttribute) context);
    public sealed virtual CppPresentationParameters& get_Params();
    public sealed virtual CppPresentationContext& modreq(System.Runtime.InteropServices.InAttribute) get_Context();
    public sealed virtual Nullable`1& modreq(System.Runtime.InteropServices.InAttribute) get_ParameterContext();
    public sealed virtual CppSuggestedScopesCollection get_SuggestedScopes();
    public sealed virtual HashSet`1<CppTypedefType> get_VisitedTypedefs();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Presentation.CppTypePresenterUtil : object {
    [ExtensionAttribute]
public static CppQualifiedNameWithTag GetNameForPresentation(ICppTypePresenterBase presenter, ICppResolveEntity ent);
    [ExtensionAttribute]
public static CppQualifiedNameWithTag GetNameForPresentationInplace(ICppTypePresenterBase presenter, ICppResolveEntity& ent);
    [ExtensionAttribute]
public static CppQualifiedNameWithTag GetNameForPresentationInplace(ICppTypePresenterBase presenter, ICppResolveEntity& ent, bool dropGlobal, bool forceTag);
    [ExtensionAttribute]
public static TPresenter CloneWithParams(TPresenter presenter, CppPresentationParameters& params, CppPresentationContext& context);
    [ExtensionAttribute]
public static TPresenter GetParameterPresenter(TPresenter presenter);
    public static bool NameResolvesToAnyNamespace(CppQualifiedName name, Nullable`1& viewPos);
    public static bool NameResolvesToEntity(CppQualifiedName name, ICppResolveEntity ent, Nullable`1& viewPos);
    public static bool NameResolvesToType(CppQualifiedName name, CppQualType type, Nullable`1& viewPos);
    [ExtensionAttribute]
public static TDeclaration PresentDeclarator(ICppTypePresenter`7<TType, TDeclaration, TNamedDeclaration, TExpression, TDeclarationSpecifierType, TExceptionSpecification, TDeclarationBuilder> presenter, CppQualType declaratorType, CppTypePresentationParameters parameters, bool declaratorIsTypedef);
    [ExtensionAttribute]
public static TType PresentType(ICppTypePresenter`7<TType, TDeclaration, TNamedDeclaration, TExpression, TDeclarationSpecifierType, TExceptionSpecification, TDeclarationBuilder> presenter, CppQualType type);
    [ExtensionAttribute]
public static TExpression PresentExpression(ICppTypePresenter`7<TType, TDeclaration, TNamedDeclaration, TExpression, TDeclarationSpecifierType, TExceptionSpecification, TDeclarationBuilder> presenter, ICppExpression expr);
    [ExtensionAttribute]
public static TDeclarationSpecifierType PresentQualifiedNameOfType(ICppTypePresenter`7<TType, TDeclaration, TNamedDeclaration, TExpression, TDeclarationSpecifierType, TExceptionSpecification, TDeclarationBuilder> presenter, CppQualifiedNameWithTag name, CppQualType presentedType);
    [ExtensionAttribute]
public static TDeclarationSpecifierType PresentTypeResolveEntityName(ICppTypePresenter`7<TType, TDeclaration, TNamedDeclaration, TExpression, TDeclarationSpecifierType, TExceptionSpecification, TDeclarationBuilder> presenter, ICppResolveEntity ent, bool forceClassTag);
    [ExtensionAttribute]
public static IList`1<TNamedDeclaration> PresentFunctionParametersTypes(ICppTypePresenter`7<TType, TDeclaration, TNamedDeclaration, TExpression, TDeclarationSpecifierType, TExceptionSpecification, TDeclarationBuilder> presenter, CppQualType[] params, bool showDefaultArguments);
    [ExtensionAttribute]
public static TNamedDeclaration PresentFunctionParameterDeclarator(ICppTypePresenter`7<TType, TDeclaration, TNamedDeclaration, TExpression, TDeclarationSpecifierType, TExceptionSpecification, TDeclarationBuilder> presenter, CppQualType paramT, CppTypePresentationParameters params);
    private static bool QualifierIsTypeDependent(CppQualifiedName name, CppViewPos& vp);
    private static CppList`1<CppDeclSpecKind> NormalizeOrder(CppList`1<CppDeclSpecKind> order, CppPresentationUserSettings settings, bool addSigned, bool addShortLong);
    private static CppGlobalNamespaceResolveEntity GetGlobalNamespace(ICppResolveEntity e);
}
public interface JetBrains.ReSharper.Psi.Cpp.Presentation.ICppDeclarationPresentationBuilder`6 {
    public abstract virtual void Parenthesize();
    public abstract virtual void PrependCallingConvention(CppCallingConvention cc, bool wasPointer, bool wasMember);
    public abstract virtual void PrependToken(CppTokenNodeType tt);
    public abstract virtual void PrependCVQualifiers(CVQualifiers qualifiers);
    public abstract virtual void PrependMemberPointerNameQualifier(TDeclaration type);
    public abstract virtual void PrependSpace();
    public abstract virtual void AppendArraySize(TExpression arraySize);
    public abstract virtual void PrependGnuAttribute(string attrName, TExpression argument);
    public abstract virtual void AppendFunctionParameters(IList`1<TNamedDeclaration> parameters, CppEllipsisKind ellipsisKind, bool explicitThis, bool isTopLevelType, Qualifiers quals, CppRestrictionSpecifiers restrictSpecs, TExceptionSpecification exceptionSpecification, TType trailingReturnType);
    public abstract virtual void AddPackExpansion();
    public abstract virtual void LearnDeclarationSpecifiers(TDeclarationSpecifierType type, CVQualifiers cvQuals, CppDeclSpecPlacement cvPlacement, CppClassTag clsTag, Signing signed, int shortLong);
    public abstract virtual void LearnInputQualifiers(InputQualifiers qualifiers);
    public abstract virtual TDeclaration Finish(InputQualifiers qualifiers, bool putSpaceAfterPtrInDataMember, string declaratorNameForMarking, bool seenFunctionType, bool wasParenthesized);
}
public interface JetBrains.ReSharper.Psi.Cpp.Presentation.ICppPresenter {
    public abstract virtual string PresentNamePartImpl(CppQualifiedNamePart name);
    public abstract virtual string PresentValue(ICppValue value);
    public abstract virtual string PresentQualifiedNameOfTypeImpl(CppQualifiedNameWithTag name, CppQualType presentedType);
    public abstract virtual string PresentQualifiedNameOfResolveEntity(CppQualifiedName name, ICppResolveEntity entity);
    [NotNullAttribute]
public abstract virtual HashSet`1<ICppClassResolveEntity> GetPresentingLambdasCache();
}
public interface JetBrains.ReSharper.Psi.Cpp.Presentation.ICppPrettyPrinter {
    public bool HasStyling { get; }
    [NotNullAttribute]
public string NewLine { get; }
    public abstract virtual bool get_HasStyling();
    public abstract virtual string get_NewLine();
    [NotNullAttribute]
public abstract virtual string AsStyled(string str, string attributeId, JetFontStyles style);
    [NotNullAttribute]
public abstract virtual string AsResolveEntityName(string name, ICppResolveEntity linkedEntity, string attributeId, JetFontStyles style);
    public abstract virtual void ToRichText(string str, CppHighlighterColorCache colorCache, RichText result, JetFontStyles fontStyle, EffectStyle effect, TextRange[] rangesToRemap);
    [CanBeNullAttribute]
public abstract virtual string GetAttributeByEntity(ICppResolveEntity entity);
    public abstract virtual string EscapeText(string s);
}
public interface JetBrains.ReSharper.Psi.Cpp.Presentation.ICppTypePresenter`7 {
    public abstract virtual TDeclarationBuilder CreatePresentedDeclarationBuilder(int markingOffset, DeclaredElementPresenterMarking marking);
    public abstract virtual TType ConvertPresentedDeclarationToTypeId(TDeclaration declarator);
    public abstract virtual TNamedDeclaration AddNameToPresentedDeclaration(TDeclaration declarator, string name);
    public abstract virtual TNamedDeclaration AddNameAndEqInitializerToPresentedDeclaration(TDeclaration declarator, string name, TExpression initializer);
    public abstract virtual TDeclarationSpecifierType CreatePresentedDeclarationSpecifierTypename(string presentedName, CppClassTag tag, bool wantsTypename);
    public abstract virtual TDeclarationSpecifierType CreatePresentedErrorType(string errorTypeText);
    public abstract virtual TExceptionSpecification CreatePresentedExceptionSpecification(ICppExceptionSpecification spec);
    public abstract virtual TExpression CreatePresentedExpressionFromString(string exprPresentation);
    public abstract virtual TDeclarationSpecifierType PresentUnresolvedType(string typeName);
}
public interface JetBrains.ReSharper.Psi.Cpp.Presentation.ICppTypePresenterBase {
    public CppPresentationParameters& Params { get; }
    [IsReadOnlyAttribute]
public CppPresentationContext& modreq(System.Runtime.InteropServices.InAttribute) Context { get; }
    [IsReadOnlyAttribute]
public Nullable`1& modreq(System.Runtime.InteropServices.InAttribute) ParameterContext { get; }
    public CppSuggestedScopesCollection SuggestedScopes { get; }
    public HashSet`1<CppTypedefType> VisitedTypedefs { get; }
    public abstract virtual ICppPresenter GetTextPresenter();
    public abstract virtual ICppTypePresenterBase DoCloneWithParams(CppPresentationParameters& modreq(System.Runtime.InteropServices.InAttribute) params, CppPresentationContext& modreq(System.Runtime.InteropServices.InAttribute) context);
    public abstract virtual CppPresentationParameters& get_Params();
    public abstract virtual CppPresentationContext& modreq(System.Runtime.InteropServices.InAttribute) get_Context();
    public abstract virtual Nullable`1& modreq(System.Runtime.InteropServices.InAttribute) get_ParameterContext();
    public abstract virtual CppSuggestedScopesCollection get_SuggestedScopes();
    public abstract virtual HashSet`1<CppTypedefType> get_VisitedTypedefs();
}
public class JetBrains.ReSharper.Psi.Cpp.Presentation.UEIniHighlightingAttributeIds : object {
    public static string INI_HEADER;
    public static string INI_KEY;
    public static string INI_OBJECT_KEY;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.PsiSourceFileUtil : object {
    private static Regex BoostDetailNegativeFilterRegex;
    private static Regex BoostDetailPositiveFilterRegex;
    private static HashSet`1<string> InternalBadHeadersList;
    private static StringComparison PathComparison;
    public static Func`2<CppFileLocation, bool> IsSourceFileFunc;
    public static Func`2<CppFileLocation, bool> IsHeaderFileFunc;
    private static PsiSourceFileUtil();
    private static string PreparePathRegexString(string s);
    private static bool FromUniversalCRT(string path);
    public static bool IsCSourceFile(CppFileLocation file);
    public static bool IsSourceFile(string name);
    public static bool IsHlslFile(string name);
    public static bool IsGlslFile(string name);
    public static bool IsBlockShadersFile(string name);
    public static bool IsHlslFile(VirtualFileSystemPath file);
    public static bool IsGlslFile(VirtualFileSystemPath file);
    public static bool IsBlockShadersFile(VirtualFileSystemPath file);
    public static bool IsHlslFile(CppFileLocation file);
    public static bool IsGlslFile(CppFileLocation file);
    public static bool IsBlockShadersFile(CppFileLocation file);
    public static bool IsHlslFile(IPsiSourceFile file);
    public static bool IsSourceFile(VirtualFileSystemPath file);
    public static bool IsHeaderFile(IPsiSourceFile file);
    public static bool IsHeaderFile(VirtualFileSystemPath file);
    public static bool IsHeaderFile(CppFileLocation file);
    public static bool IsSourceFile(IPsiSourceFile file);
    public static bool IsSourceFile(CppFileLocation file);
    public static bool IsModuleInterface(string name);
    public static bool IsModuleInterface(CppFileLocation file);
    public static bool IsModuleInterface(IPsiSourceFile file);
    public static CppFileFlavour GetFileFlavour(CppFileLocation file);
    public static bool IsReSharperGeneratedFile(SolutionCaches caches, CppFileLocation file);
    public static bool IsBoostDetailFile(CppFileLocation file);
    public static bool IsInternalBadHeader(CppFileLocation file);
    [ExtensionAttribute]
public static bool IsTemporaryFileForDebugger(IPsiSourceFile file);
}
[AttributeUsageAttribute("4")]
public class JetBrains.ReSharper.Psi.Cpp.RecursionLimitAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Limit>k__BackingField;
    public int Limit { get; }
    public RecursionLimitAttribute(int limit);
    [CompilerGeneratedAttribute]
public int get_Limit();
    public static int GetLimit(Type counter);
}
public static class JetBrains.ReSharper.Psi.Cpp.RecursiveComputationId : object {
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Cpp.ReSharperCppHLSLEnabler : object {
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Resolve.AbstractBuiltinFunctionResolveEntity : AbstractBuiltinResolveEntity {
    public CppFunctionTraits Traits { get; }
    public ICppFunctionBodyResolveEntity Body { get; }
    public int BodyChameleonVersion { get; }
    protected AbstractBuiltinFunctionResolveEntity(CppQualType type);
    public virtual CppFunctionTraits get_Traits();
    public virtual ICppFunctionBodyResolveEntity get_Body();
    public virtual int get_BodyChameleonVersion();
    public virtual ICppParameterListResolveEntity GetMainParameterList();
    public virtual int GetFirstDefaultArgIndex();
    public virtual IEnumerable`1<ICppResolveEntity> GetResolvedCxxCliOverrideSpecifierTargets();
    public virtual ICppResolvedExpression GetResolvedRequiresClause();
    public virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public virtual bool InstantiateFunctionBody(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp, bool forceChameleonInstantiation);
    public virtual ICppFunctionDeclaratorResolveEntity GetUngroupedThatProvidingBody();
    public virtual ICppFunctionOrVariableDeclaratorResolveEntity GetFirstUngrouped();
    public virtual CppList`1<ICppFunctionOrVariableDeclaratorResolveEntity> GetUngroupedDeclarators();
    public virtual ICppFunctionTemplateDeclaratorResolveEntity GetTemplateDeclaration();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Resolve.AbstractBuiltinResolveEntity : object {
    protected CppQualType myType;
    public ICppResolveEntity StructuralParent { get; }
    public ICppResolveEntityParent RealParent { get; }
    public CppQualifiedNamePart Name { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    protected AbstractBuiltinResolveEntity(CppQualType type);
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual ICppResolveEntityParent get_RealParent();
    public abstract virtual CppQualifiedNamePart get_Name();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public virtual CppAttributeList get_Attributes();
    public abstract virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public abstract virtual CppDependentInfo GetDependentInfo();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual bool Contains(ICppDeclaratorResolveEntity e);
    public CppQualType GetCppType();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppAdditionalDeductionGuideBuilder : ValueType {
    private CppClassTemplateResolveEntityPack myClassTemplate;
    private ICppClassResolveEntity myPrimaryTemplate;
    private ICppResolvedTypeFactory myTypeFactory;
    private CppQualType myClassType;
    private CppCallingConvention myCallingConvention;
    private CppRestrictionSpecifiers myRestrictionSpecifiers;
    public CppAdditionalDeductionGuideBuilder(CppClassTemplateResolveEntityPack classTemplate, ICppClassResolveEntity primaryTemplate);
    public ICppTemplateDeductionGuide DefaultCtor();
    public ICppTemplateDeductionGuide CopyCtor();
    private CppQualType GenerateCtorType(CppQualType[] ctoParams);
    public static CppUndeterminedSpecializationResolveEntity CreateUndeterminedSpecializationResolveEntity(CppClassTemplateResolveEntityPack classTemplate, ICppClassResolveEntity primaryTemplate, ICppResolvedTypeFactory typeFactory);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppArrayVariableDeclaratorResolveEntity : CppGroupedVariableDeclaratorResolveEntity {
    private ICppExpression myArraySize;
    private int myCurrentUngroupedForArraySize;
    public CppArrayVariableDeclaratorResolveEntity(ICppVariableDeclaratorResolveEntity ent, ICppVariableTemplateDeclaratorResolveEntity templ);
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    protected virtual CppDependentInfo CalculateDependentInfo();
    private void TryLearnArraySizeForNewEntity(ICppVariableDeclaratorResolveEntity ent, CppQualType entType);
    private static CppQualType PatchUpArraySize(CppQualType type, ICppExpression size, ICppResolvedTypeFactory tf);
    public static ICppExpression TryToGetSizeFromStringLiteral(ICppResolvedTypeFactory tf, CppQualType entType, ICppExpression arrayInitializer, CppLanguageDialect dialect);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppBuiltinOperatorResolveEntity : AbstractBuiltinFunctionResolveEntity {
    private CppOperatorKind myKind;
    private CppDependentInfoCachedValue myCachedDepInfo;
    public CppQualifiedNamePart Name { get; }
    public CppBuiltinOperatorResolveEntity(CppOperatorKind kind, CppQualType operatorType);
    public CppBuiltinOperatorResolveEntity(CppOperatorKind kind, CppQualType operatorType, CppDependentInfo depInfo);
    protected CppBuiltinOperatorResolveEntity(CppOperatorKind kind);
    public virtual CppQualifiedNamePart get_Name();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public virtual CppDependentInfo GetDependentInfo();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public CppOperatorKind GetKind();
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppBuiltinOperatorResolveEntityForCliArrayConstruction : CppBuiltinOperatorResolveEntity {
    protected CppBuiltinOperatorResolveEntityForCliArrayConstruction(CppQualType type);
    public static CppBuiltinOperatorResolveEntityForCliArrayConstruction Create(CppQualType arrType, int rankHint, CppTypeContext& tc);
    public virtual string ToString();
    public CppQualType GetArrayType();
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppBuiltinOperatorResolveEntityForCliOperatorSynthesis : CppBuiltinOperatorResolveEntity {
    [CompilerGeneratedAttribute]
private ICppGroupedFunctionDeclaratorResolveEntity <OperationEntity>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppGroupedFunctionDeclaratorResolveEntity <AssignmentEntity>k__BackingField;
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public ICppGroupedFunctionDeclaratorResolveEntity OperationEntity { get; }
    public ICppGroupedFunctionDeclaratorResolveEntity AssignmentEntity { get; }
    protected CppBuiltinOperatorResolveEntityForCliOperatorSynthesis(CppOperatorKind opKind, CppQualType type, ICppGroupedFunctionDeclaratorResolveEntity opEnt, ICppGroupedFunctionDeclaratorResolveEntity asnEnt);
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    [CompilerGeneratedAttribute]
public ICppGroupedFunctionDeclaratorResolveEntity get_OperationEntity();
    [CompilerGeneratedAttribute]
public ICppGroupedFunctionDeclaratorResolveEntity get_AssignmentEntity();
    public static CppBuiltinOperatorResolveEntityForCliOperatorSynthesis Create(CppOperatorKind opKind, ICppResolveEntity opEnt, ICppResolveEntity asnEnt, ICppResolvedTypeFactory tf);
    public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppBuiltinOperatorResolveEntityForFunctionPointerCall : CppBuiltinOperatorResolveEntity {
    [NotNullAttribute]
public ICppExpressionNode InvokedExpression;
    public CppBuiltinOperatorResolveEntityForFunctionPointerCall(ICppExpressionNode invokedExpression, CppQualType exprType);
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppBuiltinOperatorResolveEntityForPropertyAccess : CppBuiltinOperatorResolveEntity {
    private static CppRestrictionSpecifiers RestrictionSpecifiers;
    [CompilerGeneratedAttribute]
private ICppCxxCliPropertyDeclaratorResolveEntity <Property>k__BackingField;
    public ICppCxxCliPropertyDeclaratorResolveEntity Property { get; }
    public CppQualifiedNamePart Name { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppBuiltinOperatorResolveEntityForPropertyAccess(ICppCxxCliPropertyDeclaratorResolveEntity owner);
    private static CppBuiltinOperatorResolveEntityForPropertyAccess();
    [CompilerGeneratedAttribute]
public ICppCxxCliPropertyDeclaratorResolveEntity get_Property();
    public virtual CppQualifiedNamePart get_Name();
    public virtual ICppResolveEntityParent get_RealParent();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public virtual string ToString();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppCoAwaitResolveResult : ValueType {
    public CppQualType PromiseType;
    public CppResolveResult AwaitTransform;
    public CppResolveResult OperatorCoAwait;
    public CppQualType AwaiterType;
    public CppResolveResult AwaitReady;
    public CppResolveResult AwaitSuspend;
    public CppResolveResult AwaitResume;
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppCoReturnResolveResult : ValueType {
    public CppQualType PromiseType;
    public bool IsReturnValue;
    public CppResolveResult ReturnCall;
}
public static class JetBrains.ReSharper.Psi.Cpp.Resolve.CppCoroutineNames : object {
    public static CppQualifiedName ourStdName;
    public static CppQualifiedName ourStdExperimentalName;
    public static CppQualifiedId ourCoroutineHandleNamePart;
    public static CppQualifiedId ourCoroutineTraitsNamePart;
    public static CppQualifiedId ourPromiseTypeNamePart;
    public static CppQualifiedName ourAwaitReadyName;
    public static CppQualifiedName ourAwaitResumeName;
    public static CppQualifiedName ourAwaitSuspendName;
    public static CppQualifiedName ourAwaitTransformName;
    public static CppQualifiedName ourYieldValueName;
    public static CppQualifiedName ourReturnVoidName;
    public static CppQualifiedName ourReturnValueName;
    public static CppQualifiedName ourGetReturnObjectName;
    public static CppQualifiedName ourInitialSuspendName;
    public static CppQualifiedName ourFinalSuspendName;
    public static CppQualifiedName ourUnhandledExceptionName;
    private static CppCoroutineNames();
}
public static class JetBrains.ReSharper.Psi.Cpp.Resolve.CppCoroutineUtil : object {
    public static CppQualType GetPromiseType(ICppFunctionDeclaratorResolveEntity functionEntity, CppTypeContext& tc);
    public static CppQualType GetPromiseTypeOfEnclosingFunction(CppTypeContext& tc);
    public static CppCoAwaitResolveResult ResolveCoAwaitExpression(CppResolveEngine resolveEngine, ICppResolvedExpression arg);
    public static CppCoYieldResolveResult ResolveCoYieldExpression(CppResolveEngine resolveEngine, ICppResolvedExpression arg);
    public static CppCoReturnResolveResult ResolveCoReturnStatement(CppResolveEngine resolveEngine, ICppResolvedExpression returnedExpr);
    public static CppResolveResult ResolveGetReturnObject(CppResolveEngine resolveEngine, CppQualType promiseType);
    public static CppResolveResult ResolveInitialSuspend(CppResolveEngine resolveEngine, CppQualType promiseType);
    public static CppResolveResult ResolveFinalSuspend(CppResolveEngine resolveEngine, CppQualType promiseType);
    public static CppResolveResult ResolveReturnVoid(CppResolveEngine resolveEngine, CppQualType promiseType);
    public static CppResolveResult ResolveUnhandledException(CppResolveEngine resolveEngine, CppQualType promiseType);
    public static CppCoAwaitResolveResult ResolveCoAwaitExpression(CppResolveEngine resolveEngine, CppQualType promiseType, ICppResolvedExpression arg);
    private static CppQualifiedName CreatePromiseTypeName(CppQualType coroutineType, bool hasExperimentalCoroutines);
    private static CppQualifiedName CreateCoroutineHandleName(CppQualType promiseType, bool hasExperimentalCoroutines);
    private static bool HasExperimentalCoroutines(CppViewPos& viewPos);
    private static CppQualType GetCoroutineHandleType(CppQualType promiseType, CppTypeContext& tc);
    private static CppResolvedCallExpression ResolveMemberFunctionCall(CppResolveEngine resolveEngine, CppTypeAndCategory objectType, CppQualifiedName memberName, ICppExpression[] arguments);
    private static CppResolvedCallExpression ResolveFreeFunctionCall(CppResolveEngine resolveEngine, CppTypeAndCategory objectType, CppQualifiedName memberName, ICppExpression[] arguments);
    private static CppResolvedCallExpression ResolveMemberOrFreeFunctionCall(CppResolveEngine resolveEngine, CppTypeAndCategory objectType, CppQualifiedName memberName, ICppExpression[] arguments);
    private static void ResolveAwaiterFunctions(CppResolveEngine resolveEngine, CppTypeAndCategory awaiterType, CppQualType promiseType, CppQualType& awaiterTypeResult, CppResolveResult& awaitReadyResult, CppResolveResult& awaitResumeResult, CppResolveResult& awaitSuspendResult);
    private static CppTypeAndCategory GetAwaiterType(ICppResolvedExpression argument, ICppOverloadContextCaller caller, CppTypeContext& tc, CppResolveResult& resolveResult);
    private static bool HasMemberAwaitTransform(CppQualType promiseType, CppViewPos& viewPos);
    private static ICppResolvedExpression TryApplyAwaitTransform(CppResolveEngine resolveEngine, CppQualType promiseType, ICppResolvedExpression argument, CppResolveResult& rr);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppCoYieldResolveResult : ValueType {
    public CppQualType PromiseType;
    public CppResolveResult YieldValue;
    public CppResolveResult OperatorCoAwait;
    public CppQualType AwaiterType;
    public CppResolveResult AwaitReady;
    public CppResolveResult AwaitSuspend;
    public CppResolveResult AwaitResume;
}
public static class JetBrains.ReSharper.Psi.Cpp.Resolve.CppCxxCliPropertyDeclaratorResolveEntityUtil : object {
    [CanBeNullAttribute]
public static ICppGroupedFunctionDeclaratorResolveEntity ResolveFunction(ICppCxxCliPropertyDeclaratorResolveEntity prop, CppOperatorKind op);
    [CanBeNullAttribute]
private static ICppGroupedFunctionDeclaratorResolveEntity ResolveFunctionImpl(ICppCxxCliPropertyDeclaratorResolveEntity event_, CppQualifiedId name);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppDeclaratorGroupBuilder : object {
    private CppGroupedDeclStorage`4<KeyType, CppGroupedFunctionDeclaratorResolveEntity, ICppFunctionOrVariableDeclaratorResolveEntity, CppFunctionGroupedDeclStorageTraits> myFunctions;
    private CppGroupedDeclStorage`4<KeyType, CppGroupedVariableDeclaratorResolveEntity, ICppVariableDeclaratorResolveEntity, CppVariableGroupedDeclStorageTraits> myVars;
    private CppGroupedDeclStorage`4<KeyType, CppGroupedTypeDeclaratorResolveEntity, ICppTypeDeclaratorResolveEntity, CppTypeGroupedDeclStorageTraits> myTypes;
    internal List`1<ICppResolveEntity> myOtherEntities;
    private CppTemplateFunctionKeyEqualityComparer myTemplateEqComparer;
    private CppTemplateFunctionGroupBuilder myTemplateFunctionBuilder;
    private CppTemplateTypeGroupBuilder myTemplateTypeBuilder;
    private CppTemplateVariableGroupBuilder myTemplateVariableBuilder;
    [CompilerGeneratedAttribute]
private bool <GroupFunctionsIgnoringReturnType>k__BackingField;
    public bool GroupFunctionsIgnoringReturnType { get; }
    public CppDeclaratorGroupBuilder(bool groupFunctionsIgnoringReturnType);
    public CppDeclaratorGroupBuilder(bool groupFunctionsIgnoringReturnType, CppList`1<ICppResolveEntity> groupedEntities);
    [CompilerGeneratedAttribute]
public bool get_GroupFunctionsIgnoringReturnType();
    public ICppGroupedDeclaratorResolveEntity AddDeclaratorEntity(ICppDeclaratorResolveEntity declEnt, bool groupedMustExists);
    public ICppGroupedDeclaratorResolveEntity TryAddDeclaratorEntity(ICppDeclaratorResolveEntity declEnt, bool addExisting);
    public void AddGroupedDeclarator(ICppDeclaratorOrTemplateDeclaratorPack ent);
    public List`1<ICppResolveEntity> GetGroupedEntities();
    public void AppendGroupedEntities(CppLocationAnchor anchor, FrugalLocalList`1& result);
    public void AppendGroupedEntities(CppLocationAnchor anchor, List`1<ICppResolveEntity> result);
    public void AppendGroupedEntitiesWithUnpackedTemplateSpecializations(List`1<ICppResolveEntity> result);
    public ICppGroupedDeclaratorResolveEntity FindGroupedDeclarator(ICppDeclaratorResolveEntity ungrouped);
    public CppSmallEnumerable`1<CppGroupedVariableDeclaratorResolveEntity> GetGroupedVariables();
    public CppSmallEnumerable`1<CppGroupedFunctionDeclaratorResolveEntity> GetGroupedFunctions();
    public CppSmallEnumerable`1<ICppMutableFunctionTemplateDeclaratorResolveEntity> GetFunctionTemplates();
    public CppSmallEnumerable`1<ICppMutableVariableTemplateDeclaratorResolveEntity> GetVariableTemplates();
    public CppSmallEnumerable`1<CppGroupedTypeDeclaratorResolveEntity> GetGroupedTypeAliases();
    public CppSmallEnumerable`1<ICppMutableTypeTemplateDeclaratorResolveEntity> GetTypeAliasTemplates();
    public void ForEachUngroupedDeclarator(IUngroupedDeclaratorProcessor proc);
    public bool ContainsTypedef();
    public bool ContainsFunctionOrFunctionTemplate();
    public ICppDeclaratorResolveEntity GetAnyUngroupedDeclarator();
    private ICppGroupedFunctionDeclaratorResolveEntity AddFunctionEntity(ICppFunctionOrVariableDeclaratorResolveEntity ent, bool addExisting);
    internal ICppGroupedFunctionDeclaratorResolveEntity AddFunctionTemplateEntity(ICppFunctionOrVariableDeclaratorResolveEntity ent, bool shouldBeGroupedWithExisting);
    private ICppGroupedVariableDeclaratorResolveEntity AddVariableEntity(ICppVariableDeclaratorResolveEntity ent, bool addExisting);
    internal ICppGroupedVariableDeclaratorResolveEntity AddVariableTemplateEntity(ICppVariableDeclaratorResolveEntity ent);
    private ICppGroupedTypeDeclaratorResolveEntity AddTypeEntity(ICppTypeDeclaratorResolveEntity ent, bool addExisting);
    internal ICppGroupedTypeDeclaratorResolveEntity AddTypeTemplateEntity(ICppTypeDeclaratorResolveEntity ent);
    internal ICppGroupedFunctionDeclaratorResolveEntity AddExplicitInstantiationFunction(ICppFunctionOrVariableDeclaratorResolveEntity ent);
    internal void AddOtherEntity(ICppResolveEntity ent);
    private CppTemplateFunctionGroupBuilder GetTemplateFunctionBuilder();
    private CppTemplateTypeGroupBuilder GetTemplateTypeBuilder();
    private CppTemplateVariableGroupBuilder GetTemplateVariableBuilder();
    private CppTemplateFunctionKeyEqualityComparer GetTemplateKeyEqualityComparer();
    private void AddGroupedFunctionEntity(ICppGroupedFunctionDeclaratorResolveEntity ent);
    private void AddGroupedVariableEntity(ICppGroupedVariableDeclaratorResolveEntity ent);
    private void AddGroupedTypeEntity(ICppGroupedTypeDeclaratorResolveEntity ent);
    private void AddGroupedFunctionTemplate(ICppFunctionTemplateDeclaratorResolveEntity ent);
    private void AddGroupedTypeTemplate(ICppTypeTemplateDeclaratorResolveEntity ent);
    private void AddGroupedVariableTemplate(ICppVariableTemplateDeclaratorResolveEntity ent);
    internal bool Internal_IsDeclaratorPackComeOnlyFromGGDeclareHungarianDirective();
    public static CppTemplateId GetTemplateIdName(ICppDeclaratorResolveEntity ent);
    public static bool HasSubstitutionParents(ICppDeclaratorResolveEntity ent);
    public static CppQualType PatchFunctionType(ICppDeclaratorResolveEntity ent, CppQualType type, ICppResolvedTypeFactory tf);
    public static void AddRange(List`1<ICppResolveEntity> result, IEnumerable`1<T> range);
    public static void AddRange(List`1<ICppResolveEntity> result, IEnumerable`1<T> range, CppLocationAnchor anchor);
    public static void AddRange(FrugalLocalList`1& result, IEnumerable`1<T> range, CppLocationAnchor anchor);
    public static Action ForEachUngrouped(ICppResolveEntity ent, IUngroupedDeclaratorProcessor proc);
    private CppTemplateFunctionKey CreateTemplateGroupingKey(ICppDeclaratorResolveEntity ent);
}
internal class JetBrains.ReSharper.Psi.Cpp.Resolve.CppDeductionGuideFromAggregate : CppDeductionGuideFromConstructor {
    private CppDeductionGuideFromAggregate(CppClassTemplateResolveEntityPack classTemplate, ICppClassResolveEntity primaryTemplate, ICppGroupedFunctionDeclaratorResolveEntity ctor);
    public static CppDeductionGuideFromAggregate Create(CppClassTemplateResolveEntityPack classTemplate, ICppClassResolveEntity primaryTemplate, ICppExpression[] initList, CppArgumentListKind kind, CppTypeContext& tc);
    public virtual SourceKind GetSourceKind();
}
internal class JetBrains.ReSharper.Psi.Cpp.Resolve.CppDeductionGuideFromConstructor : CppSynthesizedDeductionGuide`1<ICppGroupedFunctionDeclaratorResolveEntity> {
    public ICppGroupedFunctionDeclaratorResolveEntity Function { get; }
    public CppDeductionGuideFromConstructor(CppClassTemplateResolveEntityPack classTemplate, ICppClassResolveEntity primaryTemplate, ICppGroupedFunctionDeclaratorResolveEntity ctor);
    public virtual CppTemplateParametersBase GetParameters();
    public virtual ICppTemplateArgument[] GetDefaults(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool CanBeCalledWithZeroArguments();
    public virtual int GetFirstDefaultArgIndex();
    public virtual ICppParameterListResolveEntity GetMainParameterList();
    public virtual ICppGroupedFunctionDeclaratorResolveEntity get_Function();
}
internal class JetBrains.ReSharper.Psi.Cpp.Resolve.CppDeductionGuideFromConstructorTemplate : CppSynthesizedDeductionGuide`1<ICppFunctionTemplateDeclaratorResolveEntity> {
    private CppTemplateParametersBase myTemplateParams;
    public ICppGroupedFunctionDeclaratorResolveEntity Function { get; }
    public CppDeductionGuideFromConstructorTemplate(CppClassTemplateResolveEntityPack classTemplate, ICppClassResolveEntity primaryTemplate, ICppFunctionTemplateDeclaratorResolveEntity ctor);
    private ICppExpressionTemplateParameterOrPack Recreate(ICppExpressionTemplateParameterOrPack original);
    private ICppTemplateParameter Recreate(ICppConceptTemplateParameter paramOrPack);
    public ICppTemplateArgument[] RecreateTemplateArgumentsFromConstraint(ICppResolvedExpression constraint);
    private CppTemplateParametersBase Recreate(CppTemplateParametersBase ctorParams);
    private CppGeneratedTemplateParameters Recreate(CppTemplateParametersBase ctorParams, int i, ICppTemplateParameter ithParam, ICppResolvedExpression oldRequiresClause);
    private static CppTemplateParametersBase Concat(CppTemplateParametersBase left, CppTemplateParametersBase right, ICppResolveEntity context);
    public virtual CppTemplateParametersBase GetParameters();
    public virtual ICppTemplateArgument[] GetDefaults(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool IsFunctionTemplateParameter(ICppTemplateParameter param);
    public virtual bool CanBeCalledWithZeroArguments();
    public virtual int GetFirstDefaultArgIndex();
    public virtual ICppParameterListResolveEntity GetMainParameterList();
    public virtual ICppGroupedFunctionDeclaratorResolveEntity get_Function();
    private void CopyDefaults(ICppTemplateArgument[] ctorDefaults, ICppTemplateArgument[] dest, int destIndex);
    private ICppTemplateArgument DropDecorations(ICppTemplateArgument arg);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Resolve.CppDeductionGuideUtil : object {
    [ExtensionAttribute]
public static bool IsUserProvided(ICppDeductionGuide guide);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppFunctionTemplateDeclaratorResolveEntity : CppTemplateDeclaratorResolveEntityBase`2<ICppGroupedFunctionDeclaratorResolveEntity, ICppFunctionOrVariableDeclaratorResolveEntity> {
    private CppFunctionSubstitutionCache mySubstCache;
    private CppDependentInfoCachedValue myCachedDepInfo;
    public CppFunctionTemplateDeclaratorResolveEntity(ICppFunctionOrVariableDeclaratorResolveEntity ent);
    protected CppFunctionTemplateDeclaratorResolveEntity(ICppResolveEntity parent, CppQualifiedNamePart name, CppLocationAnchor anchor);
    public virtual CppDependentInfo GetDependentInfo();
    public virtual CppPickFunctionSpecializationResult PickSpecializationInSFINAEContext(CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc, CppSubstitutionContext subst, ICppTemplateFunctionCallDeductionErrorConsumer errorConsumer, ICppResolvedExpression& constraint);
    public virtual CppPickFunctionSpecializationResult PickSpecialization(CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc, CppSubstitutionContext subst);
    public virtual CppPickFunctionSpecializationResult PickCachedSpecialization(CppSubstitutionContext subst);
    public virtual CppQualType GetTemplateType(ICppResolvedTypeFactory tf);
    public virtual ICppParameterListResolveEntity GetMainParameterList();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual void Dump(CppIndentationStringBuilder tw);
    public virtual IList`1<ICppGroupedFunctionDeclaratorResolveEntity> GetCachedSpecializations();
    public sealed virtual ICppTemplateArgument[] FindSubstitutionTemplateArguments(ICppFunctionDeclaratorResolveEntity substituted);
    public virtual void AddSpecialization(ICppGroupedFunctionDeclaratorResolveEntity specialization);
    public ICppGroupedFunctionDeclaratorResolveEntity AddImportedSpecialization(CppImportedTemplateFunctionSpecializationDeclaratorResolveEntity ent);
    public virtual string ToString();
    private CppFunctionSubstitutionCache GetOrCreateSubstitutionCache();
    public static CppSubstitutionContext GetRestrictedSubstitutionContext(ICppFunctionTemplateDeclaratorResolveEntity func, CppSubstitutionContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppFunctionTemplateDeclaratorResolveEntityWithSubstitution : CppFunctionTemplateDeclaratorResolveEntity {
    private ICppFunctionTemplateDeclaratorResolveEntity myInner;
    internal CppFunctionTemplateDeclaratorResolveEntityWithSubstitution(ICppResolveEntity parent, CppQualifiedNamePart name, ICppFunctionTemplateDeclaratorResolveEntity inner, CppSubstitutionDriver substitutionDriver);
    public ICppFunctionTemplateDeclaratorResolveEntity GetInner();
    public virtual string ToString();
    internal List`1<ICppGroupedFunctionDeclaratorResolveEntity> SubstituteSpecializations(CppSubstitutionDriver substitutionDriver);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Resolve.CppGroupedDeclaratorResolveEntity`1 : object {
    private CppSmallList`1<Declarator> myEntities;
    private ICppResolveEntityParent myParent;
    private CppQualifiedNamePart myName;
    private int myListOfUngroupedState;
    private Declarator myFirstEntity;
    private CppLocationAnchor myAnchor;
    [CompilerGeneratedAttribute]
private CppDeclarationSpecifiers <DeclarationSpecifiers>k__BackingField;
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; protected set; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public int EntitiesCount { get; }
    protected CppGroupedDeclaratorResolveEntity`1(Declarator ent);
    public virtual ICppResolveEntityParent get_RealParent();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    [CompilerGeneratedAttribute]
public sealed virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    [CompilerGeneratedAttribute]
protected void set_DeclarationSpecifiers(CppDeclarationSpecifiers value);
    public virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public abstract virtual CppAttributeList get_Attributes();
    public int get_EntitiesCount();
    public virtual void AddEntity(Declarator ent);
    public virtual bool Contains(ICppDeclaratorResolveEntity decl);
    public bool TryAddAndReplaceSingleEntity(Declarator ent);
    protected void ReplaceName(CppQualifiedNamePart newName);
    protected void ReplaceSingleEntity(Declarator ent);
    protected CppSmallList`1<Declarator> GetGroupedEntitiesInternal();
    public sealed virtual Declarator GetAnyUngrouped();
    private bool ParentIsValid();
}
[DebuggerDisplayAttribute("function-declarator {Name}")]
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppGroupedFunctionDeclaratorResolveEntity : object {
    private static int Released;
    private static int ReadLocked;
    private static int WriteLocked;
    private ICppResolveEntityParent myParent;
    private CppQualifiedNamePart myName;
    private CppLocationAnchor myAnchor;
    private ICppMutableFunctionTemplateDeclaratorResolveEntity myTemplateDecl;
    private CppDeclarationSpecifiers mySpecs;
    private CppAttributeList myAttributes;
    private CppList`1<ICppFunctionOrVariableDeclaratorResolveEntity> myEntities;
    private int myListOfUngroupedState;
    private CppDependentInfoCachedValue myCachedDepInfo;
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public CppFunctionTraits Traits { get; }
    public ICppFunctionBodyResolveEntity Body { get; }
    public int BodyChameleonVersion { get; }
    public CppGroupedFunctionDeclaratorResolveEntity(ICppFunctionOrVariableDeclaratorResolveEntity ent);
    public CppGroupedFunctionDeclaratorResolveEntity(ICppFunctionOrVariableDeclaratorResolveEntity ent, ICppMutableFunctionTemplateDeclaratorResolveEntity templateDecl);
    public void SetTemplateDeclarator(ICppMutableFunctionTemplateDeclaratorResolveEntity templateDecl);
    public virtual ICppResolveEntityParent get_RealParent();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual bool Contains(ICppDeclaratorResolveEntity ungrouped);
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public virtual CppAttributeList get_Attributes();
    public sealed virtual CppDependentInfo GetDependentInfo();
    private CppDependentInfo CalculateDependentInfo();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual ICppFunctionTemplateDeclaratorResolveEntity GetTemplateDeclaration();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public virtual bool InstantiateFunctionBody(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp, bool forceChameleonInstantiation);
    internal static bool InstantiateFunctionBody(ICppFunctionOrVariableDeclaratorResolveEntity ungrouped, CppViewPos& vp, bool forceChameleonInstantiation);
    public virtual ICppFunctionDeclaratorResolveEntity GetUngroupedThatProvidingBody();
    public virtual CppFunctionTraits get_Traits();
    public virtual ICppFunctionBodyResolveEntity get_Body();
    public virtual int get_BodyChameleonVersion();
    public virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public virtual ICppParameterListResolveEntity GetMainParameterList();
    public virtual int GetFirstDefaultArgIndex();
    public sealed virtual ICppFunctionOrVariableDeclaratorResolveEntity GetFirstUngrouped();
    public ICppFunctionOrVariableDeclaratorResolveEntity GetAnyUngrouped();
    public virtual IEnumerable`1<ICppResolveEntity> GetResolvedCxxCliOverrideSpecifierTargets();
    public virtual ICppResolvedExpression GetResolvedRequiresClause();
    public sealed virtual CppList`1<ICppFunctionOrVariableDeclaratorResolveEntity> GetUngroupedDeclarators();
    public virtual void AddEntity(ICppFunctionOrVariableDeclaratorResolveEntity ent);
    public static CppGroupedFunctionDeclaratorResolveEntity Create(ICppFunctionOrVariableDeclaratorResolveEntity ent);
    public static CppGroupedFunctionDeclaratorResolveEntity CreateGenerated(CppGeneratedResolveEntityType entityType, CppQualType type, ICppResolveEntityParent parent, CppQualifiedNamePart name, CppLocationAnchor anchor);
    public static CppGroupedFunctionDeclaratorResolveEntity CreateGenerated(CppGeneratedResolveEntityType entityType, CppQualType type, ICppResolveEntityParent parent, CppQualifiedNamePart name, CppLocationAnchor anchor, CppDeclarationSpecifiers specs);
    public static CppGroupedFunctionDeclaratorResolveEntity CreateGenerated(CppGeneratedFunctionDeclaratorResolveEntity ungrouped);
    public CppGeneratedResolveEntityType GetEntityType();
    public virtual string ToString();
    public static bool CanResolveReturnType(ICppGroupedFunctionDeclaratorResolveEntity func);
    public CppQualType ResolveReturnType(ICppResolvedTypeFactory tf);
    public void TryAddExplicitTemplateSpecialization(ICppFunctionOrVariableDeclaratorResolveEntity ent);
    private static bool IsSubstitutedFriend(ICppFunctionOrVariableDeclaratorResolveEntity ent);
    private void ChangeNameFromSubstitutionToTemplateId(ICppFunctionOrVariableDeclaratorResolveEntity ent);
    public static bool GroupedDeclaratorHasBody(CppGroupedFunctionDeclaratorResolveEntity grouped);
    private void ReplaceSingleEntity(ICppFunctionOrVariableDeclaratorResolveEntity ent);
    public static bool HasNonChameleonBody(ICppGroupedFunctionDeclaratorResolveEntity grouped);
    private static CppQualifiedNamePart ChangeNameFromSubstitutionToTemplateId(CppQualifiedNamePart name);
    private static bool DeclaratorHasBody(ICppFunctionDeclaratorResolveEntity decl);
    internal static bool ShouldDeduceReturnType(CppQualType returnType, ICppGroupedFunctionDeclaratorResolveEntity func);
    private static bool HasDependentArgs(CppQualifiedNamePart name);
    public static ReturnStatementFindResult FindFirstReturn(ICppScopeStatementResolveEntity cs);
    private static CppQualType CalculateReturnType(ICppFunctionBodyResolveEntity body, ICppResolvedTypeFactory typeIntern);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Resolve.CppGroupedFunctionDeclaratorResolveEntityUtil : object {
    [ExtensionAttribute]
public static bool InstantiateFunctionBody(ICppGroupedFunctionDeclaratorResolveEntity func, CppViewPos& vp);
    [ExtensionAttribute]
public static CppQualType GetTypeWithUndefinedReturnTypeAndCallingConvention(ICppGroupedFunctionDeclaratorResolveEntity func, ICppResolvedTypeFactory typeIntern);
    [ExtensionAttribute]
public static bool HasDeducibleReturnType(ICppGroupedFunctionDeclaratorResolveEntity func, ICppResolvedTypeFactory typeIntern);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppGroupedTypeDeclaratorResolveEntity : CppGroupedDeclaratorResolveEntity`1<ICppTypeDeclaratorResolveEntity> {
    private ICppTypeTemplateDeclaratorResolveEntity myTemplateDeclaration;
    [CompilerGeneratedAttribute]
private CppAttributeList <Attributes>k__BackingField;
    public CppAttributeList Attributes { get; }
    public CppGroupedTypeDeclaratorResolveEntity(ICppTypeDeclaratorResolveEntity ent, ICppTypeTemplateDeclaratorResolveEntity templateDeclaration);
    public void SetTemplateDeclaration(ICppTypeTemplateDeclaratorResolveEntity templateDeclaration);
    [CompilerGeneratedAttribute]
public virtual CppAttributeList get_Attributes();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public virtual void AddEntity(ICppTypeDeclaratorResolveEntity ent);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual CppSmallList`1<ICppTypeDeclaratorResolveEntity> GetUngroupedDeclarators();
    public virtual ICppTypeTemplateDeclaratorResolveEntity GetTemplateDeclaration();
    public static CppGroupedTypeDeclaratorResolveEntity Create(ICppTypeDeclaratorResolveEntity ent, ICppTypeTemplateDeclaratorResolveEntity templateDeclaration);
    public static CppGroupedTypeDeclaratorResolveEntity Create(ICppTypeDeclaratorResolveEntity ent);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppGroupedVariableDeclaratorResolveEntity : CppGroupedDeclaratorResolveEntity`1<ICppVariableDeclaratorResolveEntity> {
    private ICppVariableTemplateDeclaratorResolveEntity myTemplate;
    private CppAttributeList myAttributes;
    private CppDependentInfoCachedValue myCachedDepInfo;
    private CppCachedReference`1<ICppEvaluationResult> myCachedValue;
    public CppAttributeList Attributes { get; }
    public bool IsParameterPack { get; }
    protected CppGroupedVariableDeclaratorResolveEntity(ICppVariableDeclaratorResolveEntity ent, ICppVariableTemplateDeclaratorResolveEntity templDecl);
    public void SetTemplateDeclaration(ICppVariableTemplateDeclaratorResolveEntity templDecl);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual CppAttributeList get_Attributes();
    public virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual bool HasInitializer();
    public ValueTuple`2<ICppVariableDeclaratorResolveEntity, CppDeclaratorInitializer> GetUngroupedThatProvidingInitializer();
    public virtual ICppEvaluationResult GetValue(CppEvaluationParams evalParams, ICppEvaluationErrorTracker errorTracker);
    internal bool HasCachedValue();
    private static bool IsPotentiallyConstantVariable(CppGroupedVariableDeclaratorResolveEntity ent, CppEvaluationParams evalParams, ICppResolvedTypeFactory tf);
    private static ICppEvaluationResult CalculateValue(CppGroupedVariableDeclaratorResolveEntity var, CppEvaluationParams evalParams, ICppEvaluationErrorTracker errorTracker);
    public virtual bool get_IsParameterPack();
    public virtual CppSmallList`1<ICppVariableDeclaratorResolveEntity> GetUngroupedDeclarators();
    public virtual ICppVariableTemplateDeclaratorResolveEntity GetTemplateDeclaration();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public static CppGroupedVariableDeclaratorResolveEntity Create(ICppVariableDeclaratorResolveEntity ent, ICppVariableTemplateDeclaratorResolveEntity templDecl);
    public static CppGroupedVariableDeclaratorResolveEntity CreateSingle(ICppVariableDeclaratorResolveEntity ent);
    public virtual void AddEntity(ICppVariableDeclaratorResolveEntity ent);
    public virtual void ChangeNameTemplateArguments(ICppTemplateArgument[] args);
    public CppGeneratedResolveEntityType GetEntityType();
    public virtual string ToString();
    protected virtual CppDependentInfo CalculateDependentInfo();
    [CompilerGeneratedAttribute]
internal static CppRuntimeArrayValue <CalculateValue>g__CreateRuntimeArrayValue|16_0(CppGroupedVariableDeclaratorResolveEntity var, CppArrayType array, CppTypeContext& typeContext);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppGroupingEqualityComparer : CppTemplateParametersComparer {
    private CompactMap`2<ICppVariableDeclaratorResolveEntity, int> myTopLevelFunctionParameterToIndex;
    public void AddTopLevelFunctionParameters(ICppFunctionDeclaratorResolveEntity function);
    public void AddTopLevelFunctionParameters(CppList`1<ICppVariableDeclaratorResolveEntity> params);
    public virtual bool ReApply(ICppResolveEntity lhs, ICppResolveEntity rhs);
    public virtual int ReApplyHashCode(ICppResolveEntity ent);
    private bool CheckFunctionParametersForEquality(ICppVariableDeclaratorResolveEntity lhs, ICppVariableDeclaratorResolveEntity rhs);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppNamedBuiltinFunctionResolveEntity : CppBuiltinOperatorResolveEntity {
    private CppQualifiedNamePart myName;
    public CppQualifiedNamePart Name { get; }
    public CppNamedBuiltinFunctionResolveEntity(CppQualifiedNamePart name, CppQualType functionType);
    public virtual CppQualifiedNamePart get_Name();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppNewExpressionResolveResult : ValueType {
    public CppResolveResult OperatorResolveResult;
    public CppResolveResult ConstructorResolveResult;
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Resolve.CppNonTemplateGroupedDeclStorageUtil : object {
    [ExtensionAttribute]
public static TGroupedEntity FindGroupedDeclarator(CppGroupedDeclStorage`4<KeyType, TGroupedEntity, TEntity, TTraits> storage, ICppDeclaratorResolveEntity ungrouped);
    [ExtensionAttribute]
public static ICppDeclaratorResolveEntity GetAnyUngroupedDeclarator(CppGroupedDeclStorage`4<KeyType, TGroupedEntity, TEntity, TTraits> storage);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppOverloadedFunctionResolveResult : ValueType {
    public bool Succeeded;
    public CppResolveResult ResolveResult;
    public CppTypeAndCategory FunctionType;
    private CppOverloadedFunctionResolveResult(CppResolveResult& rr, CppTypeAndCategory type, bool succeeded);
    public static CppOverloadedFunctionResolveResult Success(CppResolveResult& rr, CppTypeAndCategory type);
    public static CppOverloadedFunctionResolveResult Failure();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppPickFunctionSpecializationResult : ValueType {
    [CompilerGeneratedAttribute]
private ICppGroupedFunctionDeclaratorResolveEntity <Specialization>k__BackingField;
    public ICppGroupedFunctionDeclaratorResolveEntity Specialization { get; }
    public CppPickFunctionSpecializationResult(ICppGroupedFunctionDeclaratorResolveEntity ent);
    public bool IsOk();
    [CompilerGeneratedAttribute]
public ICppGroupedFunctionDeclaratorResolveEntity get_Specialization();
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppRangeBasedForResolveEngine : object {
    private CppResolveEngine myADLResolveEngine;
    private CppResolveEngine myResolveEngine;
    private CppTypeContext myTypeContext;
    private ICppResolvedExpression myRangeExpr;
    private ICppResolvedExpression myBeginExpr;
    private ICppResolvedExpression myEndExpr;
    private CppRangeBasedForResolveKind myResolveKind;
    private CppForStatementKind myForType;
    private CppResolvedCallExpression myGetEnumeratorCallExpr;
    private CppResolvedMemberAccessExpression myCurrentMemAccessExpr;
    private CppRangeBasedForResolveEngine(ICppResolvedExpression rangeExpr, CppForStatementKind forType, CppTypeContext& tc, ICppFileResolveEntitiesCache cache);
    public static CppRangeBasedForResolveEngine Create(ICppResolvedExpression rangeInitializer, CppForStatementKind forType, CppTypeContext& tc, ICppFileResolveEntitiesCache cache);
    public static CppRangeBasedForResolveEngine Create(CppResolvedQualifiedReferenceExpression range, CppForStatementKind forType, CppTypeContext& tc);
    public ICppResolvedExpression DesugarRangeDeclarationInitializer();
    public CppResolvedUnaryExpression DesugarRangeDeclarationInitializer(ICppResolvedExpression iterator, CppDependentInfo& depInfo);
    [CanBeNullAttribute]
public CppResolvedUnaryExpression DesugarIncrement(ICppResolvedExpression iterator, CppDependentInfo& depInfo);
    [CanBeNullAttribute]
public CppResolvedBinaryExpression DesugarCondition(ICppResolvedExpression iterator, ICppResolvedExpression end, CppDependentInfo& depInfo);
    public ICppResolvedExpression GetBeginExpression();
    public ICppResolvedExpression GetEndExpression();
    public CppResolveResult GetGetEnumeratorResolveResult();
    public CppResolveResult GetCurrentResolveResult();
    public CppResolveResult GetMoveNextResolveResult();
    private void DesugarBeginEndExpression(ICppResolvedExpression& beginExpr, ICppResolvedExpression& endExpr, CppRangeBasedForResolveKind& kind);
    private ICppResolvedExpression ResolveCallToMember(CppQualifiedName name);
    private ICppResolvedExpression ResolveCallToFreeFunction(CppQualifiedName name);
    private CppResolvedMemberAccessExpression CliMemAccess(ICppResolvedExpression obj, CppQualifiedName member);
}
public enum JetBrains.ReSharper.Psi.Cpp.Resolve.CppRangeBasedForResolveKind : Enum {
    public int value__;
    public static CppRangeBasedForResolveKind ArrayRange;
    public static CppRangeBasedForResolveKind ClassMemberBeginEndCall;
    public static CppRangeBasedForResolveKind UnqualifiedBeginEndCall;
    public static CppRangeBasedForResolveKind CliUserDefined;
    public static CppRangeBasedForResolveKind CliArray;
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppResolveCallsUsingOnlyADLLookupEngine : CppResolveEngine {
    public CppResolveCallsUsingOnlyADLLookupEngine(CppTypeContext& tc, ICppFileResolveEntitiesCache cache);
    protected virtual CppOverloadContextWithCaller GetOverloadContext(ICppCallExpression expr, CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc);
}
public static class JetBrains.ReSharper.Psi.Cpp.Resolve.CppResolveConversionUtil : object {
    public static Nullable`1<CppOverloadingRunInfo> ResolveCopyConstructorIfRequired(CppStandardConversionSequence seq, CppTypeContext& tc, CppExpressionInfo from, ICppOverloadingInfoAggregatorFactory expTypeFactory);
    public static Nullable`1<CppResolveResult> GetResolveResultOfConversion(CppImplicitConversionSequence seq, ICppFileResolveEntitiesCache cache, CppTypeContext& tc);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppResolveConversionVisitor : object {
    private ICppFileResolveEntitiesCache myCache;
    private CppViewPos myViewPos;
    [CompilerGeneratedAttribute]
private CppResolveResult <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResultWasSet>k__BackingField;
    public CppResolveResult Result { get; private set; }
    public bool ResultWasSet { get; private set; }
    public CppResolveConversionVisitor(ICppFileResolveEntitiesCache cache, CppViewPos& viewPos);
    [CompilerGeneratedAttribute]
public CppResolveResult get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(CppResolveResult value);
    [CompilerGeneratedAttribute]
public bool get_ResultWasSet();
    [CompilerGeneratedAttribute]
private void set_ResultWasSet(bool value);
    public virtual bool Visit(CppOverloadingRunInfo info);
    public virtual bool Visit(CppImplicitConversionSequence conv);
    public virtual bool Visit(CppCastConversion cast);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppResolveConversionWithCopyConstructorVisitor : CppResolveConversionVisitor {
    private CppTypeContext myTypeContext;
    public CppResolveConversionWithCopyConstructorVisitor(ICppFileResolveEntitiesCache cache, CppTypeContext& tc);
    public virtual bool Visit(CppImplicitConversionSequence conv);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppResolveEngine : object {
    private ICppFileResolveEntitiesCache myFileCache;
    public CppTypeContext TypeContext;
    private CppResolveEngineMode myMode;
    [IsReadOnlyAttribute]
public CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) ViewPos { get; }
    public ICppResolvedTypeFactory TypeFactory { get; }
    public ICppFileResolveEntitiesCache ResolveCache { get; }
    [DebuggerStepThroughAttribute]
public CppResolveEngine(CppTypeContext& tc, ICppFileResolveEntitiesCache cache);
    [DebuggerStepThroughAttribute]
public CppResolveEngine(CppTypeContext& tc, ICppFileResolveEntitiesCache cache, CppResolveEngineMode mode);
    [DebuggerStepThroughAttribute]
public CppResolveEngine(ICppCompositeNode node);
    public CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) get_ViewPos();
    public ICppResolvedTypeFactory get_TypeFactory();
    public ICppFileResolveEntitiesCache get_ResolveCache();
    public CppResolveResult ResolveUnaryOperator(ICppResolvedExpression arg, CppOperatorKind kind, CppDependentInfo& depInfo);
    public CppResolveResult ResolveNonDependentUnaryOperator(ICppResolvedExpression arg, CppOperatorKind kind, FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> firstLookupPhaseCandidates);
    public CppResolveResult ResolvePsiUnaryOperatorWithCache(UnaryExpression expr);
    public CppResolveResult ResolvePostfixOperator(ICppResolvedExpression operand, CppOperatorKind operatorKind, CppDependentInfo& depInfo);
    public CppResolveResult ResolveNonDependentPostfixOperator(ICppResolvedExpression operand, CppOperatorKind operatorKind, FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> firstLookupPhaseCandidates);
    public CppResolveResult ResolvePsiPostfixOperatorWithCache(PostfixExpression expr);
    private CppResolveResult FirstLookupPhase(CppOperatorKind kind);
    public CppResolveResult ResolveBinaryOperator(ICppResolvedExpression left, ICppResolvedExpression right, CppOperatorKind kind, CppDependentInfo& depInfo);
    public CppResolveResult ResolveBinaryOperator(ICppResolvedExpression left, ICppResolvedExpression right, CppOperatorKind kind, bool allowRewrittenCandidates, ICppFunctionOrTemplateDeclaratorResolveEntity candidateToSkip, CppDependentInfo& depInfo);
    public CppResolveResult ResolveNonDependentBinaryOperator(ICppResolvedExpression left, ICppResolvedExpression right, CppOperatorKind kind, bool allowRewrittenCandidates, ICppFunctionOrTemplateDeclaratorResolveEntity candidateToSkip, FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> firstLookupPhaseCandidates);
    public CppResolveResult ResolvePsiBinaryOperatorWithCache(BinaryExpression binExpr);
    public CppResolveResult ResolveSubscriptOperator(ICppResolvedExpression left, CppSmallArray`1<ICppExpression> indices, CppDependentInfo& depInfo);
    public CppResolveResult ResolvePsiSubscriptOperatorWithCache(SubscriptExpression expr);
    public CppResolveResult ResolvePsiMultiArgumentSubscriptOperatorWithCache(CliMultiArgumentSubscriptExpression expr);
    public CppResolveResult ResolveCallExpression(ICppTypeIdOrExpression callee, ICppExpression[] arguments, CppDependentInfo& depInfo);
    public CppResolveResult ResolveNewExpressionOperator(NewExpression expr);
    public CppResolveResult ResolvePsiCallExpressionWithCache(CallExpression expr);
    public CppResolveResult ResolveMemberAccessArrowReference(ICppResolvedExpression qualExpr);
    public CppResolveResult ResolveDotMemberAccessMemberReference(ICppResolvedExpression left, CppQualifiedName name, CppResolveResult& cachedUnqual);
    public CppResolveResult ResolveDotMemberAccessMemberReference(ICppResolvedExpression left, CppQualifiedName name);
    public CppResolveResult ResolveArrowMemberAccessMemberReference(ICppResolvedExpression left, CppQualifiedName name, CppResolveResult& arrowResolveResult, CppResolveResult& cachedUnqual);
    public CppResolveResult ResolveArrowMemberAccessMemberReference(ICppResolvedExpression left, CppQualifiedName name, CppResolveResult& arrowResolveResult);
    public CppResolveResult ResolvePsiMemAccessWithCache(MemberAccessExpression ref);
    public CppResolveResult ResolveOffsetOfMemberDesignator(CppQualType left, CppQualifiedName right, CppResolveResult previousResolveResult);
    public CppResolveResult ResolveBraceInitializedTemporary(ICppTypeIdOrExpression initializerTypeNode, ICppResolvedBracedInitListExpression argumentList, CppDependentInfo& depInfo);
    public CppResolveResult ResolveCastExpression(ICppResolvedExpression from, CppQualType to, CppCastType castType, CppDependentInfo& depInfo);
    public CppCoAwaitResolveResult ResolveCoAwaitExpression(ICppResolvedExpression arg);
    public CppCoYieldResolveResult ResolveCoYieldExpression(ICppResolvedExpression arg);
    public CppNewExpressionResolveResult ResolveNewExpression(ICppNewExpression expr, CppDependentInfo& depInfo);
    public CppQualifiedName ResolveName(CppQualifiedName name);
    protected virtual CppOverloadContextWithCaller GetOverloadContext(ICppCallExpression expr, CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc);
    private Nullable`1<CppResolveResult> ResolveBinaryOperatorWithoutOverloading(ICppResolvedExpression leftOp, ICppResolvedExpression rightOp, CppOperatorKind kind);
    private CppTypeAndCategory TypeOf(ICppResolvedExpression expr);
    private CppResolveResult ResolveUnaryOperatorImpl(UnaryExpression unExpr);
    private CppResolveResult ResolveMemberAccessMemberReference(CppQualType scopeType, CppQualifiedName name, CppResolveResult& resolvedUnqual, CppDependentInfo scopeDependent);
    internal CppResolveResult ResolveNewExpressionOperator(ICppNewExpression expr);
    private CppResolveResult ResolveNewExpressionConstructor(ICppNewExpression expr);
    private CppResolveResult ResolveHlslSwizzling(CppQualType scopeType, CppQualifiedName name);
    private static CppResolveResult ResolveHlslMatrixSwizzling(HlslMatrixType matrixType, CppQualifiedId id);
}
internal static class JetBrains.ReSharper.Psi.Cpp.Resolve.CppResolveEngineImpl : object {
    private static bool RequiresOverloading(ICppResolvedUnaryExpression node, CppTypeContext& tc);
    private static bool RequiresOverloading(ICppResolvedPostfixExpression node, CppTypeContext& tc);
    private static CppResolveResult ResolveUnaryWithoutOverloading(CppOperatorKind operatorKind, CppQualType type);
    internal static CppResolveResult ResolveUnaryReference(UnaryExpression node, CppTypeContext& tc);
    internal static CppResolveResult ResolvePostfixReference(PostfixExpression node, CppTypeContext& tc);
    internal static CppResolveResult ResolveUnaryReference(ICppResolvedExpression operand, CppOperatorKind operatorKind, CppTypeContext& tc, FrugalLocalList`1<ICppFunctionOrTemplateDeclaratorResolveEntity> firstLookupPhaseCandidates);
    internal static CppResolveResult ResolveSubscriptAsBuiltin(ICppResolvedExpression lhs, ICppResolvedExpression rhs, ICppResolvedTypeFactory typeFactory);
    internal static CppResolveResult RunOverloadingOnPsiNodeWithCacheImpl(TNode expr, CppTypeContext& tc);
    private static bool IsZero(ICppResolvedExpression expr);
}
public enum JetBrains.ReSharper.Psi.Cpp.Resolve.CppResolveEngineMode : Enum {
    public int value__;
    public static CppResolveEngineMode Psi;
    public static CppResolveEngineMode Expressions;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Resolve.CppResolveEngineUtil : object {
    [ExtensionAttribute]
public static CppResolvedBraceInitializedTemporaryExpression CreateResolvedBraceInitializedTemporaryExpression(CppResolveEngine engine, ICppTypeIdOrExpression callee, ICppResolvedBracedInitListExpression arg);
    [ExtensionAttribute]
public static CppResolvedCallExpression CreateResolvedCallExpression(CppResolveEngine engine, ICppTypeIdOrExpression callee, ICppExpression[] args, CppCallExpressionKind kind);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("Status = {myStatus}, Count = {myCandidates.Count}")]
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppResolveResult : ValueType {
    private Status myStatus;
    private FrugalLocalList`1<ICppResolveEntity> myCandidates;
    private CppResolveResult(Status status);
    public CppResolveResult(Status status, FrugalLocalList`1<ICppResolveEntity> candidates);
    [DebuggerStepThroughAttribute]
public Status GetStatus();
    [DebuggerStepThroughAttribute]
public FrugalLocalList`1<ICppResolveEntity> GetCandidates();
    public ICppResolveEntity GetPrimaryEntity();
    public static CppResolveResult OkOrNotResolvedOrMultipleCandidates(FrugalLocalList`1<ICppResolveEntity> ents);
    private static FrugalLocalList`1<ICppResolveEntity> MakeSingleElementList(ICppResolveEntity ent);
    private static NullFilterResult FilterNotNull(FrugalLocalList`1& list);
    public static CppResolveResult Ok(ICppResolveEntity ent);
    public static CppResolveResult Ok(FrugalLocalList`1<ICppResolveEntity> candidates);
    public static CppResolveResult Builtin(AbstractBuiltinResolveEntity ent);
    public static CppResolveResult NotResolved();
    public static CppResolveResult NotResolved(FrugalLocalList`1<ICppResolveEntity> candidates);
    public static CppResolveResult NoViableFunction(FrugalLocalList`1<ICppResolveEntity> candidates);
    public static CppResolveResult AmbiguousFunctionCall(FrugalLocalList`1<ICppResolveEntity> viableCandidates);
    public static CppResolveResult MultipleCandidates(FrugalLocalList`1<ICppResolveEntity> candidates);
    public static CppResolveResult DerefSequence(ICppResolveEntity ent, IEnumerable`1<ICppResolveEntity> sequence);
    public static CppResolveResult CopyElided();
    public static CppResolveResult ScalarCastOrValueInit();
    public static CppResolveResult AggregateInit(ICppClassResolveEntity clazz);
    public static CppResolveResult DifferentOperator(ICppResolveEntity ent);
    public static CppResolveResult ReversedArguments(ICppResolveEntity ent);
    public static CppResolveResult DerefSequenceInternal(FrugalLocalList`1<ICppResolveEntity> sequence);
    public static CppResolveResult BadDerefSequence(FrugalLocalList`1<ICppResolveEntity> sequence);
    public static CppResolveResult BadDerefSequence(IEnumerable`1<ICppResolveEntity> sequence);
    public static CppResolveResult DependentQualifiedMember(FrugalLocalList`1<ICppResolveEntity> candidates);
    public static CppResolveResult DependentQualifiedMember(IEnumerable`1<ICppResolveEntity> candidates);
    public static CppResolveResult DependentQualifiedMember(CppLookupResult res);
    public static CppResolveResult FromLookupResult(CppLookupResult res);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Resolve.CppResolveResultUtil : object {
    [ExtensionAttribute]
public static bool IsOverloadingFailureResolveResult(CppResolveResult& rr);
    [ExtensionAttribute]
public static bool ResolveResultIsNotResolved(CppResolveResult& rr);
    [ExtensionAttribute]
public static bool ResolveResultIsFunctions(CppResolveResult& rr);
    [ExtensionAttribute]
public static bool ResolveResultIsProperties(CppResolveResult& rr);
    [ExtensionAttribute]
public static bool ResolveResultIsPropertiesAnyStatus(CppResolveResult& rr);
    [ExtensionAttribute]
public static bool ResolveResultIsIndexedPropertiesAnyStatus(CppResolveResult& rr);
    [ExtensionAttribute]
public static bool ResolveResultIsScalarPropertiesAnyStatus(CppResolveResult& rr);
    [ExtensionAttribute]
public static bool ResolveResultIsOverloadedFunctions(CppResolveResult& res);
    [ExtensionAttribute]
public static bool ResolveResultIsOverloadedProperties(CppResolveResult& res);
    [ExtensionAttribute]
public static bool ResolveResultIsRewrittenOperator(CppResolveResult& rr);
    [ExtensionAttribute]
public static bool ResolveResultIsOkOrRewrittenOperator(CppResolveResult& rr);
    [ExtensionAttribute]
public static ICppResolveEntity GetPrimaryEntityIfStatusIsOk(CppResolveResult& rr);
    [ExtensionAttribute]
public static ICppResolveEntity GetPrimaryEntityIfStatusIsBuiltin(CppResolveResult& rr);
    private static ICppResolveEntity InstantiateFunctionBodyIfNeeded(CppOrdinaryOverloadingCandidate c, ICppFileResolveEntitiesCache cache, CppViewPos& vp);
    public static CppResolveResult FromOverloadResult(CppOverloadingRunInfo info, ICppFileResolveEntitiesCache cache, CppViewPos& vp);
    [ExtensionAttribute]
public static ResolveResultWithInfo WrapResolveResult(CppResolveResult& rr, IPsiServices services);
    public static CppResolveResult FromWrappedResult(ResolveResultWithInfo res);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertIsValid(CppResolveResult& rr, ICppReference reference);
    public static bool ResolveResultsAreEqual(CppResolveResult& lhs, CppResolveResult& rhs);
}
public static class JetBrains.ReSharper.Psi.Cpp.Resolve.CppResolveUtil : object {
    public static CppResolveResult ResolveQualifiedReferenceWithCustomName(QualifiedReference ref, CppQualifiedName name, bool runOverloading);
    public static CppResolveResult ResolveQualifiedReference(QualifiedReference ref);
    public static CppOverloadedFunctionResolveResult ResolveAddressOfOverloadedFunction(ICppExpression from, CppQualType targetType, CppTypeContext& tc);
    public static ICppCompositeNode GetTemplateParameterProviderNodeByTemplateArguments(TemplateArgumentList argList);
    public static IEnumerable`1<ICppResolveEntity> GetResolveEntitiesProvidingTemplateParameters(ICppCompositeNode templateParamProviderNode);
    public static CppResolveResult ResolveScalarPropertyOverloads(CppResolveResult& input, CppViewPos& viewPos);
    public static void ResolveMemberAccessArrowReference(CppTypeAndCategory scopeType, ICppMemberAccessDerefResolveResultConsumer consumer, CppTypeContext& tc);
    public static CppResolveResult ResolveCxxCliOverrideSpecifierTarget(CppQualifiedName name, ICppDeclaratorResolveEntity func, CppTypeContext& tc);
    public static CppResolveResult ResolveCxxCliOverrideSpecifierTarget(CppLookupResult lres, ICppDeclaratorResolveEntity func);
    private static bool IsDependentDerefOperatorResolveResult(CppQualType type);
    private static CppResolveResult ResolveAddressOfOverloadedTemplates(FrugalLocalList`1<ICppResolveEntity> candidates, CppQualType targetT, ICppTemplateArgument[] explicitArgs, CppTypeContext& tc);
    private static ICppResolveEntity FindTemplateFromSubstitution(ICppResolveEntity ent);
    private static IEnumerable`1<ICppResolveEntity> FindTemplatesFromSubstitutions(IEnumerable`1<ICppResolveEntity> entities);
    private static bool HasDifferentLookupParents(FrugalLocalList`1<ICppResolveEntity> candidates, bool allowCliClasses);
    private static CppResolveResult ResolveAddressOfOverloadedFunction(FrugalLocalList`1<ICppResolveEntity> candidates, ICppResolvedQualifiedReferenceExpression from, ICppTemplateArgument[] explicitArgs, CppQualType targetT, CppTypeContext& typeContext);
    private static CppResolveResult ResolveAddressOfOverloadedFunctionImpl(ICppExpression overloadedFuncExpr, CppQualType targetT, CppTypeContext& tc, Boolean& shouldAddPointer);
    private static CppResolveResult FromDefaultCandidates(CppOverloadContextWithCaller cc);
    public static CppLookupResult ResolveOffsetOfMemberDesignator(CppQualType type, CppQualifiedName memberDesignator, CppViewPos& viewPos);
}
internal abstract class JetBrains.ReSharper.Psi.Cpp.Resolve.CppSynthesizedDeductionGuide`1 : CppSynthesizedDeductionGuideBase {
    protected TCtor myCtor;
    private ICppResolvedExpression myRequiresClause;
    protected DropDecorationsVisitor myDropDecorationsVisitor;
    private CppAttributeList myAttributes;
    public ICppResolveEntity StructuralParent { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    protected CppSynthesizedDeductionGuide`1(CppClassTemplateResolveEntityPack classTemplate, ICppClassResolveEntity primaryTemplate, TCtor ctor);
    protected void Init(ICppGroupedFunctionDeclaratorResolveEntity ctorOrPrimaryTemplate);
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual bool CanAcceptInitializerList();
    public virtual SourceKind GetSourceKind();
    public virtual void Dump(CppIndentationStringBuilder tw);
    public virtual ICppResolvedExpression GetResolvedRequiresClause();
    public sealed virtual CppAttributeList GetAttributes();
    private CppQualType GetTypeWithoutDecorations(ICppGroupedFunctionDeclaratorResolveEntity ctor);
    private CppAttributeList DropDecorations(CppAttributeList source);
    private ICppAttribute DropDecorations(ICppAttribute source);
    private ICppAttribute DropDecorations(CppAttributeWithArgument`1<ICppExpression> attr);
    private ICppAttribute DropDecorations(CppAttributeWithArgument`1<ICppTypeIdOrExpression> attr);
}
internal abstract class JetBrains.ReSharper.Psi.Cpp.Resolve.CppSynthesizedDeductionGuideBase : object {
    private CppClassTemplateResolveEntityPack myClassTemplate;
    protected CppQualType myTypeWithoutDecorations;
    public ICppGroupedFunctionDeclaratorResolveEntity Function { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    protected CppSynthesizedDeductionGuideBase(CppClassTemplateResolveEntityPack classTemplate);
    public abstract virtual bool CanBeCalledWithZeroArguments();
    public abstract virtual bool CanAcceptInitializerList();
    public abstract virtual SourceKind GetSourceKind();
    public abstract virtual void Dump(CppIndentationStringBuilder sb);
    public abstract virtual int GetFirstDefaultArgIndex();
    public abstract virtual ICppParameterListResolveEntity GetMainParameterList();
    public virtual bool IsFunctionTemplateParameter(ICppTemplateParameter param);
    public abstract virtual ICppGroupedFunctionDeclaratorResolveEntity get_Function();
    public abstract virtual CppTemplateParametersBase GetParameters();
    public abstract virtual ICppTemplateArgument[] GetDefaults(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual CppQualType GetTemplateType(ICppResolvedTypeFactory tf);
    public abstract virtual CppAttributeList GetAttributes();
    public virtual CppPickFunctionSpecializationResult PickSpecializationInSFINAEContext(CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc, CppSubstitutionContext subst, ICppTemplateFunctionCallDeductionErrorConsumer errorConsumer, ICppResolvedExpression& constraint);
    public virtual TResult Accept(ICppResolveEntityVisitor`1<TResult> visitor);
    public abstract virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public abstract virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public abstract virtual CppLocationAnchor get_LocationAnchor();
    public abstract virtual ICppResolvedExpression GetResolvedRequiresClause();
    protected CppClassTemplateResolveEntityPack GetClassTemplate();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Resolve.CppTemplateDeclaratorResolveEntityBase`2 : CppResolveEntityBase {
    protected CppAnchorIndexedValue`1<ICppTemplateArgument[]> myDefaultTemplateArguments;
    [CanBeNullAttribute]
private ICppImportedDeclaratorResolveEntity mySourceOfDefaults;
    private List`1<TGroupedResolveEntity> mySpecializations;
    public TGroupedResolveEntity PrimaryTemplateDeclaration { get; }
    public IEnumerable`1<TGroupedResolveEntity> Specializations { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    protected CppTemplateDeclaratorResolveEntityBase`2(TGroupedResolveEntity primaryEnt, TResolveEntity primaryEntUngrouped);
    protected CppTemplateDeclaratorResolveEntityBase`2(ICppResolveEntity parent, CppQualifiedNamePart name, CppLocationAnchor anchor);
    private static ICppTemplateArgument[] GetDefaults(ICppDeclaratorResolveEntity ungrouped, CppLocationAnchor anchor);
    private static CppQualifiedNamePart GetDeclModuleName(ICppImportedDeclaratorResolveEntity imported);
    public sealed virtual TGroupedResolveEntity get_PrimaryTemplateDeclaration();
    public virtual IEnumerable`1<TGroupedResolveEntity> get_Specializations();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    internal void InitSpecializations(List`1<TGroupedResolveEntity> specs);
    public virtual CppTemplateParametersBase GetParameters();
    public virtual ICppTemplateArgument[] GetDefaults(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual IEnumerable`1<ICppResolveEntity> GetAllSpecializations();
    public virtual void AddEntity(TResolveEntity ent);
    private void ForceImportOfDefaults();
    public virtual void AddSpecialization(TGroupedResolveEntity specialization);
    public void AddSpecializationWithoutJournaling(TGroupedResolveEntity specialization);
    protected void DumpDefaultTemplateArguments(CppIndentationStringBuilder tw);
    protected void DumpSpecializations(CppIndentationStringBuilder tw);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppTypeTemplateDeclaratorResolveEntity : CppTemplateDeclaratorResolveEntityBase`2<ICppGroupedTypeDeclaratorResolveEntity, ICppTypeDeclaratorResolveEntity> {
    private TriBool myIsDeducible;
    private CppUndeterminedSpecializationResolveEntity myClassRef;
    private CppQualType myClassType;
    public CppTypeTemplateDeclaratorResolveEntity(ICppTypeDeclaratorResolveEntity ent);
    protected CppTypeTemplateDeclaratorResolveEntity(ICppTypeDeclaratorResolveEntity ent, bool isDeducible);
    private CppTypeTemplateDeclaratorResolveEntity(ICppTypeDeclaratorResolveEntity ent, TriBool isDeducible);
    protected CppTypeTemplateDeclaratorResolveEntity(ICppResolveEntity parent, CppQualifiedNamePart name, CppLocationAnchor anchor);
    public virtual bool IsDeducibleTemplate();
    public virtual CppList`1<ICppDeductionGuide> GetDeductionGuides(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    public sealed virtual CppClassTemplateResolveEntityPack GetClassPack();
    public virtual ICppDeductionGuide GetAggregateDeductionGuide(ICppExpression[] args, CppArgumentListKind kind, CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc);
    public virtual CppQualType FinalizeDeduction(CppQualType qtype, CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc);
    public virtual bool IsDeducibleTemplateChildEntity(ICppResolveEntity entity);
    public virtual CppQualType InstantiateTemplateDeclarator(CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc, ICppTemplateArgument[] args, bool forDeduce, CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity source, bool decorateReturnType);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
private void CheckNoRedundantWrapping(CppQualType type);
    private bool IsInstantiatedTemplateAliasType(CppQualType type);
    private bool IsOurInstantiation(CppQualType instantiatedType);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual string ToString();
    private void DetectDeducible();
    private ICppDeductionGuide WrapDeductionGuide(ICppDeductionGuide guide, CppTypeContext& tc);
    private CppTemplateArgumentDeductionResult DeduceArguments(CppQualType rtype, CppTypeContext& tc);
    private CppQualType SubstituteValueType(CppSubstitutionContext subst, CppTypeContext& tc);
    private CppQualType GetDependentType(ICppTemplateArgument[] args, CppTypeContext& tc, CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity source);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppTypeTemplateDeclaratorResolveEntityWithSubstitution : CppTypeTemplateDeclaratorResolveEntity {
    private ICppTypeTemplateDeclaratorResolveEntity myInner;
    public CppTypeTemplateDeclaratorResolveEntityWithSubstitution(ICppScopeResolveEntity parent, CppQualifiedNamePart name, ICppTypeTemplateDeclaratorResolveEntity inner, CppSubstitutionDriver driver);
    public ICppTypeTemplateDeclaratorResolveEntity GetInner();
    public virtual string ToString();
    public static List`1<ICppGroupedTypeDeclaratorResolveEntity> SubstituteSpecializations(CppTypeTemplateDeclaratorResolveEntityWithSubstitution that, CppSubstitutionDriver driver);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppVariableTemplateDeclaratorResolveEntity : CppTemplateDeclaratorResolveEntityBase`2<ICppGroupedVariableDeclaratorResolveEntity, ICppVariableDeclaratorResolveEntity> {
    private ConcurrentDictionary`2<ICppTemplateArgument[], ICppGroupedVariableDeclaratorResolveEntity> mySubstCache;
    public CppVariableTemplateDeclaratorResolveEntity(ICppVariableDeclaratorResolveEntity primaryTemplate);
    protected CppVariableTemplateDeclaratorResolveEntity(ICppResolveEntity parent, CppQualifiedNamePart name, CppLocationAnchor anchor);
    public virtual ICppResolveEntity InstantiateTemplate(ReadOnlySpan`1<ICppTemplateArgument> args, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public ICppResolveEntity InstantiateTemplateWithSanitizedArgs(ICppTemplateArgument[] sanitizedArgs, CppViewPos& vp);
    public virtual TResult Accept(ICppResolveEntityVisitor`1<TResult> visitor);
    public virtual string ToString();
    private static ICppResolveEntity PickAndSubstituteVariableSpecialization(ICppVariableTemplateDeclaratorResolveEntity that, ICppTemplateArgument[] args, CppViewPos& vp);
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.CppVariableTemplateDeclaratorResolveEntityWithSubstitution : CppVariableTemplateDeclaratorResolveEntity {
    private ICppVariableTemplateDeclaratorResolveEntity myInner;
    public CppVariableTemplateDeclaratorResolveEntityWithSubstitution(ICppResolveEntity parent, CppQualifiedNamePart name, ICppVariableTemplateDeclaratorResolveEntity inner, CppViewPos& viewPos, ICppSubstitutionContext subst, int specCount);
    public ICppVariableTemplateDeclaratorResolveEntity GetInner();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Cpp.Resolve.DependentDecltypeWrapper : DependentResolveEntity {
    public DependentDecltypeWrapper(CppUndeterminedSpecializationResolveEntity primaryTemplate, CppDependentDecltypeResolveEntity inner);
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver driver);
}
internal class JetBrains.ReSharper.Psi.Cpp.Resolve.DependentHead : object {
    private ICppClassResolveEntity myPrimaryTemplate;
    private CppUndeterminedSpecializationResolveEntity myPrimaryTemplateReplacement;
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppDependentInfo DependentInfo { get; }
    public DependentHead(ICppClassResolveEntity primaryTemplate, CppUndeterminedSpecializationResolveEntity primaryTemplateReplacement);
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual TResult Accept(ICppResolveEntityVisitor`1<TResult> visitor);
    public sealed virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public sealed virtual CppDependentInfo get_DependentInfo();
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    private CppQualType DoSubstitutionGetType(CppSubstitutionDriver driver);
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
internal class JetBrains.ReSharper.Psi.Cpp.Resolve.DependentResolveEntity : object {
    protected CppUndeterminedSpecializationResolveEntity myPrimaryTemplate;
    protected ICppResolveEntity myInner;
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppDependentInfo DependentInfo { get; }
    public DependentResolveEntity(CppUndeterminedSpecializationResolveEntity primaryTemplate, ICppResolveEntity inner);
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual TResult Accept(ICppResolveEntityVisitor`1<TResult> visitor);
    public virtual CppLookupResult DoSubstitutionGetLookupResult(CppSubstitutionDriver driver);
    public virtual ICppTemplateArgument DoSubstitutionGetTemplateArgument(CppSubstitutionDriver driver);
    public virtual FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public virtual CppDependentInfo get_DependentInfo();
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver driver);
    protected bool HeadSubstitutedToPrimaryTemplate(CppSubstitutionDriver driver);
    [CanBeNullAttribute]
public static CppClassResolveEntityWithSubstitution SubstitutePrimaryTemplateAndCheck(CppUndeterminedSpecializationResolveEntity primaryTemplateReplacement, CppSubstitutionDriver driver);
}
internal class JetBrains.ReSharper.Psi.Cpp.Resolve.DependentTypeTemplateResolveEntity : DependentResolveEntity {
    public DependentTypeTemplateResolveEntity(CppUndeterminedSpecializationResolveEntity primaryTemplate, ICppTypeTemplateResolveEntity inner);
    public sealed virtual CppTemplateParametersBase GetParameters();
    public ICppTemplateArgument[] GetDefaults(CppViewPos& vp);
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetAllSpecializations();
    private sealed virtual override ICppTemplateArgument[] JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateResolveEntityBase.GetDefaults(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
}
internal class JetBrains.ReSharper.Psi.Cpp.Resolve.DropDecorationsVisitor : CppIdentityTypeVisitorWithResolvedOutput {
    private ICppClassResolveEntity myPrimaryTemplate;
    [CanBeNullAttribute]
private ExpressionVisitor myExpressionVisitor;
    [CanBeNullAttribute]
private DependentHead myDependentHead;
    private CppUndeterminedSpecializationResolveEntity myPrimaryTemplateReplacement;
    private Dictionary`2<ICppTemplateParameter, ICppTemplateParameter> myTemplateParameterReplacement;
    public DropDecorationsVisitor(CppClassTemplateResolveEntityPack classTemplate, ICppClassResolveEntity primaryTemplate, ICppResolvedTypeFactory tf);
    public CppViewPos GetViewPos();
    internal void Add(ICppTemplateParameter param, ICppTemplateParameter replacement);
    public sealed virtual ICppTemplateArgument Visit(CppMonostate m, CppQualifiedReferenceTemplateArgument arg);
    public sealed virtual ICppTemplateArgument Visit(CppMonostate m, CppQualType type);
    public sealed virtual ICppTemplateArgument Visit(CppMonostate m, CppTypeTemplateArgument typeArg);
    public sealed virtual ICppTemplateArgument Visit(CppMonostate m, CppTypeTemplateArgumentPack arg);
    public sealed virtual ICppTemplateArgument Visit(CppMonostate m, CppExpressionTemplateArgument arg);
    public sealed virtual ICppTemplateArgument Visit(CppMonostate m, CppExpressionTemplateArgumentPack arg);
    public sealed virtual ICppTemplateArgument Visit(CppMonostate m, CppTemplateTemplateArgument arg);
    public sealed virtual ICppTemplateArgument Visit(CppMonostate m, CppTemplateTemplateArgumentPack arg);
    public sealed virtual ICppTemplateArgument Visit(CppMonostate m, CppDependentTemplateArgument arg);
    public sealed virtual ICppTemplateArgument Visit(CppMonostate m, CppLookupFailureTemplateArgument arg);
    public sealed virtual ICppTemplateArgument Visit(CppMonostate m, CppInjectedClassNameTemplateArgument arg);
    public sealed virtual ICppTemplateArgument Visit(CppMonostate m, CppExcessiveTemplateArgument arg);
    public virtual CppQualType Visit(CppResolvedClassType clazz, Qualifiers quals);
    public virtual CppQualType Visit(CppResolvedEnumType enum_, Qualifiers quals);
    public virtual CppQualType Visit(CppTemplateParameterType e, Qualifiers quals);
    public virtual CppQualType Visit(CppDependentType type, Qualifiers quals);
    public virtual CppQualType Visit(CppDependentInstantiatedTemplateAliasType type, Qualifiers quals);
    public virtual CppQualType Visit(CppTypedefType type, Qualifiers quals);
    public virtual CppQualType Visit(CppInstantiatedTemplateAliasType type, Qualifiers quals);
    public virtual CppQualType Visit(CppNameSuggestionType type, Qualifiers quals);
    protected virtual ICppExpression VisitArraySize(ICppExpression arraySize, Boolean& changed);
    protected virtual ICppExpression VisitVectorSize(ICppExpression size, Boolean& changed);
    protected virtual ICppExpression VisitCliArrayRank(ICppExpression arrayRank, Boolean& changed);
    protected virtual ICppNoExceptSpecification VisitNoExceptSpecification(ICppNoExceptSpecification noexcept);
    private CppQualType AddDependencyOnPrimaryTemplate(CppTypeWithClassResolveEntity type, Qualifiers quals);
    private bool IsChildOfPrimaryTemplate(ICppResolveEntity clazz);
    [CanBeNullAttribute]
private ICppDependentTypeResolveEntity AddDependencyOnPrimaryTemplate(CppUndeterminedSpecializationResolveEntity undeterminedSpecialization);
    [CanBeNullAttribute]
private ICppResolveEntity AddDependencyOnPrimaryTemplate(CppDependentResolveEntity depEnt);
    private ICppDependentTypeResolveEntity VisitDependentDecltype(CppDependentDecltypeResolveEntity dependentDecltype);
    [CanBeNullAttribute]
private ICppDependentTypeResolveEntity AddDependencyOnPrimaryTemplate(ICppDependentTypeResolveEntity resolveEntity);
    [CanBeNullAttribute]
private ICppTypeTemplateResolveEntity AddDependencyOnPrimaryTemplate(ICppTypeTemplateResolveEntity typeTemplate);
    [CanBeNullAttribute]
private ICppTemplateArgument[] VisitTemplateArguments(ICppTemplateArgument[] args);
    public ICppTemplateArgument ReApply(ICppTemplateArgument a);
    public ExpressionVisitor GetExpressionVisitor();
    private DependentHead GetDependentHead();
}
internal class JetBrains.ReSharper.Psi.Cpp.Resolve.ExpressionTemplateParameter : ExpressionTemplateParameterBase {
    public bool IsParameterPack { get; }
    public ExpressionTemplateParameter(ICppExpressionTemplateParameter original, DropDecorationsVisitor dropDecorationsVisitor);
    public virtual TResult Accept(ICppResolveEntityVisitor`1<TResult> visitor);
    public virtual bool get_IsParameterPack();
    public virtual ICppResolvedExpression DoExpressionTemplateParameterSubstitution(CppSubstitutionDriver driver);
}
internal abstract class JetBrains.ReSharper.Psi.Cpp.Resolve.ExpressionTemplateParameterBase : CppExpressionTemplateParameterBase {
    private ICppExpressionTemplateParameterOrPack myOriginal;
    private DropDecorationsVisitor myDropDecorationsVisitor;
    public CppQualifiedNamePart Name { get; }
    protected ExpressionTemplateParameterBase(ICppExpressionTemplateParameterOrPack original, DropDecorationsVisitor dropDecorationsVisitor);
    public virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
    public virtual CppQualifiedNamePart get_Name();
    public virtual ICppFileResolveEntitiesCache GetResolveCache();
}
internal class JetBrains.ReSharper.Psi.Cpp.Resolve.ExpressionTemplateParameterPack : ExpressionTemplateParameterBase {
    public bool IsParameterPack { get; }
    public ExpressionTemplateParameterPack(ICppExpressionTemplateParameterPack original, DropDecorationsVisitor dropDecorationsVisitor);
    public virtual TResult Accept(ICppResolveEntityVisitor`1<TResult> visitor);
    public virtual bool get_IsParameterPack();
    public virtual ICppResolvedExpression DoExpressionTemplateParameterSubstitution(CppSubstitutionDriver driver);
    public sealed virtual ICppTemplateArgumentPack CreateEmptyMatchingArgumentPack();
}
public class JetBrains.ReSharper.Psi.Cpp.Resolve.HlslBuiltinSwizzleResolveEntity : AbstractBuiltinResolveEntity {
    private CppQualifiedNamePart myName;
    public CppQualifiedNamePart Name { get; }
    public HlslBuiltinSwizzleResolveEntity(CppQualType type, CppQualifiedId id);
    public virtual CppQualifiedNamePart get_Name();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory tf);
    public virtual CppDependentInfo GetDependentInfo();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppCxxCliPropertyDeclaratorResolveEntity {
    public bool IsEvent { get; }
    public abstract virtual bool get_IsEvent();
    public abstract virtual CppQualType[] GetResolvedIndexTypes();
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppCxxCliPropertySetResolveEntity {
    public IEnumerable`1<ICppCxxCliPropertyDeclaratorResolveEntity> Items { get; }
    public abstract virtual IEnumerable`1<ICppCxxCliPropertyDeclaratorResolveEntity> get_Items();
    public abstract virtual ICppScopeResolveEntity GetParentScope();
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppDeductionGuide {
    public abstract virtual SourceKind GetSourceKind();
    public abstract virtual bool CanBeCalledWithZeroArguments();
    public abstract virtual bool CanAcceptInitializerList();
    public abstract virtual void Dump(CppIndentationStringBuilder tw);
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppFunctionOrFunctionTemplateLikeDeducibleResolveEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppFunctionOrTemplateDeclaratorResolveEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppFunctionTemplateDeclaratorResolveEntity {
    public abstract virtual void Dump(CppIndentationStringBuilder builder);
    public abstract virtual CppDependentInfo GetDependentInfo();
    public abstract virtual CppPickFunctionSpecializationResult PickSpecialization(CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc, CppSubstitutionContext subst);
    public abstract virtual CppPickFunctionSpecializationResult PickCachedSpecialization(CppSubstitutionContext sc);
    public abstract virtual IList`1<ICppGroupedFunctionDeclaratorResolveEntity> GetCachedSpecializations();
    public abstract virtual ICppTemplateArgument[] FindSubstitutionTemplateArguments(ICppFunctionDeclaratorResolveEntity substituted);
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppFunctionTemplateLikeDeducibleResolveEntity {
    public abstract virtual CppQualType GetTemplateType(ICppResolvedTypeFactory tf);
    public abstract virtual CppPickFunctionSpecializationResult PickSpecializationInSFINAEContext(CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc, CppSubstitutionContext subst, ICppTemplateFunctionCallDeductionErrorConsumer consumer, ICppResolvedExpression& constraint);
    public abstract virtual ICppParameterListResolveEntity GetMainParameterList();
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppGroupedDeclaratorResolveEntity {
    public abstract virtual bool Contains(ICppDeclaratorResolveEntity d);
    public abstract virtual CppDependentInfo GetDependentInfo();
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppGroupedFunctionDeclaratorResolveEntity {
    [CanBeNullAttribute]
public abstract virtual ICppFunctionTemplateDeclaratorResolveEntity GetTemplateDeclaration();
    public abstract virtual bool InstantiateFunctionBody(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp, bool forceChameleonInstantiation);
    public abstract virtual ICppFunctionOrVariableDeclaratorResolveEntity GetFirstUngrouped();
    public abstract virtual ICppFunctionDeclaratorResolveEntity GetUngroupedThatProvidingBody();
    public abstract virtual CppList`1<ICppFunctionOrVariableDeclaratorResolveEntity> GetUngroupedDeclarators();
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppGroupedTypeDeclaratorResolveEntity {
    public abstract virtual ICppTypeTemplateDeclaratorResolveEntity GetTemplateDeclaration();
    public abstract virtual CppSmallList`1<ICppTypeDeclaratorResolveEntity> GetUngroupedDeclarators();
    public abstract virtual ICppTypeDeclaratorResolveEntity GetAnyUngrouped();
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppGroupedVariableDeclaratorResolveEntity {
    public abstract virtual ICppVariableTemplateDeclaratorResolveEntity GetTemplateDeclaration();
    public abstract virtual CppSmallList`1<ICppVariableDeclaratorResolveEntity> GetUngroupedDeclarators();
    public abstract virtual ICppVariableDeclaratorResolveEntity GetAnyUngrouped();
    [CanBeNullAttribute]
public abstract virtual ICppEvaluationResult GetValue(CppEvaluationParams evalParams, ICppEvaluationErrorTracker errorTracker);
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppMemberAccessDerefResolveResultConsumer {
    public abstract virtual void LearnCircularDereference(CppQualType type);
    public abstract virtual void LearnBadTargetType(CppQualType type);
    public abstract virtual void LearnFailedOverloading(CppQualType type, CppOverloadingRunInfo overload);
    public abstract virtual void LearnIterationLimitExceeded(CppQualType lastType);
    public abstract virtual void LearnNextOperator(CppQualType type, ICppGroupedFunctionDeclaratorResolveEntity arrowFunc);
    public abstract virtual void LearnResultPointerType(CppQualType type);
    public abstract virtual void LearnGenericType(CppTypeAndCategory type);
    public abstract virtual void LearnDependentType(CppTypeAndCategory type);
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppMutableFunctionTemplateDeclaratorResolveEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppMutableGroupedDeclaratorResolveEntity`1 {
    public abstract virtual void AddEntity(TDeclarator d);
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppMutableTemplateDeclaratorResolveEntity`2 {
    public abstract virtual void AddSpecialization(TInnerEntity decl);
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppMutableTypeTemplateDeclaratorResolveEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppMutableVariableTemplateDeclaratorResolveEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppSubstitutedFromTemplateDeductionGuide {
    public abstract virtual ICppTemplateDeductionGuide GetTemplateDeductionGuide();
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppTemplateDeclaratorResolveEntity`1 {
    public TInnerEntity PrimaryTemplateDeclaration { get; }
    public IEnumerable`1<TInnerEntity> Specializations { get; }
    public abstract virtual TInnerEntity get_PrimaryTemplateDeclaration();
    public abstract virtual IEnumerable`1<TInnerEntity> get_Specializations();
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppTemplateDeductionGuide {
    [CanBeNullAttribute]
public ICppGroupedFunctionDeclaratorResolveEntity Function { get; }
    public abstract virtual int GetFirstDefaultArgIndex();
    public abstract virtual CppAttributeList GetAttributes();
    public abstract virtual ICppResolvedExpression GetResolvedRequiresClause();
    public abstract virtual bool IsFunctionTemplateParameter(ICppTemplateParameter p);
    public abstract virtual ICppGroupedFunctionDeclaratorResolveEntity get_Function();
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppTypeTemplateDeclaratorResolveEntity {
    public abstract virtual CppQualType InstantiateTemplateDeclarator(CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc, ICppTemplateArgument[] args, bool forDeduce, CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity source, bool decorateReturnType);
}
public interface JetBrains.ReSharper.Psi.Cpp.Resolve.ICppVariableTemplateDeclaratorResolveEntity {
    public abstract virtual ICppResolveEntity InstantiateTemplate(ReadOnlySpan`1<ICppTemplateArgument> args, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Resolve.KeyType : ValueType {
    private CppQualType myType;
    private ICppResolvedExpression myRequiresClause;
    [CanBeNullAttribute]
private string myOwningModule;
    private bool myIgnoresFunctionReturnType;
    public KeyType(CppQualType type, bool ignoreFunctionReturnType, string owningModule, ICppResolvedExpression requiresClause);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(KeyType rhs);
}
public class JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons : object {
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string __interface_Text { get; }
    public static string Always_Description_Text { get; }
    public static string Buffer_Text { get; }
    public static string CExternalModule_Text { get; }
    public static string Class_Text { get; }
    public static string Resource_Text { get; }
    public static string ClassDefinition_Text { get; }
    public static string ClassField_Text { get; }
    public static string ClassTemplate_Text { get; }
    public static string CommentIdentifier_Text { get; }
    public static string ComparisonUtil_AfterRewriting_Text { get; }
    public static string ComparisonUtil_AmbiguousCallWithCandidates_Text { get; }
    public static string ComparisonUtil_CannotBeAnOperatorTemplate_Text { get; }
    public static string ComparisonUtil_CannotBeStaticMemberFunction_Text { get; }
    public static string ComparisonUtil_CannotBeVolatileQualified_Text { get; }
    public static string ComparisonUtil_CannotConvertReturnTypeToType_Text { get; }
    public static string ComparisonUtil_CannotConvertValueTheReturnType_Text { get; }
    public static string ComparisonUtil_CannotFindComparisonCategoryType_Text { get; }
    public static string ComparisonUtil_CannotHaveTheRefQualifier_Text { get; }
    public static string ComparisonUtil_DeducedReturnTypeMustBeAuto_Text { get; }
    public static string ComparisonUtil_FormatWithDeletionReason_Text { get; }
    public static string ComparisonUtil_FuncIsDeleted_Text { get; }
    public static string ComparisonUtil_FuncIsNotAccessible_Text { get; }
    public static string ComparisonUtil_MustBeConstQualified_Text { get; }
    public static string ComparisonUtil_MustBeDeclaredAsFriendOf_Text { get; }
    public static string ComparisonUtil_MustHaveAParameterOfClassType_Text { get; }
    public static string ComparisonUtil_MustHaveASingleParameterOfType_Text { get; }
    public static string ComparisonUtil_MustHaveTwoParametersOfSpecificTypes_Text { get; }
    public static string ComparisonUtil_NotSupportedInTheCurrentLanguageDialect_Text { get; }
    public static string ComparisonUtil_NoViableCandidates_Text { get; }
    public static string ComparisonUtil_OperatorIsNotAComparisonOperator_Text { get; }
    public static string ComparisonUtil_ReturnTypeIsNotComparisonCategory_Text { get; }
    public static string ComparisonUtil_ReturnTypeMustBeBool_Text { get; }
    public static string ComparisonUtil_SelectedCandidateIsNotRewritten_Text { get; }
    public static string ComparisonUtil_TypeContainsVariantMembers_Text { get; }
    public static string ComparisonUtil_TypeIsReference_Text { get; }
    public static string ComparisonUtil_WhileComparingArrayField_Text { get; }
    public static string ComparisonUtil_WhileComparingBase_Text { get; }
    public static string ComparisonUtil_WhileComparingField_Text { get; }
    public static string ComparisonUtil_WhileComparingParameters_Text { get; }
    public static string ComparisonUtil_WhileComparingWithZero_Text { get; }
    public static string CompoundStatement_Text { get; }
    public static string Concept_Text { get; }
    public static string Constructor_Text { get; }
    public static string Conversion_Text { get; }
    public static string ConversionOperator_Text { get; }
    public static string CppStandardLibrary_Text { get; }
    public static string CStandardLibrary_Text { get; }
    public static string DeclaredElement_From_Text { get; }
    public static string DeclaredElement_In_Text { get; }
    public static string DeclaredElement_InBrackets_Text { get; }
    public static string DeductionGuide_Text { get; }
    public static string DependentName_Text { get; }
    public static string Destructor_Text { get; }
    public static string DuringInitialIndexing_Description_Text { get; }
    public static string Enum_Text { get; }
    public static string EnumClass_Text { get; }
    public static string EnumStruct_Text { get; }
    public static string EnumDefinition_Text { get; }
    public static string Enumerator_Text { get; }
    public static string Event_Text { get; }
    public static string Field_Text { get; }
    public static string Function_Text { get; }
    public static string GenericParameter_Text { get; }
    public static string GlobalNamespace_Text { get; }
    public static string GlobalVariable_Text { get; }
    public static string GlslFile_Text { get; }
    public static string HeaderFile_Text { get; }
    public static string HlslFile_Text { get; }
    public static string IncludesCache_SerializationObject_Text { get; }
    public static string IndexingSymbols_Text { get; }
    public static string InitializingSymbolCache_Text { get; }
    public static string Interface_Text { get; }
    public static string Loading__Text { get; }
    public static string LocalVariable_Text { get; }
    public static string Macro_Text { get; }
    public static string PredefinedMacro_Text { get; }
    public static string UEReflectionMacro_Text { get; }
    public static string MacroParameter_Text { get; }
    public static string Member_Text { get; }
    public static string Method_Text { get; }
    public static string Module_Text { get; }
    public static string ModulePartition_Text { get; }
    public static string Namespace_Text { get; }
    public static string NamespaceAlias_Text { get; }
    public static string Never_Description_Text { get; }
    public static string NonTypeTemplateArgument_Text { get; }
    public static string NonTypeTemplateParameter_Text { get; }
    public static string Operator_Text { get; }
    public static string Parameter_Text { get; }
    public static string ParameterList_Text { get; }
    public static string PreparingWordIndex_Text { get; }
    public static string PresenterUtil_AnonymousFormat_Text { get; }
    public static string PresenterUtil_BracedInitList_Text { get; }
    public static string PresenterUtil_Builtin_Text { get; }
    public static string PresenterUtil_EntityKindFormat_Text { get; }
    public static string PresenterUtil_FunctionOverloadSet_Text { get; }
    public static string PresenterUtil_GeneratedByUHT_Text { get; }
    public static string PresenterUtil_ImplicitlyGenerated_Text { get; }
    public static string PresenterUtil_Inherited_Text { get; }
    public static string PresenterUtil_Intrinsic_Text { get; }
    public static string PrivateField_Text { get; }
    public static string PrivateMethod_Text { get; }
    public static string ProcessingChangedFiles_Text { get; }
    public static string Property_Text { get; }
    public static string ProtectedField_Text { get; }
    public static string ProtectedMethod_Text { get; }
    public static string PublicField_Text { get; }
    public static string PublicMethod_Text { get; }
    public static string RequiresExpressionClause_Text { get; }
    public static string Saving__Text { get; }
    public static string Something_In_Container_Text { get; }
    public static string SourceFile_Text { get; }
    public static string Struct_Text { get; }
    public static string StructDefinition_Text { get; }
    public static string StructField_Text { get; }
    public static string StructuredBindingUtil_BaseIsAmbiguous_Text { get; }
    public static string StructuredBindingUtil_BothHavePublicDataMembers_Text { get; }
    public static string StructuredBindingUtil_HasAnonymousUnionOrClassMembers_Text { get; }
    public static string StructuredBindingUtil_IsNotAccessible_Text { get; }
    public static string StructuredBindingUtil_TypeIsNotComplete_Text { get; }
    public static string SymbolCache_SerializationObject_Text { get; }
    public static string Symbols_SerializationObject_Text { get; }
    public static string SyntaxError_Text { get; }
    public static string TemplateArgument_Text { get; }
    public static string TemplateParameter_Text { get; }
    public static string TemplateTemplateArgument_Text { get; }
    public static string TemplateTemplateParameter_Text { get; }
    public static string TypeAlias_Text { get; }
    public static string Typedef_Text { get; }
    public static string TypeTemplateArgument_Text { get; }
    public static string TypeTemplateParameter_Text { get; }
    public static string Union_Text { get; }
    public static string UnionDefinition_Text { get; }
    public static string UnionMember_Text { get; }
    public static string UsingDeclaration_Text { get; }
    public static string Linkage_SearchingForAllBasesOf_Text { get; }
    public static string Linkage_Processing_Text { get; }
    public static string Linkage_GetSymbolsForDerivedEntities_Text { get; }
    public static string Linkage_ProcessingSymbols_Text { get; }
    public static string Linkage_SearchingLinkageEntities_Text { get; }
    public static string WordsCache_SerializationObject_Text { get; }
    public static string Parser_Error_ExpectedLBrace_Text { get; }
    public static string Parser_Error_ExpectedCatch_Text { get; }
    public static string Parser_Error_ExpectedTypeId_Text { get; }
    public static string Parser_Error_ExpectedConversionId_Text { get; }
    public static string Parser_Error_ExpectedParameterDeclaration_Text { get; }
    public static string Parser_Error_ExpectedCondition_Text { get; }
    public static string Parser_Error_ExpectedSecondArgumentOfForLoop_Text { get; }
    public static string Parser_Error_ExpectedCliProperty_Text { get; }
    public static string Parser_Error_ExpectedCliEvent_Text { get; }
    public static string Parser_Error_ExpectedCliPropertyAccessor_Text { get; }
    public static string Parser_Error_ExpectedCliDelegate_Text { get; }
    public static string Parser_Error_ExpectedCliConstraintTypeId_Text { get; }
    public static string Parser_Error_ExpectedDeclaration_Text { get; }
    public static string InvalidParenthesisSequence_Text { get; }
    public static string Parser_Error_ExpectedSemicolon_Text { get; }
    public static string Parser_Error_ExpectedStringLiteral_Text { get; }
    public static string Parser_Error_ExceptionInParser_Text { get; }
    public static string Parser_Error_ExpectedIdentifier_Text { get; }
    public static string Parser_Error_ExpectedAClassName_Text { get; }
    public static string Parser_Error_ExpectedAClassDeclaration_Text { get; }
    public static string Parser_Error_ExpectedRBrace_Text { get; }
    public static string Parser_Error_ExpectedEq_Text { get; }
    public static string Parser_Error_MustBeATypeConcept_Text { get; }
    public static string Parser_Error_ExpectedModuleName_Text { get; }
    public static string Parser_Error_ExpectedNewline_Text { get; }
    public static string Parser_Error_ExpectedPrivate_Text { get; }
    public static string Parser_Error_ExpectedDefaultOrDelete_Text { get; }
    public static string Parser_Error_ExpectedType_Text { get; }
    public static string Parser_Error_ExpectedDeclarator_Text { get; }
    public static string Parser_Error_ExpectedComma_Text { get; }
    public static string Parser_Error_ExpectedDeclaratorName_Text { get; }
    public static string Parser_Error_ExpectedColon_Text { get; }
    public static string Parser_Error_ExpectedRegisterKeywordOrSemantic_Text { get; }
    public static string Parser_Error_UnexpectedTemplate_Text { get; }
    public static string Parser_Error_ExpectedKeyword_Text { get; }
    public static string Parser_Error_ExpectedEqOrColon_Text { get; }
    public static string Parser_Error_ExpectedThis_Text { get; }
    public static string Parser_Error_ExpectedLambdaCapture_Text { get; }
    public static string Parser_Error_AutoIsNotAllowedInALambdaCapture_Text { get; }
    public static string Parser_Error_ExpectedLPar_Text { get; }
    public static string Parser_Error_ExpectedIn_Text { get; }
    public static string Parser_Error_ExpectedLParOrLBrace_Text { get; }
    public static string Parser_Error_ExpectedExpression_Text { get; }
    public static string Parser_Error_ExpectedRPar_Text { get; }
    public static string Parser_Error_ExpectedAuto_Text { get; }
    public static string Parser_Error_ExpectedRBracket_Text { get; }
    public static string Parser_Error_ExpectedWhile_Text { get; }
    public static string Parser_Error_ExpectedSemicolonOrColon_Text { get; }
    public static string Parser_Error_ExpectedSemanticIdentifier_Text { get; }
    public static string Parser_Error_ExpectedLabelIdentifier_Text { get; }
    public static string Parser_Error_ExpectedLt_Text { get; }
    public static string Parser_Error_ExpectedGt_Text { get; }
    public static string Parser_Error_ExpectedNumericLiteral_Text { get; }
    public static string Parser_Error_ExpectedAfterIf_Text { get; }
    public static string Parser_Error_ExpectedAfterDeclaration_Text { get; }
    public static string Parser_Error_RestrictionSpecifierCannotBeEmpty_Text { get; }
    public static string Parser_Error_ParensCannotBeUsedInIfConsteval_Text { get; }
    public static string Parser_Error_QualifiersAreNotAllowedAtTopLevelAsm_Text { get; }
    public static string Parser_Error_ExpectedAfterWhile_Text { get; }
    public static string Parser_Error_ExpectedClassOrStruct_Text { get; }
    public static string Parser_Error_ExpectedGetOrPut_Text { get; }
    public static string Parser_Error_TheAttributeUsingPrefixIsNotCompatible_Text { get; }
    public static string Parser_Error_QualifiersAreNotAllowedInGNUStyleAttribute_Text { get; }
    public static string Parser_Error_Expected__exceptOr__finally_Text { get; }
    public static string Parser_Error_ExpectedMacroParameter_Text { get; }
    public static string Parser_Error_ExpectedCommaOrRPar_Text { get; }
    public static string Parser_Error_ExpectedStatement_Text { get; }
    public static string Parser_Error_TemplateInCompoundStatement_Text { get; }
    public static string Parser_Error_TemplateTemplateParameterRequiresClass_Text { get; }
    public static string Parser_Error_ExpectedClassOrTypenameKeyword_Text { get; }
    public static string Parser_Error_ConceptMustBeATemplate_Text { get; }
    public static string Parser_Error_ConceptsAreOnlyAllowedAtNamespaceLevel_Text { get; }
    public static string Parser_Error_SuperfluousSemicolon_Text { get; }
    public static string CommonLanguageRunTimeIsSupportedInFileButSystem_Text { get; }
    public static string CommonLanguageRunTimeIsSupportedInFileButSystemString_Text { get; }
    public static string CommonLanguageRunTimeIsSupportedInFileButSystemObject_Text { get; }
    public static string CommonLanguageRunTimeIsSupportedInFileButSystemValueType_Text { get; }
    public static string CommonLanguageRunTimeIsSupportedInFileButSystemIDisposable_Text { get; }
    public static string CommonLanguageRunTimeIsSupportedInFileButSystemEnum_Text { get; }
    public static string CommonLanguageRunTimeIsSupportedInFileButSystemArray_Text { get; }
    public static string CommonLanguageRunTimeIsSupportedInFileButSystemVoid_Text { get; }
    public static string CommonLanguageRunTimeIsSupportedInFileButSystemIEnumerable_Text { get; }
    public static string Parser_Error_ExpectedSpecifierKey_Text { get; }
    public static string Parser_Error_ExpectedSpecifierValue_Text { get; }
    public static string Parser_Error_ExpectedMetaKey_Text { get; }
    public static string Parser_Error_ExpectedMetaValue_Text { get; }
    public static string Parser_Error_ExpectedRefOrValue_Text { get; }
    public static string Parser_Error_ExpectedEqOrLBrace_Text { get; }
    public static string Parser_Error_ExpectedAGenericParameter_Text { get; }
    public static string Parser_Error_ExpectedRBracketRBracket_Text { get; }
    public static string Parser_Error_ExpectedRParRPar_Text { get; }
    public static string Parser_Error_AnAttributeSpecifierSequenceIsNotAllowed_Text { get; }
    public static string Parser_Error_KeywordTypenameShouldBeFollowedByQualified_Text { get; }
    public static string Parser_Error_QualifierCanBeUsedOnlyAfter_Text { get; }
    public static string Parser_Error_UnexpectedIdentifier_Text { get; }
    public static string Parser_Error_ExpectedCommaOrRBracket_Text { get; }
    public static string Parser_Error_UnknownRestrictionSpecifier__Text { get; }
    public static string Parser_Error_AnAttributeSpecifierSequenceIsNotAllowedHere_Text { get; }
    public static string Parser_Error_ExpectedCommaOrRBrace_Text { get; }
    public static string Parser_Error_ExpectedCommaLBraceOrSemicolon_Text { get; }
    public static string Parser_Error_InvalidCombinationOfAccessibilitySpecifiers_Text { get; }
    public static string Parser_Error_ExpectedCommaOrSemicolon_Text { get; }
    public static string Parser_Error_ExpectedCommaOrLBrace_Text { get; }
    public static string Parser_Error_ExpectedCommaOrRParen_Text { get; }
    public static string Parser_Error_UnexpectedToken_Text { get; }
    public static string Parser_Error_UnexpectedCharLiteral_Text { get; }
    public static string Parser_Error_UnexpectedNumericLiteral_Text { get; }
    public static string Parser_Error_ExpectedConstantExpression_Text { get; }
    public static string Parser_Error_UnknownDeclspec__Text { get; }
    public static string Parser_Error_AnAttributeSpecifierSequenceIsNotAllowedAfterMSAttribute_Text { get; }
    public static string Parser_Error__IsNotAFoldableOperator_Text { get; }
    public static string Parser_Error_ExpectedAFoldableBinaryOperator_Text { get; }
    public static string Parser_Error_ExpectedOperator_Text { get; }
    public static string Parser_Error_ExpectedCommaOrGt_Text { get; }
    public static string Parser_Error_StatementExpressionMayOnlyBeUsedInside_Text { get; }
    public static string Parser_Error_UnexpectedCvQualifier_Text { get; }
    public static string Parser_Error_ExpectedACallAfterThe__raiseKeyword_Text { get; }
    public static string Parser_Error_ExpectedGtGtGt_Text { get; }
    public static string Parser_Error_KeywordConceptIsUsedAsAnIdentifier_Text { get; }
    public static string Parser_Error_KeywordRequiresIsUsedAsAnIdentifier_Text { get; }
    public static string Parser_Error_UnknownOperatorType_Text { get; }
    public static string Parser_Error_OperatorSignExpected_Text { get; }
    public static string Parser_Error_OnlyPartitionsOfTheCurrentModuleCan_Text { get; }
    public static string Parser_Error_InsideForLoopColonShouldBeUsedInstead_Text { get; }
    public static string Parser_Error_InsideForEachLoopInShouldBeUsedInstead_Text { get; }
    public static string Parser_Error_ExpectedCommaOrColon_Text { get; }
    public static string Parser_Error_ExpectedGenericConstraintItem_Text { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_namespace_braces { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_declaration_braces { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_statement_braces { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_switch_statement { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_expression_braces { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_child_statement { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Between_keyword_and_parenthesis { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_comma { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_semicolon { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_operator_symbols { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_member_access_symbols { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_colon { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_parenthesis { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_square_brackets_within_a_statement { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_braces { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_angle_brackets { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_empty_braces { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_comma_in_lists { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Incorrect_number_of_blank_lines_near_braces { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Line_indent_should_not_be_changed_relative_to_the_previous_line_elsewhere { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Line_should_be_indented_or_outdented_elsewhere { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Line_indent_should_be_restored_to_the_previous_level_elsewhere { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Incorrect_indent_size { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Tabs_spaces_mismatch { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Multiple_spaces_are_prohibited { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Tabs_are_prohibited_except_for_indentation { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Blank_lines_are_missing_elsewhere { get; }
    public static string CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Blank_lines_are_redundant_elsewhere { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get___interface_Text();
    public static string get_Always_Description_Text();
    public static string get_Buffer_Text();
    public static string get_CExternalModule_Text();
    public static string get_Class_Text();
    public static string get_Resource_Text();
    public static string get_ClassDefinition_Text();
    public static string get_ClassField_Text();
    public static string get_ClassTemplate_Text();
    public static string get_CommentIdentifier_Text();
    public static string get_ComparisonUtil_AfterRewriting_Text();
    public static string get_ComparisonUtil_AmbiguousCallWithCandidates_Text();
    public static string get_ComparisonUtil_CannotBeAnOperatorTemplate_Text();
    public static string get_ComparisonUtil_CannotBeStaticMemberFunction_Text();
    public static string get_ComparisonUtil_CannotBeVolatileQualified_Text();
    public static string get_ComparisonUtil_CannotConvertReturnTypeToType_Text();
    public static string get_ComparisonUtil_CannotConvertValueTheReturnType_Text();
    public static string get_ComparisonUtil_CannotFindComparisonCategoryType_Text();
    public static string get_ComparisonUtil_CannotHaveTheRefQualifier_Text();
    public static string get_ComparisonUtil_DeducedReturnTypeMustBeAuto_Text();
    public static string get_ComparisonUtil_FormatWithDeletionReason_Text();
    public static string get_ComparisonUtil_FuncIsDeleted_Text();
    public static string get_ComparisonUtil_FuncIsNotAccessible_Text();
    public static string get_ComparisonUtil_MustBeConstQualified_Text();
    public static string get_ComparisonUtil_MustBeDeclaredAsFriendOf_Text();
    public static string get_ComparisonUtil_MustHaveAParameterOfClassType_Text();
    public static string get_ComparisonUtil_MustHaveASingleParameterOfType_Text();
    public static string get_ComparisonUtil_MustHaveTwoParametersOfSpecificTypes_Text();
    public static string get_ComparisonUtil_NotSupportedInTheCurrentLanguageDialect_Text();
    public static string get_ComparisonUtil_NoViableCandidates_Text();
    public static string get_ComparisonUtil_OperatorIsNotAComparisonOperator_Text();
    public static string get_ComparisonUtil_ReturnTypeIsNotComparisonCategory_Text();
    public static string get_ComparisonUtil_ReturnTypeMustBeBool_Text();
    public static string get_ComparisonUtil_SelectedCandidateIsNotRewritten_Text();
    public static string get_ComparisonUtil_TypeContainsVariantMembers_Text();
    public static string get_ComparisonUtil_TypeIsReference_Text();
    public static string get_ComparisonUtil_WhileComparingArrayField_Text();
    public static string get_ComparisonUtil_WhileComparingBase_Text();
    public static string get_ComparisonUtil_WhileComparingField_Text();
    public static string get_ComparisonUtil_WhileComparingParameters_Text();
    public static string get_ComparisonUtil_WhileComparingWithZero_Text();
    public static string get_CompoundStatement_Text();
    public static string get_Concept_Text();
    public static string get_Constructor_Text();
    public static string get_Conversion_Text();
    public static string get_ConversionOperator_Text();
    public static string get_CppStandardLibrary_Text();
    public static string get_CStandardLibrary_Text();
    public static string get_DeclaredElement_From_Text();
    public static string get_DeclaredElement_In_Text();
    public static string get_DeclaredElement_InBrackets_Text();
    public static string get_DeductionGuide_Text();
    public static string get_DependentName_Text();
    public static string get_Destructor_Text();
    public static string get_DuringInitialIndexing_Description_Text();
    public static string get_Enum_Text();
    public static string get_EnumClass_Text();
    public static string get_EnumStruct_Text();
    public static string get_EnumDefinition_Text();
    public static string get_Enumerator_Text();
    public static string get_Event_Text();
    public static string get_Field_Text();
    public static string get_Function_Text();
    public static string get_GenericParameter_Text();
    public static string get_GlobalNamespace_Text();
    public static string get_GlobalVariable_Text();
    public static string get_GlslFile_Text();
    public static string get_HeaderFile_Text();
    public static string get_HlslFile_Text();
    public static string get_IncludesCache_SerializationObject_Text();
    public static string get_IndexingSymbols_Text();
    public static string get_InitializingSymbolCache_Text();
    public static string get_Interface_Text();
    public static string get_Loading__Text();
    public static string get_LocalVariable_Text();
    public static string get_Macro_Text();
    public static string get_PredefinedMacro_Text();
    public static string get_UEReflectionMacro_Text();
    public static string get_MacroParameter_Text();
    public static string get_Member_Text();
    public static string get_Method_Text();
    public static string get_Module_Text();
    public static string get_ModulePartition_Text();
    public static string get_Namespace_Text();
    public static string get_NamespaceAlias_Text();
    public static string get_Never_Description_Text();
    public static string get_NonTypeTemplateArgument_Text();
    public static string get_NonTypeTemplateParameter_Text();
    public static string get_Operator_Text();
    public static string get_Parameter_Text();
    public static string get_ParameterList_Text();
    public static string get_PreparingWordIndex_Text();
    public static string get_PresenterUtil_AnonymousFormat_Text();
    public static string get_PresenterUtil_BracedInitList_Text();
    public static string get_PresenterUtil_Builtin_Text();
    public static string get_PresenterUtil_EntityKindFormat_Text();
    public static string get_PresenterUtil_FunctionOverloadSet_Text();
    public static string get_PresenterUtil_GeneratedByUHT_Text();
    public static string get_PresenterUtil_ImplicitlyGenerated_Text();
    public static string get_PresenterUtil_Inherited_Text();
    public static string get_PresenterUtil_Intrinsic_Text();
    public static string get_PrivateField_Text();
    public static string get_PrivateMethod_Text();
    public static string get_ProcessingChangedFiles_Text();
    public static string get_Property_Text();
    public static string get_ProtectedField_Text();
    public static string get_ProtectedMethod_Text();
    public static string get_PublicField_Text();
    public static string get_PublicMethod_Text();
    public static string get_RequiresExpressionClause_Text();
    public static string get_Saving__Text();
    public static string get_Something_In_Container_Text();
    public static string get_SourceFile_Text();
    public static string get_Struct_Text();
    public static string get_StructDefinition_Text();
    public static string get_StructField_Text();
    public static string get_StructuredBindingUtil_BaseIsAmbiguous_Text();
    public static string get_StructuredBindingUtil_BothHavePublicDataMembers_Text();
    public static string get_StructuredBindingUtil_HasAnonymousUnionOrClassMembers_Text();
    public static string get_StructuredBindingUtil_IsNotAccessible_Text();
    public static string get_StructuredBindingUtil_TypeIsNotComplete_Text();
    public static string get_SymbolCache_SerializationObject_Text();
    public static string get_Symbols_SerializationObject_Text();
    public static string get_SyntaxError_Text();
    public static string get_TemplateArgument_Text();
    public static string get_TemplateParameter_Text();
    public static string get_TemplateTemplateArgument_Text();
    public static string get_TemplateTemplateParameter_Text();
    public static string get_TypeAlias_Text();
    public static string get_Typedef_Text();
    public static string get_TypeTemplateArgument_Text();
    public static string get_TypeTemplateParameter_Text();
    public static string get_Union_Text();
    public static string get_UnionDefinition_Text();
    public static string get_UnionMember_Text();
    public static string get_UsingDeclaration_Text();
    public static string get_Linkage_SearchingForAllBasesOf_Text();
    public static string get_Linkage_Processing_Text();
    public static string get_Linkage_GetSymbolsForDerivedEntities_Text();
    public static string get_Linkage_ProcessingSymbols_Text();
    public static string get_Linkage_SearchingLinkageEntities_Text();
    public static string get_WordsCache_SerializationObject_Text();
    public static string get_Parser_Error_ExpectedLBrace_Text();
    public static string get_Parser_Error_ExpectedCatch_Text();
    public static string get_Parser_Error_ExpectedTypeId_Text();
    public static string get_Parser_Error_ExpectedConversionId_Text();
    public static string get_Parser_Error_ExpectedParameterDeclaration_Text();
    public static string get_Parser_Error_ExpectedCondition_Text();
    public static string get_Parser_Error_ExpectedSecondArgumentOfForLoop_Text();
    public static string get_Parser_Error_ExpectedCliProperty_Text();
    public static string get_Parser_Error_ExpectedCliEvent_Text();
    public static string get_Parser_Error_ExpectedCliPropertyAccessor_Text();
    public static string get_Parser_Error_ExpectedCliDelegate_Text();
    public static string get_Parser_Error_ExpectedCliConstraintTypeId_Text();
    public static string get_Parser_Error_ExpectedDeclaration_Text();
    public static string get_InvalidParenthesisSequence_Text();
    public static string get_Parser_Error_ExpectedSemicolon_Text();
    public static string get_Parser_Error_ExpectedStringLiteral_Text();
    public static string get_Parser_Error_ExceptionInParser_Text();
    public static string get_Parser_Error_ExpectedIdentifier_Text();
    public static string get_Parser_Error_ExpectedAClassName_Text();
    public static string get_Parser_Error_ExpectedAClassDeclaration_Text();
    public static string get_Parser_Error_ExpectedRBrace_Text();
    public static string get_Parser_Error_ExpectedEq_Text();
    public static string get_Parser_Error_MustBeATypeConcept_Text();
    public static string get_Parser_Error_ExpectedModuleName_Text();
    public static string get_Parser_Error_ExpectedNewline_Text();
    public static string get_Parser_Error_ExpectedPrivate_Text();
    public static string get_Parser_Error_ExpectedDefaultOrDelete_Text();
    public static string get_Parser_Error_ExpectedType_Text();
    public static string get_Parser_Error_ExpectedDeclarator_Text();
    public static string get_Parser_Error_ExpectedComma_Text();
    public static string get_Parser_Error_ExpectedDeclaratorName_Text();
    public static string get_Parser_Error_ExpectedColon_Text();
    public static string get_Parser_Error_ExpectedRegisterKeywordOrSemantic_Text();
    public static string get_Parser_Error_UnexpectedTemplate_Text();
    public static string get_Parser_Error_ExpectedKeyword_Text();
    public static string get_Parser_Error_ExpectedEqOrColon_Text();
    public static string get_Parser_Error_ExpectedThis_Text();
    public static string get_Parser_Error_ExpectedLambdaCapture_Text();
    public static string get_Parser_Error_AutoIsNotAllowedInALambdaCapture_Text();
    public static string get_Parser_Error_ExpectedLPar_Text();
    public static string get_Parser_Error_ExpectedIn_Text();
    public static string get_Parser_Error_ExpectedLParOrLBrace_Text();
    public static string get_Parser_Error_ExpectedExpression_Text();
    public static string get_Parser_Error_ExpectedRPar_Text();
    public static string get_Parser_Error_ExpectedAuto_Text();
    public static string get_Parser_Error_ExpectedRBracket_Text();
    public static string get_Parser_Error_ExpectedWhile_Text();
    public static string get_Parser_Error_ExpectedSemicolonOrColon_Text();
    public static string get_Parser_Error_ExpectedSemanticIdentifier_Text();
    public static string get_Parser_Error_ExpectedLabelIdentifier_Text();
    public static string get_Parser_Error_ExpectedLt_Text();
    public static string get_Parser_Error_ExpectedGt_Text();
    public static string get_Parser_Error_ExpectedNumericLiteral_Text();
    public static string get_Parser_Error_ExpectedAfterIf_Text();
    public static string get_Parser_Error_ExpectedAfterDeclaration_Text();
    public static string get_Parser_Error_RestrictionSpecifierCannotBeEmpty_Text();
    public static string get_Parser_Error_ParensCannotBeUsedInIfConsteval_Text();
    public static string get_Parser_Error_QualifiersAreNotAllowedAtTopLevelAsm_Text();
    public static string get_Parser_Error_ExpectedAfterWhile_Text();
    public static string get_Parser_Error_ExpectedClassOrStruct_Text();
    public static string get_Parser_Error_ExpectedGetOrPut_Text();
    public static string get_Parser_Error_TheAttributeUsingPrefixIsNotCompatible_Text();
    public static string get_Parser_Error_QualifiersAreNotAllowedInGNUStyleAttribute_Text();
    public static string get_Parser_Error_Expected__exceptOr__finally_Text();
    public static string get_Parser_Error_ExpectedMacroParameter_Text();
    public static string get_Parser_Error_ExpectedCommaOrRPar_Text();
    public static string get_Parser_Error_ExpectedStatement_Text();
    public static string get_Parser_Error_TemplateInCompoundStatement_Text();
    public static string get_Parser_Error_TemplateTemplateParameterRequiresClass_Text();
    public static string get_Parser_Error_ExpectedClassOrTypenameKeyword_Text();
    public static string get_Parser_Error_ConceptMustBeATemplate_Text();
    public static string get_Parser_Error_ConceptsAreOnlyAllowedAtNamespaceLevel_Text();
    public static string get_Parser_Error_SuperfluousSemicolon_Text();
    public static string get_CommonLanguageRunTimeIsSupportedInFileButSystem_Text();
    public static string get_CommonLanguageRunTimeIsSupportedInFileButSystemString_Text();
    public static string get_CommonLanguageRunTimeIsSupportedInFileButSystemObject_Text();
    public static string get_CommonLanguageRunTimeIsSupportedInFileButSystemValueType_Text();
    public static string get_CommonLanguageRunTimeIsSupportedInFileButSystemIDisposable_Text();
    public static string get_CommonLanguageRunTimeIsSupportedInFileButSystemEnum_Text();
    public static string get_CommonLanguageRunTimeIsSupportedInFileButSystemArray_Text();
    public static string get_CommonLanguageRunTimeIsSupportedInFileButSystemVoid_Text();
    public static string get_CommonLanguageRunTimeIsSupportedInFileButSystemIEnumerable_Text();
    public static string get_Parser_Error_ExpectedSpecifierKey_Text();
    public static string get_Parser_Error_ExpectedSpecifierValue_Text();
    public static string get_Parser_Error_ExpectedMetaKey_Text();
    public static string get_Parser_Error_ExpectedMetaValue_Text();
    public static string get_Parser_Error_ExpectedRefOrValue_Text();
    public static string get_Parser_Error_ExpectedEqOrLBrace_Text();
    public static string get_Parser_Error_ExpectedAGenericParameter_Text();
    public static string get_Parser_Error_ExpectedRBracketRBracket_Text();
    public static string get_Parser_Error_ExpectedRParRPar_Text();
    public static string get_Parser_Error_AnAttributeSpecifierSequenceIsNotAllowed_Text();
    public static string get_Parser_Error_KeywordTypenameShouldBeFollowedByQualified_Text();
    public static string get_Parser_Error_QualifierCanBeUsedOnlyAfter_Text();
    public static string get_Parser_Error_UnexpectedIdentifier_Text();
    public static string get_Parser_Error_ExpectedCommaOrRBracket_Text();
    public static string get_Parser_Error_UnknownRestrictionSpecifier__Text();
    public static string get_Parser_Error_AnAttributeSpecifierSequenceIsNotAllowedHere_Text();
    public static string get_Parser_Error_ExpectedCommaOrRBrace_Text();
    public static string get_Parser_Error_ExpectedCommaLBraceOrSemicolon_Text();
    public static string get_Parser_Error_InvalidCombinationOfAccessibilitySpecifiers_Text();
    public static string get_Parser_Error_ExpectedCommaOrSemicolon_Text();
    public static string get_Parser_Error_ExpectedCommaOrLBrace_Text();
    public static string get_Parser_Error_ExpectedCommaOrRParen_Text();
    public static string get_Parser_Error_UnexpectedToken_Text();
    public static string get_Parser_Error_UnexpectedCharLiteral_Text();
    public static string get_Parser_Error_UnexpectedNumericLiteral_Text();
    public static string get_Parser_Error_ExpectedConstantExpression_Text();
    public static string get_Parser_Error_UnknownDeclspec__Text();
    public static string get_Parser_Error_AnAttributeSpecifierSequenceIsNotAllowedAfterMSAttribute_Text();
    public static string get_Parser_Error__IsNotAFoldableOperator_Text();
    public static string get_Parser_Error_ExpectedAFoldableBinaryOperator_Text();
    public static string get_Parser_Error_ExpectedOperator_Text();
    public static string get_Parser_Error_ExpectedCommaOrGt_Text();
    public static string get_Parser_Error_StatementExpressionMayOnlyBeUsedInside_Text();
    public static string get_Parser_Error_UnexpectedCvQualifier_Text();
    public static string get_Parser_Error_ExpectedACallAfterThe__raiseKeyword_Text();
    public static string get_Parser_Error_ExpectedGtGtGt_Text();
    public static string get_Parser_Error_KeywordConceptIsUsedAsAnIdentifier_Text();
    public static string get_Parser_Error_KeywordRequiresIsUsedAsAnIdentifier_Text();
    public static string get_Parser_Error_UnknownOperatorType_Text();
    public static string get_Parser_Error_OperatorSignExpected_Text();
    public static string get_Parser_Error_OnlyPartitionsOfTheCurrentModuleCan_Text();
    public static string get_Parser_Error_InsideForLoopColonShouldBeUsedInstead_Text();
    public static string get_Parser_Error_InsideForEachLoopInShouldBeUsedInstead_Text();
    public static string get_Parser_Error_ExpectedCommaOrColon_Text();
    public static string get_Parser_Error_ExpectedGenericConstraintItem_Text();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_namespace_braces();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_declaration_braces();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_statement_braces();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_switch_statement();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_expression_braces();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_child_statement();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Between_keyword_and_parenthesis();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_comma();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_semicolon();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_operator_symbols();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_member_access_symbols();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_colon();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_parenthesis();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_square_brackets_within_a_statement();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_braces();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_angle_brackets();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_empty_braces();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_comma_in_lists();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Incorrect_number_of_blank_lines_near_braces();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Line_indent_should_not_be_changed_relative_to_the_previous_line_elsewhere();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Line_should_be_indented_or_outdented_elsewhere();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Line_indent_should_be_restored_to_the_previous_level_elsewhere();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Incorrect_indent_size();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Tabs_spaces_mismatch();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Multiple_spaces_are_prohibited();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Tabs_are_prohibited_except_for_indentation();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Blank_lines_are_missing_elsewhere();
    public static string get_CppFormatterHighlightingProvider_InternalConfigurableSeverityItems_Blank_lines_are_redundant_elsewhere();
}
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeStyleSettings", "Configuration for setting placement information of cv-qualifiers")]
public class JetBrains.ReSharper.Psi.Cpp.Settings.CppCVQualsPlacementSettingsKey : object {
    [ObsoleteAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Put cv-qualifiers before type")]
public bool PutBeforeTypename;
    [ObsoleteAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Put 'const' before 'volatile'")]
public bool PutConstBeforeVolatile;
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Settings.CppCVQualsPlacementSettingsKeyAccessor : object {
    public abstract virtual bool GetPutBeforeTypename(IContextBoundSettingsStore store);
    public abstract virtual bool GetPutConstBeforeVolatile(IContextBoundSettingsStore store);
    public abstract virtual bool GetSpaceBeforePtrInDataMember(IContextBoundSettingsStore store);
    public abstract virtual bool GetSpaceAfterPtrInDataMember(IContextBoundSettingsStore store);
}
[SettingsKeyAttribute("System.Reflection.Missing", "C++ project properties")]
public class JetBrains.ReSharper.Psi.Cpp.Settings.CppProjectPropertiesSettingsKey : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Additional include directories")]
public string AdditionalIncludeDirectories;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Additional preprocessor definitions")]
public string AdditionalPreprocessorDefinitions;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "C++ language standard")]
public CppLanguageStandard LanguageStandard;
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Cpp.Settings.CppProjectPropertiesSettingsKeyAccessor : object {
    private static Expression`1<Func`2<CppProjectPropertiesSettingsKey, string>> ourIncludeDirectivesExpr;
    private static Expression`1<Func`2<CppProjectPropertiesSettingsKey, string>> ourPPDefinitionsExpr;
    private static Expression`1<Func`2<CppProjectPropertiesSettingsKey, CppLanguageStandard>> ourStandardExpr;
    private ProjectSettingsStorageComponent mySettingsStorage;
    public CppProjectPropertiesSettingsKeyAccessor(ProjectSettingsStorageComponent settingsStorage);
    private static CppProjectPropertiesSettingsKeyAccessor();
    public string GetAdditionalIncludeDirectories(IProject project);
    public string GetAdditionalPreprocessorDefinitions(IProject project);
    public CppLanguageStandard GetLanguageStandard(IProject project);
}
public interface JetBrains.ReSharper.Psi.Cpp.Settings.ICppIncludeDirectiveSettingsKeyAccessor {
    public abstract virtual bool UseForwardSlash(IContextBoundSettingsStore store);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.BinarySearchList`2 : ValueType {
    private CppList`1<KeyValuePair`2<KeyT, ValueT>> myList;
    public KeyValuePair`2<KeyT, ValueT> Item { get; }
    public int UpperBound(KeyT key);
    public int LowerBound(KeyT key);
    public void AddOrReplaceCloseToEnd(KeyT key, ValueT val);
    public KeyValuePair`2<KeyT, ValueT> get_Item(int index);
    public int Size();
    public void RemoveLast();
    public CppListEnumerator`1<KeyValuePair`2<KeyT, ValueT>> GetEnumerator();
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.BinarySearchListUtil : object {
    public static BinarySearchList`2<CppComplexOffset, ValueT> ShiftBinarySearchList(BinarySearchList`2<CppComplexOffset, ValueT> origin, int textOffset, int delta);
    public static BinarySearchList`2<CppComplexOffset, ValueT> DropAllAfterInBinarySearchList(BinarySearchList`2<CppComplexOffset, ValueT> origin, int textOffset);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.BlockShadersModuleSerializedAttribute : ValueType {
    public static int Size;
    public int Name;
    public CppSlice Parameters;
    public BSAttributeData Unmarshal(CppModuleUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.ChildrenStringsBuilder : object {
    private List`1<string> myBodies;
    private CppIndentationStringBuilder myParent;
    public ChildrenStringsBuilder(CppIndentationStringBuilder parent);
    public CppIndentationStringBuilder StartChild();
    public void EndChild(CppIndentationStringBuilder child);
    public void Finish();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.ClassPartDescription : ValueType {
    public ICppClassOrDelegateSymbolOrModuleEntity Symbol;
    public CppLocationAnchor Anchor;
    public ICppTemplateArgument[] Defaults;
    public ClassPartDescription(ICppClassOrDelegateSymbolOrModuleEntity symbol, CppLocationAnchor anchor, ICppTemplateArgument[] defaults);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.ClrClassPartDescription : ValueType {
    public ICppClassOrDelegateSymbol Symbol;
    public CppLocationAnchor Anchor;
    public ClrClassPartDescription(ICppClassOrDelegateSymbol sym, CppLocationAnchor anchor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAbstractDeclarationBuilder : CppForwardingBuilder {
    private ICppDeclaratorBuilder myLastDeclaratorBuilder;
    private CppUnresolvedDeclarationSpecifierTypeBuilder myUnresolvedSpecifierTypeBuilder;
    private CppResolvedDeclarationSpecifierTypeBuilder myReplacedSpecifierTypeBuilder;
    private CppDeclarationSpecifiers myDeclSpecifiers;
    private bool myCreateParameters;
    public ICppDeclaratorBuilder LastDeclaratorBuilder { get; }
    public CppClassBuilder ClassBuilder { get; }
    public ICppAttributeListBuilder AttributeListBuilder { get; }
    public CppAbstractDeclarationBuilder(ICppBuilder parent, bool createParameters);
    public sealed virtual CppTemplateDeclarationBuilder TemplateDeclarationBuilder();
    public sealed virtual ICppDeclaratorBuilder get_LastDeclaratorBuilder();
    public sealed virtual ICppUnresolvedDeclarationSpecifierTypeBuilder GetUnresolvedSpecifierTypeBuilder();
    public sealed virtual ICppResolvedDeclarationSpecifierTypeBuilder GetReplacedSpecifierTypeBuilder();
    public sealed virtual ICppAttributeListBuilder CreateAttributesBuilder();
    public sealed virtual ICppCallingConventionBuilder CreateCallingConventionBuilder();
    public sealed virtual ICppStructuredBindingDeclarationBuilder CreateStructuredBindingBuilder();
    public sealed virtual CppClassBuilder get_ClassBuilder();
    public sealed virtual ICppAttributeListBuilder get_AttributeListBuilder();
    public sealed virtual void FinishDeclaration();
    public sealed virtual void LearnSpecifier(TokenNodeType tt);
    public sealed virtual void LearnDeclspecProperty();
    public sealed virtual void LearnExport();
    public sealed virtual void LearnDecltypeAuto();
    public sealed virtual void LearnAttributes(ICppAttributeListBuilder builder);
    public sealed virtual void LearnCallingConvention(ICppCallingConventionBuilder ccBuilder);
    public sealed virtual void LearnClassSpecifier(CppClassBuilder classBuilder);
    public sealed virtual void ApplyImplicitIntType();
    public sealed virtual bool IsStandalone();
    public sealed virtual bool HasImplicitIntType();
    public sealed virtual CppDeclarationSpecifiers GetSpecifiers();
    public sealed virtual ICppDeclaratorBuilder NewDeclaratorBuilder();
    public sealed virtual ICppConceptDefinitionBuilder NewConceptDefinitionBuilder();
    public sealed virtual bool NeedTypename();
    public bool GetCreateParameters();
    public sealed virtual void LearnExplicitSpecifier();
    public sealed virtual void LearnExplicitSpecifier(CppTwinExpressionBuilder& exprBuilder);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAbstractDeclaratorBuilder : object {
    private CppAbstractDeclarationBuilder myParent;
    private CppUnresolvedTypeBuilder myUnresolvedTypeBuilder;
    private CppResolvedTypeBuilder myReplacedTypeBuilder;
    private bool myParameterPack;
    private ICppFunctionParameterListBuilder myMainParameterListBuilder;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public ICppDeclaratorSymbol Symbol { get; }
    public bool HasSymbol { get; }
    public bool IsParameterPackDeclarator { get; }
    public CppAbstractDeclaratorBuilder(CppAbstractDeclarationBuilder parent);
    public sealed virtual void AddChild(CppParserSymbol _);
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    public sealed virtual ICppDeclaratorBuilder GetDeclaratorBuilder();
    public sealed virtual ICppDeclarationBuilder GetDeclarationBuilder();
    public ICppBuilder CreateInitDeclaratorBuilder();
    public sealed virtual ICppAttributeListBuilder CreateAttributesBuilder();
    public sealed virtual ICppCallingConventionBuilder CreateCallingConventionBuilder();
    public sealed virtual ICppUnresolvedTypeBuilder GetUnresolvedTypeBuilder();
    public sealed virtual ICppResolvedTypeBuilder GetReplacedTypeBuilder();
    public sealed virtual void ComposeSymbolType(CppSymbolLocation _);
    public sealed virtual void LearnLocation(CppSymbolLocation _);
    public void LearnNavigationOffset(CppComplexOffset _);
    public void LearnQualifiedName(CppTwinQualifiedNameBuilder& _);
    public sealed virtual void LearnQualifiedName(ICppStructuredBindingDeclarationBuilder _);
    public sealed virtual void LearnInitializer(KIND kind, CppSmallArray`1<ICppExpression> unresolvedArguments, CppSmallArray`1<ICppExpression> replacedArguments);
    public sealed virtual void LearnMainParameterList(ICppFunctionParameterListBuilder builder);
    public sealed virtual void LearnFunctionBody(CppDeclarationTrailingKind kind);
    public sealed virtual void LearnPureVirtualSpecifier(CppPureVirtualSpecifiers specs);
    public sealed virtual void LearnEllipsis();
    public sealed virtual void LearnAttributes(ICppAttributeListBuilder attrsBuilder);
    public sealed virtual void LearnNoAttributes();
    public sealed virtual void LearnBitfieldSize(ICppExpression unresolvedSize, ICppExpression replacedSize);
    public void LearnCxxCliOverrideSpecifier(CppTwinQualifiedNameBuilder& _);
    public sealed virtual void LearnRequiresClause(ICppExpression unresolved, ICppExpression replaced);
    public sealed virtual ICppFunctionParameterListBuilder CreateParameterListBuilder();
    public sealed virtual ICppFunctionParameterListBuilder GetMainParameterListBuilder();
    public sealed virtual ICppDeclaratorSymbol get_Symbol();
    public sealed virtual bool get_HasSymbol();
    public sealed virtual bool get_IsParameterPackDeclarator();
    private sealed virtual override void JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorBuilder.LearnQualifiedName(CppTwinQualifiedNameBuilder& modreq(System.Runtime.InteropServices.InAttribute) _);
    private sealed virtual override void JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorBuilder.LearnCxxCliOverrideSpecifier(CppTwinQualifiedNameBuilder& modreq(System.Runtime.InteropServices.InAttribute) _);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAbstractIndex`1 : ValueType {
    private int myStorage;
    public int RawStorage { get; }
    public CppAbstractIndex`1(byte kind, int rawIndex);
    public CppAbstractIndex`1(int rawStorage);
    public int get_RawStorage();
    public byte GetKind();
    public int RawIndex();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAbstractParameterListBuilder : CppForwardingBuilder {
    private CppCVQualifiersBuilder myCVQualifierBuilder;
    private CppFuncRefQualifierBuilder myFuncRefQualifierBuilder;
    private CppQualType myUnresolvedTrailingReturnType;
    private CppQualType myReplacedTrailingReturnType;
    private CppEllipsisKind myEllipsisKind;
    private CppRestrictionSpecifiers myRestrictionSpecifiers;
    private ICppExceptionSpecification myUnresolvedExceptionSpecification;
    private ICppExceptionSpecification myReplacedExceptionSpecification;
    public CppAbstractParameterListBuilder(ICppBuilder parentBuilder);
    public void Finish();
    public sealed virtual void LearnExplicitThis();
    public sealed virtual void LearnEllipsis(CppEllipsisKind kind);
    public sealed virtual void LearnRestrictionSpecifier(CppRestrictionSpecifiers restrictionSpecifiers);
    public sealed virtual ICppDeclarationBuilder CreateDeclarationBuilderForParameter(CppBuilderPool _);
    public sealed virtual void LearnParameter(ICppDeclarationBuilder declBuilder);
    public sealed virtual void LearnEndAnchor();
    public sealed virtual void LearnKnRStyleParamsStart();
    public sealed virtual CppEllipsisKind GetEllipsisKind();
    public sealed virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public sealed virtual CppParameterListResolveEntity GetResolveEntity();
    public sealed virtual CppList`1<CppParameterDeclaratorSymbol> GetParameterSymbols();
    public sealed virtual ICppDeclarationBuilder CreateDeclarationBuilderForTrailingReturnType();
    public sealed virtual void LearnTrailingReturnStartAnchor();
    public sealed virtual void LearnTrailingReturnType(ICppDeclarationBuilder declBuilder);
    public sealed virtual CppQualType GetUnresolvedTrailingReturnType();
    public sealed virtual CppQualType GetReplacedTrailingReturnType();
    public sealed virtual void LearnCVQualifier(TokenNodeType tt);
    public sealed virtual CVQualifiers GetFunctionCVQualifiers();
    public sealed virtual void LearnRefQualifier(TokenNodeType tt);
    public sealed virtual FuncRefQualifier GetFunctionRefQualifier();
    public sealed virtual ICppExceptionSpecificationBuilder CreateExceptionSpecificationBuilder(CppComplexOffset offset);
    public sealed virtual void LearnExceptionSpecification(CppComplexOffset offset, ICppExceptionSpecificationBuilder builder);
    public sealed virtual ICppExceptionSpecification GetUnresolvedExceptionSpecification();
    public sealed virtual ICppExceptionSpecification GetReplacedExceptionSpecification();
    public sealed virtual bool HasOnlyParamsWithImplicitInt();
    public sealed virtual bool IsKnRParamListStarted();
    public sealed virtual void LearnIsMainParameterList(bool declaratorIsStatic);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAbstractResolveEntityVisitor`1 : object {
    public virtual Result Visit(ICppClassResolveEntity e);
    public virtual Result Visit(ICppStatementResolveEntity e);
    public virtual Result Visit(ICppRequiresExpressionScopeResolveEntity e);
    public virtual Result Visit(CppRequiresExpressionItemResolveEntity e);
    public virtual Result Visit(ICppParameterListResolveEntity e);
    public virtual Result Visit(ICppDeclaratorResolveEntity e);
    public virtual Result Visit(ICppConceptDefinitionResolveEntity e);
    public virtual Result Visit(ICppEnumeratorResolveEntity e);
    public virtual Result Visit(CppNamespaceResolveEntity e);
    public virtual Result Visit(CppNamespaceAliasResolveEntity e);
    public virtual Result Visit(CppUsingDeclarationResolveEntity e);
    public virtual Result Visit(CppClassTemplateResolveEntityPack e);
    public virtual Result Visit(ICppTypeTemplateParameter e);
    public virtual Result Visit(ICppTypeTemplateParameterPack e);
    public virtual Result Visit(ICppExpressionTemplateParameter e);
    public virtual Result Visit(ICppExpressionTemplateParameterPack e);
    public virtual Result Visit(ICppTemplateTemplateParameter e);
    public virtual Result Visit(ICppTemplateTemplateParameterPack e);
    public virtual Result Visit(ICppGenericParameter e);
    public virtual Result Visit(CppDependentResolveEntity e);
    public virtual Result Visit(CppDependentDecltypeResolveEntity e);
    public virtual Result Visit(CppDependentAutoTypeResolveEntity e);
    public virtual Result Visit(CppDependentFunctionReturnAutoTypeResolveEntity e);
    public virtual Result Visit(CppDependentDeducedClassTypePlaceholder e);
    public virtual Result Visit(CppUsingDeclarationResolveEntityWithSubstitution e);
    public virtual Result Visit(CppUndeterminedSpecializationResolveEntity e);
    public virtual Result Visit(CppTemplateTemplateParameterWithAppliedArgumentsResolveEntity e);
    public virtual Result Visit(CppDecltypeResolveEntity e);
    public virtual Result Visit(CppTypeOfTypeResolveEntity e);
    public virtual Result Visit(ICppDeclaratorResolveEntityPack e);
    public virtual Result Visit(CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity e);
    public virtual Result Visit(CppUndeterminedTemplateVariableSpecializationResolveEntity e);
    public virtual Result Visit(CppSuperResolveEntity e);
    public virtual Result Visit(AbstractBuiltinResolveEntity e);
    public virtual Result Visit(ICppFunctionTemplateDeclaratorResolveEntity e);
    public virtual Result Visit(ICppTypeTemplateDeclaratorResolveEntity e);
    public virtual Result Visit(ICppVariableTemplateDeclaratorResolveEntity e);
    public virtual Result Visit(CppDependencyKillerResolveEntity e);
    public virtual Result Visit(ICppCxxCliPropertySetResolveEntity e);
    public virtual Result Visit(ICppDeductionGuide e);
    public virtual Result Visit(CppUsingEnumEnumeratorResolveEntity e);
    public virtual Result Visit(HlslBuiltinFunctionResolveEntity e);
    public virtual Result Visit(BlockShadersResolveEntity e);
    public abstract virtual Result Visit(ICppResolveEntity e);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAbstractSymbolVisitor`1 : object {
    public virtual Result Visit(CppClassSymbol symbol);
    public virtual Result Visit(CppFwdClassSymbol symbol);
    public virtual Result Visit(CppDeserializedFromModuleClassSymbol symbol);
    public virtual Result Visit(CppEnumWithBaseSymbol symbol);
    public virtual Result Visit(CppFwdEnumWithBaseSymbol symbol);
    public virtual Result Visit(CppDeclarationSymbol symbol);
    public virtual Result Visit(ICppDeclaratorSymbol symbol);
    public virtual Result Visit(CppParameterDeclaratorSymbol symbol);
    public virtual Result Visit(CppEnumeratorSymbol symbol);
    public virtual Result Visit(CppNamespaceSymbol symbol);
    public virtual Result Visit(CppNamespaceAliasSymbol symbol);
    public virtual Result Visit(CppNamespaceQualifierSymbol symbol);
    public virtual Result Visit(CppExportBlockSymbol symbol);
    public virtual Result Visit(CppLinkageSpecSymbol symbol);
    public virtual Result Visit(CppTypeTemplateParameterSymbol symbol);
    public virtual Result Visit(CppTypeTemplateParameterPackSymbol symbol);
    public virtual Result Visit(CppExpressionTemplateParameterSymbol symbol);
    public virtual Result Visit(CppExpressionTemplateParameterPackSymbol symbol);
    public virtual Result Visit(CppTemplateTemplateParameterSymbol symbol);
    public virtual Result Visit(CppTemplateTemplateParameterPackSymbol symbol);
    public virtual Result Visit(CppGenericParameterSymbol symbol);
    public virtual Result Visit(CppConceptTypeTemplateParameterSymbol symbol);
    public virtual Result Visit(CppConceptTypeTemplateParameterPackSymbol symbol);
    public virtual Result Visit(CppUsingDeclarationSymbol symbol);
    public virtual Result Visit(CppUsingDirectiveSymbol symbol);
    public virtual Result Visit(CppUsingEnumDeclarationSymbol symbol);
    public virtual Result Visit(CppAliasDeclarationSymbol symbol);
    public virtual Result Visit(CppLambdaSymbol symbol);
    public virtual Result Visit(CppLambdaInitCaptureSymbol symbol);
    public virtual Result Visit(CppCxxCliPropertySymbol symbol);
    public virtual Result Visit(CppCxxCliDelegateSymbol symbol);
    public sealed virtual Result Visit(CppAnonymousCStructDeclarationSymbol symbol);
    public virtual Result Visit(CppCompoundStatementSymbol symbol);
    public virtual Result Visit(CppSwitchStatementSymbol symbol);
    public virtual Result Visit(CppWhileStatementSymbol symbol);
    public virtual Result Visit(CppDoStatementSymbol symbol);
    public virtual Result Visit(CppForStatementSymbol symbol);
    public virtual Result Visit(CppIfStatementSymbol symbol);
    public virtual Result Visit(CppReturnStatementSymbol symbol);
    public virtual Result Visit(CppExpressionStatementSymbol symbol);
    public virtual Result Visit(CppGotoStatementSymbol symbol);
    public virtual Result Visit(CppCtorInitializerStatementSymbol symbol);
    public virtual Result Visit(CppCatchBlockSymbol symbol);
    public virtual Result Visit(CppStructuredBindingSymbol symbol);
    public virtual Result Visit(CppPPDefineSymbol symbol);
    public virtual Result Visit(CppPPMacroParameterSymbol symbol);
    public virtual Result Visit(CppModuleDirectiveSymbol symbol);
    public virtual Result Visit(CppImportHeaderUnitDirectiveSymbol symbol);
    public virtual Result Visit(CppImportModuleDirectiveSymbol symbol);
    public virtual Result Visit(CppPPUndefSymbol symbol);
    public virtual Result Visit(CppPPIncludeSymbol symbol);
    public virtual Result Visit(CppPPPragmaSymbol symbol);
    public virtual Result Visit(CppRequiresExpressionSymbol symbol);
    public virtual Result Visit(CppConceptDefinitionSymbol symbol);
    public virtual Result Visit(CppRequiresExpressionItemSimpleSymbol symbol);
    public virtual Result Visit(CppRequiresExpressionItemTypenameSymbol symbol);
    public virtual Result Visit(CppRequiresExpressionItemNestedSymbol symbol);
    public virtual Result Visit(CppRequiresExpressionItemCompoundSymbol symbol);
    public virtual Result Visit(CppHLSLBufferSymbol symbol);
    public abstract virtual Result Visit(ICppSymbol symbol);
    public virtual Result Visit(ICppParserSymbol symbol);
    public virtual Result Visit(ICppPPSymbol symbol);
    public virtual Result Visit(ICppTemplateParameterSymbol symbol);
    public virtual Result Visit(ICppClassSymbol symbol);
    public virtual Result Visit(CppRequiresExpressionItemSymbol symbol);
    public virtual Result Visit(BSBlockSymbol symbol);
    public virtual Result Visit(BSBlockShaderSymbol symbol);
    public virtual Result Visit(BSBlockShaderInterfaceSymbol symbol);
    public virtual Result Visit(BSCustomizationPointSymbol symbol);
    public virtual Result Visit(BSCustomizationPointImplementationSymbol symbol);
    public virtual Result Visit(BSTemplateSymbol symbol);
    public virtual Result Visit(CppGGDeclareHungarianSymbol symbol);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppAccessibility : Enum {
    public byte value__;
    public static CppAccessibility NOT_APPLICABLE;
    public static CppAccessibility PUBLIC;
    public static CppAccessibility PROTECTED;
    public static CppAccessibility PRIVATE;
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAccessibilityProviderUtil : object {
    public static CppAccessibility GetCurrentAccessibility(ICppBuilder builder);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAccessibilityUtil : object {
    [ExtensionAttribute]
public static bool IsLessAccessible(CppAccessibility left, CppAccessibility right);
    [ExtensionAttribute]
public static Nullable`1<CppAccessibility> GetDefaultAccessibility(ICppClassResolveEntity resolveEntity);
    [ExtensionAttribute]
public static Nullable`1<CppAccessibility> GetDefaultAccessibilityFromClassKey(CppClassKey classKey, CppLanguageDialect dialect);
    [ExtensionAttribute]
public static CppAccessibility ConvertClrAccessRightsToCppAccessibility(AccessRights rigths);
    [ExtensionAttribute]
public static AccessRights ConvertCppAccessibilityToClrAccessRights(CppAccessibility accessibility);
    [ExtensionAttribute]
public static string AccessibilityToString(CppAccessibility accessibility);
    [ExtensionAttribute]
public static CppTokenNodeType TokenTypeFromAccessibility(CppAccessibility accessibility);
    [ExtensionAttribute]
public static CppAccessibility AccessibilityFromTokenType(TokenNodeType nodeType);
    public static CppAccessibility DeriveAccessibilitySpecifiers(CppBasicBaseDescription`1<ICppClassResolveEntity> desc, CppClassKey key);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAliasDeclarationResolveEntity : object {
    private ICppScopeResolveEntity myStructuralParent;
    private CppLocationAnchor myLocationAnchor;
    private CppQualifiedNamePart myName;
    private CppAliasDeclarationSymbol mySymbol;
    private CppQualType myReplacedType;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <AnchorForViewPos>k__BackingField;
    [CompilerGeneratedAttribute]
private CppAttributeList <Attributes>k__BackingField;
    public CppLocationAnchor AnchorForViewPos { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppAliasDeclarationResolveEntity(ICppScopeResolveEntity structuralParent, CppLocationAnchor locationAnchor, CppLocationAnchor anchorForViewPos, CppQualifiedNamePart name, CppAliasDeclarationSymbol symbol, CppQualType replacedType, CppAttributeList replacedAttributes);
    [CompilerGeneratedAttribute]
public CppLocationAnchor get_AnchorForViewPos();
    public sealed virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
    public sealed virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public sealed virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    [CompilerGeneratedAttribute]
public sealed virtual CppAttributeList get_Attributes();
    public sealed virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public sealed virtual ICppResolveEntityParent get_RealParent();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public CppAliasDeclarationSymbol GetDeclarationSymbol();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAliasDeclarationSymbol : CppParserSymbol {
    private CppAccessibility myAccessibility;
    private bool myExport;
    private CppAttributeList myAttributes;
    private CppSymbolTemplateParametersList myParamList;
    private CppQualType myType;
    public CppAliasDeclarationSymbol(CppQualifiedName name, CppComplexOffset offset, CppQualType type, CppSymbolTemplateParametersList paramList, CppAccessibility accessibility, CppAttributeList attributes, bool export);
    public CppQualType GetCppType();
    public CppSymbolTemplateParametersList GetParamList();
    public CppAccessibility GetAccessibility();
    public bool Export();
    public CppAttributeList GetAttributes();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAlignAsArgumentBuilder : object {
    private ICppTypeIdOrExpression myUnresolvedExpression;
    private ICppTypeIdOrExpression myReplacedExpression;
    public sealed virtual ICppDeclarationBuilder CreateDeclarationBuilder(ICppBuilder parent, bool createParameters);
    public sealed virtual void LearnQualifiedReference(CppTwinQualifiedNameBuilder& nameBuilder, bool isPackExpansion, bool hadTypename);
    public sealed virtual void LearnTypeId(ICppDeclarationBuilder declBuilder, bool isPackExpansion);
    private static void WrapToPackExpansion(CppQualType& type);
    public sealed virtual void LearnExpression(CppTwinExpressionBuilder& exprBuilder, bool isPackExpansion);
    public void LearnExpression(ICppExpression expr);
    public sealed virtual CppTwinExpressionBuilder CreateExpressionBuilder(bool createSymbols);
    public ICppTypeIdOrExpression GetUnresolved();
    public ICppTypeIdOrExpression GetReplaced();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAllByRefLambdaCapture : object {
    public static CppAllByRefLambdaCapture INSTANCE;
    private static CppAllByRefLambdaCapture();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAllByValueLambdaCapture : object {
    public static CppAllByValueLambdaCapture INSTANCE;
    private static CppAllByValueLambdaCapture();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAnonymousCStructDeclarationSymbol : CppParserSymbol {
    public CppAnonymousCStructDeclarationSymbol(CppComplexOffset location, CppQualifiedNamePart referencedType);
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAnonymousCStructDeclaratorResolveEntity : CppShadowResolveEntity {
    private ICppGroupedVariableDeclaratorResolveEntity myInner;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <LocationAnchor>k__BackingField;
    public CppLocationAnchor LocationAnchor { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public bool IsParameterPack { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppAnonymousCStructDeclaratorResolveEntity(ICppGroupedVariableDeclaratorResolveEntity inner, ICppClassResolveEntity owner, CppLocationAnchor anchor);
    [CompilerGeneratedAttribute]
public virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public sealed virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public sealed virtual CppAttributeList get_Attributes();
    public sealed virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public CppDependentInfo GetDependentInfo();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual bool HasInitializer();
    public sealed virtual bool get_IsParameterPack();
    public virtual ICppResolveEntityParent get_RealParent();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual ICppResolveEntityWithParent GetInner();
    public ICppGroupedVariableDeclaratorResolveEntity GetInnerDeclarator();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAnonymousFunctionParameterModuleEntity : CppFunctionParameterModuleEntity {
    public static CppAnonymousFunctionParameterModuleEntity Instance;
    public bool IsParameterPack { get; }
    private static CppAnonymousFunctionParameterModuleEntity();
    public virtual CppQualifiedNamePart GetName();
    public virtual ICppDeclaratorSymbol GetSymbol();
    public virtual bool get_IsParameterPack();
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAnonymousId : object {
    public static CppAnonymousId INSTANCE;
    private static CppAnonymousId();
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAnonymousLinkageId : object {
    private int myHash;
    [CompilerGeneratedAttribute]
private string <AssocTypedef>k__BackingField;
    public string Name { get; }
    public string AssocTypedef { get; }
    public CppAnonymousLinkageId(int hash);
    public CppAnonymousLinkageId(int hash, string assocTypedef);
    public string get_Name();
    [CompilerGeneratedAttribute]
public string get_AssocTypedef();
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAssignmentOperatorResolveEntityPack : CppDeclaratorWithImplicitsResolveEntityPackBase {
    public CppAssignmentOperatorResolveEntityPack(ICppMutableClassResolveEntity klass, CppLocationAnchor anchor);
    protected virtual bool GenerateImplicits();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAttribute : object {
    public static CppAttribute Deprecated;
    public static CppAttribute Noreturn;
    public static CppAttribute Nodiscard;
    public static CppAttribute MaybeUnused;
    public static CppAttribute Unused;
    public static CppAttribute Constructor;
    public static CppAttribute Destructor;
    public static CppAttribute Fallthrough;
    public static CppAttribute Likely;
    public static CppAttribute Unlikely;
    public static CppAttribute NoUniqueAddress;
    public static CppAttribute Reproducible;
    public static CppAttribute Unsequenced;
    public static CppAttribute HasSideEffects;
    public static CppAttribute Guard;
    public static CppAttribute Format;
    public static CppAttribute PassByValue;
    public static CppAttribute ParameterWithImplicitInt;
    public static CppAttribute IntrinType;
    public static CppAttributeName RSCppBitfieldSizeName;
    public static CppAttributeName RSCppAlignAsName;
    public static CppAttributeName RSCppPackName;
    public static CppAttributeName RSCppExplicitName;
    public static CppAttributeName RSCppInName;
    public static CppAttributeName RSCppInoutName;
    public static CppAttributeName RSCppOutName;
    public static CppAttributeName AssumeName;
    public static CppAttributeName GnuVectorSizeName;
    public static CppAttributeName EmulateParserCrashName;
    public static CppAttribute Explicit;
    public static CppAttribute In;
    public static CppAttribute Inout;
    public static CppAttribute Out;
    public static CppAttribute TransparentUnion;
    public static CppAttribute AlignAsWithoutArguments;
    public static CppAttribute GeneratedByUHTEmulation;
    private CppAttributeName myName;
    protected CppAttribute(CppAttributeName name);
    private static CppAttribute();
    public sealed virtual CppAttributeName GetName();
    public virtual bool Equals(ICppAttribute obj, CppEqualityComparer comparer);
    public virtual string ToString();
    public static CppAttribute Create(CppAttributeName name);
    public static CppAttributeWithArgument`1<ICppTypeIdOrExpression> CreateAlignAs(ICppTypeIdOrExpression typeIdOrExpr);
    public static CppAttributeWithArgument`1<ICppExpression> CreateExplicit(ICppExpression expr);
    private static CppAttribute CreateStandardAttribute(string name);
    private static CppAttribute CreateReSharperAttribute(string name);
    private static CppAttribute CreateJetBrainsAttribute(string name);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAttributeAlignAsArgumentsBuilder : CppAttributeWithExpressionArgumentBuilder {
    public virtual ICppAttribute GetUnresolvedAttribute(CppAttributeName name);
    public virtual ICppAttribute GetReplacedAttribute(CppAttributeName name);
    public virtual bool LearnNoArgs(ICppAttributeArgumentsParser parser);
    private static ICppAttribute CreateAttribute(ICppExpression argument);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAttributeBuilderFactory : object {
    private string myFirstName;
    private string mySecondName;
    public void LearnNamePart(string name);
    public Nullable`1<CppCallingConvention> TryParseGnuCallingConvention();
    public ValueTuple`2<CppAttributeName, ICppAttributeArgumentsBuilder> CreateArgumentsBuilder(AttributeListStyle style);
    private bool GnuStyleOrQualifier(AttributeListStyle style);
    private CppAttributeName GetName();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAttributeFormat : CppAttribute {
    public static string Name;
    public static string NameWithUnderscores;
    public string Archetype;
    public ICppExpression FirstToCheck;
    public ICppExpression StringIndex;
    public CppAttributeFormat(CppAttributeName name, string archetype, ICppExpression stringIndex, ICppExpression firstToCheck);
    public virtual string ToString();
    public virtual bool Equals(ICppAttribute obj, CppEqualityComparer comparer);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAttributeFormatArgumentsBuilder : object {
    private string myArchetype;
    private ICppExpression myUnresolvedStringIndex;
    private ICppExpression myUnresolvedFirstToCheck;
    private ICppExpression myReplacedStringIndex;
    private ICppExpression myReplacedFirstToCheck;
    public sealed virtual bool LearnNoArgs(ICppAttributeArgumentsParser parser);
    public sealed virtual bool LearnArgs(ICppAttributeArgumentsParser parser);
    public sealed virtual ICppAttribute GetUnresolvedAttribute(CppAttributeName name);
    public sealed virtual ICppAttribute GetReplacedAttribute(CppAttributeName name);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAttributeList : ValueType {
    private CppSmallList`1<ICppAttribute> myAttributes;
    private static CppEqualityComparer ourAttributeComparer;
    public static CppAttributeList Empty;
    public int Count { get; }
    public ICppAttribute Item { get; public set; }
    internal CppAttributeList(CppSmallList`1<ICppAttribute> attributes);
    public CppAttributeList(ICppAttribute attr);
    private static CppAttributeList();
    public int get_Count();
    public ICppAttribute get_Item(int i);
    public void set_Item(int i, ICppAttribute value);
    [IsReadOnlyAttribute]
public CppSmallListEnumerator`1<ICppAttribute> GetEnumerator();
    public bool IsEmpty();
    public void Add(ICppAttribute attr);
    public bool Contains(ICppAttribute attr);
    public int IndexOf(CppAttribute attribute);
    public bool Any(Predicate`1<ICppAttribute> predicate);
    public void RemoveAt(int i);
    public void RemoveRange(int first, int count);
    public static CppAttributeList Copy(CppAttributeList attrs);
    internal object GetRaw();
    internal void Marshal(CppMarshallingContext context);
    internal static CppAttributeList Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAttributeListBuilder : object {
    private CppAttributeList myUnresolvedList;
    private CppAttributeList myReplacedList;
    public sealed virtual void LearnAttribute(CppAttributeName name, ICppAttributeArgumentsBuilder builder);
    public sealed virtual void LearnAttribute(ICppAttribute unresolved, ICppAttribute replaced);
    public sealed virtual void LearnAttributeConstant(ICppAttribute attribute);
    public sealed virtual void Merge(ICppAttributeListBuilder builder);
    public sealed virtual void Merge(CppAttributeList unresolved, CppAttributeList replaced);
    public sealed virtual CppAttributeList GetUnresolvedList();
    public sealed virtual CppAttributeList GetReplacedList();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAttributeName : ValueType {
    public string Qualifier;
    public string Name;
    public CppAttributeName(string qualifier, string name);
    public virtual int GetHashCode();
    public virtual bool Equals(object rhs);
    public sealed virtual bool Equals(CppAttributeName rhs);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAttributeNoArgumentsBuilder : CppAttributeNoArgumentsBuilderBase {
    public static CppAttributeNoArgumentsBuilder Instance;
    private static CppAttributeNoArgumentsBuilder();
    protected virtual ICppAttribute GetAttribute(CppAttributeName name);
}
internal abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAttributeNoArgumentsBuilderBase : object {
    public sealed virtual bool LearnNoArgs(ICppAttributeArgumentsParser parser);
    public sealed virtual bool LearnArgs(ICppAttributeArgumentsParser parser);
    public sealed virtual ICppAttribute GetUnresolvedAttribute(CppAttributeName name);
    public sealed virtual ICppAttribute GetReplacedAttribute(CppAttributeName name);
    protected abstract virtual ICppAttribute GetAttribute(CppAttributeName name);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAttributePackedArgumentsBuilder : CppAttributeNoArgumentsBuilderBase {
    public static CppAttributePackedArgumentsBuilder Instance;
    private static CppAttributePackedArgumentsBuilder();
    protected virtual ICppAttribute GetAttribute(CppAttributeName name);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAttributeUtil : object {
    [ExtensionAttribute]
public static InputQualifiers GetInputQualifiers(CppAttributeList attrs);
    public static void Apply(InputQualifiers& qualifiers, ICppAttribute attribute);
    public static ICppAttribute GetAttributeWithName(CppAttributeList attrs, CppAttributeName name);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertTypeClass(ICppAttribute attr, CppTypeClasses typec);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertTypeClass(CppAttributeList attrs, CppTypeClasses typec);
    public static CppAttributeList Merge(CppAttributeList xs, CppAttributeList ys);
    public static CppAttributeList CreateClassAndReplaceClassType(CppAttributeList attrs, CppCreateClassAndReplaceClassTypeContext& ctx);
    private static ICppTypeIdOrExpression ReApplyToAttributeArgument(ICppTypeIdOrExpression tidexp, CppCreateClassAndReplaceClassTypeContext ctx);
    private static ICppAttribute ResolveAttributeImpl(ICppAttribute attr, CppTypeContext& tc, ICppFileResolveEntitiesCache cache);
    public static ICppAttribute ResolveAttribute(ICppAttribute attr, CppTypeContext& tc, ICppFileResolveEntitiesCache cache);
    public static CppAttributeList ResolveAttributeList(CppAttributeList attrs, CppTypeContext& tc, ICppFileResolveEntitiesCache cache);
    public static CppAttributeList SubstituteAttributes(CppAttributeList attributes, ICppSubstitutionContext subst, CppTypeContext& tc);
    public static CppAttributeList SubstituteAttributes(CppAttributeList attributes, CppSubstitutionDriver driver);
    [ExtensionAttribute]
public static void UpdateLazyMergingInfo(CppAttributeList attrs, ICppLazyMergingDataConsumer resultConsumer);
    [ExtensionAttribute]
public static ICppAttribute FindNoDiscardAttribute(CppAttributeList attrs);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAttributeWithArgument`1 : CppAttribute {
    [CompilerGeneratedAttribute]
private TArg <Argument>k__BackingField;
    public TArg Argument { get; }
    public CppAttributeWithArgument`1(CppAttributeName name, TArg arg);
    [CompilerGeneratedAttribute]
public TArg get_Argument();
    public virtual string ToString();
    public virtual bool Equals(ICppAttribute obj, CppEqualityComparer comparer);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAttributeWithArguments`1 : CppAttribute {
    [CompilerGeneratedAttribute]
private TArg <FirstArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private TArg <SecondArgument>k__BackingField;
    public TArg FirstArgument { get; }
    public TArg SecondArgument { get; }
    public CppAttributeWithArguments`1(CppAttributeName name, TArg firstArg, TArg secondArg);
    [CompilerGeneratedAttribute]
public TArg get_FirstArgument();
    [CompilerGeneratedAttribute]
public TArg get_SecondArgument();
    public virtual string ToString();
    public virtual bool Equals(ICppAttribute obj, CppEqualityComparer comparer);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAttributeWithExpressionArgumentBuilder : object {
    protected ICppExpression myUnresolvedArgument;
    protected ICppExpression myReplacedArgument;
    public virtual bool LearnNoArgs(ICppAttributeArgumentsParser parser);
    public sealed virtual bool LearnArgs(ICppAttributeArgumentsParser parser);
    public virtual ICppAttribute GetUnresolvedAttribute(CppAttributeName name);
    public virtual ICppAttribute GetReplacedAttribute(CppAttributeName name);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppAttributeWithOptionalStringLiteralArgumentBuilder : object {
    private CppStringLiteralValue myArgument;
    public sealed virtual bool LearnNoArgs(ICppAttributeArgumentsParser parser);
    public sealed virtual bool LearnArgs(ICppAttributeArgumentsParser parser);
    public sealed virtual ICppAttribute GetUnresolvedAttribute(CppAttributeName name);
    public sealed virtual ICppAttribute GetReplacedAttribute(CppAttributeName name);
    private ICppAttribute GetAttribute(CppAttributeName name);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppBaseClassInit : CppMemInitEntity {
    [CompilerGeneratedAttribute]
private CppQualType <BaseType>k__BackingField;
    public CppQualType BaseType { get; }
    public CppBaseClassInit(CppQualType baseType);
    [CompilerGeneratedAttribute]
public CppQualType get_BaseType();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppBaseKindResult : object {
    [CompilerGeneratedAttribute]
private bool <IsVirtual>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAmbiguous>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAccessible>k__BackingField;
    public bool IsVirtual { get; }
    public bool IsAmbiguous { get; }
    public bool IsAccessible { get; }
    private CppBaseKindResult(bool isAccessible, bool isVirtual, bool isAmbig);
    [CompilerGeneratedAttribute]
public bool get_IsVirtual();
    [CompilerGeneratedAttribute]
public bool get_IsAmbiguous();
    [CompilerGeneratedAttribute]
public bool get_IsAccessible();
    public static CppBaseKindResult Create(bool isAccessible, SubobjectType subobjType);
    public static CppBaseKindResult GetBaseKind(ICppClassResolveEntity derived, ICppClassResolveEntity base, CppViewPos& vp);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppBasesDependenciesInfo : Enum {
    public int value__;
    public static CppBasesDependenciesInfo None;
    public static CppBasesDependenciesInfo UnknownBases;
    public static CppBasesDependenciesInfo DependentBases;
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppBaseSpecifiers : Enum {
    public int value__;
    public static CppBaseSpecifiers NONE;
    public static CppBaseSpecifiers PRIVATE;
    public static CppBaseSpecifiers PROTECTED;
    public static CppBaseSpecifiers PUBLIC;
    public static CppBaseSpecifiers VIRTUAL;
    public static CppBaseSpecifiers EXPANSION;
    public static CppBaseSpecifiers IMPLICIT;
    public static CppBaseSpecifiers ACCESS_MASK;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppBaseSpecifiersUtil : object {
    [ExtensionAttribute]
public static bool IsVirtual(CppBaseSpecifiers spec);
    [ExtensionAttribute]
public static bool IsExpansion(CppBaseSpecifiers spec);
    [ExtensionAttribute]
public static bool IsImplicit(CppBaseSpecifiers spec);
    [ExtensionAttribute]
public static CppBaseSpecifiers DropExpansion(CppBaseSpecifiers spec);
    [ExtensionAttribute]
public static string BaseSpecifiersToString(CppBaseSpecifiers spec);
    [ExtensionAttribute]
public static CppAccessibility ToAccessibilitySpecifier(CppBaseSpecifiers bp);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppBaseTypeConstraint : object {
    private CppQualType myBaseType;
    public CppBaseTypeConstraint(CppQualType baseType);
    public virtual string ToString();
    public CppQualType GetBaseType();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppBasicBaseDescription`1 : ValueType {
    private CppBaseSpecifiers mySpecifiers;
    private ResolveEntityType myEntity;
    public CppBasicBaseDescription`1(CppBaseSpecifiers specifiers, ResolveEntityType entity);
    public CppBaseSpecifiers Specifiers();
    public ResolveEntityType Entity();
    public sealed virtual bool Equals(CppBasicBaseDescription`1<ResolveEntityType> other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppBinaryStreamReader : ValueType {
    [CompilerGeneratedAttribute]
private Byte* <Input>k__BackingField;
    internal Byte* Input { get; private set; }
    internal CppBinaryStreamReader(Byte* ptr);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal Byte* get_Input();
    [CompilerGeneratedAttribute]
private void set_Input(Byte* value);
    public byte ReadByte();
    public bool ReadBool();
    public int ReadInt();
    public UInt32 ReadUInt();
    public ushort ReadUShort();
    public ulong ReadULong();
    public double ReadDouble();
    public CppSlice ReadSlice();
    public TEnum ReadEnum();
    public CppModuleEntityIndex ReadModuleEntityIndex();
    public CppModuleNameIndex ReadNameIndex();
    public CppModuleExpressionIndex ReadExpressionIndex();
    public CppModuleUnknownInfoIndex ReadUnknownInfoIndex();
    public CppModuleTemplateArgumentIndex ReadTemplargIndex();
    private T ReadUnmanagedType();
    public CppSerializedQualifiedName ReadQualName();
    public CppSerializedModuleTemplateParameters ReadTemplateParameters();
    public CppSerializedModuleType ReadQualType();
    public CppSerializedModuleTypeWithPackExpansion ReadQualTypeWithPackExpansion();
    public CppSerializedTypeIdOrExpression ReadTypeIdOrExpression();
    public CppSerializedSymbolLocation ReadSymbolLocation();
    public CppSerializedFileLocation ReadFileLocation();
    public CppSerializedModuleDescriptor ReadModuleDescriptor();
    public CppLocationAnchor ReadLocationAnchor();
    public void Skip(int size);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppBinaryStreamWriter : ValueType {
    [CompilerGeneratedAttribute]
private Byte* <Output>k__BackingField;
    internal Byte* Output { get; private set; }
    internal CppBinaryStreamWriter(Byte* ptr);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal Byte* get_Output();
    [CompilerGeneratedAttribute]
private void set_Output(Byte* value);
    public void WriteEnum(TEnum e);
    public void Write(T t);
    public void LeaveEmpty(int size);
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppBitfieldSizeUtil : object {
    public static Nullable`1<ulong> GetBitfieldSize(ICppAttribute bitfieldSizeAttribute, CppTypeContext& tc);
    public static Nullable`1<ulong> TryGetBitfieldSize(ICppAttribute bitfieldSizeAttribute);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppBreakStatementResolveEntity : CppGotoStatementResolveEntityBase {
    private static CppQualifiedId ourName;
    public CppQualifiedNamePart Name { get; }
    public CppBreakStatementResolveEntity(ICppResolveEntity parent, CppLocationAnchor anchor);
    private static CppBreakStatementResolveEntity();
    public virtual CppQualifiedNamePart get_Name();
    public virtual CppGotoStatementKind GetKind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppBuilderPool : object {
    private Stack`1<CppNullDeclarationBuilder> myNullDeclarationBuilders;
    private Stack`1<CppNormalDeclaration0Builder> myDeclaration0Builders;
    private Stack`1<CppNormalDeclarator0Builder> myDeclarator0Builders;
    private Stack`1<CppUnresolvedDeclarationSpecifierTypeBuilder> myUnresolvedDeclarationSpecifierTypeBuilders;
    private Stack`1<CppResolvedDeclarationSpecifierTypeBuilder> myResolvedDeclarationSpecifierTypeBuilders;
    private Stack`1<CppParameterDeclarationBuilder> myParameterDeclarationBuilders;
    public CppNullDeclarationBuilder AllocNullDeclarationBuilder(ICppBuilder parent, bool needTypename, bool createParameters);
    public void FreeNullDeclarationBuilder(CppNullDeclarationBuilder builder);
    public CppNormalDeclaration0Builder AllocDeclaration0Builder(ICppBuilder parent, CppSymbolLocation loc);
    public void FreeDeclaration0Builder(ICppDeclaration0Builder builder);
    public CppNormalDeclarator0Builder AllocDeclarator0Builder(CppNormalDeclaration0Builder parent);
    public void FreeDeclarator0Builder(ICppDeclaratorBuilder builder);
    public CppUnresolvedDeclarationSpecifierTypeBuilder AllocUnresolvedDeclarationSpecifierTypeBuilder(CppSymbolTypeIntern typeIntern, CppLanguageDialect dialect);
    public void FreeUnresolvedDeclarationSpecifierTypeBuilder(CppUnresolvedDeclarationSpecifierTypeBuilder builder);
    public CppResolvedDeclarationSpecifierTypeBuilder AllocResolvedDeclarationSpecifierTypeBuilder(ICppResolvedTypeFactory typeIntern);
    public void FreeResolvedDeclarationSpecifierTypeBuilder(CppResolvedDeclarationSpecifierTypeBuilder builder);
    public CppParameterDeclarationBuilder AllocParameterDeclarationBuilder(ICppParameterListBuilder parent);
    public void FreeParameterDeclarationBuilder(CppParameterDeclarationBuilder builder);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppBuilderWithOwnerUtil : object {
    [ExtensionAttribute]
public static CppFileSymbolsCache GetOwnerByBuilder(ICppBuilder b);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppBuilderWithParent : object {
    private ICppBuilder myParent;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    protected CppBuilderWithParent(ICppBuilder parent);
    public abstract virtual void AddChild(CppParserSymbol sym);
    public abstract virtual ICppScopeResolveEntity get_ResolveEntity();
    public virtual ICppBuilder get_Parent();
    public void Init(ICppBuilder parent);
    public void Clear();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppBuilderWithViewPosUtil : object {
    [ExtensionAttribute]
public static CppViewPos GetViewPosByBuilder(ICppBuilder builder);
    [ExtensionAttribute]
private static CppTemplateHeaders GetTemplateParametersByBuilder(ICppBuilder b, CppTemplateParametersBase lastTemplParams);
    [ExtensionAttribute]
public static CppTemplateHeaders CalculateTemplateParameters(ICppBuilder parentBuilder);
    public static CppViewPos CopyTemplateParametersInViewPos(CppViewPos& viewPos);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppBuiltClassType : Enum {
    public int value__;
    public static CppBuiltClassType NONE;
    public static CppBuiltClassType REGULAR;
    public static CppBuiltClassType FORWARD;
    public static CppBuiltClassType REFERENCE_FOUND;
    public static CppBuiltClassType REFERENCE_NOT_FOUND;
    public static CppBuiltClassType PURE_REFERENCE;
    public static CppBuiltClassType OPAQUE_ENUM;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppBuiltinCliTypeTemplateParameter : CppTypeTemplateParameter {
    public CppBuiltinCliTypeTemplateParameter(CppTypeTemplateParameterSymbol sym, CppViewPos& viewPos);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppBuiltinDestructorResolveEntity : CppBuiltinOperatorResolveEntity {
    [CompilerGeneratedAttribute]
private CppQualType <BuiltinType>k__BackingField;
    public CppQualifiedNamePart Name { get; }
    public CppQualType BuiltinType { get; private set; }
    public CppBuiltinDestructorResolveEntity(CppQualType builtinType, CppQualType funcType);
    public virtual CppQualifiedNamePart get_Name();
    [CompilerGeneratedAttribute]
public CppQualType get_BuiltinType();
    [CompilerGeneratedAttribute]
private void set_BuiltinType(CppQualType value);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppBuiltinNames : object {
    public static CppQualifiedId DebugBreak;
    public static CppQualifiedId SizeT;
    public static CppQualifiedId _GUID;
    public static CppQualifiedId TypeInfo;
    public static CppQualifiedId Annotation;
    public static CppQualifiedId BuiltinUnreachable;
    public static CppQualifiedId BuiltinTrap;
    public static CppQualifiedId BuiltinDebugTrap;
    public static CppQualifiedId BuiltinExpect;
    public static CppQualifiedId BuiltinAlloca;
    public static CppQualifiedId BuiltinReturnAddress;
    public static CppQualifiedId BuiltinExtractReturnAddr;
    public static CppQualifiedId BuiltinFrobReturnAddr;
    public static CppQualifiedId BuiltinFrameAddress;
    public static CppQualifiedId BuiltinVaList;
    public static CppQualifiedId BuiltinVaCopy;
    public static CppQualifiedId BuiltinVaStart;
    public static CppQualifiedId BuiltinVaEnd;
    public static CppQualifiedId BuiltinHugeVal;
    public static CppQualifiedId BuiltinHugeValf;
    public static CppQualifiedId BuiltinHugeVall;
    public static CppQualifiedId BuiltinNan;
    public static CppQualifiedId BuiltinNanf;
    public static CppQualifiedId BuiltinNanl;
    public static CppQualifiedId BuiltinNans;
    public static CppQualifiedId BuiltinNansf;
    public static CppQualifiedId BuiltinNansl;
    public static CppQualifiedId BuiltinInf;
    public static CppQualifiedId BuiltinInff;
    public static CppQualifiedId BuiltinInfl;
    public static CppQualifiedId BuiltinIsfinite;
    public static CppQualifiedId BuiltinIsInf;
    public static CppQualifiedId BuiltinIsInfSign;
    public static CppQualifiedId BuiltinIsnan;
    public static CppQualifiedId BuiltinIsnanf;
    public static CppQualifiedId BuiltinIsnanl;
    public static CppQualifiedId BuiltinSignBit;
    public static CppQualifiedId BuiltinPopcount;
    public static CppQualifiedId BuiltinPopcountl;
    public static CppQualifiedId BuiltinPopcountll;
    public static CppQualifiedId BuiltinIsGreater;
    public static CppQualifiedId BuiltinIsGreaterEqual;
    public static CppQualifiedId BuiltinIsLess;
    public static CppQualifiedId BuiltinIsLessEqual;
    public static CppQualifiedId BuiltinIsLessGreater;
    public static CppQualifiedId BuiltinIsUnordered;
    public static CppQualifiedId BuiltinClz;
    public static CppQualifiedId BuiltinCtz;
    public static CppQualifiedId BuiltinClzl;
    public static CppQualifiedId BuiltinCtzl;
    public static CppQualifiedId BuiltinClzll;
    public static CppQualifiedId BuiltinCtzll;
    public static CppQualifiedId BuiltinFfs;
    public static CppQualifiedId BuiltinFfsl;
    public static CppQualifiedId BuiltinFfsll;
    public static CppQualifiedId BuiltinObjectSize;
    public static CppQualifiedId BuiltinMemcpy;
    public static CppQualifiedId BuiltinMemset;
    public static CppQualifiedId BuiltinMemcpyChk;
    public static CppQualifiedId BuiltinMempcpyChk;
    public static CppQualifiedId BuiltinMemmoveChk;
    public static CppQualifiedId BuiltinMemsetChk;
    public static CppQualifiedId BuiltinStrcpyChk;
    public static CppQualifiedId BuiltinStrncpyChk;
    public static CppQualifiedId BuiltinStpcpyChk;
    public static CppQualifiedId BuiltinStrcatChk;
    public static CppQualifiedId BuiltinStrncatChk;
    public static CppQualifiedId BuiltinPrintfChk;
    public static CppQualifiedId BuiltinVPrintfChk;
    public static CppQualifiedId BuiltinFPrintfChk;
    public static CppQualifiedId BuiltinVFPrintfChk;
    public static CppQualifiedId BuiltinSPrintfChk;
    public static CppQualifiedId BuiltinVSPrintfChk;
    public static CppQualifiedId BuiltinSNPrintfChk;
    public static CppQualifiedId BuiltinVSNPrintfChk;
    public static CppQualifiedId BuiltinBZero;
    public static CppQualifiedId BuiltinBSwap16;
    public static CppQualifiedId BuiltinBSwap32;
    public static CppQualifiedId BuiltinBSwap64;
    public static CppQualifiedId BuiltinBSwap128;
    public static CppQualifiedId BuiltinIsConstantEvaluated;
    public static CppQualifiedId BuiltinBitCast;
    public static CppQualifiedId BuiltinAssume;
    public static CppQualifiedId BuiltinLaunder;
    public static CppQualifiedId BuiltinIsPointerInterconvertibleWithClass;
    public static CppQualifiedId IsPointerInterconvertibleWithClass;
    public static CppQualifiedId BuiltinIsCorrespondingMember;
    public static CppQualifiedId IsCorrespondingMember;
    public static CppQualifiedId IntAddr;
    public static CppQualifiedName GlobalNamespace;
    private static CppBuiltinNames();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppBuiltinOffsetOfBuilder : ValueType {
    private CppQualType myTypeArgument;
    private CppQualifiedName myMemberDesignator;
    public sealed virtual void LearnTypeArgument(ICppDeclarationBuilder declBuilder);
    public sealed virtual void LearnMemberDesignator(CppQualifiedNameBuilder& nameBuilder);
    public CppQualType GetTypeArgument();
    public CppQualifiedName GetMemberDesignator();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppBuiltinUtil : object {
    private static CppFunctionFlags SubscriptOpFlags;
    private static CppBuiltinUtil();
    public static void GenerateBuiltins(CppGlobalNamespaceResolveEntity globalNs, ICppResolvedTypeFactory tf);
    public static void GenerateFunctionBodyBuiltins(ICppScopeResolveEntity scope, ICppResolvedTypeFactory tf);
    public static bool ComputeHasBuiltinResult(string id, CppTokenNodeTypeTraits traits, CppRootInclusionContext context);
    public static bool ComputeHasFeatureResult(string id, CppLanguageDialect dialect, CppTokenNodeTypeTraits traits);
    public static string ComputeHasAttributeResult(HasAttributeKind hasAttrKind, CppAttributeName attributeName);
    private static string ComputeHasCAttributeResult(string id, bool hasGnuPrefix);
    private static string ComputeHasCppAttributeResult(string id, bool hasGnuPrefix);
    private static string ComputeHasAttributeResult(string id);
    private static CppDeclaratorResolveEntityPack CreateDeclaratorGroup(ICppScopeResolveEntity scope, CppQualifiedNamePart name);
    [ExtensionAttribute]
private static TDeclarator MarkSupportedBuiltin(TDeclarator declarator);
    private static ICppFunctionDeclaratorResolveEntity GenerateFunction(CppQualifiedNamePart name, CppQualType funcType, ICppScopeResolveEntity scope, CppDeclarationSpecifiers specifiers);
    private static ICppFunctionDeclaratorResolveEntity GenerateFunction(CppQualifiedNamePart name, CppQualType returnType, CppQualType[] parameters, CppGlobalNamespaceResolveEntity scope, ICppResolvedTypeFactory tf, CppDeclarationSpecifiers specifiers, CppEllipsisKind ellipsis);
    private static ICppFunctionDeclaratorResolveEntity GenerateFunction(CppQualifiedNamePart name, CppQualType returnType, CppQualType parameter, CppGlobalNamespaceResolveEntity scope, ICppResolvedTypeFactory tf, CppDeclarationSpecifiers specifiers);
    private static CppQualType GenerateNamedParameter(ICppResolvedTypeFactory tf, CppQualType t, string name);
    private static void GenerateDebugBreak(CppGlobalNamespaceResolveEntity globalNs, ICppResolvedTypeFactory tf);
    private static void GenerateOperatorNew(CppGlobalNamespaceResolveEntity globalNs, ICppResolvedTypeFactory tf);
    private static void GenerateOperatorDelete(CppGlobalNamespaceResolveEntity globalNs, ICppResolvedTypeFactory tf);
    private static ICppGroupedTypeDeclaratorResolveEntity GenerateSizeT(CppGlobalNamespaceResolveEntity globalNs, ICppResolvedTypeFactory tf);
    private static ICppExpression GenerateSizeTOneValue(ICppResolvedTypeFactory tf);
    private static ICppClassResolveEntity GenerateGUID(CppGlobalNamespaceResolveEntity globalNs);
    private static ICppClassResolveEntity GenerateTypeInfo(CppNamespaceResolveEntity ns);
    private static void GenerateAnnotation(CppGlobalNamespaceResolveEntity globalNs, ICppResolvedTypeFactory tf);
    private static void GenerateIsPointerCompatibleWithClassBuiltin(CppGlobalNamespaceResolveEntity globalNs, ICppResolvedTypeFactory tf);
    private static void GenerateIsCorrespondingMemberBuiltin(CppGlobalNamespaceResolveEntity globalNs, ICppResolvedTypeFactory tf);
    private static ICppClassResolveEntity GenerateRsCppNoDeduce(CppGlobalNamespaceResolveEntity globalNs, ICppResolvedTypeFactory tf);
    private static void GenerateIntegerPackBuiltin(CppGlobalNamespaceResolveEntity ns, ICppResolvedTypeFactory tf);
    private static CppNamespaceResolveEntity FindNamespaceChild(CppNamespaceResolveEntity ns, CppQualifiedNamePart name);
    private static ICppClassResolveEntity FindClrClassChild(CppNamespaceResolveEntity ns, CppQualifiedNamePart name);
    private static CppClassTemplateResolveEntityPack FindClrClassTemplateChild(CppNamespaceResolveEntity ns, CppQualifiedNamePart name);
    private static HashMap`2<CppNumericTypeKind, ICppClassResolveEntity> FindClrNumericTypes(CppNamespaceResolveEntity ns);
    private static CppNamespaceResolveEntity GenerateNamespace(CppGlobalNamespaceResolveEntity globalNs, CppQualifiedId name);
    private static CppNamespaceResolveEntity FindOrGenerateNamespace(CppGlobalNamespaceResolveEntity globalNs, CppQualifiedId name);
    private static CppDeclaratorResolveEntityPack GenerateInteriorPtr(CppNamespaceResolveEntity cliNs, ICppResolvedTypeFactory tf);
    private static CppDeclaratorResolveEntityPack GeneratePinPtr(CppNamespaceResolveEntity cliNs, ICppResolvedTypeFactory tf);
    private static CppDeclaratorResolveEntityPack GenerateCliArray(CppNamespaceResolveEntity cliNs, ICppResolvedTypeFactory tf);
    private static void CreateBuiltinTypedef(CppGlobalNamespaceResolveEntity globalNs, CppQualifiedId id, CppQualType type);
    private static void GenerateHlslVectorsAndMatrices(CppGlobalNamespaceResolveEntity globalNs);
    private static void GenerateHlslVectorTypedefs(CppGlobalNamespaceResolveEntity globalNs, int idStart, int typeStart);
    private static void GenerateHlslVectorTypedefs(CppGlobalNamespaceResolveEntity globalNs);
    private static void GenerateHlslMatrixTypedefs(CppGlobalNamespaceResolveEntity globalNs, int idStart, int typeStart);
    private static void GenerateHlslMatrixTypedefs(CppGlobalNamespaceResolveEntity globalNs);
    private static void GenerateHlslTypedefs(CppGlobalNamespaceResolveEntity globalNs);
    private static void AddDeclaratorThroughPack(ICppScopeResolveEntity parent, ICppDeclaratorResolveEntity child);
    private static void GenerateHlslIntrinsicResolveEntities(ICppScopeResolveEntity scope, IEnumerable`1<HlslKnownBuiltinFunction> intrinsics);
    private static void GenerateField(CppClassResolveEntity class_, CppQualifiedId name, CppQualType type);
    private static CppClassResolveEntity GenerateCompleteHlslClass(ICppScopeResolveEntity parent, CppQualifiedId name, CppClassKey classKey);
    private static void GenerateDoubleSubscriptOperator(CppClassResolveEntity class_, CppQualType resourceType, CppQualifiedId fieldName, CppQualifiedId sliceTypeName, CppQualifiedId fieldTypeName, CppQualType indexType);
    private static void PopulateHlslClass(CppClassResolveEntity class_, IEnumerable`1<HlslKnownBuiltinFunction> intrinsics, int subscriptCardinality, bool isReadWrite, bool hasMipsMember, bool hasSampleMember);
    private static ClassGenerationResult GenerateHlslClass(CppQualifiedId name, int params, bool useDefault, CppGlobalNamespaceResolveEntity globalNs, IEnumerable`1<HlslKnownBuiltinFunction> intrinsics, int subscriptCardinality, bool isReadWrite, bool hasMipsMember, bool hasSampleMember);
    private static void GenerateHlslClass(CppQualifiedId name, int params, bool useDefault, CppGlobalNamespaceResolveEntity globalNs, HashSet`1<CppClassTemplateResolveEntityPack> generated, IEnumerable`1<HlslKnownBuiltinFunction> intrinsics, int subscriptCardinality, bool isReadWrite, bool hasMipsMember, bool hasSampleMember);
    private static HashSet`1<CppClassTemplateResolveEntityPack> GenerateHlslTextureClassesWithDefaults(CppGlobalNamespaceResolveEntity globalNs);
    private static void GenerateHlslTextureClassesWithoutDefaults(CppGlobalNamespaceResolveEntity globalNs);
    private static ICppClassResolveEntity GenerateCompleteHlslClass(CppGlobalNamespaceResolveEntity globalNs, CppQualifiedId name, IEnumerable`1<HlslKnownBuiltinFunction> intrinsics, bool isReadWrite, bool hasMipsMember, bool hasSampleMember);
    private static ICppClassResolveEntity GenerateHlslByteAddressBuffer(CppGlobalNamespaceResolveEntity globalNs);
    private static ICppClassResolveEntity GenerateHlslRWByteAddressBuffer(CppGlobalNamespaceResolveEntity globalNs);
    private static ICppClassResolveEntity GenerateRayDesc(CppGlobalNamespaceResolveEntity globalNs);
    private static CppClassResolveEntity GenerateRaytracingAccelerationStructure(CppGlobalNamespaceResolveEntity globalNs);
    private static CppEnumeratorResolveEntity GenerateEnumerator(CppEnumResolveEntity class_, CppEnumWithBaseSymbol symbol, CppQualifiedId name, UInt32 value, CppEnumeratorResolveEntity previous);
    private static void GenerateRayFlags(CppGlobalNamespaceResolveEntity globalNs);
    private static void GenerateRaytracingPipelineFlag(CppGlobalNamespaceResolveEntity globalNs);
    private static void GenerateCommittedStatus(CppGlobalNamespaceResolveEntity globalNs);
    private static void GenerateCandidateType(CppGlobalNamespaceResolveEntity globalNs);
    private static void GenerateRayQuery(CppGlobalNamespaceResolveEntity globalNs);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppC11GenericExpressionBuilder : ValueType {
    private bool myCreateSymbols;
    private ICppExpression myReplacedControllingExpression;
    private CppList`1<CppC11GenericExpressionClause> myReplacedClauses;
    private bool myIsDefault;
    private CppQualType myReplacedType;
    private ICppExpression myReplacedExpression;
    public CppC11GenericExpressionBuilder(bool createSymbols);
    public sealed virtual CppExpressionBuilder CreateExpressionBuilder();
    public sealed virtual ICppDeclarationBuilder CreateInnerDeclarationBuilder(ICppBuilder parent);
    public sealed virtual void LearnControllingExpression(CppExpressionBuilder& builder);
    public sealed virtual void LearnDefault();
    public sealed virtual void LearnType(ICppDeclarationBuilder builder);
    public sealed virtual void LearnExpression(CppExpressionBuilder& builder);
    public sealed virtual void ApplyClause();
    public ICppExpression GetReplacedExpression();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppCachedInitializerState : Enum {
    public int value__;
    public static CppCachedInitializerState INITIAL;
    public static CppCachedInitializerState IN_PROGRESS;
    public static CppCachedInitializerState DONE;
}
internal enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppCachedRequiresClauseState : Enum {
    public int value__;
    public static CppCachedRequiresClauseState INITIAL;
    public static CppCachedRequiresClauseState IN_PROGRESS;
    public static CppCachedRequiresClauseState DONE;
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppCallingConvention : Enum {
    public byte value__;
    public static CppCallingConvention UNSPECIFIED;
    public static CppCallingConvention CDECL;
    public static CppCallingConvention CLRCALL;
    public static CppCallingConvention FASTCALL;
    public static CppCallingConvention STDCALL;
    public static CppCallingConvention THISCALL;
    public static CppCallingConvention VECTORCALL;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCallingConventionBuilder : object {
    private CppCallingConvention myCallingConvention;
    public sealed virtual void LearnCallingConvention(CppCallingConvention cc);
    public sealed virtual CppCallingConvention GetCallingConvention();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCallingConventionUtil : object {
    public static CppCallingConvention CallingConventionFromTokenType(TokenNodeType nodeType);
    [ExtensionAttribute]
public static CppTokenNodeType CallingConventionToTokenType(CppCallingConvention cc);
    [ExtensionAttribute]
public static string CallingConventionToString(CppCallingConvention cc);
    public static Nullable`1<CppCallingConvention> FromGnuAttributeString(string s);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCatchBlockBuilder : CppScopeStatementBuilder`2<CppCatchBlockSymbol, CppCatchBlockResolveEntity> {
    public CppCatchBlockBuilder(ICppBuilder parent);
    protected virtual CppCatchBlockSymbol CreateSymbol(CppSymbolLocation location);
    protected virtual CppCatchBlockResolveEntity CreateResolveEntity(ICppScopeResolveEntity parent, CppLocationAnchor anchor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCatchBlockModuleEntity : CppControlStructureStatementModuleEntity {
    public CppCatchBlockModuleEntity(CppLocationAnchor anchor, CppRegularFunctionModuleEntity function);
    public virtual ICppStatementResolveEntity Import(CppScopeResolveEntityBase targetParent, CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCatchBlockResolveEntity : CppControlStructureScopeResolveEntity {
    private static CppQualifiedId ourName;
    public CppQualifiedNamePart Name { get; }
    public CppCatchBlockResolveEntity(ICppResolveEntity parentScope, CppLocationAnchor loc);
    private static CppCatchBlockResolveEntity();
    public virtual CppQualifiedNamePart get_Name();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCatchBlockResolveEntityWithSubstitution : CppCatchBlockResolveEntity {
    public CppCatchBlockResolveEntityWithSubstitution(ICppResolveEntity parentScope, CppLocationAnchor loc);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCatchBlockSymbol : CppScopeStatementSymbol {
    public CppCatchBlockSymbol(CppSymbolLocation loc);
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCheckPreprocessorSymbols : object {
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void CheckPreprocessorSymbols(IList`1<ICppSymbol> preprocessorSymbols);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppChildAddedToClass : object {
    private ICppMutableClassResolveEntity myCent;
    private ICppResolveEntity myChild;
    public CppChildAddedToClass(ICppMutableClassResolveEntity cent, ICppResolveEntity child);
    public sealed virtual void Rollback();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppChildrenMapUtil : object {
    public static void AddChildToChildrenMap(Dictionary`2& map, CppQualifiedNamePart key, ICppResolveEntity value);
    [ExtensionAttribute]
public static void RemoveChildFromChildrenMap(Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>> map, CppQualifiedNamePart key, ICppResolveEntity value);
    [ExtensionAttribute]
public static CppSmallList`1<ICppResolveEntity> GetChildByName(Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>> map, CppQualifiedNamePart key);
    [ExtensionAttribute]
public static CppList`1<ICppResolveEntity> GetChildren(Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>> map);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassBaseClauseBuilder : object {
    private CppClassBuilder myParent;
    private CppBaseSpecifiers mySpecifiers;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public CppClassBaseClauseBuilder(CppClassBuilder parent);
    public sealed virtual void AddChild(CppParserSymbol sym);
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    public sealed virtual void LearnSpecifier(TokenNodeType tt);
    public sealed virtual void BaseType(CppTwinQualifiedNameBuilder& name, bool expansion);
    public sealed virtual CppTwinQualifiedNameBuilder CreateQualifiedNameBuilder();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassBodyBuilder : object {
    private CppClassBuilder myParent;
    private CppAccessibility myAccessibility;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public CppClassBuilder ClassBuilder { get; }
    public ICppClassSymbol Symbol { get; }
    public CppClassBodyBuilder(CppClassBuilder parent);
    public sealed virtual void AddChild(CppParserSymbol sym);
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    public CppClassBuilder get_ClassBuilder();
    public ICppClassSymbol get_Symbol();
    public sealed virtual void LearnAccessibility(CppAccessibility accessibility);
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual ICppParserSymbol GetClassParentSymbol();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassBuilder : object {
    private ICppDeclarationBuilder myDeclBuilder;
    private CppAccessibility myCliAccessibility;
    private CppSymbolLocation myLocation;
    private CppSymbolLocation myRBraceLocation;
    private CppScopeSymbol myScopeSym;
    private ICppClassSymbol myClassSym;
    private Nullable`1<CppLocationAnchor> myClassSymAnchor;
    private ICppMutableClassResolveEntity myResolveEnt;
    private CppList`1<CppBasicBaseDescription`1<CppQualifiedName>> myEntityBases;
    private CppEnumeratorResolveEntity myLastEnumeratorResolveEnt;
    private bool myFoundImported;
    private bool myHasBody;
    private CppBuiltClassType myClassType;
    private CppClassVirtualSpecifiers myClassVirtualSpecifiers;
    private CppQualifiedName myUnresolvedName;
    private CppQualifiedName myReplacedName;
    private CppClassKey myKey;
    private CppAttributeList myUnresolvedAttributes;
    private CppAttributeList myReplacedAttributes;
    private CppQualType myUnresolvedEnumBaseType;
    private CppQualType myReplacedEnumBaseType;
    private bool myClassHasUEVmRigMethod;
    private List`1<DeferredFuncParsingData> myDeferredFuncParsingData;
    public bool FoundImported { get; }
    public CppClassBuilder(ICppDeclarationBuilder parent);
    public ICppDeclarationBuilder DeclarationBuilder();
    public bool get_FoundImported();
    public void FinishClass();
    public void LearnCliAccessibility(TokenNodeType tt);
    public void LearnLocation(CppSymbolLocation location);
    public void LearnRBraceLocation(CppSymbolLocation location);
    public void LearnKey(CppClassKeyBuilder& keyBuilder);
    public static ICppAttributeListBuilder CreateAttributesBuilder(bool detectionMode);
    public void LearnAttributes(ICppAttributeListBuilder attrBuilder);
    public void LearnTrailingAttributes(ICppAttributeListBuilder attrBuilder);
    public void LearnAttributeFromInsideClassBody(ICppAttribute unresolved, ICppAttribute replaced);
    public void LearnName(CppTwinQualifiedNameBuilder& nameBuilder);
    public void LearnBaseClauseStart(bool hasBaseClause, bool hasBody, bool isStandalone, bool isFriend);
    public void LearnBodyStart(bool hasBody);
    public void LearnClassVirtualSpecifiers(CppClassVirtualSpecifiers specifiers);
    public void LearnUERigVmMethod();
    public void AddMember(CppParserSymbol sym, ICppResolveEntity ent);
    public void AddBase(CppBaseSpecifiers specifiers, CppQualifiedName unresolvedQualName, CppQualifiedName replacedQualName);
    public void LearnEnumBaseType(ICppUnresolvedDeclarationSpecifierTypeBuilder typeBuilder, ICppResolvedDeclarationSpecifierTypeBuilder replacedTypeBuilder);
    public bool ClassAllowsDeclarators();
    public void SetUsedAsType();
    public void UpdateLazyMergingFlags();
    public ICppMutableClassResolveEntity GetClassResolveEntity();
    public CppBuiltClassType GetBuiltType();
    public ICppClassSymbol GetClassSymbol();
    public CppLocationAnchor GetClassSymbolAnchor();
    public CppQualifiedName GetUnresolvedQualifiedName();
    public CppQualifiedName GetReplacedQualifiedName();
    public CppClassKey GetClassKey();
    public bool HasBody();
    public bool OpaqueEnumHasBody();
    public bool HasUEVmRigMethod();
    public bool HasNoDeferredFuncParsingDataYet();
    public bool AddDeferredFuncParsingData(ICppFunctionDeclaratorBuilder funcBuilder, object payload);
    public CppClassBuilder GetOutermostClassIfNested();
    [CanBeNullAttribute]
public List`1<DeferredFuncParsingData> GetDeferredFuncParsingData();
    public ValueTuple`2<CppEnumeratorSymbol, CppEnumeratorResolveEntity> BuildAndAddEnumerator(CppSymbolLocation loc, string name, ICppAttributeListBuilder ab, CppTwinExpressionBuilder eb);
    public ValueTuple`2<CppEnumeratorSymbol, CppEnumeratorResolveEntity> BuildAndAddEnumerator(CppSymbolLocation loc, string name, ICppAttributeListBuilder ab);
    private ValueTuple`2<CppEnumeratorSymbol, CppEnumeratorResolveEntity> BuildAndAddEnumeratorImpl(CppSymbolLocation loc, string name, ICppAttributeListBuilder ab, ICppExpression unresolvedInitializer, ICppExpression resolvedInitializer);
    private ValueTuple`2<CppEnumeratorSymbol, CppEnumeratorResolveEntity> BuildEnumeratorImpl(CppSymbolLocation loc, CppQualifiedId name, ICppAttributeListBuilder ab, ICppExpression unresolvedInitializer, ICppExpression resolvedInitializer);
    private bool CheckWhetherInjectedName(ICppScopeResolveEntity scope, CppLocationAnchor anchor, ICppResolveEntity& e);
    private static bool AreSymbolsSortedByOffset(ICppSymbol[] symbols);
    private static void GenerateUEVmRigMacro(ICppMutableClassResolveEntity cent, CppGlobalNamespaceBuilder rootBuilder, CppSymbolLocation rbraceLocation);
    internal static void AddClassChildToBuilder(ICppDeclarationBuilder b, CppParserSymbol sym);
    private static ICppClassLandingPad FindClassLandingPad(ICppBuilder b);
    [CompilerGeneratedAttribute]
internal static void <GenerateUEVmRigMacro>g__PresentParameter|68_0(StringBuilder replacementBuilder, ICppPresenter presenter, CppParameterDeclaratorData element);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassBuilderUtil : object {
    public static CppQualifiedNamePart GetRealNameOfClassForPack(CppTemplateId tid, CppClassTemplateResolveEntityPack pack, ICppScopeResolveEntity parentScope, CppLocationAnchor currentAnchor);
    public static bool CanAddSymbolToClass(ICppMutableClassResolveEntity ent, ICppClassSymbol symbol, CppQualifiedNamePart name);
    public static ICppMutableClassResolveEntity CreateClassOrEnumResolveEntity(ICppResolveEntityParent parent, ICppClassSymbol sym, CppLocationAnchor anchor, CppQualifiedNamePart name, CppAttributeList attributes, string moduleId);
    public static ICppClassResolveEntity FindClassResolveEntityInPack(ICppResolvedTypeFactory tf, IEnumerable`1<ICppClassResolveEntity> specializations, CppQualifiedNamePart name);
    public static FrugalLocalList`1<ICppResolveEntity> FindPackCandidatesInNamespace(ICppScopeResolveEntity structuralParent, CppLocationAnchor anchor, CppQualifiedNamePart packName, FindPackOptions options);
    public static CppClassTemplateResolveEntityPack FindPackInNamespace(ICppScopeResolveEntity structuralParent, CppLocationAnchor anchor, CppQualifiedNamePart packName, FindPackOptions options);
    public static FindPackOptions GetFindPackOptions(bool findExisting);
    public static CppClassTemplateResolveEntityPack FindOrCreatePackInNamespace(ICppScopeResolveEntity structuralParent, CppLocationAnchor anchor, CppQualifiedNamePart packName, bool findExisting, string moduleId);
    public static NameAndStructuralParent CalculateNameAndStructuralParentForClass(ICppScopeResolveEntity lexicalParent, ICppClassSymbol sym, CppQualifiedName replacedName, CppLocationAnchor currentAnchor, List`1<CppTemplateParametersBase> templParams);
    public static ICppMutableClassResolveEntity CreateClassInsideNameAndStructuralParent(NameAndStructuralParent np, ICppScopeResolveEntity lexicalParent, ICppClassSymbol symbol, CppLocationAnchor anchor, bool explicitInstantiation, CppAttributeList replacedAttributes, CppQualType replacedEnumBaseType, string moduleId, Boolean& foundImportedClass);
    public static bool HandleReferenceToAnonymousStructure(ICppMutableClassResolveEntity embracingClass, ICppFileResolveEntitiesCache resolveCache, CppQualifiedNamePart referencedType);
    private static void HandleAnonymousStructuresInCCode(ICppMutableClassResolveEntity embracingClass, ICppClassResolveEntity entity, CppLocationAnchor anchor);
    public static ICppMutableClassResolveEntity CreateClassResolveEntity(ICppScopeResolveEntity lexicalParent, ICppClassSymbol symbol, CppQualifiedName replacedName, CppLocationAnchor anchor, List`1<CppTemplateParametersBase> templParams, bool explicitInstantiation, CppAttributeList replacedAttributes, CppQualType replacedEnumBaseType, string moduleId, Boolean& foundImportedClass);
    public static ICppResolveEntity FindFwdClassResolveEntity(ICppScopeResolveEntity parentScope, CppLocationAnchor anchor, CppQualifiedName name, CppClassTag tag);
    private static bool IsFwdClassNotStandalone(ICppSymbol sym);
    private static ICppMutableClassResolveEntity TryAddSymbolToPack(ICppClassSymbol sym, CppQualifiedNamePart realName, CppClassTemplateResolveEntityPack pack, CppLocationAnchor currentAnchor, CppAttributeList attributes);
    private static ICppMutableClassResolveEntity FindOrCreateClassResolveEntityInNamespace(ICppScopeResolveEntity lexicalParentScope, ICppScopeResolveEntity parentScope, CppLocationAnchor currentAnchor, CppQualifiedNamePart name, ICppClassSymbol sym, bool explicitInstantiation, bool findExisting, CppAttributeList attributes, CppQualType replacedEnumBaseType, string moduleId, Boolean& foundImportedClassWithSymbol);
    private static bool HasCompatibleOwningModule(ICppClassResolveEntity existedClass, ICppClassSymbol addingSymbol, string owningModuleOfAddingSymbol, CppResolveEntitiesDetachedData detachedData, Boolean& changeOwningModule);
    private static void AddPackToParentIfNeeded(ICppScopeResolveEntity parentScope, CppLocationAnchor currentAnchor, bool findExisting, bool packIsImplicitlyImported, CppTemplateId tid, CppClassTemplateResolveEntityPack pack);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static CppClassOrEnumModuleEntity GetImportedModuleEntity(ICppClassResolveEntity clsEnt);
    public static void AddAnonymousClassToParentScope(ICppMutableClassResolveEntity cent, ICppScopeResolveEntity parentScope);
    public static CppEnumeratorResolveEntity CreateEnumeratorResolveEntity(ICppMutableClassResolveEntity enumScope, ICppExpression initializer, CppEnumeratorSymbol symbol, CppLocationAnchor anchor, CppEnumeratorResolveEntity previousEnumerator, CppAttributeList attributes);
    public static void InitGenerated(CppClassOrEnumData classData, ICppClassOrDelegateSymbol classSymbol, CppLocationAnchor classAnchor, CppQualifiedNamePart name);
    public static ValueTuple`2<CppEnumResolveEntity, CppEnumWithBaseSymbol> GenerateEnumResolveEntity(ICppScopeResolveEntity parent, CppQualifiedNamePart name, CppClassKey classKey, CppLocationAnchor classAnchor, CppQualType underlyingType);
    public static CppClassResolveEntity GenerateClassResolveEntity(ICppScopeResolveEntity parent, CppQualifiedId name, CppClassKey classKey);
    public static CppClassResolveEntity GenerateClassResolveEntity(ICppScopeResolveEntity parent, CppQualifiedId name, CppClassKey classKey, CppLocationAnchor classAnchor);
    [CompilerGeneratedAttribute]
internal static string <HasCompatibleOwningModule>g__GetOwningModule|18_0(ICppResolveEntity clazz, CppResolveEntitiesDetachedData detachedData);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassConstructors : CppCompletionDecoration {
    private ICppClassOrUndeterminedSpecializationResolveEntity myResolveEntity;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    public CppQualifiedNamePart Name { get; }
    public CppClassConstructors(CppQualifiedNamePart customName, ICppClassOrUndeterminedSpecializationResolveEntity resolveEntity);
    [CompilerGeneratedAttribute]
public virtual CppQualifiedNamePart get_Name();
    public ICppClassOrUndeterminedSpecializationResolveEntity GetResolveEntity();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassConstructorsAreCached : object {
    private ICppMutableClassResolveEntity myCent;
    public CppClassConstructorsAreCached(ICppMutableClassResolveEntity cent);
    public sealed virtual void Rollback();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassData : CppClassOrEnumData {
    private CppList`1<CppBasicBaseDescription`1<CppQualifiedName>> myRawBases;
    private CppBasicBaseDescription`1[] myCachedBases;
    private CppCachedValue`1<CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>>> myCachedNonDependentBases;
    private CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> myPartialCliBases;
    private CppDeclaratorResolveEntityPack myConversions;
    private CppConstructorDeclaratorResolveEntityPack myConstructors;
    private CppConstructorDeclaratorResolveEntityPack myStaticConstructors;
    private CppDeclaratorResolveEntityPack myDestructors;
    private CppDeclaratorResolveEntityPack myCliFinalizers;
    private CppCachedReference`1<IEnumerable`1<ICppResolveEntity>> myCachedClassConstructors;
    private CppCachedReference`1<IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity>> myCachedClassConversions;
    private CppList`1<ICppClassResolveEntity> myAnonymousClasses;
    private Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppDeclaratorResolveEntityPack>> myAnonymousSubclassMembers;
    private Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppFunctionDeclaratorResolveEntity>> myFriendFunctions;
    private Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity>> myFriendClasses;
    private CppSmallList`1<ICppDependentTypeResolveEntity> myFriendTypes;
    private object myAggregateMembers;
    private CppClassTraits myTraits;
    private ImportPhase modreq(System.Runtime.CompilerServices.IsVolatile) myImportPhase;
    protected CppClassData(CppQualifiedNamePart name, CppClassKey key);
    protected CppClassData(CppQualifiedNamePart name, CppClassKey key, CppList`1<ClassPartDescription> parts);
    public virtual CppClassVirtualSpecifiers GetClassVirtualSpecifiers();
    public virtual bool HasAbstractSpecifier();
    public virtual bool IsFinal();
    public virtual bool IsSealed();
    public virtual bool IsFinalOrSealed();
    public virtual bool Exported();
    protected virtual void SetExported();
    public virtual CppDeclaratorResolveEntityPack GetOrCreateConversions(CppLocationAnchor anchor);
    public virtual CppDeclaratorResolveEntityPack GetOrCreateConstructors(CppLocationAnchor anchor);
    public virtual CppDeclaratorResolveEntityPack GetOrCreateStaticConstructors(CppLocationAnchor anchor);
    public virtual CppDeclaratorResolveEntityPack GetOrCreateDestructors(CppLocationAnchor anchor);
    public virtual CppDeclaratorResolveEntityPack GetOrCreateCliFinalizers(CppLocationAnchor anchor);
    public virtual ICppDeclaratorResolveEntityPack GetConversions();
    public virtual ICppDeclaratorResolveEntityPack GetConstructors();
    public virtual ICppDeclaratorResolveEntityPack GetStaticConstructors();
    public virtual ICppDeclaratorResolveEntityPack GetDestructors();
    public virtual ICppDeclaratorResolveEntityPack GetCliFinalizers();
    public virtual IEnumerable`1<ICppResolveEntity> GetClassConstructors();
    public virtual IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity> GetClassConversions(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    public virtual CppConstructorDeclaratorResolveEntityPack EnsureConstructorExists(CppLocationAnchor anchor);
    public static CppQualifiedNamePart FriendEntityName(ICppResolveEntity ent);
    public virtual void AddFriend(ICppFunctionDeclaratorResolveEntity dent);
    public virtual void AddFriend(ICppTypeTemplateInstantiationResolveEntity cent);
    public virtual void AddFriend(ICppDependentTypeResolveEntity type);
    public virtual CppSmallList`1<ICppFunctionDeclaratorResolveEntity> GetFriendFunctions(CppQualifiedNamePart name);
    public virtual ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppFunctionDeclaratorResolveEntity>> GetFriendFunctions();
    public virtual CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity> GetFriendClasses(CppQualifiedNamePart name);
    public virtual ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity>> GetFriendClasses();
    public virtual CppSmallList`1<ICppDependentTypeResolveEntity> GetFriendDependentTypes();
    public virtual CppList`1<ICppResolveEntity> GetAggregateMembers();
    public sealed virtual bool HasFixedEnumUnderlyingType();
    public virtual bool HasImmediateVirtualFunctions();
    public virtual bool HasInheritingConstructors();
    public virtual CppBasicBaseDescription`1[] GetBases();
    public virtual CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> GetNonDependentBases();
    private void WaitWhileImportingFinish();
    public virtual void SetBases(CppList`1<CppBasicBaseDescription`1<CppQualifiedName>> bases);
    internal void SetResolvedBasesWithoutJournaling(CppBasicBaseDescription`1[] bases, CppViewPos viewPosForBases);
    public virtual void ResolveBases();
    public virtual void GenerateImplicitDisposableIfNeeded();
    public virtual CppList`1<ICppClassResolveEntity> AnonymousClasses();
    public virtual void AddAnonymousClass(ICppClassResolveEntity cent);
    public virtual CppSmallList`1<ICppDeclaratorResolveEntityPack> GetAnonymousSubclassMembers(CppQualifiedNamePart name);
    public virtual void RegisterAnonymousSubclassMembers(CppList`1<ICppDeclaratorResolveEntityPack> packs);
    public virtual bool IsAbstract();
    public virtual bool IsPolymorphic();
    public virtual bool HasVirtualDestructor();
    public virtual bool IsTriviallyCopyable(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool HasTrivialDestructor(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool HasNothrowDestructor(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool IsTrivial(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool IsStandardLayout(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool IsPOD(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool HasTrivialConstructor();
    public virtual bool HasUniqueObjectRepresentations(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual CppQualType GetEnumUnderlyingType();
    public virtual void SetEnumUnderlyingType(CppQualType t, CppLocationAnchor anchor);
    public virtual void SetResolvedEnumUnderlyingType(CppQualType t);
    public sealed virtual void MergeNonMergedSymbols();
    public virtual void Journaling_RollbackCachedClassConstructors();
    protected virtual void DumpBases(CppIndentationStringBuilder tw);
    protected virtual void DumpVirtualSpecifiers(CppIndentationStringBuilder tw);
    protected virtual void DumpSpecialMembers(CppIndentationStringBuilder tw);
    protected virtual void DumpAnonymousClasses(CppIndentationStringBuilder tw);
    protected virtual void DumpFriends(CppIndentationStringBuilder tw);
    protected virtual void SetVirtualSpecifiers(CppClassVirtualSpecifiers specifiers);
    protected virtual List`1<ICppResolveEntity> CalculateSortedMembers();
    public virtual void ForceImporting();
    private ImportingStatus ForceImportingImpl();
    protected virtual void MarkAsReadyToImport(CppJournal journal);
    private static CppBasicBaseDescription`1[] ImportBases(CppBasicBaseDescription`1[] source, CppModuleImportingContext ctx);
    private static CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> ImportNonDependentBases(CppBasicBaseDescription`1[] source, CppModuleImportingContext ctx);
    private static List`1<ICppResolveEntity> ImportChildren(ICppClassModuleEntityChild[] source, ICppMutableClassResolveEntity targetClass, CppModuleImportingContext ctx, CppList`1& secondPassMembers);
    private void ImportAnonymousClasses(CppSmallArray`1<CppClassOrEnumModuleEntity> source, CppJournal journal, ICppMutableClassResolveEntity that, CppModuleImportingContext ctx);
    private void ImportFriends();
    private CppBasicBaseDescription`1[] CalculateBases();
    private CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> CalculateNonDependentBases();
    private bool IsComplete();
    private CppList`1<ICppResolveEntity> CalculateAggregateMembers();
    private void EnsureStaticConstructorExists(CppLocationAnchor anchor);
    private void RevertSymbolMerging();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassifyEntVisitor : object {
    [CompilerGeneratedAttribute]
private static CppClassifyEntVisitor <Instance>k__BackingField;
    public static CppClassifyEntVisitor Instance { get; }
    private static CppClassifyEntVisitor();
    [CompilerGeneratedAttribute]
public static CppClassifyEntVisitor get_Instance();
    public sealed virtual CppQualRefEntities Visit(ICppClassResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(ICppStatementResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(ICppRequiresExpressionScopeResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(CppRequiresExpressionItemResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(ICppParameterListResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(ICppDeclaratorResolveEntity ent);
    public sealed virtual CppQualRefEntities Visit(ICppConceptDefinitionResolveEntity ent);
    public sealed virtual CppQualRefEntities Visit(ICppEnumeratorResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(CppNamespaceResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(CppNamespaceAliasResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(CppUsingDeclarationResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(CppClassTemplateResolveEntityPack e);
    public sealed virtual CppQualRefEntities Visit(ICppTypeTemplateParameter e);
    public sealed virtual CppQualRefEntities Visit(ICppTypeTemplateParameterPack e);
    public sealed virtual CppQualRefEntities Visit(ICppExpressionTemplateParameter e);
    public sealed virtual CppQualRefEntities Visit(ICppExpressionTemplateParameterPack e);
    public sealed virtual CppQualRefEntities Visit(ICppTemplateTemplateParameter e);
    public sealed virtual CppQualRefEntities Visit(ICppTemplateTemplateParameterPack e);
    public sealed virtual CppQualRefEntities Visit(ICppGenericParameter e);
    public sealed virtual CppQualRefEntities Visit(CppDependentResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(CppDependentDecltypeResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(CppDependentAutoTypeResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(CppDependentFunctionReturnAutoTypeResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(CppDependentDeducedClassTypePlaceholder e);
    public sealed virtual CppQualRefEntities Visit(CppUsingDeclarationResolveEntityWithSubstitution e);
    public sealed virtual CppQualRefEntities Visit(CppUndeterminedSpecializationResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(CppTemplateTemplateParameterWithAppliedArgumentsResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(CppDecltypeResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(CppTypeOfTypeResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(ICppDeclaratorResolveEntityPack e);
    public sealed virtual CppQualRefEntities Visit(CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(CppUndeterminedTemplateVariableSpecializationResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(CppSuperResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(AbstractBuiltinResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(ICppFunctionTemplateDeclaratorResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(ICppTypeTemplateDeclaratorResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(ICppVariableTemplateDeclaratorResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(CppDependencyKillerResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(ICppCxxCliPropertySetResolveEntity ent);
    public sealed virtual CppQualRefEntities Visit(ICppDeductionGuide e);
    public sealed virtual CppQualRefEntities Visit(CppUsingEnumEnumeratorResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(HlslBuiltinFunctionResolveEntity e);
    public sealed virtual CppQualRefEntities Visit(BlockShadersResolveEntity e);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassInheritance : object {
    public static bool IsDerivedFrom(ICppClassOrGenericParameterResolveEntity derived, ICppClassOrGenericParameterResolveEntity base, CppViewPos& viewPos);
    public static IEnumerable`1<CppQualifiedNamePart> GetConversionNames(ICppClassResolveEntity cent, CppViewPos& viewPos);
    [ExtensionAttribute]
public static IEnumerable`1<ICppClassResolveEntity> GetAllNonDependentBases(ICppClassResolveEntity cent, CppViewPos& viewPos);
    public static IList`1<ICppClassResolveEntity> GetAllVirtualNonDependentBases(ICppClassResolveEntity clsEnt, CppViewPos& viewPos);
    public static IList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> GetNonDependentDerivationChain(ICppClassResolveEntity derived, ICppClassResolveEntity base, CppViewPos& viewPos);
    public static CppImplicitBasesType CalculateImplicitBasesType(ICppClassResolveEntity cent);
    public static ICppClassResolveEntity GetImplicitBaseResolveEntity(CppImplicitBasesType implicitBaseType, ICppFileResolveEntitiesCache resolveCache);
    public static CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> GetNonDependentBasesFromBases(CppBasicBaseDescription`1[] bases, CppViewPos& scopeForBases, CppImplicitBasesType implicitBaseType, ICppFileResolveEntitiesCache resolveCache);
    public static bool NeedImplicitDisposable(ICppClassResolveEntity cent, CppViewPos& vp);
    [ExtensionAttribute]
public static CppBasesDependenciesInfo GetBasesDependenciesInfo(ICppClassResolveEntity cent, CppViewPos& viewPos);
    public static CppDependentInfo ConvertDepInfo(CppBasesDependenciesInfo dinfo);
    private static bool VisitNonDependentBasesRec(ICppClassOrGenericParameterResolveEntity current, CppViewPos& viewPos, Visitor& visitor);
    [ExtensionAttribute]
private static ICollection`1<ICppClassResolveEntity> AllNonDependentBases(ICppClassResolveEntity clazz, CppViewPos& viewPos);
    private static bool IsFullDependent(CppBasesDependenciesInfo r);
    private static CppBasesDependenciesInfo GetBasesDependenciesInfoRec(JetHashSet`1<CppQualType> visited, CppQualType current, CppViewPos& viewPos);
    private static bool NonDependentDerivationChainRec(IList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> trace, JetHashSet`1<ICppClassResolveEntity> seen, ICppClassResolveEntity current, ICppClassResolveEntity target, CppViewPos& viewPos, bool skipPrivate);
    private static IList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> NonDepedendentDerivationChain(ICppClassResolveEntity current, ICppClassResolveEntity target, CppViewPos& viewPos);
    private static void GetClassConversionNames(ICppClassResolveEntity clazz, JetHashSet`1<CppQualifiedNamePart> out);
    private static bool HasCliClassBase(CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> list);
    private static bool HasCliDelegateBase(CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> list);
    private static bool FindBase(CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> list, ICppClassResolveEntity base);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassInheritanceInfo : object {
    public ICppClassResolveEntity Entity;
    public bool IsCliInterface;
    public bool IsCliManagedClass;
    public bool IsIDisposable;
    private bool myIsValid;
    private bool myIsComplete;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myIsBasesReady;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myIsInheritanceReady;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myIsHideSetReady;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myIsVisibleMethodsReady;
    private bool myHasImmediateDependentBases;
    private List`1<CppBasicBaseDescription`1<CppClassInheritanceInfo>> myBases;
    private HashSet`1<CppClassInheritanceInfo> myAllBases;
    private HashSet`1<CppClassInheritanceInfo> myVirtualBases;
    private Dictionary`2<ICppGroupedFunctionDeclaratorResolveEntity, CppMethodInheritanceInfo> myMethods;
    private Dictionary`2<CppMethodInheritanceInfo, CppVTableEntryInfo> myVTable;
    private List`1<CppVTableEntryInfoDeferredImplement> myDeferredImplements;
    private HashSet`1<CppMethodInheritanceInfo> myHideSet;
    private Dictionary`2<CppMethodNameKey, CppSmallList`1<CppMethodInheritanceInfo>> myVisibleMethods;
    public bool IsValid { get; }
    public bool IsComplete { get; }
    public bool IsImportedClrClass { get; }
    public IEnumerable`1<CppBasicBaseDescription`1<CppClassInheritanceInfo>> Bases { get; }
    public IReadOnlyDictionary`2<ICppGroupedFunctionDeclaratorResolveEntity, CppMethodInheritanceInfo> Methods { get; }
    public IReadOnlyDictionary`2<CppMethodInheritanceInfo, CppVTableEntryInfo> VTable { get; }
    public IEnumerable`1<CppVTableEntryInfoDeferredImplement> DeferredImplements { get; }
    public ISet`1<CppClassInheritanceInfo> AllBases { get; }
    public ISet`1<CppClassInheritanceInfo> AllVirtualBases { get; }
    public IReadOnlyDictionary`2<CppMethodNameKey, CppSmallList`1<CppMethodInheritanceInfo>> VisibleMethods { get; }
    private CppClassInheritanceInfo(ICppClassResolveEntity entity);
    public bool get_IsValid();
    public bool get_IsComplete();
    public bool get_IsImportedClrClass();
    public IEnumerable`1<CppBasicBaseDescription`1<CppClassInheritanceInfo>> get_Bases();
    public IReadOnlyDictionary`2<ICppGroupedFunctionDeclaratorResolveEntity, CppMethodInheritanceInfo> get_Methods();
    public IReadOnlyDictionary`2<CppMethodInheritanceInfo, CppVTableEntryInfo> get_VTable();
    public IEnumerable`1<CppVTableEntryInfoDeferredImplement> get_DeferredImplements();
    public ISet`1<CppClassInheritanceInfo> get_AllBases();
    public ISet`1<CppClassInheritanceInfo> get_AllVirtualBases();
    public IReadOnlyDictionary`2<CppMethodNameKey, CppSmallList`1<CppMethodInheritanceInfo>> get_VisibleMethods();
    public static CppClassInheritanceInfo GetCached(ICppClassResolveEntity entity);
    public bool IsAbstract();
    public List`1<ICppGroupedFunctionDeclaratorResolveEntity> GetPureSlotMethods(bool cliInterface);
    private bool EntryIsPure(CppVTableEntryInfo entry);
    public bool IsPotentialVirtualBaseSlot(CppMethodInheritanceInfo slot);
    private bool CacheBases();
    private void Journaling_RollbackBases();
    private bool CacheInheritance();
    private void Journaling_RollbackInheritance();
    private Builder CreateBuilder();
    private void CollectMethods(ICppClassResolveEntity entity);
    private void CollectMethods(ICppDeclaratorResolveEntityPack pack, bool filterOutImplicitlyGeneratedMembers);
    private void CollectMethods(CppDeclaratorResolveEntityPack pack, bool filterOutImplicitlyGeneratedMembers);
    private void CollectMethods(ICppGroupedFunctionDeclaratorResolveEntity decl);
    private void InheritVTables();
    private bool CacheVisibleMethods();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassInstantiationKey : ValueType {
    public ICppTemplateArgument[] TemplateArguments;
    public int HashCode;
    public CppClassInstantiationKey(ICppTemplateArgument[] templargs, int hashCode);
    public CppClassInstantiationKey(ICppTemplateArgument[] templargs);
    public sealed virtual bool Equals(CppClassInstantiationKey other);
    public virtual int GetHashCode();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassKey : Enum {
    public byte value__;
    public static CppClassKey NONE;
    public static CppClassKey CLASS;
    public static CppClassKey STRUCT;
    public static CppClassKey UNION;
    public static CppClassKey __INTERFACE;
    public static CppClassKey HLSL_INTERFACE;
    public static CppClassKey ENUM;
    public static CppClassKey ENUM_CLASS;
    public static CppClassKey ENUM_STRUCT;
    public static CppClassKey REF_CLASS;
    public static CppClassKey REF_STRUCT;
    public static CppClassKey VALUE_CLASS;
    public static CppClassKey VALUE_STRUCT;
    public static CppClassKey INTERFACE_CLASS;
    public static CppClassKey INTERFACE_STRUCT;
    public static CppClassKey BS_RESOURCE;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassKeyBuilder : ValueType {
    private State myKey;
    public void LearnToken(TokenNodeType tt);
    public CppClassKey GetClassKey();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassKeyUtil : object {
    [ExtensionAttribute]
public static bool IsStronglyTypedEnum(CppClassKey key);
    [ExtensionAttribute]
public static bool IsEnum(CppClassKey key);
    [ExtensionAttribute]
public static bool IsClass(CppClassKey key);
    [ExtensionAttribute]
public static bool IsClassOrUnion(CppClassKey key);
    [ExtensionAttribute]
public static bool IsClassTypeKey(CppClassKey key);
    [ExtensionAttribute]
public static CppClassTag ClassKeyAsClassTag(CppClassKey key);
    [ExtensionAttribute]
public static string ClassKeyAsString(CppClassKey key);
    [ExtensionAttribute]
public static bool IsCliClassOrInterface(CppClassKey key);
    [ExtensionAttribute]
public static bool IsCliRefClassOrInterface(CppClassKey key);
    [ExtensionAttribute]
public static bool IsCliNonInterfaceClass(CppClassKey key);
    [ExtensionAttribute]
public static bool IsCliInterface(CppClassKey key);
    [ExtensionAttribute]
public static bool IsCliRefClass(CppClassKey key);
    [ExtensionAttribute]
public static bool IsCliValueClass(CppClassKey key);
    [ExtensionAttribute]
public static bool IsAnyInterface(CppClassKey key);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassLazyMergingInfo : ValueType {
    private static UInt32 CONTAINS_OTHER_CLASSES_MASK;
    private static UInt32 IS_VALID_MASK;
    private UInt32 myAnchorDelta;
    public CppSmallList`1<ICppClassSymbol> SymbolsFromName;
    public CppSmallList`1<ICppClassSymbol> SymbolsFromBody;
    public int AnchorDelta { get; }
    public bool ContainsOtherClasses { get; }
    public CppClassLazyMergingInfo(CppSmallList`1<ICppClassSymbol> symbolsFromName, CppSmallList`1<ICppClassSymbol> symbolsFromBody, int anchorDelta, bool hasOtherClassesInside);
    private static CppClassLazyMergingInfo();
    public bool IsValid();
    public int get_AnchorDelta();
    public bool get_ContainsOtherClasses();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassLinkageEntity : CppLinkageEntity {
    [CompilerGeneratedAttribute]
private CppClassKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private CppClassVirtualSpecifiers <VirtualSpecifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CppQualType> <EnumUnderlyingType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAnonymousClass>k__BackingField;
    public CppClassKey Key { get; }
    public CppClassVirtualSpecifiers VirtualSpecifiers { get; }
    public Nullable`1<CppQualType> EnumUnderlyingType { get; }
    public bool IsAnonymousClass { get; }
    public CppQualifiedName DebugQualifiedName { get; }
    public CppClassLinkageEntity(CppQualifiedNamePart name, ICppLinkageEntity parent, CppClassKey key, CppClassVirtualSpecifiers virtualSpecifiers, Nullable`1<CppQualType> enumUnderlyingType, bool isAnonymousClass);
    [CompilerGeneratedAttribute]
public CppClassKey get_Key();
    [CompilerGeneratedAttribute]
public CppClassVirtualSpecifiers get_VirtualSpecifiers();
    [CompilerGeneratedAttribute]
public Nullable`1<CppQualType> get_EnumUnderlyingType();
    [CompilerGeneratedAttribute]
public bool get_IsAnonymousClass();
    public virtual CppQualifiedName get_DebugQualifiedName();
    public virtual Result Accept(ICppDependentLinkageEntityVisitor`1<Result> visitor);
    public virtual Result Accept(ICppLinkageEntityVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassLinkageEntityInstantiation : CppClassLinkageEntity {
    private ICppLinkageEntity myClassWithoutSubstitution;
    public CppClassLinkageEntityInstantiation(CppQualifiedNamePart name, ICppLinkageEntity parent, CppClassKey key, CppClassVirtualSpecifiers virtualSpecifiers, ICppLinkageEntity classWithoutSubstitution, bool isAnonymousClass);
    public ICppLinkageEntity GetClassWithoutSubstitution();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassModuleEntity : CppClassOrEnumModuleEntity {
    private static int DefinitionSerializedSize;
    public CppClassVirtualSpecifiers VirtualSpecifiers;
    public bool IsAnonymousClass;
    public CppBasicBaseDescription`1[] Bases;
    public CppBasicBaseDescription`1[] NonDependentBases;
    public ICppClassModuleEntityChild[] Children;
    public CppSmallArray`1<ICppModuleEntity> Friends;
    public CppSmallArray`1<CppClassOrEnumModuleEntity> AnonymousClasses;
    public CppClassModuleEntity(int index, ICppScopeModuleEntity parent, CppClassKey key, CppAccessibility accessibility, bool isAnonymousClass, bool exported);
    internal CppClassModuleEntity(int index);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassModuleEntityKind : Enum {
    public int value__;
    public static CppClassModuleEntityKind REGULAR;
    public static CppClassModuleEntityKind REFERENTIAL;
    public static CppClassModuleEntityKind EXPLICIT_INSTANTIATION;
    public static CppClassModuleEntityKind REEXPORTED;
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassNonStaticFieldsView : ValueType {
    private ICppClassResolveEntity myClass;
    public CppClassNonStaticFieldsView(ICppClassResolveEntity clazz);
    public Enumerator GetEnumerator();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassOrEnumData : object {
    protected CppQualifiedNamePart myName;
    protected CppTemplateId myFirstDeclarationTemplateName;
    protected CppClassKey myClassKey;
    protected CppList`1<ClassPartDescription> myParts;
    protected CppAttributeList myAttributes;
    protected CppLocationAnchor myDefinitionLocationAnchor;
    protected CppLocationAnchor myEndLocationAnchor;
    protected bool myEndLocationAnchorIsSet;
    internal Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>> myChildren;
    protected ICppResolveEntity myAssocTypedef;
    protected NotMergedSymbolsState modreq(System.Runtime.CompilerServices.IsVolatile) myNotMergedSymbolsState;
    protected CppList`1<ICppSymbol> myNotMergedSymbols;
    protected CppLocationAnchor myAnchorOfFirstNotMergedSymbol;
    internal CppModuleImportingContext ImportingContext;
    protected Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myImportingInProgress;
    internal List`1 modreq(System.Runtime.CompilerServices.IsVolatile) mySortedMembers;
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    protected CppClassOrEnumData(CppQualifiedNamePart name, CppClassKey key);
    protected CppClassOrEnumData(CppQualifiedNamePart name, CppClassKey key, CppList`1<ClassPartDescription> parts);
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public CppClassOrEnumModuleEntity GetImportedModuleEntity();
    public sealed virtual bool ContainsSymbol(ICppClassOrDelegateSymbolOrModuleEntity thatSymbolOrModuleEntity);
    private static bool HasTheSameDefinitionSymbol(CppClassOrEnumModuleEntity a, CppClassOrEnumModuleEntity b);
    public void DumpData(CppIndentationStringBuilder tw);
    protected abstract virtual void DumpBases(CppIndentationStringBuilder sb);
    protected abstract virtual void DumpVirtualSpecifiers(CppIndentationStringBuilder sb);
    protected abstract virtual void DumpSpecialMembers(CppIndentationStringBuilder sb);
    protected abstract virtual void DumpAnonymousClasses(CppIndentationStringBuilder sb);
    protected abstract virtual void DumpFriends(CppIndentationStringBuilder sb);
    public virtual CppClassKey GetKey();
    public virtual CppClassTag GetTag();
    public CppList`1<ClassPartDescription> GetPartDescription();
    public abstract virtual bool Exported();
    public virtual bool HasDefinition();
    public virtual ICppDefinitionClassSymbol GetDefinitionSymbol();
    public virtual CppViewPos GetScopeForBaseClasses(ICppClassSymbol sym);
    public virtual CppLocationAnchor GetAnchorBySymbol(ICppClassOrDelegateSymbol sym);
    public virtual ICppTemplateArgument[] GetDefaultTemplateArguments(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    public virtual void AddAttribute(ICppAttribute replaced, CppLocationAnchor anchor);
    public virtual void AddSymbolPart(ICppClassOrDelegateSymbol sym, CppLocationAnchor anchor, CppQualifiedNamePart newName, CppAttributeList attributes);
    public virtual void AddModulePart(CppClassOrEnumModuleEntity ment, CppModuleImportingContext ctx);
    protected abstract virtual void MarkAsReadyToImport(CppJournal journal);
    public virtual bool IsAnonymousClass();
    public virtual void SetDefinitionLocationAnchor(CppLocationAnchor anchor);
    public virtual CppLocationAnchor GetDefinitionLocationAnchor();
    public virtual bool IsEndLocationAnchorSet();
    public virtual void SetEndLocationAnchor(CppLocationAnchor anchor);
    public virtual CppLocationAnchor GetEndLocationAnchor();
    public virtual ICppGroupedTypeDeclaratorResolveEntity GetAssociatedTypedefForClass(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual void SetAssociatedTypedef(ICppTypeDeclaratorResolveEntity assocTypedef);
    public virtual void SetAssociatedTypedef(CppDeclaratorResolveEntityPack assocTypedef);
    public virtual void AddSymbolsForLateMerging(CppList`1<ICppSymbol> syms, CppLocationAnchor anchorOfFirstSymbol);
    public bool AreSymbolsMerged();
    public virtual void AddChild(ICppResolveEntity ent);
    public CppSmallList`1<ICppResolveEntity> RawChildByName(CppQualifiedNamePart name);
    public virtual CppSmallList`1<ICppResolveEntity> ChildByName(CppQualifiedNamePart name, CppLocationAnchor anchor);
    public virtual CppList`1<ICppResolveEntity> GetChildren();
    public virtual CppAttributeList GetAttributes();
    public virtual bool IsTemplateInstantiation();
    public virtual ICppTemplateResolveEntity GetTemplate();
    public virtual ICppTemplateArgument[] GetArguments();
    public virtual void Journaling_RollbackSymbolPart(bool isDefinition, int attributesCount, CppClassVirtualSpecifiers specifiers);
    public virtual void Journaling_RollbackChild(ICppResolveEntity ent);
    public abstract virtual void MergeNonMergedSymbols();
    public virtual List`1<ICppResolveEntity> GetAllMembersSorted();
    public sealed virtual CppAccessibility GetAccessibility();
    public virtual FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public virtual void CheckInvariant();
    public abstract virtual ICppMutableClassResolveEntity GetThat();
    protected abstract virtual void SetExported();
    public static bool SymbolCouldBeSkippedInResolveEntity(ICppClassOrDelegateSymbol sym);
    public void AddSymbolPart(ICppClassOrDelegateSymbol sym, CppLocationAnchor anchor, CppQualifiedNamePart newName, CppAttributeList attributes, bool calledWhenClassCreated);
    protected abstract virtual void SetVirtualSpecifiers(CppClassVirtualSpecifiers specs);
    protected abstract virtual List`1<ICppResolveEntity> CalculateSortedMembers();
    private CppList`1<ICppResolveEntity> GetRawChildren();
    private ICppAttribute Resolve(ICppAttribute replaced, CppLocationAnchor anchor);
    [CompilerGeneratedAttribute]
internal static void <get_SymbolParts>g__Add|21_0(ICppClassOrDelegateSymbolOrModuleEntity symbolOrModuleEntity, HashSet`1<ICppSymbol> result);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
internal static ICppClassOrDelegateSymbol <HasTheSameDefinitionSymbol>g__GetDefinitionSymbol|24_0(CppClassOrEnumModuleEntity moduleEntity);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassOrEnumModuleEntity : object {
    protected static int BaseSerializedStateSize;
    public ICppScopeModuleEntity Parent;
    public CppClassKey Key;
    public bool HasDefinition;
    public CppQualifiedNamePart Name;
    public ICppClassOrDelegateSymbol[] SymbolParts;
    [CanBeNullAttribute]
public CppTypeAliasModuleEntity AssocTypedef;
    public CppSmallArray`1<ICppAttribute> Attributes;
    private CppAccessibility myAccessibility;
    private bool myExported;
    public int Index;
    protected CppClassOrEnumModuleEntity(int index, ICppScopeModuleEntity parent, CppClassKey key, CppAccessibility accessibility, bool exported);
    protected internal CppClassOrEnumModuleEntity(int index);
    public sealed virtual ICppScopeModuleEntity GetParent();
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual CppClassModuleEntityKind GetKind();
    public sealed virtual bool IsExplicitlyExported();
    public CppAccessibility GetAccessibility();
    public sealed virtual CppImportResult`1<ICppClassResolveEntity> Import(CppModuleImportingContext ctx, ICppScopeResolveEntity targetParent, bool onlyFindExisting, bool addToParentScope);
    public sealed virtual CppImportResult`1<ICppScopeResolveEntity> ImportScopeAutoParent(CppModuleImportingContext ctx);
    public abstract virtual CppModuleEntityKind Kind();
    public abstract virtual int SerializedSize();
    public abstract virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public abstract virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    protected void MarshalBase(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    protected void UnmarshalBase(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public bool ContainsSymbol(ICppClassOrDelegateSymbol thatSymbol);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassResolveEntity : CppClassData {
    private ICppResolveEntityParent myParent;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <LocationAnchor>k__BackingField;
    public CppDependentInfo DependentInfo { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppLocationAnchor LocationAnchor { get; }
    [CanBeNullAttribute]
public CppTemplateId FirstTemplateDeclarationName { get; }
    public CppClassResolveEntity(ICppResolveEntityParent parent, CppQualifiedNamePart name, CppClassKey key, CppLocationAnchor anchor);
    public virtual void AddSymbolsForLateMerging(CppList`1<ICppSymbol> syms, CppLocationAnchor anchorOfFirstSymbol);
    public virtual CppDeclaratorResolveEntityPack GetOrCreateConversions(CppLocationAnchor anchor);
    public virtual CppDeclaratorResolveEntityPack GetOrCreateConstructors(CppLocationAnchor anchor);
    public virtual CppDeclaratorResolveEntityPack GetOrCreateStaticConstructors(CppLocationAnchor anchor);
    public virtual CppDeclaratorResolveEntityPack GetOrCreateDestructors(CppLocationAnchor anchor);
    public virtual CppDeclaratorResolveEntityPack GetOrCreateCliFinalizers(CppLocationAnchor anchor);
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public virtual CppDependentInfo get_DependentInfo();
    public virtual void AddAnonymousClass(ICppClassResolveEntity cent);
    public virtual void AddChild(ICppResolveEntity ent);
    public virtual void RemoveChild(ICppResolveEntity ent);
    public virtual ICppResolveEntityParent get_RealParent();
    public virtual ICppResolveEntity get_StructuralParent();
    [CompilerGeneratedAttribute]
public virtual CppLocationAnchor get_LocationAnchor();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public void Dump(CppIndentationStringBuilder tw);
    public virtual string ToString();
    public virtual ICppMutableClassResolveEntity GetThat();
    public CppTemplateId get_FirstTemplateDeclarationName();
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
private void AssertNotFrozen();
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassResolveEntityInternalUtil : object {
    public static IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity> GetClassConversionsImpl(ICppClassResolveEntity cent, CppViewPos& viewPos);
    public static IEnumerable`1<ICppResolveEntity> GetClassConstructorsImpl(ICppClassResolveEntity cent);
    private static Nullable`1<ConstructorCharacteristics> GetCharacteristics(ICppDeclaratorOrTemplateDeclaratorPack ent, ICppResolvedTypeFactory typeFactory);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassResolveEntityUtil : object {
    public static ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppFunctionDeclaratorResolveEntity>> EmptyFriendFunctionsCollection;
    public static ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity>> EmptyFriendClassesCollection;
    private static CppClassResolveEntityUtil();
    [ExtensionAttribute]
public static void InstantiateClass(ICppClassResolveEntity input, CppViewPos& viewPos);
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertClassHasDefinition(ICppClassResolveEntity cent);
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertClassInstantiated(ICppClassResolveEntity input);
    [ExtensionAttribute]
public static bool HasDefaultCtor(ICppClassResolveEntity clazz);
    [ExtensionAttribute]
public static bool IsLambda(ICppClassResolveEntity clazz);
    [ExtensionAttribute]
public static CppQualType GetLambdaSignature(ICppClassResolveEntity lambda, Nullable`1& viewPos);
    [ExtensionAttribute]
public static bool IsCliManagedClass(ICppClassResolveEntity cls);
    [ExtensionAttribute]
public static bool IsCliInterface(ICppClassResolveEntity cls);
    [ExtensionAttribute]
public static bool IsCliEnum(ICppClassResolveEntity cls);
    [ExtensionAttribute]
public static bool IsCliDelegate(ICppClassResolveEntity cls);
    [ExtensionAttribute]
public static bool IsNonStaticField(CppGroupedVariableDeclaratorResolveEntity var);
    [ExtensionAttribute]
public static IEnumerable`1<ICppResolveEntity> GetConstructors(ICppClassResolveEntity clsEnt, CppViewPos& viewPos);
    public static IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity> GetDestructors(ICppClassResolveEntity clsEnt);
    [ExtensionAttribute]
public static IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity> GetNonDependentConstructors(ICppClassResolveEntity clsEnt, CppViewPos& viewPos);
    public static IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity> GetNonDependentConstructorsOrEmptyIfIncomplete(ICppClassResolveEntity clsEnt, CppViewPos& viewPos);
    [CanBeNullAttribute]
public static CppAssignmentOperatorResolveEntityPack GetAssignmentPack(ICppClassResolveEntity clazz, Boolean& isCapturelessLambda);
    [ExtensionAttribute]
public static CppSizeAndAlignment GetSizeAndAlignment(ICppClassResolveEntity cent);
    [ExtensionAttribute]
public static bool ContainsReferenceTypeMember(ICppClassResolveEntity clazz);
    [ExtensionAttribute]
public static CppList`1<ICppVariableDeclaratorResolveEntity> CollectAggregateClassTypeMembersSorted(ICppClassResolveEntity clazz);
    [ExtensionAttribute]
public static bool IsDerivedFrom(ICppClassResolveEntity derived, ICppClassResolveEntity base, CppViewPos& vp);
    public static void PropagateEnumIntoParentScope(ICppEnumeratorResolveEntity ent);
    private static void CollectAnonymousClassMembers(ICppClassResolveEntity cent, CppList`1& members);
    public static void RegisterAnonymousSubclassMembers(ICppMutableClassResolveEntity parentClass, ICppClassResolveEntity cent);
    public static ICppTemplateArgument[] GetArgumentsForClassDependencyCheck(CppQualifiedNamePart clsName);
    [ExtensionAttribute]
public static bool IsExplicitInstantiation(ICppClassResolveEntity clazz);
    [ExtensionAttribute]
public static ICppGroupedVariableDeclaratorResolveEntity GetUuidOfClass(ICppClassResolveEntity clazz, ICppRootFileResolveEntitiesCache resolveCache);
    private static void CollectAggregateClassTypeMembersSortedImpl(ICppClassResolveEntity classEnt, CppList`1& members);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassResolveEntityWithSubstitution : CppResolveEntityWithSubstitution {
    private ICppClassResolveEntity myInner;
    private CppClassKey myKey;
    private ICppClassResolveEntityWithSubstitutionState myState;
    private List`1<ICppSymbol> myAdditionalSymbolParts;
    [CompilerGeneratedAttribute]
private CppDependentInfo <TemplateArgumentsDependentInfo>k__BackingField;
    public CppDependentInfo TemplateArgumentsDependentInfo { get; }
    public CppDependentInfo DependentInfo { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppClassResolveEntityWithSubstitution(ICppResolveEntity structuralParent, CppQualifiedNamePart name, CppClassKey key, Nullable`1& createSubstitutionViewPos, ICppClassResolveEntity inner, ICppSubstitutionContext subst, CppDependentInfo templateArgumentsDependentInfo);
    [CompilerGeneratedAttribute]
public CppDependentInfo get_TemplateArgumentsDependentInfo();
    public sealed virtual void AssertInstantiated();
    public sealed virtual bool IsInstantiated();
    public bool InstantiationInProgress();
    public CppInstantiationStatus Instantiate(CppViewPos& pointOfInstantiation);
    public sealed virtual ICppClassResolveEntity GetInner();
    public sealed virtual void Dump(CppIndentationStringBuilder tw);
    public sealed virtual CppDefaultedSpecialMembers GetTemplateDefaultedSpecialMembers();
    public virtual TResult Accept(ICppResolveEntityVisitor`1<TResult> visitor);
    public sealed virtual void AddChild(ICppResolveEntity ent);
    public sealed virtual void RemoveChild(ICppResolveEntity ent);
    public sealed virtual CppSmallList`1<ICppResolveEntity> ChildByName(CppQualifiedNamePart name, CppLocationAnchor anchor);
    public sealed virtual CppList`1<ICppResolveEntity> GetChildren();
    public sealed virtual void AddAnonymousClass(ICppClassResolveEntity ent);
    public sealed virtual CppList`1<ICppClassResolveEntity> AnonymousClasses();
    public sealed virtual CppSmallList`1<ICppDeclaratorResolveEntityPack> GetAnonymousSubclassMembers(CppQualifiedNamePart name);
    public sealed virtual void RegisterAnonymousSubclassMembers(CppList`1<ICppDeclaratorResolveEntityPack> members);
    public sealed virtual void GenerateImplicitDisposableIfNeeded();
    public sealed virtual CppViewPos GetScopeForBaseClasses(ICppClassSymbol sym);
    public sealed virtual CppLocationAnchor GetAnchorBySymbol(ICppClassOrDelegateSymbol sym);
    public sealed virtual bool HasDefinition();
    public sealed virtual bool Exported();
    public sealed virtual ICppDefinitionClassSymbol GetDefinitionSymbol();
    public sealed virtual CppClassKey GetKey();
    public sealed virtual CppClassVirtualSpecifiers GetClassVirtualSpecifiers();
    public sealed virtual bool HasAbstractSpecifier();
    public sealed virtual bool IsFinal();
    public sealed virtual bool IsSealed();
    public sealed virtual bool IsFinalOrSealed();
    public sealed virtual bool IsAnonymousClass();
    public sealed virtual bool IsAbstract();
    public sealed virtual bool IsPolymorphic();
    public sealed virtual bool HasVirtualDestructor();
    public bool IsTriviallyCopyable(CppViewPos& vp);
    public bool HasTrivialDestructor(CppViewPos& vp);
    public bool HasNothrowDestructor(CppViewPos& vp);
    public bool IsTrivial(CppViewPos& vp);
    public bool IsStandardLayout(CppViewPos& vp);
    public bool IsPOD(CppViewPos& vp);
    public bool HasUniqueObjectRepresentations(CppViewPos& vp);
    public sealed virtual bool HasTrivialConstructor();
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetClassConstructors();
    public sealed virtual CppQualType GetEnumUnderlyingType();
    public sealed virtual CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> GetNonDependentBases();
    public sealed virtual CppBasicBaseDescription`1[] GetBases();
    public sealed virtual ICppDeclaratorResolveEntityPack GetConversions();
    public sealed virtual ICppDeclaratorResolveEntityPack GetConstructors();
    public sealed virtual ICppDeclaratorResolveEntityPack GetStaticConstructors();
    public sealed virtual ICppDeclaratorResolveEntityPack GetDestructors();
    public sealed virtual ICppDeclaratorResolveEntityPack GetCliFinalizers();
    public IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity> GetClassConversions(CppViewPos& viewPos);
    private static CppViewPos ViewPosForDefaultTemplateArgumentsSubstitution(CppClassResolveEntityWithSubstitution cent);
    public ICppTemplateArgument[] GetDefaultTemplateArguments(CppViewPos& viewPos);
    public sealed virtual CppSmallList`1<ICppFunctionDeclaratorResolveEntity> GetFriendFunctions(CppQualifiedNamePart name);
    public sealed virtual ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppFunctionDeclaratorResolveEntity>> GetFriendFunctions();
    public sealed virtual CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity> GetFriendClasses(CppQualifiedNamePart name);
    public sealed virtual ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity>> GetFriendClasses();
    public sealed virtual CppSmallList`1<ICppDependentTypeResolveEntity> GetFriendDependentTypes();
    public sealed virtual CppList`1<ICppResolveEntity> GetAggregateMembers();
    public sealed virtual List`1<ICppResolveEntity> GetAllMembersSorted();
    public sealed virtual bool HasImmediateVirtualFunctions();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasFixedEnumUnderlyingType();
    public sealed virtual bool HasInheritingConstructors();
    public sealed virtual CppClassTag GetTag();
    public sealed virtual CppLocationAnchor GetDefinitionLocationAnchor();
    public sealed virtual bool IsEndLocationAnchorSet();
    public sealed virtual CppLocationAnchor GetEndLocationAnchor();
    public sealed virtual CppDeclaratorResolveEntityPack GetOrCreateConversions(CppLocationAnchor anchor);
    public sealed virtual CppDeclaratorResolveEntityPack GetOrCreateConstructors(CppLocationAnchor anchor);
    public sealed virtual CppDeclaratorResolveEntityPack GetOrCreateStaticConstructors(CppLocationAnchor anchor);
    public sealed virtual CppDeclaratorResolveEntityPack GetOrCreateDestructors(CppLocationAnchor anchor);
    public sealed virtual CppDeclaratorResolveEntityPack GetOrCreateCliFinalizers(CppLocationAnchor anchor);
    public sealed virtual void AddFriend(ICppFunctionDeclaratorResolveEntity dent);
    public sealed virtual void AddFriend(ICppTypeTemplateInstantiationResolveEntity cent);
    public sealed virtual void AddFriend(ICppDependentTypeResolveEntity type);
    public sealed virtual void SetBases(CppList`1<CppBasicBaseDescription`1<CppQualifiedName>> bases);
    public sealed virtual void ResolveBases();
    public sealed virtual void AddSymbolPart(ICppClassOrDelegateSymbol sym, CppLocationAnchor anchor, CppQualifiedNamePart name, CppAttributeList attributes);
    public sealed virtual void AddModulePart(CppClassOrEnumModuleEntity ment, CppModuleImportingContext ctx);
    public sealed virtual void SetEnumUnderlyingType(CppQualType replacedType, CppLocationAnchor anchor);
    public sealed virtual void SetResolvedEnumUnderlyingType(CppQualType resolvedType);
    public sealed virtual void SetDefinitionLocationAnchor(CppLocationAnchor anchor);
    public sealed virtual void SetEndLocationAnchor(CppLocationAnchor anchor);
    public sealed virtual void AddSymbolsForLateMerging(CppList`1<ICppSymbol> syms, CppLocationAnchor anchorOfFirstSymbol);
    public sealed virtual void ForceImporting();
    public sealed virtual CppConstructorDeclaratorResolveEntityPack EnsureConstructorExists(CppLocationAnchor anchor);
    public sealed virtual void Journaling_RollbackSymbolPart(bool isDefinition, int attributesCount, CppClassVirtualSpecifiers specifiers);
    public sealed virtual void Journaling_RollbackChild(ICppResolveEntity ent);
    public sealed virtual void Journaling_RollbackCachedClassConstructors();
    public sealed virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public sealed virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public sealed virtual CppDependentInfo get_DependentInfo();
    public ICppGroupedTypeDeclaratorResolveEntity GetAssociatedTypedefForClass(CppViewPos& viewPos);
    public sealed virtual void SetAssociatedTypedef(ICppTypeDeclaratorResolveEntity assocTypedef);
    public sealed virtual void SetAssociatedTypedef(CppDeclaratorResolveEntityPack assocTypedef);
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual bool ContainsSymbol(ICppClassOrDelegateSymbolOrModuleEntity symbol);
    private bool AdditionalPartsContainsSymbol(ICppClassOrDelegateSymbolOrModuleEntity thatSymbol);
    public virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual bool IsTemplateInstantiation();
    public sealed virtual ICppTemplateResolveEntity GetTemplate();
    public sealed virtual ICppTemplateArgument[] GetArguments();
    public sealed virtual CppAttributeList GetAttributes();
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
private void AssertNotFrozen();
    public Nullable`1<CppViewPos> PointOfInstantiation();
    public ICppClassResolveEntity GetRawDefinition();
    public ICppClassResolveEntityWithSubstitutionState GetState();
    public ICppClassResolveEntity GetTemplateSpecialization(CppViewPos& vp);
    public void AddExplicitInstantiationSymbolPart(ICppClassOrDelegateSymbol symbol, CppLocationAnchor anchor, CppAttributeList attrs);
    public virtual string ToString();
    public void Journaling_RollbackInstantiation();
    public ICppGroupedFunctionDeclaratorResolveEntity FindSubstitutionForCurrentlySubstituted(ICppGroupedFunctionDeclaratorResolveEntity orig);
    public List`1<ICppSymbol> GetAdditionalSymbolParts();
    private CppClassOrEnumData InitializeState(CppLocationAnchor anchor);
    public bool IsExplicitInstantiation();
    private sealed virtual override CppInstantiationStatus JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntityWithSubstitution.Instantiate(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) pointOfInstantiation);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.IsTriviallyCopyable(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.HasTrivialDestructor(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.HasNothrowDestructor(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.IsTrivial(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.IsStandardLayout(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.IsPOD(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.HasUniqueObjectRepresentations(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.GetClassConversions(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    private sealed virtual override ICppTemplateArgument[] JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.GetDefaultTemplateArguments(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    private sealed virtual override ICppGroupedTypeDeclaratorResolveEntity JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.GetAssociatedTypedefForClass(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassResolveEntityWithSubstitutionClrImportedInstantiatedState : CppClassResolveEntityWithSubstitutionInstantiatedState {
    private bool myBasesAreComputed;
    private CppDeclaratorResolveEntityPack myConversions;
    private CppDeclaratorResolveEntityPack myConstructors;
    private CppDeclaratorResolveEntityPack myDestructors;
    public CppClassResolveEntityWithSubstitutionClrImportedInstantiatedState(CppClassResolveEntityWithSubstitution that, ICppClassResolveEntity inner, ICppSubstitutionContext subst, CppViewPos& pointOfInstantiation);
    public virtual CppInstantiationStatus StateInstantiate();
    public virtual void Dump(CppIndentationStringBuilder tw);
    public virtual CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> GetNonDependentBases();
    public virtual CppBasicBaseDescription`1[] GetBases();
    public virtual CppSmallList`1<ICppResolveEntity> ChildByName(CppQualifiedNamePart name, CppLocationAnchor anchor);
    public virtual CppList`1<ICppResolveEntity> GetChildren();
    public virtual ICppDeclaratorResolveEntityPack GetConversions();
    public virtual ICppDeclaratorResolveEntityPack GetConstructors();
    public virtual ICppDeclaratorResolveEntityPack GetDestructors();
    public virtual ICppDeclaratorResolveEntityPack GetCliFinalizers();
    public virtual CppList`1<ICppResolveEntity> GetAggregateMembers();
    public virtual List`1<ICppResolveEntity> GetAllMembersSorted();
    private CppSmallList`1<ICppResolveEntity> ChildByNameImpl(CppQualifiedNamePart name);
    private void EnforceChildren();
    private CppDeclaratorResolveEntityPack GetConversionsUnderLock();
    private CppDeclaratorResolveEntityPack GetConstructorsUnderLock();
    private CppDeclaratorResolveEntityPack GetDestructorsUnderLock();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassResolveEntityWithSubstitutionDefinitionState : CppClassData {
    private ICppMutableClassResolveEntity myThat;
    private CppLocationAnchor myAnchor;
    public CppClassResolveEntityWithSubstitutionDefinitionState(ICppMutableClassResolveEntity that, CppClassKey key, CppLocationAnchor anchor);
    public CppClassResolveEntityWithSubstitutionDefinitionState(ICppMutableClassResolveEntity that, CppClassKey key, CppLocationAnchor anchor, CppList`1<ClassPartDescription> parts);
    public sealed virtual CppInstantiationStatus StateInstantiate();
    public sealed virtual bool InstantiationInProgress();
    public sealed virtual Nullable`1<CppViewPos> PointOfInstantiation();
    public sealed virtual ICppClassResolveEntity GetRawDefinition();
    public sealed virtual void Dump(CppIndentationStringBuilder tw);
    public sealed virtual CppLocationAnchor GetLocationAnchor();
    public sealed virtual CppDefaultedSpecialMembers GetTemplateDefaultedSpecialMembers();
    public sealed virtual ICppGroupedFunctionDeclaratorResolveEntity FindSubstitutionForCurrentlySubstituted(ICppGroupedFunctionDeclaratorResolveEntity e);
    public virtual ICppMutableClassResolveEntity GetThat();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassResolveEntityWithSubstitutionInstantiatedState : object {
    protected CppClassResolveEntityWithSubstitution myThat;
    protected ICppClassResolveEntity myInner;
    protected ICppSubstitutionContext mySubst;
    protected CppViewPos myPointOfInstantiation;
    protected Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>> myChildren;
    protected CppList`1<ICppClassResolveEntity> myAnonymousClasses;
    protected Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppDeclaratorResolveEntityPack>> myAnonymousSubclassMembers;
    protected CppDeclaratorResolveEntityPack myConversions;
    protected ICppDeclaratorResolveEntityPack myConstructors;
    protected CppConstructorDeclaratorResolveEntityPack myStaticConstructors;
    protected CppDeclaratorResolveEntityPack myDestructors;
    protected CppDeclaratorResolveEntityPack myCliFinalizers;
    protected Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppFunctionDeclaratorResolveEntity>> myFriendDeclarators;
    protected Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity>> myFriendClasses;
    protected CppSmallList`1<ICppDependentTypeResolveEntity> myFriendTypes;
    protected CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> myNonDependentBases;
    protected CppBasicBaseDescription`1[] myBases;
    protected CppClassTraits myTraits;
    protected CppCachedReference`1<IEnumerable`1<ICppResolveEntity>> myCachedClassConstructors;
    protected CppCachedReference`1<IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity>> myCachedClassConversions;
    protected CppCachedValue`1<CppAttributeList> myCachedAttributes;
    protected CppLocationAnchor myEndLocationAnchor;
    protected bool myEndLocationAnchorIsSet;
    protected InstantiationPhase myPhase;
    protected bool myInstantiationInProgress;
    protected List`1<ICppResolveEntity> myPendingEntities;
    private List`1<ICppResolveEntity> mySortedMembers;
    protected int myFirstNotInstantiatedYet;
    [CanBeNullAttribute]
protected CppClassResolveEntityWithSubstitution myNotInstantiatedInnerClass;
    [CanBeNullAttribute]
protected CppDefaultedSpecialMembers myTemplateDefaultedSpecialMembers;
    [CanBeNullAttribute]
protected ICppGroupedFunctionDeclaratorResolveEntity myCurrentlySubstitutedFunction;
    public CppClassResolveEntityWithSubstitutionInstantiatedState(CppClassResolveEntityWithSubstitution that, ICppClassResolveEntity inner, ICppSubstitutionContext subst, CppViewPos& pointOfInstantiation);
    protected CppViewPos ViewPosForMembersInstantiation();
    public virtual CppInstantiationStatus StateInstantiate();
    public sealed virtual bool InstantiationInProgress();
    public virtual Nullable`1<CppViewPos> PointOfInstantiation();
    public virtual ICppClassResolveEntity GetRawDefinition();
    public virtual void Dump(CppIndentationStringBuilder tw);
    public virtual CppLocationAnchor GetLocationAnchor();
    public virtual CppClassVirtualSpecifiers GetClassVirtualSpecifiers();
    public virtual void AddChild(ICppResolveEntity ent);
    public virtual CppSmallList`1<ICppResolveEntity> ChildByName(CppQualifiedNamePart name, CppLocationAnchor anchor);
    public virtual CppList`1<ICppResolveEntity> GetChildren();
    public virtual void AddAnonymousClass(ICppClassResolveEntity ent);
    public virtual CppList`1<ICppClassResolveEntity> AnonymousClasses();
    public virtual CppSmallList`1<ICppDeclaratorResolveEntityPack> GetAnonymousSubclassMembers(CppQualifiedNamePart name);
    public virtual void RegisterAnonymousSubclassMembers(CppList`1<ICppDeclaratorResolveEntityPack> packs);
    public virtual void GenerateImplicitDisposableIfNeeded();
    public virtual CppViewPos GetScopeForBaseClasses(ICppClassSymbol sym);
    public virtual CppLocationAnchor GetAnchorBySymbol(ICppClassOrDelegateSymbol sym);
    public virtual bool HasDefinition();
    public virtual ICppDefinitionClassSymbol GetDefinitionSymbol();
    public virtual bool HasAbstractSpecifier();
    public virtual bool IsFinal();
    public virtual bool IsSealed();
    public virtual bool IsFinalOrSealed();
    public virtual bool IsAnonymousClass();
    public virtual bool IsAbstract();
    public virtual bool IsPolymorphic();
    public virtual bool HasVirtualDestructor();
    public virtual bool IsTriviallyCopyable(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool HasTrivialDestructor(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool HasNothrowDestructor(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool IsTrivial(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool IsStandardLayout(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool IsPOD(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public bool HasUniqueObjectRepresentations(CppViewPos& vp);
    public virtual bool HasTrivialConstructor();
    public virtual IEnumerable`1<ICppResolveEntity> GetClassConstructors();
    public virtual CppQualType GetEnumUnderlyingType();
    public virtual CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> GetNonDependentBases();
    public virtual CppBasicBaseDescription`1[] GetBases();
    public virtual ICppDeclaratorResolveEntityPack GetConversions();
    public virtual ICppDeclaratorResolveEntityPack GetConstructors();
    public virtual ICppDeclaratorResolveEntityPack GetStaticConstructors();
    public virtual ICppDeclaratorResolveEntityPack GetDestructors();
    public virtual ICppDeclaratorResolveEntityPack GetCliFinalizers();
    public virtual CppAttributeList GetAttributes();
    public sealed virtual bool Exported();
    public virtual IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity> GetClassConversions(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    public virtual CppLocationAnchor GetDefinitionLocationAnchor();
    public virtual bool IsEndLocationAnchorSet();
    public virtual CppLocationAnchor GetEndLocationAnchor();
    public virtual CppSmallList`1<ICppFunctionDeclaratorResolveEntity> GetFriendFunctions(CppQualifiedNamePart name);
    public virtual ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppFunctionDeclaratorResolveEntity>> GetFriendFunctions();
    public virtual CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity> GetFriendClasses(CppQualifiedNamePart name);
    public virtual ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity>> GetFriendClasses();
    public virtual CppSmallList`1<ICppDependentTypeResolveEntity> GetFriendDependentTypes();
    public virtual CppList`1<ICppResolveEntity> GetAggregateMembers();
    public virtual List`1<ICppResolveEntity> GetAllMembersSorted();
    public virtual bool HasImmediateVirtualFunctions();
    public virtual bool HasInheritingConstructors();
    public sealed virtual bool HasFixedEnumUnderlyingType();
    public virtual CppDeclaratorResolveEntityPack GetOrCreateConversions(CppLocationAnchor anchor);
    public virtual CppDeclaratorResolveEntityPack GetOrCreateConstructors(CppLocationAnchor anchor);
    public virtual CppDeclaratorResolveEntityPack GetOrCreateStaticConstructors(CppLocationAnchor anchor);
    public virtual CppDeclaratorResolveEntityPack GetOrCreateDestructors(CppLocationAnchor anchor);
    public virtual CppDeclaratorResolveEntityPack GetOrCreateCliFinalizers(CppLocationAnchor anchor);
    public virtual void AddFriend(ICppFunctionDeclaratorResolveEntity dent);
    public virtual void AddFriend(ICppTypeTemplateInstantiationResolveEntity cent);
    public virtual void AddFriend(ICppDependentTypeResolveEntity type);
    public virtual void SetBases(CppList`1<CppBasicBaseDescription`1<CppQualifiedName>> bases);
    public virtual void ResolveBases();
    public virtual void SetEnumUnderlyingType(CppQualType type, CppLocationAnchor anchor);
    public virtual void SetResolvedEnumUnderlyingType(CppQualType resolvedType);
    public virtual void SetDefinitionLocationAnchor(CppLocationAnchor anchor);
    public virtual void SetEndLocationAnchor(CppLocationAnchor anchor);
    public virtual void AddSymbolsForLateMerging(CppList`1<ICppSymbol> symbols, CppLocationAnchor anchor);
    public virtual void AddModuleEntityForLateImporting(CppClassOrEnumModuleEntity ent, CppModuleImportingContext ctx);
    public virtual void ForceImporting();
    public virtual CppConstructorDeclaratorResolveEntityPack EnsureConstructorExists(CppLocationAnchor anchor);
    public virtual CppDefaultedSpecialMembers GetTemplateDefaultedSpecialMembers();
    public virtual ICppGroupedFunctionDeclaratorResolveEntity FindSubstitutionForCurrentlySubstituted(ICppGroupedFunctionDeclaratorResolveEntity orig);
    public virtual void Journaling_RollbackSymbolPart(bool isDefinition, int attributesCount, CppClassVirtualSpecifiers specs);
    public virtual void Journaling_RollbackChild(ICppResolveEntity ent);
    public virtual void Journaling_RollbackCachedClassConstructors();
    protected void CalculateBases();
    protected bool AreBasesMerged();
    protected void CollectNonSpecialMembers(List`1<ICppResolveEntity> result);
    private void AddFunctionOrTemplateMember(CppQualifiedNamePart childName, ICppFunctionOrTemplateDeclaratorResolveEntity child);
    private void AddTemplateDeclarator(CppQualifiedNamePart childName, ICppFunctionTemplateDeclaratorResolveEntity child);
    private void AddTemplateDeclarator(CppQualifiedNamePart childName, ICppVariableTemplateDeclaratorResolveEntity child);
    private void CalculateMembers();
    private void SubstituteMember(CppSubstitutionDriver driver, ICppResolveEntity childOfInner, ICppResolvedTypeFactory typeFactory);
    private void SubstituteTemplateTypeDeclarator(ICppTypeTemplateDeclaratorResolveEntity typeDeclTemplate);
    private void SubstituteDeclarator(ICppGroupedDeclaratorResolveEntity declarator);
    private void SubstituteEnumerator(ICppResolveEntity childOfInner, ICppResolveEntity child, ICppEnumeratorResolveEntity echild);
    private void SubstituteNestedClass(ICppResolveEntity childOfInner, CppClassResolveEntityWithSubstitution cchild, ICppResolveEntity child);
    private void SubstituteNestedTemplateClass(CppClassTemplateResolveEntityPack pack, ICppClassResolveEntity clazz, CppQualifiedNamePart childName);
    private void PrepareMembersForSubstitution();
    private void IfAnonymousAddMembersToParent();
    private CppConstructorDeclaratorResolveEntityPack EnsureStaticConstructorExists(CppLocationAnchor anchor);
    private ICppGroupedFunctionDeclaratorResolveEntity SubstituteNonTemplateMemberFunction(ICppGroupedFunctionDeclaratorResolveEntity func, CppQualifiedNamePart substitutedName, ICppResolvedTypeFactory typeFactory);
    private CppGroupedFunctionDeclaratorResolveEntity SubstituteTemplateDeclaratorMember(ICppGroupedFunctionDeclaratorResolveEntity decl, ICppFunctionTemplateDeclaratorResolveEntity templ, CppQualifiedNamePart substitutedName, CppSubstitutionDriver driver, ICppResolvedTypeFactory typeFactory);
    private CppGroupedFunctionDeclaratorResolveEntity SubstituteFunctionTemplateSpecialization(ICppGroupedFunctionDeclaratorResolveEntity originalFunc, CppQualifiedNamePart substitutedName, ICppResolvedTypeFactory typeFactory, CppFunctionTemplateDeclaratorResolveEntityWithSubstitution substitutedTempl);
    private CppGroupedFunctionDeclaratorResolveEntity SubstituteFunction(ICppGroupedFunctionDeclaratorResolveEntity originalFunc, CppQualifiedNamePart substitutedName, ICppResolvedTypeFactory typeFactory, ICppMutableFunctionTemplateDeclaratorResolveEntity substitutedTempl);
    private bool TrySubstituteTemplateDeclaratorMember(ICppGroupedVariableDeclaratorResolveEntity decl, CppQualifiedNamePart substitutedName, ICppResolvedTypeFactory typeFactory);
    private static void CalculateFriends(CppClassResolveEntityWithSubstitution that, ICppClassResolveEntity inner, ICppSubstitutionContext subst, CppViewPos& pointOfInstantiation);
    private static bool IsDefaulted(ICppGroupedFunctionDeclaratorResolveEntity func);
    private bool SubstituteSpecialMember(ICppGroupedFunctionDeclaratorResolveEntity func, ICppResolvedTypeFactory tf);
    private static CppClassTemplateResolveEntityPackWithSubstitution FindClassPackInSubstitution(CppClassTemplateResolveEntityPack pack, CppSmallList`1<ICppResolveEntity> candidates);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntityWithSubstitutionState.HasUniqueObjectRepresentations(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassSpecializationLinkageEntity : CppClassLinkageEntity {
    private ICppLinkageEntity myPrimaryTemplate;
    public CppClassSpecializationLinkageEntity(CppQualifiedNamePart name, ICppLinkageEntity parent, CppClassKey key, CppClassVirtualSpecifiers virtualSpecifiers, ICppLinkageEntity primaryTemplate, bool isAnonymousClass);
    public sealed virtual ICppLinkageEntity GetPrimaryTemplate();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassSymbol : CppScopeSymbol {
    private CppAccessibility myAccessibility;
    private CppClassVirtualSpecifiers myClassVirtualSpecifiers;
    private CppClassKey myKey;
    private Flags myFlags;
    private CppSymbolTemplateParametersList myParamList;
    private CppAttributeList myAttributes;
    private CppList`1<CppBasicBaseDescription`1<CppQualifiedName>> myBases;
    private CppComplexOffset myBodyEndOffset;
    private CppComplexOffset myBodyStartOffset;
    private CppClassLazyMergingInfo myLazyMergingFlags;
    private static int ModuleAttachmentOffset;
    public bool IsExplicitInstantiation { get; }
    public CppClassTag Tag { get; }
    public CppClassKey Key { get; }
    public CppClassVirtualSpecifiers ClassVirtualSpecifiers { get; }
    public CppClassSymbol(CppQualifiedName name, CppSymbolTemplateParametersList paramList, CppAttributeList attributes, CppSymbolLocation loc, CppClassKey key, CppAccessibility accessibility, CppClassVirtualSpecifiers classVirtualSpecifiers, bool isExplicitInstantiation, bool export, CppModuleAttachment moduleAttachment);
    internal CppClassSymbol(CppQualifiedName name, CppSymbolTemplateParametersList paramList, CppAttributeList attributes, CppSymbolLocation loc, CppClassKey key, CppAccessibility accessibility, CppClassVirtualSpecifiers classVirtualSpecifiers, Flags flags);
    private static Flags CreateFlags(bool isExplicitInstantiation, bool export, CppModuleAttachment moduleAttachment);
    public bool get_IsExplicitInstantiation();
    public sealed virtual CppSymbolTemplateParametersList ParamList();
    public sealed virtual CppAttributeList Attributes();
    public sealed virtual CppClassTag get_Tag();
    public sealed virtual CppClassKey get_Key();
    public sealed virtual CppClassVirtualSpecifiers get_ClassVirtualSpecifiers();
    public sealed virtual void SetLazyMergingInfo(CppClassLazyMergingInfo flags);
    public sealed virtual CppClassLazyMergingInfo GetLazyMergingInfo();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool Exported();
    public sealed virtual CppModuleAttachment ModuleAttachment();
    public virtual TResult Accept(ICppSymbolVisitor`1<TResult> visitor);
    public sealed virtual CppList`1<CppBasicBaseDescription`1<CppQualifiedName>> GetBases();
    public sealed virtual bool IsAnonymousClass();
    public sealed virtual void SetBodyStartOffset(CppComplexOffset offset);
    public sealed virtual CppComplexOffset GetBodyStartOffset();
    public sealed virtual void SetBodyEndOffset(CppComplexOffset offset);
    public sealed virtual CppComplexOffset GetBodyEndOffset();
    internal Flags GetFlags();
    public void AddBase(CppBasicBaseDescription`1<CppQualifiedName> descr);
    public void AddAttribute(ICppAttribute unresolvedAttr);
    public void SetIsAnonymousClass(bool value);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassSymbolAndAnchor : object {
    [CompilerGeneratedAttribute]
private ICppClassSymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <Anchor>k__BackingField;
    public ICppClassSymbol Symbol { get; }
    public CppLocationAnchor Anchor { get; }
    public CppClassSymbolAndAnchor(ICppClassSymbol symbol, CppLocationAnchor anchor);
    [CompilerGeneratedAttribute]
public ICppClassSymbol get_Symbol();
    [CompilerGeneratedAttribute]
public CppLocationAnchor get_Anchor();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassSymbolComparerByTagCompatibilityAndName : object {
    public static CppClassSymbolComparerByTagCompatibilityAndName Instance;
    private static CppClassSymbolComparerByTagCompatibilityAndName();
    public sealed virtual bool Equals(ICppClassSymbol lhs, ICppClassSymbol rhs);
    public sealed virtual int GetHashCode(ICppClassSymbol sym);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassSymbolUtil : object {
    [ExtensionAttribute]
public static bool HasEnumUnderlyingType(ICppClassSymbol sym);
    public static Nullable`1<CppQualType> GetEnumUnderlyingTypeIfApplicable(ICppClassSymbol sym);
    public static CppQualType GetEnumUnderlyingTypeForSymbol(ICppClassSymbol sym, ICppResolvedTypeFactory tf);
    public static void UpdateClassLazyMergingFlags(ICppClassSymbol sym);
    private static void UpdateLazyMergingInfoWithClassBody(CppScopeSymbol body, ICppLazyMergingDataConsumer resultConsumer);
    private static void UpdateLazyMergingInfoWithClassChildSymbol(ICppSymbol symbol, ICppLazyMergingDataConsumer resultConsumer);
    private static CppClassLazyMergingInfo CalculateLazyMergingInfo(ICppClassSymbol sym);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassTag : Enum {
    public int value__;
    public static CppClassTag NO_TAG;
    public static CppClassTag CLASS_TAG;
    public static CppClassTag STRUCT_TAG;
    public static CppClassTag UNION_TAG;
    public static CppClassTag ENUM_TAG;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassTagUtil : object {
    public static bool IsTagsCompatible(CppClassTag declTag, CppClassTag refTag);
    [ExtensionAttribute]
public static string TagToString(CppClassTag tag);
    [ExtensionAttribute]
public static string TagToDefinitionString(CppClassTag tag);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassTemplatePackModuleEntity : object {
    public ICppClassOrRefClassModuleEntity PrimaryTemplate;
    public CppClassTemplatePackModuleEntity(ICppClassOrRefClassModuleEntity primaryTemplate);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassTemplateResolveEntityPack : object {
    private static CppLocationAnchor UninitializedLocationAnchor;
    protected ConcurrentDictionary`2<CppClassInstantiationKey, ICppClassResolveEntity> myInstanced;
    protected List`1<ICppClassResolveEntity> mySpecializations;
    private ICppResolveEntityParentScope myParent;
    private CppQualifiedNamePart myName;
    private bool mySpecializationsTaken;
    private List`1<ICppClassResolveEntity> myIncorrectPrimaryTemplates;
    private bool myIncorrectPrimaryTemplatesTaken;
    private CppLocationAnchor myAnchor;
    private NotMergedSymbolsState myDeferredSpecializationsState;
    private List`1<CppDeferredPackSpecializationData> myDeferredSpecializations;
    private int myDeferredSpecializationsLastUnmerged;
    [CanBeNullAttribute]
protected internal DeductionGuidesContainer myDGContainer;
    private TriBool myIsAggregate;
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    protected CppClassTemplateResolveEntityPack(ICppResolveEntityParentScope parent, CppQualifiedNamePart name, CppViewPos& viewPos, CppClassTemplateResolveEntityPack inner, CppSubstitutionContext subst);
    protected CppClassTemplateResolveEntityPack(ICppResolveEntityParentScope parent, CppQualifiedNamePart name, CppViewPos& viewPos, CppClassTemplateResolveEntityPack inner, CppSubstitutionContext subst, int specCount);
    protected CppClassTemplateResolveEntityPack(ICppResolveEntityParentScope parent, CppQualifiedNamePart name);
    private static CppClassTemplateResolveEntityPack();
    public void AddPrimaryTemplateNoJournal(ICppClassResolveEntity ent);
    public void Dump(CppIndentationStringBuilder tw);
    public bool ShouldDump();
    public void ForceMerge(CppLocationAnchor anchor);
    public ICppClassResolveEntity GetPrimaryTemplate(CppLocationAnchor anchor);
    public IEnumerable`1<ICppClassResolveEntity> GetSpecializations(CppLocationAnchor anchor);
    public IEnumerable`1<ICppClassResolveEntity> GetIncorrectPrimaryTemplates(CppLocationAnchor anchor);
    public List`1<ICppClassResolveEntity> GetSpecializationsRaw();
    public ICppClassResolveEntity FindSpecialization(CppViewPos& viewPos, CppQualifiedNamePart name);
    public virtual ICppClassOrUndeterminedSpecializationResolveEntity Instantiate(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, ICppTemplateArgument[] args);
    [ConditionalAttribute("JET_DEBUG_MODE")]
private void AssertTemplateArgumentsAreSanitized(ICppTemplateArgument[] args);
    public void AssertContainsChild(ICppClassResolveEntity possiblyChild);
    public CppClassKey GetKey();
    public virtual CppTemplateParametersBase GetParameters();
    public virtual ICppTemplateArgument[] GetDefaults(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    public virtual IEnumerable`1<ICppResolveEntity> GetAllSpecializations();
    public virtual bool IsDeducibleTemplate();
    public CppList`1<ICppDeductionGuide> GetDeductionGuides(CppViewPos& vp);
    public sealed virtual CppClassTemplateResolveEntityPack GetClassPack();
    protected virtual void SubstituteInnerDeductionGuides(ICppClassResolveEntity primaryTemplate, CppViewPos _);
    public virtual ICppDeductionGuide GetAggregateDeductionGuide(ICppExpression[] args, CppArgumentListKind kind, CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc);
    public virtual CppQualType FinalizeDeduction(CppQualType type, CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc);
    public virtual bool IsDeducibleTemplateChildEntity(ICppResolveEntity entity);
    public CppList`1<ICppUserProvidedDeductionGuide> GetUserProvidedDeductionGuides();
    public CppList`1<CppUserProvidedDeductionGuideTemplate> GetUserProvidedDeductionGuideTemplates();
    [CanBeNullAttribute]
public ICppClassResolveEntity GetFirstSpecialization();
    public void AddSpecializationWithoutJournaling(ICppClassResolveEntity clazz);
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual TResult Accept(ICppResolveEntityVisitor`1<TResult> visitor);
    public static CppClassTemplateResolveEntityPack Create(ICppResolveEntityParentScope parent, CppQualifiedNamePart name, string moduleId);
    public void AddSpecialization(ICppClassResolveEntity ent);
    public void AddSpecializationLazy(CppDeferredPackSpecializationData data);
    public void MarkAsSpecialization(ICppClassResolveEntity ent);
    public void Add(ICppUserProvidedDeductionGuide guide, ICppResolvedTypeFactory tf);
    public void Add(CppUserProvidedDeductionGuideTemplate guide, ICppResolvedTypeFactory tf);
    public ICppClassResolveEntity GetPrimaryAggregateTemplate(CppViewPos& vp);
    public bool IsClr();
    public bool AreSymbolsMerged();
    public virtual string ToString();
    private void MergeDeferredSpecialization(CppDeferredPackSpecializationData data);
    private void MergeAllDeferredSpecializationsUpTo(CppLocationAnchor upto);
    private void AddSpecialization2(ICppClassResolveEntity ent);
    private void InsertToSpecializations(ICppClassResolveEntity ent);
    private void InsertToInstanced(ICppClassResolveEntity ent);
    private void EnsurePendingActionsMerged(CppLocationAnchor anchor);
    private void CreateSynthesizedGuides(ICppClassResolveEntity primaryTemplate);
    private static ICppClassOrUndeterminedSpecializationResolveEntity PickSpecialization(List`1<ICppClassResolveEntity> specializations, ICppClassResolveEntity primaryTemplate, CppClassTemplateResolveEntityPack pack, CppClassInstantiationKey instantiationKey, CppViewPos& viewPos);
    public void Journaling_RollbackSpecialization();
    public void Journaling_RollbackIncorrectPrimaryTemplate();
    public void Journaling_RollbackDeferredSpecialization();
    public void Journaling_RollbackDeferredSpecializationMerging(List`1<CppDeferredPackSpecializationData> data);
    public void Journaling_RollbackInstancing(CppClassInstantiationKey key);
    [CanBeNullAttribute]
protected ICppClassResolveEntity TryFindCachedInstantiation(CppClassInstantiationKey key);
    protected void MergeAllDeferredSpecializationsUpToWithoutLock(CppLocationAnchor upto);
    private static ICppTemplateArgument[] GetTemplateArgumentsByClassName(CppQualifiedNamePart name);
    private sealed virtual override CppList`1<ICppDeductionGuide> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeducibleTypeTemplateResolveEntity.GetDeductionGuides(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassTemplateResolveEntityPackUtil : object {
    [ExtensionAttribute]
public static ICppClassResolveEntity GetPrimaryTemplate(CppClassTemplateResolveEntityPack pack, CppViewPos& viewPos);
    [ExtensionAttribute]
public static ICppTemplateArgument[] GetDefaultParameters(CppClassTemplateResolveEntityPack pack, CppViewPos& viewPos);
    [ExtensionAttribute]
public static IEnumerable`1<ICppClassResolveEntity> GetSpecializations(CppClassTemplateResolveEntityPack pack, CppViewPos& viewPos);
    [ExtensionAttribute]
public static ICppTemplateArgument[] GetDefaultParameters(ICppClassResolveEntity primaryTemplate, CppViewPos& viewPos);
    [ExtensionAttribute]
public static bool IsPrimaryTemplateClass(ICppClassResolveEntity ent);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassTemplateResolveEntityPackWithSubstitution : CppClassTemplateResolveEntityPack {
    private CppClassTemplateResolveEntityPack myInner;
    private CppSubstitutionContext mySubst;
    public CppClassTemplateResolveEntityPackWithSubstitution(ICppScopeResolveEntity structuralParent, CppViewPos& viewPos, CppQualifiedNamePart name, CppClassTemplateResolveEntityPack inner, CppSubstitutionContext subst);
    public CppClassTemplateResolveEntityPackWithSubstitution(ICppScopeResolveEntity structuralParent, CppViewPos& viewPos, CppQualifiedNamePart name, CppClassTemplateResolveEntityPack inner, CppSubstitutionContext subst, int specCount);
    public CppClassTemplateResolveEntityPack GetInner();
    public virtual ICppTemplateArgument[] GetDefaults(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    protected virtual void SubstituteInnerDeductionGuides(ICppClassResolveEntity primaryTemplate, CppViewPos instantiationPoint);
    public virtual TResult Accept(ICppResolveEntityVisitor`1<TResult> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassTraits : ValueType {
    private int myFlags;
    private static CppClassTraits();
    public bool HasAbstractSpecifier();
    public bool IsFinal();
    public bool IsSealed();
    public bool IsFinalOrSealed();
    public CppClassVirtualSpecifiers GetClassVirtualSpecifiers();
    public void SetClassVirtualSpecifiers(CppClassVirtualSpecifiers specifiers);
    public bool Exported();
    public void SetExported(bool value);
    public bool IsAbstract(ICppClassResolveEntity clazz);
    public bool IsPolymorphic(ICppClassResolveEntity clazz);
    public bool HasVirtualDestructor(ICppClassResolveEntity clazz);
    public bool IsStandardLayout(ICppClassResolveEntity clazz, CppViewPos& vp);
    public bool IsTriviallyCopyable(ICppClassResolveEntity clazz, CppViewPos& vp);
    public bool HasTrivialDestructor(ICppClassResolveEntity clazz, CppViewPos& vp);
    public bool HasNothrowDestructor(ICppClassResolveEntity clazz, CppViewPos& vp);
    public bool IsTrivial(ICppClassResolveEntity clazz, CppViewPos& vp);
    public bool IsPOD(ICppClassResolveEntity clazz, CppViewPos& vp);
    public bool HasUniqueObjectRepresentations(ICppClassResolveEntity clazz, CppViewPos& vp);
    public bool HasTrivialConstructor(ICppClassResolveEntity clazz);
    public void Clear();
    private bool CalculateIsTriviallyCopyable(ICppClassResolveEntity clazz, CppViewPos& vp, int flags);
    private static bool ClassHasTrivialNonAccessibleDestructor(ICppClassResolveEntity clazz, CppViewPos& vp);
    private bool CalculateIsTrivial(ICppClassResolveEntity clazz, CppViewPos& vp, int flags);
    private bool CalculateIsPOD(ICppClassResolveEntity clazz, CppViewPos& vp, int flags);
    private bool CalculateHasUniqueObjectRepresentations(ICppClassResolveEntity clazz, CppViewPos& vp, int flags);
    private static int GetShift(LazyTraitIndex idx);
    private static TriBool Get(int flags, LazyTraitIndex idx);
    private bool Set(LazyTraitIndex idx, bool value);
    private static int GetShift(NonLazyTraitIndex idx);
    private static bool Get(int flags, NonLazyTraitIndex idx);
    private bool Set(NonLazyTraitIndex idx, bool value);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassVirtualSpecifiers : Enum {
    public byte value__;
    public static CppClassVirtualSpecifiers None;
    public static CppClassVirtualSpecifiers Final;
    public static CppClassVirtualSpecifiers Sealed;
    public static CppClassVirtualSpecifiers Abstract;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassVirtualSpecifiersUtil : object {
    public static void AddClassVirtualSpecifier(CppClassVirtualSpecifiers& target, TokenNodeType tt);
    [ExtensionAttribute]
public static string SpecsToString(CppClassVirtualSpecifiers specifiers);
    [ExtensionAttribute]
public static void SpecsToString(CppClassVirtualSpecifiers specifiers, StringBuilder sb);
    [ExtensionAttribute]
public static bool IsFinal(CppClassVirtualSpecifiers spec);
    [ExtensionAttribute]
public static bool IsSealed(CppClassVirtualSpecifiers spec);
    [ExtensionAttribute]
public static bool IsFinalOrSealed(CppClassVirtualSpecifiers spec);
    [ExtensionAttribute]
public static bool IsAbstract(CppClassVirtualSpecifiers spec);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassVisibility : object {
    [ExtensionAttribute]
public static bool IsClassComplete(ICppClassResolveEntity cent, CppViewPos& viewPos);
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertClassComplete(ICppClassResolveEntity input, CppViewPos& vp, string message);
    public static bool CanSeeClassContent(ICppClassResolveEntity cent, CppViewPos& viewPos);
    public static bool CanSeeClassContent(ICppClassOrGenericParameterResolveEntity ent, CppViewPos& viewPos);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCliFinalizerTag : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public CppCliFinalizerTag(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCliSimpleTypeId : object {
    private CppQualType myQualType;
    public CppCliSimpleTypeId(CppQualType qualType);
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
    public CppQualType GetQualType();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClrClassResolveEntity : object {
    private NotMergedState modreq(System.Runtime.CompilerServices.IsVolatile) myNotMergedSymbolsState;
    private CppList`1<ClrClassPartDescription> myParts;
    private ITypeElement myClazz;
    private CppClassKey myClassKey;
    private CppCachedReference`1<IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity>> myCachedClassConversions;
    private CppCachedReference`1<IEnumerable`1<ICppResolveEntity>> myCachedClassConstructors;
    private CppQualifiedNamePart myName;
    private ICppResolveEntity myParent;
    private Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>> myChildren;
    private CppDeclaratorResolveEntityPack myConstructors;
    private CppDeclaratorResolveEntityPack myStaticConstructors;
    private CppDeclaratorResolveEntityPack myConversions;
    private CppDeclaratorResolveEntityPack myDestructors;
    private CppDeclaratorResolveEntityPack myCliFinalizers;
    private CppBasicBaseDescription`1[] myBases;
    private CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> myNonDependentBases;
    private CppType myEnumUnderlyingType;
    private BuiltinClass myBuiltinClass;
    private CppPredefinedType myPredefinedType;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <LocationAnchor>k__BackingField;
    public IClrDeclaredElement ClrDeclaredElement { get; }
    public CppDependentInfo DependentInfo { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    private CppClrClassResolveEntity(ICppScopeResolveEntity scope, ICppResolveEntity parent, ITypeElement clazz, CppQualifiedNamePart name);
    public sealed virtual BuiltinClass GetBuiltinClass();
    public sealed virtual CppPredefinedType GetPredefinedType();
    public sealed virtual CppSmallList`1<ICppResolveEntity> ClrChildByName(CppQualifiedNamePart name);
    public sealed virtual IClrDeclaredElement get_ClrDeclaredElement();
    public sealed virtual bool HasDefinition();
    public sealed virtual bool Exported();
    public sealed virtual ICppDefinitionClassSymbol GetDefinitionSymbol();
    public sealed virtual CppClassKey GetKey();
    public sealed virtual CppClassTag GetTag();
    public sealed virtual CppClassVirtualSpecifiers GetClassVirtualSpecifiers();
    public sealed virtual bool IsFinalOrSealed();
    public sealed virtual bool HasAbstractSpecifier();
    public sealed virtual bool IsFinal();
    public sealed virtual bool IsSealed();
    public sealed virtual bool IsAnonymousClass();
    public sealed virtual bool IsAbstract();
    public sealed virtual bool IsPolymorphic();
    public sealed virtual bool HasVirtualDestructor();
    public bool IsTriviallyCopyable(CppViewPos& vp);
    public bool HasTrivialDestructor(CppViewPos& vp);
    public bool HasNothrowDestructor(CppViewPos& vp);
    public bool IsTrivial(CppViewPos& vp);
    public bool IsStandardLayout(CppViewPos& vp);
    public bool IsPOD(CppViewPos& vp);
    public bool HasUniqueObjectRepresentations(CppViewPos& vp);
    public sealed virtual bool HasTrivialConstructor();
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetClassConstructors();
    public sealed virtual CppQualType GetEnumUnderlyingType();
    public sealed virtual CppBasicBaseDescription`1[] GetBases();
    public sealed virtual CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> GetNonDependentBases();
    public sealed virtual ICppDeclaratorResolveEntityPack GetConversions();
    public sealed virtual ICppDeclaratorResolveEntityPack GetConstructors();
    public sealed virtual ICppDeclaratorResolveEntityPack GetStaticConstructors();
    public sealed virtual ICppDeclaratorResolveEntityPack GetDestructors();
    public sealed virtual ICppDeclaratorResolveEntityPack GetCliFinalizers();
    public IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity> GetClassConversions(CppViewPos& vp);
    public ICppTemplateArgument[] GetDefaultTemplateArguments(CppViewPos& vp);
    public sealed virtual CppAttributeList GetAttributes();
    public sealed virtual CppSmallList`1<ICppFunctionDeclaratorResolveEntity> GetFriendFunctions(CppQualifiedNamePart name);
    public sealed virtual ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppFunctionDeclaratorResolveEntity>> GetFriendFunctions();
    public sealed virtual CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity> GetFriendClasses(CppQualifiedNamePart name);
    public sealed virtual ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity>> GetFriendClasses();
    public sealed virtual CppSmallList`1<ICppDependentTypeResolveEntity> GetFriendDependentTypes();
    public sealed virtual CppList`1<ICppResolveEntity> GetAggregateMembers();
    public sealed virtual List`1<ICppResolveEntity> GetAllMembersSorted();
    public sealed virtual bool HasImmediateVirtualFunctions();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasFixedEnumUnderlyingType();
    public sealed virtual bool HasInheritingConstructors();
    public sealed virtual CppViewPos GetScopeForBaseClasses(ICppClassSymbol s);
    public sealed virtual CppLocationAnchor GetAnchorBySymbol(ICppClassOrDelegateSymbol s);
    public sealed virtual CppLocationAnchor GetDefinitionLocationAnchor();
    public sealed virtual bool IsEndLocationAnchorSet();
    public sealed virtual CppLocationAnchor GetEndLocationAnchor();
    public ICppGroupedTypeDeclaratorResolveEntity GetAssociatedTypedefForClass(CppViewPos& viewPos);
    public sealed virtual bool IsTemplateInstantiation();
    public sealed virtual ICppTemplateResolveEntity GetTemplate();
    public sealed virtual ICppTemplateArgument[] GetArguments();
    public sealed virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public sealed virtual CppDependentInfo get_DependentInfo();
    public sealed virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public sealed virtual void AddChild(ICppResolveEntity ent);
    public sealed virtual void RemoveChild(ICppResolveEntity e);
    public sealed virtual CppSmallList`1<ICppResolveEntity> ChildByName(CppQualifiedNamePart name, CppLocationAnchor anchor);
    public sealed virtual CppList`1<ICppResolveEntity> GetChildren();
    public sealed virtual void AddAnonymousClass(ICppClassResolveEntity e);
    public sealed virtual CppList`1<ICppClassResolveEntity> AnonymousClasses();
    public sealed virtual CppSmallList`1<ICppDeclaratorResolveEntityPack> GetAnonymousSubclassMembers(CppQualifiedNamePart name);
    public sealed virtual ICppResolveEntityParent get_RealParent();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    [CompilerGeneratedAttribute]
public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual TResult Accept(ICppResolveEntityVisitor`1<TResult> visitor);
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual bool ContainsSymbol(ICppClassOrDelegateSymbolOrModuleEntity s);
    public sealed virtual void Journaling_RollbackCachedClassConstructors();
    public sealed virtual CppDeclaratorResolveEntityPack GetOrCreateConversions(CppLocationAnchor anchor);
    public sealed virtual CppDeclaratorResolveEntityPack GetOrCreateConstructors(CppLocationAnchor anchor);
    public sealed virtual CppDeclaratorResolveEntityPack GetOrCreateStaticConstructors(CppLocationAnchor anchor);
    public sealed virtual CppDeclaratorResolveEntityPack GetOrCreateDestructors(CppLocationAnchor anchor);
    public sealed virtual CppDeclaratorResolveEntityPack GetOrCreateCliFinalizers(CppLocationAnchor anchor);
    public sealed virtual void AddFriend(ICppFunctionDeclaratorResolveEntity e);
    public sealed virtual void AddFriend(ICppTypeTemplateInstantiationResolveEntity e);
    public sealed virtual void AddFriend(ICppDependentTypeResolveEntity e);
    public sealed virtual void SetBases(CppList`1<CppBasicBaseDescription`1<CppQualifiedName>> bases);
    public sealed virtual void ResolveBases();
    public sealed virtual void AddSymbolPart(ICppClassOrDelegateSymbol sym, CppLocationAnchor anchor, CppQualifiedNamePart newName, CppAttributeList attributes);
    public sealed virtual void AddModulePart(CppClassOrEnumModuleEntity e, CppModuleImportingContext ctx);
    public sealed virtual void SetEnumUnderlyingType(CppQualType replacedType, CppLocationAnchor anchor);
    public sealed virtual void SetResolvedEnumUnderlyingType(CppQualType t);
    public sealed virtual void SetDefinitionLocationAnchor(CppLocationAnchor anchor);
    public sealed virtual void SetEndLocationAnchor(CppLocationAnchor anchor);
    public sealed virtual void AddSymbolsForLateMerging(CppList`1<ICppSymbol> syms, CppLocationAnchor anchor);
    public sealed virtual void ForceImporting();
    public sealed virtual CppConstructorDeclaratorResolveEntityPack EnsureConstructorExists(CppLocationAnchor anchor);
    public sealed virtual void SetAssociatedTypedef(CppDeclaratorResolveEntityPack assocTypedef);
    public sealed virtual void SetAssociatedTypedef(ICppTypeDeclaratorResolveEntity assocTypedef);
    public sealed virtual void RegisterAnonymousSubclassMembers(CppList`1<ICppDeclaratorResolveEntityPack> members);
    public sealed virtual void GenerateImplicitDisposableIfNeeded();
    public sealed virtual void Journaling_RollbackSymbolPart(bool isDefinition, int attributesCount, CppClassVirtualSpecifiers specs);
    public sealed virtual void Journaling_RollbackChild(ICppResolveEntity ent);
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public static ICppResolveEntity Import(ICppScopeResolveEntity parent, ITypeElement clazz);
    public ITypeElement GetTypeElement();
    public Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>> GetRawChildren();
    public static CppClassKey ComputeClassKey(ITypeElement element);
    public static CppClassVirtualSpecifiers ComputeClassVirtualSpecifiers(ITypeElement element);
    private void MergeNonMerged();
    private void MergeBases(CppClrTypeConverter& cvt);
    private void Journaling_RollbackMergedToClass();
    private bool IsInheritedFromIDisposable();
    private static bool IsIDisposable(ITypeElement clazz);
    private static bool Contains(IDeclaredType[] superTypes, ITypeElement clazz);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.IsTriviallyCopyable(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.HasTrivialDestructor(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.HasNothrowDestructor(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.IsTrivial(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.IsStandardLayout(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.IsPOD(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.HasUniqueObjectRepresentations(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.GetClassConversions(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    private sealed virtual override ICppTemplateArgument[] JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.GetDefaultTemplateArguments(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    private sealed virtual override ICppGroupedTypeDeclaratorResolveEntity JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.GetAssociatedTypedefForClass(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClrCreateLinkageEntityContext : object {
    private Dictionary`2<ITypeParameter, ICppLinkageTemplateParameter> mySubstitution;
    public int AddTemplateParameter(ITypeParameter tag);
    public void SetTemplateParameter(ITypeParameter tag, ICppLinkageTemplateParameter param);
    public void AddDirectTemplateParameterMapping(ITypeParameter tag, ICppLinkageTemplateParameter param);
    public ICppLinkageTemplateParameter GetTemplateParameter(ITypeParameter tag);
    public ICppLinkageTemplateParameter TryGetTemplateParameter(ITypeParameter tag);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClrEnumeratorDeclarator : CppGeneratedVariableDeclaratorResolveEntity {
    private ICppValue myValue;
    [CompilerGeneratedAttribute]
private IClrDeclaredElement <ClrDeclaredElement>k__BackingField;
    public IClrDeclaredElement ClrDeclaredElement { get; }
    public CppClrEnumeratorDeclarator(CppClrClassResolveEntity parent, IField field, CppClrTypeConverter& cvt);
    [CompilerGeneratedAttribute]
public sealed virtual IClrDeclaredElement get_ClrDeclaredElement();
    public sealed virtual ICppEvaluationResult GetValue(ICppEvaluationErrorTracker errorTracker);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual ICppClassResolveEntity GetEnumeration();
    public sealed virtual ICppEnumeratorResolveEntity GetPreviousEnumerator();
    public sealed virtual bool HasValueCached();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    private static ICppValue ConvertClrEnumeratorValue(object value);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClrLinkageEntityFactory : object {
    public static ICppLinkageEntity FromDeclaredElement(IClrDeclaredElement element);
    public static ICppLinkageEntity CreateLinkageEntity(IClrDeclaredElement arg, CppClrCreateLinkageEntityContext ctx);
    private static ICppLinkageEntity SetOwner(ICppLinkageEntity owner, CppMutableLinkageTemplateParameterList params);
    private static ICppLinkageTemplateParameter CreateLinkageGenericParameter(ITypeParameter param, CppMutableLinkageTemplateParameterList paramList, CppClrCreateLinkageEntityContext ctx);
    private static CppMutableLinkageTemplateParameterList CreateLinkageGenericParameters(IList`1<ITypeParameter> parameters, CppClrCreateLinkageEntityContext ctx);
    private static ICppLinkageTemplateArgument[] CreateLinkageGenericArguments(IList`1<ITypeParameter> parameters, ISubstitution substitution, CppClrCreateLinkageEntityContext ctx);
    private static ICppLinkageEntity CreateLinkageEntity(IClrDeclaredElement arg, ISubstitution substitution, CppClrCreateLinkageEntityContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClrNameConverter : object {
    private static Dictionary`2<string, CppQualifiedNamePart> operatorNameTable;
    private static CppClrNameConverter();
    public static CppQualifiedId ConvertName(ITypeParametersOwner function);
    public static CppQualifiedNamePart ConvertName(ICppScopeResolveEntity parent, ITypeParametersOwner function);
    public static CppQualifiedNamePart ConvertName(IClrDeclaredElement element);
    public static CppQualifiedNamePart ConvertName(IProperty element);
    public static string GetAccessorName(IAccessor accessor);
    public static CppQualifiedNamePart ConvertName(IAccessor accessor);
    public static CppQualifiedNamePart ConvertName(ISignOperator op);
    public static CppQualifiedNamePart ConvertGenericName(ICppScopeResolveEntity parent, ITypeParametersOwner clazz);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClrNamespaceResolveEntity : CppNamespaceResolveEntity {
    private HashSet`1<string> myCheckedClrChildNames;
    private Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>> myClrChildren;
    [CompilerGeneratedAttribute]
private INamespace <ClrPart>k__BackingField;
    public INamespace ClrPart { get; }
    public IClrDeclaredElement ClrDeclaredElement { get; }
    public CppClrNamespaceResolveEntity(ICppScopeResolveEntity parentScope, INamespace clrPart, CppQualifiedNamePart name, CppLocationAnchor anchor, Dictionary`2<CppQualifiedNamePart, CppUnmergedActions> actionsMap);
    [CompilerGeneratedAttribute]
public INamespace get_ClrPart();
    public virtual IClrDeclaredElement get_ClrDeclaredElement();
    public virtual CppSmallList`1<ICppResolveEntity> ChildByName(CppQualifiedNamePart part, CppLocationAnchor anchor, bool includeReachableButNotVisibleClasses);
    public virtual CppSmallList`1<ICppResolveEntity> ClrChildByName(CppQualifiedNamePart part);
    public virtual bool IsInline();
    public virtual string ToString();
    public virtual bool ShouldDump();
    public bool IsSystemNamespace();
    public static bool IsInternalTypeMember(IClrDeclaredElement declaredElement);
    private void EnsureClrElementsCreated(CppQualifiedNamePart name);
    private static bool HasNativeCppClassAttribute(IAttributesSet attributes);
    private ICppResolveEntity ImportTypeElement(ITypeElement clrClass, CppClrNamespaceResolveEntity ent, CppQualifiedId qualifiedId, Boolean& nativeCppClassWasCreated, Boolean& nativeCppEnumWasCreated);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClrTypeConverter : ValueType {
    private ICppResolveEntity myEntity;
    private HashMap`2<ITypeParameter, ICppGenericParameter> myParameterCache;
    [CompilerGeneratedAttribute]
private ICppResolvedTypeFactory <TypeFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private CppGlobalNamespaceResolveEntity <GlobalNamespace>k__BackingField;
    public ICppResolvedTypeFactory TypeFactory { get; }
    public CppGlobalNamespaceResolveEntity GlobalNamespace { get; }
    public CppClrTypeConverter(ICppResolveEntity entity);
    public CppClrTypeConverter(CppClrTypeConverter cvt, ITypeParametersOwner entity, CppQualifiedNamePart name);
    public ICppClassResolveEntity LookupClrClass(ITypeElement clrclass);
    private ICppClassResolveEntity LookupClrClass(ITypeElement clrclass, ISubstitution subst);
    private static CppSmallList`1<ITypeElement> GetParentClassChain(ITypeElement clazz);
    public ICppGenericParameter LookupGenericParameter(ITypeParameter param);
    public CppQualType ConvertType(IType type);
    public CppQualType ConvertType(IType type, bool constPtr);
    public CppQualType ConvertFunctionType(IParametersOwner func);
    public CppQualType ConvertFunctionType(IParametersOwner func, bool constPtr);
    public CppQualType ConvertBaseType(IDeclaredType type);
    public CppQualType[] ConvertFunctionParameters(IParametersOwner func, CppEllipsisKind& vararg, bool decorate);
    public CppQualType[] ConvertFunctionParameters(IParametersOwner func, CppEllipsisKind& vararg, bool decorate, bool constPtr);
    [CompilerGeneratedAttribute]
public ICppResolvedTypeFactory get_TypeFactory();
    [CompilerGeneratedAttribute]
public CppGlobalNamespaceResolveEntity get_GlobalNamespace();
    public CppViewPos ViewPosForInstantiation();
    public static CppDeclarationSpecifiers CalculateDeclarationSpecifiers(IModifiersOwner function);
    public static CppDeclarationSpecifiers CalculateDeclarationSpecifiers(IOverridableMember function);
    public static CppDeclarationSpecifiers CalculateDeclarationSpecifiers(IConstructor constructor);
    public static CppDeclarationSpecifiers CalculateDeclarationSpecifiers(IConversionOperator conv);
    public static CppDeclarationSpecifiers CalculateDeclarationSpecifiers(IProperty prop);
    public static CppDeclarationSpecifiers CalculateDeclarationSpecifiers(IEvent e);
    public static CppPureVirtualSpecifiers CalculatePureVirtualSpecifiers(IClrDeclaredElement parent, IModifiersOwner function);
    public static CppPureVirtualSpecifiers CalculatePureVirtualSpecifiers(IClrDeclaredElement parent, IOverridableMember function);
    public static CppPredefinedType GetPredefinedType(ITypeElement type, Boolean& found);
    private ICppClassResolveEntity DoLookupClrClass(IClrTypeName clrName, ISubstitution subst, CppSmallList`1<ITypeElement> parentClrClasses);
    private CppClrNamespaceResolveEntity DoLookupClrNamespace(IClrTypeName clrName);
    [CanBeNullAttribute]
private static ICppClassResolveEntity TryFindNativeClass(ICppClrScopeResolveEntity scope, CppQualifiedId typeName, IEnumerator`1<TypeNameAndTypeParameterNumber> enumerator);
    private void InitParameterCache();
    private void RegisterGeneric(ITypeParametersOwner elt, CppQualifiedNamePart name);
    private static bool ContainsTypeModifier(IType declaredType, Type modifierType);
    private static bool IsImplicitlyDereferencedType(IType type);
    private static bool HasConstModifier(IType type);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClrUngroupedFunctionDeclarator : CppGeneratedFunctionDeclaratorResolveEntity {
    private IClrDeclaredElement myElement;
    private List`1<ICppResolveEntity> myOverrideSpecifiers;
    private bool myIsExplicit;
    [CompilerGeneratedAttribute]
private CppDeclarationSpecifiers <DeclarationSpecifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private CppPureVirtualSpecifiers <PureVirtualSpecifiers>k__BackingField;
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public IClrDeclaredElement ClrDeclaredElement { get; }
    public CppClrUngroupedFunctionDeclarator(CppClrClassResolveEntity parent, IConstructor constructor, CppClrTypeConverter& cvt);
    public CppClrUngroupedFunctionDeclarator(CppClrClassResolveEntity parent, IMethod function, CppQualifiedNamePart name, CppClrTypeConverter& cvt);
    public CppClrUngroupedFunctionDeclarator(CppClrClassResolveEntity parent, IConversionOperator conv, CppClrTypeConverter& cvt);
    public CppClrUngroupedFunctionDeclarator(CppClrClassResolveEntity parent, ISignOperator conv, CppClrTypeConverter& cvt);
    public CppClrUngroupedFunctionDeclarator(CppCxxCliClrPropertyResolveEntity parent, IAccessor accessor, CppClrTypeConverter& cvt);
    [CompilerGeneratedAttribute]
public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    [CompilerGeneratedAttribute]
public virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public virtual CppAttributeList get_Attributes();
    public virtual CppAccessibility GetAccessibility();
    public sealed virtual IClrDeclaredElement get_ClrDeclaredElement();
    public virtual IEnumerable`1<ICppResolveEntity> GetResolvedCxxCliOverrideSpecifierTargets();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppClrUngroupedVariableDeclarator : CppGeneratedVariableDeclaratorResolveEntity {
    private IField myClrDeclaredElement;
    [CompilerGeneratedAttribute]
private CppPureVirtualSpecifiers <PureVirtualSpecifiers>k__BackingField;
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public IClrDeclaredElement ClrDeclaredElement { get; }
    public CppClrUngroupedVariableDeclarator(CppClrClassResolveEntity parent, IField field, CppClrTypeConverter& cvt);
    [CompilerGeneratedAttribute]
public virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public sealed virtual IClrDeclaredElement get_ClrDeclaredElement();
    public virtual CppAccessibility GetAccessibility();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCodeFragmentCompoundStatementResolveEntity : CppCompoundStatementResolveEntity {
    private ICppFileResolveEntitiesCache myFragmentCache;
    private CppLocationAnchor myOuterAnchor;
    private ICppScopeResolveEntity myRealResolveScope;
    public CppCodeFragmentCompoundStatementResolveEntity(ICppResolveEntity structuralParent, CppLocationAnchor outerAnchor, ICppFileResolveEntitiesCache cache);
    public virtual CppLocationAnchor GetOuterAnchor();
    public virtual ICppFileResolveEntitiesCache GetCodeFragmentResolveCache();
    public virtual Kind GetKind();
    public ICppScopeResolveEntity GetRealResolveScope();
    public void SetRealResolveScope(ICppScopeResolveEntity scope);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCodeFragmentResolveEntitiesCache : CppFileResolveEntitiesCacheBase {
    private ICppFileResolveEntitiesCache myOwner;
    private int myCurrentAnchor;
    public CppLocationAnchor CurrentAnchor { get; }
    public CppPPLocationAnchor CurrentPPAnchor { get; }
    public ICppRootFileResolveEntitiesCache RootCache { get; }
    public CppResolveMutex ResolveMutex { get; }
    public ICppResolvedTypeFactory TypeFactory { get; }
    public ICppResolvedTypeFactory VerboseTypeFactory { get; }
    public ICppResolvedTypeFactory VerboseNormalizingTypeFactory { get; }
    public CppRootInclusionContext InclusionContext { get; }
    public CppGlobalNamespaceResolveEntity GlobalNamespace { get; }
    public CppModuleId CurrentModule { get; }
    public bool AllowPendingActions { get; }
    public CppCodeFragmentResolveEntitiesCache(ICppScopeResolveEntity context);
    public sealed virtual Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> GetTemplateParametersMapping(ICppResolveEntity e);
    public sealed virtual CppLocationAnchor IncrementCurrentAnchor(int delta);
    public sealed virtual CppLocationAnchor IncrementCurrentAnchor();
    public sealed virtual CppLocationAnchor get_CurrentAnchor();
    public sealed virtual CppPPLocationAnchor IncrementCurrentPPAnchor();
    public sealed virtual CppPPLocationAnchor get_CurrentPPAnchor();
    public sealed virtual ICppRootFileResolveEntitiesCache get_RootCache();
    public sealed virtual CppResolveMutex get_ResolveMutex();
    public sealed virtual ICppResolvedTypeFactory get_TypeFactory();
    public sealed virtual ICppResolvedTypeFactory get_VerboseTypeFactory();
    public sealed virtual ICppResolvedTypeFactory get_VerboseNormalizingTypeFactory();
    public sealed virtual CppRootInclusionContext get_InclusionContext();
    public sealed virtual CppGlobalNamespaceResolveEntity get_GlobalNamespace();
    public sealed virtual CppLanguageDialect GetDialect();
    public sealed virtual CppModuleId get_CurrentModule();
    public sealed virtual bool get_AllowPendingActions();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCodeFragmentSymbolsCache : CppFileSymbolsCache {
    public CppPragmaPackState PragmaPack;
    public Nullable`1<UInt32> PragmaPackForChameleon { get; }
    public CppCodeFragmentSymbolsCache(CppCodeFragmentResolveEntitiesCache resolveEntitiesCache, CppSymbolTypeIntern typeIntern, CppFileLocation baseFile, Nullable`1<UInt32> pragmaPack, ICppBuilder rootBuilder);
    public virtual Nullable`1<UInt32> get_PragmaPackForChameleon();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppComparisonCategories : object {
    private ICppRootFileResolveEntitiesCache myResolveCache;
    private CppQualType myStrongOrdering;
    private CppQualType myWeakOrdering;
    private CppQualType myPartialOrdering;
    public CppComparisonCategories(ICppRootFileResolveEntitiesCache resolveCache);
    public static CppComparisonCategories FromViewPos(CppViewPos& viewPos);
    public CppQualType GetTypeFromComparisonCategory(CppComparisonCategoryType cat, CppTypeContext& tc);
    private CppQualType GetTypeFromComparisonCategoryImpl(CppQualType& cachedType, CppQualifiedName categoryName, CppComparisonCategoryType cat, CppTypeContext& tc);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppComparisonCategoriesUtil : object {
    public static string PresentComparisonCategory(CppComparisonCategoryType type);
    public static CppComparisonCategoryType GetCommonComparisonCategory(CppComparisonCategoryType a, CppComparisonCategoryType b);
    public static Nullable`1<CppComparisonCategoryType> GetComparisonCategoryFromType(CppQualType type);
    public static CppQualType GetTypeFromComparisonCategory(CppComparisonCategoryType cat, CppTypeContext& tc);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppComparisonCategoryNames : object {
    public static string StrongOrdering;
    public static string WeakOrdering;
    public static string PartialOrdering;
    public static CppQualifiedName ourStrongOrderingName;
    public static CppQualifiedName ourWeakOrderingName;
    public static CppQualifiedName ourPartialOrderingName;
    private static CppComparisonCategoryNames();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppComparisonCategoryType : Enum {
    public byte value__;
    public static CppComparisonCategoryType PartialOrdering;
    public static CppComparisonCategoryType WeakOrdering;
    public static CppComparisonCategoryType StrongOrdering;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppComparisonUtil : object {
    private static string SingleIndent;
    public static bool CanHaveDefaultSpecifier(ICppFunctionDeclaratorResolveEntity func);
    public static ValueTuple`2<bool, string> CanHaveDefaultSpecifier(ICppFunctionDeclaratorResolveEntity func, ICppPresenter presenter);
    private static bool CanHaveDefaultSpecifier(ICppFunctionDeclaratorResolveEntity func, StringBuilder reason, ICppPresenter presenter);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppFunctionDeclaratorResolveEntity GetDefaultedComparisonFunction(ICppGroupedFunctionDeclaratorResolveEntity func);
    [ExtensionAttribute]
public static bool IsDefaultedComparisonFunction(ICppGroupedFunctionDeclaratorResolveEntity func);
    [ExtensionAttribute]
public static bool IsDefaultedComparisonFunction(ICppFunctionDeclaratorResolveEntity func);
    [ExtensionAttribute]
public static CppDefaultedComparisonInfo CalculateDefaultedComparisonInfo(ICppFunctionDeclaratorResolveEntity func);
    [ExtensionAttribute]
private static ValueTuple`2<CppDefaultedComparisonInfo, string> CalculateDefaultedComparisonInfo(ICppFunctionDeclaratorResolveEntity func, ICppPresenter presenter);
    public static CppDefaultedComparisonInfo AppendReasonForDeletion(ICppFunctionDeclaratorResolveEntity func, String& str, ICppPresenter presenter);
    public static ICppResolvedOperatorCallExpression RewriteBinaryOperator(ICppResolvedBinaryExpression expr, ICppResolvedTypeFactory tf);
    public static bool IsReturnTypeOfRewrittenEqualityOperatorNotBool(CppResolveResult& rr, ICppResolvedTypeFactory typeFactory);
    [ExtensionAttribute]
public static string PresentComparisonCategoryLookupFailure(ICppPresenter presenter, CppComparisonCategoryType comparisonCategory);
    private static ICppFunctionDeclaratorResolveEntity FindFriendFunction(ICppFunctionDeclaratorResolveEntity func);
    private static bool IsConstReferenceToClass(CppQualType type, ICppClassResolveEntity cls);
    private static bool AreValidFriendComparisonFunctionParameters(CppQualType p1, CppQualType p2, ICppClassResolveEntity cls);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCompletionDecoration : object {
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public virtual ICppResolveEntity get_StructuralParent();
    public abstract virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCompletionDecorationUtil : object {
    public static ICppResolveEntity GetInnerResolveEntity(ICppResolveEntity ent);
    public static bool IsElaboratedReference(ICppResolveEntity ent);
    public static bool IsInjectedClassName(ICppResolveEntity ent);
    public static bool IsConstructorName(ICppResolveEntity ent);
    public static bool IsDependentUsing(ICppResolveEntity ent, Boolean& grayed);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppComplexOffset : ValueType {
    public static CppComplexOffset ZERO;
    public static int INF_TEXT_OFFSET;
    public static CppComplexOffset INF;
    public static int INVALID_TEXT_OFFSET;
    public static CppComplexOffset INVALID;
    [CompilerGeneratedAttribute]
private int <TextOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OffsetInSubstitution>k__BackingField;
    public int TextOffset { get; }
    public int OffsetInSubstitution { get; }
    public bool IsInvalid { get; }
    public CppComplexOffset(int textOffset, int offsetInSubstitution);
    public CppComplexOffset(int textOffset);
    private static CppComplexOffset();
    [CompilerGeneratedAttribute]
public int get_TextOffset();
    [CompilerGeneratedAttribute]
public int get_OffsetInSubstitution();
    public bool get_IsInvalid();
    public sealed virtual int CompareTo(CppComplexOffset r);
    public sealed virtual bool Equals(CppComplexOffset r);
    public virtual bool Equals(object r);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CppComplexOffset Min(CppComplexOffset one, CppComplexOffset other);
    public static CppComplexOffset Max(CppComplexOffset one, CppComplexOffset other);
    public static bool op_Equality(CppComplexOffset a, CppComplexOffset b);
    public static bool op_Inequality(CppComplexOffset a, CppComplexOffset b);
    public CppComplexOffset ShiftLocation(int textOffsetDelta);
    public CppComplexOffset PreviousOffset();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCompoundStatementBuilder : CppCompoundStatementBuilderBase {
    private CppCompoundStatementResolveEntity myResolveEnt;
    public CppCompoundStatementBuilder(ICppBuilder parent);
    public void LearnLocation(CppSymbolLocation location);
    public CppCompoundStatementResolveEntity GetCompoundStatementResolveEntity();
    public virtual CppScopeStatementResolveEntity GetResolveEntity();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCompoundStatementBuilderBase : CppScopeStatementBuilderBase {
    protected CppCompoundStatementSymbol mySymbol;
    protected CppCompoundStatementBuilderBase(ICppBuilder parent);
    public CppCompoundStatementSymbol GetCompoundStatementSymbol();
    public virtual CppScopeSymbol GetSymbol();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCompoundStatementInExpressionBuilder : CppCompoundStatementBuilderBase {
    private CppCompoundStatementInExpressionSymbol myStatementSymbol;
    public CppGnuExpressionCompoundStatementResolveEntity ResolveEntity;
    private CppLocationAnchor myStartAnchor;
    public CppCompoundStatementInExpressionBuilder(ICppBuilder parent, CppSymbolLocation loc);
    public void Finish();
    public CppCompoundStatementInExpressionSymbol GetStatementSymbol();
    public virtual CppScopeStatementResolveEntity GetResolveEntity();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCompoundStatementInExpressionSymbol : CppCompoundStatementSymbol {
    private int myAnchorDelta;
    public CppCompoundStatementInExpressionSymbol(CppSymbolLocation loc);
    public int GetAnchorDelta();
    public void SetAnchorDelta(int delta);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCompoundStatementModuleEntity : CppScopeStatementModuleEntity {
    public CppCompoundStatementModuleEntity(CppLocationAnchor anchor, CppRegularFunctionModuleEntity function);
    public virtual ICppStatementResolveEntity Import(CppScopeResolveEntityBase targetParent, CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCompoundStatementResolveEntity : CppScopeStatementResolveEntity {
    public static CppQualifiedId StaticName;
    public CppQualifiedNamePart Name { get; }
    public CppCompoundStatementResolveEntity(ICppResolveEntity parentScope, CppLocationAnchor location);
    private static CppCompoundStatementResolveEntity();
    public virtual CppQualifiedNamePart get_Name();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCompoundStatementResolveEntityWithSubstitution : CppCompoundStatementResolveEntity {
    public CppCompoundStatementResolveEntityWithSubstitution(ICppResolveEntity parent, CppLocationAnchor anchor);
    protected void Init(ICppScopeStatementResolveEntity inner, CppSubstitutionDriver driver, bool forceExpressionSubstitution);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCompoundStatementSymbol : CppScopeStatementSymbol {
    public CppCompoundStatementSymbol(CppSymbolLocation loc);
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConceptDefinition0Builder : object {
    private CppNormalDeclaration0Builder myParent;
    private CppConceptDefinitionSymbol myScopeSym;
    private CppConceptDefinitionResolveEntity myResolveEnt;
    private CppSymbolLocation myLocation;
    private CppQualifiedName myUnresolvedName;
    private CppQualifiedName myReplacedName;
    private CppDeclaratorCreationData myCreationData;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public CppConceptDefinitionSymbol Symbol { get; }
    public bool HasSymbol { get; }
    public CppConceptDefinition0Builder(CppNormalDeclaration0Builder parent);
    public sealed virtual void AddChild(CppParserSymbol _);
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    public sealed virtual ICppDeclarationBuilder GetDeclarationBuilder();
    public sealed virtual void LearnLocation(CppSymbolLocation location);
    public void LearnQualifiedName(CppTwinQualifiedNameBuilder& twinBuilder);
    public sealed virtual void ComposeSymbol(CppSymbolLocation loc);
    public sealed virtual void LearnExpression(CppTwinExpressionBuilder& exprBuilder);
    public sealed virtual CppConceptDefinitionSymbol get_Symbol();
    public sealed virtual bool get_HasSymbol();
    private sealed virtual override void JetBrains.ReSharper.Psi.Cpp.Symbols.ICppConceptDefinitionBuilder.LearnQualifiedName(CppTwinQualifiedNameBuilder& modreq(System.Runtime.InteropServices.InAttribute) _);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConceptDefinitionModuleEntity : object {
    public ICppExpression Definition;
    public ICppScopeModuleEntity Parent;
    private CppQualifiedNamePart myName;
    private CppSymbolLocation mySymbolLocation;
    private bool myExplicitlyExported;
    public int Index;
    public CppConceptDefinitionModuleEntity(int index, CppQualifiedNamePart name, ICppScopeModuleEntity parent, CppConceptDefinitionResolveEntity source);
    internal CppConceptDefinitionModuleEntity(int index);
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual ICppScopeModuleEntity GetParent();
    public sealed virtual CppConceptDefinitionSymbol GetSymbol();
    public sealed virtual CppSymbolLocation GetSymbolLocation();
    public sealed virtual bool Export();
    public sealed virtual bool IsExplicitlyExported();
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public sealed virtual CppConceptDefinitionResolveEntity Import(CppModuleImportingContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConceptDefinitionResolveEntity : object {
    private ICppResolveEntityParentScope myParent;
    private CppQualifiedNamePart myName;
    private ICppConceptDefinitionSymbolOrModuleEntity mySource;
    private ICppExpression myReplacedExpression;
    private CppModuleImportingContext myImportingContext;
    private ICppResolvedExpression myResolvedExpression;
    private CppCachedReference`1<ICppTemplateArgument[]> myDefaults;
    private ConcurrentDictionary`2<ICppTemplateArgument[], ICppConceptDefinitionResolveEntity> mySubstCache;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <LocationAnchor>k__BackingField;
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public CppQualifiedNamePart FullName { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppConceptDefinitionResolveEntity(ICppResolveEntityParentScope parent, CppQualifiedNamePart name, CppConceptDefinitionSymbol sym, CppLocationAnchor anchor);
    public CppConceptDefinitionResolveEntity(ICppResolveEntityParentScope parent, CppQualifiedNamePart name, CppConceptDefinitionModuleEntity source, CppModuleImportingContext importingContext);
    private CppConceptDefinitionResolveEntity(ICppResolveEntityParentScope parent, CppQualifiedNamePart name, CppLocationAnchor anchor);
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual CppQualifiedNamePart get_FullName();
    [CompilerGeneratedAttribute]
public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual ICppResolvedExpression GetDefinition();
    private ICppResolvedExpression CalculateResolvedExpression();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual CppTemplateParametersBase GetParameters();
    public ICppTemplateArgument[] GetDefaults(CppViewPos& vp);
    internal void SetDefaults(ICppTemplateArgument[] defaults);
    private static ICppTemplateArgument[] CalculateDefaults(CppConceptDefinitionResolveEntity this);
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetAllSpecializations();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public ICppConceptDefinitionResolveEntity InstantiateTemplate(ReadOnlySpan`1<ICppTemplateArgument> args, CppViewPos& vp);
    public ICppConceptDefinitionResolveEntity ModuleImporting_InstantiateTemplateWithSanitizedArguments(ICppTemplateArgument[] sanitizedArgs, CppViewPos& vp);
    public bool Export();
    public bool IsImported();
    public void Dump(CppIndentationStringBuilder tw);
    public virtual string ToString();
    public CppSymbolLocation GetSymbolLocation();
    public void SetReplacedExpression(ICppExpression expression);
    public CppReExportedConceptDefinitionModuleEntity CreateReExportedModuleEntity();
    private sealed virtual override ICppConceptDefinitionResolveEntity JetBrains.ReSharper.Psi.Cpp.Symbols.ICppConceptDefinitionTemplateResolveEntity.InstantiateTemplate(ReadOnlySpan`1<ICppTemplateArgument> args, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override ICppTemplateArgument[] JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateResolveEntityBase.GetDefaults(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConceptDefinitionSymbol : CppParserSymbol {
    private CppSymbolTemplateParametersList myParamList;
    private bool myExport;
    private ICppExpression myExpression;
    [CompilerGeneratedAttribute]
private CppFileLocation <ContainingFile>k__BackingField;
    public CppFileLocation ContainingFile { get; }
    public CppConceptDefinitionSymbol(CppQualifiedName name, CppSymbolTemplateParametersList paramList, ICppExpression expression, CppSymbolLocation loc, bool export);
    [CompilerGeneratedAttribute]
public virtual CppFileLocation get_ContainingFile();
    public CppSymbolTemplateParametersList ParamList();
    public ICppExpression GetExpression();
    public void SetExpression(ICppExpression expr);
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual string ToString();
    public sealed virtual CppConceptDefinitionSymbol GetSymbol();
    public sealed virtual CppSymbolLocation GetSymbolLocation();
    public sealed virtual bool Export();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConceptDefinitionWithAppliedArgumentsResolveEntity : CppTemplateWithAppliedArgumentsResolveEntityBase {
    private CppViewPos myViewPos;
    private CppDependentInfo myDependentInfo;
    private CppCachedReference`1<ICppResolvedExpression> myDefinition;
    private CppCachedReference`1<ICppEvaluationResult> myCachedValue;
    public CppQualifiedNamePart FullName { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppConceptDefinitionWithAppliedArgumentsResolveEntity(CppConceptDefinitionResolveEntity templ, ICppTemplateArgument[] args, CppViewPos& viewPos);
    public sealed virtual CppQualifiedNamePart get_FullName();
    public sealed virtual ICppResolvedExpression GetDefinition();
    private ICppResolvedExpression CalculateDefinition();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public ICppEvaluationResult GetValue();
    private ICppEvaluationResult CalculateValue();
    public CppConceptDefinitionResolveEntity GetConceptTemplate();
    public ICppConceptDefinitionResolveEntity DoSubstitutionGetResolveEntity(CppSubstitutionDriver substDriver);
    public virtual string ToString();
    public CppTypeContext GetTypeContext();
    private ICppEvaluationResult EvaluateDefinition(ICppResolvedExpression definition);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConceptParameterBuilder : CppForwardingBuilder {
    private string myName;
    private CppQualifiedName myUnresolvedConceptName;
    private CppQualifiedName myReplacedConceptName;
    private CppSymbolLocation myLocation;
    private CppConceptDefinitionResolveEntity myConcept;
    private ICppTemplateParameter myPrototypeParameter;
    private ICppTypeTemplateArgument myUnresolvedDefaultType;
    private ICppTypeTemplateArgument myReplacedDefaultType;
    private bool myWasBuilt;
    private bool myHasEllipsis;
    private ICppTemplateParameterSymbol mySymbol;
    private ICppTemplateParameter myEntity;
    public CppConceptParameterBuilder(CppTemplateHeaderBuilder parentBuilder);
    public sealed virtual void LearnLocation(CppSymbolLocation loc);
    public sealed virtual void LearnConceptName(CppTwinQualifiedNameBuilder nameBuilder);
    public sealed virtual void LearnEllipsis();
    public sealed virtual void LearnName(string name);
    public sealed virtual bool LearnConcept(CppConceptDefinitionResolveEntity reference);
    public sealed virtual void LearnDefaultTypeArgument(ICppDeclarationBuilder declBuilder);
    public sealed virtual ICppTemplateParameterSymbol GetSymbol();
    public ICppTemplateParameter GetResolveEntity();
    private void Build();
    private void BuildType();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConceptSpecializationLinkageEntity : CppUndeterminedSpecializationLinkageEntity {
    public CppConceptSpecializationLinkageEntity(CppQualifiedNamePart name, ICppLinkageEntity parent, ICppLinkageEntity primaryTemplate);
    public virtual Result Accept(ICppDependentLinkageEntityVisitor`1<Result> visitor);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConceptTemplateParameterSymbolBase : CppParameterSymbolBase {
    private CppQualifiedName myConceptName;
    private string myName;
    public string NamePartRaw { get; }
    public CppQualifiedNamePart NamePart { get; }
    protected CppConceptTemplateParameterSymbolBase(string name, CppSymbolLocation loc, CppQualifiedName concept);
    public virtual string get_NamePartRaw();
    public virtual CppQualifiedNamePart get_NamePart();
    public virtual CppQualifiedName GetConceptName();
    public virtual ICppTemplateArgument GetDefault();
    public virtual string ToString();
}
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConceptTemplateParameterUtil : object {
    public static CppQualifiedName CalculateResolvedConceptNameHintByReplacedConceptName(ICppConceptTemplateParameter param, ICppRootFileResolveEntitiesCache resolvedCache);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConceptTypeTemplateParameter : CppConceptTypeTemplateParameterBase {
    private ICppTypeTemplateArgument myUnresolvedDefault;
    private ICppTypeTemplateArgument myResolvedDefault;
    public CppConceptTypeTemplateParameter(CppConceptTypeTemplateParameterSymbol sym, CppViewPos& viewPos, CppQualifiedName conceptName, CppConceptDefinitionResolveEntity concept, ICppTypeTemplateArgument unresolvedDefault);
    public virtual ICppTemplateArgument GetDefault(ICppResolvedTypeFactory tf);
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConceptTypeTemplateParameterBase : CppTypeTemplateParameterBase {
    protected CppQualifiedName myReplacedConceptName;
    private CppCachedReference`1<CppConceptDefinitionResolveEntity> myResolvedConcept;
    private CppCachedReference`1<ICppResolvedExpression> myResolvedConceptExpression;
    protected CppConceptTypeTemplateParameterBase(CppConceptTypeTemplateParameterSymbolBase sym, CppViewPos& viewPos, CppQualifiedName conceptName, CppConceptDefinitionResolveEntity concept);
    public virtual CppQualifiedName GetReplacedConceptName();
    public sealed virtual CppQualifiedName CalculateResolvedConceptNameHint();
    public virtual bool IsConcept();
    public virtual CppConceptDefinitionResolveEntity GetResolvedConcept();
    public virtual ICppResolvedExpression GetResolvedConceptExpression();
    public virtual void Journaling_RollbackCachedConcept();
    public virtual void Journaling_RollbackCachedConceptExpression();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConceptTypeTemplateParameterPack : CppConceptTypeTemplateParameterBase {
    public CppConceptTypeTemplateParameterPack(CppConceptTypeTemplateParameterPackSymbol sym, CppViewPos& viewPos, CppQualifiedName conceptName, CppConceptDefinitionResolveEntity concept);
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual ICppTemplateArgumentPack CreateEmptyMatchingArgumentPack();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConceptTypeTemplateParameterPackSymbol : CppConceptTypeTemplateParameterSymbolBase {
    public CppConceptTypeTemplateParameterPackSymbol(string name, CppSymbolLocation loc, CppQualifiedName concept, CppTypeTemplateParameterKey key);
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConceptTypeTemplateParameterSymbol : CppConceptTypeTemplateParameterSymbolBase {
    protected CppConceptTypeTemplateParameterSymbol(string name, CppSymbolLocation loc, CppQualifiedName concept, CppTypeTemplateParameterKey key);
    public static CppConceptTypeTemplateParameterSymbol Create(string name, CppSymbolLocation loc, CppQualifiedName concept, CppTypeTemplateParameterKey key, ICppTemplateArgument def);
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConceptTypeTemplateParameterSymbolBase : CppConceptTemplateParameterSymbolBase {
    [CompilerGeneratedAttribute]
private CppTypeTemplateParameterKey <Key>k__BackingField;
    public CppTypeTemplateParameterKey Key { get; }
    protected CppConceptTypeTemplateParameterSymbolBase(string name, CppSymbolLocation loc, CppQualifiedName concept, CppTypeTemplateParameterKey key);
    [CompilerGeneratedAttribute]
public virtual CppTypeTemplateParameterKey get_Key();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConceptTypeTemplateParameterWithArgumentSymbol : CppConceptTypeTemplateParameterSymbol {
    private ICppTemplateArgument myDefault;
    public CppConceptTypeTemplateParameterWithArgumentSymbol(string name, CppSymbolLocation loc, CppQualifiedName concept, CppTypeTemplateParameterKey key, ICppTemplateArgument def);
    public virtual ICppTemplateArgument GetDefault();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppConditionalExprKind : Enum {
    public int value__;
    public static CppConditionalExprKind QuestionMark;
    public static CppConditionalExprKind GnuChooseExpr;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConstrainedAutoTypeModuleEntity : object {
    [CanBeNullAttribute]
public ICppConceptDefinitionModuleEntity ConceptDefinition;
    public CppQualifiedName Name;
    public bool IsDecltypeAuto;
    public bool IsVariadic;
    public CppConstrainedAutoTypeModuleEntity(ICppConceptDefinitionModuleEntity conceptDefinition, CppQualifiedName name, bool isDecltypeAuto, bool isVariadic);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConstructorDeclaratorResolveEntityPack : CppDeclaratorWithImplicitsResolveEntityPackBase {
    private bool myGeneratingInProgress;
    public CppConstructorDeclaratorResolveEntityPack(ICppMutableClassResolveEntity klass, CppQualifiedNamePart name, CppLocationAnchor anchor);
    protected virtual bool GenerateImplicits();
    public bool GeneratingInProgress();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppConstructorKind : Enum {
    public int value__;
    public static CppConstructorKind COPY;
    public static CppConstructorKind MOVE;
    public static CppConstructorKind UNKNOWN;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConstructorKindUtil : object {
    [ExtensionAttribute]
public static CppConstructorKind GetConstructorKind(ICppClassResolveEntity clsT, ICppFunctionDeclaratorResolveEntity decl);
    [ExtensionAttribute]
public static CppConstructorKind GetConstructorKind(ICppClassResolveEntity clsT, ICppFunctionDeclaratorResolveEntity decl, CppQualType& argType);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppContinueStatementResolveEntity : CppGotoStatementResolveEntityBase {
    private static CppQualifiedId ourName;
    public CppQualifiedNamePart Name { get; }
    public CppContinueStatementResolveEntity(ICppResolveEntity parent, CppLocationAnchor anchor);
    private static CppContinueStatementResolveEntity();
    public virtual CppQualifiedNamePart get_Name();
    public virtual CppGotoStatementKind GetKind();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppControlStructureScopeResolveEntity : CppScopeStatementResolveEntity {
    protected CppControlStructureScopeResolveEntity(ICppResolveEntity parentScope, CppLocationAnchor location);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppControlStructureStatementModuleEntity : CppScopeStatementModuleEntity {
    protected CppControlStructureStatementModuleEntity(CppLocationAnchor anchor, CppRegularFunctionModuleEntity function);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConversionId : object {
    private CppQualType myConversionType;
    public CppConversionId(CppQualType conversionType);
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public CppQualType GetConversionType();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppConversionsPackId : object {
    public static CppConversionsPackId INSTANCE;
    private static CppConversionsPackId();
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCreateClassAndReplaceClassTypeContext : ValueType {
    public ICppResolvedTypeFactory typeFactory;
    public ICppFileResolveEntitiesCache cache;
    public bool allowsPendingActions;
    public bool allowsLatePendingActions;
    public ICppScopeResolveEntity lexicalParent;
    public ICppScopeResolveEntity structuralParent;
    public CppTemplateHeaders templateHeaders;
    public CppQualType declSpecQualType;
    [CanBeNullAttribute]
public CppTemplateParametersBase inventedTemplateParams;
    public bool isFunctionParameterPack;
    public CppCreateClassAndReplaceClassTypeContext(ICppResolvedTypeFactory typeFactory, ICppFileResolveEntitiesCache cache, bool allowsPendingActions, bool allowsLatePendingActions);
    public CppCreateClassAndReplaceClassTypeContext Init(ICppScopeResolveEntity lexicalParent, ICppScopeResolveEntity structuralParent, CppTemplateHeaders& templateHeaders, CppQualType declSpecQualType);
    public CppCreateClassAndReplaceClassTypeContext Init(ICppScopeResolveEntity lexicalParent, ICppScopeResolveEntity structuralParent, CppTemplateHeaders& templateHeaders);
    public CppCreateClassAndReplaceClassTypeContext Init(ICppScopeResolveEntity lexicalParent, ICppScopeResolveEntity structuralParent);
    public CppCreateClassAndReplaceClassTypeContext Init(ICppScopeResolveEntity lexicalParent, CppTemplateHeaders& templateHeaders);
    public CppCreateClassAndReplaceClassTypeContext Init(ICppScopeResolveEntity lexicalParent);
    public static CppCreateClassAndReplaceClassTypeContext CreateByResolveEntitiesCache(ICppFileResolveEntitiesCache cache, bool allowsPendingActions, bool allowsLatePendingActions);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCreateLinkageEntityContext : object {
    private Dictionary`2<CppTemplateParameterTag, ICppLinkageTemplateParameter> mySubstitution;
    [CanBeNullAttribute]
private HashSet`1<ICppResolvedExpression> myConvertingRightNowRequiresClauses;
    [CanBeNullAttribute]
private HashSet`1<ICppClassResolveEntity> myConvertingRightNowClasses;
    private Dictionary`2<ICppResolveEntity, ICppLinkageEntity> myLocalEntityCache;
    [CompilerGeneratedAttribute]
private CppLinkageEntityCache <LinkageCache>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppRootFileResolveEntitiesCache <ResolveCache>k__BackingField;
    public CppLinkageEntityCache LinkageCache { get; }
    public ICppRootFileResolveEntitiesCache ResolveCache { get; }
    public CppCreateLinkageEntityContext(ICppRootFileResolveEntitiesCache resolveCache);
    private CppCreateLinkageEntityContext(Dictionary`2<ICppResolveEntity, ICppLinkageEntity> localEntityCache, ICppRootFileResolveEntitiesCache resolveCache, CppLinkageEntityCache linkageCache, HashSet`1<ICppResolvedExpression> convertingRightNowRequiresClauses, HashSet`1<ICppClassResolveEntity> convertingRightNowClasses);
    [CompilerGeneratedAttribute]
public CppLinkageEntityCache get_LinkageCache();
    [CompilerGeneratedAttribute]
public ICppRootFileResolveEntitiesCache get_ResolveCache();
    public static CppCreateLinkageEntityContext ContextForViewPos(CppViewPos& vp);
    public static CppCreateLinkageEntityContext ContextForPsiNode(ICppCompositeNode node);
    public static CppCreateLinkageEntityContext ContextForDeclarator(ICppDeclaratorResolveEntity decl);
    public int AddTemplateParameter(CppTemplateParameterTag tag);
    public void SetTemplateParameter(CppTemplateParameterTag tag, ICppLinkageTemplateParameter param);
    public void AddDirectTemplateParameterMapping(CppTemplateParameterTag tag, ICppLinkageTemplateParameter param);
    public ICppLinkageTemplateParameter GetTemplateParameter(CppTemplateParameterTag tag);
    public ICppLinkageTemplateParameter TryGetTemplateParameter(CppTemplateParameterTag tag);
    public ICppLinkageEntity TryLookupLocalCachedEntity(ICppResolveEntity entity);
    public void AddLocalCachedEntity(ICppResolveEntity entity, ICppLinkageEntity linkage);
    public bool IsConvertingRightNow(ICppClassResolveEntity clazz);
    public void MarkAsConvertingRightNow(ICppClassResolveEntity clazz);
    public void MarkAsConverted(ICppClassResolveEntity clazz);
    public ICppExpression ConvertRequiresClause(ICppResolvedExpression requiresClause);
    private bool MarkRequiresClauseAsCurrentlyConverted(ICppResolvedExpression requiresClause);
    public static CppQualifiedNamePart ConvertLinkageEntityName(CppQualifiedNamePart name, ICppLinkageEntity ent, CppCreateLinkageEntityContext ctx);
    public CppCreateLinkageEntityContext CloneWithEmptyTemplateParameterSubstitution();
    private static void PopulateContextFromResolveEntity(ICppResolveEntity ent, CppCreateLinkageEntityContext ctx);
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCreateSubstitutionUtil : object {
    private static bool ContainsPackExpansion(ICppTemplateArgument arg);
    public static bool AreValidArgumentsForSubstituionDict(CppTemplateParametersBase params, ICppTemplateArgument[] args, bool strict);
    public static CppSubstitutionContext TemplateArgumentsToSubstitutionDict(ICppResolveEntity e, ICppTemplateArgument[] args);
    public static CppSubstitutionContext TemplateArgumentsToSubstitutionDict(CppTemplateParametersBase params, ICppTemplateArgument[] args);
    public static FrugalLocalList`1<Pair`2<ICppTemplateArgumentPack, CppTemplateParameterTag>> FindArgumentPacks(CppQualType type, ICppSubstitutionContext subst, Int32& cardinality);
    public static CppQualifiedNamePart ConstructSubstitutionName(ICppResolveEntity e, ICppTemplateArgument[] args, CppViewPos viewPos, CppSubstitutionContext substitutionContext);
    public static ICppTemplateArgument[] ExtractArgumentFromDeduced(ICppResolveEntity e, CppSubstitutionContext subst);
    public static CppQualifiedNamePart ConstructSubstitutionNameFromDeduced(ICppResolveEntity e, CppSubstitutionContext subst, CppViewPos& viewPos);
    public static ICppResolveEntity CreateSubstitutionResolveEntity(ICppScopeResolveEntity structuralParent, CppQualifiedNamePart name, ICppResolveEntity ent, CppSubstitutionDriver driver);
    public static ICppClassResolveEntity CreateClassSubstitutionResolveEntity(ICppResolveEntity structuralParent, CppViewPos& viewPos, CppQualifiedNamePart name, ICppClassResolveEntity ent, ICppSubstitutionContext subst);
    public static ICppDeclaratorResolveEntity CreateDeclaratorSubstitutionResolveEntity(ICppResolveEntity structuralParent, CppViewPos& viewPos, CppQualifiedNamePart name, ICppDeclaratorResolveEntity ent, ICppSubstitutionContext subst);
    public static CppClassTemplateResolveEntityPack CreateClassTemplatePackSubstitutionResolveEntity(ICppScopeResolveEntity structuralParent, CppViewPos& viewPos, CppQualifiedNamePart name, CppClassTemplateResolveEntityPack pack, ICppSubstitutionContext subst);
    public static CppDeclaratorResolveEntityPack CreateDeclaratorPackSubstitutionResolveEntity(CppClassResolveEntityWithSubstitution structuralParent, CppViewPos& viewPos, CppQualifiedNamePart name, ICppDeclaratorResolveEntityPack pack, ICppSubstitutionContext subst);
    public static CppLambdaScopeResolveEntity CreateSubstitutionResolveEntity(ICppResolveEntity structuralParent, CppViewPos& vp, CppLambdaScopeResolveEntity scope, ICppSubstitutionContext subst);
    public static ICppGroupedFunctionDeclaratorResolveEntity CreateSubstitutionResolveEntity(ICppResolveEntity structuralParent, CppViewPos& viewPos, CppQualifiedNamePart name, ICppGroupedFunctionDeclaratorResolveEntity pack, ICppSubstitutionContext subst, ICppMutableFunctionTemplateDeclaratorResolveEntity newTemplateDecl);
    public static ICppGroupedTypeDeclaratorResolveEntity CreateSubstitutionResolveEntity(ICppResolveEntity structuralParent, CppViewPos& viewPos, CppQualifiedNamePart name, ICppGroupedTypeDeclaratorResolveEntity pack, ICppSubstitutionContext subst, ICppTypeTemplateDeclaratorResolveEntity newTemplateDecl);
    public static ICppGroupedVariableDeclaratorResolveEntity CreateSubstitutionResolveEntity(ICppResolveEntity structuralParent, CppViewPos& viewPos, CppQualifiedNamePart name, ICppGroupedVariableDeclaratorResolveEntity pack, ICppSubstitutionContext subst, ICppVariableTemplateDeclaratorResolveEntity newTemplateDecl);
    public static ICppCxxCliPropertyDeclaratorResolveEntity CreateCliPropertySubstitutionResolveEntity(ICppResolveEntity structuralParent, CppViewPos& viewPos, CppQualifiedNamePart name, ICppCxxCliPropertyDeclaratorResolveEntity pack, ICppSubstitutionContext subst);
    public static List`1<ICppClassResolveEntity> CreateSubstitutionResolveEntity(ICppResolveEntity structuralParent, CppViewPos& viewPos, IEnumerable`1<ICppClassResolveEntity> ents, ICppSubstitutionContext subst);
    private static ICppFunctionTemplateDeclaratorResolveEntity CreateFunctionTemplateSubstitutionResolveEntity(CppClassResolveEntityWithSubstitution structuralParent, CppQualifiedNamePart name, ICppFunctionTemplateDeclaratorResolveEntity pack, CppSubstitutionDriver driver);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCtorInitializerStatementModuleEntity : CppStatementModuleEntityBase {
    [CanBeNullAttribute]
private ICppModuleEntity myTarget;
    [CanBeNullAttribute]
private ICppModuleOperatorCallExpression myExpression;
    private CppSmallArray`1<ICppExpression> myArguments;
    private CppArgumentListKind myArgumentListKind;
    private bool myIsPackExpansion;
    public CppCtorInitializerStatementModuleEntity(ICppModuleEntity target, CppSmallArray`1<ICppExpression> arguments, ICppModuleOperatorCallExpression expression, CppArgumentListKind argumentListKind, CppLocationAnchor anchor, bool isPackExpansion);
    public virtual ICppStatementResolveEntity Import(CppScopeResolveEntityBase targetParent, CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    private static ICppResolvedExpression[] ImportResolvedArguments(CppSmallArray`1<ICppExpression> source, CppModuleImportingContext ctx);
    private static ICppResolveEntity ImportCtorInitializerTarget(ICppModuleEntity source, CppModuleImportingContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCtorInitializerStatementResolveEntity : CppCtorInitializerStatementResolveEntityBase {
    private CppQualifiedName myName;
    private CppCachedReference`1<ICppResolveEntity> myResolvedTarget;
    private CppCachedReference`1<ICppResolvedExpression[]> myResolvedArguments;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <LocationAnchor>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppExpression[] <Arguments>k__BackingField;
    public CppLocationAnchor LocationAnchor { get; }
    public ICppExpression[] Arguments { get; }
    public CppSubstitutionContext ExpansionClosure { get; }
    public CppCtorInitializerStatementResolveEntity(ICppScopeResolveEntity parent, CppLocationAnchor anchor, CppQualifiedName name, ICppExpression[] args, CppArgumentListKind argumentListKind, bool isPackExpansion);
    public CppCtorInitializerStatementResolveEntity(ICppScopeResolveEntity parent, CppLocationAnchor anchor, ICppResolveEntity target, ICppResolvedExpression[] resolvedArgs, ICppResolvedOperatorCallExpression expression, CppArgumentListKind argumentListKind, bool isPackExpansion);
    [CompilerGeneratedAttribute]
public virtual CppLocationAnchor get_LocationAnchor();
    [CompilerGeneratedAttribute]
public ICppExpression[] get_Arguments();
    public virtual CppSubstitutionContext get_ExpansionClosure();
    public virtual string ToString();
    public virtual ICppResolveEntity GetResolvedTarget();
    public virtual ICppResolvedExpression[] GetResolvedArguments();
    public virtual CppViewPos GetViewPos();
    private ICppResolveEntity ResolveTarget();
    private ICppResolvedExpression[] ResolveArguments();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCtorInitializerStatementResolveEntityBase : object {
    protected ICppScopeResolveEntity myParent;
    protected CppCachedReference`1<ICppResolvedOperatorCallExpression> myCachedExpression;
    [CompilerGeneratedAttribute]
private CppArgumentListKind <ArgumentListKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPackExpansion>k__BackingField;
    public ICppResolveEntity StructuralParent { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppQualifiedNamePart Name { get; }
    public CppArgumentListKind ArgumentListKind { get; }
    public bool IsPackExpansion { get; }
    [CanBeNullAttribute]
public CppSubstitutionContext ExpansionClosure { get; }
    protected CppCtorInitializerStatementResolveEntityBase(ICppScopeResolveEntity parent, CppArgumentListKind argumentListKind, bool isPackExpansion);
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public abstract virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    [CompilerGeneratedAttribute]
public CppArgumentListKind get_ArgumentListKind();
    [CompilerGeneratedAttribute]
public bool get_IsPackExpansion();
    public abstract virtual CppSubstitutionContext get_ExpansionClosure();
    [CanBeNullAttribute]
public abstract virtual ICppResolveEntity GetResolvedTarget();
    public CppQualType GetTargetType(ICppResolvedTypeFactory tf);
    public abstract virtual ICppResolvedExpression[] GetResolvedArguments();
    public ICppResolvedOperatorCallExpression GetResolvedExpression();
    public abstract virtual CppViewPos GetViewPos();
    protected static ICppResolveEntity GetResolveTargetFromType(CppQualType type);
    private ICppResolvedOperatorCallExpression ResolveExpression();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCtorInitializerStatementResolveEntityWithSubstitution : CppCtorInitializerStatementResolveEntityBase {
    private CppCtorInitializerStatementResolveEntityBase myInner;
    private CppSubstitutionDriver myDriver;
    private CppCachedReference`1<ICppResolveEntity> myResolvedTarget;
    private CppCachedReference`1<ICppResolvedExpression[]> myResolvedArguments;
    [CompilerGeneratedAttribute]
private CppSubstitutionContext <ExpansionClosure>k__BackingField;
    public CppLocationAnchor LocationAnchor { get; }
    public CppSubstitutionContext ExpansionClosure { get; }
    public CppCtorInitializerStatementResolveEntityWithSubstitution(ICppScopeResolveEntity parent, CppCtorInitializerStatementResolveEntityBase inner, CppSubstitutionDriver driver, bool isPackExpansion, CppSubstitutionContext expansionClosure);
    public virtual CppLocationAnchor get_LocationAnchor();
    [CompilerGeneratedAttribute]
public virtual CppSubstitutionContext get_ExpansionClosure();
    public virtual ICppResolveEntity GetResolvedTarget();
    public virtual ICppResolvedExpression[] GetResolvedArguments();
    public virtual CppViewPos GetViewPos();
    private ICppResolveEntity SubstituteTarget();
    private ICppResolvedExpression[] SubstituteArguments();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCtorInitializerStatementSymbol : CppParserSymbol {
    [CompilerGeneratedAttribute]
private ICppExpression[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private CppArgumentListKind <ArgumentListKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPackExpansion>k__BackingField;
    public ICppExpression[] Arguments { get; }
    public CppArgumentListKind ArgumentListKind { get; }
    public bool IsPackExpansion { get; }
    public CppCtorInitializerStatementSymbol(CppComplexOffset loc, CppQualifiedName name, ICppExpression[] args, CppArgumentListKind argumentListKind, bool isPackExpansion);
    [CompilerGeneratedAttribute]
public ICppExpression[] get_Arguments();
    [CompilerGeneratedAttribute]
public CppArgumentListKind get_ArgumentListKind();
    [CompilerGeneratedAttribute]
public bool get_IsPackExpansion();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCustomLexicalParentFunctionDeclaratorResolveEntity : CppFunctionDeclaratorResolveEntity {
    private ICppScopeResolveEntity myLexicalParentScope;
    public CppCustomLexicalParentFunctionDeclaratorResolveEntity(ICppScopeResolveEntity lexicalParentScope, ICppResolveEntityParentScope parent, CppQualifiedNamePart name, ICppDeclaratorSymbol sym, CppLocationAnchor anchor, CppQualType replacedType, CppAttributeList attributes);
    public virtual ICppScopeResolveEntity LexicalParentScope();
    public sealed virtual ICppClassResolveEntity LexicalParentClass();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCustomLexicalParentTypeDeclaratorResolveEntity : CppTypeDeclaratorResolveEntity {
    private ICppScopeResolveEntity myLexicalParentScope;
    public CppCustomLexicalParentTypeDeclaratorResolveEntity(ICppScopeResolveEntity lexicalParentScope, ICppResolveEntityParentScope parent, CppQualifiedNamePart name, ICppDeclaratorSymbol sym, CppLocationAnchor anchor, CppQualType replacedType, CppAttributeList attributes);
    public virtual ICppScopeResolveEntity LexicalParentScope();
    public sealed virtual ICppClassResolveEntity LexicalParentClass();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCustomLexicalParentVariableDeclaratorResolveEntity : CppVariableDeclaratorResolveEntity {
    private ICppScopeResolveEntity myLexicalParentScope;
    public CppCustomLexicalParentVariableDeclaratorResolveEntity(ICppScopeResolveEntity lexicalParentScope, ICppResolveEntityParentScope parent, CppQualifiedNamePart name, ICppDeclaratorSymbol sym, CppLocationAnchor anchor, CppQualType replacedType, CppAttributeList attributes);
    public virtual ICppScopeResolveEntity LexicalParentScope();
    public sealed virtual ICppClassResolveEntity LexicalParentClass();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCxxCliClrPropertyResolveEntity : CppCxxCliPropertyResolveEntityBase {
    private ITypeMember myTypeMember;
    [CompilerGeneratedAttribute]
private CppDeclarationSpecifiers <DeclarationSpecifiers>k__BackingField;
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public bool IsEvent { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public IClrDeclaredElement ClrDeclaredElement { get; }
    public CppCxxCliClrPropertyResolveEntity(ICppResolveEntityParentScope parent, IProperty prop, CppClrTypeConverter& cvt);
    public CppCxxCliClrPropertyResolveEntity(ICppResolveEntityParentScope parent, IEvent event, CppClrTypeConverter& cvt);
    [CompilerGeneratedAttribute]
public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppAccessibility GetAccessibility();
    public virtual bool get_IsEvent();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual IClrDeclaredElement get_ClrDeclaredElement();
    public ITypeMember GetTypeMember();
    private void MergeAccessor(IAccessor accessor, CppClrTypeConverter& cvt);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCxxCliDelegateConstructorResolveEntity : object {
    private ICppClassResolveEntity myParent;
    private CppQualifiedNamePart myName;
    [CompilerGeneratedAttribute]
private CtorType <ConstructorType>k__BackingField;
    public CtorType ConstructorType { get; }
    public CppFunctionTraits Traits { get; }
    public ICppFunctionBodyResolveEntity Body { get; }
    public int BodyChameleonVersion { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppQualifiedNamePart Name { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public CppCxxCliDelegateConstructorResolveEntity(ICppClassResolveEntity parent, CppQualifiedNamePart name, CtorType ctorType);
    [CompilerGeneratedAttribute]
public CtorType get_ConstructorType();
    public virtual IEnumerable`1<ICppResolveEntity> GetResolvedCxxCliOverrideSpecifierTargets();
    public virtual ICppResolvedExpression GetResolvedRequiresClause();
    public virtual CppFunctionTraits get_Traits();
    public virtual ICppFunctionBodyResolveEntity get_Body();
    public virtual int get_BodyChameleonVersion();
    public virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public virtual ICppParameterListResolveEntity GetMainParameterList();
    public virtual int GetFirstDefaultArgIndex();
    public virtual ICppResolveEntityParent get_RealParent();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual CppQualifiedNamePart get_Name();
    public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public virtual CppAttributeList get_Attributes();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCxxCliDelegateSymbol : CppScopeSymbol {
    private CppSymbolTemplateParametersList myParamList;
    private CppAccessibility myAccessibility;
    private CppPureVirtualSpecifiers myFlags;
    [CompilerGeneratedAttribute]
private CppQualType <RawType>k__BackingField;
    [CompilerGeneratedAttribute]
private CppDeclarationSpecifiers <DeclarationSpecifiers>k__BackingField;
    public bool IsExplicitInstantiation { get; }
    public CppQualType RawType { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; public set; }
    public CppClassTag Tag { get; }
    public CppClassKey Key { get; }
    public CppClassVirtualSpecifiers ClassVirtualSpecifiers { get; }
    public CppCxxCliDelegateSymbol(CppQualifiedName name, CppSymbolTemplateParametersList paramList, CppSymbolLocation loc, CppDeclarationSpecifiers specifiers, CppAccessibility accessibility, CppQualType type);
    public CppCxxCliDelegateSymbol(CppQualifiedName name, CppSymbolTemplateParametersList paramList, CppSymbolLocation loc, CppDeclarationSpecifiers specifiers, CppAccessibility accessibility, CppQualType type, CppPureVirtualSpecifiers flags);
    public sealed virtual bool get_IsExplicitInstantiation();
    [CompilerGeneratedAttribute]
public sealed virtual CppQualType get_RawType();
    public sealed virtual CppSymbolTemplateParametersList ParamList();
    public sealed virtual CppAttributeList Attributes();
    public CppSmallList`1<CppQualifiedName> CxxCliOverrideSpecifiers();
    [CompilerGeneratedAttribute]
public sealed virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public sealed virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public void set_PureVirtualSpecifiers(CppPureVirtualSpecifiers value);
    public sealed virtual CppDeclarationTrailingKind GetDeclarationTrailingKind();
    public sealed virtual bool IsParameterPack();
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual CppCompoundStatementSymbol GetFunctionBody();
    public sealed virtual bool IsFunction();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual ICppExpression GetRequiresClause();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public sealed virtual bool IsAnonymousClass();
    public sealed virtual CppClassTag get_Tag();
    public sealed virtual CppClassKey get_Key();
    public sealed virtual CppClassVirtualSpecifiers get_ClassVirtualSpecifiers();
    public sealed virtual bool Exported();
    public void SetAccessibility(CppAccessibility val);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCxxCliPropertyBuilder : object {
    private ICppBuilder myParent;
    private ICppScopeResolveEntity myResolveEntity;
    private CppCxxCliPropertySymbol mySymbol;
    private CppAccessibility myAccessibility;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public CppCxxCliPropertyBuilder(ICppBuilder parent, ICppScopeResolveEntity resolveEntity, CppCxxCliPropertySymbol symbol);
    public sealed virtual void AddChild(CppParserSymbol sym);
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    public sealed virtual void LearnAccessibility(CppAccessibility accessibility);
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual ICppParserSymbol GetClassParentSymbol();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCxxCliPropertyDeclaratorResolveEntityWithSubstitution : CppDeclaratorResolveEntityWithSubstitutionBase`1<ICppCxxCliPropertyDeclaratorResolveEntity> {
    private CppCachedReference`1<CppQualType[]> myCachedResolvedIndexTypes;
    private Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>> myChildren;
    private bool myInSubstituteChildren;
    private CppDependentInfoCachedValue myCachedDepInfo;
    public bool IsParameterPack { get; }
    public bool IsEvent { get; }
    public CppCxxCliPropertyDeclaratorResolveEntityWithSubstitution(ICppResolveEntity structuralParent, CppViewPos& vp, CppQualifiedNamePart name, ICppCxxCliPropertyDeclaratorResolveEntity inner, ICppSubstitutionContext subst);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual bool HasInitializer();
    public sealed virtual ICppEvaluationResult GetValue(CppEvaluationParams p, ICppEvaluationErrorTracker errorTracker);
    public sealed virtual bool get_IsParameterPack();
    public sealed virtual ICppVariableTemplateDeclaratorResolveEntity GetTemplateDeclaration();
    public sealed virtual bool Contains(ICppDeclaratorResolveEntity decl);
    public sealed virtual CppSmallList`1<ICppVariableDeclaratorResolveEntity> GetUngroupedDeclarators();
    public sealed virtual ICppVariableDeclaratorResolveEntity GetAnyUngrouped();
    public sealed virtual CppQualType[] GetResolvedIndexTypes();
    public sealed virtual bool get_IsEvent();
    public sealed virtual void AddChild(ICppResolveEntity ent);
    public sealed virtual void RemoveChild(ICppResolveEntity e);
    public sealed virtual CppSmallList`1<ICppResolveEntity> ChildByName(CppQualifiedNamePart name, CppLocationAnchor anchor);
    public sealed virtual CppList`1<ICppResolveEntity> GetChildren();
    public sealed virtual void AddAnonymousClass(ICppClassResolveEntity ent);
    public sealed virtual CppList`1<ICppClassResolveEntity> AnonymousClasses();
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    private CppQualType[] ResolveIndexTypes();
    private void SubstituteChildren();
    private void Journaling_RollbackSubstituteChildren();
    private void Journaling_RollbackAddChild(ICppResolveEntity ent);
    public sealed virtual CppDependentInfo GetDependentInfo();
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCxxCliPropertyIndexesBuilder : CppForwardingBuilder {
    private CppCxxCliPropertyResolveEntity myResolveEntity;
    private CppCxxCliPropertySymbol mySymbol;
    private CppList`1<CppQualType> myUnresolvedTypes;
    private CppList`1<CppQualType> myReplacedTypes;
    public CppCxxCliPropertyIndexesBuilder(ICppBuilder parent, CppCxxCliPropertyResolveEntity resolveEntity, CppCxxCliPropertySymbol symbol);
    public void LearnTypeId(ICppDeclarationBuilder decl);
    public void Apply();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCxxCliPropertyResolveEntity : CppCxxCliPropertyResolveEntityBase {
    private CppCxxCliPropertySymbol mySymbol;
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public bool IsEvent { get; }
    public CppCxxCliPropertyResolveEntity(ICppResolveEntityParentScope parent, CppQualifiedNamePart name, CppCxxCliPropertySymbol sym, CppLocationAnchor anchor, CppQualType replacedType);
    public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppAccessibility GetAccessibility();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual bool get_IsEvent();
    public ICppDeclaratorSymbol GetDeclaratorSymbol();
    public void GenerateImplicitAccessors();
    private void GenerateAccessor(CppQualifiedId name, CppQualType signature);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCxxCliPropertyResolveEntityBase : CppScopeResolveEntityBase {
    private ICppResolveEntityParentScope myStructuralParent;
    private CppQualType myUnresolvedType;
    private CppDependentInfoCachedValue myCachedDepInfo;
    private CppQualType[] myReplacedIndexTypes;
    private CppCachedReference`1<CppQualType[]> myCachedResolvedIndexTypes;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    public bool IsFriend { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public bool IsParameterPack { get; }
    public bool IsEvent { get; }
    public CppQualifiedNamePart Name { get; }
    protected CppCxxCliPropertyResolveEntityBase(ICppResolveEntityParentScope parent, CppQualifiedNamePart name, CppLocationAnchor anchor, CppQualType replacedType);
    public bool get_IsFriend();
    public virtual ICppResolveEntityParent get_RealParent();
    public virtual ICppResolveEntity get_StructuralParent();
    public abstract virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public virtual CppAttributeList get_Attributes();
    public virtual bool get_IsParameterPack();
    public abstract virtual bool get_IsEvent();
    [CompilerGeneratedAttribute]
public virtual CppQualifiedNamePart get_Name();
    public virtual ICppVariableTemplateDeclaratorResolveEntity GetTemplateDeclaration();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public sealed virtual bool HasInitializer();
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    public virtual ICppEvaluationResult GetValue(CppEvaluationParams evalParams, ICppEvaluationErrorTracker errorTracker);
    public virtual CppDependentInfo GetDependentInfo();
    public abstract virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public virtual FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual bool Contains(ICppDeclaratorResolveEntity decl);
    public virtual CppSmallList`1<ICppVariableDeclaratorResolveEntity> GetUngroupedDeclarators();
    public virtual ICppVariableDeclaratorResolveEntity GetAnyUngrouped();
    public virtual CppQualType[] GetResolvedIndexTypes();
    public virtual CppQualType ResolveType(ICppResolvedTypeFactory f);
    public void Dump(CppIndentationStringBuilder tw);
    public void SetStructuralParent(ICppResolveEntityParentScope structuralParent);
    public void SetIndexTypes(CppQualType[] indexTypes);
    public virtual ICppScopeResolveEntity LexicalParentScope();
    public virtual string ToString();
    public CppQualType[] GetReplacedIndexTypes();
    private CppQualType GetNonNormalizedType(ICppResolvedTypeFactory typeIntern);
    private CppQualType[] ResolveIndexTypes();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCxxCliPropertySetResolveEntity : object {
    private List`1<ICppCxxCliPropertyDeclaratorResolveEntity> myItems;
    public IEnumerable`1<ICppCxxCliPropertyDeclaratorResolveEntity> Items { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppCxxCliPropertySetResolveEntity(List`1<ICppCxxCliPropertyDeclaratorResolveEntity> items);
    public sealed virtual IEnumerable`1<ICppCxxCliPropertyDeclaratorResolveEntity> get_Items();
    public sealed virtual ICppScopeResolveEntity GetParentScope();
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    private static void AddChildEntities(FrugalLocalList`1& res, ICppScopeResolveEntity ce, CppViewPos& viewPos, CppQualifiedNamePart innerName, CppLookupFilter filter);
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppCxxCliPropertySymbol : CppScopeSymbol {
    private static byte EventBit;
    private byte myAccessibility;
    private CppPureVirtualSpecifiers myFlags;
    [CompilerGeneratedAttribute]
private CppQualType[] <IndexTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private CppDeclarationSpecifiers <DeclarationSpecifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private CppQualType <RawType>k__BackingField;
    public CppQualType[] IndexTypes { get; public set; }
    public bool IsEvent { get; public set; }
    public bool IsExplicitInstantiation { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; public set; }
    public CppQualType RawType { get; }
    public CppCxxCliPropertySymbol(CppQualifiedName name, CppSymbolLocation loc, CppDeclarationSpecifiers specifiers, CppAccessibility accessibility, CppQualType type);
    public CppCxxCliPropertySymbol(CppQualifiedName name, CppSymbolLocation loc, CppDeclarationSpecifiers specifiers, byte accessibility, CppQualType type, CppPureVirtualSpecifiers flags, CppQualType[] indexTypes);
    [CompilerGeneratedAttribute]
public CppQualType[] get_IndexTypes();
    [CompilerGeneratedAttribute]
public void set_IndexTypes(CppQualType[] value);
    public bool get_IsEvent();
    public void set_IsEvent(bool value);
    public sealed virtual bool get_IsExplicitInstantiation();
    public sealed virtual CppSymbolTemplateParametersList ParamList();
    public sealed virtual CppAttributeList Attributes();
    public CppSmallList`1<CppQualifiedName> CxxCliOverrideSpecifiers();
    public sealed virtual ICppExpression GetRequiresClause();
    [CompilerGeneratedAttribute]
public sealed virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public sealed virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public void set_PureVirtualSpecifiers(CppPureVirtualSpecifiers value);
    [CompilerGeneratedAttribute]
public sealed virtual CppQualType get_RawType();
    public sealed virtual CppDeclarationTrailingKind GetDeclarationTrailingKind();
    public sealed virtual bool IsParameterPack();
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual CppCompoundStatementSymbol GetFunctionBody();
    public sealed virtual bool IsFunction();
    public sealed virtual CppAccessibility GetAccessibility();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public byte GetAccessibilityFlag();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDataMemberInit : CppMemInitEntity {
    [CompilerGeneratedAttribute]
private ICppResolveEntity <Member>k__BackingField;
    public ICppResolveEntity Member { get; }
    public CppDataMemberInit(ICppResolveEntity ent);
    [CompilerGeneratedAttribute]
public ICppResolveEntity get_Member();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDecayBuiltinTypedefModuleEntity : object {
    public ICppClassOrRefClassModuleEntity Parent;
    public CppDecayBuiltinTypedefModuleEntity(ICppClassOrRefClassModuleEntity parent);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public sealed virtual CppImportResult`1<ICppGroupedTypeDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDecayClassInstantiation : object {
    private static CppQualifiedId TypedefStdName;
    private static CppQualifiedId TypedefUE4Name;
    private CppDecayClassPack myPack;
    private CppSubstitutionId myName;
    private CppDeclaratorResolveEntityPack myTypedef;
    private ICppDeclaratorResolveEntityPack myConstructors;
    private ICppDeclaratorResolveEntityPack myAssignmentOperators;
    [CompilerGeneratedAttribute]
private CppDependentInfo <DependentInfo>k__BackingField;
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public ICppResolveEntityParent RealParent { get; }
    public CppDependentInfo DependentInfo { get; }
    public CppDecayClassInstantiation(CppDecayClassPack pack, CppSubstitutionId name, Kind kind, CppQualType type, CppDependentInfo dependentInfo);
    private static CppDecayClassInstantiation();
    public virtual bool HasDefinition();
    public sealed virtual bool Exported();
    public virtual bool IsEndLocationAnchorSet();
    public virtual CppLocationAnchor GetEndLocationAnchor();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual bool ContainsSymbol(ICppClassOrDelegateSymbolOrModuleEntity _);
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual TResult Accept(ICppResolveEntityVisitor`1<TResult> visitor);
    public virtual ICppResolveEntityParent get_RealParent();
    public virtual void AddChild(ICppResolveEntity ent);
    public virtual void RemoveChild(ICppResolveEntity ent);
    public virtual CppSmallList`1<ICppResolveEntity> ChildByName(CppQualifiedNamePart name, CppLocationAnchor anchor);
    public virtual CppList`1<ICppResolveEntity> GetChildren();
    public virtual void AddAnonymousClass(ICppClassResolveEntity ent);
    public virtual CppList`1<ICppClassResolveEntity> AnonymousClasses();
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver driver);
    [CompilerGeneratedAttribute]
public virtual CppDependentInfo get_DependentInfo();
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public virtual bool IsTemplateInstantiation();
    public virtual ICppTemplateResolveEntity GetTemplate();
    public virtual ICppTemplateArgument[] GetArguments();
    public virtual CppBasicBaseDescription`1[] GetBases();
    public virtual ICppDefinitionClassSymbol GetDefinitionSymbol();
    public virtual CppClassKey GetKey();
    public virtual CppClassTag GetTag();
    public virtual CppClassVirtualSpecifiers GetClassVirtualSpecifiers();
    public virtual bool HasAbstractSpecifier();
    public virtual bool IsFinal();
    public virtual bool IsSealed();
    public virtual bool IsFinalOrSealed();
    public virtual bool IsAnonymousClass();
    public virtual bool IsAbstract();
    public virtual bool IsPolymorphic();
    public virtual bool HasVirtualDestructor();
    public virtual bool IsTriviallyCopyable(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool HasTrivialConstructor();
    public virtual bool HasTrivialDestructor(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool HasNothrowDestructor(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool IsTrivial(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool IsStandardLayout(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool IsPOD(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public bool HasUniqueObjectRepresentations(CppViewPos& vp);
    public virtual CppQualType GetEnumUnderlyingType();
    public virtual CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> GetNonDependentBases();
    public virtual ICppDeclaratorResolveEntityPack GetConversions();
    public virtual ICppDeclaratorResolveEntityPack GetStaticConstructors();
    public virtual ICppDeclaratorResolveEntityPack GetDestructors();
    public virtual ICppDeclaratorResolveEntityPack GetCliFinalizers();
    public virtual ICppDeclaratorResolveEntityPack GetConstructors();
    public virtual IEnumerable`1<ICppResolveEntity> GetClassConstructors();
    public virtual IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity> GetClassConversions(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual ICppTemplateArgument[] GetDefaultTemplateArguments(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual CppSmallList`1<ICppFunctionDeclaratorResolveEntity> GetFriendFunctions(CppQualifiedNamePart name);
    public virtual CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity> GetFriendClasses(CppQualifiedNamePart name);
    public virtual ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppFunctionDeclaratorResolveEntity>> GetFriendFunctions();
    public virtual ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity>> GetFriendClasses();
    public virtual CppSmallList`1<ICppDependentTypeResolveEntity> GetFriendDependentTypes();
    public virtual CppViewPos GetScopeForBaseClasses(ICppClassSymbol sym);
    public virtual CppLocationAnchor GetAnchorBySymbol(ICppClassOrDelegateSymbol sym);
    public virtual CppLocationAnchor GetDefinitionLocationAnchor();
    public virtual ICppGroupedTypeDeclaratorResolveEntity GetAssociatedTypedefForClass(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual CppSmallList`1<ICppDeclaratorResolveEntityPack> GetAnonymousSubclassMembers(CppQualifiedNamePart name);
    public virtual CppAttributeList GetAttributes();
    public virtual CppList`1<ICppResolveEntity> GetAggregateMembers();
    public virtual List`1<ICppResolveEntity> GetAllMembersSorted();
    public virtual bool HasImmediateVirtualFunctions();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasFixedEnumUnderlyingType();
    public virtual bool HasInheritingConstructors();
    public virtual FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public CppSubstitutionId GetSubstitutionId();
    private ICppDeclaratorResolveEntityPack GetAssignmentOperators();
    internal CppDeclaratorResolveEntityPack GetTypedefEntity();
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.HasUniqueObjectRepresentations(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDecayClassPack : CppClassTemplateResolveEntityPack {
    public Kind kind;
    public CppDecayClassPack(ICppResolveEntityParentScope parent, CppQualifiedNamePart name, Kind kind);
    public virtual ICppClassOrUndeterminedSpecializationResolveEntity Instantiate(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, ICppTemplateArgument[] args);
    private static CppQualType GetDecayedType(CppQualType _Ty, ICppResolvedTypeFactory tf);
    public static Kind IsDecayClassPack(ICppResolveEntityParentScope parent, CppQualifiedNamePart name);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaration0Builder : CppForwardingBuilder {
    protected CppTemplateDeclarationBuilder myTemplDeclBuilder;
    protected ICppDeclaratorBuilder myLastDeclaratorBuilder;
    protected CppDeclarationSymbol myDeclSymbol;
    protected CppUnresolvedDeclarationSpecifierTypeBuilder myUnresolvedSpecifierTypeBuilder;
    protected CppResolvedDeclarationSpecifierTypeBuilder myReplacedSpecifierTypeBuilder;
    protected CppDeclarationSpecifiers myDeclSpecifiers;
    protected ICppAttributeListBuilder myAttributesBuilder;
    protected CppCallingConvention myCallingConvention;
    protected CppClassBuilder myClassBuilder;
    protected bool myCanDropDeclarationSymbol;
    protected bool myIsDeclarationDroppable;
    protected CppBuilderPool myPool;
    protected bool myHasImplicitIntType;
    protected CppLocationAnchor myRollbackPointStartAnchor;
    protected bool myPreprocessorDetectionEnabled;
    public CppDeclarationSpecifiers Specifiers { get; }
    public ICppDeclaratorBuilder LastDeclaratorBuilder { get; }
    public CppClassBuilder ClassBuilder { get; }
    public ICppAttributeListBuilder AttributeListBuilder { get; }
    public CppCallingConvention CallingConvention { get; }
    protected CppDeclaration0Builder(ICppBuilder parent, CppTemplateDeclarationBuilder templDeclBuilder, CppSymbolLocation loc);
    protected CppDeclaration0Builder(ICppBuilder parent, CppSymbolLocation loc, CppBuilderPool pool);
    public void Init(ICppBuilder parent, CppSymbolLocation loc);
    public void Clear();
    public CppDeclarationSymbol GetDeclarationSymbol();
    public virtual void AddChild(CppParserSymbol sym);
    public sealed virtual CppTemplateDeclarationBuilder TemplateDeclarationBuilder();
    public CppDeclarationSpecifiers get_Specifiers();
    public sealed virtual ICppDeclaratorBuilder get_LastDeclaratorBuilder();
    public sealed virtual void LearnSpecifier(TokenNodeType token);
    public sealed virtual void LearnDeclspecProperty();
    public sealed virtual void LearnDecltypeAuto();
    public sealed virtual void ApplyImplicitIntType();
    public sealed virtual bool IsStandalone();
    public sealed virtual bool HasImplicitIntType();
    public sealed virtual CppDeclarationSpecifiers GetSpecifiers();
    public sealed virtual void LearnAttributes(ICppAttributeListBuilder attributesBuilder);
    public sealed virtual void LearnClassSpecifier(CppClassBuilder classBuilder);
    public sealed virtual void LearnCallingConvention(ICppCallingConventionBuilder ccBuilder);
    public void LearnCanNotDropDeclarationSymbol();
    public sealed virtual ICppDeclaratorBuilder NewDeclaratorBuilder();
    private void SetLastDeclaratorBuilder(ICppDeclaratorBuilder builder);
    protected abstract virtual ICppDeclaratorBuilder NewDeclaratorBuilderImpl();
    public abstract virtual ICppConceptDefinitionBuilder NewConceptDefinitionBuilder();
    public sealed virtual bool NeedTypename();
    public sealed virtual ICppUnresolvedDeclarationSpecifierTypeBuilder GetUnresolvedSpecifierTypeBuilder();
    public sealed virtual ICppResolvedDeclarationSpecifierTypeBuilder GetReplacedSpecifierTypeBuilder();
    public sealed virtual ICppAttributeListBuilder CreateAttributesBuilder();
    public sealed virtual ICppCallingConventionBuilder CreateCallingConventionBuilder();
    public sealed virtual ICppStructuredBindingDeclarationBuilder CreateStructuredBindingBuilder();
    public sealed virtual CppClassBuilder get_ClassBuilder();
    public sealed virtual ICppAttributeListBuilder get_AttributeListBuilder();
    public CppCallingConvention get_CallingConvention();
    public sealed virtual void FinishDeclaration();
    public bool IsDeclarationDroppable();
    public sealed virtual void LearnTrailingReturnType();
    public sealed virtual void LearnDeclarator(CppDeclaratorSymbol declSym);
    public sealed virtual void LearnClassSymbol(ICppClassSymbol sym);
    public sealed virtual void IncrementAnchor(int diff);
    public sealed virtual void LearnExplicitSpecifier();
    public sealed virtual void LearnExplicitSpecifier(CppTwinExpressionBuilder& exprBuilder);
    public sealed virtual void LearnExport();
    public void StartAbortableMode();
    public void DisableRollback();
    public bool IsDeclarationAbortable();
    public bool DisablePreprocessorDetection();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclarationBuilderUtil : object {
    public static void RegisterFriendDeclaration(ICppScopeResolveEntity scope, CppQualType declSpecQualType, CppLocationAnchor anchor);
    public static void AddFriend(CppQualType qualType, ICppMutableClassResolveEntity embracingClass);
    public static void DeclareDelegateMembers(CppQualType replacedDelegateType, ICppClassResolveEntity resolveEnt, CppCxxCliDelegateSymbol sym, ICppFileResolveEntitiesCache resolveCache);
    [ExtensionAttribute]
public static CppQualType GetDeclarationType(ICppDeclarationBuilder declBuilder);
    [ExtensionAttribute]
public static CppQualType GetReplacedDeclarationType(ICppDeclarationBuilder declBuilder);
    [ExtensionAttribute]
public static void DoFinishDeclaration(ICppDeclarationBuilder builder, CppClassBuilder classBuilder);
    [ExtensionAttribute]
public static bool IsAbortable(ICppDeclarationBuilder declarationBuilder);
    private static bool ShouldBeAnonymous(ICppMutableClassResolveEntity cent);
    [ExtensionAttribute]
public static void LearnTokenType(ICppDeclarationBuilder declBuilder, TokenNodeType tt);
    [ExtensionAttribute]
public static bool IsExport(ICppDeclarationBuilder builder);
    [ExtensionAttribute]
public static bool HasExternalLinkage(ICppDeclarationBuilder builder);
    private static bool HasLinkageSpecificationParent(ICppBuilder builder);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclarationDetectionBuilder : CppBuilderWithParent {
    private ICppScopeResolveEntity myScope;
    private List`1<CppTemplateParametersBase> myEntParams;
    private Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> myMapping;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public CppDeclarationDetectionBuilder(ICppBuilder parent, ICppScopeResolveEntity scope, List`1<CppTemplateParametersBase> entParams, Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> fp);
    public virtual ICppScopeResolveEntity get_ResolveEntity();
    public virtual void AddChild(CppParserSymbol s);
    public List`1<CppTemplateParametersBase> GetEntParams();
    public Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> GetMapping();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclarationSpecifiers : Enum {
    public ushort value__;
    public static CppDeclarationSpecifiers None;
    public static CppDeclarationSpecifiers Typedef;
    public static CppDeclarationSpecifiers Static;
    public static CppDeclarationSpecifiers Mutable;
    public static CppDeclarationSpecifiers Virtual;
    public static CppDeclarationSpecifiers ConstEval;
    public static CppDeclarationSpecifiers Friend;
    public static CppDeclarationSpecifiers Auto;
    public static CppDeclarationSpecifiers Extern;
    public static CppDeclarationSpecifiers Inline;
    public static CppDeclarationSpecifiers Property;
    public static CppDeclarationSpecifiers Register;
    public static CppDeclarationSpecifiers ConstExpr;
    public static CppDeclarationSpecifiers ThreadLocal;
    public static CppDeclarationSpecifiers Export;
    public static CppDeclarationSpecifiers Event;
    public static CppDeclarationSpecifiers Literal;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclarationSpecifiersUtil : object {
    public static void AddSpecifier(CppDeclarationSpecifiers& target, TokenNodeType tt);
    [ExtensionAttribute]
public static string SpecsToString(CppDeclarationSpecifiers specs);
    [ExtensionAttribute]
public static void SpecsToString(CppDeclarationSpecifiers specs, StringBuilder sb);
    [ExtensionAttribute]
public static IEnumerable`1<ITreeNode> CreatePsiNodesForDeclarationSpecifiers(CppDeclarationSpecifiers specs);
    [ExtensionAttribute]
public static string DebugSpecsToString(CppDeclarationSpecifiers specs);
    [ExtensionAttribute]
public static bool IsTypedef(CppDeclarationSpecifiers spec);
    [ExtensionAttribute]
public static bool IsStatic(CppDeclarationSpecifiers spec);
    [ExtensionAttribute]
public static bool IsThreadLocal(CppDeclarationSpecifiers spec);
    [ExtensionAttribute]
public static bool IsMutable(CppDeclarationSpecifiers spec);
    [ExtensionAttribute]
public static bool IsVirtual(CppDeclarationSpecifiers spec);
    [ExtensionAttribute]
public static bool IsFriend(CppDeclarationSpecifiers spec);
    [ExtensionAttribute]
public static bool IsAuto(CppDeclarationSpecifiers spec);
    [ExtensionAttribute]
public static bool IsExport(CppDeclarationSpecifiers spec);
    [ExtensionAttribute]
public static bool IsExtern(CppDeclarationSpecifiers spec);
    [ExtensionAttribute]
public static bool IsInline(CppDeclarationSpecifiers spec);
    [ExtensionAttribute]
public static bool IsProperty(CppDeclarationSpecifiers spec);
    [ExtensionAttribute]
public static bool IsRegister(CppDeclarationSpecifiers spec);
    [ExtensionAttribute]
public static bool IsConstExpr(CppDeclarationSpecifiers spec);
    [ExtensionAttribute]
public static bool IsConstEval(CppDeclarationSpecifiers spec);
    [ExtensionAttribute]
public static bool IsConstExprOrConstEval(CppDeclarationSpecifiers spec);
    [ExtensionAttribute]
public static bool IsEvent(CppDeclarationSpecifiers spec);
    [ExtensionAttribute]
public static bool IsLiteral(CppDeclarationSpecifiers spec);
    [ExtensionAttribute]
public static bool IsStaticOrLiteral(CppDeclarationSpecifiers spec);
    [ExtensionAttribute]
public static bool IsStaticOrThreadLocal(CppDeclarationSpecifiers spec);
    [CompilerGeneratedAttribute]
internal static void <SpecsToString>g__Append|2_0(string keyword, <>c__DisplayClass2_0& );
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclarationSymbol : CppScopeSymbol {
    private CppDeclarationSpecifiers myDeclSpecs;
    private CppQualType myDeclSpecType;
    public CppDeclarationSymbol(CppSymbolLocation loc);
    public bool IsDroppable();
    public void DropDeclaration();
    public void SetDeclSpecType(CppQualType qualType);
    public CppQualType GetDeclSpecType();
    public void SetDeclSpecs(CppDeclarationSpecifiers declSpecs);
    public CppDeclarationSpecifiers GetDeclSpecs();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclarationTrailingKind : Enum {
    public int value__;
    public static CppDeclarationTrailingKind NONE;
    public static CppDeclarationTrailingKind DEFAULT;
    public static CppDeclarationTrailingKind DELETE;
    public static CppDeclarationTrailingKind FUNCTION_BODY;
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclarationTrailingKindUtil : object {
    public static bool IsSomeTrailingBody(CppDeclarationTrailingKind kind);
    public static bool IsDeleted(CppDeclarationTrailingKind kind);
    public static bool IsDefaulted(CppDeclarationTrailingKind kind);
    public static bool IsExecutableBody(CppDeclarationTrailingKind kind);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclarator0Builder`2 : object {
    protected CppDeclaration0Builder myParent;
    protected TSymbol myScopeSym;
    protected TResolveEntity myResolveEnt;
    protected CppUnresolvedTypeBuilder myUnresolvedTypeBuilder;
    protected CppResolvedTypeBuilder myReplacedTypeBuilder;
    protected CppSymbolLocation myLocation;
    protected CppQualifiedName myUnresolvedName;
    protected CppQualifiedName myReplacedName;
    protected ICppFunctionParameterListBuilder myMainParametersBuilder;
    protected CppAttributeList myUnresolvedAttributes;
    protected CppAttributeList myReplacedAttributes;
    protected CppDeclaratorCreationData myCreationData;
    protected CppPureVirtualSpecifiers myPureVirtualSpecifiers;
    protected CppSmallList`1<CppQualifiedName> myUnresolvedCxxCliOverrideSpecifiers;
    protected CppSmallList`1<CppQualifiedName> myReplacedCxxCliOverrideSpecifiers;
    protected ICppExpression myUnresolvedRequiresClause;
    protected ICppExpression myReplacedRequiresClause;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public ICppDeclaratorSymbol Symbol { get; }
    public bool HasSymbol { get; }
    public bool IsParameterPackDeclarator { get; }
    protected CppDeclarator0Builder`2(CppDeclaration0Builder parent);
    protected void Init(CppDeclaration0Builder parent);
    protected void Clear();
    internal static void InitAttributes(CppAttributeList& unresolvedAttributes, CppAttributeList& replacedAttributes, ICppDeclarationBuilder parent);
    public virtual void SetUsedInDeferredParsing();
    public ICppParameterListBuilder GetFunctionParametersBuilder();
    public sealed virtual ICppDeclaratorBuilder GetDeclaratorBuilder();
    public sealed virtual ICppDeclarationBuilder GetDeclarationBuilder();
    public abstract virtual ICppBuilder CreateInitDeclaratorBuilder();
    public sealed virtual ICppAttributeListBuilder CreateAttributesBuilder();
    public sealed virtual ICppCallingConventionBuilder CreateCallingConventionBuilder();
    public sealed virtual ICppUnresolvedTypeBuilder GetUnresolvedTypeBuilder();
    public sealed virtual ICppResolvedTypeBuilder GetReplacedTypeBuilder();
    public abstract virtual void ComposeSymbolType(CppSymbolLocation _);
    public sealed virtual void LearnLocation(CppSymbolLocation location);
    public void LearnQualifiedName(CppTwinQualifiedNameBuilder& twinBuilder);
    public sealed virtual void LearnQualifiedName(ICppStructuredBindingDeclarationBuilder structuredBindingBuilder);
    public abstract virtual void LearnInitializer(KIND kind, CppSmallArray`1<ICppExpression> unresolvedArguments, CppSmallArray`1<ICppExpression> replacedArguments);
    public sealed virtual void LearnMainParameterList(ICppFunctionParameterListBuilder plistBuilder);
    public abstract virtual void LearnFunctionBody(CppDeclarationTrailingKind trailingKind);
    public sealed virtual void LearnPureVirtualSpecifier(CppPureVirtualSpecifiers specs);
    public sealed virtual ICppFunctionParameterListBuilder CreateParameterListBuilder();
    public sealed virtual ICppFunctionParameterListBuilder GetMainParameterListBuilder();
    public sealed virtual void LearnEllipsis();
    public sealed virtual void LearnAttributes(ICppAttributeListBuilder attrsBuilder);
    public sealed virtual void LearnNoAttributes();
    public sealed virtual void LearnBitfieldSize(ICppExpression unresolvedSize, ICppExpression replacedSize);
    public void LearnCxxCliOverrideSpecifier(CppTwinQualifiedNameBuilder& twinBuilder);
    public sealed virtual void LearnRequiresClause(ICppExpression unresolved, ICppExpression replaced);
    public sealed virtual void LearnAutoParameter(ICppTypeTemplateParameterOrPack param);
    [CanBeNullAttribute]
public sealed virtual CppTemplateParametersBase GetTemplateParameters();
    public sealed virtual void AddChild(CppParserSymbol sym);
    public TResolveEntity GetDeclaratorResolveEntity();
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    public sealed virtual ICppDeclaratorSymbol get_Symbol();
    public sealed virtual bool get_HasSymbol();
    public sealed virtual bool get_IsParameterPackDeclarator();
    public abstract virtual void LearnFunctionBody(CppFunctionBodyBuilder _);
    public sealed virtual bool ShouldParseFunctionBody();
    public abstract virtual void LearnClosedBodyChameleon();
    public abstract virtual void LearnCtorBlockWithoutBody();
    protected bool IsExplicitInstantiation();
    protected static bool ShouldParseFunctionBody(CppQualifiedName name, CppDeclarationSpecifiers specifiers, CppQualType symbolType);
    private sealed virtual override void JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorBuilder.LearnQualifiedName(CppTwinQualifiedNameBuilder& modreq(System.Runtime.InteropServices.InAttribute) _);
    private sealed virtual override void JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorBuilder.LearnCxxCliOverrideSpecifier(CppTwinQualifiedNameBuilder& modreq(System.Runtime.InteropServices.InAttribute) _);
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorBuilderUtil : object {
    public static bool IsBuildingMainParameterList(ICppInnerDeclaratorBuilder declaratorBuilder);
    public static void LearnMainParameterList(ICppInnerDeclaratorBuilder declaratorBuilder, ICppFunctionParameterListBuilder plistBuilder);
    public static void LearnParametersAndTrailingReturnType(ICppInnerDeclaratorBuilder declaratorBuilder, ICppFunctionParameterListBuilder plistBuilder);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorCreationData : ValueType {
    public NameAndStructuralParent myNameAndStructuralParent;
    public ICppScopeResolveEntity myLexicalParent;
    public ICppFileResolveEntitiesCache myResolveEntitiesCache;
    public bool myFriendInTemplate;
    public CppDeclaratorCreationData(NameAndStructuralParent nameAndStructuralParent, ICppScopeResolveEntity lexicalParent, ICppFileResolveEntitiesCache resolveEntitiesCache, bool friendInTemplate);
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorCreationUtil : object {
    public static CppDeclaratorCreationData PrepareDeclarator0Creation(ICppScopeResolveEntity lexicalParentScope, CppQualifiedName replacedName, CppLocationAnchor anchor, ICppFileResolveEntitiesCache resolveEntitiesCache, List`1<CppTemplateParametersBase> templParams, bool friend, bool isExplicitInstantiation);
    public static FrugalLocalList`1<CppDeclaratorResolveEntityPack> FindCandidatePacksForDeclaratorCreation(ICppScopeResolveEntity scope, CppQualifiedNamePart name, CppLocationAnchor anchor, bool isFunction, bool isStatic, bool shouldFindExisting);
    public static CppDeclaratorResolveEntityBase CreateDeclarator0(CppDeclaratorCreationData data, CppDeclaratorSymbol symbol, CppQualType replacedType, CppLocationAnchor anchor, CppAttributeList attributes, string moduleId, CppDeclaratorResolveEntityPack& containingPack);
    public static CppStructuredBindingResolveEntity CreateStructuredBindingDeclarator(ICppFileResolveEntitiesCache resolveCache, CppQualifiedNamePart entName, ICppScopeResolveEntity lexicalParent, CppStructuredBindingSymbol symbol, CppLocationAnchor anchor, CppVariableDeclaratorResolveEntity declaration, int elementIndex, int numElements);
    public static bool ShouldFindExisting(CppDeclaratorSymbol symbol);
    public static FrugalLocalList`1<CppDeclaratorResolveEntityPack> FindDeclaratorGroups(ICppScopeResolveEntity scope, CppQualifiedNamePart name, CppLocationAnchor anchor);
    public static void AddNewGroupedIntoNewOrExistingPack(ICppDeclaratorOrTemplateDeclaratorPack declarator, ICppScopeResolveEntity scope, CppQualifiedNamePart name, CppLocationAnchor anchor);
    public static CppDeclaratorResolveEntityPack FindOrCreateDeclaratorGroup(ICppScopeResolveEntity scope, CppQualifiedNamePart name, CppLocationAnchor anchor);
    private static CppDeclaratorResolveEntityPack FindDeclaratorGroup(ICppScopeResolveEntity scope, CppQualifiedNamePart name, CppLocationAnchor anchor);
    private static void WalkInlineNamespaces(CppNamespaceResolveEntity scope, CppQualifiedNamePart name, CppLocationAnchor anchor, FrugalLocalList`1& result);
    [CanBeNullAttribute]
private static CppClassTemplateResolveEntityPack FindClassTemplate(ICppScopeResolveEntity structuralParent, CppDeclaratorSymbol symbol, CppLocationAnchor anchor, CppQualifiedNamePart name);
    private static CppDeclaratorResolveEntityBase CreateDeclarator0DontNotifySymbolLocator(CppDeclaratorCreationData data, CppDeclaratorSymbol symbol, CppQualType replacedType, CppLocationAnchor anchor, CppAttributeList attributes, string moduleId, CppDeclaratorResolveEntityPack& containingPack);
    public static void Patch(CppQualType& declType, CppAttributeList attributes, ICppTypeFactory tf);
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorDependentInfoUtil : object {
    public static CppDependentInfo GetDeclaratorDependentInfoImpl(ICppExpressionTemplateParameterOrPack ent);
    public static CppDependentInfo GetDeclaratorDependentInfoImpl(ICppFunctionTemplateDeclaratorResolveEntity ent);
    public static CppDependentInfo GetDeclaratorDependentInfoImpl(ICppVariableDeclaratorResolveEntity var);
    public static CppDependentInfo GetDeclaratorDependentInfoImpl(ICppCxxCliPropertyDeclaratorResolveEntity var);
    private static bool DependsOnNonOwnTemplateParameters(ICppGroupedFunctionDeclaratorResolveEntity primaryTemplate);
    private static bool Contains(CppTemplateParametersBase params, CppTemplateParameterTag tag);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorInitializer : ValueType {
    public static CppDeclaratorInitializer Invalid;
    public KIND Kind;
    public CppSmallArray`1<ICppExpression> Arguments;
    public CppDeclaratorInitializer(KIND kind, CppSmallArray`1<ICppExpression> arguments);
    private static CppDeclaratorInitializer();
    public static CppDeclaratorInitializer Create(KIND kind, ICppExpression argument);
    public static CppDeclaratorInitializer CreateEq(ICppExpression argument);
    [IsReadOnlyAttribute]
public bool IsValid();
    [CanBeNullAttribute]
public ICppExpression GetCopyInitArgument();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorInitializerUtil : object {
    [ExtensionAttribute]
public static ICppExpression GetParameterDefaultArgument(CppDeclaratorInitializer init);
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertTypeClass(CppDeclaratorInitializer initializer, CppTypeClasses typec);
    [ExtensionAttribute]
public static bool UpdateLazyMergingInfo(CppDeclaratorInitializer initializer, ICppLazyMergingDataConsumer resultConsumer);
    [ExtensionAttribute]
public static CppDeclaratorInitializer CreateClassAndReplaceClassType(CppDeclaratorInitializer initializer, CppCreateClassAndReplaceClassTypeContext& ctx);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppExpression GetArrayInitializer(CppDeclaratorInitializer init);
    [ExtensionAttribute]
public static CppDependentInfo GetDependentInfo(CppDeclaratorInitializer init);
    [ExtensionAttribute]
public static CppSmallArray`1<ICppExpression> ResolveDeclaratorInitializerArguments(CppDeclaratorInitializer initializer, CppTypeContext& tc, ICppFileResolveEntitiesCache fileCache);
    [ExtensionAttribute]
public static ICppResolvedExpression GetAutoInitializer(CppDeclaratorInitializer init, ICppVariableDeclaratorResolveEntity var, CppTypeContext& tc);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorLinkageEntity : CppLinkageEntity {
    private ICppExpression myRequiresClause;
    [CompilerGeneratedAttribute]
private CppDeclarationSpecifiers <DeclarationSpecifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private CppPureVirtualSpecifiers <PureVirtualSpecifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private CppQualType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private CppLinkageDeclaratorType <DeclaratorType>k__BackingField;
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppQualType Type { get; }
    public bool IsFunction { get; }
    public bool IsTypeAlias { get; }
    public bool IsCliPropertyOrEvent { get; }
    public bool IsDeductionGuide { get; }
    public bool IsConcept { get; }
    public CppLinkageDeclaratorType DeclaratorType { get; }
    public CppDeclaratorLinkageEntity(CppQualifiedNamePart name, ICppLinkageEntity parent, CppQualType type, CppDeclarationSpecifiers declarationSpecifiers, CppPureVirtualSpecifiers pureVirtualSpecifiers, CppLinkageDeclaratorType declaratorType, ICppExpression requiresClause);
    [CompilerGeneratedAttribute]
public CppDeclarationSpecifiers get_DeclarationSpecifiers();
    [CompilerGeneratedAttribute]
public CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    [CompilerGeneratedAttribute]
public CppQualType get_Type();
    public bool get_IsFunction();
    public bool get_IsTypeAlias();
    public bool get_IsCliPropertyOrEvent();
    public bool get_IsDeductionGuide();
    public bool get_IsConcept();
    [CompilerGeneratedAttribute]
public CppLinkageDeclaratorType get_DeclaratorType();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual Result Accept(ICppLinkageEntityVisitor`1<Result> visitor);
}
[DebuggerDisplayAttribute("{Name}{PresentSpecifiers()}")]
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorResolveEntityBase : object {
    private ICppResolveEntityParentScope myStructuralParent;
    private CppLocationAnchor myLocationAnchor;
    private CppQualifiedNamePart myName;
    private ICppDeclaratorSymbol mySymbol;
    private CppQualType myUnresolvedType;
    [CompilerGeneratedAttribute]
private CppAttributeList <Attributes>k__BackingField;
    public bool IsFriend { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; private set; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    protected CppDeclaratorResolveEntityBase(ICppResolveEntityParentScope parent, CppQualifiedNamePart name, ICppDeclaratorSymbol sym, CppLocationAnchor anchor, CppQualType replacedType, CppAttributeList replacedAttributes);
    protected void ResolveAndSetAttributes(CppAttributeList replacedAttributes);
    public bool get_IsFriend();
    public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    [CompilerGeneratedAttribute]
public virtual CppAttributeList get_Attributes();
    [CompilerGeneratedAttribute]
private void set_Attributes(CppAttributeList value);
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public virtual CppAccessibility GetAccessibility();
    public abstract virtual bool HasDefinition();
    public virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
    public virtual void AddChild(ICppResolveEntity e);
    public virtual void RemoveChild(ICppResolveEntity e);
    public virtual CppSmallList`1<ICppResolveEntity> ChildByName(CppQualifiedNamePart name, CppLocationAnchor anchor);
    public virtual CppList`1<ICppResolveEntity> GetChildren();
    public virtual void AddAnonymousClass(ICppClassResolveEntity e);
    public virtual CppList`1<ICppClassResolveEntity> AnonymousClasses();
    public virtual ICppResolveEntityParent get_RealParent();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual ICppScopeResolveEntity LexicalParentScope();
    public virtual void Dump(CppIndentationStringBuilder tw);
    public void SetStructuralParent(ICppResolveEntityParentScope structuralParent);
    public CppQualType GetUnresolvedType();
    public virtual string ToString();
    public static string ToString(ICppDeclaratorResolveEntity ent);
    public ICppDeclaratorSymbol GetDeclaratorSymbol();
    public string PresentSpecifiers();
    protected virtual void DumpInternal(CppIndentationStringBuilder sb);
    protected abstract virtual CppQualType GetNonNormalizedType(ICppResolvedTypeFactory typeIntern, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPosForDeclSpecs, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPosForDeclarator);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorResolveEntityPack : CppResolveEntityBase {
    private FrugalLocalList`1<ICppDeclaratorResolveEntity> myPendingNonFriendsEntities;
    private CppSmallList`1<ICppDeclaratorResolveEntity> myPendingFriendsEntities;
    private FrugalLocalList`1<CppDeferredDeclaratorData> myPendingSymbols;
    private CppDeclaratorGroupBuilder myBuilder;
    private bool myInsideMergingOfFriends;
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppDeclaratorResolveEntityPack(ICppResolveEntity parent, CppQualifiedNamePart name, CppLocationAnchor anchor);
    private CppDeclaratorResolveEntityPack(ICppResolveEntity parent, CppQualifiedNamePart name, CppLocationAnchor anchor, CppList`1<ICppResolveEntity> groupedEntities);
    public static CppDeclaratorResolveEntityPack Create(ICppResolveEntity parent, CppQualifiedNamePart name, CppLocationAnchor anchor);
    public static CppDeclaratorResolveEntityPack CreateWithGroupedEntities(ICppResolveEntity parent, CppQualifiedNamePart name, CppLocationAnchor anchor, CppList`1<ICppResolveEntity> entities);
    public virtual void Dump(CppIndentationStringBuilder tw);
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    [CanBeNullAttribute]
public ICppSymbol GetSymbolForCodeCompletion();
    public virtual TResult Accept(ICppResolveEntityVisitor`1<TResult> visitor);
    public virtual void ForceMerge(CppLocationAnchor anchor);
    public virtual IEnumerable`1<ICppResolveEntity> GetGroupedEntities();
    public virtual IEnumerable`1<ICppResolveEntity> GetGroupedEntities(CppLocationAnchor anchor);
    public virtual void AppendGroupedEntities(CppLocationAnchor anchor, FrugalLocalList`1& result);
    public virtual void AppendGroupedEntities(CppLocationAnchor anchor, List`1<ICppResolveEntity> result);
    public virtual ICppGroupedDeclaratorResolveEntity FindGroupedDeclarator(ICppDeclaratorResolveEntity ungrouped);
    public CppSmallEnumerable`1<CppGroupedVariableDeclaratorResolveEntity> GetGroupedVariables();
    public CppSmallEnumerable`1<CppGroupedFunctionDeclaratorResolveEntity> GetGroupedFunctions();
    public CppSmallEnumerable`1<ICppMutableFunctionTemplateDeclaratorResolveEntity> GetFunctionTemplates();
    public CppSmallEnumerable`1<CppGroupedTypeDeclaratorResolveEntity> GetGroupedTypeAliases();
    public void AddDeclarator(ICppDeclaratorResolveEntity ent);
    public void AddFriend(ICppDeclaratorResolveEntity ent);
    public void AddFriendUnsafe(ICppDeclaratorResolveEntity ent);
    public void AddDeclaratorLazy(CppDeferredDeclaratorData data);
    public bool TryAddDeclarator(ICppDeclaratorResolveEntity ent);
    public void AddGroupedDeclarator(ICppDeclaratorOrTemplateDeclaratorPack ent);
    public ICppGroupedVariableDeclaratorResolveEntity AddVariableTemplate(ICppVariableDeclaratorResolveEntity ungrouped);
    public ICppGroupedFunctionDeclaratorResolveEntity AddFunctionTemplate(ICppFunctionDeclaratorResolveEntity ungrouped);
    public ICppGroupedFunctionDeclaratorResolveEntity AddExplicitInstantiationFunction(ICppFunctionDeclaratorResolveEntity ungrouped);
    public ICppGroupedTypeDeclaratorResolveEntity AddTypeAliasTemplate(ICppTypeDeclaratorResolveEntity ungrouped);
    public void AddOtherEntity(ICppResolveEntity e);
    public virtual string ToString();
    public void ForEachUngroupedDeclarator(IUngroupedDeclaratorProcessor proc);
    public bool ContainsImportedDeclarator();
    private static bool IsImported(ICppDeclaratorResolveEntity ent);
    public bool ContainsTypedef();
    public bool CouldContainDeclaratorAttachedTo(string moduleName, ICppFileResolveEntitiesCache resolveCache);
    public bool ContainsFunctionOrFunctionTemplate();
    public ICppDeclaratorResolveEntity GetAnyUngroupedDeclarator();
    public bool ContainsSymbolInFile(CppFileLocation file);
    public CppSmallEnumerable`1<ICppMutableVariableTemplateDeclaratorResolveEntity> GetVariableTemplates();
    public CppSmallEnumerable`1<ICppMutableTypeTemplateDeclaratorResolveEntity> GetTypeAliasTemplates();
    public void AppendGroupedEntitiesWithUnpackedTemplateSpecializations(List`1<ICppResolveEntity> output);
    public void AddDeclaratorUnsafe(ICppDeclaratorResolveEntity ent);
    public ICppGroupedDeclaratorResolveEntity AddDeclaratorUnsafeAndGroup(ICppDeclaratorResolveEntity decl);
    protected virtual void DoMergeDeclaratorsUpTo(CppLocationAnchor upto, bool withImplicits);
    protected void DoMergeDeclaratorsUpTo(CppLocationAnchor upto);
    internal CppDeclaratorGroupBuilder GetBuilder();
    protected CppDeclaratorGroupBuilder GetBuilder(bool createIfNotExist);
    protected FrugalLocalList`1<ICppDeclaratorResolveEntity> GetPendingNonFriendsEntities();
    protected FrugalLocalList`1<CppDeferredDeclaratorData> GetPendingSymbols();
    internal void MergeDeclaratorsUpTo(CppLocationAnchor upto, bool withImplicits, bool mergeSubstitutedFriends);
    protected void MergeOneNonLazy();
    protected void MergeOneLazy();
    protected ICppDeclaratorResolveEntity CreateDeclaratorByDeferredData(CppDeferredDeclaratorData data);
    protected void CreateAllLazy();
    private void MergeFriends(bool mergeSubstitutedFriends);
    private static List`1<ICppResolveEntity> FilterByAnchorImpl(List`1<ICppResolveEntity> input, CppLocationAnchor anchor);
    internal bool Internal_IsDeclaratorPackComeOnlyFromGGDeclareHungarianDirective();
    private static bool IsConversionName(CppQualifiedNamePart name);
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorResolveEntityPackUtil : object {
    public static void EnsureDelayedDeclaratorsAreMerged(ICppScopeResolveEntity scope, CppQualifiedNamePart name, bool isFunction, CppLocationAnchor anchor);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorResolveEntityUtil : object {
    [ExtensionAttribute]
public static bool IsDeleted(ICppFunctionDeclaratorResolveEntity func);
    [ExtensionAttribute]
public static CppDeclarationSpecifiers AdjustDeclarationSpecifiers(CppDeclarationSpecifiers original, ICppScopeResolveEntity parent);
    [ExtensionAttribute]
public static bool IsConstructorValid(ICppFunctionDeclaratorResolveEntity ctor, ICppFriendDeclTargetResolveEntity clazz, CppViewPos& viewPos);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppFunctionDeclaratorResolveEntity Ungroup(ICppFunctionDeclaratorResolveEntity func);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppDeclaratorResolveEntity Ungroup(ICppDeclaratorResolveEntity decl);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string GetOwningModule(ICppDeclaratorResolveEntity declarator, ICppFileResolveEntitiesCache resolveCache);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorResolveEntityWithSubstitutionBase`1 : CppResolveEntityWithSubstitution {
    private CppViewPos myViewPos;
    private Declarator myInner;
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    protected CppDeclaratorResolveEntityWithSubstitutionBase`1(ICppResolveEntityParent structuralParent, CppViewPos& viewPos, CppQualifiedNamePart name, Declarator inner, ICppSubstitutionContext subst);
    public virtual ICppDeclaratorResolveEntity GetInner();
    public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public virtual CppAttributeList get_Attributes();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public sealed virtual CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) PointOfInstantiation();
    public virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
    public Declarator GetTypedInner();
    protected void UpdateInstantiationPoint(CppViewPos& vp);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorSpecializationLinkageEntity : CppDeclaratorLinkageEntity {
    private ICppLinkageEntity myPrimaryTemplate;
    public CppDeclaratorSpecializationLinkageEntity(CppQualifiedNamePart name, ICppLinkageEntity parent, CppQualType type, CppDeclarationSpecifiers declarationSpecifiers, CppPureVirtualSpecifiers pureVirtualSpecifiers, ICppLinkageEntity primaryTemplate, CppLinkageDeclaratorType declaratorType, ICppExpression requiresClause);
    public sealed virtual ICppLinkageEntity GetPrimaryTemplate();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorSymbol : CppParserSymbol {
    private CppDeclarationSpecifiers mySpecifiers;
    protected int myAnchorDelta;
    private ushort myFlags;
    private static int ModuleAttachmentOffset;
    public bool IsExplicitInstantiation { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; public set; }
    public CppQualType RawType { get; }
    internal CppDeclaratorSymbol(RawData& data);
    protected CppDeclaratorSymbol(CppQualifiedName name, CppComplexOffset loc);
    protected CppDeclaratorSymbol(CppQualifiedName name, CppComplexOffset loc, CppDeclarationSpecifiers specifiers, bool isExplicitInstantiation, CppAccessibility accessibility, CppModuleAttachment moduleAttachment, CppLazyMergingDataConsumer lazyMergingInfo);
    protected void InitLazyMergingInfo(CppLazyMergingDataConsumer result);
    public sealed virtual bool get_IsExplicitInstantiation();
    public virtual CppSymbolTemplateParametersList ParamList();
    public virtual CppAttributeList Attributes();
    public virtual CppSmallList`1<CppQualifiedName> CxxCliOverrideSpecifiers();
    public virtual ICppExpression GetRequiresClause();
    public sealed virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public sealed virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public void set_PureVirtualSpecifiers(CppPureVirtualSpecifiers value);
    public abstract virtual CppQualType get_RawType();
    public virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual CppDeclarationTrailingKind GetDeclarationTrailingKind();
    public sealed virtual bool IsParameterPack();
    public CppModuleAttachment ModuleAttachment();
    public sealed virtual bool IsFunction();
    public sealed virtual CppAccessibility GetAccessibility();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    private static CppDeclaratorSymbol CreateImpl(CppQualifiedName name, CppSymbolTemplateParametersList paramList, CppAttributeList attrList, CppComplexOffset loc, CppDeclarationSpecifiers specifiers, bool isExplicitInstantiation, CppAccessibility accessibility, CppQualType type, CppSmallList`1<CppQualifiedName> overrideSpecifiers, ICppExpression requiresClause, bool withFuncBody, CppModuleAttachment moduleAttachment, CppLazyMergingDataConsumer lazyMergingInfo);
    public static CppDeclaratorSymbol Create(CppQualifiedName name, CppSymbolTemplateParametersList paramList, CppAttributeList attrList, CppComplexOffset loc, CppDeclarationSpecifiers specifiers, bool isExplicitInstantiation, CppAccessibility accessibility, CppQualType type, CppSmallList`1<CppQualifiedName> overrideSpecifiers, ICppExpression requiresClause, bool withFuncBody, CppModuleAttachment moduleAttachment);
    public virtual CppCompoundStatementSymbol GetFunctionBody();
    public virtual void SetInitializer(CppDeclaratorInitializer initializer);
    public void SetFunctionBody(CppDeclarationTrailingKind trailingKind);
    public void SetAccessibility(CppAccessibility accessibility);
    public bool IsFunctionWithAutoParams();
    public virtual string ToString();
    public ushort GetDeclaratorFlags();
    public abstract virtual CppSmallList`1<ICppClassSymbol> GetAffectedSymbols();
    public int GetLazyMergingAnchorDelta();
    public bool CanBeLazilyMerged();
    public void DisableLazyMerging();
    private DeclaratorFlags DeclarationTrailingKindToFlags(CppDeclarationTrailingKind kind);
    private CppDeclarationTrailingKind FlagsToDeclarationTrailingKind(DeclaratorFlags flags);
    private CppAccessibility FlagsToAccessibility(DeclaratorFlags flags);
    private DeclaratorFlags AccessibilityToFlags(CppAccessibility accessibility);
    private string SpecsToString();
    private string AttributesToString();
    private string HasInitToString();
    private string PVSpecToString();
    private string AccessibilityToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorSymbolUtil : object {
    [ExtensionAttribute]
public static CppQualType GetDeclaratorSymbolType(ICppDeclaratorSymbol declarator, ICppSymbolTypeFactory factory);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorWithAttributesSymbol : CppDeclaratorWithFuncBodySymbol {
    private CppAttributeList myAttributes;
    private CppSmallList`1<CppQualifiedName> myCxxCliOverrideSpecifiers;
    private ICppExpression myRequiresClause;
    public CppDeclaratorWithAttributesSymbol(CppQualifiedName name, CppSymbolTemplateParametersList paramList, CppAttributeList attrList, CppComplexOffset loc, CppDeclarationSpecifiers specifiers, bool isExplicitInstantiation, CppAccessibility accessibility, CppQualType type, CppSmallList`1<CppQualifiedName> overrideSpecifiers, ICppExpression requiresClause, CppModuleAttachment moduleAttachment, CppLazyMergingDataConsumer lazyMergingInfo);
    internal CppDeclaratorWithAttributesSymbol(RawData& data, CppUnpackedQualTypeAndInitializer& typeAndInitializer, CppSymbolTemplateParametersList paramList, CppAttributeList attrList, CppSmallList`1<CppQualifiedName> overrideSpecifiers, ICppExpression requiresClause, CppCompoundStatementSymbol funcBody);
    protected virtual void Visit(CppLazyMergingDataConsumer consumer);
    public virtual CppAttributeList Attributes();
    public virtual CppSmallList`1<CppQualifiedName> CxxCliOverrideSpecifiers();
    public virtual ICppExpression GetRequiresClause();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorWithFuncBodySymbol : CppDeclaratorWithTemplateParametersSymbol {
    [CanBeNullAttribute]
private CppCompoundStatementSymbol myBody;
    public CppDeclaratorWithFuncBodySymbol(CppQualifiedName name, CppSymbolTemplateParametersList paramList, CppComplexOffset loc, CppDeclarationSpecifiers specifiers, bool isExplicitInstantiation, CppAccessibility accessibility, CppQualType type, CppModuleAttachment moduleAttachment, CppLazyMergingDataConsumer lazyMergingInfo);
    internal CppDeclaratorWithFuncBodySymbol(RawData& data, CppUnpackedQualTypeAndInitializer& typeAndInitializer, CppSymbolTemplateParametersList paramList, CppCompoundStatementSymbol funcBody);
    public virtual CppCompoundStatementSymbol GetFunctionBody();
    public void SetBody(CppCompoundStatementSymbol body);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorWithImplicitsResolveEntityPackBase : CppDeclaratorResolveEntityPack {
    private static Func`2<ICppResolveEntity, bool> IsNotImplicit;
    protected ICppMutableClassResolveEntity myClass;
    protected bool myShouldGenerate;
    protected bool myGeneratedAlready;
    protected bool myShouldGenerateMoveOperations;
    private static CppDeclaratorWithImplicitsResolveEntityPackBase();
    protected CppDeclaratorWithImplicitsResolveEntityPackBase(ICppMutableClassResolveEntity klass, CppQualifiedNamePart name, CppLocationAnchor anchor);
    public virtual void Dump(CppIndentationStringBuilder tw);
    public IEnumerable`1<ICppResolveEntity> GetGroupedEntitiesWithoutImplicits();
    protected virtual void DoMergeDeclaratorsUpTo(CppLocationAnchor upto, bool withImplicits);
    protected abstract virtual bool GenerateImplicits();
    public void EnableGeneration(bool withMoveOperations);
    [CanBeNullAttribute]
public CppDefaultedSpecialMembers GetTemplateDefaultedSpecialMembers();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorWithInitializerSymbol : CppDeclaratorSymbol {
    private CppUnpackedQualTypeAndInitializer myTypeAndInitializer;
    private CppSmallList`1<ICppClassSymbol> myAffectedSymbols;
    public CppQualType RawType { get; }
    public CppDeclaratorWithInitializerSymbol(CppQualifiedName name, CppComplexOffset loc, CppDeclarationSpecifiers specifiers, bool isExplicitInstantiation, CppAccessibility accessibility, CppQualType type, CppModuleAttachment moduleAttachment, CppLazyMergingDataConsumer lazyMergingInfo);
    internal CppDeclaratorWithInitializerSymbol(RawData& data, CppUnpackedQualTypeAndInitializer& typeAndInitializer);
    public virtual CppQualType get_RawType();
    public virtual CppSmallList`1<ICppClassSymbol> GetAffectedSymbols();
    public virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual void SetInitializer(CppDeclaratorInitializer initializer);
    private void UpdateLazyMergingInfoForInitializer(CppDeclaratorInitializer initializer);
    internal void InitLazyMergingInfo();
    protected virtual void Visit(CppLazyMergingDataConsumer consumer);
    internal CppUnpackedQualTypeAndInitializer& modreq(System.Runtime.InteropServices.InAttribute) GetTypeAndInitializer();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorWithTemplateParametersSymbol : CppDeclaratorWithInitializerSymbol {
    private CppSymbolTemplateParametersList myParamList;
    public CppDeclaratorWithTemplateParametersSymbol(CppQualifiedName name, CppSymbolTemplateParametersList paramList, CppComplexOffset loc, CppDeclarationSpecifiers specifiers, bool isExplicitInstantiation, CppAccessibility accessibility, CppQualType type, CppModuleAttachment moduleAttachment, CppLazyMergingDataConsumer lazyMergingInfo);
    internal CppDeclaratorWithTemplateParametersSymbol(RawData& data, CppUnpackedQualTypeAndInitializer& typeAndInitializer, CppSymbolTemplateParametersList paramList);
    protected virtual void Visit(CppLazyMergingDataConsumer consumer);
    public virtual CppSymbolTemplateParametersList ParamList();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaredElementTypeUtil : object {
    [ExtensionAttribute]
public static CppDeclaredElementType GetDeclaredElementType(ICppResolveEntity input);
    [ExtensionAttribute]
public static CppDeclaredElementType GetDeclaredElementType(ICppLinkageEntity input);
    [ExtensionAttribute]
public static CppDeclaredElementType GetDeclaredElementType(ICppSymbol input);
    public static CppDeclaredElementType GetDeclaredElementType(CppResolveResult& rr);
    [ExtensionAttribute]
public static bool WithoutReturnType(IDeclaredElement declaredElement);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDecltypeDestructorTag : object {
    public static CppDecltypeDestructorTag INSTANCE;
    private static CppDecltypeDestructorTag();
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDecltypeId : object {
    private ICppExpression myExpr;
    private CppDecltypeKind myKind;
    public CppDecltypeId(ICppExpression expr, CppDecltypeKind kind);
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public ICppExpression GetExpression();
    public CppDecltypeKind GetKind();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppDecltypeKind : Enum {
    public byte value__;
    public static CppDecltypeKind DECLTYPE;
    public static CppDecltypeKind TYPEOF;
    public static CppDecltypeKind TYPEOF_UNQUAL;
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDecltypeKindUtil : object {
    public static Nullable`1<CppDecltypeKind> FromTokenNodeType(TokenNodeType nodeType);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDecltypeModuleEntity : CppDecltypeModuleEntityBase {
    public CppDecltypeModuleEntity(ICppExpression argument, CppDecltypeKind kind);
    private sealed virtual override CppModuleEntityKind JetBrains.ReSharper.Psi.Cpp.Symbols.ICppModuleEntity.Kind();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDecltypeModuleEntityBase : object {
    public ICppExpression Argument;
    public CppDecltypeKind Kind;
    protected CppDecltypeModuleEntityBase(ICppExpression argument, CppDecltypeKind kind);
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDecltypeResolveEntity : object {
    private ICppResolvedExpression myExpr;
    private CppDecltypeKind myKind;
    private ICppFileResolveEntitiesCache myResolveCache;
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppDecltypeResolveEntity(ICppResolvedExpression expr, CppDecltypeKind kind, ICppFileResolveEntitiesCache resolveCache);
    public sealed virtual ICppResolvedExpression GetExpression();
    public sealed virtual CppDecltypeKind GetKind();
    public sealed virtual ICppFileResolveEntitiesCache GetResolveCache();
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeductionGuideModuleEntity : object {
    public CppClassModuleEntity PrimaryTemplate;
    public CppQualifiedNamePart Name;
    public CppQualType Type;
    public CppParameterListModuleEntity ParamList;
    [CanBeNullAttribute]
public ICppExpression RequiresClause;
    public CppSmallArray`1<ICppAttribute> Attributes;
    public CppDeductionGuideModuleEntity(CppClassModuleEntity primaryTemplate, CppQualifiedNamePart name, CppQualType type, CppParameterListModuleEntity paramList);
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual ICppScopeModuleEntity GetParent();
    public sealed virtual bool IsExplicitlyExported();
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public void Import(CppModuleImportingContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDefaultedComparisonInfo : ValueType {
    public bool IsDeleted;
    public ICppFunctionDeclaratorResolveEntity InvokedNonConstexprFunction;
    public CppComparisonCategoryType Category;
    public bool ComparisonCategoryTypeNotFound;
    public ICppResolvedBinaryExpression ComparisonWithNoViableCandidates;
    public TriBool IsNoexcept;
    public static CppDefaultedComparisonInfo GetDefault();
    public static CppDefaultedComparisonInfo GetDeleted();
    public static CppDefaultedComparisonInfo GetComparisonCategoryTypeNotFound();
    public static CppDefaultedComparisonInfo GetComparisonWithNoViableCandidates(ICppResolvedBinaryExpression expr);
    public bool Merge(CppDefaultedComparisonInfo other);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDefaultedSpecialMembers : object {
    [CanBeNullAttribute]
public ICppFunctionDeclaratorResolveEntity DefaultCtor;
    [CanBeNullAttribute]
public ICppFunctionDeclaratorResolveEntity CopyCtor;
    [CanBeNullAttribute]
public ICppFunctionDeclaratorResolveEntity MoveCtor;
    [CanBeNullAttribute]
public ICppFunctionDeclaratorResolveEntity CopyAssignment;
    [CanBeNullAttribute]
public ICppFunctionDeclaratorResolveEntity MoveAssignment;
    [CanBeNullAttribute]
public ICppFunctionDeclaratorResolveEntity Destructor;
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeferredDeclaratorData : ValueType {
    public CppDeclaratorSymbol Symbol;
    public CppLocationAnchor Anchor;
    public CppQualType DeclSpecType;
    public int AnchorDiff;
    public CppDeferredDeclaratorData(CppDeclaratorSymbol symbol, CppLocationAnchor anchor, int anchorDiff, CppQualType declSpecType);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeferredPackSpecializationData : ValueType {
    public ICppClassSymbol symbol;
    public CppLocationAnchor anchor;
    public CppDeferredPackSpecializationData(ICppClassSymbol symbol, CppLocationAnchor anchor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDelegateDeclaration0Builder : CppDeclaration0Builder {
    public CppDelegateDeclaration0Builder(ICppBuilder parent, CppSymbolLocation loc);
    public virtual ICppConceptDefinitionBuilder NewConceptDefinitionBuilder();
    protected virtual ICppDeclaratorBuilder NewDeclaratorBuilderImpl();
    private static CppTemplateDeclarationBuilder GetTemplateDeclarationBuilder(ICppBuilder builder);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDelegateDeclarator0Builder : CppDeclarator0Builder`2<CppCxxCliDelegateSymbol, CppClassResolveEntity> {
    public CppDelegateDeclarator0Builder(CppDelegateDeclaration0Builder parent);
    public virtual void LearnFunctionBody(CppFunctionBodyBuilder _);
    public virtual void LearnFunctionBody(CppDeclarationTrailingKind trailingKind);
    public virtual void LearnClosedBodyChameleon();
    public virtual void LearnCtorBlockWithoutBody();
    public virtual ICppBuilder CreateInitDeclaratorBuilder();
    public virtual void ComposeSymbolType(CppSymbolLocation loc);
    public virtual void LearnInitializer(KIND kind, CppSmallArray`1<ICppExpression> unresolvedArguments, CppSmallArray`1<ICppExpression> replacedArguments);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependencyKillerResolveEntity : object {
    [CompilerGeneratedAttribute]
private ICppDependentTypeResolveEntity <InnerEntity>k__BackingField;
    public ICppDependentTypeResolveEntity InnerEntity { get; }
    public CppDependentInfo DependentInfo { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppDependencyKillerResolveEntity(ICppDependentTypeResolveEntity resolveEntity);
    [CompilerGeneratedAttribute]
public ICppDependentTypeResolveEntity get_InnerEntity();
    public sealed virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public sealed virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public sealed virtual CppDependentInfo get_DependentInfo();
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public CppTemplateParametersBase GetParameters();
    public ICppTemplateArgument[] GetDefaults(CppViewPos& vp);
    public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentAutoTypeLinkageEntity : object {
    private CppQualType myType;
    public CppQualifiedName DebugQualifiedName { get; }
    public CppDependentAutoTypeLinkageEntity(CppQualType type);
    public sealed virtual CppQualifiedName get_DebugQualifiedName();
    public sealed virtual Result Accept(ICppDependentLinkageEntityVisitor`1<Result> visitor);
    public sealed virtual string Present(ICppPresenter presenter);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentAutoTypeResolveEntity : object {
    [CompilerGeneratedAttribute]
private ICppExpression <InitializerExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private CppQualType <AutoType>k__BackingField;
    public ICppExpression InitializerExpression { get; private set; }
    public CppQualType AutoType { get; private set; }
    public CppDependentInfo DependentInfo { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppDependentAutoTypeResolveEntity(ICppExpression innerExpr, CppQualType autoType);
    [CompilerGeneratedAttribute]
public ICppExpression get_InitializerExpression();
    [CompilerGeneratedAttribute]
private void set_InitializerExpression(ICppExpression value);
    [CompilerGeneratedAttribute]
public CppQualType get_AutoType();
    [CompilerGeneratedAttribute]
private void set_AutoType(CppQualType value);
    public virtual FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHidByName);
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver driver);
    public virtual CppDependentInfo get_DependentInfo();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentDecltypeLinkageEntity : object {
    private string myStr;
    public CppQualifiedName DebugQualifiedName { get; }
    public CppDependentDecltypeLinkageEntity(ICppExpression expr);
    public sealed virtual CppQualifiedName get_DebugQualifiedName();
    public sealed virtual Result Accept(ICppDependentLinkageEntityVisitor`1<Result> visitor);
    public sealed virtual string Present(ICppPresenter _);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentDecltypeModuleEntity : CppDecltypeModuleEntityBase {
    public CppDependentDecltypeModuleEntity(ICppExpression argument, CppDecltypeKind kind);
    private sealed virtual override CppModuleEntityKind JetBrains.ReSharper.Psi.Cpp.Symbols.ICppModuleEntity.Kind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentDecltypeResolveEntity : object {
    private CppDecltypeKind myKind;
    private ICppFileResolveEntitiesCache myFileCache;
    [CompilerGeneratedAttribute]
private ICppResolvedExpression <DecltypeExpression>k__BackingField;
    public ICppResolvedExpression DecltypeExpression { get; }
    public CppDependentInfo DependentInfo { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppDependentDecltypeResolveEntity(ICppResolvedExpression innerExpr, CppDecltypeKind kind, ICppFileResolveEntitiesCache cache);
    [CompilerGeneratedAttribute]
public ICppResolvedExpression get_DecltypeExpression();
    public sealed virtual ICppResolvedExpression GetExpression();
    public sealed virtual CppDecltypeKind GetKind();
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool forceHideByName, bool ignoreDependencies);
    public sealed virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public sealed virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public sealed virtual CppDependentInfo get_DependentInfo();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual ICppFileResolveEntitiesCache GetResolveCache();
    public static CppQualType CheckFailureAndGetDecltype(ICppResolvedExpression substitutedExpr, CppDecltypeKind kind, CppTypeContext& tc, ICppFileResolveEntitiesCache resolveCache);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentDeducedClassTypePlaceholder : object {
    public ICppDeducibleTypeTemplateResolveEntity ClassTemplate;
    public CppDeclaratorInitializer Initializer;
    [CanBeNullAttribute]
public ICppArgumentList ArgumentList;
    public CppDependentInfo DependentInfo { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppDependentDeducedClassTypePlaceholder(ICppDeducibleTypeTemplateResolveEntity classTemplate, CppDeclaratorInitializer initializer);
    public CppDependentDeducedClassTypePlaceholder(ICppDeducibleTypeTemplateResolveEntity classTemplate, ICppArgumentList argumentList);
    public sealed virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver driver);
    public sealed virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver driver);
    public sealed virtual CppDependentInfo get_DependentInfo();
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentDeducedClassTypePlaceholderLinkageEntity : object {
    public static CppDependentDeducedClassTypePlaceholderLinkageEntity INSTANCE;
    private static string Name;
    private static CppQualifiedId ourDebugName;
    public CppQualifiedName DebugQualifiedName { get; }
    private static CppDependentDeducedClassTypePlaceholderLinkageEntity();
    public sealed virtual CppQualifiedName get_DebugQualifiedName();
    public sealed virtual string Present(ICppPresenter _);
    public sealed virtual Result Accept(ICppDependentLinkageEntityVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentDeducedClassTypePlaceholderModuleEntity : object {
    private ICppModuleEntity myClassTemplate;
    private CppDeclaratorInitializer myInitializer;
    public CppDependentDeducedClassTypePlaceholderModuleEntity(ICppModuleEntity classTemplate, CppDeclaratorInitializer initializer);
    public CppImportResult`1<CppDependentDeducedClassTypePlaceholder> Import(CppModuleImportingContext ctx);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentFunctionReturnAutoTypeResolveEntity : object {
    private static CppQualifiedId ourName;
    public CppQualType AutoType;
    public CppDependentInfo DependentInfo { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppDependentFunctionReturnAutoTypeResolveEntity(CppQualType autoType);
    private static CppDependentFunctionReturnAutoTypeResolveEntity();
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver driver);
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver driver);
    public virtual CppDependentInfo get_DependentInfo();
    public virtual FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentLinkageEntity : object {
    private CppQualifiedName myName;
    [CompilerGeneratedAttribute]
private ICppDependentLinkageEntity <Head>k__BackingField;
    public ICppDependentLinkageEntity Head { get; }
    public CppQualifiedName Tail { get; }
    public CppQualifiedName DebugQualifiedName { get; }
    public CppDependentLinkageEntity(ICppDependentLinkageEntity head, CppQualifiedName name);
    [CompilerGeneratedAttribute]
public ICppDependentLinkageEntity get_Head();
    public CppQualifiedName get_Tail();
    public sealed virtual CppQualifiedName get_DebugQualifiedName();
    public sealed virtual Result Accept(ICppDependentLinkageEntityVisitor`1<Result> visitor);
    public sealed virtual string Present(ICppPresenter presenter);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentModuleEntity : object {
    public ICppDependentModuleEntityHead Head;
    public CppQualifiedName Tail;
    public CppLookupFilter Filter;
    public CppDependentInfo DependentInfo;
    public CppDependentModuleEntity(ICppDependentModuleEntityHead head, CppQualifiedName tail, CppLookupFilter filter, CppDependentInfo dependentInfo);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentResolveEntity : object {
    private ICppDependentScopeLikeResolveEntity myHead;
    private CppQualifiedName myTail;
    private CppLookupFilter myFilter;
    [CompilerGeneratedAttribute]
private CppDependentInfo <DependentInfo>k__BackingField;
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppDependentInfo DependentInfo { get; }
    private CppDependentResolveEntity(ICppDependentScopeLikeResolveEntity head, CppQualifiedName tail, CppLookupFilter filter, CppDependentInfo depInfo);
    public sealed virtual ICppTemplateArgument DoSubstitutionGetTemplateArgument(CppSubstitutionDriver substDriver);
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual CppLookupResult DoSubstitutionGetLookupResult(CppSubstitutionDriver substDriver);
    public sealed virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public sealed virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    private CppQualType SubstituteEnableIf(ICppTypeTemplateInstantiationResolveEntity enableIfInst, CppSubstitutionDriver substDriver);
    [CompilerGeneratedAttribute]
public sealed virtual CppDependentInfo get_DependentInfo();
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& vp, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public sealed virtual CppTemplateParametersBase GetParameters();
    public ICppTemplateArgument[] GetDefaults(CppViewPos& vp);
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetAllSpecializations();
    public static CppDependentResolveEntity CreateDependentResolveEntity(ICppDependentScopeLikeResolveEntity head, CppQualifiedName tail, CppLookupFilter filter);
    public static CppDependentResolveEntity CreateDependentResolveEntityWithCustomDependentInfo(ICppDependentScopeLikeResolveEntity head, CppQualifiedName tail, CppLookupFilter filter, CppDependentInfo depInfo);
    public static FrugalLocalList`1<ICppResolveEntity> CreateSingleDepEntList(ICppDependentScopeLikeResolveEntity head, CppQualifiedNamePart tail, CppLookupFilter filter);
    public static CppDependentResolveEntity ApplyTemplateArguments(CppDependentResolveEntity e, ICppTemplateArgument[] args);
    [DebuggerStepThroughAttribute]
public ICppDependentScopeLikeResolveEntity GetTypeParameter();
    [DebuggerStepThroughAttribute]
public CppQualifiedName GetTail();
    [DebuggerStepThroughAttribute]
public CppLookupFilter GetFilter();
    private static CppQualType LookupResultToSubstitutionResult(CppLookupResult lookupResult, ICppResolvedTypeFactory tf);
    public static bool Is_type(CppQualifiedNamePart name);
    public ICppTemplateArgument DoSubstitutionGetTemplateArgument(CppSubstitutionDriver substDriver, CppQualifiedName lookedUpNameHintWithoutSubstitution, bool hadTypename);
    public virtual string ToString();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    [CanBeNullAttribute]
public ICppTypeTemplateInstantiationResolveEntity GetEnableIfInstantiaion();
    private ICppTemplateArgument DoSubstitutionGetTemplateArgumentWithSubstitutedNameHint(CppSubstitutionDriver substDriver, CppQualifiedName lookedUpNameHint, bool hadTypename);
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    private sealed virtual override ICppTemplateArgument[] JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateResolveEntityBase.GetDefaults(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentResolveEntityParentScope : object {
    private ICppScopeResolveEntity myLexicalParent;
    private ICppDependentScopeLikeResolveEntity myScope;
    public CppDependentResolveEntityParentScope(ICppDependentScopeLikeResolveEntity scope, ICppScopeResolveEntity lexicalParent);
    public ICppDependentScopeLikeResolveEntity GetScope();
    public ICppScopeResolveEntity GetLexicalParent();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentStructuredBindingTypeModuleEntity : CppDependentAutoTypeResolveEntity {
    public int ElementIndex;
    public int NumElements;
    public ICppVariableModuleEntity StructuredBindingDeclaration;
    public CppDependentStructuredBindingTypeModuleEntity(ICppExpression initializer, CppQualType autoType, int elementIndex, int numElements, ICppVariableModuleEntity structuredBindingDeclaration);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentStructuredBindingTypeResolveEntity : CppDependentAutoTypeResolveEntity {
    private int myElementIndex;
    private int myNumElements;
    private ICppVariableDeclaratorResolveEntity myStructuredBindingDeclaration;
    public CppDependentStructuredBindingTypeResolveEntity(ICppVariableDeclaratorResolveEntity structuredBindingDeclaration, CppDependentAutoTypeResolveEntity structuredBindingDeclarationAutoType, int elementIndex, int numElements);
    public CppDependentStructuredBindingTypeResolveEntity(ICppVariableDeclaratorResolveEntity structuredBindingDeclaration, ICppExpression innerExpr, CppQualType autoType, int elementIndex, int numElements);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public ICppVariableDeclaratorResolveEntity GetStructuredBindingDeclaration();
    public int GetElementIndex();
    public int GetNumElements();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentSuperLinkageEntity : object {
    public static CppDependentSuperLinkageEntity INSTANCE;
    public CppQualifiedName DebugQualifiedName { get; }
    private static CppDependentSuperLinkageEntity();
    public sealed virtual CppQualifiedName get_DebugQualifiedName();
    public sealed virtual string Present(ICppPresenter _);
    public sealed virtual Result Accept(ICppDependentLinkageEntityVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentTemplateArgument : object {
    private CppDependentResolveEntity myResolveEntity;
    private CppQualifiedName myLookedUpName;
    [CompilerGeneratedAttribute]
private bool <PackExpansion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HadTypename>k__BackingField;
    public bool PackExpansion { get; }
    public bool HadTypename { get; }
    public ICppTemplateArgument Pattern { get; }
    public CppQualifiedName LookedUpName { get; }
    public CppDependentTemplateArgument(CppDependentResolveEntity e, bool isPackExpansion, CppQualifiedName lookedUpName, bool hadTypename);
    [CompilerGeneratedAttribute]
public bool get_PackExpansion();
    [CompilerGeneratedAttribute]
public bool get_HadTypename();
    public ICppTemplateArgument get_Pattern();
    public sealed virtual Result Accept(Data data, ICppTemplateArgumentVisitor`2<Result, Data> visitor);
    public sealed virtual CppQualifiedName get_LookedUpName();
    public CppDependentResolveEntity GetResolveEntity();
    public IEnumerable`1<ICppTemplateArgument> Unpack();
    public virtual string ToString();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public ValueTuple`2<CppList`1<ICppTemplateArgument>, SubstitutionStatus> ExpandGetTemplateArguments(CppSubstitutionDriver substDriver, bool checkSubstitutionFailure);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentUsing : CppCompletionDecoration {
    private bool myGrayed;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    public CppQualifiedNamePart Name { get; }
    public CppDependentUsing(CppQualifiedNamePart name, bool grayed);
    [CompilerGeneratedAttribute]
public virtual CppQualifiedNamePart get_Name();
    public bool IsGrayed();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeprecatedAttributeArgumentsBuilder : object {
    private CppStringLiteralValue myMessageArgument;
    [CanBeNullAttribute]
private CppStringLiteralValue myQuickFixArgument;
    public sealed virtual bool LearnNoArgs(ICppAttributeArgumentsParser parser);
    public sealed virtual bool LearnArgs(ICppAttributeArgumentsParser parser);
    public sealed virtual ICppAttribute GetUnresolvedAttribute(CppAttributeName name);
    public sealed virtual ICppAttribute GetReplacedAttribute(CppAttributeName name);
    private ICppAttribute GetAttribute(CppAttributeName name);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeserializedFromModuleClassSymbol : CppSymbol {
    private CppQualifiedNamePart myName;
    private byte myFlags;
    [CompilerGeneratedAttribute]
private CppFileLocation <ContainingFile>k__BackingField;
    [CompilerGeneratedAttribute]
private CppClassKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private CppClassVirtualSpecifiers <ClassVirtualSpecifiers>k__BackingField;
    public CppFileLocation ContainingFile { get; }
    public CppQualifiedName Name { get; }
    public ICppParserSymbol Parent { get; }
    public CppClassTag Tag { get; }
    public CppClassKey Key { get; }
    public CppClassVirtualSpecifiers ClassVirtualSpecifiers { get; }
    public bool IsFriend { get; }
    public bool IsExplicitInstantiation { get; }
    public bool IsDefinition { get; }
    public CppDeserializedFromModuleClassSymbol(CppSymbolLocation loc, CppQualifiedNamePart name, CppClassVirtualSpecifiers classVirtualSpecifiers, CppClassKey key, byte flags);
    [CompilerGeneratedAttribute]
public virtual CppFileLocation get_ContainingFile();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public sealed virtual CppQualifiedName get_Name();
    public sealed virtual ICppParserSymbol get_Parent();
    public sealed virtual CppClassTag get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual CppClassKey get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual CppClassVirtualSpecifiers get_ClassVirtualSpecifiers();
    public sealed virtual bool Exported();
    public sealed virtual CppSymbolTemplateParametersList ParamList();
    public sealed virtual CppAttributeList Attributes();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual CppModuleAttachment ModuleAttachment();
    public bool get_IsFriend();
    public bool get_IsExplicitInstantiation();
    public bool get_IsDefinition();
    public sealed virtual void SetLazyMergingInfo(CppClassLazyMergingInfo flags);
    public sealed virtual CppClassLazyMergingInfo GetLazyMergingInfo();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDesignatorBuilder : ValueType {
    private CppExpressionBuilder myExpressionBuilder;
    private ICppDesignator myDesignator;
    public CppDesignatorBuilder(CppExpressionBuilder exprBuilder);
    public sealed virtual CppExpressionBuilder CreateExpressionBuilder();
    public sealed virtual void LearnSubscriptDesignator(CppExpressionBuilder& index);
    public sealed virtual void LearnMemAccessDesignator(string name);
    public ICppDesignator GetResult();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDestructorTag : object {
    public static CppDestructorTag ANONYMOUS_CLASS_DESTRUCTOR_TAG;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CanBeNullAttribute]
public string Name { get; }
    public CppDestructorTag(string name);
    private static CppDestructorTag();
    [CompilerGeneratedAttribute]
public string get_Name();
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDoStatementBuilder : CppLoopStatementBuilder`2<CppDoStatementSymbol, CppDoStatementResolveEntity> {
    public CppDoStatementBuilder(ICppBuilder parent, CppSymbolLocation loc);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDoStatementModuleEntity : CppLoopStatementModuleEntity {
    public CppDoStatementModuleEntity(CppLocationAnchor anchor, CppRegularFunctionModuleEntity function);
    public virtual ICppStatementResolveEntity Import(CppScopeResolveEntityBase targetParent, CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDoStatementResolveEntity : CppDoStatementResolveEntityBase {
    private CppResolveEntityCondition myCondition;
    public CppDoStatementResolveEntity(ICppResolveEntity parentScope, CppLocationAnchor location);
    public virtual void SetReplacedCondition(ICppExpression e, CppLocationAnchor location);
    public virtual void SetResolvedCondition(ICppResolvedExpression e);
    public virtual ICppResolvedExpression GetCondition();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDoStatementResolveEntityBase : CppLoopStatementResolveEntityBase {
    public static CppQualifiedId NAME;
    public CppQualifiedNamePart Name { get; }
    protected CppDoStatementResolveEntityBase(ICppResolveEntity parentScope, CppLocationAnchor location);
    private static CppDoStatementResolveEntityBase();
    public virtual CppQualifiedNamePart get_Name();
    public virtual string ToString();
    internal virtual CppFuncEvaluationResult Evaluate(CppExpressionEvaluator evaluator, CppFunctionEvaluationContext functionCtx, CppQualType retType);
    internal virtual CppLoopStatementResolveEntityBase Substitute(ICppScopeResolveEntity parent, CppSubstitutionDriver driver);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDoStatementResolveEntityWithSubstitution : CppDoStatementResolveEntityBase {
    private CppDoStatementResolveEntityBase myInner;
    private CppSubstitutedCondition myCondition;
    public CppDoStatementResolveEntityWithSubstitution(ICppScopeResolveEntity parent, CppDoStatementResolveEntityBase inner, CppSubstitutionDriver driver);
    public virtual ICppResolvedExpression GetCondition();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDoStatementSymbol : CppLoopStatementSymbol {
    public CppDoStatementSymbol(CppSymbolLocation loc);
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDoSubstituteResult : ValueType {
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDoSubstituteResult`1 : ValueType {
    [CanBeNullAttribute]
private R myResult;
    private Status myStatus;
    private CppDoSubstituteResult`1(R r, Status status);
    public static CppDoSubstituteResult`1<R> Ok(R r);
    public static CppDoSubstituteResult`1<R> Null();
    public static CppDoSubstituteResult`1<R> RecursionGuardFail();
    public static CppDoSubstituteResult`1<R> NotCompletelyInstantiatedFail();
    private static CppDoSubstituteResult`1<R> Fail(Status status);
    public bool IsOk();
    public bool IsFail();
    public R GetResult();
    public CppDoSubstituteResult`1<Other> FailWithTheSameStatus();
    public CppDoSubstituteResult`1<Other> As();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDoubleArgumentTypeTraitExpressionBuilder : ValueType {
    private CppQualType myFirstArgument;
    private CppQualType mySecondArgument;
    public sealed virtual void LearnFirstArgument(ICppDeclarationBuilder declBuilder);
    public sealed virtual void LearnSecondArgument(ICppDeclarationBuilder declBuilder);
    public CppQualType GetFirstArgument();
    public CppQualType GetSecondArgument();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDropDecorationsVisitor : object {
    public static CppDropDecorationsVisitor INSTANCE;
    private static CppDropDecorationsVisitor();
    public sealed virtual ICppTemplateArgument Visit(ICppResolvedTypeFactory tf, CppQualifiedReferenceTemplateArgument arg);
    public sealed virtual ICppTemplateArgument Visit(ICppResolvedTypeFactory tf, CppQualType arg);
    public sealed virtual ICppTemplateArgument Visit(ICppResolvedTypeFactory tf, CppTypeTemplateArgument arg);
    public sealed virtual ICppTemplateArgument Visit(ICppResolvedTypeFactory tf, CppTypeTemplateArgumentPack arg);
    public sealed virtual ICppTemplateArgument Visit(ICppResolvedTypeFactory tf, CppExpressionTemplateArgument arg);
    public sealed virtual ICppTemplateArgument Visit(ICppResolvedTypeFactory tf, CppExpressionTemplateArgumentPack arg);
    public sealed virtual ICppTemplateArgument Visit(ICppResolvedTypeFactory tf, CppTemplateTemplateArgument arg);
    public sealed virtual ICppTemplateArgument Visit(ICppResolvedTypeFactory tf, CppTemplateTemplateArgumentPack arg);
    public sealed virtual ICppTemplateArgument Visit(ICppResolvedTypeFactory tf, CppDependentTemplateArgument arg);
    public sealed virtual ICppTemplateArgument Visit(ICppResolvedTypeFactory tf, CppLookupFailureTemplateArgument arg);
    public sealed virtual ICppTemplateArgument Visit(ICppResolvedTypeFactory tf, CppInjectedClassNameTemplateArgument arg);
    public sealed virtual ICppTemplateArgument Visit(ICppResolvedTypeFactory tf, CppExcessiveTemplateArgument arg);
    private static CppQualType ReApply(ICppResolvedTypeFactory tf, CppQualType type);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppDumpResolveEntitiesUtil : object {
    public static string DumpResolveEntitiesPreciseWithoutDetachedData(ICppRootFileResolveEntitiesCache fileCache);
    public static void DumpResolveEntitiesPrecise(ICppRootFileResolveEntitiesCache fileCache, StringBuilder StringBuilder);
    [ExtensionAttribute]
public static void DumpResolveEntity(CppIndentationStringBuilder tw, ICppResolveEntity e);
    private static bool IsRsInternal(ICppResolveEntity e);
    private static void DumpParentsOneLine(CppIndentationStringBuilder tw, ICppResolveEntity e);
    private static void DumpResolveEntityOneLine(CppIndentationStringBuilder tw, ICppResolveEntity e);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppElaboratedReferenceCompletionDecoration : CppCompletionDecoration {
    private ICppClassResolveEntity myInnerResolveEntity;
    public CppQualifiedNamePart Name { get; }
    public CppElaboratedReferenceCompletionDecoration(ICppClassResolveEntity innerResolveEntity);
    public virtual CppQualifiedNamePart get_Name();
    public ICppClassResolveEntity GetInnerResolveEntity();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppEllipsisKind : Enum {
    public byte value__;
    public static CppEllipsisKind None;
    public static CppEllipsisKind Standard;
    public static CppEllipsisKind CliArray;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppEmptyParameterListModuleEntity : CppParameterListModuleEntityBase {
    public CppSmallArray`1<CppFunctionParameterModuleEntity> Parameters { get; }
    public CppEmptyParameterListModuleEntity(ICppScopeModuleEntity parent, byte flags);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual CppSmallArray`1<CppFunctionParameterModuleEntity> get_Parameters();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppEnumBodyBuilder : object {
    [CompilerGeneratedAttribute]
private CppClassBuilder <parent>P;
    public CppClassBuilder ClassBuilder { get; }
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public CppEnumBodyBuilder(CppClassBuilder parent);
    public CppClassBuilder get_ClassBuilder();
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    public sealed virtual void AddChild(CppParserSymbol s);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppEnumData : CppClassOrEnumData {
    protected bool myEnumUnderlyingTypeIsSet;
    protected CppQualType myReplacedEnumUnderlyingType;
    protected CppLocationAnchor myLocationAnchorForUnderlyingType;
    protected CppCachedValue`1<CppQualType> myResolvedEnumUnderlyingType;
    private bool myExported;
    protected CppEnumData(CppQualifiedNamePart name, CppClassKey key);
    protected CppEnumData(CppQualifiedNamePart name, CppClassKey key, CppList`1<ClassPartDescription> parts);
    protected virtual void SetExported();
    public virtual bool Exported();
    protected virtual void DumpBases(CppIndentationStringBuilder sb);
    protected virtual void DumpVirtualSpecifiers(CppIndentationStringBuilder sb);
    protected virtual void DumpSpecialMembers(CppIndentationStringBuilder sb);
    protected virtual void DumpAnonymousClasses(CppIndentationStringBuilder sb);
    protected virtual void DumpFriends(CppIndentationStringBuilder sb);
    protected virtual void SetVirtualSpecifiers(CppClassVirtualSpecifiers specs);
    protected virtual List`1<ICppResolveEntity> CalculateSortedMembers();
    public virtual void ForceImporting();
    protected virtual void MarkAsReadyToImport(CppJournal journal);
    public virtual CppQualType GetEnumUnderlyingType();
    public virtual void SetEnumUnderlyingType(CppQualType replacedType, CppLocationAnchor anchor);
    public virtual void SetResolvedEnumUnderlyingType(CppQualType resolvedType);
    public sealed virtual bool HasFixedEnumUnderlyingType();
    public virtual CppClassVirtualSpecifiers GetClassVirtualSpecifiers();
    public virtual bool HasAbstractSpecifier();
    public virtual bool IsFinal();
    public virtual bool IsSealed();
    public virtual bool IsFinalOrSealed();
    public virtual CppDeclaratorResolveEntityPack GetOrCreateConversions(CppLocationAnchor anchor);
    public virtual CppDeclaratorResolveEntityPack GetOrCreateConstructors(CppLocationAnchor anchor);
    public virtual CppDeclaratorResolveEntityPack GetOrCreateStaticConstructors(CppLocationAnchor anchor);
    public virtual CppDeclaratorResolveEntityPack GetOrCreateDestructors(CppLocationAnchor anchor);
    public virtual CppDeclaratorResolveEntityPack GetOrCreateCliFinalizers(CppLocationAnchor anchor);
    public virtual ICppDeclaratorResolveEntityPack GetConversions();
    public virtual ICppDeclaratorResolveEntityPack GetConstructors();
    public virtual ICppDeclaratorResolveEntityPack GetStaticConstructors();
    public virtual ICppDeclaratorResolveEntityPack GetDestructors();
    public virtual ICppDeclaratorResolveEntityPack GetCliFinalizers();
    public virtual IEnumerable`1<ICppResolveEntity> GetClassConstructors();
    public virtual IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity> GetClassConversions(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual CppConstructorDeclaratorResolveEntityPack EnsureConstructorExists(CppLocationAnchor anchor);
    public virtual void AddFriend(ICppFunctionDeclaratorResolveEntity ent);
    public virtual void AddFriend(ICppTypeTemplateInstantiationResolveEntity ent);
    public virtual void AddFriend(ICppDependentTypeResolveEntity ent);
    public virtual CppSmallList`1<ICppFunctionDeclaratorResolveEntity> GetFriendFunctions(CppQualifiedNamePart name);
    public virtual ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppFunctionDeclaratorResolveEntity>> GetFriendFunctions();
    public virtual CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity> GetFriendClasses(CppQualifiedNamePart name);
    public virtual ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity>> GetFriendClasses();
    public virtual CppSmallList`1<ICppDependentTypeResolveEntity> GetFriendDependentTypes();
    public virtual CppList`1<ICppResolveEntity> GetAggregateMembers();
    public virtual bool HasImmediateVirtualFunctions();
    public virtual bool HasInheritingConstructors();
    public virtual CppBasicBaseDescription`1[] GetBases();
    public virtual CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> GetNonDependentBases();
    public virtual void SetBases(CppList`1<CppBasicBaseDescription`1<CppQualifiedName>> bases);
    public virtual void ResolveBases();
    public virtual void GenerateImplicitDisposableIfNeeded();
    public virtual CppList`1<ICppClassResolveEntity> AnonymousClasses();
    public virtual void AddAnonymousClass(ICppClassResolveEntity ent);
    public virtual CppSmallList`1<ICppDeclaratorResolveEntityPack> GetAnonymousSubclassMembers(CppQualifiedNamePart name);
    public virtual void RegisterAnonymousSubclassMembers(CppList`1<ICppDeclaratorResolveEntityPack> subclasses);
    public virtual bool IsAbstract();
    public virtual bool IsPolymorphic();
    public virtual bool HasVirtualDestructor();
    public virtual bool IsTriviallyCopyable(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool HasTrivialDestructor(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool HasNothrowDestructor(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool IsTrivial(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool IsStandardLayout(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool IsPOD(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual bool HasTrivialConstructor();
    public virtual bool HasUniqueObjectRepresentations(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public sealed virtual void MergeNonMergedSymbols();
    public virtual void Journaling_RollbackCachedClassConstructors();
    private CppQualType CalculateEnumUnderlyingType(ICppScopeResolveEntity lookupParent, ICppResolvedTypeFactory tf);
    private void RevertSymbolMerging();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppEnumeratorModuleEntity : object {
    public CppEnumModuleEntity Parent;
    public CppQualifiedNamePart Name;
    public ICppExpression Initializer;
    private CppComplexOffset myLocation;
    public CppComplexOffset Location { get; }
    public CppEnumeratorModuleEntity(CppEnumModuleEntity parent, CppQualifiedNamePart name, CppEnumeratorSymbol symbol);
    public sealed virtual ICppClassOrRefClassModuleEntity GetParent();
    public sealed virtual bool IsExplicitlyExported();
    public sealed virtual CppQualifiedNamePart GetName();
    private sealed virtual override ICppScopeModuleEntity JetBrains.ReSharper.Psi.Cpp.Symbols.ICppNamespaceModuleEntityChild.GetParent();
    public CppComplexOffset get_Location();
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppEnumeratorResolveEntity : object {
    private ICppClassResolveEntity myEnumScope;
    private CppEnumeratorSymbol mySymbol;
    private CppLocationAnchor myLocationAnchor;
    [CanBeNullAttribute]
private ICppExpression myInitializer;
    [CanBeNullAttribute]
private CppEnumeratorResolveEntity myPreviousEnumerator;
    private CppCachedReference`1<ICppEvaluationResult> myCachedValue;
    private CppDependentInfoCachedValue myCachedDepInfo;
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public bool IsParameterPack { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppEnumeratorResolveEntity(ICppClassResolveEntity enumParent, ICppExpression initializer, CppEnumeratorSymbol sym, CppLocationAnchor anchor, CppEnumeratorResolveEntity previous);
    public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public virtual CppAttributeList get_Attributes();
    public virtual bool get_IsParameterPack();
    public virtual ICppResolveEntityParent get_RealParent();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual ICppClassResolveEntity GetEnumeration();
    public virtual ICppEnumeratorResolveEntity GetPreviousEnumerator();
    public virtual bool HasValueCached();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public sealed virtual bool HasInitializer();
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual ICppEvaluationResult GetValue(ICppEvaluationErrorTracker errorTracker);
    private ICppEvaluationResult CalculateValue(ICppEvaluationErrorTracker errorTracker);
    public virtual CppDependentInfo GetDependentInfo();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public CppEnumeratorSymbol GetSymbol();
    public virtual string ToString();
    private CppDeclaratorInitializer CalculateInitializer(ICppFileResolveEntitiesCache resolveCache);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppEnumeratorResolveEntityWithSubstitution : CppResolveEntityWithSubstitution {
    private CppViewPos myViewPos;
    private ICppEnumeratorResolveEntity myInner;
    private CppCachedReference`1<ICppResolvedExpression> myInitializer;
    private CppCachedReference`1<ICppEvaluationResult> myValue;
    private CppDependentInfoCachedValue myCachedDepInfo;
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public bool IsParameterPack { get; }
    public CppEnumeratorResolveEntityWithSubstitution(ICppClassResolveEntity enumParent, CppViewPos& viewPos, CppQualifiedNamePart name, ICppEnumeratorResolveEntity inner, ICppSubstitutionContext subst);
    public sealed virtual ICppClassResolveEntity GetEnumeration();
    public sealed virtual ICppEnumeratorResolveEntity GetPreviousEnumerator();
    public sealed virtual bool HasValueCached();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public sealed virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public sealed virtual CppAttributeList get_Attributes();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public sealed virtual bool HasInitializer();
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual ICppEvaluationResult GetValue(ICppEvaluationErrorTracker errorTracker);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public CppDependentInfo CalculateDependentInfo();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public sealed virtual bool get_IsParameterPack();
    public ICppEnumeratorResolveEntity GetInner();
    private ICppResolvedExpression CalculateInitializer();
    private ICppEvaluationResult CalculateValue(ICppEvaluationErrorTracker errorTracker);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppEnumeratorSymbol : CppSymbol {
    private ICppExpression myInitializerExpression;
    private CppQualifiedNamePart myNamePart;
    private CppAttributeList myAttributes;
    private ICppParserSymbol myParent;
    public CppQualifiedName Name { get; }
    public CppFileLocation ContainingFile { get; }
    public ICppParserSymbol Parent { get; public set; }
    public CppEnumeratorSymbol(CppQualifiedNamePart namePart, ICppExpression initializerExpression, CppAttributeList attributes, CppComplexOffset loc);
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual CppQualifiedName get_Name();
    public virtual CppFileLocation get_ContainingFile();
    public sealed virtual ICppParserSymbol get_Parent();
    public void set_Parent(ICppParserSymbol value);
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public ICppExpression GetInitializerExpression();
    public CppAttributeList Attributes();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppEnumeratorWithAttributesResolveEntity : CppEnumeratorResolveEntity {
    [CompilerGeneratedAttribute]
private CppAttributeList <Attributes>k__BackingField;
    public CppAttributeList Attributes { get; }
    public CppEnumeratorWithAttributesResolveEntity(ICppClassResolveEntity enumParent, ICppExpression replacedInitializer, CppEnumeratorSymbol sym, CppLocationAnchor anchor, CppEnumeratorResolveEntity previous, CppAttributeList attributes);
    [CompilerGeneratedAttribute]
public virtual CppAttributeList get_Attributes();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppEnumModuleEntity : CppClassOrEnumModuleEntity {
    public CppQualType UnderlyingType;
    public bool HasFixedUnderlyingType;
    public CppEnumeratorModuleEntity[] Children;
    public CppEnumModuleEntity(int index, ICppScopeModuleEntity parent, CppClassKey key, CppAccessibility accessibility, bool exported);
    internal CppEnumModuleEntity(int index);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppEnumResolveEntity : CppEnumData {
    [CompilerGeneratedAttribute]
private ICppResolveEntityParent <RealParent>k__BackingField;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <LocationAnchor>k__BackingField;
    public CppDependentInfo DependentInfo { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppEnumResolveEntity(ICppResolveEntityParent parent, CppQualifiedNamePart name, CppClassKey key, CppLocationAnchor anchor);
    public virtual void AddSymbolsForLateMerging(CppList`1<ICppSymbol> syms, CppLocationAnchor anchorOfFirstSymbol);
    public sealed virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public sealed virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public sealed virtual CppDependentInfo get_DependentInfo();
    public virtual void AddChild(ICppResolveEntity ent);
    public sealed virtual void RemoveChild(ICppResolveEntity ent);
    [CompilerGeneratedAttribute]
public sealed virtual ICppResolveEntityParent get_RealParent();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    [CompilerGeneratedAttribute]
public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public void Dump(CppIndentationStringBuilder tw);
    public virtual string ToString();
    public virtual ICppMutableClassResolveEntity GetThat();
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
private void AssertNotFrozen();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppEnumResolveEntityWithSubstitutionDefinitionState : CppEnumData {
    private ICppMutableClassResolveEntity myThat;
    private CppLocationAnchor myAnchor;
    public CppEnumResolveEntityWithSubstitutionDefinitionState(ICppMutableClassResolveEntity that, CppClassKey key, CppLocationAnchor anchor);
    public CppEnumResolveEntityWithSubstitutionDefinitionState(ICppMutableClassResolveEntity that, CppClassKey key, CppLocationAnchor anchor, CppList`1<ClassPartDescription> parts);
    public sealed virtual CppInstantiationStatus StateInstantiate();
    public sealed virtual bool InstantiationInProgress();
    public sealed virtual Nullable`1<CppViewPos> PointOfInstantiation();
    public sealed virtual ICppClassResolveEntity GetRawDefinition();
    public sealed virtual void Dump(CppIndentationStringBuilder tw);
    public sealed virtual CppLocationAnchor GetLocationAnchor();
    public sealed virtual CppDefaultedSpecialMembers GetTemplateDefaultedSpecialMembers();
    public sealed virtual ICppGroupedFunctionDeclaratorResolveEntity FindSubstitutionForCurrentlySubstituted(ICppGroupedFunctionDeclaratorResolveEntity e);
    public virtual ICppMutableClassResolveEntity GetThat();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppEnumWithBaseSymbol : CppScopeSymbol {
    private CppAccessibility myAccessibility;
    private CppClassKey myKey;
    private bool myExport;
    private CppModuleAttachment myModuleAttachment;
    private CppSymbolTemplateParametersList myParamList;
    private CppAttributeList myAttributes;
    private CppComplexOffset myBodyEndOffset;
    private CppComplexOffset myBodyStartOffset;
    private CppClassLazyMergingInfo myLazyMergingFlags;
    private CppQualType myQualType;
    public CppClassTag Tag { get; }
    public CppClassKey Key { get; }
    public CppClassVirtualSpecifiers ClassVirtualSpecifiers { get; }
    public CppEnumWithBaseSymbol(CppQualifiedName name, CppSymbolTemplateParametersList paramList, CppAttributeList attributes, CppSymbolLocation loc, CppClassKey key, CppAccessibility accessibility, bool export, CppModuleAttachment moduleAttachment, CppQualType underlyingType);
    public sealed virtual CppSymbolTemplateParametersList ParamList();
    public sealed virtual CppAttributeList Attributes();
    public sealed virtual CppClassTag get_Tag();
    public sealed virtual CppClassKey get_Key();
    public sealed virtual CppClassVirtualSpecifiers get_ClassVirtualSpecifiers();
    public sealed virtual void SetLazyMergingInfo(CppClassLazyMergingInfo flags);
    public sealed virtual CppClassLazyMergingInfo GetLazyMergingInfo();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool Exported();
    public sealed virtual CppModuleAttachment ModuleAttachment();
    public virtual TResult Accept(ICppSymbolVisitor`1<TResult> visitor);
    public sealed virtual bool IsAnonymousClass();
    public sealed virtual void SetBodyStartOffset(CppComplexOffset offset);
    public sealed virtual CppComplexOffset GetBodyStartOffset();
    public sealed virtual void SetBodyEndOffset(CppComplexOffset offset);
    public sealed virtual CppComplexOffset GetBodyEndOffset();
    public CppQualType GetUnderlyingType();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExceptionSpecificationBuilder : object {
    private ICppExceptionSpecification myUnresolvedExceptionSpecification;
    private ICppExceptionSpecification myReplacedExceptionSpecification;
    public sealed virtual void LearnThrowAnySpecification();
    public sealed virtual void LearnNoExceptSpecification();
    public sealed virtual void LearnNoExceptSpecification(CppTwinExpressionBuilder& exprBuilder);
    public sealed virtual ICppDeclarationBuilder CreateDeclarationBuilderForDynamicExceptionSpecification(ICppBuilder parent, bool isDetectionMode);
    public sealed virtual void LearnDynamicExceptionSpecification();
    public sealed virtual void LearnDynamicExceptionSpecificationElement(ICppDeclarationBuilder builder, bool isPackExpansion);
    public sealed virtual ICppExceptionSpecification GetUnresolvedExceptionSpecification();
    public sealed virtual ICppExceptionSpecification GetReplacedExceptionSpecification();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExcessiveTemplateArgument : object {
    [CompilerGeneratedAttribute]
private ICppTemplateArgument <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PackExpansion>k__BackingField;
    public ICppTemplateArgument Inner { get; }
    public bool PackExpansion { get; }
    public CppExcessiveTemplateArgument(ICppTemplateArgument inner);
    [CompilerGeneratedAttribute]
public ICppTemplateArgument get_Inner();
    [CompilerGeneratedAttribute]
public bool get_PackExpansion();
    public sealed virtual Result Accept(Data data, ICppTemplateArgumentVisitor`2<Result, Data> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpansionContext : object {
    public int Index;
    private ICppSubstitutionMapping myExpansionMapping;
    public CppSubstitutionContext Prototype;
    public CppExpansionContext(CppSubstitutionContext proto, int index, int capacity);
    public sealed virtual bool TryGetSubstitution(CppTemplateParameterTag tag, ICppTemplateArgument& a);
    public sealed virtual bool ContainsSubstitutionFor(CppTemplateParameterTag p);
    public sealed virtual bool TryGetExpansion(CppTemplateParameterTag tag, ICppTemplateArgument& a);
    public sealed virtual bool ContainsExpansionFor(CppTemplateParameterTag p);
    public sealed virtual ICppSubstitutionContext ReplaceTags(CppTemplateParametersBase old, CppTemplateParametersBase new_);
    public sealed virtual CppSubstitutionContext Reinstate();
    public void AddExpansion(CppTemplateParameterTag p, ICppTemplateArgument a);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExportBlockBuilder : CppTopLevelBlockBuilder {
    private CppExportBlockSymbol mySymbol;
    public CppExportBlockBuilder(ICppBuilder parent);
    protected virtual CppTopLevelBlockSymbol GetSymbol();
    public void LearnSymbolLocation(CppSymbolLocation location);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExportBlockSymbol : CppTopLevelBlockSymbol {
    public CppExportBlockSymbol(CppSymbolLocation loc);
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionBuilder : ValueType {
    private ICppExpression myExpr;
    private bool myCreateSymbols;
    public CppExpressionBuilder(bool createSymbols);
    public ICppExpression GetExpression();
    public sealed virtual CppExpressionBuilder CreateInnerExpressionBuilder();
    public sealed virtual ICppDeclarationBuilder CreateInnerDeclarationBuilder(ICppBuilder parent);
    public sealed virtual CppQualifiedNameBuilder CreateInnerQualifiedNameBuilder();
    public sealed virtual CppFunctionArgumentListBuilder CreateInnerFunctionArgumentListBuilder();
    public sealed virtual CppDesignatorBuilder CreateDesignatorBuilder();
    public sealed virtual CppC11GenericExpressionBuilder CreateC11GenericExpressionBuilder();
    public sealed virtual void LearnEmptyExpression();
    public sealed virtual void ApplyThrowOperator();
    public sealed virtual void ApplyCStyleCast(ICppDeclarationBuilder declBuilder);
    public sealed virtual void ApplyUnaryOperator(TokenNodeType tok);
    public sealed virtual void ApplyMSAssume();
    public sealed virtual void LearnSizeOfExpression(ICppDeclarationBuilder builder);
    public sealed virtual void LearnSizeOfEllipsisExpression(CppQualifiedNameBuilder& nameBuilder);
    public sealed virtual void ApplySizeOf();
    public sealed virtual void LearnAlignOfExpression(ICppDeclarationBuilder builder);
    public sealed virtual void ApplyAlignOf();
    public sealed virtual void LearnMSUuidOfExpression(ICppDeclarationBuilder builder);
    public sealed virtual void ApplyMSUuidOf();
    public sealed virtual void LearnMSEventHookExpression(bool unhook, CppFunctionArgumentListBuilder& builder);
    public sealed virtual void ApplyNoExcept();
    public sealed virtual void ApplyBuiltinAddressOf();
    public sealed virtual void ApplyGnuBuiltinConstantP();
    public sealed virtual void LearnBuiltinOffsetOf(CppBuiltinOffsetOfBuilder offsetOfBuilder);
    public sealed virtual void LearnNewExpression(CppNewExpressionBuilder builder);
    public sealed virtual void ApplyDeleteOperator(bool isArrayKind);
    public sealed virtual void LearnSingleArgumentTypeTraitExpression(ICppDeclarationBuilder argumentTypeId, TokenNodeType kwToken);
    public sealed virtual void LearnDoubleArgumentTypeTraitExpression(CppDoubleArgumentTypeTraitExpressionBuilder builder, TokenNodeType kwToken);
    public sealed virtual void LearnMultiArgumentTypeTraitExpression(CppMultiArgumentTypeTraitExpressionBuilder builder, TokenNodeType kwToken);
    public sealed virtual void ApplyCast(TokenNodeType tt, ICppDeclarationBuilder declBuilder);
    public sealed virtual void LearnTypeIdExpression(ICppDeclarationBuilder builder);
    public sealed virtual void ApplyTypeId();
    public sealed virtual void ApplyParen();
    public sealed virtual void LearnQualifiedReferenceExpression(CppQualifiedNameBuilder& qualNameBuilder);
    public sealed virtual void LearnQualifiedReferenceExpression(CppTwinQualifiedNameBuilder& qualNameBuilder);
    public sealed virtual void ApplyPostfixOperator(TokenNodeType tt);
    public sealed virtual void ApplyDotOperator(TokenNodeType tt, CppQualifiedNameBuilder& name);
    public sealed virtual void ApplySubscriptionOperator(CppExpressionBuilder exprBuilder, bool isPackExpansion);
    public sealed virtual void ApplyMultiArgumentSubscriptionOperator(CppFunctionArgumentListBuilder& argListBuilder, bool cli);
    public sealed virtual void LearnCliTypeId(CppQualifiedNameBuilder& nameBuilder);
    public sealed virtual void ApplyBinaryOperator(CppOperatorKind kind, CppExpressionBuilder& exprBuilder);
    public sealed virtual void ApplyConditionalOperator(CppExpressionBuilder& secondArgumentBuilder, CppExpressionBuilder& thirdArgumentBuilder, CppConditionalExprKind kind);
    public sealed virtual void ApplyGnuBuiltinChooseExpr(CppFunctionArgumentListBuilder& argBuilder);
    public sealed virtual void ApplyUnaryLeftFoldExpression(CppOperatorKind kind);
    public sealed virtual void ApplyUnaryRightFoldExpression(CppOperatorKind kind);
    public sealed virtual void ApplyBinaryFoldExpression(CppOperatorKind kind, CppExpressionBuilder& exprBuilder);
    public sealed virtual void LearnLambdaExpression(CppLambdaBuilder builder);
    public sealed virtual void LearnRequiresExpression(CppRequiresExpressionBuilder builder);
    public sealed virtual void LearnC11GenericExpression(CppC11GenericExpressionBuilder& builder);
    public sealed virtual void LearnGnuStatementExpression(CppCompoundStatementInExpressionBuilder builder);
    public sealed virtual bool LearnLiteral(TokenNodeType tt, string text, CppLanguageDialect dialect);
    public sealed virtual bool LearnStringLiteral(CppStringLiteralBuilder& builder);
    public sealed virtual void LearnThis();
    public sealed virtual void LearnMSNoopExpression();
    public sealed virtual void LearnGNUAddressOfLabelExpression(string labelName);
    public sealed virtual void ApplyCallOperator(CppFunctionArgumentListBuilder& builder);
    public sealed virtual void LearnCallToTypeId(CppUnresolvedDeclarationSpecifierTypeBuilder typeBuilder, CppFunctionArgumentListBuilder& argBuilder);
    public sealed virtual void LearnBracedInitializedTypeId(CppUnresolvedDeclarationSpecifierTypeBuilder typeBuilder, CppFunctionArgumentListBuilder& argBuilder);
    public sealed virtual void LearnBracedInitializedTypeIdDecl(ICppDeclarationBuilder declBuilder, CppFunctionArgumentListBuilder& argBuilder);
    public sealed virtual void ApplyBracedInitializer(CppFunctionArgumentListBuilder& argBuilder);
    public sealed virtual void LearnBracedInitList(CppFunctionArgumentListBuilder& builder);
    public void ApplyPackExpansion();
    public sealed virtual void ApplyCoAwaitExpression();
    public sealed virtual void ApplyCoYieldExpression();
    public sealed virtual void LearnDesignation(CppDesignatorBuilder& designator, CppExpressionBuilder& initializer, InitializerKind kind);
    public CppExpressionBuilder CreateExpressionBuilder(bool createSymbols);
    public sealed virtual CppQualifiedNameBuilder CreateQualifiedNameBuilder();
    public sealed virtual CppStringLiteralBuilder CreateStringLiteralBuilder();
    public sealed virtual CppFunctionArgumentListBuilder CreateFunctionArgumentListBuilder(bool createSymbols);
    public sealed virtual CppNewExpressionBuilder CreateNewExpressionBuilder();
    public sealed virtual CppDoubleArgumentTypeTraitExpressionBuilder CreateDoubleArgumentTypeTraitExpressionBuilder();
    public sealed virtual CppMultiArgumentTypeTraitExpressionBuilder CreateMultiArgumentTypeTraitExpressionBuilder();
    public sealed virtual CppBuiltinOffsetOfBuilder CreateBuiltinOffsetOfBuilder();
    public sealed virtual ICppExpression GetExpressionForLookup();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionStatementBuilder : ValueType {
    private CppComplexOffset myLocation;
    private ICppScopeStatementBuilder myParent;
    public CppExpressionStatementBuilder(CppComplexOffset loc, ICppScopeStatementBuilder parentBuilder);
    public void Learn(CppTwinExpressionBuilder& exprBuilder);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionStatementModuleEntity : CppStatementModuleEntityBase {
    private ICppExpression myArgument;
    public CppExpressionStatementModuleEntity(ICppExpression argument, CppLocationAnchor anchor);
    public virtual ICppStatementResolveEntity Import(CppScopeResolveEntityBase targetParent, CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionStatementResolveEntity : CppExpressionStatementResolveEntityBase {
    private ICppExpression myReplacedExpression;
    private CppCachedReference`1<ICppResolvedExpression> myResolvedExpression;
    public CppExpressionStatementResolveEntity(ICppScopeResolveEntity parent, ICppExpression replacedExpression, CppLocationAnchor location);
    public CppExpressionStatementResolveEntity(ICppScopeResolveEntity parent, ICppResolvedExpression resolvedExpression, CppLocationAnchor location);
    public virtual ICppResolvedExpression GetExpression();
    private ICppResolvedExpression CalculateExpression();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionStatementResolveEntityBase : object {
    private static CppQualifiedNamePart ourName;
    protected ICppScopeResolveEntity myParent;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <LocationAnchor>k__BackingField;
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    protected CppExpressionStatementResolveEntityBase(ICppScopeResolveEntity parent, CppLocationAnchor location);
    private static CppExpressionStatementResolveEntityBase();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    [CompilerGeneratedAttribute]
public virtual CppLocationAnchor get_LocationAnchor();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public abstract virtual ICppResolvedExpression GetExpression();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionStatementResolveEntityWithSubstitution : CppExpressionStatementResolveEntityBase {
    private CppExpressionStatementResolveEntityBase myInner;
    private CppSubstitutionDriver myDriver;
    private CppCachedReference`1<ICppResolvedExpression> myCachedExpression;
    public CppExpressionStatementResolveEntityWithSubstitution(ICppScopeResolveEntity parent, CppExpressionStatementResolveEntityBase inner, CppSubstitutionDriver driver);
    public virtual ICppResolvedExpression GetExpression();
    private ICppResolvedExpression CalculateExpression();
    public void SubstituteExpressionIfItContainsLambda();
    private ICppResolvedExpression CalculateInnerExpression(ICppResolvedExpression innerExpression);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionStatementSymbol : CppParserSymbol {
    private static CppQualifiedName NAME;
    public ICppExpression Expression;
    public CppExpressionStatementSymbol(CppComplexOffset loc, ICppExpression expression);
    private static CppExpressionStatementSymbol();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionTemplateArgument : object {
    private ICppExpression myExpression;
    public CppExpressionTemplateArgument(ICppExpression expr);
    public sealed virtual IEnumerable`1<CppExpressionTemplateArgument> UnpackExprArgs();
    public sealed virtual Result Accept(Data data, ICppTemplateArgumentVisitor`2<Result, Data> visitor);
    [DebuggerStepThroughAttribute]
public ICppExpression GetExpression();
    public sealed virtual ICppTemplateArgument Import(CppModuleImportingContext ctx);
    public sealed virtual CppModuleTemplateArgumentKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual string ToString();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionTemplateArgumentPack : CppTemplateArgumentPackBase`1<CppExpressionTemplateArgument> {
    public CppList`1<CppExpressionTemplateArgument> Packed { get; }
    public CppExpressionTemplateArgumentPack(CppExpressionTemplateArgument[] packed);
    public CppList`1<CppExpressionTemplateArgument> get_Packed();
    public sealed virtual IEnumerable`1<CppExpressionTemplateArgument> UnpackExprArgs();
    public virtual Result Accept(Data data, ICppTemplateArgumentVisitor`2<Result, Data> visitor);
    public virtual ICppTemplateArgumentPack Clone();
    public virtual ICppTemplateArgument MakeInvalidElement();
    public virtual ICppTemplateArgumentPack New(int cardinality);
    public virtual string ToString();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionTemplateParameter : CppSimpleExpressionTemplateParameterBase {
    private ICppExpression myUnresolvedDefault;
    public bool IsParameterPack { get; }
    public CppExpressionTemplateParameter(CppExpressionTemplateParameterSymbol sym, CppViewPos& viewPos, CppQualType replacedType);
    public virtual ICppResolvedExpression DoExpressionTemplateParameterSubstitution(CppSubstitutionDriver substDriver);
    public virtual ICppTemplateArgument GetDefault(ICppResolvedTypeFactory tf);
    public virtual bool get_IsParameterPack();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public void SetDefault(ICppExpression e);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionTemplateParameterBase : object {
    private ICppAnyExpressionTemplateParameterSymbol mySymbol;
    private CppDependentInfoCachedValue myCachedDepInfo;
    protected CppTemplateParameterTag myTag;
    protected CppViewPos myViewPos;
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public bool IsParameterPack { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    protected CppExpressionTemplateParameterBase(ICppAnyExpressionTemplateParameterSymbol sym, CppViewPos& viewPos);
    public virtual ICppFileResolveEntitiesCache GetResolveCache();
    public virtual CppViewPos GetViewPos();
    public virtual CppTemplateParameterTag GetTag();
    public virtual void ReplaceTag(CppTemplateParameterTag tag);
    public virtual bool IsConcept();
    public virtual bool IsInvented();
    public virtual ICppResolvedExpression GetResolvedConceptExpression();
    public virtual bool NameEquals(CppQualifiedNamePart name);
    public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public virtual CppAttributeList get_Attributes();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual bool HasInitializer();
    public virtual CppDependentInfo GetDependentInfo();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public abstract virtual bool get_IsParameterPack();
    public virtual ICppResolveEntityParent get_RealParent();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public virtual ICppSymbol GetSymbol();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    public abstract virtual ICppResolvedExpression DoExpressionTemplateParameterSubstitution(CppSubstitutionDriver substDriver);
    public virtual ICppTemplateArgument GetDefault(ICppResolvedTypeFactory tf);
    public abstract virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public abstract virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionTemplateParameterDeclarationBuilder : CppForwardingBuilder {
    private ICppDeclaratorBuilder myLastDeclaratorBuilder;
    private ICppUnresolvedDeclarationSpecifierTypeBuilder myUnresolvedSpecifierTypeBuilder;
    private ICppResolvedDeclarationSpecifierTypeBuilder myReplacedSpecifierTypeBuilder;
    private CppDeclarationSpecifiers myDeclSpecifiers;
    public ICppDeclaratorBuilder LastDeclaratorBuilder { get; }
    public CppClassBuilder ClassBuilder { get; }
    public ICppAttributeListBuilder AttributeListBuilder { get; }
    public CppExpressionTemplateParameterDeclarationBuilder(ICppBuilder parent);
    public sealed virtual CppTemplateDeclarationBuilder TemplateDeclarationBuilder();
    public sealed virtual ICppDeclaratorBuilder get_LastDeclaratorBuilder();
    public sealed virtual ICppUnresolvedDeclarationSpecifierTypeBuilder GetUnresolvedSpecifierTypeBuilder();
    public sealed virtual ICppResolvedDeclarationSpecifierTypeBuilder GetReplacedSpecifierTypeBuilder();
    public sealed virtual ICppAttributeListBuilder CreateAttributesBuilder();
    public sealed virtual ICppCallingConventionBuilder CreateCallingConventionBuilder();
    public sealed virtual ICppStructuredBindingDeclarationBuilder CreateStructuredBindingBuilder();
    public sealed virtual CppClassBuilder get_ClassBuilder();
    public sealed virtual ICppAttributeListBuilder get_AttributeListBuilder();
    public sealed virtual void FinishDeclaration();
    public sealed virtual void LearnSpecifier(TokenNodeType tt);
    public sealed virtual void LearnDeclspecProperty();
    public sealed virtual void LearnDecltypeAuto();
    public sealed virtual void LearnAttributes(ICppAttributeListBuilder _);
    public sealed virtual void LearnCallingConvention(ICppCallingConventionBuilder ccBuilder);
    public sealed virtual void LearnClassSpecifier(CppClassBuilder classBuilder);
    public sealed virtual void ApplyImplicitIntType();
    public sealed virtual bool IsStandalone();
    public sealed virtual bool HasImplicitIntType();
    public sealed virtual CppDeclarationSpecifiers GetSpecifiers();
    public sealed virtual ICppDeclaratorBuilder NewDeclaratorBuilder();
    public sealed virtual ICppConceptDefinitionBuilder NewConceptDefinitionBuilder();
    public sealed virtual bool NeedTypename();
    public sealed virtual void LearnExplicitSpecifier();
    public sealed virtual void LearnExplicitSpecifier(CppTwinExpressionBuilder& exprBuilder);
    public sealed virtual void LearnExport();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionTemplateParameterDeclaratorBuilder : object {
    private CppExpressionTemplateParameterDeclarationBuilder myParent;
    private CppUnresolvedTypeBuilder myUnresolvedTypeBuilder;
    private CppResolvedTypeBuilder myReplacedTypeBuilder;
    private CppSymbolLocation myLocation;
    private CppQualifiedName myUnresolvedName;
    private CppQualifiedName myReplacedName;
    private ICppExpressionTemplateParameterSymbol mySymbol;
    private ICppExpressionTemplateParameterOrPack myEntity;
    private bool myParameterPack;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public ICppDeclaratorSymbol Symbol { get; }
    public bool HasSymbol { get; }
    public bool IsParameterPackDeclarator { get; }
    public CppExpressionTemplateParameterDeclaratorBuilder(CppExpressionTemplateParameterDeclarationBuilder parent);
    public sealed virtual void AddChild(CppParserSymbol _);
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    public sealed virtual ICppDeclaratorBuilder GetDeclaratorBuilder();
    public sealed virtual ICppDeclarationBuilder GetDeclarationBuilder();
    public ICppBuilder CreateInitDeclaratorBuilder();
    public sealed virtual ICppAttributeListBuilder CreateAttributesBuilder();
    public sealed virtual ICppCallingConventionBuilder CreateCallingConventionBuilder();
    public sealed virtual ICppUnresolvedTypeBuilder GetUnresolvedTypeBuilder();
    public sealed virtual ICppResolvedTypeBuilder GetReplacedTypeBuilder();
    public sealed virtual void ComposeSymbolType(CppSymbolLocation _);
    public sealed virtual void LearnLocation(CppSymbolLocation location);
    public void LearnQualifiedName(CppTwinQualifiedNameBuilder& twinBuilder);
    public sealed virtual void LearnQualifiedName(ICppStructuredBindingDeclarationBuilder nameBuilder);
    public sealed virtual void LearnInitializer(KIND kind, CppSmallArray`1<ICppExpression> unresolvedArguments, CppSmallArray`1<ICppExpression> replacedArguments);
    public sealed virtual void LearnMainParameterList(ICppFunctionParameterListBuilder _);
    public sealed virtual void LearnFunctionBody(CppDeclarationTrailingKind kind);
    public sealed virtual void LearnPureVirtualSpecifier(CppPureVirtualSpecifiers _);
    public sealed virtual void LearnEllipsis();
    public sealed virtual void LearnAttributes(ICppAttributeListBuilder _);
    public sealed virtual void LearnNoAttributes();
    public sealed virtual void LearnBitfieldSize(ICppExpression unresolvedSize, ICppExpression replacedSize);
    public void LearnCxxCliOverrideSpecifier(CppTwinQualifiedNameBuilder& _);
    public sealed virtual void LearnRequiresClause(ICppExpression unresolved, ICppExpression replaced);
    public sealed virtual ICppFunctionParameterListBuilder CreateParameterListBuilder();
    public sealed virtual ICppFunctionParameterListBuilder GetMainParameterListBuilder();
    public sealed virtual ICppDeclaratorSymbol get_Symbol();
    public sealed virtual bool get_HasSymbol();
    public sealed virtual bool get_IsParameterPackDeclarator();
    public ICppExpressionTemplateParameterSymbol GetSymbol();
    public ICppExpressionTemplateParameterOrPack GetEntity();
    private sealed virtual override void JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorBuilder.LearnQualifiedName(CppTwinQualifiedNameBuilder& modreq(System.Runtime.InteropServices.InAttribute) _);
    private sealed virtual override void JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorBuilder.LearnCxxCliOverrideSpecifier(CppTwinQualifiedNameBuilder& modreq(System.Runtime.InteropServices.InAttribute) _);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionTemplateParameterPack : CppSimpleExpressionTemplateParameterBase {
    public bool IsParameterPack { get; }
    public CppExpressionTemplateParameterPack(CppExpressionTemplateParameterPackSymbol sym, CppViewPos& viewPos, CppQualType replacedType);
    public virtual ICppResolvedExpression DoExpressionTemplateParameterSubstitution(CppSubstitutionDriver substDriver);
    public virtual bool get_IsParameterPack();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual ICppTemplateArgumentPack CreateEmptyMatchingArgumentPack();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionTemplateParameterPackSymbol : CppExpressionTemplateParameterSymbolBase {
    public CppExpressionTemplateParameterPackSymbol(CppQualifiedName name, CppSymbolLocation loc, CppQualType type);
    public virtual ICppTemplateArgument GetDefault();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual bool IsParameterPack();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionTemplateParameterPackWithSubstitution : CppExpressionTemplateParameterWithSubstitutionBase`1<ICppExpressionTemplateParameterPack> {
    public bool IsParameterPack { get; }
    public CppExpressionTemplateParameterPackWithSubstitution(ICppExpressionTemplateParameterPack inner, CppViewPos& pointOfInstantiation, ICppSubstitutionContext subst, CppQualType resolvedType);
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual bool get_IsParameterPack();
    public virtual ICppResolvedExpression DoExpressionTemplateParameterSubstitution(CppSubstitutionDriver substDriver);
    public sealed virtual ICppTemplateArgumentPack CreateEmptyMatchingArgumentPack();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionTemplateParameterSymbol : CppExpressionTemplateParameterSymbolBase {
    private CppExpressionTemplateArgument myDefault;
    public CppExpressionTemplateParameterSymbol(CppQualifiedName name, CppSymbolLocation loc, CppQualType type);
    public virtual bool IsParameterPack();
    public virtual ICppTemplateArgument GetDefault();
    public void SetDefault(CppExpressionTemplateArgument arg);
    public ICppExpression GetDefaultExpression();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionTemplateParameterSymbolBase : CppParameterSymbolBase {
    private CppQualifiedName myName;
    [CompilerGeneratedAttribute]
private CppQualType <Type>k__BackingField;
    public CppQualType RawType { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppQualType Type { get; }
    public CppQualifiedName Name { get; }
    public CppQualifiedNamePart NamePart { get; }
    public bool IsExplicitInstantiation { get; }
    protected CppExpressionTemplateParameterSymbolBase(CppQualifiedName name, CppSymbolLocation loc, CppQualType type);
    public virtual CppQualType get_RawType();
    public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public virtual CppSymbolTemplateParametersList ParamList();
    public virtual CppAttributeList Attributes();
    public virtual CppSmallList`1<CppQualifiedName> CxxCliOverrideSpecifiers();
    public virtual ICppExpression GetRequiresClause();
    [CompilerGeneratedAttribute]
public virtual CppQualType get_Type();
    public virtual CppQualifiedName get_Name();
    public virtual CppQualifiedNamePart get_NamePart();
    public virtual CppDeclarationTrailingKind GetDeclarationTrailingKind();
    public virtual CppAccessibility GetAccessibility();
    public virtual bool IsFunction();
    public abstract virtual bool IsParameterPack();
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual CppCompoundStatementSymbol GetFunctionBody();
    public virtual bool get_IsExplicitInstantiation();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionTemplateParameterWithSubstitution : CppExpressionTemplateParameterWithSubstitutionBase`1<ICppExpressionTemplateParameter> {
    public bool IsParameterPack { get; }
    public CppExpressionTemplateParameterWithSubstitution(ICppExpressionTemplateParameter inner, CppViewPos& pointOfInstantiation, ICppSubstitutionContext subst, CppQualType resolvedType);
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual bool get_IsParameterPack();
    public virtual ICppResolvedExpression DoExpressionTemplateParameterSubstitution(CppSubstitutionDriver substDriver);
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExpressionTemplateParameterWithSubstitutionBase`1 : CppTemplateParameterWithSubstitutionBase`1<Inner> {
    private CppQualType myResolvedType;
    private CppDependentInfoCachedValue myCachedDepInfo;
    public ICppResolveEntityParent RealParent { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public bool IsParameterPack { get; }
    protected CppExpressionTemplateParameterWithSubstitutionBase`1(Inner inner, CppViewPos& pointOfInstantiation, ICppSubstitutionContext subst, CppQualType resolvedType);
    public virtual ICppResolveEntityParent get_RealParent();
    public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public virtual CppAttributeList get_Attributes();
    public abstract virtual bool get_IsParameterPack();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public virtual CppDependentInfo GetDependentInfo();
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual bool HasInitializer();
    public virtual string ToString();
    public abstract virtual ICppResolvedExpression DoExpressionTemplateParameterSubstitution(CppSubstitutionDriver substDriver);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppExtendedReferentialClassOrEnumModuleEntity : CppReferentialClassOrEnumModuleEntity {
    public ICppClassModuleEntityChild[] CustomChildren;
    public CppExtendedReferentialClassOrEnumModuleEntity(ICppClassOrRefClassModuleEntity parent, CppSmallArray`1<ICppModuleTemplateArgument> templargs);
    public virtual CppModuleEntityKind Kind();
    public virtual CppImportResult`1<ICppClassResolveEntity> Import(CppModuleImportingContext ctx, ICppScopeResolveEntity targetParent, bool onlyFindExisting, bool addToParentScope);
    protected virtual CppImportResult`1<ICppClassResolveEntity> ImportPrimaryTemplate(CppModuleImportingContext ctx, ICppScopeResolveEntity targetParent, bool onlyFindExisting, bool addToParentScope);
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFailedSpecializationResolveEntity : CppUndeterminedSpecializationResolveEntity {
    private ICppResolvedExpression myFailedConstraint;
    private CppViewPos myViewPos;
    public CppFailedSpecializationResolveEntity(CppClassTemplateResolveEntityPack pack, CppClassInstantiationKey instantiationKey, CppDependentInfo depInfo, ICppResolvedExpression constraint, CppViewPos& viewPos);
    public virtual bool HasSubstitutionFailure();
    public sealed virtual ICppResolvedExpression GetFailedConstraint();
    public CppTypeContext GetConstraintTypeContext();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFileResolveEntitiesCache : CppFileResolveEntitiesCacheBase {
    private int myCurrentAnchor;
    private int myCurrentPPAnchor;
    private CppResolveEntitiesDetachedData myDetachedData;
    private CppLanguageDialect myDialect;
    private long myVersion;
    private CppJournal myCurrentJournal;
    private ICppPerfEventAccumulator myPerfEvents;
    private Dictionary`2<ICppResolveEntity, LinkageEntityData> myResolveToLinkageEntityMap;
    private int myResolveToLinkageEntityMapVersion;
    private CppMergeSymbolActions myMergeSymbolActions;
    private Dictionary`2<CppModuleDescriptor, CppModuleImportingContext> myImportedModules;
    [CompilerGeneratedAttribute]
private bool <AllowPendingActions>k__BackingField;
    [CompilerGeneratedAttribute]
private CppPPUsagesCollection <PPUsageEngine>k__BackingField;
    [CompilerGeneratedAttribute]
private CppSymbolLocator <SymbolLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private CppGlobalNamespaceResolveEntity <GlobalNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppResolvedTypeFactory <TypeFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppResolvedTypeFactory <VerboseTypeFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppResolvedTypeFactory <VerboseNormalizingTypeFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private CppFileLocation <SourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private CppResolveMutex <ResolveMutex>k__BackingField;
    [CompilerGeneratedAttribute]
private CppRootInclusionContext <InclusionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private CppGlobalSymbolCache <GlobalCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUESolution>k__BackingField;
    [CompilerGeneratedAttribute]
private CppUE4Version <UEVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private CppModuleId <CurrentModule>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ClassInstantiationsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private CppComparisonCategories <ComparisonCategories>k__BackingField;
    public CppLocationAnchor CurrentAnchor { get; }
    public CppPPLocationAnchor CurrentPPAnchor { get; }
    public bool AllowPendingActions { get; }
    public CppPPUsagesCollection PPUsageEngine { get; }
    public CppSymbolLocator SymbolLocator { get; public set; }
    public CppGlobalNamespaceResolveEntity GlobalNamespace { get; }
    public ICppResolvedTypeFactory TypeFactory { get; }
    public ICppResolvedTypeFactory VerboseTypeFactory { get; }
    public ICppResolvedTypeFactory VerboseNormalizingTypeFactory { get; }
    public CppFileLocation SourceFile { get; }
    public ICppRootFileResolveEntitiesCache RootCache { get; }
    public CppResolveMutex ResolveMutex { get; }
    public CppRootInclusionContext InclusionContext { get; }
    public CppGlobalSymbolCache GlobalCache { get; }
    public ISymbolScope ClrScope { get; }
    public bool IsUESolution { get; }
    public CppUE4Version UEVersion { get; }
    public CppModuleId CurrentModule { get; private set; }
    public int ClassInstantiationsCount { get; public set; }
    public CppComparisonCategories ComparisonCategories { get; }
    public CppFileResolveEntitiesCache(CppGlobalSymbolCache cache, CppRootInclusionContext context, CppFileLocation sourceFile, CppLanguageDialect dialect, ISymbolScope clrScope, bool allowPendingActions, bool collectPPUsages, CppMergeSymbolActions mergeSymbolActions);
    public sealed virtual Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> GetTemplateParametersMapping(ICppResolveEntity ent);
    public sealed virtual IEnumerable`1<KeyValuePair`2<ICppResolveEntity, Dictionary`2<ICppResolveEntity, CppTemplateParametersBase>>> Journaling_QueryTemplateParameterMapping();
    public sealed virtual Dictionary`2<ICppResolveEntity, ICppLinkageEntity> Journaling_QueryResolveToLinkageEntityMap();
    public sealed virtual CppLocationAnchor IncrementCurrentAnchor(int delta);
    public sealed virtual CppLocationAnchor IncrementCurrentAnchor();
    public sealed virtual CppLocationAnchor get_CurrentAnchor();
    public sealed virtual CppPPLocationAnchor IncrementCurrentPPAnchor();
    public sealed virtual CppPPLocationAnchor get_CurrentPPAnchor();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AllowPendingActions();
    public sealed virtual void SetStartAnchor(CppLocationAnchor anchor);
    public sealed virtual void SetStartPPAnchor(CppPPLocationAnchor anchor);
    [CompilerGeneratedAttribute]
public sealed virtual CppPPUsagesCollection get_PPUsageEngine();
    [CompilerGeneratedAttribute]
public sealed virtual CppSymbolLocator get_SymbolLocator();
    [CompilerGeneratedAttribute]
public void set_SymbolLocator(CppSymbolLocator value);
    [CompilerGeneratedAttribute]
public sealed virtual CppGlobalNamespaceResolveEntity get_GlobalNamespace();
    [CompilerGeneratedAttribute]
public sealed virtual ICppResolvedTypeFactory get_TypeFactory();
    [CompilerGeneratedAttribute]
public sealed virtual ICppResolvedTypeFactory get_VerboseTypeFactory();
    [CompilerGeneratedAttribute]
public sealed virtual ICppResolvedTypeFactory get_VerboseNormalizingTypeFactory();
    [CompilerGeneratedAttribute]
public sealed virtual CppFileLocation get_SourceFile();
    public sealed virtual ICppRootFileResolveEntitiesCache get_RootCache();
    [CompilerGeneratedAttribute]
public sealed virtual CppResolveMutex get_ResolveMutex();
    [CompilerGeneratedAttribute]
public sealed virtual CppRootInclusionContext get_InclusionContext();
    [CompilerGeneratedAttribute]
public sealed virtual CppGlobalSymbolCache get_GlobalCache();
    public sealed virtual ISymbolScope get_ClrScope();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsUESolution();
    [CompilerGeneratedAttribute]
public sealed virtual CppUE4Version get_UEVersion();
    public sealed virtual ICppLinkageEntity TryGetCachedLinkageEntity(ICppResolveEntity resolveEntity);
    public sealed virtual void CacheLinkageEntity(ICppResolveEntity resolveEntity, ICppLinkageEntity linkageEntity);
    public sealed virtual void RecacheLinkageEntitySymbols();
    public sealed virtual void ClearLinkageEntitiesCache();
    public sealed virtual CppLanguageDialect GetDialect();
    public sealed virtual void SetCurrentModule(CppModuleId module);
    [CompilerGeneratedAttribute]
public sealed virtual CppModuleId get_CurrentModule();
    [CompilerGeneratedAttribute]
private void set_CurrentModule(CppModuleId value);
    public sealed virtual CppResolveEntitiesDetachedData GetDetachedData();
    public sealed virtual CppJournal GetCurrentJournal();
    public sealed virtual CppJournal Snapshot();
    public sealed virtual void Rollback(CppJournal journal);
    public sealed virtual long GetVersion();
    public sealed virtual ICppPerfEventAccumulator GetPerfEvents();
    public sealed virtual CppMergeSymbolActions GetMergeSymbolActions();
    [CompilerGeneratedAttribute]
public sealed virtual int get_ClassInstantiationsCount();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ClassInstantiationsCount(int value);
    [CompilerGeneratedAttribute]
public sealed virtual CppComparisonCategories get_ComparisonCategories();
    public sealed virtual bool TryGetContextOfAlreadyImportedModule(CppModuleDescriptor descriptor, CppModuleImportingContext& ctx);
    public sealed virtual void RegisterImportedModule(CppModuleImportingContext ctx);
    public sealed virtual void UnregisterImportedModule(CppModuleImportingContext ctx);
    public sealed virtual bool ImportsModulesOtherThanBuiltins();
    private static Dictionary`2<CppQualifiedNamePart, CppUnmergedActions> CreateUnmergedActionsMap(CppInclusionContext context);
    private static Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>> CreateChildrenMap(CppInclusionContext inclusionContext);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFileResolveEntitiesCacheBase : object {
    protected Dictionary`2<ICppResolveEntity, Dictionary`2<ICppResolveEntity, CppTemplateParametersBase>> myTemplateParametersMappingCache;
    public sealed virtual void AddTemplateParametersMapping(ICppResolveEntity ent, Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> fp);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFileSymbolsCache : object {
    private CppLocationAnchor myStartAnchor;
    private CppPPLocationAnchor myStartPPAnchor;
    private CppSymbolTypeIntern myTypeIntern;
    private BinarySearchList`2<CppComplexOffset, CppLocationAnchor> myClassEndOffsetToAnchorCache;
    private bool myDetectionMode;
    private BinarySearchList`2<CppComplexOffset, CppLocationAnchor> myOffsetToAnchorCache;
    private BinarySearchList`2<CppComplexOffset, CppPPLocationAnchor> myOffsetToPPAnchorCache;
    private BinarySearchList`2<CppComplexOffset, CppInclusionContextSnapshot> myPreprocessorSnapshots;
    private bool myPsiModeEnabled;
    protected ICppFileResolveEntitiesCache myResolveCache;
    private BinarySearchList`2<CppComplexOffset, CppJournal> myResolveCacheSnapshots;
    private Dictionary`2<ICppSymbol, ICppResolveEntity> mySymbolToEntityCache;
    [CompilerGeneratedAttribute]
private ICppBuilder <RootBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private CppNamespaceSymbol <GlobalNamespaceSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private CppFileLocation <BaseFile>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ICppSymbol> <PreprocessorSymbols>k__BackingField;
    public ICppBuilder RootBuilder { get; }
    public CppNamespaceSymbol GlobalNamespaceSymbol { get; public set; }
    public ICppFileResolveEntitiesCache ResolveCache { get; }
    public CppFileLocation BaseFile { get; }
    public List`1<ICppSymbol> PreprocessorSymbols { get; public set; }
    public Nullable`1<UInt32> PragmaPackForChameleon { get; }
    public CppModuleId CurrentModule { get; }
    public CppFileSymbolsCache(ICppFileResolveEntitiesCache resolveCache, CppSymbolTypeIntern typeIntern, CppFileLocation baseFile, ICppBuilder rootBuilder);
    [CompilerGeneratedAttribute]
public sealed virtual ICppBuilder get_RootBuilder();
    [CompilerGeneratedAttribute]
public CppNamespaceSymbol get_GlobalNamespaceSymbol();
    [CompilerGeneratedAttribute]
public void set_GlobalNamespaceSymbol(CppNamespaceSymbol value);
    public sealed virtual ICppFileResolveEntitiesCache get_ResolveCache();
    [CompilerGeneratedAttribute]
public sealed virtual CppFileLocation get_BaseFile();
    [CompilerGeneratedAttribute]
public sealed virtual List`1<ICppSymbol> get_PreprocessorSymbols();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PreprocessorSymbols(List`1<ICppSymbol> value);
    public sealed virtual void SetDetectionMode(bool enabled);
    public void SetGlobalNamespace(CppNamespaceSymbol symbol, ICppScopeResolveEntity entity);
    public void ShiftTextOffsets(int textOffset, int delta);
    public void RegisterAndIncrementAnchor(CppComplexOffset offset);
    public void RegisterAndIncrementAnchor(ICppSymbol sym);
    public void RegisterAndIncrementAnchor(ICppSymbol sym, ICppResolveEntity ent);
    public void RegisterAndIncrementAnchor(ICppSymbol sym, ICppResolveEntity ent, CppComplexOffset pointOfDeclaration);
    public void RegisterSymbolAndResolveEntity(ICppSymbol sym, ICppResolveEntity ent);
    public void RegisterSymbol(ICppSymbol sym);
    public void RegisterClassEnd(CppComplexOffset offset, CppLocationAnchor anchor);
    public sealed virtual void RegisterPreprocessorSnapshot(CppComplexOffset offset, CppInclusionContextSnapshot snapshot);
    public sealed virtual void RegisterCacheSnapshot(CppComplexOffset offset);
    public sealed virtual void RegisterAndIncrementAnchorForIncludeDirective(CppComplexOffset offset, bool localInclude);
    public sealed virtual ICppSymbol IgnorePPSymbol(CppComplexOffset offset);
    public CppLocationAnchor GetCurrentAnchor();
    public IEnumerable`1<ICppSymbol> GetSymbols();
    public ICppResolveEntity FindResolveEntityBySymbol(ICppSymbol symbol);
    public ICppResolveEntity TryFindResolveEntityBySymbol(ICppSymbol symbol);
    public CppLocationAnchor FindLocationAnchorByOffset(CppComplexOffset offset);
    public CppPPLocationAnchor FindPPLocationAnchorByOffset(CppComplexOffset offset);
    private static TAnchor FindAnchorByOffsetImpl(CppComplexOffset offset, BinarySearchList`2<CppComplexOffset, TAnchor> offsetToAnchorCache, TAnchor startAnchor);
    public KeyValuePair`2<CppComplexOffset, CppInclusionContextSnapshot> GetSnapshotAtOffset(CppComplexOffset offset);
    public CppComplexOffset RestoreCacheSnapshotAtOffset(CppComplexOffset offset);
    public sealed virtual bool HasCacheSnapshot();
    public virtual Nullable`1<UInt32> get_PragmaPackForChameleon();
    public sealed virtual CppSymbolTypeIntern GetTypeIntern();
    public sealed virtual void DisablePsiMode();
    public CppModuleId get_CurrentModule();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFileSymbolsCacheUtil : object {
    public static CppFileSymbolsCache CreateWithGlobalNamespace(CppInclusionContext context, CppSymbolTypeIntern typeIntern, CppFileLocation baseFile);
    public static CppFileSymbolsCache CreateWithNewResolveCache(CppGlobalSymbolCache cache, CppSymbolTypeIntern typeIntern, CppFileLocation baseFile, CppLanguageDialect dialect);
    public static CppFileSymbolsCache CreateForCodeFragment(CppViewPos& view, CppSymbolTypeIntern typeIntern, CppFileLocation baseFile, Nullable`1<UInt32> pragmaPack, CppAccessibility accessibility);
    public static CppFileSymbolsCache CreateForPseudoFunctionBody(CppViewPos& view, CppSymbolTypeIntern typeIntern, CppFileLocation baseFile, Nullable`1<UInt32> pragmaPack);
    public static CppFileSymbolsCache CreateForFunctionBody(CppViewPos& view, CppSymbolTypeIntern typeIntern, CppFileLocation baseFile, Nullable`1<UInt32> pragmaPack);
    private static CppFileSymbolsCache Create(CppViewPos& view, CppSymbolTypeIntern typeIntern, CppFileLocation baseFile, Nullable`1<UInt32> pragmaPack, CppAccessibility accessibility, Func`4<ICppScopeResolveEntity, CppLocationAnchor, CppCodeFragmentResolveEntitiesCache, TFragmentResolveEntity> fragmentResolveEntityFactory);
    public static CppFileSymbolsCache CreateSymbolsCacheForCodeFragment(CppViewPos& view, CppSymbolTypeIntern typeIntern, ICppCompositeNode context, Nullable`1<UInt32> pragmaPack);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppForStatementBuilder : CppLoopStatementBuilder`2<CppForStatementSymbol, CppForStatementResolveEntity> {
    public CppForStatementBuilder(ICppBuilder parent, CppSymbolLocation loc);
    public void LearnKind(CppForStatementKind kind);
    public void LearnInitExpression(CppTwinExpressionBuilder& builder);
    public void LearnIterationExpression(CppTwinExpressionBuilder& builder);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppForStatementKind : Enum {
    public int value__;
    public static CppForStatementKind OLD_STYLE;
    public static CppForStatementKind RANGE_BASED;
    public static CppForStatementKind MS_FOREACH;
    public static CppForStatementKind CO_AWAIT;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppForStatementModuleEntity : CppLoopStatementModuleEntity {
    public ICppExpression InitExpression;
    public ICppExpression IterationExpression;
    private CppForStatementKind myKind;
    public CppForStatementModuleEntity(CppForStatementKind kind, CppLocationAnchor anchor, CppRegularFunctionModuleEntity function);
    public virtual ICppStatementResolveEntity Import(CppScopeResolveEntityBase targetParent, CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppForStatementResolveEntity : CppForStatementResolveEntityBase {
    private CppResolveEntityCondition myCondition;
    private ReplacedAndResolvedExpression myInitExpression;
    private ReplacedAndResolvedExpression myIterationExpression;
    private CppForStatementKind myKind;
    public CppForStatementResolveEntity(ICppResolveEntity parentScope, CppLocationAnchor location);
    public sealed virtual void SetReplacedCondition(ICppExpression e, CppLocationAnchor location);
    public sealed virtual void SetResolvedCondition(ICppResolvedExpression e);
    public virtual CppForStatementKind GetKind();
    public virtual ICppResolvedExpression GetCondition();
    public void SetReplacedInitExpression(ICppExpression e, CppLocationAnchor location);
    public void SetReplacedIterationExpression(ICppExpression e, CppLocationAnchor location);
    public void SetResolvedInitExpression(ICppResolvedExpression e);
    public void SetResolvedIterationExpression(ICppResolvedExpression e);
    public virtual ICppResolvedExpression GetInitExpression();
    public virtual ICppResolvedExpression GetIterationExpression();
    public void SetKind(CppForStatementKind kind);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppForStatementResolveEntityBase : CppLoopStatementResolveEntityBase {
    private static string ourRawName;
    public static CppQualifiedId NAME;
    public CppQualifiedNamePart Name { get; }
    protected CppForStatementResolveEntityBase(ICppResolveEntity parentScope, CppLocationAnchor location);
    private static CppForStatementResolveEntityBase();
    public virtual CppQualifiedNamePart get_Name();
    public abstract virtual CppForStatementKind GetKind();
    public abstract virtual ICppResolvedExpression GetInitExpression();
    public abstract virtual ICppResolvedExpression GetIterationExpression();
    internal virtual CppFuncEvaluationResult Evaluate(CppExpressionEvaluator evaluator, CppFunctionEvaluationContext functionCtx, CppQualType retType);
    private CppFuncEvaluationResult EvalOldStyleForLoop(CppExpressionEvaluator evaluator, CppFunctionEvaluationContext functionCtx, CppQualType retType);
    private CppFuncEvaluationResult EvalRangeBasedStyleForLoop(CppExpressionEvaluator evaluator, CppFunctionEvaluationContext functionCtx, CppQualType retType);
    private static CppResolvedQualifiedReferenceExpression CreateRefToVar(CppGroupedVariableDeclaratorResolveEntity var, CppViewPos& viewPos);
    private CppGroupedVariableDeclaratorResolveEntity CreateVarAndAddValueToContext(CppQualType autoType, ICppResolvedExpression initializer, CppTypeContext& typeContext, CppExpressionEvaluator evaluator, CppEvaluationFail& fail);
    internal virtual CppLoopStatementResolveEntityBase Substitute(ICppScopeResolveEntity parent, CppSubstitutionDriver driver);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppForStatementResolveEntityWithSubstitution : CppForStatementResolveEntityBase {
    private static Func`2<CppForStatementResolveEntityBase, ICppResolvedExpression> InitGetter;
    private static Func`2<CppForStatementResolveEntityBase, ICppResolvedExpression> ContitionGetter;
    private static Func`2<CppForStatementResolveEntityBase, ICppResolvedExpression> IterationGetter;
    private CppForStatementResolveEntityBase myInner;
    private CppSubstitutionDriver myDriver;
    private SubstitutedExpression myInit;
    private SubstitutedExpression myCondition;
    private SubstitutedExpression myIteration;
    public CppForStatementResolveEntityWithSubstitution(ICppResolveEntity parentScope, CppForStatementResolveEntityBase inner, CppSubstitutionDriver driver);
    private static CppForStatementResolveEntityWithSubstitution();
    public virtual ICppResolvedExpression GetInitExpression();
    public virtual ICppResolvedExpression GetCondition();
    public virtual ICppResolvedExpression GetIterationExpression();
    public virtual CppForStatementKind GetKind();
    private static ICppResolvedExpression GetInitExpressionStatic(CppForStatementResolveEntityBase stmt);
    private static ICppResolvedExpression GetConditionStatic(CppForStatementResolveEntityBase stmt);
    private static ICppResolvedExpression GetIterationExpressionStatic(CppForStatementResolveEntityBase stmt);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppForStatementSymbol : CppLoopStatementSymbol {
    public ICppExpression InitExpression;
    public ICppExpression IterationExpression;
    public CppForStatementKind Kind;
    public CppForStatementSymbol(CppSymbolLocation loc);
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppForwardingBuilder : CppBuilderWithParent {
    public ICppScopeResolveEntity ResolveEntity { get; }
    public CppForwardingBuilder(ICppBuilder parent);
    public virtual ICppScopeResolveEntity get_ResolveEntity();
    public virtual void AddChild(CppParserSymbol sym);
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFragmentBuilder : object {
    public static CppFragmentBuilder`1<TFragmentResolveEntity> Create(TFragmentResolveEntity ent, CppAccessibility accessibility);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFragmentBuilder`1 : object {
    private CppFileSymbolsCache myOwner;
    private FragmentResolveEntity myResolveEnt;
    private CppAccessibility myAccessibility;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public CppFragmentBuilder`1(FragmentResolveEntity ent, CppAccessibility accessibility);
    public sealed virtual void AddChild(CppParserSymbol sym);
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    public sealed virtual CppFileSymbolsCache GetOwner();
    internal void SetOwner(CppFileSymbolsCache owner);
    public sealed virtual ICppParserSymbol GetClassParentSymbol();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual void AddGotoStatement(CppComplexOffset loc, CppGotoStatementKind kind);
    public sealed virtual CppScopeSymbol GetSymbol();
    public sealed virtual CppScopeStatementResolveEntity GetResolveEntity();
    public void LearnLocation(CppSymbolLocation location);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFreeStandingFunctionParameter : CppFunctionParameterModuleEntityWithName {
    public CppQualType Type;
    private bool myParameterIsPack;
    public bool IsParameterPack { get; }
    public CppFreeStandingFunctionParameter(CppParameterListModuleEntity paramList, CppQualifiedNamePart name, CppQualType type, ICppDeclaratorSymbol symbol);
    public virtual bool get_IsParameterPack();
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFreeStandingFunctionParameterWithInitializer : CppFreeStandingFunctionParameter {
    private CppDeclaratorInitializer myInitializer;
    public CppFreeStandingFunctionParameterWithInitializer(CppParameterListModuleEntity paramList, CppQualifiedNamePart name, CppQualType type, ICppDeclaratorSymbol symbol, CppDeclaratorInitializer initializer);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public virtual CppDeclaratorInitializer GetInitializer();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFriendFunctionModuleEntity : CppRegularFunctionModuleEntity {
    private CppClassModuleEntity myLexicalParent;
    private OptionalData myOptionalData;
    public CppQualType Type;
    public ICppExpression RequiresClause { get; }
    public CppCompoundStatementModuleEntity Body { get; }
    public CppSmallArray`1<ICppAttribute> Attributes { get; }
    public CppFriendFunctionModuleEntity(int index, CppClassModuleEntity lexicalParent, CppQualifiedNamePart name, CppDeclarationSpecifiers declarationSpecifiers, CppPureVirtualSpecifiers pureVirtualSpecifiers, CppAccessibility accessibility, IEnumerable`1<ICppSymbol> symbols, CppSmallArray`1<ICppAttribute> attributes);
    internal CppFriendFunctionModuleEntity(int index);
    public virtual ICppExpression get_RequiresClause();
    public virtual CppCompoundStatementModuleEntity get_Body();
    public virtual CppSmallArray`1<ICppAttribute> get_Attributes();
    internal void SetRequiresClause(ICppExpression requiresClause);
    internal virtual void SetBody(CppCompoundStatementModuleEntity body);
    public virtual CppQualType ImportType(CppModuleImportingContext ctx);
    public virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public sealed virtual CppImportResult`1<ICppFunctionDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
    private CppImportResult`1<ICppFunctionDeclaratorResolveEntity> FindBySignature(CppSmallList`1<ICppFunctionDeclaratorResolveEntity> friends, CppModuleImportingContext ctx, CppGroupingEqualityComparer comparer);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppFuncKeywordKind : Enum {
    public int value__;
    public static CppFuncKeywordKind __FUNCTION;
    public static CppFuncKeywordKind __FUNCDNAME;
    public static CppFuncKeywordKind __FUNCSIG;
    public static CppFuncKeywordKind __PRETTY_FUNCTION;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFunctionArgumentListBuilder : ValueType {
    private CppList`1<ICppExpression> myArguments;
    private bool myCreateSymbols;
    public CppFunctionArgumentListBuilder(bool createSymbols);
    public sealed virtual CppExpressionBuilder CreateExpressionBuilder();
    public sealed virtual void LearnArgument(CppExpressionBuilder& b, bool isPackExpansion);
    public ICppExpression[] GetArguments();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFunctionBodyBuilder : CppCompoundStatementBuilderBase {
    public ICppScopeResolveEntity ResolveEntity { get; }
    public CppFunctionBodyBuilder(ICppFileSymbolsCache symbolsCache, CppSymbolLocation loc);
    public virtual ICppScopeResolveEntity get_ResolveEntity();
    public virtual CppScopeStatementResolveEntity GetResolveEntity();
    public CppFunctionBodyResolveEntity GetFuncBodyResolveEntity();
    public virtual void AddGotoStatement(CppComplexOffset loc, CppGotoStatementKind kind);
    public void LearnCtorInitializer(CppComplexOffset loc, CppTwinQualifiedNameBuilder& nameBuilder, CppTwinFunctionArgumentListBuilder& argsBuilder, CppArgumentListKind argumentListKind, bool isPackExpansion);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFunctionBodyResolveEntity : CppCodeFragmentCompoundStatementResolveEntity {
    private CppFunctionDeclaratorResolveEntity myFunction;
    public ICppFunctionDeclaratorResolveEntity Function { get; }
    public CppFunctionBodyResolveEntity(ICppScopeResolveEntity parentScope, CppLocationAnchor outerAnchor, ICppFileResolveEntitiesCache resolveCache);
    public virtual Kind GetKind();
    public sealed virtual ICppFunctionDeclaratorResolveEntity get_Function();
    public sealed virtual CppQualType GetResolvedFunctionReturnType(ICppResolvedTypeFactory tf);
    public void SetFunction(CppFunctionDeclaratorResolveEntity function);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFunctionBodyResolveEntityWithSubstitution : CppCompoundStatementResolveEntityWithSubstitution {
    private static CppQualifiedNamePart ourName;
    private CppFunctionDeclaratorWithSubstitution myFunction;
    private ICppFunctionBodyResolveEntity myInner;
    private CppSubstitutionDriver myDriver;
    private bool myForceExpressionSubstitution;
    public CppQualifiedNamePart Name { get; }
    public ICppFunctionDeclaratorResolveEntity Function { get; }
    public CppFunctionBodyResolveEntityWithSubstitution(CppFunctionDeclaratorWithSubstitution func, ICppFunctionBodyResolveEntity inner, ICppSubstitutionContext subst, CppViewPos& pointOfInstantiation, ICppFileResolveEntitiesCache resolveCache, bool forceExpressionSubstitution);
    private static CppFunctionBodyResolveEntityWithSubstitution();
    public void Init();
    public virtual CppQualifiedNamePart get_Name();
    public sealed virtual ICppFunctionDeclaratorResolveEntity get_Function();
    public sealed virtual CppQualType GetResolvedFunctionReturnType(ICppResolvedTypeFactory tf);
    public CppFunctionDeclaratorWithSubstitution GetOwningFunction();
    public virtual string ToString();
    public void ForceExpressionSubstitution();
    public bool ExpressionsWereSubstituted();
    public CppLocationAnchor AnchorOfInstantiation();
    private static void ForceExpressionSubstitutionInScope(ICppScopeStatementResolveEntity scope);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFunctionDeclaratorResolveEntity : CppDeclaratorResolveEntityBase {
    private ICppFunctionBodyResolveEntity myFunctionBody;
    private CppSmallList`1<CppQualifiedName> myCxxCliOverrideSpecifiers;
    private CppCachedReference`1<IEnumerable`1<ICppResolveEntity>> myCachedResolvedCxxCliOverrideSpecifierTargets;
    private ICppExpression myReplacedRequiresClause;
    private ICppResolvedExpression myCachedResolvedRequiresClause;
    private CppFunctionTraits modreq(System.Runtime.CompilerServices.IsVolatile) myTraits;
    private BodyState myBodyState;
    private int myBodyChameleonVersion;
    private CppCachedRequiresClauseState modreq(System.Runtime.CompilerServices.IsVolatile) myCachedResolvedRequiresClauseState;
    public CppSmallList`1<CppQualifiedName> CxxCliOverrideSpecifiers { get; public set; }
    public CppQualType ReplacedType { get; }
    public CppFunctionTraits Traits { get; }
    public ICppFunctionBodyResolveEntity Body { get; }
    public int BodyChameleonVersion { get; }
    public CppFunctionDeclaratorResolveEntity(ICppResolveEntityParentScope parent, CppQualifiedNamePart name, ICppDeclaratorSymbol sym, CppLocationAnchor anchor, CppQualType replacedType, CppAttributeList attrs);
    public CppSmallList`1<CppQualifiedName> get_CxxCliOverrideSpecifiers();
    public void set_CxxCliOverrideSpecifiers(CppSmallList`1<CppQualifiedName> value);
    public virtual CppQualType get_ReplacedType();
    public virtual ICppParameterListResolveEntity GetMainParameterList();
    public virtual ICppResolvedExpression GetResolvedRequiresClause();
    public virtual IEnumerable`1<ICppResolveEntity> GetResolvedCxxCliOverrideSpecifierTargets();
    public virtual CppFunctionTraits get_Traits();
    public virtual ICppFunctionBodyResolveEntity get_Body();
    public virtual int get_BodyChameleonVersion();
    public virtual CppAccessibility GetAccessibility();
    public virtual bool HasDefinition();
    public virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public virtual int GetFirstDefaultArgIndex();
    public void SetBody(CppFunctionBodyResolveEntity body);
    public void SetClosedChameleonBody();
    public void OpenChameleon(ICppFunctionBodyResolveEntity body);
    public void CloseChameleon();
    public void CloseChameleonIfOpen();
    public void SetOrReplaceChameleon(CppFunctionBodyResolveEntity body);
    public void SetCtorBlockWithoutBody();
    public void SetReplacedRequiresClause(ICppExpression expression);
    public bool HasNonChameleonBody();
    public bool HasVisibleBody(bool returnTrueForChameleon, CppViewPos& vp);
    public virtual string ToString();
    public static int GetFirstDefaultArgIndex(CppParameterListResolveEntity paramList);
    protected virtual void DumpInternal(CppIndentationStringBuilder tw);
    protected virtual CppQualType GetNonNormalizedType(ICppResolvedTypeFactory typeFactory, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPosForDeclSpecs, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPosForDeclarator);
    private CppParameterListResolveEntity GetParameterListImpl();
    private IEnumerable`1<ICppResolveEntity> ResolveCxxCliOverrideSpecifierTargets();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFunctionDeclaratorWithSubstitution : CppDeclaratorResolveEntityWithSubstitutionBase`1<ICppFunctionDeclaratorResolveEntity> {
    private CppFunctionBodyResolveEntityWithSubstitution myBody;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myBodySubstitutionInProgress;
    private int myBodyChameleonVersion;
    private CppParameterListWithSubstitution myParameterList;
    private IEnumerable`1<ICppResolveEntity> myOverrideSpecifiers;
    private CppCachedRequiresClauseState modreq(System.Runtime.CompilerServices.IsVolatile) myRequiresClauseState;
    private ICppResolvedExpression myCachedRequiresClause;
    private CppFunctionTraits modreq(System.Runtime.CompilerServices.IsVolatile) myTraits;
    public CppFunctionTraits Traits { get; }
    public ICppFunctionBodyResolveEntity Body { get; }
    public int BodyChameleonVersion { get; }
    public CppFunctionDeclaratorWithSubstitution(ICppResolveEntityParent structuralParent, CppViewPos& vp, CppQualifiedNamePart name, ICppFunctionDeclaratorResolveEntity inner, ICppSubstitutionContext subst);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual CppFunctionTraits get_Traits();
    public sealed virtual ICppFunctionBodyResolveEntity get_Body();
    public sealed virtual int get_BodyChameleonVersion();
    public sealed virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public sealed virtual int GetFirstDefaultArgIndex();
    public CppParameterListWithSubstitution GetParameterList();
    public sealed virtual ICppParameterListResolveEntity GetMainParameterList();
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetResolvedCxxCliOverrideSpecifierTargets();
    public sealed virtual ICppResolvedExpression GetResolvedRequiresClause();
    public void SetParameterList(CppParameterListWithSubstitution parameterList);
    public void UpdateInstantiationPoint(CppViewPos& vp);
    public bool InstantiateFunctionBody(CppViewPos& vp, bool forceChameleonInstantiation);
    public ICppSubstitutionContext GetSubstitutionForBody();
    public CppFunctionBodyResolveEntityWithSubstitution GetBody();
    private void WaitWhileBodySubstitutionInProgress();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFunctionParameterDeclaratorPack : CppResolveEntityBase {
    private CppSmallList`1<ICppGroupedVariableDeclaratorResolveEntity> myGroupedDeclarators;
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppFunctionParameterDeclaratorPack(ICppParameterListResolveEntity parent, ICppGroupedVariableDeclaratorResolveEntity var);
    public CppFunctionParameterDeclaratorPack(ICppParameterListResolveEntity parent, ICppGroupedVariableDeclaratorResolveEntity var, CppLocationAnchor anchor);
    public sealed virtual void Dump(CppIndentationStringBuilder tw);
    public sealed virtual void ForceMerge(CppLocationAnchor a);
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetGroupedEntities();
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetGroupedEntities(CppLocationAnchor anchor);
    public sealed virtual void AppendGroupedEntities(CppLocationAnchor anchor, FrugalLocalList`1& result);
    public sealed virtual void AppendGroupedEntities(CppLocationAnchor anchor, List`1<ICppResolveEntity> result);
    public sealed virtual ICppGroupedDeclaratorResolveEntity FindGroupedDeclarator(ICppDeclaratorResolveEntity ungrouped);
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public void Add(ICppGroupedVariableDeclaratorResolveEntity var);
    public void UpdateParameterResolveEntity(CppVariableDeclaratorResolveEntity var);
    public CppSmallList`1<ICppGroupedVariableDeclaratorResolveEntity> GetGroupedDeclarators();
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFunctionParameterModuleEntity : object {
    public bool IsParameterPack { get; }
    public abstract virtual CppQualifiedNamePart GetName();
    [CanBeNullAttribute]
public abstract virtual ICppDeclaratorSymbol GetSymbol();
    public virtual CppDeclaratorInitializer GetInitializer();
    public abstract virtual bool get_IsParameterPack();
    public abstract virtual CppModuleEntityKind Kind();
    public abstract virtual int SerializedSize();
    public abstract virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public abstract virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFunctionParameterModuleEntityWithInitializer : CppFunctionParameterModuleEntityWithName {
    private CppSmallArray`1<ICppExpression> myInitializerArguments;
    private KIND myInitializerKind;
    private bool myParameterIsPack;
    public bool IsParameterPack { get; }
    public CppFunctionParameterModuleEntityWithInitializer(CppParameterListModuleEntity paramList, CppQualifiedNamePart name, ICppDeclaratorSymbol symbol, CppDeclaratorInitializer initializer);
    private void SetInitializer(CppDeclaratorInitializer initializer);
    public virtual CppDeclaratorInitializer GetInitializer();
    public virtual bool get_IsParameterPack();
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFunctionParameterModuleEntityWithName : CppFunctionParameterModuleEntity {
    protected static int BaseSerializedSize;
    private CppQualifiedNamePart myName;
    public CppParameterListModuleEntity ParamList;
    private CppSymbolLocation mySymbolLocation;
    public string Name { get; }
    public ICppExpression Initializer { get; }
    public bool ShouldBeResolved { get; }
    protected CppFunctionParameterModuleEntityWithName(CppParameterListModuleEntity paramList, CppQualifiedNamePart name, ICppDeclaratorSymbol symbol);
    public static CppFunctionParameterModuleEntityWithName Create(CppParameterListModuleEntity paramList, CppQualifiedNamePart name, ICppDeclaratorSymbol symbol);
    public sealed virtual string get_Name();
    public sealed virtual ICppExpression get_Initializer();
    public sealed virtual bool Equals(ICppDecoratedFunctionParameter _);
    public sealed virtual bool get_ShouldBeResolved();
    public virtual CppQualifiedNamePart GetName();
    public virtual ICppDeclaratorSymbol GetSymbol();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFunctionParameterModuleEntityWithNamePack : CppFunctionParameterModuleEntityWithName {
    public bool IsParameterPack { get; }
    internal CppFunctionParameterModuleEntityWithNamePack(CppParameterListModuleEntity paramList, CppQualifiedNamePart name, ICppDeclaratorSymbol symbol);
    public virtual bool get_IsParameterPack();
    public virtual CppModuleEntityKind Kind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFunctionParameterModuleEntityWithNameSingle : CppFunctionParameterModuleEntityWithName {
    public bool IsParameterPack { get; }
    internal CppFunctionParameterModuleEntityWithNameSingle(CppParameterListModuleEntity paramList, CppQualifiedNamePart name, ICppDeclaratorSymbol symbol);
    public virtual bool get_IsParameterPack();
    public virtual CppModuleEntityKind Kind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFunctionParameterResolveEntity : object {
    private CppParameterListResolveEntity myParent;
    private CppParameterDeclaratorSymbol mySymbol;
    private CppQualType myReplacedType;
    private CppDependentInfoCachedValue myCachedDepInfo;
    private CppLocationAnchor myInitializerAnchor;
    [CanBeNullAttribute]
private ICppExpression myCachedResolvedInitializer;
    [CanBeNullAttribute]
private ICppExpression myReplacedInitializer;
    private CppCachedInitializerState modreq(System.Runtime.CompilerServices.IsVolatile) myCachedResolvedInitializerState;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <LocationAnchor>k__BackingField;
    [CompilerGeneratedAttribute]
private CppAttributeList <Attributes>k__BackingField;
    public ICppResolveEntity StructuralParent { get; }
    public ICppResolveEntityParent RealParent { get; }
    public CppQualifiedNamePart Name { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; private set; }
    public bool IsParameterPack { get; }
    public CppFunctionParameterResolveEntity(CppParameterListResolveEntity parent, CppQualifiedNamePart name, CppParameterDeclaratorSymbol symbol, CppLocationAnchor anchor, CppQualType replacedType, CppAttributeList replacedAttributes);
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual ICppResolveEntityParent get_RealParent();
    [CompilerGeneratedAttribute]
public sealed virtual CppQualifiedNamePart get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public sealed virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    [CompilerGeneratedAttribute]
public virtual CppAttributeList get_Attributes();
    [CompilerGeneratedAttribute]
private void set_Attributes(CppAttributeList value);
    public CppParameterDeclaratorSymbol GetDeclaratorSymbol();
    public CppQualType GetReplacedType();
    public sealed virtual CppQualType GetCppType(ICppResolvedTypeFactory typeFactory);
    public CppQualType GetTypeWithoutFunctionParamAdjusting(ICppResolvedTypeFactory typeFactory);
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
    internal CppViewPos GetViewPosForDeclarationSpecifiers(ICppFileResolveEntitiesCache resolveCache);
    internal CppViewPos GetViewPosForDeclarator(ICppFileResolveEntitiesCache resolveCache);
    internal CppViewPos GetViewPosForInitializer(ICppFileResolveEntitiesCache resolveCache);
    public sealed virtual bool Contains(ICppDeclaratorResolveEntity d);
    public sealed virtual CppDependentInfo GetDependentInfo();
    private CppDependentInfo CalculateDependentInfo();
    public sealed virtual bool get_IsParameterPack();
    public sealed virtual bool HasInitializer();
    internal void SetInitializer(ICppExpression replacedInitializer, CppLocationAnchor anchor);
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    private CppDeclaratorInitializer ComposeResolvedInitializer();
    public sealed virtual ICppVariableTemplateDeclaratorResolveEntity GetTemplateDeclaration();
    public sealed virtual CppSmallList`1<ICppVariableDeclaratorResolveEntity> GetUngroupedDeclarators();
    public sealed virtual ICppVariableDeclaratorResolveEntity GetAnyUngrouped();
    public sealed virtual ICppEvaluationResult GetValue(CppEvaluationParams evalParams, ICppEvaluationErrorTracker errorTracker);
    public virtual string ToString();
    private void ResolveAndSetAttributes(CppAttributeList replacedAttributes);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFunctionParameterUtil : object {
    [ExtensionAttribute]
public static ICppDeclaratorSymbol GetDeclaratorSymbol(ICppVariableDeclaratorResolveEntity param);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFunctionSubstitutionCache : object {
    private Dictionary`2<ICppTemplateArgument[], ICppGroupedFunctionDeclaratorResolveEntity> myCachedSpecs;
    [CanBeNullAttribute]
public ICppGroupedFunctionDeclaratorResolveEntity PickSpecializationInSFINAEContext(ICppMutableFunctionTemplateDeclaratorResolveEntity templ, CppSubstitutionContext subst, CppTypeContext& tc, ICppTemplateFunctionCallDeductionErrorConsumer errorConsumer, ICppResolvedExpression& constraint);
    private ICppGroupedFunctionDeclaratorResolveEntity CheckCachedSpecialization(ICppMutableFunctionTemplateDeclaratorResolveEntity templ, CppSubstitutionContext subst, ICppTemplateArgument[] args, CppTypeContext& tc, ICppFileResolveEntitiesCache resolveCache, ICppTemplateFunctionCallDeductionErrorConsumer errorConsumer, ICppGroupedFunctionDeclaratorResolveEntity cached);
    [CanBeNullAttribute]
public ICppGroupedFunctionDeclaratorResolveEntity PickSpecialization(ICppMutableFunctionTemplateDeclaratorResolveEntity templ, CppSubstitutionContext subst, CppTypeContext& tc);
    [CanBeNullAttribute]
public ICppGroupedFunctionDeclaratorResolveEntity PickCachedSpecialization(ICppFunctionTemplateDeclaratorResolveEntity templ, CppSubstitutionContext subst);
    public void DumpCachedSubstitutions(ICppFunctionTemplateDeclaratorResolveEntity templ, CppIndentationStringBuilder tw);
    public List`1<ICppGroupedFunctionDeclaratorResolveEntity> GetCachedSpecializations();
    public ICppTemplateArgument[] FindSubstitutionTemplateArguments(ICppFunctionDeclaratorResolveEntity substituted);
    [CanBeNullAttribute]
private ICppGroupedFunctionDeclaratorResolveEntity TryFindMatchingExplicitSpecialization(ICppFunctionTemplateDeclaratorResolveEntity templ, ICppTemplateArgument[] args);
    private ICppGroupedFunctionDeclaratorResolveEntity AddToCache(ICppFunctionTemplateDeclaratorResolveEntity templ, ICppTemplateArgument[] key, ICppGroupedFunctionDeclaratorResolveEntity value);
    private ICppGroupedFunctionDeclaratorResolveEntity UpdateCached(ICppFunctionTemplateDeclaratorResolveEntity templ, ICppTemplateArgument[] key, ICppGroupedFunctionDeclaratorResolveEntity value);
    private static bool IsMatchingExplicitSpecialization(ICppGroupedFunctionDeclaratorResolveEntity declEnt, ICppTemplateArgument[] args);
    private static CppSubstitutionContext DropDecorations(CppSubstitutionContext ctx, ICppResolvedTypeFactory tf);
    private static ICppTemplateArgument[] GetKey(ICppFunctionTemplateDeclaratorResolveEntity templ, CppSubstitutionContext& subst, ICppResolvedTypeFactory tf);
    public ValueTuple`2<ICppGroupedFunctionDeclaratorResolveEntity, bool> GroupImportedSpecialization(ICppMutableFunctionTemplateDeclaratorResolveEntity templ, CppImportedTemplateFunctionSpecializationDeclaratorResolveEntity ungrouped);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFunctionTemplateModuleEntity : object {
    private CppSmallArray`1<ICppFunctionModuleEntity> mySpecializations;
    public ICppFunctionModuleEntity PrimaryTemplate { get; }
    public CppFunctionTemplateModuleEntity(CppSmallArray`1<ICppFunctionModuleEntity> specializations);
    public ICppFunctionModuleEntity get_PrimaryTemplate();
    public CppImportResult`1<ICppFunctionTemplateDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppFunctionTraits : Enum {
    public int value__;
    public static CppFunctionTraits UNINITIALIZED;
    public static CppFunctionTraits DELETED;
    public static CppFunctionTraits NORMAL;
    public static CppFunctionTraits NOEXCEPT;
    public static CppFunctionTraits TRIVIAL;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFwdClassSymbol : CppParserSymbol {
    private CppAccessibility myAccessibility;
    private CppClassVirtualSpecifiers myClassVirtualSpecifiers;
    private CppClassKey myKey;
    private CppSymbolTemplateParametersList myParamList;
    private CppAttributeList myAttributes;
    private Flags myFlags;
    private CppClassLazyMergingInfo myLazyMergingFlags;
    private static int ModuleAttachmentOffset;
    public bool Standalone { get; public set; }
    public bool IsFriend { get; public set; }
    public bool IsExplicitInstantiation { get; }
    public CppClassTag Tag { get; }
    public CppClassKey Key { get; }
    public CppClassVirtualSpecifiers ClassVirtualSpecifiers { get; }
    public CppFwdClassSymbol(CppQualifiedName name, CppSymbolTemplateParametersList paramList, CppAttributeList attributes, CppComplexOffset loc, CppClassKey key, CppAccessibility accessibility, CppClassVirtualSpecifiers classVirtualSpecifiers, bool standalone, bool isFriend, bool isExplicitInstantiation, bool export, CppModuleAttachment moduleAttachment);
    internal CppFwdClassSymbol(CppQualifiedName name, CppSymbolTemplateParametersList paramList, CppAttributeList attributes, CppComplexOffset loc, CppClassKey key, CppAccessibility accessibility, CppClassVirtualSpecifiers classVirtualSpecifiers, Flags flags);
    private static Flags CreteFlags(bool standalone, bool isFriend, bool isExplicitInstantiation, bool export, CppModuleAttachment moduleAttachment);
    public bool get_Standalone();
    public void set_Standalone(bool value);
    public bool get_IsFriend();
    public void set_IsFriend(bool value);
    public bool get_IsExplicitInstantiation();
    public sealed virtual CppSymbolTemplateParametersList ParamList();
    public sealed virtual CppAttributeList Attributes();
    public sealed virtual CppClassTag get_Tag();
    public sealed virtual CppClassKey get_Key();
    public sealed virtual CppClassVirtualSpecifiers get_ClassVirtualSpecifiers();
    public sealed virtual void SetLazyMergingInfo(CppClassLazyMergingInfo flags);
    public sealed virtual CppClassLazyMergingInfo GetLazyMergingInfo();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool Exported();
    public sealed virtual CppModuleAttachment ModuleAttachment();
    internal Flags GetFlags();
    public virtual TResult Accept(ICppSymbolVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppFwdEnumWithBaseSymbol : CppParserSymbol {
    private CppAccessibility myAccessibility;
    private CppClassKey myKey;
    private bool myExport;
    private CppModuleAttachment myModuleAttachment;
    private CppSymbolTemplateParametersList myParamList;
    private CppAttributeList myAttributes;
    private CppClassLazyMergingInfo myLazyMergingFlags;
    private CppQualType myQualType;
    public CppClassTag Tag { get; }
    public CppClassKey Key { get; }
    public CppClassVirtualSpecifiers ClassVirtualSpecifiers { get; }
    public CppFwdEnumWithBaseSymbol(CppQualifiedName name, CppSymbolTemplateParametersList paramList, CppAttributeList attributes, CppComplexOffset loc, CppClassKey key, CppAccessibility accessibility, bool export, CppModuleAttachment moduleAttachment, CppQualType underlyingType);
    public sealed virtual CppSymbolTemplateParametersList ParamList();
    public sealed virtual CppClassTag get_Tag();
    public sealed virtual CppClassKey get_Key();
    public sealed virtual CppClassVirtualSpecifiers get_ClassVirtualSpecifiers();
    public sealed virtual void SetLazyMergingInfo(CppClassLazyMergingInfo flags);
    public sealed virtual CppClassLazyMergingInfo GetLazyMergingInfo();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool Exported();
    public sealed virtual CppModuleAttachment ModuleAttachment();
    public virtual TResult Accept(ICppSymbolVisitor`1<TResult> visitor);
    public sealed virtual CppAttributeList Attributes();
    public CppQualType GetUnderlyingType();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGcnewConstraint : object {
    public static CppGcnewConstraint INSTANCE;
    private static CppGcnewConstraint();
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGeneratedDeclaratorResolveEntity : object {
    protected CppQualType myType;
    private CppGeneratedResolveEntityType myEntityType;
    private ICppResolveEntityParent myParent;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <LocationAnchor>k__BackingField;
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    protected CppGeneratedDeclaratorResolveEntity(CppGeneratedResolveEntityType entityType, CppQualType type, ICppResolveEntityParent parent, CppQualifiedNamePart name, CppLocationAnchor anchor);
    public void SetParent(ICppResolveEntityParent parent);
    public abstract virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public virtual CppAttributeList get_Attributes();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public abstract virtual CppAccessibility GetAccessibility();
    public abstract virtual bool HasDefinition();
    public virtual ICppResolveEntityParent get_RealParent();
    public virtual ICppResolveEntity get_StructuralParent();
    [CompilerGeneratedAttribute]
public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    [CompilerGeneratedAttribute]
public virtual CppLocationAnchor get_LocationAnchor();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual CppGeneratedResolveEntityType GetEntityType();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGeneratedFunctionDeclaratorResolveEntity : CppGeneratedDeclaratorResolveEntity {
    [CompilerGeneratedAttribute]
private CppDeclarationSpecifiers <DeclarationSpecifiers>k__BackingField;
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppFunctionTraits Traits { get; }
    public ICppFunctionBodyResolveEntity Body { get; }
    public int BodyChameleonVersion { get; }
    public CppGeneratedFunctionDeclaratorResolveEntity(CppGeneratedResolveEntityType entityType, CppQualType type, ICppResolveEntityParent parent, CppQualifiedNamePart name, CppLocationAnchor anchor, CppDeclarationSpecifiers declSpecs);
    public virtual CppAccessibility GetAccessibility();
    public virtual bool HasDefinition();
    [CompilerGeneratedAttribute]
public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppFunctionTraits get_Traits();
    public virtual ICppFunctionBodyResolveEntity get_Body();
    public virtual int get_BodyChameleonVersion();
    public virtual ICppParameterListResolveEntity GetMainParameterList();
    public virtual IEnumerable`1<ICppResolveEntity> GetResolvedCxxCliOverrideSpecifierTargets();
    public virtual ICppResolvedExpression GetResolvedRequiresClause();
    public virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public virtual int GetFirstDefaultArgIndex();
    public CppQualType GetSignature();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGeneratedFunctionParameterModuleEntity : CppFunctionParameterModuleEntity {
    private string myName;
    public string Name { get; }
    public ICppExpression Initializer { get; }
    public bool ShouldBeResolved { get; }
    public bool IsParameterPack { get; }
    public CppGeneratedFunctionParameterModuleEntity(string name);
    public virtual CppQualifiedNamePart GetName();
    public virtual ICppDeclaratorSymbol GetSymbol();
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public sealed virtual bool Equals(ICppDecoratedFunctionParameter _);
    public sealed virtual string get_Name();
    public sealed virtual ICppExpression get_Initializer();
    public sealed virtual bool get_ShouldBeResolved();
    public virtual bool get_IsParameterPack();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGeneratedMsMakeIntegerSequenceTemplateDeclaratorBuilder : object {
    public static CppQualifiedId OurName;
    private static CppGeneratedMsMakeIntegerSequenceTemplateDeclaratorBuilder();
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual CppTemplateParametersBase CreateTemplateParameters(ICppFileResolveEntitiesCache cache, ICppResolvedTypeFactory tf);
    public sealed virtual CppGeneratedTypeTemplateDeclaratorResolveEntityBase CreateDeclarator(CppGeneratedTypeDeclaratorResolveEntity primaryTemplate);
    private static CppTemplateParametersBase CreateIntSeqTemplateParameters(ICppFileResolveEntitiesCache cache, ICppResolvedTypeFactory tf);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppGeneratedResolveEntityType : Enum {
    public int value__;
    public static CppGeneratedResolveEntityType NOT_GENERATED;
    public static CppGeneratedResolveEntityType BUILTIN;
    public static CppGeneratedResolveEntityType IMPLICITLY_GENERATED_MEMBER;
    public static CppGeneratedResolveEntityType INHERITED_CONSTRUCTOR;
    public static CppGeneratedResolveEntityType FUNC;
    public static CppGeneratedResolveEntityType CLR;
    public static CppGeneratedResolveEntityType DELEGATE_CONSTRUCTOR;
    public static CppGeneratedResolveEntityType CLI_ACCESSOR;
    public static CppGeneratedResolveEntityType SYNTHESIZED_DEDUCTION_GUIDE;
    public static CppGeneratedResolveEntityType UE4_GENERATED_MEMBER;
    public static CppGeneratedResolveEntityType IMPORTED_FROM_MODULE;
    public static CppGeneratedResolveEntityType DEFAULTED_SPECIAL_MEMBER;
    public static CppGeneratedResolveEntityType GG_DECLARE_HUNGARIAN_TYPEDEF;
    public static CppGeneratedResolveEntityType BLOCK_SHADERS_GENERATED_MEMBER;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGeneratedResolveEntityTypeUtil : object {
    [ExtensionAttribute]
public static bool IsImplicitlyGeneratedOrDefaultedSpecialMember(CppGeneratedResolveEntityType type);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGeneratedTemplateDeclaratorBuilderUtil : object {
    [ExtensionAttribute]
public static ICppTypeTemplateDeclaratorResolveEntity Generate(ICppGeneratedTypeTemplateDeclaratorBuilder builder, CppGlobalNamespaceResolveEntity globalNs);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGeneratedTemplateDeclaratorPack`1 : object {
    private ICppTemplateDeclaratorResolveEntity`1<TInnerEntity> myTemplate;
    private CppGlobalNamespaceResolveEntity myGlobalNs;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppGeneratedTemplateDeclaratorPack`1(CppQualifiedNamePart name, ICppTemplateDeclaratorResolveEntity`1<TInnerEntity> template, CppGlobalNamespaceResolveEntity globalNs);
    public sealed virtual void Dump(CppIndentationStringBuilder b);
    public sealed virtual void ForceMerge(CppLocationAnchor anchor);
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetGroupedEntities();
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetGroupedEntities(CppLocationAnchor anchor);
    public sealed virtual void AppendGroupedEntities(CppLocationAnchor anchor, FrugalLocalList`1& result);
    public sealed virtual void AppendGroupedEntities(CppLocationAnchor anchor, List`1<ICppResolveEntity> result);
    public sealed virtual ICppGroupedDeclaratorResolveEntity FindGroupedDeclarator(ICppDeclaratorResolveEntity ungrouped);
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual TResult Accept(ICppResolveEntityVisitor`1<TResult> visitor);
    public sealed virtual ICppResolveEntity get_StructuralParent();
    [CompilerGeneratedAttribute]
public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGeneratedTemplateParameters : CppTemplateParametersHeader {
    private ICppResolvedExpression myRequiresClause;
    public CppGeneratedTemplateParameters(IEnumerable`1<ICppTemplateParameter> data);
    public CppGeneratedTemplateParameters(IEnumerable`1<ICppTemplateParameter> data, ICppResolvedExpression requiresClause);
    public virtual string ToString();
    public virtual ICppResolvedExpression GetResolvedRequiresClause();
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGeneratedTemplateParametersUtil : object {
    public static ICppTypeTemplateParameter CreateTypeTemplateParameter(ICppFileResolveEntitiesCache cache, CppQualifiedNamePart name, CppTypeTemplateParameterKey key);
    public static ICppTypeTemplateParameter CreateTypeTemplateParameter(ICppFileResolveEntitiesCache cache, CppQualifiedNamePart name);
    public static ICppTypeTemplateParameter CreateTypeTemplateParameter(ICppFileResolveEntitiesCache cache);
    public static ICppTypeTemplateParameterPack CreateTypeTemplateParameterPack(ICppFileResolveEntitiesCache cache, CppQualifiedNamePart name);
    public static ICppTypeTemplateParameterPack CreateTypeTemplateParameterPack(ICppFileResolveEntitiesCache cache, CppQualifiedNamePart name, CppTypeTemplateParameterKey key);
    public static ICppTemplateTemplateParameter CreateTemplateTemplateParameter(ICppFileResolveEntitiesCache cache, CppQualifiedNamePart name, CppTemplateParametersBase parameters);
    public static ICppTemplateTemplateParameter CreateTemplateTemplateParameter(ICppFileResolveEntitiesCache cache, CppTemplateParametersBase parameters);
    public static ICppTemplateTemplateParameterPack CreateTemplateTemplateParameterPack(ICppFileResolveEntitiesCache cache, CppQualifiedNamePart name, CppTemplateParametersBase parameters);
    public static ICppExpressionTemplateParameter CreateExpressionTemplateParameter(ICppFileResolveEntitiesCache cache, CppQualifiedNamePart name, CppQualType resolvedType);
    public static ICppExpressionTemplateParameter CreateExpressionTemplateParameter(ICppFileResolveEntitiesCache cache, CppQualType resolvedType);
    public static ICppExpressionTemplateParameterPack CreateExpressionTemplateParameterPack(ICppFileResolveEntitiesCache cache, CppQualifiedNamePart name, CppQualType resolvedType);
    public static ICppExpressionTemplateParameterPack CreateExpressionTemplateParameterPack(ICppFileResolveEntitiesCache cache, CppQualType resolvedType);
    public static ICppGenericParameter CreateGenericParameter(ICppFileResolveEntitiesCache cache, CppQualifiedNamePart name, ICppSymbol symbol, CppBasicBaseDescription`1[] bases, CppGenericParameterFlags flags);
    public static bool IsGeneratedGenericParameter(ICppGenericParameter param);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGeneratedTypeDeclaratorResolveEntity : CppGeneratedDeclaratorResolveEntity {
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppGeneratedTypeDeclaratorResolveEntity(CppGeneratedResolveEntityType entityType, CppQualType type, ICppResolveEntityParentScope parent, CppQualifiedNamePart name, CppLocationAnchor anchor);
    public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppAccessibility GetAccessibility();
    public virtual bool HasDefinition();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGeneratedTypePackElementTemplateDeclaratorBuilder : object {
    public static CppQualifiedId OurName;
    private static CppGeneratedTypePackElementTemplateDeclaratorBuilder();
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual CppTemplateParametersBase CreateTemplateParameters(ICppFileResolveEntitiesCache cache, ICppResolvedTypeFactory tf);
    public sealed virtual CppGeneratedTypeTemplateDeclaratorResolveEntityBase CreateDeclarator(CppGeneratedTypeDeclaratorResolveEntity primaryTemplate);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGeneratedTypeTemplateDeclaratorResolveEntityBase : CppTypeTemplateDeclaratorResolveEntity {
    protected CppGeneratedTypeTemplateDeclaratorResolveEntityBase(ICppTypeDeclaratorResolveEntity ent);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGeneratedVariableDeclaratorResolveEntity : CppGeneratedDeclaratorResolveEntity {
    [CompilerGeneratedAttribute]
private CppDeclarationSpecifiers <DeclarationSpecifiers>k__BackingField;
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public bool IsParameterPack { get; }
    public CppGeneratedVariableDeclaratorResolveEntity(CppGeneratedResolveEntityType entityType, CppQualType type, ICppResolveEntityParentScope parent, CppQualifiedNamePart name, CppDeclarationSpecifiers specs, CppLocationAnchor anchor);
    [CompilerGeneratedAttribute]
public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppAccessibility GetAccessibility();
    public virtual bool HasDefinition();
    public virtual CppDeclaratorInitializer GetInitializer();
    public virtual bool HasInitializer();
    public virtual bool get_IsParameterPack();
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGenerateImplicitMembersUtil : object {
    public static CppQualType CopyParameterType(CppQualType classType);
    public static CppQualType MoveParameterType(CppQualType classType);
    public static bool LanguageHasImplicitMembers(CppLanguageDialect dialect);
    public static CppGeneratingImplicitMembersStatus GeneratingImplicitMembersStatus(ICppClassResolveEntity cent, CppLanguageDialect dialect);
    public static bool GenerateImplicitlyGeneratedMembers(ICppMutableClassResolveEntity cent);
    private static void GenerateDestructor(ICppMutableClassResolveEntity cent, CppRestrictionSpecifiers restrictionSpecs);
    private static CppSmallList`1<ICppFunctionDeclaratorResolveEntity> CollectOperatorsForImplicitEqualityGeneration(ICppMutableClassResolveEntity cent, CppLocationAnchor anchor);
    public static ICppGroupedFunctionDeclaratorResolveEntity GenerateImplicitMember(CppQualType type, ICppMutableClassResolveEntity cent, CppQualifiedNamePart name, ICppFunctionDeclaratorResolveEntity template);
    internal static ICppGroupedFunctionDeclaratorResolveEntity GenerateDefaultConstructor(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf, ICppFunctionDeclaratorResolveEntity template);
    internal static ICppGroupedFunctionDeclaratorResolveEntity GenerateDefaultConstructorOfManagedClass(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf);
    [CanBeNullAttribute]
private static ICppFunctionDeclaratorResolveEntity FindDefaultedDestructor(ICppClassResolveEntity cent);
    internal static CppAssignmentOperatorResolveEntityPack FindOrCreateAssignmentOperator(ICppMutableClassResolveEntity cent, CppLocationAnchor anchor);
    public static CppImplicitlyGeneratedFunctionDeclaratorResolveEntity CreateImplicitEqualityOperator(ICppScopeResolveEntity scope, ICppFunctionDeclaratorResolveEntity threeWayComparison, CppLocationAnchor anchor);
    private static void GenerateImplicitEqualityOperators(CppSmallList`1<ICppFunctionDeclaratorResolveEntity> operators, ICppMutableClassResolveEntity cent, CppLocationAnchor anchor);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppGeneratingImplicitMembersStatus : Enum {
    public int value__;
    public static CppGeneratingImplicitMembersStatus None;
    public static CppGeneratingImplicitMembersStatus Standard;
    public static CppGeneratingImplicitMembersStatus Cli;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGenericConstraintClauseBuilder : object {
    private WhereClauseBuilder myParentBuilder;
    private string myName;
    private CppTypeGenericParameter mySpecifiedParameter;
    private CppList`1<ICppGenericConstraint> myUnresolvedConstraints;
    public CppGenericConstraintClauseBuilder(WhereClauseBuilder parentBuilder);
    public void LearnName(string name);
    public void LearnRef();
    public void LearnValue();
    public void LearnGcnew();
    public void LearnBaseType(ICppDeclarationBuilder b);
    public string GetName();
    public CppList`1<ICppGenericConstraint> GetUnresolvedConstaints();
    public WhereClauseBuilder GetParentBuilder();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGenericParameterBuilder : object {
    private CppTemplateHeaderBuilder myParentBuilder;
    private string myName;
    private CppSymbolLocation myLocation;
    private CppTypeTemplateParameterKey myKey;
    private bool myWasBuilt;
    private ICppTypeTemplateParameterSymbol mySymbol;
    private ICppGenericParameter myEntity;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public CppGenericParameterBuilder(CppTemplateHeaderBuilder parentBuilder);
    public void LearnName(string name);
    public void LearnLocation(CppSymbolLocation loc);
    public void LearnKey(CppTypeTemplateParameterKey key);
    public ICppTemplateParameterSymbol GetSymbol();
    public ICppTemplateParameter GetResolveEntity();
    public sealed virtual void AddChild(CppParserSymbol sym);
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    private void Build();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppGenericParameterFlags : Enum {
    public int value__;
    public static CppGenericParameterFlags NONE;
    public static CppGenericParameterFlags HAS_REF_CONSTRAINT;
    public static CppGenericParameterFlags HAS_VALUE_CONSTRAINT;
    public static CppGenericParameterFlags HAS_GCNEW_CONSTRAINT;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGenericParameterFlagsUtil : object {
    public static bool IsRef(CppGenericParameterFlags flags);
    public static bool IsValue(CppGenericParameterFlags flags);
    public static bool isGcNew(CppGenericParameterFlags flags);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGenericParameters : CppTemplateParametersBase {
    private CppGenericParameters myConstraintsSource;
    public CppGenericParameters(IEnumerable`1<ICppTemplateParameter> params);
    public void BorrowConstraints(CppGenericParameters from);
    public CppGenericParameters GetConstraintsSource();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGenericParameterSymbol : CppTypeTemplateParameterSymbolBase {
    public CppGenericParameterSymbol(string name, CppTypeTemplateParameterKey key, CppSymbolLocation loc);
    public virtual ICppTemplateArgument GetDefault();
    public CppTypeTemplateArgument GetDefaultType();
    public virtual string ToString();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGenericParameterWithSubstitution : CppTypeTemplateParameterWithSubstitutionBase`1<ICppGenericParameter> {
    private CppBasicBaseDescription`1[] myBases;
    private CppList`1<CppBasicBaseDescription`1<ICppClassOrGenericParameterResolveEntity>> myNonDependentBases;
    public CppGenericParameterWithSubstitution(ICppGenericParameter inner, CppViewPos& pointOfInstantiation, ICppSubstitutionContext subst, CppBasicBaseDescription`1[] bases);
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public sealed virtual CppBasicBaseDescription`1[] GetBases();
    public sealed virtual CppList`1<CppBasicBaseDescription`1<ICppClassOrGenericParameterResolveEntity>> GetNonDependentBases();
    public sealed virtual CppGenericParameterFlags GetFlags();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGenericSymbolEqualityComparer`1 : object {
    public static CppGenericSymbolEqualityComparer`1<T> INSTANCE;
    private static CppGenericSymbolEqualityComparer`1();
    public sealed virtual bool Equals(T lhs, T rhs);
    public sealed virtual int GetHashCode(T obj);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGetDefaultTemplateArgumentsUtil : object {
    public static ICppTemplateArgument[] GetDefaultsFromParameters(CppTemplateParametersBase params, ICppResolvedTypeFactory tf);
    public static ICppTemplateArgument[] GetDefaultsFromName(CppQualifiedNamePart name, ICppResolvedTypeFactory tf);
    public static ICppTemplateArgument[] MergeDefaultArguments(ICppTemplateArgument[] a, ICppTemplateArgument[] b);
    public static int GetFirstDefaultedArgument(ICppTypeTemplateInstantiationResolveEntity cent, CppViewPos viewPos);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGGDeclareHungarianDirectiveContainer : object {
    private CppNamespaceResolveEntity myNamespaceResolveEntity;
    private Dictionary`2<string, CppGGDeclareHungarianObject> myNameToObjects;
    private static PrefixRecord[] ourPPrefixes;
    private static PrefixRecord[] ourRPrefixes;
    private static PrefixRecord[] ourCPrefixes;
    private static PrefixRecord[] ourAPrefixes;
    public CppGGDeclareHungarianDirectiveContainer(CppNamespaceResolveEntity ent);
    private static CppGGDeclareHungarianDirectiveContainer();
    public void AddObject(CppGGDeclareHungarianSymbol symbol, CppQualType replacedType, CppLocationAnchor anchor);
    public bool TryGenerate(CppQualifiedNamePart name);
    private bool TryForce(string objectName, CppGGDeclareHungarianPrefixKind prefix, CppQualifiedNamePart originalId);
    public void CollectAllEnabled(Dictionary`2<string, int> nameToEnabledBitset, CppLocationAnchor anchor);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGGDeclareHungarianEagerCache : CppGGDeclareHungarianTypeCache {
    internal ICppScopeResolveEntity StructuralParent;
    internal CppLocationAnchor LocationAnchor;
    internal CppAccessibility Accessibility;
    internal CppGGDeclareHungarianEagerCache(ICppScopeResolveEntity structuralParent, CppQualType replaceType, CppLocationAnchor locationAnchor, CppAccessibility accessibility);
}
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGGDeclareHungarianEagerGeneration : object {
    private static String[] myPrefixText;
    private static CppGGDeclareHungarianEagerGeneration();
    public static void Generate(ICppScopeResolveEntity parent, CppGGDeclareHungarianSymbol symbol, CppQualType replacedType, CppLocationAnchor anchor);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGGDeclareHungarianEagerTypeResolveEntity : object {
    private CppQualifiedNamePart myName;
    private CppGGDeclareHungarianPrefixKind myPrefixKind;
    private CppGGDeclareHungarianEagerCache myEagerCache;
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppGGDeclareHungarianEagerTypeResolveEntity(CppQualifiedNamePart name, CppGGDeclareHungarianPrefixKind prefixKind, CppGGDeclareHungarianEagerCache eagerCache);
    public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public virtual CppAttributeList get_Attributes();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public virtual CppAccessibility GetAccessibility();
    public virtual ICppResolveEntityParent get_RealParent();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual string ToString();
    public CppDependentInfo GetDependentInfo();
    public sealed virtual bool HasDefinition();
    public sealed virtual CppGeneratedResolveEntityType GetEntityType();
    public sealed virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppGGDeclareHungarianMode : Enum {
    public int value__;
    public static CppGGDeclareHungarianMode INVALID;
    public static CppGGDeclareHungarianMode ALL;
    public static CppGGDeclareHungarianMode BASE;
    public static CppGGDeclareHungarianMode MINI;
    public static CppGGDeclareHungarianMode ARRAY;
    public static CppGGDeclareHungarianMode ARRAY_PTR;
    public static CppGGDeclareHungarianMode ENUM;
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGGDeclareHungarianModeUtil : object {
    private static int ALL_BITMASK;
    private static int BASE_BITMASK;
    private static int MINI_BITMASK;
    private static int ARRAY_BITMASK;
    private static int ARRAY_PTR_BITMASK;
    private static int ENUM_BITMASK;
    public static CppGGDeclareHungarianMode StringToGGDeclareHungarianMode(string text);
    public static string GGDeclareHungarianModeToString(CppGGDeclareHungarianMode mode);
    public static int ModeToMask(CppGGDeclareHungarianMode mode);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGGDeclareHungarianObject : CppGGDeclareHungarianTypeCache {
    private CppSmallList`1<Part> myParts;
    private int myEnableGenerationBitmask;
    private int myAlreadyGeneratedBitmask;
    public CppGGDeclareHungarianObject(CppQualType replacedType);
    public void AddPart(CppGGDeclareHungarianSymbol symbol, CppLocationAnchor anchor, CppNamespaceResolveEntity parent);
    public int GetEnableGenerationBitmaskByAnchor(CppLocationAnchor anchor);
    public bool Need(CppGGDeclareHungarianPrefixKind prefixKind);
    public void Generate(CppGGDeclareHungarianPrefixKind prefixKind, CppQualifiedNamePart desiredName, CppNamespaceResolveEntity parent);
    private void MarkAsGenerated(CppGGDeclareHungarianPrefixKind prefixKind, CppNamespaceResolveEntity parent);
    private Part FindFirstPart(CppGGDeclareHungarianPrefixKind prefixKind);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppGGDeclareHungarianPrefixKind : Enum {
    public int value__;
    public static CppGGDeclareHungarianPrefixKind PP;
    public static CppGGDeclareHungarianPrefixKind PPC;
    public static CppGGDeclareHungarianPrefixKind RP;
    public static CppGGDeclareHungarianPrefixKind RPC;
    public static CppGGDeclareHungarianPrefixKind CP;
    public static CppGGDeclareHungarianPrefixKind CPC;
    public static CppGGDeclareHungarianPrefixKind PCPC;
    public static CppGGDeclareHungarianPrefixKind R;
    public static CppGGDeclareHungarianPrefixKind RC;
    public static CppGGDeclareHungarianPrefixKind P;
    public static CppGGDeclareHungarianPrefixKind PC;
    public static CppGGDeclareHungarianPrefixKind C;
    public static CppGGDeclareHungarianPrefixKind A;
    public static CppGGDeclareHungarianPrefixKind RA;
    public static CppGGDeclareHungarianPrefixKind RCA;
    public static CppGGDeclareHungarianPrefixKind PA;
    public static CppGGDeclareHungarianPrefixKind PCA;
    public static CppGGDeclareHungarianPrefixKind AP;
    public static CppGGDeclareHungarianPrefixKind APC;
    public static CppGGDeclareHungarianPrefixKind RAP;
    public static CppGGDeclareHungarianPrefixKind RAPC;
    public static CppGGDeclareHungarianPrefixKind RCAP;
    public static CppGGDeclareHungarianPrefixKind RCAPC;
    public static CppGGDeclareHungarianPrefixKind PAP;
    public static CppGGDeclareHungarianPrefixKind PAPC;
    public static CppGGDeclareHungarianPrefixKind PCAP;
    public static CppGGDeclareHungarianPrefixKind LAST;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGGDeclareHungarianSymbol : CppParserSymbol {
    private static CppQualifiedId ourGGDeclareHungarianName;
    public CppGGDeclareHungarianMode Mode;
    public CppQualType Type;
    public string PatternName;
    public CppAccessibility Accessibility;
    public CppGGDeclareHungarianSymbol(CppComplexOffset loc, CppGGDeclareHungarianMode mode, CppQualType type, string patternName, CppAccessibility accessibility);
    private static CppGGDeclareHungarianSymbol();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGGDeclareHungarianTypeCache : object {
    private CppQualType myReplacedType;
    private CppQualType myResolvedType;
    private CppQualType myArrayType;
    private CppQualType myArrayPtrType;
    private CppQualType myArrayPtrConstType;
    public CppGGDeclareHungarianTypeCache(CppQualType replacedType);
    public CppQualType PrefixKindToType(CppGGDeclareHungarianPrefixKind prefixKind, ICppScopeResolveEntity parent, CppLocationAnchor anchor, ICppResolvedTypeFactory tf);
    public CppQualType GetResolvedType(ICppScopeResolveEntity parent, CppLocationAnchor anchor, ICppResolvedTypeFactory tf);
    public CppQualType GetArrayType(ICppScopeResolveEntity parent, CppLocationAnchor anchor, ICppResolvedTypeFactory tf);
    public CppQualType GetArrayPtrType(ICppScopeResolveEntity parent, CppLocationAnchor anchor, ICppResolvedTypeFactory tf);
    public CppQualType GetArrayPtrConstType(ICppScopeResolveEntity parent, CppLocationAnchor anchor, ICppResolvedTypeFactory tf);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGlobalNamespaceBuilder : object {
    private CppNamespaceSymbol myScopeSym;
    private CppGlobalNamespaceResolveEntity myResolveEnt;
    private CppInclusionContext myContext;
    private CppFileSymbolsCache mySymbolBuilder;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public CppNamespaceSymbol Symbol { get; }
    public CppGlobalNamespaceBuilder(CppInclusionContext context, CppFileLocation location, CppGlobalNamespaceResolveEntity prelude);
    public sealed virtual void AddChild(CppParserSymbol sym);
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    public sealed virtual CppFileSymbolsCache GetOwner();
    public CppInclusionContext GetInclusionContext();
    public CppNamespaceSymbol get_Symbol();
    public sealed virtual ICppParserSymbol GetClassParentSymbol();
    public void SetOwner(CppFileSymbolsCache owner);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGlobalNamespaceId : object {
    public static CppGlobalNamespaceId INSTANCE;
    private static CppGlobalNamespaceId();
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGlobalNamespaceModuleEntity : CppNamespaceModuleEntity {
    public static int SerializedSize;
    public Dictionary`2<ICppModuleEntity, string> OwningModule;
    internal CppModuleEntityFactory ModuleEntityFactory;
    public virtual bool IsInline();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGlobalNamespaceResolveEntity : CppClrNamespaceResolveEntity {
    private CppBuiltinsRefs myBuiltinsRefs;
    private HashSet`1<string> mySupportedBuiltinDeclarators;
    [CompilerGeneratedAttribute]
private ICppFileResolveEntitiesCache <SymbolCache>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbolScope <ClrGlobalSymbolsScope>k__BackingField;
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public ICppFileResolveEntitiesCache SymbolCache { get; }
    public ISymbolScope ClrGlobalSymbolsScope { get; }
    public CppGlobalNamespaceResolveEntity(ICppFileResolveEntitiesCache cache, ISymbolScope clrGlobalSymbolsScope, Dictionary`2<CppQualifiedNamePart, CppUnmergedActions> actionsMap, Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>> childrenMap);
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    [CompilerGeneratedAttribute]
public ICppFileResolveEntitiesCache get_SymbolCache();
    [CompilerGeneratedAttribute]
public ISymbolScope get_ClrGlobalSymbolsScope();
    public static CppGlobalNamespaceResolveEntity GetInstance(ICppResolveEntity scope);
    public static CppGlobalNamespaceResolveEntity GetInstance(CppViewPos& viewPos);
    public CppBuiltinsRefs GetBuiltinsRefs();
    public bool HasBuiltin(string name);
    public bool MarkBuiltinAsSupported(CppQualifiedId qualId);
    public virtual string ToString();
    public virtual bool ShouldDump();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGnuExpressionCompoundStatementResolveEntity : CppCompoundStatementResolveEntity {
    public static CppQualifiedId StaticName;
    public CppQualifiedNamePart Name { get; }
    public CppGnuExpressionCompoundStatementResolveEntity(ICppResolveEntity parentScope, CppLocationAnchor anchor);
    private static CppGnuExpressionCompoundStatementResolveEntity();
    public virtual CppQualifiedNamePart get_Name();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGnuExpressionCompoundStatementResolveEntityWithSubstitution : CppCompoundStatementResolveEntityWithSubstitution {
    public CppCompoundStatementResolveEntity Inner;
    public CppQualifiedNamePart Name { get; }
    public CppGnuExpressionCompoundStatementResolveEntityWithSubstitution(ICppResolveEntity parent, CppCompoundStatementResolveEntity inner);
    public void Init(CppSubstitutionDriver driver);
    public virtual CppQualifiedNamePart get_Name();
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppGotoStatementKind : Enum {
    public int value__;
    public static CppGotoStatementKind BREAK;
    public static CppGotoStatementKind CONTINUE;
    public static CppGotoStatementKind GOTO;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGotoStatementModuleEntity : CppStatementModuleEntityBase {
    private CppGotoStatementKind myKind;
    public CppGotoStatementModuleEntity(CppGotoStatementKind kind, CppLocationAnchor anchor);
    public virtual ICppStatementResolveEntity Import(CppScopeResolveEntityBase targetParent, CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGotoStatementResolveEntity : CppGotoStatementResolveEntityBase {
    private static CppQualifiedId ourName;
    public CppQualifiedNamePart Name { get; }
    public CppGotoStatementResolveEntity(ICppResolveEntity parent, CppLocationAnchor anchor);
    private static CppGotoStatementResolveEntity();
    public virtual CppQualifiedNamePart get_Name();
    public virtual CppGotoStatementKind GetKind();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGotoStatementResolveEntityBase : object {
    [CompilerGeneratedAttribute]
private ICppResolveEntity <StructuralParent>k__BackingField;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <LocationAnchor>k__BackingField;
    public ICppResolveEntity StructuralParent { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppQualifiedNamePart Name { get; }
    protected CppGotoStatementResolveEntityBase(ICppResolveEntity parent, CppLocationAnchor anchor);
    [CompilerGeneratedAttribute]
public virtual ICppResolveEntity get_StructuralParent();
    [CompilerGeneratedAttribute]
public virtual CppLocationAnchor get_LocationAnchor();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public abstract virtual CppQualifiedNamePart get_Name();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public abstract virtual CppGotoStatementKind GetKind();
    public static CppGotoStatementResolveEntityBase Create(CppGotoStatementKind kind, ICppResolveEntity parent, CppLocationAnchor anchor);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGotoStatementResolveEntityWithSubstitution : CppGotoStatementResolveEntityBase {
    private CppGotoStatementResolveEntityBase myInner;
    public CppQualifiedNamePart Name { get; }
    public CppGotoStatementResolveEntityWithSubstitution(ICppScopeResolveEntity parent, CppGotoStatementResolveEntityBase inner);
    public virtual CppQualifiedNamePart get_Name();
    public virtual CppGotoStatementKind GetKind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppGotoStatementSymbol : CppParserSymbol {
    private CppGotoStatementKind myKind;
    public CppGotoStatementSymbol(CppComplexOffset loc, CppGotoStatementKind kind);
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public CppGotoStatementKind GetKind();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppHasApplicableStructuralParentVisitor : object {
    public static CppHasApplicableStructuralParentVisitor Instance;
    private static CppHasApplicableStructuralParentVisitor();
    public sealed virtual bool Visit(ICppClassResolveEntity e);
    public sealed virtual bool Visit(ICppStatementResolveEntity e);
    public sealed virtual bool Visit(ICppRequiresExpressionScopeResolveEntity e);
    public sealed virtual bool Visit(CppRequiresExpressionItemResolveEntity e);
    public sealed virtual bool Visit(ICppParameterListResolveEntity e);
    public sealed virtual bool Visit(ICppDeclaratorResolveEntity e);
    public sealed virtual bool Visit(ICppConceptDefinitionResolveEntity e);
    public sealed virtual bool Visit(ICppEnumeratorResolveEntity e);
    public sealed virtual bool Visit(CppNamespaceResolveEntity e);
    public sealed virtual bool Visit(CppNamespaceAliasResolveEntity e);
    public sealed virtual bool Visit(CppUsingDeclarationResolveEntity e);
    public sealed virtual bool Visit(CppClassTemplateResolveEntityPack e);
    public sealed virtual bool Visit(ICppTypeTemplateParameter e);
    public sealed virtual bool Visit(ICppTypeTemplateParameterPack e);
    public sealed virtual bool Visit(ICppExpressionTemplateParameter e);
    public sealed virtual bool Visit(ICppExpressionTemplateParameterPack e);
    public sealed virtual bool Visit(ICppTemplateTemplateParameter e);
    public sealed virtual bool Visit(ICppTemplateTemplateParameterPack e);
    public sealed virtual bool Visit(ICppGenericParameter e);
    public sealed virtual bool Visit(CppDependentResolveEntity e);
    public sealed virtual bool Visit(CppDependentDecltypeResolveEntity e);
    public sealed virtual bool Visit(CppDependentAutoTypeResolveEntity e);
    public sealed virtual bool Visit(CppDependentFunctionReturnAutoTypeResolveEntity e);
    public sealed virtual bool Visit(CppDependentDeducedClassTypePlaceholder e);
    public sealed virtual bool Visit(CppUsingDeclarationResolveEntityWithSubstitution e);
    public sealed virtual bool Visit(CppUndeterminedSpecializationResolveEntity e);
    public sealed virtual bool Visit(CppTemplateTemplateParameterWithAppliedArgumentsResolveEntity e);
    public sealed virtual bool Visit(CppDecltypeResolveEntity e);
    public sealed virtual bool Visit(CppTypeOfTypeResolveEntity e);
    public sealed virtual bool Visit(ICppDeclaratorResolveEntityPack e);
    public sealed virtual bool Visit(CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity e);
    public sealed virtual bool Visit(CppUndeterminedTemplateVariableSpecializationResolveEntity e);
    public sealed virtual bool Visit(CppSuperResolveEntity e);
    public sealed virtual bool Visit(AbstractBuiltinResolveEntity e);
    public sealed virtual bool Visit(ICppFunctionTemplateDeclaratorResolveEntity e);
    public sealed virtual bool Visit(ICppTypeTemplateDeclaratorResolveEntity e);
    public sealed virtual bool Visit(ICppVariableTemplateDeclaratorResolveEntity e);
    public sealed virtual bool Visit(CppDependencyKillerResolveEntity e);
    public sealed virtual bool Visit(ICppCxxCliPropertySetResolveEntity e);
    public sealed virtual bool Visit(ICppDeductionGuide e);
    public sealed virtual bool Visit(CppUsingEnumEnumeratorResolveEntity e);
    public sealed virtual bool Visit(HlslBuiltinFunctionResolveEntity e);
    public sealed virtual bool Visit(BlockShadersResolveEntity e);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppHLSLBufferBuilder : CppForwardingBuilder {
    private CppHLSLBufferSymbol mySymbol;
    public CppHLSLBufferBuilder(ICppBuilder parent);
    public void LearnName(TokenNodeType tag, CppQualifiedNamePart name, CppSymbolLocation loc);
    public CppHLSLBufferSymbol GetSymbol();
    public virtual void AddChild(CppParserSymbol sym);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppHLSLBufferSymbol : CppScopeSymbol {
    private BufferKind myKind;
    public CppHLSLBufferSymbol(CppQualifiedName name, BufferKind kind, CppSymbolLocation loc);
    public BufferKind GetBufferKind();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppIfStatementBuilder : CppStatementWithConditionBuilder {
    private CppIfStatementSymbol mySymbol;
    private CppIfStatementResolveEntity myResolveEnt;
    public CppIfStatementBuilder(ICppBuilder parent, CppSymbolLocation loc);
    public void LearnConstexpr();
    public void LearnConsteval(bool cond);
    public void LearnThenBuilder(CppCompoundStatementBuilder thenBuilder);
    public void LearnElseBuilder(CppCompoundStatementBuilder elseBuilder);
    protected virtual ICppMutableStatementWithConditionResolveEntity GetResolveEntity();
    protected virtual CppStatementWithConditionSymbol GetSymbol();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppIfStatementModuleEntity : CppScopeStatementModuleEntity {
    [CanBeNullAttribute]
public ICppExpression Condition;
    [NotNullAttribute]
public CppCompoundStatementModuleEntity Then;
    [CanBeNullAttribute]
public CppCompoundStatementModuleEntity Else;
    private bool myIsConstexpr;
    private bool myIsConsteval;
    public bool ConstevalCondition;
    public CppIfStatementModuleEntity(bool isConstexpr, bool isConsteval, CppLocationAnchor anchor, CppRegularFunctionModuleEntity function);
    public virtual ICppStatementResolveEntity Import(CppScopeResolveEntityBase targetParent, CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppIfStatementResolveEntity : CppIfStatementResolveEntityBase {
    private CppResolveEntityCondition myCondition;
    private CppCompoundStatementResolveEntity myElseResolveEnt;
    private CppCompoundStatementResolveEntity myThenResolveEnt;
    public CppIfStatementResolveEntity(ICppResolveEntity parentScope, CppLocationAnchor location);
    public sealed virtual void SetReplacedCondition(ICppExpression expr, CppLocationAnchor location);
    public sealed virtual void SetResolvedCondition(ICppResolvedExpression condition);
    public void SetThenResolveEntity(CppCompoundStatementResolveEntity thenEntity);
    public void SetElseResolveEntity(CppCompoundStatementResolveEntity elseEntity);
    public virtual void AddChild(ICppResolveEntity child);
    public virtual ICppResolvedExpression GetCondition();
    public virtual CppCompoundStatementResolveEntity GetThenResolveEntity();
    public virtual CppCompoundStatementResolveEntity GetElseResolveEntity();
    public virtual CppViewPos ViewPosForCondition();
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppIfStatementResolveEntityBase : CppScopeResolveEntityBase {
    private static CppQualifiedNamePart ourName;
    private bool myIsConstExpr;
    private bool myIsConstEval;
    private bool myConstEvalCondition;
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    protected CppIfStatementResolveEntityBase(ICppResolveEntity parentScope, CppLocationAnchor location);
    private static CppIfStatementResolveEntityBase();
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual List`1<ICppResolveEntity> GetSortedChildren();
    public virtual bool IsConstExpr();
    public virtual bool IsConstEval();
    public virtual bool GetConstEvalCondition();
    public abstract virtual ICppResolvedExpression GetCondition();
    public abstract virtual CppCompoundStatementResolveEntity GetThenResolveEntity();
    public abstract virtual CppCompoundStatementResolveEntity GetElseResolveEntity();
    public abstract virtual CppViewPos ViewPosForCondition();
    public void SetConstExpr();
    public void SetConstEval(bool cond);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppIfStatementResolveEntityWithSubstitution : CppIfStatementResolveEntityBase {
    private ICppIfStatementResolveEntity myInner;
    private CppSubstitutedCondition myCondition;
    private LazySubstitutedBranch myThenResolveEnt;
    private LazySubstitutedBranch myElseResolveEnt;
    private CppCompoundStatementResolveEntity InnerThenResolveEntity { get; }
    private CppCompoundStatementResolveEntity InnerElseResolveEntity { get; }
    public CppIfStatementResolveEntityWithSubstitution(ICppScopeResolveEntity parent, ICppIfStatementResolveEntity inner, CppSubstitutionDriver driver);
    private CppCompoundStatementResolveEntity get_InnerThenResolveEntity();
    private CppCompoundStatementResolveEntity get_InnerElseResolveEntity();
    public virtual ICppResolvedExpression GetCondition();
    public virtual CppCompoundStatementResolveEntity GetThenResolveEntity();
    public virtual CppCompoundStatementResolveEntity GetElseResolveEntity();
    public virtual CppViewPos ViewPosForCondition();
    public CppCompoundStatementResolveEntity GetThenResolveEntity(bool forceExpressionSubstitution);
    public CppCompoundStatementResolveEntity GetElseResolveEntity(bool forceExpressionSubstitution);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppIfStatementSymbol : CppStatementWithConditionSymbol {
    private CppCompoundStatementSymbol myElse;
    private bool myIsConstExpr;
    private bool myIsConstEval;
    private bool myConstEvalCondition;
    private CppCompoundStatementSymbol myThen;
    public CppIfStatementSymbol(CppSymbolLocation loc);
    public bool IsConstExpr();
    public bool IsConstEval();
    public bool GetConstEvalCondition();
    public void SetConstExpr();
    public void SetConstEval(bool cond);
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public CppCompoundStatementSymbol GetThenBranch();
    [CanBeNullAttribute]
public CppCompoundStatementSymbol GetElseBranch();
    public void SetThenBranch(CppCompoundStatementSymbol branch);
    public void SetElseBranch(CppCompoundStatementSymbol branch);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppImplicitBasesType : Enum {
    public int value__;
    public static CppImplicitBasesType NO_IMPLICIT_BASES;
    public static CppImplicitBasesType CLI_ENUM;
    public static CppImplicitBasesType CLI_REF_CLASS;
    public static CppImplicitBasesType CLI_VALUE_CLASS;
    public static CppImplicitBasesType CLI_INTERFACE_CLASS;
    public static CppImplicitBasesType CLI_DELEGATE;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImplicitlyGeneratedEqualityOperatorResolveEntity : CppImplicitlyGeneratedFunctionDeclaratorResolveEntity {
    private ICppFunctionDeclaratorResolveEntity myThreeWayComparison;
    public CppAttributeList Attributes { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public ICppFunctionDeclaratorResolveEntity ThreeWayComparison { get; }
    public CppImplicitlyGeneratedEqualityOperatorResolveEntity(CppQualType type, ICppResolveEntityParent parent, CppLocationAnchor anchor, ICppFunctionDeclaratorResolveEntity threeWayComparison);
    public virtual CppAttributeList get_Attributes();
    public virtual CppAccessibility GetAccessibility();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual ICppResolvedExpression GetResolvedRequiresClause();
    public ICppFunctionDeclaratorResolveEntity get_ThreeWayComparison();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImplicitlyGeneratedFunctionDeclaratorResolveEntity : CppGeneratedFunctionDeclaratorResolveEntity {
    private CppFunctionTraits modreq(System.Runtime.CompilerServices.IsVolatile) myTraits;
    public CppFunctionTraits Traits { get; }
    public CppImplicitlyGeneratedFunctionDeclaratorResolveEntity(CppQualType type, ICppClassResolveEntity parent, CppQualifiedNamePart name, CppLocationAnchor anchor);
    public CppImplicitlyGeneratedFunctionDeclaratorResolveEntity(CppQualType type, ICppClassResolveEntity parent, CppQualifiedNamePart name);
    protected CppImplicitlyGeneratedFunctionDeclaratorResolveEntity(CppQualType type, ICppResolveEntityParent parent, CppQualifiedNamePart name, CppLocationAnchor anchor, CppDeclarationSpecifiers declSpecs);
    public virtual CppFunctionTraits get_Traits();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportDirectiveSymbol : CppSymbol {
    [CompilerGeneratedAttribute]
private bool <IsExported>k__BackingField;
    [CompilerGeneratedAttribute]
private CppFileLocation <ContainingFile>k__BackingField;
    public bool IsExported { get; }
    public CppFileLocation ContainingFile { get; }
    protected CppImportDirectiveSymbol(CppSymbolLocation location, bool isExported);
    [CompilerGeneratedAttribute]
public bool get_IsExported();
    [CompilerGeneratedAttribute]
public virtual CppFileLocation get_ContainingFile();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportedConstrainedTypeOrPackTemplateParameterBase : object {
    private ICppFileResolveEntitiesCache myResolveCache;
    [CanBeNullAttribute]
protected CppConceptDefinitionResolveEntity myConcept;
    protected ICppResolvedExpression myResolvedConceptExpression;
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppDependentInfo DependentInfo { get; }
    public CppTypeTemplateParameterKey Key { get; }
    protected CppImportedConstrainedTypeOrPackTemplateParameterBase(CppConceptDefinitionResolveEntity concept, ICppFileResolveEntitiesCache resolveCache);
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public abstract virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public abstract virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public abstract virtual bool NameEquals(CppQualifiedNamePart name);
    public sealed virtual ICppFileResolveEntitiesCache GetResolveCache();
    public sealed virtual ICppTemplateArgument GetDefault(ICppResolvedTypeFactory tf);
    public sealed virtual bool IsConcept();
    public abstract virtual bool IsInvented();
    public sealed virtual CppConceptDefinitionResolveEntity GetResolvedConcept();
    public sealed virtual ICppResolvedExpression GetResolvedConceptExpression();
    public void SetResolvedConceptExpression(ICppResolvedExpression value);
    public sealed virtual ICppSymbol GetSymbol();
    public sealed virtual CppViewPos GetViewPos();
    public abstract virtual CppTemplateParameterTag GetTag();
    public abstract virtual void ReplaceTag(CppTemplateParameterTag _);
    public abstract virtual CppQualifiedName GetReplacedConceptName();
    public abstract virtual CppQualifiedName CalculateResolvedConceptNameHint();
    public sealed virtual CppDependentInfo get_DependentInfo();
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& _, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public abstract virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver driver);
    public abstract virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver driver);
    public sealed virtual CppTypeTemplateParameterKey get_Key();
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportedConstrainedTypeTemplateParameter : CppImportedConstrainedTypeTemplateParameterBase {
    private CppTemplateParameterTag myTag;
    private bool myIsInvented;
    private CppQualifiedName myResolvedNameHint;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    public CppQualifiedNamePart Name { get; }
    public CppImportedConstrainedTypeTemplateParameter(CppQualifiedNamePart name, CppConceptDefinitionResolveEntity concept, ICppFileResolveEntitiesCache resolveCache, bool isInvented, bool orphaned);
    [CompilerGeneratedAttribute]
public virtual CppQualifiedNamePart get_Name();
    public virtual bool NameEquals(CppQualifiedNamePart name);
    public virtual CppTemplateParameterTag GetTag();
    public virtual void ReplaceTag(CppTemplateParameterTag tag);
    public virtual bool IsInvented();
    internal void SetResolvedNameHint(CppQualifiedName resolvedNameHint);
    public virtual CppQualifiedName GetReplacedConceptName();
    public virtual CppQualifiedName CalculateResolvedConceptNameHint();
    public virtual string ToString();
    internal static string Present(ICppConceptTemplateParameter param);
    internal static CppQualifiedName GetConstraintName(ICppResolvedQualifiedReferenceExpression constraintRef);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportedConstrainedTypeTemplateParameterBase : CppImportedConstrainedTypeOrPackTemplateParameterBase {
    protected CppImportedConstrainedTypeTemplateParameterBase(CppConceptDefinitionResolveEntity concept, ICppFileResolveEntitiesCache resolveCache);
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver driver);
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver driver);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportedConstrainedTypeTemplateParameterPack : CppImportedConstrainedTypeOrPackTemplateParameterBase {
    private CppTemplateParameterTag myTag;
    private bool myIsInvented;
    private CppQualifiedName myResolvedNameHint;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    public CppQualifiedNamePart Name { get; }
    public CppImportedConstrainedTypeTemplateParameterPack(CppQualifiedNamePart name, CppConceptDefinitionResolveEntity concept, ICppFileResolveEntitiesCache resolveCache, bool isInvented, bool orphaned);
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver driver);
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver driver);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    [CompilerGeneratedAttribute]
public virtual CppQualifiedNamePart get_Name();
    public virtual bool NameEquals(CppQualifiedNamePart name);
    public virtual CppTemplateParameterTag GetTag();
    public virtual void ReplaceTag(CppTemplateParameterTag tag);
    public virtual bool IsInvented();
    public sealed virtual ICppTemplateArgumentPack CreateEmptyMatchingArgumentPack();
    internal void SetResolvedNameHint(CppQualifiedName resolvedNameHint);
    public virtual CppQualifiedName GetReplacedConceptName();
    public virtual CppQualifiedName CalculateResolvedConceptNameHint();
    public virtual string ToString();
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportedDeclaratorResolveEntityUtil : object {
    [ExtensionAttribute]
public static bool IsVisible(ICppImportedDeclaratorResolveEntity declarator, CppLocationAnchor anchor);
    [ExtensionAttribute]
public static bool IsVisibleTypeDeclarator(ICppTypeDeclaratorResolveEntity declarator, CppLocationAnchor anchor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportedDeductionGuideResolveEntity : object {
    public CppQualType Type;
    public ICppResolvedExpression RequiresClause;
    private ICppClassResolveEntity myPrimaryTemplate;
    public CppParameterListResolveEntity ParameterList;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <LocationAnchor>k__BackingField;
    [CompilerGeneratedAttribute]
private CppAttributeList <Attributes>k__BackingField;
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; internal set; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public ICppResolveEntityParent RealParent { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; internal set; }
    public CppFunctionTraits Traits { get; }
    public ICppFunctionBodyResolveEntity Body { get; }
    public int BodyChameleonVersion { get; }
    public CppImportedDeductionGuideResolveEntity(ICppClassResolveEntity primaryTemplate, CppLocationAnchor locationAnchor);
    public sealed virtual ICppResolveEntity get_StructuralParent();
    [CompilerGeneratedAttribute]
public sealed virtual CppQualifiedNamePart get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(CppQualifiedNamePart value);
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    [CompilerGeneratedAttribute]
public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual ICppResolveEntityParent get_RealParent();
    public sealed virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public sealed virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    [CompilerGeneratedAttribute]
public sealed virtual CppAttributeList get_Attributes();
    [CompilerGeneratedAttribute]
internal void set_Attributes(CppAttributeList value);
    public sealed virtual CppQualType GetCppType(ICppResolvedTypeFactory _);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public sealed virtual CppFunctionTraits get_Traits();
    public sealed virtual ICppFunctionBodyResolveEntity get_Body();
    public sealed virtual int get_BodyChameleonVersion();
    public sealed virtual ICppParameterListResolveEntity GetMainParameterList();
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetResolvedCxxCliOverrideSpecifierTargets();
    public sealed virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public sealed virtual int GetFirstDefaultArgIndex();
    public sealed virtual ICppResolvedExpression GetResolvedRequiresClause();
    public sealed virtual bool Contains(ICppDeclaratorResolveEntity decl);
    public sealed virtual ICppFunctionTemplateDeclaratorResolveEntity GetTemplateDeclaration();
    public bool InstantiateFunctionBody(CppViewPos& vp, bool forceChameleonInstantiation);
    public sealed virtual ICppFunctionOrVariableDeclaratorResolveEntity GetFirstUngrouped();
    public sealed virtual ICppFunctionDeclaratorResolveEntity GetUngroupedThatProvidingBody();
    public sealed virtual CppList`1<ICppFunctionOrVariableDeclaratorResolveEntity> GetUngroupedDeclarators();
    public sealed virtual SourceKind GetSourceKind();
    public sealed virtual bool CanBeCalledWithZeroArguments();
    public sealed virtual bool CanAcceptInitializerList();
    public sealed virtual void Dump(CppIndentationStringBuilder tw);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Resolve.ICppGroupedFunctionDeclaratorResolveEntity.InstantiateFunctionBody(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp, bool forceChameleonInstantiation);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportedFreeStandingFunctionParameter : CppGeneratedVariableDeclaratorResolveEntity {
    private CppFreeStandingFunctionParameter mySource;
    public CppModuleImportingContext ImportingContext;
    private CppDeclaratorInitializer myInitializer;
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public bool IsParameterPack { get; }
    public CppImportedFreeStandingFunctionParameter(ICppResolveEntityParentScope parent, CppModuleImportingContext ctx, CppFreeStandingFunctionParameter source);
    public ICppDeclaratorSymbol GetDeclaratorSymbol();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual bool get_IsParameterPack();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory tf);
    public sealed virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
    public virtual bool HasInitializer();
    public virtual CppDeclaratorInitializer GetInitializer();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportedFriendFunctionDeclaratorResolveEntity : CppImportedFunctionDeclaratorResolveEntity {
    private ICppClassResolveEntity myLexicalParentClass;
    public CppImportedFriendFunctionDeclaratorResolveEntity(ICppScopeResolveEntity parent, CppQualifiedNamePart name, CppModuleImportingContext importingContext, CppFriendFunctionModuleEntity source);
    public sealed virtual ICppClassResolveEntity LexicalParentClass();
    public sealed virtual ICppScopeResolveEntity LexicalParentScope();
    public void SetLexicalParentClass(ICppClassResolveEntity lexicalParentClass);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportedFunctionBody : CppCompoundStatementResolveEntity {
    private CppImportedFunctionDeclaratorResolveEntity myFunction;
    private CppCompoundStatementModuleEntity mySource;
    public CppModuleImportingContext ImportingContext;
    [CompilerGeneratedAttribute]
private bool <ChildrenImportIsInProgress>k__BackingField;
    public ICppFunctionDeclaratorResolveEntity Function { get; }
    internal bool ChildrenImportIsInProgress { get; private set; }
    public CppImportedFunctionBody(CppImportedFunctionDeclaratorResolveEntity function, CppCompoundStatementModuleEntity source, CppModuleImportingContext importingContext);
    private static ICppResolveEntity PatchStructuralParent(CppImportedFunctionDeclaratorResolveEntity function);
    public sealed virtual ICppFunctionDeclaratorResolveEntity get_Function();
    public sealed virtual CppQualType GetResolvedFunctionReturnType(ICppResolvedTypeFactory tf);
    public virtual CppList`1<ICppResolveEntity> GetChildren();
    public virtual List`1<ICppResolveEntity> GetSortedChildren();
    [CompilerGeneratedAttribute]
internal bool get_ChildrenImportIsInProgress();
    [CompilerGeneratedAttribute]
private void set_ChildrenImportIsInProgress(bool value);
    public void ImportChildren();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportedFunctionDeclaratorResolveEntity : object {
    private ICppResolvedExpression myRequiresClause;
    private CppParameterListResolveEntity modreq(System.Runtime.CompilerServices.IsVolatile) myParameterList;
    private CppImportedFunctionBody myBody;
    private CppFunctionTraits modreq(System.Runtime.CompilerServices.IsVolatile) myTraits;
    public CppRegularFunctionModuleEntity Source;
    public CppModuleImportingContext ImportingContext;
    [CompilerGeneratedAttribute]
private ICppResolveEntity <StructuralParent>k__BackingField;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppAttributeList Attributes { get; }
    public int BodyChameleonVersion { get; }
    public CppFunctionTraits Traits { get; }
    public ICppFunctionBodyResolveEntity Body { get; }
    public CppImportedFunctionDeclaratorResolveEntity(ICppScopeResolveEntity parent, CppQualifiedNamePart name, CppModuleImportingContext importingContext, CppRegularFunctionModuleEntity source);
    public sealed virtual ICppResolveEntityParent get_RealParent();
    [CompilerGeneratedAttribute]
public sealed virtual ICppResolveEntity get_StructuralParent();
    [CompilerGeneratedAttribute]
public sealed virtual CppQualifiedNamePart get_Name();
    public virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public sealed virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual CppAttributeList get_Attributes();
    public sealed virtual int get_BodyChameleonVersion();
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetResolvedCxxCliOverrideSpecifierTargets();
    public sealed virtual CppFunctionTraits get_Traits();
    public bool IsUserProvided();
    public sealed virtual bool HasDefinition();
    public sealed virtual ICppParameterListResolveEntity GetMainParameterList();
    private ICppParameterListResolveEntity GetMainParameterListUnderLock(ICppRootFileResolveEntitiesCache resolveCache);
    public sealed virtual ICppResolvedExpression GetResolvedRequiresClause();
    public sealed virtual CppGeneratedResolveEntityType GetEntityType();
    public void SetRequiresClause(ICppResolvedExpression value);
    public sealed virtual int GetFirstDefaultArgIndex();
    public sealed virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public bool IsExplicitInstantiation();
    public sealed virtual ICppFunctionBodyResolveEntity get_Body();
    internal CppImportedFunctionBody GetBody();
    internal void SetBody(CppImportedFunctionBody body);
    public CppQualType GetReturnType(ICppResolvedTypeFactory tf);
    public sealed virtual CppQualType GetCppType(ICppResolvedTypeFactory tf);
    public sealed virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
    public sealed virtual ICppTopLevelDeclaratorModuleEntity GetSource();
    public sealed virtual CppModuleImportingContext GetImportingContext();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportedFunctionParameter : object {
    private CppParameterListResolveEntity myParent;
    private int myIndex;
    private CppFunctionParameterModuleEntity mySource;
    private CppModuleImportingContext myImportingContext;
    private CppDeclaratorInitializer myInitializer;
    private CppDependentInfoCachedValue myCachedDepInfo;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public bool IsParameterPack { get; }
    public CppImportedFunctionParameter(CppParameterListResolveEntity paramList, int index, CppModuleImportingContext importingContext, CppFunctionParameterModuleEntity source);
    public sealed virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public sealed virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public sealed virtual CppAttributeList get_Attributes();
    public sealed virtual CppQualType GetCppType(ICppResolvedTypeFactory tf);
    public CppDependentInfo GetDependentInfo();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public sealed virtual ICppResolveEntityParent get_RealParent();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    [CompilerGeneratedAttribute]
public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public ICppDeclaratorSymbol GetDeclaratorSymbol();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual bool HasInitializer();
    public sealed virtual bool get_IsParameterPack();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportedLambdaParenOperatorResolveEntity : CppImportedFunctionDeclaratorResolveEntity {
    public CppLocationAnchor LocationAnchor { get; }
    public CppImportedLambdaParenOperatorResolveEntity(CppLambdaClassResolveEntity parent, CppModuleImportingContext ctx, CppRegularFunctionModuleEntity source);
    public virtual CppLocationAnchor get_LocationAnchor();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportedRequiresExpressionParameter : CppGeneratedVariableDeclaratorResolveEntity {
    public CppModuleImportingContext ImportingContext;
    [CompilerGeneratedAttribute]
private bool <IsParameterPack>k__BackingField;
    public bool IsParameterPack { get; }
    public CppImportedRequiresExpressionParameter(ICppResolveEntityParentScope parent, CppModuleImportingContext ctx, Parameter source);
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory tf);
    [CompilerGeneratedAttribute]
public virtual bool get_IsParameterPack();
    public sealed virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportedTemplateFunctionSpecializationDeclaratorResolveEntity : CppImportedFunctionDeclaratorResolveEntity {
    private ICppFunctionDeclaratorResolveEntity myUngroupedPrimaryTemplate;
    public CppImportedTemplateFunctionSpecializationDeclaratorResolveEntity(ICppScopeResolveEntity parent, CppQualifiedNamePart name, CppModuleImportingContext importingContext, CppRegularFunctionModuleEntity source, ICppFunctionDeclaratorResolveEntity ungroupedPrimaryTemplate);
    public ICppFunctionDeclaratorResolveEntity GetUngroupedPrimaryTemplate();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportedTemplateVariableSpecializationDeclaratorResolveEntity : CppImportedVariableDeclaratorResolveEntity {
    private ICppVariableDeclaratorResolveEntity myUngroupedPrimaryTemplate;
    public CppImportedTemplateVariableSpecializationDeclaratorResolveEntity(ICppScopeResolveEntity parent, CppQualifiedNamePart name, CppModuleImportingContext importingContext, CppVariableModuleEntity source, ICppVariableDeclaratorResolveEntity ungroupedPrimaryTemplate);
    public ICppVariableDeclaratorResolveEntity GetUngroupedPrimaryTemplate();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportedTypeAliasResolveEntity : object {
    private ICppResolveEntityParent myParent;
    public CppTypeAliasModuleEntity Source;
    public CppModuleImportingContext ImportingContext;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppImportedTypeAliasResolveEntity(ICppResolveEntityParentScope parent, CppTypeAliasModuleEntity source, CppModuleImportingContext ctx);
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppQualType GetCppType(ICppResolvedTypeFactory tf);
    public sealed virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
    public sealed virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public sealed virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public sealed virtual CppAttributeList get_Attributes();
    public sealed virtual ICppResolveEntityParent get_RealParent();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    [CompilerGeneratedAttribute]
public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual CppGeneratedResolveEntityType GetEntityType();
    public virtual string ToString();
    public sealed virtual ICppTopLevelDeclaratorModuleEntity GetSource();
    public sealed virtual CppModuleImportingContext GetImportingContext();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportedVariableDeclaratorResolveEntity : object {
    public CppVariableModuleEntity Source;
    private CppDeclaratorInitializer myInitializer;
    public CppModuleImportingContext ImportingContext;
    private ICppScopeResolveEntity myParent;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CppAttributeList <Attributes>k__BackingField;
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppAttributeList Attributes { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public bool IsParameterPack { get; }
    public CppImportedVariableDeclaratorResolveEntity(ICppScopeResolveEntity parent, CppQualifiedNamePart name, CppModuleImportingContext ctx, CppVariableModuleEntity source);
    public sealed virtual ICppResolveEntityParent get_RealParent();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    [CompilerGeneratedAttribute]
public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual CppGeneratedResolveEntityType GetEntityType();
    public virtual string ToString();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    [CompilerGeneratedAttribute]
public sealed virtual CppAttributeList get_Attributes();
    public sealed virtual bool HasDefinition();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public sealed virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public sealed virtual bool get_IsParameterPack();
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual bool HasInitializer();
    public sealed virtual CppViewPos GetViewPosForEvaluation();
    public sealed virtual CppQualType GetCppType(ICppResolvedTypeFactory tf);
    public sealed virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
    public sealed virtual ICppTopLevelDeclaratorModuleEntity GetSource();
    public sealed virtual CppModuleImportingContext GetImportingContext();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportExportVisitorBase : CppAbstractExpressionVisitorWithDefaults`1<ICppExpression> {
    public sealed virtual ICppDesignator Visit(ICppMemberAccessDesignator source);
    public sealed virtual ICppDesignator Visit(ICppSubscriptDesignator source);
    public sealed virtual ICppRequiresExpressionItem Visit(ICppRequiresExpressionItemSimple source);
    public sealed virtual ICppRequiresExpressionItem Visit(ICppRequiresExpressionItemTypename source);
    public sealed virtual ICppRequiresExpressionItem Visit(ICppRequiresExpressionItemNested source);
    public sealed virtual ICppRequiresExpressionItem Visit(ICppRequiresExpressionItemCompound source);
    public sealed virtual CppUnknownEntityInfo Visit(CppInternalFailure info);
    public sealed virtual CppUnknownEntityInfo Visit(CppLookupFailure info);
    public sealed virtual CppUnknownEntityInfo Visit(CppUnknownArraySizeFailure info);
    public sealed virtual CppUnknownEntityInfo Visit(CppExpressionEvaluationFailure info);
    public sealed virtual CppUnknownEntityInfo Visit(CppRecursiveTypeCalculationFailure info);
    public sealed virtual CppUnknownEntityInfo Visit(CppStructuredBindingTypeDeductionFailure info);
    public sealed virtual CppUnknownEntityInfo Visit(CppInvalidStructuredBindingsInitializerClassFailure info);
    public sealed virtual CppUnknownEntityInfo Visit(CppInvalidFoldExpressionFailure info);
    public sealed virtual CppUnknownEntityInfo Visit(CppUnknownUE4TypeFailure info);
    public sealed virtual CppUnknownEntityInfo Visit(CppAggregateParenInitInfo info);
    public sealed virtual CppUnknownEntityInfo Visit(CppDeducedReturnTypeUsedBeforeFunctionDefinition info);
    public sealed virtual CppUnknownEntityInfo Visit(CppUnresolvedTypeInChangeSignature info);
    public sealed virtual CppUnknownEntityInfo Visit(CppUnknownEntityInfoWithReason info);
    public sealed virtual CppUnknownEntityInfo Visit(CppComparisonCategoryLookupFailure info);
    public sealed virtual CppUnknownEntityInfo Visit(CppGenericAsTemplargFailure info);
    public sealed virtual CppUnknownEntityInfo Visit(CppNonExpressionTemplateArgumentUsedAsExpressionFailure info);
    public sealed virtual CppUnknownEntityInfo Visit(CppInvalidNonTypeTemplateArgumentValueFailure info);
    public sealed virtual CppUnknownEntityInfo Visit(CppInvalidArgumentOfBuiltinTypeTraitFailure info);
    public sealed virtual CppUnknownEntityInfo Visit(CppSubstitutionFailure source);
    public sealed virtual CppUnknownEntityInfo Visit(CppInvalidTypeFailure source);
    public sealed virtual CppUnknownEntityInfo Visit(CppAutoTypeDeductionFailure source);
    public sealed virtual CppUnknownEntityInfo Visit(CppAutoTypeConstraintFailure source);
    public sealed virtual CppUnknownEntityInfo Visit(CppZeroOrNegativeArraySizeFailure source);
    public sealed virtual CppUnknownEntityInfo Visit(CppTypeConversionFailure source);
    public sealed virtual CppUnknownEntityInfo Visit(CppLinkageUnknownTypeFailure info);
    public sealed virtual CppUnknownEntityInfo Visit(CppInvalidNumberOfStructuredBindingsFailure source);
    public abstract virtual CppUnknownEntityInfo Visit(CppUnknownTemplateDeductionInfo source);
    public abstract virtual CppUnknownEntityInfo Visit(CppNontypeResolveEntityUsedAsTypeFailure source);
    public abstract virtual CppUnknownEntityInfo Visit(CppNontypeModuleEntityUsedAsTypeFailure source);
    public virtual CppQualType Visit(CppAutoType t, Qualifiers q);
    public virtual CppQualType Visit(CppResolvedAutoType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppArrayType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppVectorType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppFunctionType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppUnresolvedFunctionWithoutArgumentsType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppUnresolvedFunctionSingleArgumentType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppUnresolvedFunctionMultipleArgumentsType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppReplacedFunctionType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppNumericType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppPointerType t, Qualifiers q);
    public virtual CppQualType Visit(CppTemplateParameterType t, Qualifiers q);
    public virtual CppQualType Visit(CppGenericParameterType t, Qualifiers q);
    public virtual CppQualType Visit(CppPackExpansionType t, Qualifiers q);
    public virtual CppQualType Visit(CppDependentType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppTypeReference t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppElaboratedTypeReference t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppVoidType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppBuiltinTypeTraitType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppDecoratedBuiltinTypeTraitType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppClassType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppPendingClassType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppUnknownType t, Qualifiers q);
    public virtual CppQualType Visit(CppResolvedClassType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppNullptrType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppEnumType t, Qualifiers q);
    public virtual CppQualType Visit(CppResolvedEnumType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppDecoratedType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppMemberPointerType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppDeclarationSpecifierType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppCliHandleType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppCliInteriorPointerType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppCliPinPointerType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppCliArrayType t, Qualifiers q);
    public abstract virtual CppQualType Visit(CppDeducedClassTypePlaceholder t, Qualifiers q);
    public virtual CppQualType Visit(CppDependentInstantiatedTemplateAliasType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppLinkageEntityType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppDependentLinkageEntityType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppLinkageTemplateParameterType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppLinkageArrayType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppLinkageVectorType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppLinkageCliArrayType t, Qualifiers q);
    public sealed virtual CppQualType Visit(HlslVectorType t, Qualifiers q);
    public sealed virtual CppQualType Visit(HlslMatrixType t, Qualifiers q);
    public sealed virtual CppQualType Visit(HlslSamplerType t, Qualifiers q);
    public sealed virtual CppQualType VisitReference(CppQualType innerType, ReferenceFlag flag);
    public sealed virtual CppQualType VisitTypeWithDeclSpecPlacement(CppQualType innerType, CppDeclSpecPlacement placement);
    public virtual CppQualType Visit(CppTypedefType t, Qualifiers q);
    public virtual CppQualType Visit(CppInstantiatedTemplateAliasType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppCEnumeratorType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppNamedType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppNameSuggestionType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppScopeSuggestionType t, Qualifiers q);
    public abstract virtual CppQualType Visit(CppNamedParameterType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppFunctionWithTrailingReturnType t, Qualifiers q);
    public virtual CppQualType Visit(CppModuleEntityType t, Qualifiers q);
    public virtual CppQualType Visit(CppInstantiatedTemplateAliasModuleType t, Qualifiers q);
    public virtual CppQualType Visit(CppDependentInstantiatedTemplateAliasModuleType t, Qualifiers q);
    public virtual CppQualType Visit(CppTypedefModuleType t, Qualifiers q);
    public abstract virtual CppQualType Visit(CppDeducedClassTypePlaceholderModuleType t, Qualifiers q);
    public CppQualType ReApply(CppQualType t);
    public CppUnknownEntityInfo ReApply(CppUnknownEntityInfo info);
    public ICppExceptionSpecification ReApply(ICppExceptionSpecification exceptSpec);
    public ICppExpression ReApply(ICppExpression expr);
    public virtual ICppExpression VisitExpression(ICppExpression expr);
    public virtual ICppExpression Visit(ICppEmptyExpression empty);
    public virtual ICppExpression Visit(ICppResolvedLiteralExpression literalExpression);
    public virtual ICppExpression Visit(ICppMSAssumeExpression assume);
    public virtual ICppExpression Visit(ICppMSNoopExpression expr);
    public virtual ICppExpression Visit(ICppDeleteExpression deleteExpression);
    public virtual ICppExpression Visit(ICppDesignation designation);
    protected abstract virtual ICppDesignation CreateDesignation(ICppDesignator designator, ICppExpression initializer, ICppDesignation source);
    public virtual ICppExpression Visit(ICppResolvedBracedInitListExpression source);
    public virtual ICppExpression Visit(ICppResolvedThisExpression source);
    protected CppResolvedBracedInitListExpression ReApply(ICppResolvedBracedInitListExpression source);
    protected ICppTypeIdOrExpression ReApply(ICppTypeIdOrExpression source);
    protected ICppArgumentList ReApply(ICppArgumentList source);
    protected ICppExpression[] ReApply(ICppExpression[] sourceArgs);
    protected CppDeclaratorInitializer ReApply(CppDeclaratorInitializer source);
    protected CppSmallArray`1<ICppExpression> ReApply(CppSmallArray`1<ICppExpression> sourceArgs);
    protected ICppRequiresExpressionItem ReApply(ICppRequiresExpressionItem item);
    protected CppDependentAutoTypeResolveEntity ReApply(CppDependentAutoTypeResolveEntity csource);
    protected CppList`1<Element> ReApply(CppList`1<Element> source);
    protected CppLookupFailureTemplateArgument ReApply(CppLookupFailureTemplateArgument csource);
    protected CppConversionId ReApply(CppConversionId convId);
    protected CppDecltypeId ReApply(CppDecltypeId source);
    protected CppTypeOfTypeId ReApply(CppTypeOfTypeId source);
    protected ICppResolvedExpression ReApply(ICppLiteralValue literal);
    protected ICppEvaluationResult ReApply(ICppValue value);
    protected abstract virtual ICppResolvedTypeFactory GetTypeFactory();
    protected abstract virtual CppQualifiedName ReApply(CppQualifiedName name);
    protected abstract virtual ICppExpression ReApplyToTypeConstraint(ICppExpression e);
    protected abstract virtual ICppEvaluationResult ReApplyToEnumeratorValue(ICppEnumValue v);
    protected abstract virtual ICppEvaluationResult ReApplyToObjectValue(ICppObjectValue v);
    protected abstract virtual CppArrayValue ReApplyToArrayValue(CppArrayValue v);
    protected abstract virtual ICppEvaluationResult ReApplyToPointerValue(ICppPointerValue v);
    protected abstract virtual ICppEvaluationResult ReApplyToReferenceValue(ICppReferenceValue v);
    protected abstract virtual CppStringLiteralValue ReApplyToStringLiteral(CppStringLiteralValue v);
    protected CppSimpleArrayValue ReApply(CppSimpleArrayValue source);
    protected CppRLEArrayValue ReApply(CppRLEArrayValue source);
    protected CppPointerToArrayElement ReApply(CppPointerToArrayElement pointerToArrayElement);
    protected CppReferenceToArrayElement ReApply(CppReferenceToArrayElement referenceToArrayElement);
    protected CppNullPointer ReApply(CppNullPointer nullPtr);
    protected ICppEvaluationResult ReApply(ICppEvaluationResult source);
    private ICppDesignator ReApplyToQualifier(ICppDesignator designator);
    protected ICppAttribute ReApply(ICppAttribute source);
    private CppAttributeWithArgument`1<ICppExpression> ReApply(CppAttributeWithArgument`1<ICppExpression> source);
    private CppAttributeWithArgument`1<ICppTypeIdOrExpression> ReApply(CppAttributeWithArgument`1<ICppTypeIdOrExpression> source);
    private CppAttributeFormat ReApply(CppAttributeFormat source);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportHeaderUnitDirectiveSymbol : CppImportDirectiveSymbol {
    private CppFileLocation myTarget;
    public CppImportHeaderUnitDirectiveSymbol(CppSymbolLocation location, bool isExported, CppFileLocation target);
    public CppFileLocation GetTarget();
    public virtual string ToString();
    public virtual TResult Accept(ICppSymbolVisitor`1<TResult> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportModuleDirectiveSymbol : CppImportDirectiveSymbol {
    [CompilerGeneratedAttribute]
private CppModuleId <ModuleId>k__BackingField;
    public CppModuleId ModuleId { get; }
    public CppImportModuleDirectiveSymbol(CppSymbolLocation location, bool isExported, CppModuleId moduleId);
    [CompilerGeneratedAttribute]
public CppModuleId get_ModuleId();
    public virtual string ToString();
    public virtual TResult Accept(ICppSymbolVisitor`1<TResult> visitor);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppImportResult`1 : ValueType {
    private TEntity myEntity;
    public bool IsODRViolation { get; }
    public CppImportResult`1(TEntity entity);
    public static CppImportResult`1<TEntity> ODRViolation();
    public bool get_IsODRViolation();
    public TEntity GetEntity();
    public CppImportResult`1<TOtherEntity> Cast();
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppIncreaseIdent : ValueType {
    private CppIndentationStringBuilder myTW;
    private int myIncrease;
    public CppIncreaseIdent(CppIndentationStringBuilder tw, int increase);
    public sealed virtual void Dispose();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppIndentationStringBuilder : object {
    private StringBuilder myTW;
    private int myIdent;
    private bool myStartOfLine;
    public CppIndentationStringBuilder(StringBuilder tw);
    private CppIndentationStringBuilder(StringBuilder tw, int ident, bool startOfLine);
    public StringBuilder GetStringBuilder();
    public void Indent(int increase);
    public void Write(string text);
    public void Write(int text);
    public void WriteLine();
    public void WriteLine(string text);
    public CppIndentationStringBuilder Nested(StringBuilder tw);
    public void WriteNested(IEnumerable`1<string> text);
    private void PrintIdent();
    private void PrintEoln();
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppInheritanceUtil : object {
    public static TriBool IsVirtual(ICppGroupedFunctionDeclaratorResolveEntity ent);
    public static TriBool IsOverride(ICppGroupedFunctionDeclaratorResolveEntity ent);
    public static bool IsFinal(ICppDeclaratorResolveEntity ent);
    public static bool IsNew(ICppDeclaratorResolveEntity ent);
    public static IEnumerable`1<ICppResolveEntity> FindBaseResolveEntities(ICppResolveEntity ent);
    public static IEnumerable`1<ICppGroupedFunctionDeclaratorResolveEntity> FindPureFunctions(ICppClassResolveEntity ent);
    public static IEnumerable`1<ICppGroupedFunctionDeclaratorResolveEntity> FindOverridableFunctions(ICppClassResolveEntity ent);
    public static IEnumerable`1<ICppClassResolveEntity> FindBaseClasses(ICppClassResolveEntity classResolveEntity, CppQualType baseType);
    public static IEnumerable`1<ICppClassResolveEntity> FindBaseClasses(ICppClassResolveEntity classResolveEntity);
    public static IEnumerable`1<ICppClassResolveEntity> FindAllBases(ICppClassResolveEntity entity);
    public static IEnumerable`1<ICppClassResolveEntity> FindAllBases(ICppClassResolveEntity entity, Boolean& hasDependentBase);
    public static bool HasVirtualDestructor(ICppClassResolveEntity classEntity);
    public static CppList`1<ICppClassOrUndeterminedSpecializationResolveEntity> GetBasesThatNeedInitialization(ICppClassResolveEntity classEntity, CppViewPos& viewPos);
    public static IDictionary`2<ICppLinkageEntity, SearchTargetRole> FindDirectDerivedLinkageEntities(CppLinkageEntityCache cache, ICppLinkageEntity linkageEntity, IProgressIndicator pi);
    public static IDictionary`2<ICppLinkageEntity, SearchTargetRole> FindAllDerivedLinkageEntities(CppLinkageEntityCache cache, ICppLinkageEntity linkageEntity, IProgressIndicator pi);
    public static bool CanHaveDerivedEntities(ICppResolveEntity ent);
    public static bool CanHaveDerivedEntities(ICppLinkageEntity ent);
    public static bool CanHaveBaseEntities(ICppLinkageEntity ent);
    public static bool HasDerivedEntities(CppLinkageEntityCache cache, ICppLinkageEntity entity);
    public static IEnumerable`1<ICppLinkageEntity> FindAllBaseLinkageEntities(CppLinkageEntityCache linkageCache, ICppLinkageEntity linkageEntity, IProgressIndicator pi);
    public static ICppGroupedFunctionDeclaratorResolveEntity GetDerivedMethodEntity(ICppClassResolveEntity classEntity, ICppGroupedFunctionDeclaratorResolveEntity methodEntity);
    public static bool IsAbstract(ICppClassResolveEntity classEnt);
    public static bool ContainsVirtualFunctions(CppDeclaratorResolveEntityPack pack);
    public static bool CalculateIsPolymorphic(ICppClassResolveEntity classEntity);
    private static void FindBaseClasses(ICppClassResolveEntity classResolveEntity, CppBaseSpecifiers baseSpecs, CppQualType baseType, CppViewPos& viewPos, List`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> bases, Boolean& hasDependentBase);
    private static bool NeedsImplicitBase(List`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> bases, CppImplicitBasesType implicitBaseType);
    public static IEnumerable`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> FindBaseClassesIfComplete(ICppClassResolveEntity classResolveEntity, Boolean& hasDependentBase);
    private static IEnumerable`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> FindBaseClasses(ICppClassResolveEntity classResolveEntity, Boolean& hasDependentBase);
    private static IDictionary`2<ICppLinkageEntity, SearchTargetRole> FindDerivedLinkageEntitiesImpl(CppLinkageEntityCache linkageCache, ICppLinkageEntity linkageEntity, bool directInheritorsOnly, IProgressIndicator pi);
    private static TriBool IsVirtualFunctionWithoutCheckOfBases(ICppGroupedFunctionDeclaratorResolveEntity entity);
    private static TriBool CalcIsVirtual(ICppGroupedFunctionDeclaratorResolveEntity ent);
    private static TriBool CalcIsOverride(ICppGroupedFunctionDeclaratorResolveEntity ent);
    private static ICppClassOrUndeterminedSpecializationResolveEntity BaseTypeNeedsUserConstructor(CppQualType base, ICppClassResolveEntity derived, CppViewPos& viewPos);
    private static void FindAllBasesImpl(ICppClassResolveEntity classEntity, List`1<ICppClassResolveEntity> bases, HashSet`1<ICppClassResolveEntity> processedClasses, Boolean& hasDependentBase);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppInheritedConstructor : CppGeneratedFunctionDeclaratorResolveEntity {
    [CompilerGeneratedAttribute]
private ICppGroupedFunctionDeclaratorResolveEntity <BaseCtor>k__BackingField;
    public ICppGroupedFunctionDeclaratorResolveEntity BaseCtor { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppFunctionTraits Traits { get; }
    public CppAttributeList Attributes { get; }
    public CppInheritedConstructor(CppQualType type, ICppResolveEntity parent, ICppGroupedFunctionDeclaratorResolveEntity baseCtor, CppQualifiedNamePart name, CppLocationAnchor anchor);
    [CompilerGeneratedAttribute]
public ICppGroupedFunctionDeclaratorResolveEntity get_BaseCtor();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppFunctionTraits get_Traits();
    public virtual CppAttributeList get_Attributes();
    public virtual int GetFirstDefaultArgIndex();
    public virtual ICppParameterListResolveEntity GetMainParameterList();
    public virtual ICppResolvedExpression GetResolvedRequiresClause();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppInheritedConstructorModuleEntity : object {
    public ICppFunctionModuleEntity BaseCtor;
    public ICppClassOrRefClassModuleEntity Parent;
    public CppInheritedConstructorModuleEntity(ICppClassOrRefClassModuleEntity parent, ICppFunctionModuleEntity baseCtor);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public sealed virtual CppImportResult`1<ICppGroupedFunctionDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
    [CompilerGeneratedAttribute]
internal static bool <Import>g__InheritsFrom|8_0(ICppGroupedFunctionDeclaratorResolveEntity candidate, ICppGroupedFunctionDeclaratorResolveEntity baseCtor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppInitDeclaratorBuilder : CppBuilderWithParent {
    private CppDeclaratorResolveEntityBase myEntity;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public CppInitDeclaratorBuilder(ICppDeclaratorBuilder parent, CppDeclaratorResolveEntityBase entity);
    public virtual void AddChild(CppParserSymbol _);
    public virtual ICppScopeResolveEntity get_ResolveEntity();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppInjectedClassNameResolveEntity : object {
    private ICppClassResolveEntity myInner;
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppInjectedClassNameResolveEntity(ICppClassResolveEntity inner);
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public ICppClassResolveEntity GetInner();
    public sealed virtual bool Equals(object rhs);
    public sealed virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppInjectedClassNameTemplateArgument : object {
    public CppInjectedClassNameResolveEntity InjectedClassName;
    public CppInjectedClassNameTemplateArgument(CppInjectedClassNameResolveEntity injectedClassName);
    public sealed virtual Result Accept(Data data, ICppTemplateArgumentVisitor`2<Result, Data> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppInnerDeclaratorBuilder : object {
    private ICppInnerDeclaratorBuilder myDeclBuilder;
    private ICppUnresolvedTypeBuilder myUnresolvedTypeBuilder;
    private ICppResolvedTypeBuilder myReplacedTypeBuilder;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public CppInnerDeclaratorBuilder(ICppInnerDeclaratorBuilder declBuilder);
    public sealed virtual void AddChild(CppParserSymbol sym);
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    public sealed virtual ICppDeclaratorBuilder GetDeclaratorBuilder();
    public sealed virtual ICppUnresolvedTypeBuilder GetUnresolvedTypeBuilder();
    public sealed virtual ICppResolvedTypeBuilder GetReplacedTypeBuilder();
    public sealed virtual ICppFunctionParameterListBuilder CreateParameterListBuilder();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppInstantiateClassTemplateUtil : object {
    [ExtensionAttribute]
public static ICppScopeLikeResolveEntity InstantiateClassTemplate(ICppTypeTemplateResolveEntity ent, CppViewPos& viewPos, ICppTemplateArgument[] args);
    [ExtensionAttribute]
public static ICppScopeLikeResolveEntity InstantiateClassTemplate(ICppTypeTemplateResolveEntity ent, CppViewPos& viewPos, ReadOnlySpan`1<ICppTemplateArgument> args);
    [ExtensionAttribute]
public static ICppClassOrUndeterminedSpecializationResolveEntity InstantiateClassTemplate(CppClassTemplateResolveEntityPack pack, CppViewPos& viewPos, ReadOnlySpan`1<ICppTemplateArgument> args);
    [ExtensionAttribute]
public static CppTemplateTemplateParameterWithAppliedArgumentsResolveEntity InstantiateClassTemplate(ICppTemplateTemplateParameterOrPack ent, CppViewPos& viewPos, ReadOnlySpan`1<ICppTemplateArgument> args);
    [ExtensionAttribute]
public static CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity InstantiateClassTemplate(ICppTypeTemplateDeclaratorResolveEntity ent, CppViewPos& viewPos, ReadOnlySpan`1<ICppTemplateArgument> args);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppInstantiationStatus : Enum {
    public int value__;
    public static CppInstantiationStatus IN_PROGRESS;
    public static CppInstantiationStatus DONE;
    public static CppInstantiationStatus INFINITE_RECURSION;
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppIntegerPackUtil : object {
    public static CppQualifiedId Name;
    private static int MaxLength;
    private static CppIntegerPackUtil();
    public static bool IsIntegerPack(ICppResolvedExpression expr, CppTypeContext& tc, ICppResolvedExpression& countArg);
    public static bool Unpack(ICppResolvedExpression countExpr, CppTypeContext& tc, CppList`1& result);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppInvalidResolveEntityParent : object {
    private ICppScopeResolveEntity myLexicalParent;
    public CppInvalidResolveEntityParent(ICppScopeResolveEntity lexicalParent);
    public ICppScopeResolveEntity GetLexicalParent();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppInvalidResolveEntityParentScope : CppInvalidResolveEntityParent {
    public CppInvalidResolveEntityParentScope(ICppScopeResolveEntity lexicalParent);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppInventedConceptTypeTemplateParameter : CppInventedTypeTemplateParameter {
    private CppQualifiedName myConceptName;
    private CppViewPos myViewPos;
    private CppCachedReference`1<CppConceptDefinitionResolveEntity> myResolvedConcept;
    private CppCachedReference`1<ICppResolvedExpression> myResolvedConceptExpression;
    public CppInventedConceptTypeTemplateParameter(CppViewPos& viewPos, CppQualifiedName conceptName);
    public virtual CppViewPos GetViewPos();
    public virtual CppQualifiedName GetReplacedConceptName();
    public sealed virtual CppQualifiedName CalculateResolvedConceptNameHint();
    public virtual bool IsConcept();
    public virtual CppConceptDefinitionResolveEntity GetResolvedConcept();
    public virtual ICppResolvedExpression GetResolvedConceptExpression();
    public sealed virtual void Journaling_RollbackCachedConcept();
    public sealed virtual void Journaling_RollbackCachedConceptExpression();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppInventedConceptTypeTemplateParameterPack : CppInventedTypeTemplateParameterPack {
    private CppQualifiedName myConceptName;
    private CppViewPos myViewPos;
    private CppCachedReference`1<CppConceptDefinitionResolveEntity> myResolvedConcept;
    private CppCachedReference`1<ICppResolvedExpression> myResolvedConceptExpression;
    public CppInventedConceptTypeTemplateParameterPack(CppViewPos& viewPos, CppQualifiedName conceptName);
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppQualifiedName GetReplacedConceptName();
    public sealed virtual CppQualifiedName CalculateResolvedConceptNameHint();
    public virtual bool IsConcept();
    public sealed virtual CppConceptDefinitionResolveEntity GetResolvedConcept();
    public virtual ICppResolvedExpression GetResolvedConceptExpression();
    public sealed virtual void Journaling_RollbackCachedConcept();
    public sealed virtual void Journaling_RollbackCachedConceptExpression();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppInventedTypeTemplateParameter : CppInventedTypeTemplateParameterBase {
    public CppInventedTypeTemplateParameter(ICppFileResolveEntitiesCache resolveCache);
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppInventedTypeTemplateParameterBase : object {
    private ICppFileResolveEntitiesCache myResolveCache;
    private CppTemplateParameterTag myTag;
    public CppDependentInfo DependentInfo { get; }
    public CppTypeTemplateParameterKey Key { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    protected CppInventedTypeTemplateParameterBase(ICppFileResolveEntitiesCache resolveCache);
    protected CppInventedTypeTemplateParameterBase(CppInventedTypeTemplateParameterBase other);
    public virtual ICppFileResolveEntitiesCache GetResolveCache();
    public virtual ICppTemplateArgument GetDefault(ICppResolvedTypeFactory tf);
    public virtual CppTemplateParameterTag GetTag();
    public virtual void ReplaceTag(CppTemplateParameterTag tag);
    public virtual CppDependentInfo get_DependentInfo();
    public virtual CppTypeTemplateParameterKey get_Key();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public virtual bool NameEquals(CppQualifiedNamePart name);
    public virtual bool IsConcept();
    public virtual bool IsInvented();
    public virtual ICppResolvedExpression GetResolvedConceptExpression();
    public virtual ICppSymbol GetSymbol();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    public abstract virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public abstract virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver driver);
    public abstract virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver driver);
    public virtual FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppInventedTypeTemplateParameterPack : CppInventedTypeTemplateParameterBase {
    public CppInventedTypeTemplateParameterPack(CppInventedTypeTemplateParameterBase base);
    public CppInventedTypeTemplateParameterPack(ICppFileResolveEntitiesCache resolveCache);
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual ICppTemplateArgumentPack CreateEmptyMatchingArgumentPack();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppIsHidingScopeEntityVisitor : object {
    public sealed virtual bool Visit(ICppClassResolveEntity e);
    public sealed virtual bool Visit(ICppStatementResolveEntity ent);
    public sealed virtual bool Visit(ICppRequiresExpressionScopeResolveEntity ent);
    public sealed virtual bool Visit(CppRequiresExpressionItemResolveEntity ent);
    public sealed virtual bool Visit(ICppParameterListResolveEntity e);
    public sealed virtual bool Visit(ICppDeclaratorResolveEntity e);
    public sealed virtual bool Visit(ICppConceptDefinitionResolveEntity e);
    public sealed virtual bool Visit(ICppEnumeratorResolveEntity e);
    public sealed virtual bool Visit(CppNamespaceResolveEntity e);
    public sealed virtual bool Visit(CppNamespaceAliasResolveEntity e);
    public sealed virtual bool Visit(CppUsingDeclarationResolveEntity e);
    public sealed virtual bool Visit(CppClassTemplateResolveEntityPack e);
    public sealed virtual bool Visit(ICppTypeTemplateParameter e);
    public sealed virtual bool Visit(ICppTypeTemplateParameterPack e);
    public sealed virtual bool Visit(ICppExpressionTemplateParameter e);
    public sealed virtual bool Visit(ICppExpressionTemplateParameterPack e);
    public sealed virtual bool Visit(ICppTemplateTemplateParameter e);
    public sealed virtual bool Visit(ICppTemplateTemplateParameterPack e);
    public sealed virtual bool Visit(ICppGenericParameter e);
    public sealed virtual bool Visit(CppDependentResolveEntity e);
    public sealed virtual bool Visit(CppDependentDecltypeResolveEntity e);
    public sealed virtual bool Visit(CppDependentAutoTypeResolveEntity e);
    public sealed virtual bool Visit(CppDependentFunctionReturnAutoTypeResolveEntity e);
    public sealed virtual bool Visit(CppDependentDeducedClassTypePlaceholder e);
    public sealed virtual bool Visit(CppUsingDeclarationResolveEntityWithSubstitution e);
    public sealed virtual bool Visit(CppUndeterminedSpecializationResolveEntity e);
    public sealed virtual bool Visit(CppTemplateTemplateParameterWithAppliedArgumentsResolveEntity e);
    public sealed virtual bool Visit(CppSuperResolveEntity e);
    public sealed virtual bool Visit(AbstractBuiltinResolveEntity e);
    public sealed virtual bool Visit(ICppDeclaratorResolveEntityPack e);
    public sealed virtual bool Visit(CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity e);
    public sealed virtual bool Visit(CppUndeterminedTemplateVariableSpecializationResolveEntity e);
    public sealed virtual bool Visit(ICppFunctionTemplateDeclaratorResolveEntity e);
    public sealed virtual bool Visit(ICppTypeTemplateDeclaratorResolveEntity e);
    public sealed virtual bool Visit(ICppVariableTemplateDeclaratorResolveEntity e);
    public sealed virtual bool Visit(CppDecltypeResolveEntity e);
    public sealed virtual bool Visit(CppTypeOfTypeResolveEntity e);
    public sealed virtual bool Visit(CppDependencyKillerResolveEntity e);
    public sealed virtual bool Visit(ICppCxxCliPropertySetResolveEntity e);
    public sealed virtual bool Visit(ICppDeductionGuide e);
    public sealed virtual bool Visit(CppUsingEnumEnumeratorResolveEntity e);
    public sealed virtual bool Visit(HlslBuiltinFunctionResolveEntity e);
    public sealed virtual bool Visit(BlockShadersResolveEntity e);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppIsSubstitutionFailureResolveEntityVisitor : object {
    public static CppIsSubstitutionFailureResolveEntityVisitor Instance;
    private static CppIsSubstitutionFailureResolveEntityVisitor();
    public sealed virtual bool Visit(ICppClassResolveEntity e);
    public sealed virtual bool Visit(ICppStatementResolveEntity e);
    public sealed virtual bool Visit(ICppRequiresExpressionScopeResolveEntity e);
    public sealed virtual bool Visit(CppRequiresExpressionItemResolveEntity e);
    public sealed virtual bool Visit(ICppParameterListResolveEntity e);
    public sealed virtual bool Visit(ICppDeclaratorResolveEntity e);
    public sealed virtual bool Visit(ICppConceptDefinitionResolveEntity e);
    public sealed virtual bool Visit(ICppEnumeratorResolveEntity e);
    public sealed virtual bool Visit(CppNamespaceResolveEntity e);
    public sealed virtual bool Visit(CppNamespaceAliasResolveEntity e);
    public sealed virtual bool Visit(CppUsingDeclarationResolveEntity e);
    public sealed virtual bool Visit(CppClassTemplateResolveEntityPack e);
    public sealed virtual bool Visit(ICppTypeTemplateParameter e);
    public sealed virtual bool Visit(ICppTypeTemplateParameterPack e);
    public sealed virtual bool Visit(ICppExpressionTemplateParameter e);
    public sealed virtual bool Visit(ICppExpressionTemplateParameterPack e);
    public sealed virtual bool Visit(ICppTemplateTemplateParameter e);
    public sealed virtual bool Visit(ICppTemplateTemplateParameterPack e);
    public sealed virtual bool Visit(ICppGenericParameter e);
    public sealed virtual bool Visit(CppDependentResolveEntity e);
    public sealed virtual bool Visit(CppDependentDecltypeResolveEntity e);
    public sealed virtual bool Visit(CppDependentAutoTypeResolveEntity e);
    public sealed virtual bool Visit(CppDependentFunctionReturnAutoTypeResolveEntity e);
    public sealed virtual bool Visit(CppDependentDeducedClassTypePlaceholder e);
    public sealed virtual bool Visit(CppUsingDeclarationResolveEntityWithSubstitution e);
    public sealed virtual bool Visit(CppUndeterminedSpecializationResolveEntity e);
    public sealed virtual bool Visit(CppTemplateTemplateParameterWithAppliedArgumentsResolveEntity e);
    public sealed virtual bool Visit(CppUndeterminedTemplateVariableSpecializationResolveEntity e);
    public sealed virtual bool Visit(CppDecltypeResolveEntity e);
    public sealed virtual bool Visit(CppTypeOfTypeResolveEntity e);
    public sealed virtual bool Visit(ICppDeclaratorResolveEntityPack e);
    public sealed virtual bool Visit(CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity e);
    public sealed virtual bool Visit(CppSuperResolveEntity e);
    public sealed virtual bool Visit(AbstractBuiltinResolveEntity e);
    public sealed virtual bool Visit(ICppFunctionTemplateDeclaratorResolveEntity e);
    public sealed virtual bool Visit(ICppTypeTemplateDeclaratorResolveEntity e);
    public sealed virtual bool Visit(ICppVariableTemplateDeclaratorResolveEntity e);
    public sealed virtual bool Visit(CppDependencyKillerResolveEntity e);
    public sealed virtual bool Visit(ICppCxxCliPropertySetResolveEntity e);
    public sealed virtual bool Visit(ICppDeductionGuide e);
    public sealed virtual bool Visit(CppUsingEnumEnumeratorResolveEntity e);
    public sealed virtual bool Visit(HlslBuiltinFunctionResolveEntity e);
    public sealed virtual bool Visit(BlockShadersResolveEntity e);
    public bool ReApply(ICppResolveEntity ent);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppJournal : object {
    private CppNoConcurrencyChecker myCc;
    private List`1<ICppJournalEntry> myLog;
    private CppJournal myParent;
    private bool myValid;
    public CppJournal(CppJournal parent);
    public CppJournal GetParent();
    public void Add(ICppJournalEntry entry);
    public void Rollback();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppJournalContainerEntries : object {
    [ExtensionAttribute]
public static void JournalingListAddItem(ICppResolveEntity rent, List`1<T> list, U item);
    [ExtensionAttribute]
public static void JournalingListAddRange(ICppResolveEntity rent, List`1<T> list, IEnumerable`1<T> range);
    [ExtensionAttribute]
public static void JournalingDictAddItem(ICppResolveEntity rent, Dictionary`2<K, V> dict, K key, V2 value);
    [ExtensionAttribute]
public static V JournalingConcurrentDictAddItem(ICppResolveEntity rent, ConcurrentDictionary`2<K, V> dict, K key, V value);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppJournalUtil : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static CppJournal GetJournal(ICppResolveEntity e);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLambdaAssignmentOperatorPack : object {
    public static int CopyIndex;
    public static int MoveIndex;
    private ICppClassResolveEntity myLambda;
    private CppGroupedFunctionDeclaratorResolveEntity[] myGroupedDeclarators;
    public ICppResolveEntityParent RealParent { get; }
    public CppGroupedFunctionDeclaratorResolveEntity[] GroupedDeclarators { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLambdaAssignmentOperatorPack(ICppClassResolveEntity lambda, ICppResolvedTypeFactory tf);
    public ICppResolveEntityParent get_RealParent();
    public sealed virtual void Dump(CppIndentationStringBuilder out);
    public sealed virtual void ForceMerge(CppLocationAnchor anchor);
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetGroupedEntities();
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetGroupedEntities(CppLocationAnchor anchor);
    public CppGroupedFunctionDeclaratorResolveEntity[] get_GroupedDeclarators();
    public sealed virtual void AppendGroupedEntities(CppLocationAnchor anchor, FrugalLocalList`1& result);
    public sealed virtual void AppendGroupedEntities(CppLocationAnchor anchor, List`1<ICppResolveEntity> result);
    public sealed virtual ICppGroupedDeclaratorResolveEntity FindGroupedDeclarator(ICppDeclaratorResolveEntity ungrouped);
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual string ToString();
    private static CppGroupedFunctionDeclaratorResolveEntity CreateLambdaAssignmentOperator(ICppClassResolveEntity lambda, CppQualType classType, CppQualType paramType, CppCallingConvention callingConvention, CppRestrictionSpecifiers restrictionSpecifiers, CppLocationAnchor anchor, ICppResolvedTypeFactory tf);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLambdaBodyBuilder : CppCompoundStatementBuilderBase {
    private CppLambdaBodyResolveEntity myResolveEntity;
    private CppLocationAnchor myStartAnchor;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public CppLambdaBodyBuilder(ICppBuilder parent, CppSymbolLocation loc, bool isLambdaGeneric);
    public virtual ICppScopeResolveEntity get_ResolveEntity();
    public virtual CppScopeStatementResolveEntity GetResolveEntity();
    public CppLambdaBodyResolveEntity GetLambdaBodyResolveEntity();
    public int GetAnchorDelta();
    private static int AnchorDelta(CppLocationAnchor a, CppLocationAnchor b);
    public virtual void AddGotoStatement(CppComplexOffset loc, CppGotoStatementKind kind);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLambdaBodyResolveEntity : CppCompoundStatementResolveEntity {
    private ICppFunctionDeclaratorResolveEntity myFunction;
    private CppQualType myReplacedFunctionType;
    [CompilerGeneratedAttribute]
private bool <IsLambdaGeneric>k__BackingField;
    public bool IsLambdaGeneric { get; }
    public ICppFunctionDeclaratorResolveEntity Function { get; }
    public CppLambdaBodyResolveEntity(ICppScopeResolveEntity parentScope, bool isLambdaGeneric);
    [CompilerGeneratedAttribute]
public bool get_IsLambdaGeneric();
    public sealed virtual ICppFunctionDeclaratorResolveEntity get_Function();
    public sealed virtual CppQualType GetResolvedFunctionReturnType(ICppResolvedTypeFactory tf);
    public void Set(ICppFunctionDeclaratorResolveEntity function, CppQualType replacedFunctionType);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLambdaBuilder : object {
    private CppLambdaSymbol mySymbol;
    private CppLambdaScopeResolveEntity myLambdaScopeResolveEntity;
    private CppLambdaClassResolveEntity myClassResolveEntity;
    private ICppBuilder myParent;
    private CppLambdaDeclaratorParameterListBuilder myParamListBuilder;
    private CppUnresolvedTypeBuilder myUnresolvedTypeBuilder;
    private CppResolvedTypeBuilder myReplacedTypeBuilder;
    private ICppExpression myReplacedRequiresClause;
    private CppAttributeListBuilder myAttributesBuilder;
    public CppLambdaBuilder(ICppBuilder parent, CppSymbolLocation location);
    public CppLambdaSymbol GetSymbol();
    public CppLambdaScopeResolveEntity GetLambdaScope();
    public CppLambdaClassResolveEntity GetClassResolveEntity();
    public ICppBuilder GetParent();
    public void LearnThisCaptured();
    public void LearnThisByValueCaptured();
    public void LearnAllByValueCaptured();
    public void LearnAllByRefCaptured();
    public void LearnCapture(ICppLambdaCapture cap);
    public void LearnAttributes(CppAttributeListBuilder attributeListBuilder);
    public void LearnParameterList(CppLambdaDeclaratorParameterListBuilder paramListBuilder);
    public void LearnRequiresClause(ICppExpression unresolved, ICppExpression replaced);
    public void Finish(CppLambdaBodyBuilder bodyBuilder);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLambdaClassParenOperator : object {
    private CppLambdaClassResolveEntity myParent;
    private CppQualType myReplacedType;
    private CppViewPos myViewPosForParamsResolve;
    [CanBeNullAttribute]
private CppLambdaBodyResolveEntity myBody;
    private ICppExpression myReplacedRequiresClause;
    private ICppResolvedExpression myCachedResolvedRequiresClause;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CppDeclarationSpecifiers <DeclarationSpecifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private CppAttributeList <Attributes>k__BackingField;
    public CppFunctionTraits Traits { get; }
    public ICppFunctionBodyResolveEntity Body { get; }
    public int BodyChameleonVersion { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppQualifiedNamePart Name { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public CppLambdaClassParenOperator(CppQualifiedNamePart name, CppQualType replacedType, CppLambdaClassResolveEntity parent, ICppScopeResolveEntity scope, CppLambdaBodyResolveEntity body, CppDeclarationSpecifiers declarationSpecifiers, ICppExpression requiresClause, CppAttributeList replacedAttributes);
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetResolvedCxxCliOverrideSpecifierTargets();
    public sealed virtual ICppResolvedExpression GetResolvedRequiresClause();
    public sealed virtual CppFunctionTraits get_Traits();
    public sealed virtual ICppFunctionBodyResolveEntity get_Body();
    public sealed virtual int get_BodyChameleonVersion();
    public sealed virtual ICppParameterListResolveEntity GetMainParameterList();
    public sealed virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public sealed virtual int GetFirstDefaultArgIndex();
    public sealed virtual ICppResolveEntityParent get_RealParent();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    [CompilerGeneratedAttribute]
public sealed virtual CppQualifiedNamePart get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public sealed virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    [CompilerGeneratedAttribute]
public sealed virtual CppAttributeList get_Attributes();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public sealed virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public sealed virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
    public CppQualType GetReplacedType();
    private CppParameterListResolveEntity GetParameterListImpl();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLambdaClassResolveEntity : object {
    private CppLambdaSymbol mySymbol;
    private ICppResolveEntity myParent;
    private CppLocationAnchor myLocationAnchor;
    private CppDeclaratorResolveEntityPack myParenOperator;
    private CppLambdaScopeResolveEntity myScope;
    private ICppDeclaratorResolveEntityPack myConstructors;
    private CppDeclaratorResolveEntityPack myConversions;
    private ICppDeclaratorResolveEntityPack myAssignmentOperators;
    private bool myIsCaptureLess;
    public CppDependentInfo DependentInfo { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppLambdaClassResolveEntity(CppLambdaSymbol symbol, ICppResolveEntity parent, CppLocationAnchor anchor, CppLambdaScopeResolveEntity scope);
    public sealed virtual ICppDefinitionClassSymbol GetDefinitionSymbol();
    public sealed virtual bool HasDefinition();
    public sealed virtual bool Exported();
    public sealed virtual CppClassKey GetKey();
    public sealed virtual CppClassTag GetTag();
    public sealed virtual CppClassVirtualSpecifiers GetClassVirtualSpecifiers();
    public sealed virtual bool HasAbstractSpecifier();
    public sealed virtual bool IsFinal();
    public sealed virtual bool IsSealed();
    public sealed virtual bool IsFinalOrSealed();
    public sealed virtual bool IsAnonymousClass();
    public sealed virtual bool IsAbstract();
    public sealed virtual bool IsPolymorphic();
    public sealed virtual bool HasVirtualDestructor();
    public bool IsTriviallyCopyable(CppViewPos& vp);
    public bool HasTrivialDestructor(CppViewPos& vp);
    public bool HasNothrowDestructor(CppViewPos& vp);
    public bool IsTrivial(CppViewPos& vp);
    public bool IsStandardLayout(CppViewPos& vp);
    public bool IsPOD(CppViewPos& vp);
    public bool HasUniqueObjectRepresentations(CppViewPos& vp);
    public sealed virtual bool HasTrivialConstructor();
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetClassConstructors();
    public sealed virtual CppQualType GetEnumUnderlyingType();
    public sealed virtual CppBasicBaseDescription`1[] GetBases();
    public sealed virtual ICppDeclaratorResolveEntityPack GetConversions();
    public sealed virtual ICppDeclaratorResolveEntityPack GetConstructors();
    public sealed virtual ICppDeclaratorResolveEntityPack GetStaticConstructors();
    public sealed virtual ICppDeclaratorResolveEntityPack GetDestructors();
    public sealed virtual ICppDeclaratorResolveEntityPack GetCliFinalizers();
    public IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity> GetClassConversions(CppViewPos& vp);
    public ICppTemplateArgument[] GetDefaultTemplateArguments(CppViewPos& vp);
    public sealed virtual CppSmallList`1<ICppFunctionDeclaratorResolveEntity> GetFriendFunctions(CppQualifiedNamePart name);
    public sealed virtual ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppFunctionDeclaratorResolveEntity>> GetFriendFunctions();
    public sealed virtual CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity> GetFriendClasses(CppQualifiedNamePart name);
    public sealed virtual ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity>> GetFriendClasses();
    public sealed virtual CppSmallList`1<ICppDependentTypeResolveEntity> GetFriendDependentTypes();
    public sealed virtual CppList`1<ICppResolveEntity> GetAggregateMembers();
    public sealed virtual List`1<ICppResolveEntity> GetAllMembersSorted();
    public sealed virtual bool HasImmediateVirtualFunctions();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasFixedEnumUnderlyingType();
    public sealed virtual bool HasInheritingConstructors();
    public sealed virtual CppViewPos GetScopeForBaseClasses(ICppClassSymbol sym);
    public sealed virtual CppLocationAnchor GetAnchorBySymbol(ICppClassOrDelegateSymbol sym);
    public sealed virtual CppLocationAnchor GetDefinitionLocationAnchor();
    public sealed virtual bool IsEndLocationAnchorSet();
    public sealed virtual CppLocationAnchor GetEndLocationAnchor();
    public sealed virtual CppSmallList`1<ICppDeclaratorResolveEntityPack> GetAnonymousSubclassMembers(CppQualifiedNamePart name);
    public ICppGroupedTypeDeclaratorResolveEntity GetAssociatedTypedefForClass(CppViewPos& vp);
    public sealed virtual CppAttributeList GetAttributes();
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public sealed virtual CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> GetNonDependentBases();
    public sealed virtual void AddChild(ICppResolveEntity e);
    public sealed virtual void RemoveChild(ICppResolveEntity e);
    public sealed virtual CppSmallList`1<ICppResolveEntity> ChildByName(CppQualifiedNamePart name, CppLocationAnchor anchor);
    public sealed virtual CppList`1<ICppResolveEntity> GetChildren();
    public sealed virtual void AddAnonymousClass(ICppClassResolveEntity e);
    public sealed virtual CppList`1<ICppClassResolveEntity> AnonymousClasses();
    public sealed virtual bool IsTemplateInstantiation();
    public sealed virtual ICppTemplateResolveEntity GetTemplate();
    public sealed virtual ICppTemplateArgument[] GetArguments();
    public sealed virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver driver);
    public sealed virtual CppDependentInfo get_DependentInfo();
    public sealed virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver driver);
    public sealed virtual ICppResolveEntityParent get_RealParent();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual bool ContainsSymbol(ICppClassOrDelegateSymbolOrModuleEntity _);
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public CppLambdaScopeResolveEntity GetScope();
    public ICppDeclaratorResolveEntityPack GetAssignmentOperators();
    public virtual string ToString();
    public ICppGroupedFunctionDeclaratorResolveEntity GetGroupedParenOperator();
    public ICppFunctionOrTemplateDeclaratorResolveEntity GetGroupedParenOperatorOrTemplate();
    public void SetParenOperator(CppQualType replacedSignature, CppTemplateParametersBase templParams, ICppScopeResolveEntity scope, CppLambdaBodyResolveEntity body, ICppExpression requiresClause, CppAttributeList replacedAttributes);
    public void SetParenOperator(ICppFunctionDeclaratorResolveEntity parenOp);
    public bool IsCaptureLess();
    public void SetCaptureLess(bool isCaptureLess);
    public CppLambdaClassParenOperator GetParenOperator();
    public CppLambdaSymbol GetSymbol();
    public void Dump(CppIndentationStringBuilder tw);
    private CppDeclaratorResolveEntityPack CreateConversions(ICppFileResolveEntitiesCache resolveCache);
    private static ICppFunctionOrTemplateDeclaratorResolveEntity CreateConversion(ICppResolvedTypeFactory tf, CppLambdaClassResolveEntity lambda, CppQualType signature, CppTemplateParametersBase templateParams, CppCallingConvention memberCallingConvention, CppCallingConvention callingConvention, CppRestrictionSpecifiers restrictionSpecifiers, CppLocationAnchor anchor);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.IsTriviallyCopyable(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.HasTrivialDestructor(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.HasNothrowDestructor(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.IsTrivial(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.IsStandardLayout(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.IsPOD(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.HasUniqueObjectRepresentations(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    private sealed virtual override IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.GetClassConversions(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    private sealed virtual override ICppTemplateArgument[] JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.GetDefaultTemplateArguments(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    private sealed virtual override ICppGroupedTypeDeclaratorResolveEntity JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.GetAssociatedTypedefForClass(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLambdaClassResolveEntityUtil : object {
    [ExtensionAttribute]
public static bool IsCapturelessLambda(ICppClassResolveEntity lambda);
    [ExtensionAttribute]
public static bool LambdaHasDefaultConstructorAndAssignmentOperator(ICppClassResolveEntity lambda, CppLanguageDialect dialect);
    public static ICppTemplateArgument[] GetTemplateArguments(List`1<ICppTemplateParameter> lambdaTemplateDependencies, ICppClassResolveEntityWithSubstitution substitutedLambda);
    public static CppLambdaScopeResolveEntity GetLambdaScope(ICppClassResolveEntity clazz);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLambdaConstructorDeclaratorPack : object {
    private ICppClassResolveEntity myLambda;
    private CppGroupedFunctionDeclaratorResolveEntity[] myGroupedDeclarators;
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLambdaConstructorDeclaratorPack(ICppClassResolveEntity lambda, ICppResolvedTypeFactory tf);
    public sealed virtual void Dump(CppIndentationStringBuilder out);
    public ICppResolveEntityParent get_RealParent();
    public sealed virtual void ForceMerge(CppLocationAnchor anchor);
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetGroupedEntities();
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetGroupedEntities(CppLocationAnchor anchor);
    public sealed virtual void AppendGroupedEntities(CppLocationAnchor anchor, FrugalLocalList`1& result);
    public sealed virtual void AppendGroupedEntities(CppLocationAnchor anchor, List`1<ICppResolveEntity> result);
    public sealed virtual ICppGroupedDeclaratorResolveEntity FindGroupedDeclarator(ICppDeclaratorResolveEntity ungrouped);
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual string ToString();
    public CppGroupedFunctionDeclaratorResolveEntity GetCopyCtor();
    public CppGroupedFunctionDeclaratorResolveEntity GetMoveCtor();
    private static CppViewPos GetViewPos(ICppGroupedVariableDeclaratorResolveEntity var);
    private static CppGroupedFunctionDeclaratorResolveEntity CreateCtor(ICppClassResolveEntity lambda, CppQualType classType, CppQualType[] paramTypes, CppCallingConvention callingConvention, CppRestrictionSpecifiers restrictionSpecifiers, CppLocationAnchor anchor, bool isDeleted, ICppResolvedTypeFactory tf);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLambdaDeclaratorParameterListBuilder : CppBuilderWithParent {
    private CppParameterListResolveEntity myResolveEntity;
    private CppList`1<CppParameterDeclaratorSymbol> myParameterSymbols;
    private CppQualType myUnresolvedTrailingReturnType;
    private CppQualType myReplacedTrailingReturnType;
    private CppRestrictionSpecifiers myRestrictionSpecifiers;
    private ICppExceptionSpecification myUnresolvedExceptionSpecification;
    private ICppExceptionSpecification myReplacedExceptionSpecification;
    private bool myIsMutable;
    private bool myIsConstexpr;
    private bool myIsConsteval;
    private bool myIsStatic;
    private bool myExplicitThis;
    private CppEllipsisKind myEllipsisKind;
    private Result myTemplateParameters;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public CppLambdaDeclaratorParameterListBuilder(CppLambdaBuilder parent);
    public virtual void AddChild(CppParserSymbol sym);
    public virtual ICppScopeResolveEntity get_ResolveEntity();
    public void LearnTemplateHeader(CppTemplateHeaderBuilder builder);
    public sealed virtual void LearnAutoParameter(ICppTypeTemplateParameterOrPack param);
    public sealed virtual void LearnExplicitThis();
    public sealed virtual void LearnEllipsis(CppEllipsisKind kind);
    public sealed virtual void LearnRestrictionSpecifier(CppRestrictionSpecifiers specifiers);
    public sealed virtual ICppDeclarationBuilder CreateDeclarationBuilderForParameter(CppBuilderPool pool);
    public sealed virtual void LearnParameter(ICppDeclarationBuilder declarationBuilder);
    public sealed virtual void LearnEndAnchor();
    public sealed virtual void LearnKnRStyleParamsStart();
    public sealed virtual CppEllipsisKind GetEllipsisKind();
    public sealed virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public sealed virtual FuncRefQualifier GetFunctionRefQualifier();
    public sealed virtual CppParameterListResolveEntity GetResolveEntity();
    public sealed virtual CppList`1<CppParameterDeclaratorSymbol> GetParameterSymbols();
    public sealed virtual ICppDeclarationBuilder CreateDeclarationBuilderForTrailingReturnType();
    public sealed virtual void LearnTrailingReturnStartAnchor();
    public sealed virtual void LearnTrailingReturnType(ICppDeclarationBuilder declBuilder);
    public sealed virtual CppQualType GetUnresolvedTrailingReturnType();
    public sealed virtual CppQualType GetReplacedTrailingReturnType();
    public sealed virtual ICppExceptionSpecificationBuilder CreateExceptionSpecificationBuilder(CppComplexOffset _);
    public sealed virtual void LearnExceptionSpecification(CppComplexOffset _, ICppExceptionSpecificationBuilder builder);
    public sealed virtual ICppExceptionSpecification GetUnresolvedExceptionSpecification();
    public sealed virtual ICppExceptionSpecification GetReplacedExceptionSpecification();
    public sealed virtual bool HasOnlyParamsWithImplicitInt();
    public sealed virtual bool IsKnRParamListStarted();
    public sealed virtual void LearnMutable();
    public bool IsMutable();
    public sealed virtual void LearnConstexpr();
    public sealed virtual void LearnConsteval();
    public sealed virtual void LearnStatic();
    public bool IsConstexpr();
    public bool IsConsteval();
    public bool IsStatic();
    [CanBeNullAttribute]
public CppTemplateParameterSymbols GetTemplateParameterSymbols();
    [CanBeNullAttribute]
public CppTemplateParametersBase GetTemplateParameters();
    public void Finish();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLambdaId : object {
    public static CppLambdaId INSTANCE;
    private static CppLambdaId();
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLambdaInitCaptureBuilder : ValueType {
    private CppLambdaBuilder myParentBuilder;
    private bool myRef;
    private bool myPack;
    private CppSymbolLocation myLocation;
    private CppQualifiedId myName;
    private CppLambdaInitCaptureSymbol mySymbol;
    private CppUngroupedLambdaInitCaptureResolveEntity myResolveEntity;
    public CppLambdaInitCaptureBuilder(CppLambdaBuilder parentBuilder);
    public void LearnRef();
    public void LearnPack();
    public void LearnLocation(CppSymbolLocation location);
    public void LearnName(string name);
    public void BuildSymbol();
    public ICppSymbol GetSymbol();
    public void LearnParenInitializer(CppTwinFunctionArgumentListBuilder& argList);
    public void LearnBracedInitializer(CppTwinFunctionArgumentListBuilder& argList);
    public void LearnEqualInitializer(CppTwinExpressionBuilder exprBuilder);
    public void LearnNoInitializer();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLambdaInitCaptureResolveEntity : CppUngroupedLambdaInitCaptureResolveEntity {
    private CppDependentInfoCachedValue myCachedDepInfo;
    public CppLambdaInitCaptureResolveEntity(ICppResolveEntityParentScope parent, CppLambdaInitCaptureSymbol sym, CppLocationAnchor anchor);
    public CppLambdaInitCaptureResolveEntity(CppLambdaScopeResolveEntity parent, CppLambdaInitCaptureSymbol sym, CppLocationAnchor anchor, CppDeclaratorInitializer resolvedInitializer);
    public sealed virtual ICppEvaluationResult GetValue(CppEvaluationParams evalParams, ICppEvaluationErrorTracker errorTracker);
    public sealed virtual bool Contains(ICppDeclaratorResolveEntity decl);
    public sealed virtual CppSmallList`1<ICppVariableDeclaratorResolveEntity> GetUngroupedDeclarators();
    public sealed virtual ICppVariableDeclaratorResolveEntity GetAnyUngrouped();
    public sealed virtual ICppVariableTemplateDeclaratorResolveEntity GetTemplateDeclaration();
    public sealed virtual CppDependentInfo GetDependentInfo();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLambdaInitCaptureSymbol : CppSymbol {
    private CppQualifiedId myName;
    private bool myPack;
    private bool myRef;
    private CppDeclaratorInitializer myInitializer;
    [CompilerGeneratedAttribute]
private CppFileLocation <ContainingFile>k__BackingField;
    public CppQualifiedName Name { get; }
    public ICppParserSymbol Parent { get; }
    public CppFileLocation ContainingFile { get; }
    public CppLambdaInitCaptureSymbol(CppSymbolLocation loc, CppQualifiedId name, bool ref, bool isPack);
    public sealed virtual CppQualifiedName get_Name();
    public sealed virtual ICppParserSymbol get_Parent();
    [CompilerGeneratedAttribute]
public virtual CppFileLocation get_ContainingFile();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public CppQualifiedId GetNamePart();
    public CppDeclaratorInitializer GetInitializer();
    public bool IsRef();
    public bool IsPack();
    public void SetInitializer(CppDeclaratorInitializer initializer);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLambdaScopeResolveEntity : CppControlStructureScopeResolveEntity {
    private static string ourRawName;
    public static CppQualifiedNamePart StaticName;
    private CppLambdaSymbol myLambdaSymbol;
    [CanBeNullAttribute]
private List`1<ICppTemplateParameter> myTemplateDependencies;
    private ICppClassResolveEntity myClassResolveEntity;
    public CppQualifiedNamePart Name { get; }
    public CppLambdaScopeResolveEntity(ICppResolveEntity parentScope, CppLambdaSymbol sym, CppLocationAnchor loc, List`1<ICppTemplateParameter> templateDependencies);
    public CppLambdaScopeResolveEntity(ICppResolveEntity parentScope, CppLambdaScopeResolveEntity original, List`1<ICppTemplateParameter> templateDependencies);
    private static CppLambdaScopeResolveEntity();
    public virtual CppQualifiedNamePart get_Name();
    public CppLambdaSymbol GetLambdaSymbol();
    public List`1<ICppTemplateParameter> GetTemplateDependencies();
    public virtual string ToString();
    public ICppClassResolveEntity GetClassResolveEntity();
    public void SetClassResolveEntity(ICppClassResolveEntity clazz);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLambdaSymbol : CppSymbol {
    private int myAnchorDelta;
    private CppCompoundStatementSymbol myBody;
    private CppList`1<ICppLambdaCapture> myCapture;
    private bool myIsConsteval;
    private bool myIsConstexpr;
    private bool myIsStatic;
    private ICppExpression myRequiresClause;
    private CppQualType mySignature;
    private CppSmallArray`1<ICppTemplateParameterSymbol> myTemplateParameters;
    private CppAttributeList myAttributes;
    [CompilerGeneratedAttribute]
private CppFileLocation <ContainingFile>k__BackingField;
    public CppQualifiedName Name { get; }
    public ICppParserSymbol Parent { get; public set; }
    public CppFileLocation ContainingFile { get; }
    public CppLambdaSymbol(CppSymbolLocation loc);
    public sealed virtual CppQualifiedName get_Name();
    public sealed virtual ICppParserSymbol get_Parent();
    public void set_Parent(ICppParserSymbol value);
    [CompilerGeneratedAttribute]
public virtual CppFileLocation get_ContainingFile();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public void AddCapture(ICppLambdaCapture cap);
    public CppList`1<ICppLambdaCapture> GetCapture();
    public void SetCapture(CppList`1<ICppLambdaCapture> capture);
    public bool IsCaptureLess();
    public int GetAnchorDelta();
    public void SetAnchorDelta(int anchorDelta);
    public CppQualType GetSignature();
    public void SetSignature(CppQualType signature);
    public CppCompoundStatementSymbol GetBody();
    public void SetBody(CppCompoundStatementSymbol body);
    public bool IsConstExpr();
    public void SetIsConstexpr(bool isConstexpr);
    public bool IsConstEval();
    public void SetIsConsteval(bool isConsteval);
    public bool IsStatic();
    public void SetIsStatic(bool isStatic);
    public CppSmallArray`1<ICppTemplateParameterSymbol> GetTemplateParameters();
    public void SetTemplateParameters(CppSmallArray`1<ICppTemplateParameterSymbol> templateParameters);
    public ICppExpression GetRequiresClause();
    public void SetRequiresClause(ICppExpression clause);
    public CppAttributeList GetAttributes();
    public void SetAttributes(CppAttributeList attributes);
    public CppDeclarationSpecifiers GetParentOperatorDeclSpecs();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLambdaToFunctionPointerConversionModuleEntity : object {
    public ICppClassOrRefClassModuleEntity Class;
    public CppCallingConvention CallingConvention;
    public CppLambdaToFunctionPointerConversionModuleEntity(ICppClassOrRefClassModuleEntity class, CppConversionId conversionId);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public sealed virtual CppImportResult`1<ICppGroupedFunctionDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
    private static CppCallingConvention GetCallingConvention(CppQualifiedNamePart operatorName);
    private static CppCallingConvention GetCallingConvention(CppConversionId conversionId);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLazyMergingDataConsumer : object {
    private bool myAddOnlyFwdClasses;
    private ICollection`1<ICppClassSymbol> mySymbols;
    [CompilerGeneratedAttribute]
private int <AnchorDelta>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SeenClasses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SeenClassesWithAnonymousName>k__BackingField;
    public int AnchorDelta { get; private set; }
    public bool SeenClasses { get; private set; }
    public bool SeenClassesWithAnonymousName { get; private set; }
    public ICollection`1<ICppClassSymbol> AffectedSymbols { get; }
    public CppLazyMergingDataConsumer(ICollection`1<ICppClassSymbol> resultCollection, bool addOnlyFwdClasses);
    [CompilerGeneratedAttribute]
public int get_AnchorDelta();
    [CompilerGeneratedAttribute]
private void set_AnchorDelta(int value);
    [CompilerGeneratedAttribute]
public bool get_SeenClasses();
    [CompilerGeneratedAttribute]
private void set_SeenClasses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SeenClassesWithAnonymousName();
    [CompilerGeneratedAttribute]
private void set_SeenClassesWithAnonymousName(bool value);
    public ICollection`1<ICppClassSymbol> get_AffectedSymbols();
    public sealed virtual void LearnTrailingReturnType();
    public sealed virtual void LearnDeclarator(CppDeclaratorSymbol declSym);
    public sealed virtual void LearnClassSymbol(ICppClassSymbol sym);
    public sealed virtual void IncrementAnchor(int diff);
    private void AddClassSymbol(ICppClassSymbol cls);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageConceptExpressionTemplateParameter : CppLinkageConceptTemplateParameter {
    private CppQualType myType;
    public CppQualType Type { get; }
    public CppLinkageConceptExpressionTemplateParameter(CppQualifiedName concept, CppQualifiedNamePart name, int parameterIndex, CppQualType type, CppLinkageTemplateParameterList parameterList);
    public virtual CppQualType get_Type();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageConceptExpressionTemplateParameterPack : CppLinkageConceptTemplateParameter {
    private CppQualType myType;
    public CppQualType Type { get; }
    public CppLinkageConceptExpressionTemplateParameterPack(CppQualifiedName concept, CppQualifiedNamePart name, int parameterIndex, CppQualType type, CppLinkageTemplateParameterList parameterList);
    public virtual CppQualType get_Type();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageConceptTemplateParameter : CppLinkageTemplateParameter {
    private CppQualifiedName myConcept;
    public CppQualifiedName ConceptName { get; }
    protected CppLinkageConceptTemplateParameter(CppQualifiedName concept, CppQualifiedNamePart name, int parameterIndex, CppLinkageTemplateParameterList parameterList);
    public virtual CppQualifiedName get_ConceptName();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageConceptTemplateTemplateParameter : CppLinkageConceptTemplateParameter {
    private ICppLinkageTemplateParameter[] myParameters;
    private int myHashCode;
    public ICppLinkageTemplateParameter[] Parameters { get; }
    public CppLinkageConceptTemplateTemplateParameter(CppQualifiedName concept, CppQualifiedNamePart name, int parameterIndex, ICppLinkageTemplateParameter[] params, CppLinkageTemplateParameterList parameterList);
    public virtual ICppLinkageTemplateParameter[] get_Parameters();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageConceptTemplateTemplateParameterPack : CppLinkageConceptTemplateParameter {
    private ICppLinkageTemplateParameter[] myParameters;
    private int myHashCode;
    public ICppLinkageTemplateParameter[] Parameters { get; }
    public CppLinkageConceptTemplateTemplateParameterPack(CppQualifiedName concept, CppQualifiedNamePart name, int parameterIndex, ICppLinkageTemplateParameter[] params, CppLinkageTemplateParameterList parameterList);
    public virtual ICppLinkageTemplateParameter[] get_Parameters();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageConceptTypeTemplateParameter : CppLinkageConceptTemplateParameter {
    [CompilerGeneratedAttribute]
private CppTypeTemplateParameterKey <Key>k__BackingField;
    public CppTypeTemplateParameterKey Key { get; }
    public CppLinkageConceptTypeTemplateParameter(CppQualifiedName concept, CppQualifiedNamePart name, CppTypeTemplateParameterKey key, int parameterIndex, CppLinkageTemplateParameterList parameterList);
    [CompilerGeneratedAttribute]
public sealed virtual CppTypeTemplateParameterKey get_Key();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageConceptTypeTemplateParameterPack : CppLinkageConceptTemplateParameter {
    [CompilerGeneratedAttribute]
private CppTypeTemplateParameterKey <Key>k__BackingField;
    public CppTypeTemplateParameterKey Key { get; }
    public CppLinkageConceptTypeTemplateParameterPack(CppQualifiedName concept, CppQualifiedNamePart name, CppTypeTemplateParameterKey key, int parameterIndex, CppLinkageTemplateParameterList parameterList);
    [CompilerGeneratedAttribute]
public sealed virtual CppTypeTemplateParameterKey get_Key();
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageDeclaratorType : Enum {
    public byte value__;
    public static CppLinkageDeclaratorType Function;
    public static CppLinkageDeclaratorType TypeAlias;
    public static CppLinkageDeclaratorType CliPropertyOrEvent;
    public static CppLinkageDeclaratorType DeductionGuide;
    public static CppLinkageDeclaratorType Concept;
    public static CppLinkageDeclaratorType Other;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageDependentTemplateArgument : object {
    private ICppDependentLinkageEntity myDependentTemplate;
    public CppLinkageDependentTemplateArgument(ICppDependentLinkageEntity dependentTemplate);
    public sealed virtual string Present(ICppPresenter presenter);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageDummyTypeTemplateParameter : CppLinkageTypeTemplateParameter {
    public static CppLinkageDummyTypeTemplateParameter RETURN_TYPE;
    private CppLinkageDummyTypeTemplateParameter(string name, int parameterIndex);
    private static CppLinkageDummyTypeTemplateParameter();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageEntity : object {
    private CppQualifiedNamePart myName;
    private ICppLinkageEntity myParent;
    public string DbgDescription { get; }
    public CppQualifiedNamePart Name { get; }
    public ICppLinkageEntity Parent { get; }
    protected CppLinkageEntity(CppQualifiedNamePart name, ICppLinkageEntity parent);
    public virtual string get_DbgDescription();
    public virtual CppQualifiedNamePart get_Name();
    public virtual string Present(ICppPresenter presenter);
    public virtual ICppLinkageEntity get_Parent();
    public abstract virtual Result Accept(ICppLinkageEntityVisitor`1<Result> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageEntityFactory : object {
    public static ICppLinkageEntity FromResolveEntity(ICppResolveEntity resolveEntity, bool useResolveCache);
    public static ICppLinkageEntity FromResolveEntityWithAliasing(ICppResolveEntity resolveEntity);
    public static ICppLinkageEntity FromNamespaceSymbol(ICppNamespaceSymbol symbol, IPsiServices psiServices);
    public static ICppLinkageEntity FromNamespaceSymbol(ICppNamespaceSymbol symbol, CppAnonymousNameHelper anonymousNameHelper);
    private static Nullable`1<CppQualType> GetEnumUnderlyingTypeForLinkageEntity(ICppClassResolveEntity ent);
    private static T AssertNoParams(T result, CppMutableLinkageTemplateParameterList params);
    private static ICppLinkageEntity SetOwner(ICppLinkageEntity owner, CppMutableLinkageTemplateParameterList params);
    private static CppLinkageDeclaratorType GetLinkageDeclaratorType(ICppDeclaratorResolveEntity resolveEntity);
    private static CppQualifiedNamePart ConvertNamePart(CppQualifiedNamePart namePart, CppCreateLinkageEntityContext ctx, CppMutableLinkageTemplateParameterList& outputParams);
    private static CppUndeterminedSpecializationLinkageEntity CreateUndeterminedSpecializationLinkageEntity(CppTemplateWithAppliedArgumentsResolveEntityBase resolveEntity, CppCreateLinkageEntityContext ctx);
    public static CppQualifiedName ConvertQualifiedName(CppQualifiedName name, CppCreateLinkageEntityContext ctx);
    public static CppQualifiedNamePart ConvertLinkageEntityName(CppQualifiedNamePart name, CppCreateLinkageEntityContext ctx);
    public static CppQualifiedNamePart ConvertLinkageEntityName(CppQualifiedNamePart name, ICppLinkageEntity ent, CppCreateLinkageEntityContext ctx);
    public static ICppDependentLinkageEntity CreateDependentLinkageEntity(ICppAnyDependentResolveEntity param, CppCreateLinkageEntityContext ctx);
    public static ICppLinkageEntity CreateLinkageEntity(ICppResolveEntity resolveEntity, CppCreateLinkageEntityContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageEntityTemplateTemplateArgument : object {
    [CompilerGeneratedAttribute]
private ICppLinkageEntity <TypeTemplate>k__BackingField;
    public ICppLinkageEntity TypeTemplate { get; }
    public CppLinkageEntityTemplateTemplateArgument(ICppLinkageEntity typeTemplate);
    [CompilerGeneratedAttribute]
public ICppLinkageEntity get_TypeTemplate();
    public sealed virtual string Present(ICppPresenter presenter);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageEntityUtil : object {
    [ExtensionAttribute]
public static CppQualifiedName GetNestedName(ICppLinkageEntity linkageEntity);
    [ExtensionAttribute]
public static CppQualifiedName GetQualifiedName(ICppLinkageEntity linkageEntity);
    [ExtensionAttribute]
private static CppQualifiedName GetQualifiedNameImpl(ICppLinkageEntity linkageEntity, bool stopAtNamespace);
    [ExtensionAttribute]
public static CppQualifiedName GetQualifiedNameWithoutInlineNamespaces(ICppLinkageEntity linkageEntity);
    [ExtensionAttribute]
public static bool IsTopLevel(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static bool IsTopLevelOrInsideClass(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static bool IsTemplateClassOrTemplateClassChild(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static bool IsTemplateClass(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static bool IsTemplate(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static bool IsNamespace(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static bool IsConstructor(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static bool IsStaticDeclarator(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static bool IsGlobalStaticDeclarator(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static bool IsConversionOperator(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static bool IsDestructor(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static bool IsCliFinalizer(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static bool IsDeductionGuide(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static bool IsFunctionDeclarator(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static bool IsCallableDeclarator(ICppLinkageEntity ent, CppLinkageEntityCache linkageCache);
    [ExtensionAttribute]
public static bool IsType(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static bool IsAnonymousNamespaceMember(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static bool IsNewDeclarator(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static bool IsNonNewDeclarator(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static ICppLinkageEntity RemoveSubstitutionIfClassInstantiation(ICppLinkageEntity ent);
    [ExtensionAttribute]
public static ICppLinkageEntity GetClassByMember(ICppLinkageEntity linkageEntity);
    [ExtensionAttribute]
public static ICppLinkageEntity GetEnclosingNamespace(ICppLinkageEntity linkageEntity, bool returnSelf);
    public static IEnumerable`1<ICppLinkageEntity> FindConstructorsByClass(CppLinkageEntityCache cache, CppClassLinkageEntity linkageEntity);
    public static IEnumerable`1<ICppLinkageEntity> FindDestructorsByClass(CppLinkageEntityCache cache, CppClassLinkageEntity linkageEntity, bool appendImplicitDestructor);
    public static IEnumerable`1<ICppLinkageEntity> FindCliFinalizersByClass(CppLinkageEntityCache cache, CppClassLinkageEntity linkageEntity);
    public static IEnumerable`1<ICppLinkageEntity> FindDeductionGuidesByClass(CppLinkageEntityCache cache, CppClassLinkageEntity linkageEntity);
    public static ICppLinkageEntity GetPrimaryTemplate(ICppLinkageEntity ent);
    private static int GetHeight(ICppLinkageEntity ent);
    private static bool IsDefinitionSymbol(ICppParserSymbol sym);
    public static bool HasDefinition(CppLinkageEntityCache cache, ICppLinkageEntity linkageEntity);
    public static IEnumerable`1<ICppParserSymbol> GetDefinitions(CppLinkageEntityCache cache, ICppLinkageEntity linkageEntity);
    public static ICppLinkageEntity GetCommonParent(ICppLinkageEntity a, ICppLinkageEntity b);
    public static ICppLinkageEntity GetCommonParent(IEnumerable`1<ICppLinkageEntity> entities);
    [ExtensionAttribute]
public static ICppLinkageTemplateArgument[] GetArgumentsIfLinkageSubstitutionId(CppQualifiedNamePart namePart);
    public static IDictionary`2<ICppParserSymbol, ICppLinkageEntity> FindEntitiesInFile(CppFile file);
    public static void FindUE4RpcEntitiesInFile(CppFile file, HashSet`1<ICppLinkageEntity> rpcs);
    public static IEnumerable`1<ICppLinkageEntity> FindDistinctEntitiesInFile(CppFile file);
    public static void DumpAllLinkageEntities(TextWriter writer, CppLinkageEntityCache cache);
    public static void DumpLinkageEntities(TextWriter writer, CppLinkageEntityCache cache, IEnumerable`1<ICppLinkageEntity> linkageEntities);
    public static void DumpLinkageEntities(TextWriter writer, CppLinkageEntityCache cache, CppFile file);
    public static HashSet`1<ICppLinkageEntity> FindAbstractLinkageEntities(CppGlobalSymbolCache globalCache, IEnumerable`1<ICppLinkageEntity> linkageEntities);
    private static void AddUE4RpcEntitiesForSymbol(ICppResolvedTypeFactory tf, CppFile file, ICppDeclaratorSymbol declaratorSymbol, ICollection`1<ICppLinkageEntity> outRpcs);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageExcessiveTemplateArgument : CppLinkageTemplateArgumentBase {
    [CompilerGeneratedAttribute]
private ICppLinkageTemplateArgument <Inner>k__BackingField;
    public ICppLinkageTemplateArgument Inner { get; }
    public CppLinkageExcessiveTemplateArgument(ICppLinkageTemplateArgument inner);
    [CompilerGeneratedAttribute]
public ICppLinkageTemplateArgument get_Inner();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string Present(ICppPresenter presenter);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageExpressionTemplateArgument : CppLinkageTemplateArgumentBase {
    private string myStr;
    private int myHashCode;
    private ICppExpression myExpression;
    public CppLinkageExpressionTemplateArgument(CppExpressionTemplateArgument arg, CppCreateLinkageEntityContext ctx);
    public virtual string Present(ICppPresenter p);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public ICppExpression GetExpression();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageExpressionTemplateArgumentPack : CppLinkageTemplateArgumentPackBase`1<ICppLinkageExpressionTemplateArgument> {
    public CppLinkageExpressionTemplateArgumentPack(List`1<ICppLinkageExpressionTemplateArgument> args);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageExpressionTemplateParameter : CppLinkageTemplateParameter {
    private CppQualType myType;
    public CppQualType Type { get; }
    public CppLinkageExpressionTemplateParameter(CppQualifiedNamePart name, int parameterIndex, CppQualType type, CppLinkageTemplateParameterList parameterList);
    public sealed virtual CppQualType get_Type();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageExpressionTemplateParameterPack : CppLinkageTemplateParameter {
    private CppQualType myType;
    public CppQualType Type { get; }
    public CppLinkageExpressionTemplateParameterPack(CppQualifiedNamePart name, int parameterIndex, CppQualType type, CppLinkageTemplateParameterList parameterList);
    public sealed virtual CppQualType get_Type();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageGenericParameter : CppLinkageTemplateParameter {
    [CompilerGeneratedAttribute]
private CppTypeTemplateParameterKey <Key>k__BackingField;
    public CppTypeTemplateParameterKey Key { get; }
    public CppLinkageGenericParameter(CppQualifiedNamePart name, CppTypeTemplateParameterKey key, int parameterIndex, CppLinkageTemplateParameterList parameterList);
    [CompilerGeneratedAttribute]
public sealed virtual CppTypeTemplateParameterKey get_Key();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageParameterTemplateTemplateArgument : object {
    private ICppLinkageTemplateParameter myTypeTemplate;
    public CppLinkageParameterTemplateTemplateArgument(ICppLinkageTemplateParameter typeTemplate);
    public sealed virtual string Present(ICppPresenter presenter);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageSpecificationBuilder : CppTopLevelBlockBuilder {
    private CppLinkageSpecSymbol mySymbol;
    public CppLinkageSpecificationBuilder(ICppBuilder parent);
    protected virtual CppTopLevelBlockSymbol GetSymbol();
    public void LearnSymbolLocation(CppSymbolLocation location, bool exported);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageSpecSymbol : CppTopLevelBlockSymbol {
    [CompilerGeneratedAttribute]
private bool <exported>P;
    public bool Exported { get; }
    public CppLinkageSpecSymbol(CppSymbolLocation loc, bool exported);
    public bool get_Exported();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageTemplateArgumentBase : object {
    public abstract virtual string Present(ICppPresenter presenter);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageTemplateArgumentFactory : object {
    public static CppLinkageTemplateArgumentFactory INSTANCE;
    private static CppLinkageTemplateArgumentFactory();
    public sealed virtual ICppLinkageTemplateArgument Visit(CppCreateLinkageEntityContext ctx, CppQualifiedReferenceTemplateArgument arg);
    public sealed virtual ICppLinkageTemplateArgument Visit(CppCreateLinkageEntityContext ctx, CppQualType typeArgument);
    public sealed virtual ICppLinkageTemplateArgument Visit(CppCreateLinkageEntityContext ctx, CppTypeTemplateArgument typeArgument);
    public sealed virtual ICppLinkageTemplateArgument Visit(CppCreateLinkageEntityContext ctx, CppTypeTemplateArgumentPack typePackArgument);
    public sealed virtual ICppLinkageTemplateArgument Visit(CppCreateLinkageEntityContext ctx, CppExpressionTemplateArgument expressionArgument);
    public sealed virtual ICppLinkageTemplateArgument Visit(CppCreateLinkageEntityContext ctx, CppExpressionTemplateArgumentPack expressionArgumentPack);
    public sealed virtual ICppLinkageTemplateArgument Visit(CppCreateLinkageEntityContext ctx, CppTemplateTemplateArgument templateArgument);
    public sealed virtual ICppLinkageTemplateArgument Visit(CppCreateLinkageEntityContext ctx, CppTemplateTemplateArgumentPack templateTemplateArgumentPack);
    public sealed virtual ICppLinkageTemplateArgument Visit(CppCreateLinkageEntityContext ctx, CppDependentTemplateArgument dependentTemplateArgument);
    public sealed virtual ICppLinkageTemplateArgument Visit(CppCreateLinkageEntityContext ctx, CppInjectedClassNameTemplateArgument arg);
    public sealed virtual ICppLinkageTemplateArgument Visit(CppCreateLinkageEntityContext ctx, CppLookupFailureTemplateArgument arg);
    public sealed virtual ICppLinkageTemplateArgument Visit(CppCreateLinkageEntityContext ctx, CppExcessiveTemplateArgument arg);
    public static ICppLinkageTemplateArgument CreateLinkageTemplateArgument(ICppTemplateArgument arg, CppCreateLinkageEntityContext ctx);
    public static ICppLinkageTemplateArgument[] CreateLinkageTemplateArguments(ICppTemplateArgument[] arguments, CppCreateLinkageEntityContext ctx);
    [CanBeNullAttribute]
private static ICppLinkageTemplateTemplateArgument ConvertTemplateTemplateArgumentREToLEArgument(CppTemplateTemplateArgument arg, CppCreateLinkageEntityContext ctx);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageTemplateArgumentPackBase`1 : object {
    private List`1<TArg> myPacked;
    protected CppLinkageTemplateArgumentPackBase`1(List`1<TArg> packed);
    public virtual IEnumerable`1<ICppLinkageTemplateArgument> Unpack();
    public virtual string Present(ICppPresenter presenter);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageTemplateArgumentUtil : object {
    [ExtensionAttribute]
public static ICppLinkageTemplateArgument[] Flatten(ICppLinkageTemplateArgument[] args);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageTemplateId : object {
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
private CppLinkageTemplateParameterList <ParameterList>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppLinkageTemplateArgument[] <Arguments>k__BackingField;
    public CppQualifiedNamePart Inner { get; }
    public ICppLinkageTemplateParameter[] Parameters { get; }
    public ICppExpression RequiresClause { get; }
    public CppLinkageTemplateParameterList ParameterList { get; }
    public ICppLinkageTemplateArgument[] Arguments { get; }
    public CppLinkageTemplateId(CppQualifiedNamePart inner, CppLinkageTemplateParameterList parameters, ICppLinkageTemplateArgument[] arguments);
    [CompilerGeneratedAttribute]
public CppQualifiedNamePart get_Inner();
    public ICppLinkageTemplateParameter[] get_Parameters();
    public ICppExpression get_RequiresClause();
    [CompilerGeneratedAttribute]
public CppLinkageTemplateParameterList get_ParameterList();
    [CompilerGeneratedAttribute]
public ICppLinkageTemplateArgument[] get_Arguments();
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
    private static string ToString(ICppLinkageTemplateArgument[] args);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageTemplateParameter : object {
    private int myParameterIndex;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CppLinkageTemplateParameterList <OwnerParameterList>k__BackingField;
    public CppQualifiedNamePart Name { get; }
    public CppLinkageTemplateParameterList OwnerParameterList { get; }
    protected CppLinkageTemplateParameter(CppQualifiedNamePart name, int parameterIndex, CppLinkageTemplateParameterList parameterList);
    [CompilerGeneratedAttribute]
public virtual CppQualifiedNamePart get_Name();
    [CompilerGeneratedAttribute]
public virtual CppLinkageTemplateParameterList get_OwnerParameterList();
    public virtual int GetParameterIndex();
    public virtual string Present(ICppPresenter p);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageTemplateParameterList : object {
    [CompilerGeneratedAttribute]
private ICppLinkageEntity <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppLinkageTemplateParameter[] <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppExpression <RequiresClause>k__BackingField;
    public ICppLinkageEntity Owner { get; public set; }
    public ICppLinkageTemplateParameter[] Parameters { get; public set; }
    public ICppExpression RequiresClause { get; public set; }
    [CompilerGeneratedAttribute]
public ICppLinkageEntity get_Owner();
    [CompilerGeneratedAttribute]
public void set_Owner(ICppLinkageEntity value);
    [CompilerGeneratedAttribute]
public ICppLinkageTemplateParameter[] get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(ICppLinkageTemplateParameter[] value);
    [CompilerGeneratedAttribute]
public ICppExpression get_RequiresClause();
    [CompilerGeneratedAttribute]
public void set_RequiresClause(ICppExpression value);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageTemplateParameterVisitor : CppAbstractResolveEntityVisitor`1<CppLinkageTemplateParameter> {
    private CppCreateLinkageEntityContext myTypeIntern;
    private CppLinkageTemplateParameterList myParamList;
    public CppLinkageTemplateParameterVisitor(CppCreateLinkageEntityContext ctx, CppLinkageTemplateParameterList ownerList);
    public virtual CppLinkageTemplateParameter Visit(ICppTypeTemplateParameter param);
    public virtual CppLinkageTemplateParameter Visit(ICppTypeTemplateParameterPack param);
    public virtual CppLinkageTemplateParameter Visit(ICppExpressionTemplateParameter param);
    public virtual CppLinkageTemplateParameter Visit(ICppExpressionTemplateParameterPack param);
    public virtual CppLinkageTemplateParameter Visit(ICppTemplateTemplateParameter param);
    public virtual CppLinkageTemplateParameter Visit(ICppTemplateTemplateParameterPack param);
    public virtual CppLinkageTemplateParameter Visit(ICppGenericParameter param);
    public virtual CppLinkageTemplateParameter Visit(ICppResolveEntity e);
    private CppQualifiedNamePart ConvertName(ICppTemplateParameter parameter);
    private CppQualifiedName ConvertConceptName(ICppConceptTemplateParameter param);
    public static CppMutableLinkageTemplateParameterList CreateLinkageTemplateParameters(CppTemplateParametersBase parameters, CppCreateLinkageEntityContext ctx);
    public static ICppLinkageTemplateParameter CreateLinkageTemplateParameter(ICppTemplateParameter param, CppMutableLinkageTemplateParameterList paramList, CppCreateLinkageEntityContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageTemplateTemplateArgumentPack : CppLinkageTemplateArgumentPackBase`1<ICppLinkageTemplateTemplateArgument> {
    public CppLinkageTemplateTemplateArgumentPack(List`1<ICppLinkageTemplateTemplateArgument> packed);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageTemplateTemplateParameter : CppLinkageTemplateParameter {
    private ICppLinkageTemplateParameter[] myParameters;
    private int myHashCode;
    public ICppLinkageTemplateParameter[] Parameters { get; }
    public CppLinkageTemplateTemplateParameter(CppQualifiedNamePart name, int parameterIndex, ICppLinkageTemplateParameter[] params, CppLinkageTemplateParameterList parameterList);
    public sealed virtual ICppLinkageTemplateParameter[] get_Parameters();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageTemplateTemplateParameterPack : CppLinkageTemplateParameter {
    private ICppLinkageTemplateParameter[] myParameters;
    private int myHashCode;
    public ICppLinkageTemplateParameter[] Parameters { get; }
    public CppLinkageTemplateTemplateParameterPack(CppQualifiedNamePart name, int parameterIndex, ICppLinkageTemplateParameter[] params, CppLinkageTemplateParameterList parameterList);
    public sealed virtual ICppLinkageTemplateParameter[] get_Parameters();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageTypeTemplateArgument : CppLinkageTemplateArgumentBase {
    private CppQualType myType;
    public IEnumerable`1<CppQualType> ArgTypes { get; }
    public CppLinkageTypeTemplateArgument(CppQualType type);
    public virtual string Present(ICppPresenter presenter);
    public sealed virtual IEnumerable`1<CppQualType> get_ArgTypes();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageTypeTemplateArgumentPack : CppLinkageTemplateArgumentPackBase`1<ICppLinkageTypeTemplateArgument> {
    public IEnumerable`1<CppQualType> ArgTypes { get; }
    public CppLinkageTypeTemplateArgumentPack(List`1<ICppLinkageTypeTemplateArgument> packed);
    public sealed virtual IEnumerable`1<CppQualType> get_ArgTypes();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageTypeTemplateParameter : CppLinkageTemplateParameter {
    [CompilerGeneratedAttribute]
private CppTypeTemplateParameterKey <Key>k__BackingField;
    public CppTypeTemplateParameterKey Key { get; }
    public CppLinkageTypeTemplateParameter(CppQualifiedNamePart name, CppTypeTemplateParameterKey key, int parameterIndex, CppLinkageTemplateParameterList parameterList);
    [CompilerGeneratedAttribute]
public virtual CppTypeTemplateParameterKey get_Key();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageTypeTemplateParameterPack : CppLinkageTemplateParameter {
    [CompilerGeneratedAttribute]
private CppTypeTemplateParameterKey <Key>k__BackingField;
    public CppTypeTemplateParameterKey Key { get; }
    public CppLinkageTypeTemplateParameterPack(CppQualifiedNamePart name, CppTypeTemplateParameterKey key, int parameterIndex, CppLinkageTemplateParameterList parameterList);
    [CompilerGeneratedAttribute]
public sealed virtual CppTypeTemplateParameterKey get_Key();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLocationAnchor : ValueType {
    private int myLocation;
    public int AnchorLocation { get; public set; }
    public CppLocationAnchor Next { get; }
    public CppLocationAnchor Prev { get; }
    public CppLocationAnchor(int location);
    public sealed virtual int get_AnchorLocation();
    public void set_AnchorLocation(int value);
    public sealed virtual CppLocationAnchor get_Next();
    public CppLocationAnchor get_Prev();
    public sealed virtual int CompareTo(CppLocationAnchor rhs);
    public static bool op_Equality(CppLocationAnchor lhs, CppLocationAnchor rhs);
    public static bool op_Inequality(CppLocationAnchor lhs, CppLocationAnchor rhs);
    public bool IsValid();
    public static CppLocationAnchor CreateGeneratedLocation(int location);
    public static CppLocationAnchor GeneratedEntity();
    public static CppLocationAnchor TopMost();
    public static CppLocationAnchor BeforeTopMost();
    public static CppLocationAnchor BottomMost();
    public static CppLocationAnchor Invalid();
    public static CppLocationAnchor Min(CppLocationAnchor a, CppLocationAnchor b);
    public static CppLocationAnchor Max(CppLocationAnchor a, CppLocationAnchor b);
    public sealed virtual bool Equals(CppLocationAnchor other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLocationAnchorUtil : object {
    [ExtensionAttribute]
public static CppLocationAnchor EnsureAfter(CppLocationAnchor anchor, ICppClassResolveEntity clazz);
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLookinResolveScope : object {
    public static FrugalLocalList`1<ICppResolveEntity> LookinClass(ICppClassResolveEntity e, CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public static FrugalLocalList`1<ICppResolveEntity> LookinParameterList(ICppParameterListResolveEntity paramList, CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter);
    public static FrugalLocalList`1<ICppResolveEntity> LookinCliProperty(ICppCxxCliPropertyDeclaratorResolveEntity prop, CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLookupFailureTemplateArgument : object {
    private CppQualifiedName myDecoratedName;
    public CppLookupFailureTemplateArgument(CppQualifiedName decoratedName);
    public sealed virtual ICppTemplateArgument Import(CppModuleImportingContext ctx);
    public sealed virtual CppModuleTemplateArgumentKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual Result Accept(Data data, ICppTemplateArgumentVisitor`2<Result, Data> visitor);
    public CppQualifiedName GetDecoratedName();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLookupResultUtils : object {
    [ExtensionAttribute]
public static CppQualType LookupResultToQualType(CppLookupResult pp, ICppResolvedTypeFactory typeIntern);
    [ExtensionAttribute]
public static CppQualType TypeResolveEntityToQualType(ICppResolveEntity ent, ICppResolvedTypeFactory typeIntern, bool returnDeducedClassTypePlaceholder);
    [ExtensionAttribute]
public static CppQualType TypeResolveEntityToQualType(ICppResolveEntity ent, ICppResolvedTypeFactory typeIntern);
    [ExtensionAttribute]
public static CppQualType TypeResolveEntityToQualType(ICppResolveEntity ent);
    [ExtensionAttribute]
public static CppQualType ToQualType(CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity e, ICppResolvedTypeFactory typeIntern);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLoopStatementBuilder`2 : CppStatementWithConditionBuilder {
    protected TSymbol mySymbol;
    protected TResolveEntity myResolveEnt;
    protected CppLoopStatementBuilder`2(ICppBuilder parent, TSymbol symbol, TResolveEntity resolveEntity);
    public void LearnBodyBuilder(CppCompoundStatementBuilder bodyBuilder);
    protected virtual ICppMutableStatementWithConditionResolveEntity GetResolveEntity();
    protected virtual CppStatementWithConditionSymbol GetSymbol();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLoopStatementModuleEntity : CppScopeStatementModuleEntity {
    [CanBeNullAttribute]
public ICppExpression Condition;
    public CppCompoundStatementModuleEntity Body;
    protected CppLoopStatementModuleEntity(CppLocationAnchor anchor, CppRegularFunctionModuleEntity function);
    protected void ImportLoopStatement(TLoopStatement target, CppModuleImportingContext ctx);
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLoopStatementResolveEntityBase : CppScopeResolveEntityBase {
    private CppCompoundStatementResolveEntity myBody;
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    protected CppLoopStatementResolveEntityBase(ICppResolveEntity parentScope, CppLocationAnchor location);
    public abstract virtual ICppResolvedExpression GetCondition();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public CppCompoundStatementResolveEntity GetBody();
    public void SetBody(CppCompoundStatementResolveEntity body);
    public sealed virtual List`1<ICppResolveEntity> GetSortedChildren();
    internal abstract virtual CppFuncEvaluationResult Evaluate(CppExpressionEvaluator evaluator, CppFunctionEvaluationContext functionCtx, CppQualType retType);
    internal abstract virtual CppLoopStatementResolveEntityBase Substitute(ICppScopeResolveEntity parent, CppSubstitutionDriver driver);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppLoopStatementSymbol : CppStatementWithConditionSymbol {
    private CppCompoundStatementSymbol myBody;
    protected CppLoopStatementSymbol(CppSymbolLocation loc);
    public CppCompoundStatementSymbol GetBody();
    public void SetBody(CppCompoundStatementSymbol body);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppMainParameterListBuilder : CppParameterListBuilder {
    private ICppFunctionDeclaratorBuilder myParent;
    public CppMainParameterListBuilder(ICppFunctionDeclaratorBuilder parent);
    public sealed virtual void LearnAutoParameter(ICppTypeTemplateParameterOrPack param);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppMatchSpecializationUtil : object {
    public static bool IsIdentitySpecialization(CppTemplateParametersBase p, ICppTemplateArgument[] a);
    public static bool MatchSpecialization(ICppResolvedTypeFactory typeFactory, CppTemplateParametersBase p1, ICppTemplateArgument[] a1, CppTemplateParametersBase p2, ICppTemplateArgument[] a2);
    public static bool EqualsSpecialization(ICppResolvedTypeFactory typeFactory, CppTemplateId tid1, CppTemplateId tid2);
    public static bool EqualsFunctionTemplate(ICppResolvedTypeFactory typeFactory, CppTemplateParametersBase p1, CppTemplateParametersBase p2, CppQualType t1, CppQualType t2);
    public static bool EqualsConversionTemplate(ICppResolvedTypeFactory typeFactory, CppTemplateParametersBase p1, CppTemplateParametersBase p2, CppQualType t1, CppQualType t2);
    public static bool IsParameterAndArgumentFromIdentitySpecialization(ICppTemplateParameter p, ICppTemplateArgument a);
    public static CppTemplateParametersBase FilterConversionTemplateParams(CppTemplateParametersBase params, CppQualType type);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppMemberFunctionOfReferentialClassModuleEntity : object {
    public ICppFunctionModuleEntity Inner;
    public ICppClassOrRefClassModuleEntity Parent;
    public CppMemberFunctionOfReferentialClassModuleEntity(ICppFunctionModuleEntity inner, ICppClassOrRefClassModuleEntity parent);
    public sealed virtual CppImportResult`1<ICppGroupedFunctionDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppMemberTypedefOfReferentialClassModuleEntity : object {
    public ICppTypeAliasModuleEntity Inner;
    public ICppClassOrRefClassModuleEntity Parent;
    public CppMemberTypedefOfReferentialClassModuleEntity(ICppTypeAliasModuleEntity inner, ICppClassOrRefClassModuleEntity parent);
    public sealed virtual CppImportResult`1<ICppGroupedTypeDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppMemberVariableOfReferentialClassModuleEntity : object {
    public ICppVariableModuleEntity Inner;
    public ICppClassOrRefClassModuleEntity Parent;
    public CppMemberVariableOfReferentialClassModuleEntity(ICppVariableModuleEntity inner, ICppClassOrRefClassModuleEntity parent);
    public sealed virtual CppImportResult`1<ICppGroupedVariableDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppMemInitEntity : object {
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppMergeSymbolActionsPool : AutoClearingThreadSafeObjectPool`1<CppMergeSymbolActions> {
    public static int CheckPeriod;
    public CppMergeSymbolActionsPool(Lifetime lifetime);
    protected virtual CppMergeSymbolActions CreateObject();
    protected virtual void ClearObject(CppMergeSymbolActions actions);
    protected virtual void InitObject(CppMergeSymbolActions actions);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppMethodInheritanceInfo : object {
    private static List`1<ICppTypeTemplateArgument> myCanonicGenericParams;
    public CppClassInheritanceInfo Class;
    public ICppGroupedFunctionDeclaratorResolveEntity Entity;
    public CppMethodNameKey SignatureKey;
    public bool IsStub;
    public bool IsImplicit;
    public bool IsDeclaredVirtual;
    public bool IsPure;
    public bool IsInterfaceWithDefault;
    public CppAccessibility Accessibility;
    private CppQualType mySignatureType;
    private CppSmallList`1<CppVTableEntryInfo> myVirtualSlots;
    private CppSmallList`1<CppMethodInheritanceInfo> myHides;
    private CppDependentInfo myDependentInfo;
    private bool myDependentInfoReady;
    public CppQualType SignatureType { get; }
    public CppDependentInfo DependentInfo { get; }
    public bool IsIsolated { get; }
    public bool IsComplete { get; }
    public bool IsStatic { get; }
    public bool IsDestructor { get; }
    public bool IsCliFinalizer { get; }
    public bool IsVirtual { get; }
    public bool IsPublic { get; }
    public bool IsPrivate { get; }
    public bool IsOverride { get; }
    public bool IsOverrideOrImplementation { get; }
    public bool IsSealed { get; }
    public CppVTableEntryInfoPrimary PrimaryVirtualSlot { get; }
    public CppSmallList`1<CppVTableEntryInfo> VirtualSlots { get; }
    public CppSmallList`1<CppMethodInheritanceInfo> Hides { get; }
    public CppMethodInheritanceInfo(CppClassInheritanceInfo cls, ICppGroupedFunctionDeclaratorResolveEntity entity, bool isStub);
    private static CppMethodInheritanceInfo();
    public CppQualType get_SignatureType();
    public CppDependentInfo get_DependentInfo();
    public bool get_IsIsolated();
    public bool get_IsComplete();
    public bool get_IsStatic();
    public bool get_IsDestructor();
    public bool get_IsCliFinalizer();
    public bool get_IsVirtual();
    public bool get_IsPublic();
    public bool get_IsPrivate();
    public bool get_IsOverride();
    public bool get_IsOverrideOrImplementation();
    public bool get_IsSealed();
    public CppVTableEntryInfoPrimary get_PrimaryVirtualSlot();
    public CppSmallList`1<CppVTableEntryInfo> get_VirtualSlots();
    public CppSmallList`1<CppMethodInheritanceInfo> get_Hides();
    [CanBeNullAttribute]
public static CppMethodInheritanceInfo GetCached(ICppGroupedFunctionDeclaratorResolveEntity entity);
    [CanBeNullAttribute]
public static CppMethodInheritanceInfo GetCached(ICppGroupedFunctionDeclaratorResolveEntity entity, bool withStubs);
    public bool HasVirtualSlot(CppMethodInheritanceInfo slot);
    public List`1<CppMethodInheritanceInfo> GetHides(bool skipImplicit);
    public List`1<CppMethodInheritanceInfo> GetBases(bool skipImplicit, bool skipAliases);
    public List`1<CppVTableEntryInfo> GetVirtualBases(bool skipImplicit, bool skipAliases);
    public List`1<CppVTableEntryInfo> GetAllVirtualBases(bool skipImplicit, bool skipAliases);
    [CanBeNullAttribute]
public CppVTableEntryInfo FindOverridingSlot(CppMethodInheritanceInfo info);
    public bool CanImplementInterfaceMethods();
    public void BuildDirect(Builder builder, CppList`1<CppMethodInheritanceInfo> bases);
    public void BuildExplicitOverrides(Builder builder);
    public void BuildImplement(Builder builder, CppVTableEntryInfo slot);
    public static CppQualType ComputeSignatureType(ICppGroupedFunctionDeclaratorResolveEntity entity);
    private static List`1<ICppTypeTemplateArgument> EnsureCanonicGenericParams(int count);
    public static CppQualType CanonifyGenericParams(CppQualType type, ICppGroupedFunctionDeclaratorResolveEntity entity);
    private void AddPrimarySlot(Builder builder, CppVTableEntryInfo previous, bool isSealed);
    private void AddAliasSlot(Builder builder, CppVTableEntryInfo previous);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppMethodNameKey : ValueType {
    public static CppQualifiedNamePart DESTRUCTOR_NAME;
    public static CppQualifiedNamePart CLI_FINALIZER_NAME;
    public static CppMethodNameKey DESTRUCTOR_KEY;
    public bool IsStatic;
    public CppQualifiedNamePart Name;
    public CppQualifiedNamePart PropertyName;
    public int GenericParamCount;
    public CppMethodNameKey(bool isStatic, CppQualifiedNamePart propName, CppQualifiedNamePart ownName, int genParams);
    private static CppMethodNameKey();
    public static CppMethodNameKey Get(ICppGroupedFunctionDeclaratorResolveEntity entity);
    public virtual int GetHashCode();
    public virtual bool Equals(object rhs);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppMinMaxArgCountResult : ValueType {
    public int MinArgCount;
    public int MaxArgCount;
    public bool CanHaveMoreArguments { get; }
    public bool get_CanHaveMoreArguments();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModule : object {
    public CppFileLocation File;
    public CppGlobalNamespaceModuleEntity GlobalNamespace;
    public HashSet`1<CppFileLocation> IncludedFiles;
    public HashSet`1<CppFileLocation> IncludedPragmaOnceFiles;
    public CppList`1<CppPPDefineSymbol> Defines;
    public CppList`1<CppImportHeaderUnitDirectiveSymbol> HeaderUnitImports;
    public CppList`1<CppImportModuleDirectiveSymbol> ModuleImports;
    [CanBeNullAttribute]
public Int32[] PragmaWarningAsErrors;
    [CanBeNullAttribute]
public Int32[] PragmaWarningDisabled;
    public CppModule(CppFileLocation file, CppGlobalNamespaceModuleEntity globalNamespace, HashSet`1<CppFileLocation> includedFiles, HashSet`1<CppFileLocation> includedPragmaOnceFiles, CppList`1<CppPPDefineSymbol> defines, CppList`1<CppImportHeaderUnitDirectiveSymbol> headerUnitImports, CppList`1<CppImportModuleDirectiveSymbol> moduleImports, Int32[] pragmaWarningAsErrors, Int32[] pragmaWarningDisabled);
    public static CppList`1<CppPPDefineSymbol> FilterOutNonExportableMacros(IEnumerable`1<CppPPDefineSymbol> allDefines);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleAttachment : Enum {
    public byte value__;
    public static CppModuleAttachment Named;
    public static CppModuleAttachment Global;
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleAttributeIndex : ValueType {
    public static int Size;
    private CppAbstractIndex`1<CppModuleAttributeKind> myStorage;
    internal int RawStorage { get; }
    public CppModuleAttributeIndex(CppModuleAttributeKind kind, int rawIndex);
    public CppModuleAttributeIndex(int rawStorage);
    public CppModuleAttributeKind GetKind();
    public int RawIndex();
    internal int get_RawStorage();
    public bool IsValid();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleAttributeKind : Enum {
    public byte value__;
    public static CppModuleAttributeKind Simple;
    public static CppModuleAttributeKind Expression;
    public static CppModuleAttributeKind TypeIdOrExpression;
    public static CppModuleAttributeKind StringLiteral;
    public static CppModuleAttributeKind DoubleStringLiteral;
    public static CppModuleAttributeKind Format;
    public static CppModuleAttributeKind UE;
    public static CppModuleAttributeKind BlockShaders;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleBinaryExpression : CppBinaryExpression {
    public CppModuleResolveResult ResolveResult;
    public CppDependentInfo DependentInfo;
    public CppModuleBinaryExpression(ICppExpression leftArgument, ICppExpression rightArgument, CppOperatorKind operatorKind, CppModuleResolveResult resolveResult, CppDependentInfo dependentInfo);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleBraceInitializedTemporaryExpression : CppBraceInitializedTemporaryExpression {
    public CppModuleResolveResult ResolveResult;
    public CppDependentInfo DependentInfo;
    public CppModuleBraceInitializedTemporaryExpression(ICppTypeIdOrExpression initializerTypeNode, CppResolvedBracedInitListExpression argumentList, CppModuleResolveResult resolveResult, CppDependentInfo dependentInfo);
    public CppResolvedBracedInitListExpression GetResolvedArgumentList();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleBuiltinOffsetOfExpression : CppBuiltinOffsetOfExpression {
    public CppModuleResolveResult ResolvedMember;
    public CppModuleBuiltinOffsetOfExpression(CppQualType typeArgument, CppQualifiedName memberDesignator, CppModuleResolveResult resolvedMember);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleCallExpression : CppCallExpression {
    public CppModuleResolveResult ResolveResult;
    public CppDependentInfo DependentInfo;
    public CppCallExpressionKind Kind;
    public CppModuleCallExpression(ICppTypeIdOrExpression callee, ICppExpression[] arguments, CppCallExpressionKind kind, CppModuleResolveResult resolveResult, CppDependentInfo dependentInfo);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleCastExpression : CppCastExpression {
    public CppModuleResolveResult ResolveResult;
    public CppDependentInfo DependentInfo;
    public CppModuleCastExpression(ICppExpression argument, CppCastType castType, CppQualType targetType, CppModuleResolveResult resolveResult, CppDependentInfo dependentInfo);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleConstrainedTypeTemplateParameter : CppModuleConstrainedTypeTemplateParameterOrPack {
    public CppModuleConstrainedTypeTemplateParameter(CppQualifiedNamePart name, bool orphaned, ICppConceptDefinitionModuleEntity conceptDefinition, bool isInvented);
    public virtual ICppTemplateParameter Import(CppModuleImportingContext ctx);
    internal void ImportConstraint(CppImportedConstrainedTypeTemplateParameter target, CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleConstrainedTypeTemplateParameterOrPack : CppModuleTypeTemplateParameterOrPackBase {
    protected ICppConceptDefinitionModuleEntity ConceptDefinition;
    public CppQualifiedName ConceptNameHint;
    [CompilerGeneratedAttribute]
private bool <IsInvented>k__BackingField;
    public bool IsInvented { get; private set; }
    protected CppModuleConstrainedTypeTemplateParameterOrPack(CppQualifiedNamePart name, bool orphaned, ICppConceptDefinitionModuleEntity conceptDefinition, bool isInvented);
    [CompilerGeneratedAttribute]
public bool get_IsInvented();
    [CompilerGeneratedAttribute]
private void set_IsInvented(bool value);
    protected ICppResolvedExpression CreateConstraint(ICppTypeTemplateParameterOrPack templParam, CppConceptDefinitionResolveEntity conceptDef, CppQualifiedName resolvedConceptNameHint, CppModuleImportingContext ctx);
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleConstrainedTypeTemplateParameterPack : CppModuleConstrainedTypeTemplateParameterOrPack {
    public CppModuleConstrainedTypeTemplateParameterPack(CppQualifiedNamePart name, bool orphaned, ICppConceptDefinitionModuleEntity conceptDefinition, bool isInvented);
    public virtual ICppTemplateParameter Import(CppModuleImportingContext ctx);
    internal void ImportConstraint(CppImportedConstrainedTypeTemplateParameterPack target, CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleDependentTemplateArgument : object {
    private CppDependentModuleEntity myEntity;
    private CppQualifiedName myLookedUpName;
    private bool myIsPackExpansion;
    private bool myHadTypename;
    public CppModuleDependentTemplateArgument(CppDependentModuleEntity entity, CppQualifiedName lookedUpName, bool isPackExpansion, bool hadTypename);
    public sealed virtual ICppTemplateArgument Import(CppModuleImportingContext ctx);
    public sealed virtual CppModuleTemplateArgumentKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    internal static CppModuleDependentTemplateArgument Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleDescriptor : ValueType {
    private CppModuleId myId;
    private CppFileLocation myLocation;
    public bool IsNamedModule { get; }
    internal CppModuleDescriptor(CppModuleId id);
    internal CppModuleDescriptor(CppFileLocation location);
    public static CppModuleDescriptor Create(CppModuleId id, CppFileLocation location);
    public bool get_IsNamedModule();
    public CppModuleId GetId();
    public CppFileLocation GetLocation();
    public sealed virtual bool Equals(CppModuleDescriptor other);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleDirectiveSymbol : CppSymbol {
    [CompilerGeneratedAttribute]
private bool <IsExported>k__BackingField;
    [CompilerGeneratedAttribute]
private CppModuleId <ModuleId>k__BackingField;
    [CompilerGeneratedAttribute]
private CppFileLocation <ContainingFile>k__BackingField;
    public bool IsExported { get; }
    public CppModuleId ModuleId { get; }
    public CppFileLocation ContainingFile { get; }
    public string Name { get; }
    public CppModuleDirectiveSymbol(CppSymbolLocation location, bool isExported, CppModuleId moduleId);
    [CompilerGeneratedAttribute]
public bool get_IsExported();
    [CompilerGeneratedAttribute]
public CppModuleId get_ModuleId();
    [CompilerGeneratedAttribute]
public virtual CppFileLocation get_ContainingFile();
    public virtual TResult Accept(ICppSymbolVisitor`1<TResult> visitor);
    public sealed virtual string get_Name();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleEntityComparer : object {
    public static CppModuleEntityComparer Instance;
    private static CppModuleEntityComparer();
    public sealed virtual bool Equals(ICppModuleEntity x, ICppModuleEntity y);
    public sealed virtual int GetHashCode(ICppModuleEntity obj);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleEntityFactory : object {
    private Dictionary`2<CppModuleEntityKind, List`1<ICppModuleEntity>> myEntities;
    public void Marshal(CppModuleMarshallingContext context, UnsafeWriter writer);
    public void Unmarshal(UnsafeReader reader);
    public void FillContext(CppModuleUnmarshallingContext context);
    private static ICppModuleEntity CreateEmptyModuleEntity(CppModuleEntityKind kind, int index);
    public ICppModuleEntity Get(CppModuleEntityKind kind, int index);
    internal List`1<ICppModuleEntity> GetListOfEntities(CppModuleEntityKind kind);
    public CppClassModuleEntity CreateClass(ICppScopeModuleEntity parent, CppClassKey key, ICppClassResolveEntity source, bool exported);
    public CppEnumModuleEntity CreateEnum(ICppScopeModuleEntity parent, CppClassKey key, ICppClassResolveEntity source, bool exported);
    public CppClassOrEnumModuleEntity CreateClassOrEnum(ICppScopeModuleEntity parent, ICppClassResolveEntity source, bool exported);
    public ClosureTypeEntity CreateLambdaClosure(CppLambdaSymbol symbol, ICppScopeModuleEntity parent, bool isCaptureLess);
    public CppVariableModuleEntity CreateVariable(ICppScopeModuleEntity parent, ICppGroupedVariableDeclaratorResolveEntity source, bool isExplicitlyExported);
    public CppTemplateVariableSpecializationModuleEntity CreateTemplateVariableSpecialization(ICppScopeModuleEntity parent, ICppGroupedVariableDeclaratorResolveEntity source, bool isExplicitlyExported);
    public CppTypeAliasModuleEntity CreateTypeAlias(ICppScopeModuleEntity parent, ICppGroupedTypeDeclaratorResolveEntity source, CppQualifiedNamePart name);
    internal CppTypeAliasModuleEntity CreateTypeAlias(ICppScopeModuleEntity parent, CppQualifiedNamePart name, CppDeclarationSpecifiers declSpecs, CppAccessibility accessibility, IEnumerable`1<ICppSymbol> symbols);
    public CppRegularFunctionModuleEntityWithTypeWithOptionalData CreateFunctionWithTypeWithOptionalData(ICppScopeModuleEntity parent, ICppGroupedFunctionDeclaratorResolveEntity source, CppQualifiedNamePart name, CppSmallArray`1<ICppAttribute> attributes);
    public CppRegularFunctionModuleEntityWithType CreateFunctionWithType(ICppScopeModuleEntity parent, ICppGroupedFunctionDeclaratorResolveEntity source, CppQualifiedNamePart name);
    private CppRegularFunctionModuleEntityWithTypeWithOptionalData CreateFunctionWithTypeWithOptionalData(ICppScopeModuleEntity parent, CppQualifiedNamePart name, CppAccessibility accessibility, CppDeclarationSpecifiers declarationSpecifiers, CppPureVirtualSpecifiers pureVirtualSpecifiers, IEnumerable`1<ICppSymbol> symbols, CppSmallArray`1<ICppAttribute> attributes);
    internal CppRegularFunctionModuleEntityWithType CreateFunctionWithType(ICppScopeModuleEntity parent, CppQualifiedNamePart name, CppAccessibility accessibility, CppDeclarationSpecifiers declarationSpecifiers, CppPureVirtualSpecifiers pureVirtualSpecifiers, IEnumerable`1<ICppSymbol> symbols);
    public CppRegularFunctionModuleEntityWithTypeParts CreateFunctionWithTypeParts(ICppScopeModuleEntity parent, ICppGroupedFunctionDeclaratorResolveEntity source, CppQualifiedNamePart name);
    private CppRegularFunctionModuleEntityWithTypeParts CreateFunctionWithTypeParts(ICppScopeModuleEntity parent, CppQualifiedNamePart name, CppAccessibility accessibility, CppDeclarationSpecifiers declarationSpecifiers, CppPureVirtualSpecifiers pureVirtualSpecifiers, IEnumerable`1<ICppSymbol> symbols);
    public CppRegularFunctionModuleEntityWithTypePartsWithOptionalData CreateFunctionWithTypePartsWithOptionalData(ICppScopeModuleEntity parent, ICppGroupedFunctionDeclaratorResolveEntity source, CppQualifiedNamePart name, CppSmallArray`1<ICppAttribute> attributes);
    internal CppRegularFunctionModuleEntityWithTypePartsWithOptionalData CreateFunctionWithTypePartsWithOptionalData(ICppScopeModuleEntity parent, CppQualifiedNamePart name, CppAccessibility accessibility, CppDeclarationSpecifiers declarationSpecifiers, CppPureVirtualSpecifiers pureVirtualSpecifiers, IEnumerable`1<ICppSymbol> symbols, CppSmallArray`1<ICppAttribute> attributes);
    public CppFriendFunctionModuleEntity CreateFriendFunction(CppClassModuleEntity parent, ICppFunctionDeclaratorResolveEntity source, CppQualifiedNamePart name, CppSmallArray`1<ICppAttribute> attributes);
    public CppTemplateFunctionSpecializationModuleEntity CreateFunctionTemplateSpecialization(ICppScopeModuleEntity parent, ICppGroupedFunctionDeclaratorResolveEntity source, CppQualifiedNamePart name, CppSmallArray`1<ICppAttribute> attributes);
    public CppConceptDefinitionModuleEntity CreateConcept(ICppScopeModuleEntity parent, CppConceptDefinitionResolveEntity source, CppQualifiedNamePart name);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleEntityIndex : ValueType {
    public static int Size;
    private CppAbstractIndex`1<CppModuleEntityKind> myStorage;
    public static CppModuleEntityIndex GlobalNamespace;
    internal int RawStorage { get; }
    public CppModuleEntityIndex(CppModuleEntityKind kind, int rawIndex);
    public CppModuleEntityIndex(int rawStorage);
    private static CppModuleEntityIndex();
    public CppModuleEntityKind GetKind();
    public int RawIndex();
    public bool IsValid();
    internal int get_RawStorage();
    public sealed virtual bool Equals(CppModuleEntityIndex other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleEntityKind : Enum {
    public byte value__;
    public static CppModuleEntityKind Namespace;
    public static CppModuleEntityKind NamespaceAlias;
    public static CppModuleEntityKind Class;
    public static CppModuleEntityKind Enum;
    public static CppModuleEntityKind ReferentialClassOrEnum;
    public static CppModuleEntityKind ExtendedReferentialClassOrEnum;
    public static CppModuleEntityKind NestedClassOrEnum;
    public static CppModuleEntityKind SubstitutedLambdaClass;
    public static CppModuleEntityKind ReExportedClass;
    public static CppModuleEntityKind ReExportedEnum;
    public static CppModuleEntityKind ReExportedLambda;
    public static CppModuleEntityKind Enumerator;
    public static CppModuleEntityKind ReferentialEnumerator;
    public static CppModuleEntityKind UsingEnumerator;
    public static CppModuleEntityKind ConceptDefinition;
    public static CppModuleEntityKind SubstitutedConcept;
    public static CppModuleEntityKind ReExportedConceptDefinition;
    public static CppModuleEntityKind ConstrainedAutoType;
    public static CppModuleEntityKind Super;
    public static CppModuleEntityKind FunctionWithType;
    public static CppModuleEntityKind FunctionWithTypeWithOptionalData;
    public static CppModuleEntityKind FunctionWithTypeParts;
    public static CppModuleEntityKind FunctionWithTypePartsWithOptionalData;
    public static CppModuleEntityKind ReExportedFunctionWithType;
    public static CppModuleEntityKind ReExportedFunctionWithTypeWithOptionalData;
    public static CppModuleEntityKind ReExportedFunctionWithTypeParts;
    public static CppModuleEntityKind ReExportedFunctionWithTypePartsWithOptionalData;
    public static CppModuleEntityKind Variable;
    public static CppModuleEntityKind ReExportedVariable;
    public static CppModuleEntityKind TemplateVariableSpecialization;
    public static CppModuleEntityKind ReExportedTemplateVariableSpecialization;
    public static CppModuleEntityKind TypeAlias;
    public static CppModuleEntityKind ReExportedTypeAlias;
    public static CppModuleEntityKind TemplateFunctionSpecialization;
    public static CppModuleEntityKind ReExportedTemplateFunctionSpecialization;
    public static CppModuleEntityKind UEFunction;
    public static CppModuleEntityKind FriendFunction;
    public static CppModuleEntityKind ReExportedFriendFunction;
    public static CppModuleEntityKind SubstitutedFriendFunction;
    public static CppModuleEntityKind InheritedCtor;
    public static CppModuleEntityKind SpecialMemberFunction;
    public static CppModuleEntityKind SpecialMemberFunctionOfReferentialClass;
    public static CppModuleEntityKind LambdaToFunctionPointerConversion;
    public static CppModuleEntityKind DeductionGuide;
    public static CppModuleEntityKind HlslBuiltinFunction;
    public static CppModuleEntityKind FunctionTemplate;
    public static CppModuleEntityKind VariableTemplate;
    public static CppModuleEntityKind TypeAliasTemplate;
    public static CppModuleEntityKind ClassTemplate;
    public static CppModuleEntityKind SubstitutedFunction;
    public static CppModuleEntityKind SubstitutedVariable;
    public static CppModuleEntityKind SubstitutedTypeTemplateDeclarator;
    public static CppModuleEntityKind SubstitutedTemplateTemplateParameter;
    public static CppModuleEntityKind MemberFunctionOfReferentialClass;
    public static CppModuleEntityKind MemberVariableOfReferentialClass;
    public static CppModuleEntityKind MemberTypedefOfReferentialClass;
    public static CppModuleEntityKind DecayBuiltinTypedef;
    public static CppModuleEntityKind UndeterminedSpecialization;
    public static CppModuleEntityKind UndeterminedVariableSpecialization;
    public static CppModuleEntityKind UsingDeclaration;
    public static CppModuleEntityKind BuiltinOperator;
    public static CppModuleEntityKind BuiltinDestructor;
    public static CppModuleEntityKind Decltype;
    public static CppModuleEntityKind DependentDecltype;
    public static CppModuleEntityKind DependentType;
    public static CppModuleEntityKind DependentAutoType;
    public static CppModuleEntityKind DependentStructuredBindingType;
    public static CppModuleEntityKind DeducedClassTypePlaceholder;
    public static CppModuleEntityKind LambdaClosure;
    public static CppModuleEntityKind LambdaScope;
    public static CppModuleEntityKind LambdaInitCapture;
    public static CppModuleEntityKind RequiresExpressionScope;
    public static CppModuleEntityKind RequiresExpressionParameter;
    public static CppModuleEntityKind RequiresExpressionParameterPack;
    public static CppModuleEntityKind ParameterList;
    public static CppModuleEntityKind EmptyParameterList;
    public static CppModuleEntityKind SubstitutedParameterList;
    public static CppModuleEntityKind UuidDeclarator;
    public static CppModuleEntityKind AnonymousFunctionParameter;
    public static CppModuleEntityKind GeneratedFunctionParameter;
    public static CppModuleEntityKind FunctionParameterWithName;
    public static CppModuleEntityKind FunctionParameterPackWithName;
    public static CppModuleEntityKind FunctionParameterWithInitializer;
    public static CppModuleEntityKind FreeStandingFunctionParameter;
    public static CppModuleEntityKind FreeStandingFunctionParameterWithInitializer;
    public static CppModuleEntityKind TypeTemplateParameter;
    public static CppModuleEntityKind TypeTemplateParameterPack;
    public static CppModuleEntityKind ConstrainedTypeTemplateParameter;
    public static CppModuleEntityKind ConstrainedTypeTemplateParameterPack;
    public static CppModuleEntityKind InventedTypeTemplateParameter;
    public static CppModuleEntityKind InventedTypeTemplateParameterPack;
    public static CppModuleEntityKind ExpressionTemplateParameter;
    public static CppModuleEntityKind ExpressionTemplateParameterPack;
    public static CppModuleEntityKind TemplateTemplateParameter;
    public static CppModuleEntityKind TemplateTemplateParameterPack;
    public static CppModuleEntityKind CompoundStatement;
    public static CppModuleEntityKind ReturnStatement;
    public static CppModuleEntityKind ExpressionStatement;
    public static CppModuleEntityKind CtorInitializerStatement;
    public static CppModuleEntityKind IfStatement;
    public static CppModuleEntityKind WhileStatement;
    public static CppModuleEntityKind DoStatement;
    public static CppModuleEntityKind ForStatement;
    public static CppModuleEntityKind SwitchStatement;
    public static CppModuleEntityKind CatchBlock;
    public static CppModuleEntityKind GotoStatement;
    public static CppModuleEntityKind SubstitutedFunctionBody;
    public static CppModuleEntityKind SubstitutedScopeStatement;
    public static CppModuleEntityKind BSBlock;
    public static CppModuleEntityKind BSBlockShader;
    public static CppModuleEntityKind BSBlockShaderInterface;
    public static CppModuleEntityKind BSCustomizationPoint;
    public static CppModuleEntityKind BSCustomizationPointImplementation;
    public static CppModuleEntityKind BSInterfaceMemberData;
    public static CppModuleEntityKind BSTemplate;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleEnumValue : CppModuleValue {
    public ICppClassOrRefClassModuleEntity Enumeration;
    public ICppValue UnderlyingValue;
    public CppModuleEnumValue(ICppClassOrRefClassModuleEntity enumeration, ICppValue underlyingValue);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleExcessiveTemplateArgument : object {
    private ICppModuleTemplateArgument myInner;
    public CppModuleExcessiveTemplateArgument(ICppModuleTemplateArgument inner);
    public sealed virtual ICppTemplateArgument Import(CppModuleImportingContext ctx);
    public sealed virtual CppModuleTemplateArgumentKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleExportingContext : CppImportExportVisitorBase {
    public CppGlobalNamespaceModuleEntity GlobalNamespace;
    private ICppRootFileResolveEntitiesCache myResolveCache;
    private ICppResolvedTypeFactory myTypeFactory;
    private Dictionary`2<ICppResolveEntity, ICppModuleEntity> myCache;
    private Dictionary`2<CppTemplateParameterTag, ICppModuleTemplateParameter> myTemplateParameterCache;
    private Dictionary`2<ICppTemplateParameter, ICppModuleTemplateParameter> myOrphanedTemplateParameterCache;
    private Dictionary`2<ICppClassResolveEntity, CppClassOrEnumModuleEntity> myClassesExportedWithoutDefinition;
    private HashSet`1<CppNestedNamespaceModuleEntity> myShallowExportedNamespace;
    private Dictionary`2<ICppTypeModuleEntity, CppModuleEntityType> myTypeCache;
    private Dictionary`2<ICppTypeAliasModuleEntity, CppTypedefModuleType> myTypedefTypeCache;
    private ModuleKind myModuleKind;
    private string myModuleName;
    private bool myAllowEntitiesReExport;
    private CppModuleEntityFactory Factory { get; }
    public CppModuleExportingContext(ICppRootFileResolveEntitiesCache resolveCache, ModuleKind moduleKind, bool allowEntitiesReExport);
    public virtual ICppExpression Visit(ICppResolvedCastExpression source);
    public virtual ICppExpression Visit(ICppResolvedCallExpression source);
    public virtual ICppExpression Visit(ICppResolvedUnaryExpression source);
    public virtual ICppExpression Visit(ICppResolvedBinaryExpression source);
    public virtual ICppExpression Visit(ICppResolvedPostfixExpression source);
    public virtual ICppExpression Visit(ICppResolvedSubscriptExpression source);
    public virtual ICppExpression Visit(ICppResolvedConditionalExpression source);
    public virtual ICppExpression Visit(ICppParenExpression source);
    public virtual ICppExpression Visit(ICppResolvedSizeOfExpression sizeofExpr);
    public virtual ICppExpression Visit(ICppResolvedSizeOfEllipsisExpression sizeofExpr);
    public virtual ICppExpression Visit(ICppResolvedAlignOfExpression sizeofExpr);
    public virtual ICppExpression Visit(ICppResolvedNoExceptExpression noexceptExpr);
    public virtual ICppExpression Visit(ICppResolvedUserDefinedLiteralExpression source);
    public virtual ICppExpression Visit(ICppResolvedBraceInitializedTemporaryExpression source);
    public virtual ICppExpression Visit(ICppResolvedSingleArgumentTypeTraitExpression source);
    public virtual ICppExpression Visit(ICppResolvedDoubleArgumentTypeTraitExpression source);
    public virtual ICppExpression Visit(ICppResolvedMultiArgumentTypeTraitExpression source);
    public virtual ICppExpression Visit(ICppResolvedBuiltinOffsetOfExpression source);
    public virtual ICppExpression Visit(ICppResolvedBuiltinAddressOfExpression source);
    public virtual ICppExpression Visit(ICppResolvedNewExpression source);
    public virtual ICppExpression Visit(ICppResolvedQualifiedReferenceExpression source);
    public virtual ICppExpression Visit(ICppResolvedFoldExpression source);
    public virtual ICppExpression Visit(ICppResolvedMemberAccessExpression source);
    public virtual ICppExpression Visit(ICppResolvedMSUuidOfExpression source);
    public virtual ICppExpression Visit(ICppResolvedPackExpansionExpression source);
    public virtual ICppExpression Visit(ICppResolvedTypeIdExpression source);
    public virtual ICppExpression Visit(ICppReplacedLambdaExpression lambda);
    public virtual ICppExpression Visit(ICppResolvedGnuBuiltinConstantPExpression source);
    public virtual ICppExpression Visit(ICppResolvedGNUAddressOfLabelExpression source);
    public virtual ICppExpression Visit(ICppThrowExpression source);
    public virtual ICppExpression Visit(ICppReplacedRequiresExpression source);
    public virtual ICppExpression Visit(ICppReplacedGnuStatementExpression source);
    private CppModuleCallExpression ExportCallExpression(ICppResolvedCallExpression source);
    private CppModuleBraceInitializedTemporaryExpression ExportBraceInitializedTemporary(ICppResolvedBraceInitializedTemporaryExpression source);
    private void ExportGlobalOperatorNewCandidates(ICppResolvedNewExpression expr);
    private bool IsGlobalFunction(CppGroupedFunctionDeclaratorResolveEntity function);
    private Scope ExportRequiresExpressionScope(ICppRequiresExpressionScopeResolveEntity sourceScope, ICppModuleEntity parent);
    private CppSmallArray`1<Parameter> ExportRequiresExpressionParameters(ICppParameterListResolveEntity paramList);
    private Parameter ExportRequiresExpressionParameter(ICppParameterListResolveEntity paramList, ICppVariableDeclaratorResolveEntity source);
    private CppSmallArray`1<ICppRequiresExpressionItem> ExportRequiresExpressionItems(CppList`1<ICppRequiresExpressionItem> source);
    private bool IsNamedModule();
    private CppModuleEntityFactory get_Factory();
    public static CppGlobalNamespaceModuleEntity ExportModule(ICppRootFileResolveEntitiesCache rc, ModuleKind moduleKind, bool allowEntitiesReExport);
    public ICppModuleTemplateParameter ExportTemplateParameter(ICppTemplateParameter source);
    public ICppModuleTemplateParameter ExportTemplateParameterImpl(ICppTemplateParameter source);
    public CppModuleTemplateParameters ExportTemplateParameters(CppTemplateParametersBase source);
    public ICppModuleTemplateArgument ExportTemplateArgument(ICppTemplateArgument source);
    public CppSmallArray`1<ICppModuleTemplateArgument> ExportTemplateArguments(ReadOnlySpan`1<ICppTemplateArgument> source);
    public CppQualifiedNamePart ExportName(CppQualifiedNamePart name);
    public CppModuleSubstitutionId ExportSubstitutionId(CppSubstitutionId substId);
    public CppQualifiedName ExportQualifiedName(CppQualifiedName source);
    public CppUndeterminedSpecializationModuleEntity ExportUndeterminedSpecialization(CppUndeterminedSpecializationResolveEntity source);
    public ICppDependentModuleEntityHead ExportDependentModuleEntityHead(ICppDependentScopeLikeResolveEntity source);
    public ICppTypeModuleEntity Export(ICppClassOrUndeterminedSpecializationResolveEntity re);
    public CppSubstitutedTemplateTemplateParameterModuleEntity Export(CppTemplateTemplateParameterWithAppliedArgumentsResolveEntity source);
    public CppDependentModuleEntity ExportDependentEntity(CppDependentResolveEntity source);
    public ICppTypeModuleEntity ExportTypeDependentEntity(ICppDependentTypeResolveEntity source);
    public CppDependentDecltypeModuleEntity Export(CppDependentDecltypeResolveEntity source);
    public CppDependentStructuredBindingTypeModuleEntity Export(CppDependentStructuredBindingTypeResolveEntity source);
    public CppQualType ExportType(CppQualType type);
    public CppQualType ExportType(ICppDeclaratorResolveEntity declarator);
    public CppSmallArray`1<ICppExpression> ExportInitializerArguments(ICppExpression[] sourceArguments);
    public CppDeclaratorInitializer ExportInitializer(CppDeclaratorInitializer initializer);
    public ICppScopeModuleEntity ExportScopeAutoParent(ICppResolveEntity source);
    private CppParameterListModuleEntityBase ExportParameterListWithCheckCache(CppParameterListResolveEntity parameterList);
    private CppSubstitutedParameterListModuleEntity ExportParameterListWithSubstitution(CppParameterListWithSubstitution source);
    public ICppScopeModuleEntity ExportScopeStatement(ICppScopeStatementResolveEntity source);
    public ICppFunctionModuleEntity ExportFunctionWithSubstitution(CppFunctionDeclaratorWithSubstitution source);
    public ICppScopeModuleEntity ExportClassParentAutoParent(ICppResolveEntity source);
    public ICppClassOrRefClassModuleEntity ExportClassOrEnumAutoParent(ICppClassResolveEntity source);
    public ICppClassOrRefClassModuleEntity ExportClassOrEnumWithoutDefinition(ICppClassResolveEntity source);
    private ICppClassOrRefClassModuleEntity ExportClassOrEnumWithoutDefinition(ICppClassResolveEntity source, bool exported);
    private CppClassOrEnumModuleEntity ExportClassOrEnumWithoutDefinition(ICppScopeModuleEntity targetParent, ICppClassResolveEntity source, bool exported);
    public ICppClassOrRefClassModuleEntity ExportClassOrEnum(ICppScopeModuleEntity targetParent, ICppClassResolveEntity source);
    [CanBeNullAttribute]
private ICppClassOrRefClassModuleEntity TryExportLambdaClass(ICppClassResolveEntity source);
    [CanBeNullAttribute]
private CppReExportedClassOrEnumModuleEntity TryReExportClassOrEnum(ICppClassResolveEntity source);
    private static bool CouldBeReExported(CppClassOrEnumModuleEntity reexportingClass);
    private CppReExportedClassOrEnumModuleEntity ReExportClassOrEnum(CppClassOrEnumData sourceData, ICppClassResolveEntity source, CppClassOrEnumModuleEntity reexportingClass);
    public ICppClassOrRefClassModuleEntity ExportReferentialClass(ICppScopeModuleEntity targetParent, ICppClassResolveEntity source, CppClassModuleEntityKind kind);
    private CppReferentialClassOrEnumModuleEntity ExportReferentialClass(ICppClassResolveEntity source, ICppTemplateArgument[] sourceTemplateArguments);
    private ICppClassOrRefClassModuleEntity ExportSpecializations(CppClassTemplateResolveEntityPack sourcePack, ICppClassResolveEntity& sourcePrimaryTemplate);
    private CppSubstitutedLambdaClassModuleEntity ExportLambdaSubstitution(CppClassResolveEntityWithSubstitution source, List`1<ICppTemplateParameter> templateDeps, ICppClassOrRefClassModuleEntity targetInner, ICppScopeModuleEntity targetParent);
    private void ExportClass(ICppClassResolveEntity source, ICppClassResolveEntity sourcePrimaryTemplate, CppClassModuleEntity target, ICppScopeModuleEntity targetParent);
    private void ExportDeductionGuides(CppClassTemplateResolveEntityPack pack, CppClassModuleEntity targetPrimaryTemplate, CppNamespaceModuleEntity targetNamespace);
    private void ForceImportOfAllSpecializations(ICppClassResolveEntity clazz, CppNamespaceResolveEntity parent);
    private void ForceImportNamespace(CppNamespaceResolveEntity ns);
    private CppBasicBaseDescription`1[] ExportBases(CppBasicBaseDescription`1[] source);
    private CppBasicBaseDescription`1[] ExportNonDependentBases(CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> source);
    private ICppClassModuleEntityChild[] ExportClassChildren(List`1<ICppResolveEntity> sourceMembers, CppClassModuleEntity target);
    public void ExportDefaultTemplateArguments(ICppTemplateArgument[] sourceDefaultTemplateArguments, CppQualifiedNamePart targetName);
    public CppSmallArray`1<ICppModuleEntity> ExportFriends(ICppClassResolveEntity source, CppClassModuleEntity targetClass);
    private CppSmallArray`1<ICppAttribute> ExportAttributes(CppAttributeList source);
    [CanBeNullAttribute]
public static ICppGroupedFunctionDeclaratorResolveEntity TryFindGroupedForFriendFunction(ICppFunctionDeclaratorResolveEntity function);
    public void ExportEnum(ICppClassResolveEntity source, CppEnumModuleEntity target, ICppScopeModuleEntity parent);
    public ICppEnumeratorModuleEntity ExportEnumeratorAutoParent(ICppEnumeratorResolveEntity source);
    public CppEnumeratorModuleEntity ExportEnumerator(CppEnumModuleEntity parent, CppEnumeratorResolveEntity source);
    public ICppFunctionModuleEntity ExportFunctionAutoParent(ICppGroupedFunctionDeclaratorResolveEntity source);
    public CppSubstitutedFunctionModuleEntity ExportSubstitutedFunction(ICppFunctionTemplateDeclaratorResolveEntity templateDecl, ICppGroupedFunctionDeclaratorResolveEntity source);
    private static ICppTemplateArgument[] GetSubstitutionTemplateArguments(ICppFunctionTemplateDeclaratorResolveEntity templateDecl, ICppFunctionDeclaratorResolveEntity substituted);
    private CppSmallArray`1<ICppModuleTemplateArgument> FilterOut(ICppTemplateArgument[] sourceTemplateArguments, Int32[] defaultedTemplateArguments);
    private static bool IsSubstitutedFriendFunction(ICppGroupedFunctionDeclaratorResolveEntity source, CppFunctionDeclaratorWithSubstitution& funcWithSubstitution);
    [CanBeNullAttribute]
private CppSubstitutedFriendFunctionModuleEntity TryExportSubstitutedFriendFunction(ICppGroupedFunctionDeclaratorResolveEntity source);
    public ICppFunctionModuleEntity ExportNonSubstitutedFunctionAutoParent(ICppGroupedFunctionDeclaratorResolveEntity source);
    public static CppSpecialMemberFunctionKind GetSpecialMemberFunctionKind(ICppGeneratedFunctionDeclaratorResolveEntity function, ICppClassResolveEntity clazz);
    [CanBeNullAttribute]
public CppSubstitutedFriendFunctionModuleEntity ExportSubstitutedFriendFunction(CppFunctionDeclaratorWithSubstitution source, ICppClassResolveEntity& lexicalParent);
    public CppSubstitutedFriendFunctionModuleEntity ExportSubstitutedFriendFunction(CppFunctionDeclaratorWithSubstitution source, ICppFriendFunctionModuleEntity targetInner, ICppClassResolveEntity innerLexicalParent, ICppClassResolveEntity& lexicalParent);
    public ICppFunctionModuleEntity ExportFunction(ICppScopeModuleEntity targetParent, ICppGroupedFunctionDeclaratorResolveEntity source, bool exportBody, bool isExplicitlyExported);
    private static bool ShouldAddFriendFunctionToEnclosingNamespace(ICppGroupedFunctionDeclaratorResolveEntity grouped);
    public CppFriendFunctionModuleEntity ExportFriendFunction(CppClassModuleEntity targetParent, ICppFunctionDeclaratorResolveEntity source);
    [CanBeNullAttribute]
private ICppTemplateArgument[] GetDefaultTemplateArgumentsOfUngroupedFunction(ICppFunctionDeclaratorResolveEntity func);
    [CanBeNullAttribute]
private static ICppTemplateArgument[] GetDefaultTemplateArguments(CppTemplateParametersBase tparams, ICppResolvedTypeFactory tf);
    private void SetOwningModule(ICppTopLevelDeclaratorModuleEntity target, ICppDeclaratorResolveEntity source);
    private void SetOwningModule(ICppModuleEntity target, string module);
    [CanBeNullAttribute]
private string GetOwningModule(ICppClassResolveEntity clazz);
    private bool ShouldExportFunctionType(ICppDeclaratorResolveEntity function);
    private CppQualType[] ExportFunctionParameters(CppQualType[] sourceParameterTypes);
    private static bool CouldBeConstantlyEvaluated(ICppGroupedFunctionDeclaratorResolveEntity func);
    private bool ShouldExportFunctionBody(ICppGroupedFunctionDeclaratorResolveEntity func);
    public CppUEGeneratedFunctionModuleEntity ExportUEGeneratedFunction(ICppScopeModuleEntity targetParent, CppGroupedFunctionDeclaratorResolveEntity source);
    public CppParameterListModuleEntityBase ExportParameterList(ICppScopeModuleEntity targetParent, ICppGroupedFunctionDeclaratorResolveEntity sourceFunction, CppParameterListResolveEntity paramList, CppQualifiedNamePart sourceName);
    public void CopyTemplateParameters(CppTemplateParametersBase from, CppTemplateParametersBase to);
    public CppDeductionGuideModuleEntity ExportDeductionGuide(CppClassModuleEntity targetPrimaryTemplate, ICppUserProvidedDeductionGuide source);
    private CppFunctionParameterModuleEntity ExportFunctionParameter(ICppVariableDeclaratorResolveEntity source, CppParameterListResolveEntity sourceParamList, CppParameterListModuleEntity targetParamList);
    public CppDeductionGuideModuleEntity ExportDeductionGuideTemplate(CppClassModuleEntity targetPrimaryTemplate, CppUserProvidedDeductionGuideTemplate source);
    public CppCompoundStatementModuleEntity ExportFunctionBody(ICppFunctionBodyResolveEntity source, CppRegularFunctionModuleEntity function);
    public CppCompoundStatementModuleEntity ExportCompoundStatement(CppCompoundStatementResolveEntity source, CppRegularFunctionModuleEntity function);
    public ICppModuleEntity[] ExportCompoundStatementChildren(List`1<ICppResolveEntity> source, CppCompoundStatementModuleEntity targetParent, CppRegularFunctionModuleEntity function);
    public ICppModuleEntity ExportStatement(ICppResolveEntity source, ICppScopeModuleEntity targetParent, CppRegularFunctionModuleEntity function);
    public CppReturnStatementModuleEntity ExportReturnStatement(CppReturnStatementResolveEntity source);
    public CppIfStatementModuleEntity ExportIfStatement(CppIfStatementResolveEntity source, CppRegularFunctionModuleEntity function);
    public CppLoopStatementModuleEntity ExportLoopStatement(CppLoopStatementModuleEntity target, CppLoopStatementResolveEntityBase source, CppRegularFunctionModuleEntity function);
    public CppForStatementModuleEntity ExportForStatement(CppForStatementResolveEntity source, CppRegularFunctionModuleEntity function);
    public CppScopeStatementModuleEntity ExportControlStructureStatement(CppScopeStatementModuleEntity target, CppControlStructureScopeResolveEntity source, CppRegularFunctionModuleEntity function);
    public void ExportScopeStatementChildren(CppScopeResolveEntityBase source, CppScopeStatementModuleEntity target, CppRegularFunctionModuleEntity function);
    public CppCtorInitializerStatementModuleEntity ExportCtorInitializerStatement(CppCtorInitializerStatementResolveEntity source);
    public ICppModuleEntity ExportCtorInitializerTarget(ICppResolveEntity source);
    public CppSmallArray`1<ICppExpression> ExportResolvedArguments(ICppResolvedExpression[] sourceArgs);
    public CppNamespaceModuleEntity ExportNamespaceAutoParent(CppNamespaceResolveEntity source);
    public void ExportNamespaceChildren(CppNamespaceModuleEntity res, CppNamespaceResolveEntity source);
    public CppNestedNamespaceModuleEntity ExportNamespace(CppNamespaceModuleEntity targetParent, CppNamespaceResolveEntity source, bool deep);
    public CppSmallArray`1<CppClassOrEnumModuleEntity> ExportAnonymousClasses(ICppScopeModuleEntity targetParent, CppList`1<ICppClassResolveEntity> source);
    public CppNestedNamespaceModuleEntity[] ExportInlineNamespaces(CppList`1<CppNamespaceResolveEntity> source);
    public ICppNamespaceModuleEntityChild ExportNamespaceAlias(ICppScopeModuleEntity targetParent, CppNamespaceAliasResolveEntity source);
    public ICppTypeAliasModuleEntity ExportTypeAliasAutoParent(ICppGroupedTypeDeclaratorResolveEntity source, bool reexportForbidden);
    public CppTypeAliasModuleEntity ExportTypeAlias(ICppScopeModuleEntity targetParent, ICppGroupedTypeDeclaratorResolveEntity source);
    public CppUsingEnumeratorModuleEntity ExportUsingEnumerator(CppUsingEnumEnumeratorResolveEntity source);
    public ICppConceptDefinitionModuleEntity ExportConceptDefinitionAutoParent(CppConceptDefinitionResolveEntity source);
    public ICppConceptDefinitionModuleEntity ExportConceptDefinition(ICppScopeModuleEntity targetParent, CppConceptDefinitionResolveEntity source);
    public CppUsingDeclarationModuleEntity ExportUsingDeclaration(CppUsingDeclarationResolveEntity source, ICppScopeModuleEntity parent);
    public HlslBuiltinFunctionModuleEntity ExportHlslBuiltinFunction(HlslBuiltinFunctionResolveEntity entity, ICppModuleEntity parent);
    public ICppModuleEntity ExportVariableOrParameterAutoParent(ICppGroupedVariableDeclaratorResolveEntity source);
    public ICppVariableModuleEntity ExportVariableAutoParent(ICppGroupedVariableDeclaratorResolveEntity source);
    public ICppVariableModuleEntity ExportNonCachedVariableAutoParent(ICppGroupedVariableDeclaratorResolveEntity source);
    private CppSmallArray`1<ICppModuleTemplateArgument> ExportTemplateArgumentsWithoutDefaults(ICppTemplateResolveEntityBase template, ReadOnlySpan`1<ICppTemplateArgument> arguments, int firstArgToExport);
    public ICppVariableModuleEntity ExportVariableWithoutSubstitution(ICppScopeModuleEntity targetParent, ICppGroupedVariableDeclaratorResolveEntity source);
    public ICppVariableModuleEntity ExportVariable(ICppScopeModuleEntity targetParent, ICppGroupedVariableDeclaratorResolveEntity source, bool isExplicitlyExported);
    private CppDeclaratorInitializer GetInitializer(ICppGroupedVariableDeclaratorResolveEntity var);
    public void ExportNamespaceChild(CppNamespaceModuleEntity targetParent, ICppResolveEntity source);
    private BSBlockModuleEntity ExportBSBlock(BSBlockResolveEntity resolveEntity, ICppScopeModuleEntity parent);
    private BSBlockShaderModuleEntity ExportBSBlockShader(BSBlockShaderResolveEntity resolveEntity, ICppScopeModuleEntity parent);
    private BSBlockShaderInterfaceModuleEntity ExportBSBlockShaderInterface(BSBlockShaderInterfaceResolveEntity resolveEntity, ICppScopeModuleEntity parent);
    private BSTemplateModuleEntity ExportBSTemplate(BSTemplateResolveEntity resolveEntity, ICppScopeModuleEntity parent);
    private void ExportDeclaratorPack(CppNamespaceModuleEntity targetParent, CppDeclaratorResolveEntityPack declaratorResolveEntityPack);
    private bool FromAnotherModule(ICppGroupedFunctionDeclaratorResolveEntity func);
    private bool FromAnotherModule(ICppGroupedVariableDeclaratorResolveEntity var);
    private void ExportTopLevelClassOrEnum(CppNamespaceModuleEntity targetParent, ICppClassResolveEntity classResolveEntity);
    private bool TopLevelClassMustBeExported(ICppClassResolveEntity classResolveEntity);
    private void ExportClassTemplatePack(CppNamespaceModuleEntity targetParent, CppClassTemplateResolveEntityPack classTemplateResolveEntityPack);
    private static bool HasNonFriendUngroupedDeclarators(ICppGroupedFunctionDeclaratorResolveEntity grouped);
    public ICppClassModuleEntityChild ExportClassChild(CppClassModuleEntity targetParent, ICppResolveEntity source, CppList`1& functionsWithBody, CppList`1& ueGeneratedFunctions);
    private ICppClassModuleEntityChild ExportMemberFunction(CppClassModuleEntity targetParent, CppGroupedFunctionDeclaratorResolveEntity source, CppList`1& functionsWithBody, CppList`1& ueGeneratedFunctions);
    private CppSpecialMemberFunctionOfReferentialClassModuleEntity CreateImplicitlyGeneratedConstructor(CppGroupedFunctionDeclaratorResolveEntity source, CppSpecialMemberFunctionKind kind, CppClassModuleEntity targetParent);
    protected virtual ICppResolvedTypeFactory GetTypeFactory();
    protected virtual CppQualifiedName ReApply(CppQualifiedName name);
    public CppModuleResolveResult ExportResolveResult(CppResolveResult& source, CppViewPos& vp);
    public CppSmallArray`1<ICppModuleEntity> ExportResolveResultCandidates(FrugalLocalList`1<ICppResolveEntity> sourceCandidates, CppViewPos& vp);
    public static ICppGroupedFunctionDeclaratorResolveEntity GetInnerIfShadow(ICppGroupedFunctionDeclaratorResolveEntity func);
    public static ICppGroupedVariableDeclaratorResolveEntity GetInnerIfShadow(ICppGroupedVariableDeclaratorResolveEntity var);
    public static ICppGroupedTypeDeclaratorResolveEntity GetInnerIfShadow(ICppGroupedTypeDeclaratorResolveEntity type);
    public ICppModuleEntity ExportCandidate(ICppResolveEntity source, CppViewPos& vp);
    private CppFunctionTemplateModuleEntity ExportFunctionTemplate(ICppFunctionTemplateDeclaratorResolveEntity source, CppViewPos& vp);
    private ICppFunctionModuleEntity ExportTemplateFunctionSpecialization(ICppGroupedFunctionDeclaratorResolveEntity spec);
    private CppBuiltinDestructorResolveEntity ExportBuiltinDestructor(CppBuiltinDestructorResolveEntity source);
    private CppBuiltinOperatorResolveEntity ExportBuiltinOperator(CppBuiltinOperatorResolveEntity source);
    private CppSubstitutedConceptModuleEntity ExportSubstitutedConcept(CppConceptDefinitionWithAppliedArgumentsResolveEntity source);
    private CppSubstitutedVariableModuleEntity ExportSubstitutedVariable(ICppGroupedVariableDeclaratorResolveEntity source, ICppVariableTemplateDeclaratorResolveEntity template, ICppScopeModuleEntity targetParent);
    private CppUndeterminedVariableSpecializationModuleEntity ExportUndeterminedTemplateVariableSpecialization(CppUndeterminedTemplateVariableSpecializationResolveEntity source, CppViewPos& vp);
    private CppSmallArray`1<ICppVariableModuleEntity> ExportSpecializations(ICppVariableTemplateDeclaratorResolveEntity template, ICppScopeModuleEntity targetParent, CppViewPos& vp);
    public CppSubstitutedTypeTemplateDeclaratorModuleEntity ExportSubstitutedTypeTemplateDeclarator(CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity source);
    public CppDependentDeducedClassTypePlaceholderModuleEntity ExportDependentDeducedClassTypePlaceholder(CppDependentDeducedClassTypePlaceholder placeholder);
    public ICppModuleEntity ExportClassTemplate(ICppDeducibleTypeTemplateResolveEntity classTemplate);
    public CppDeclaratorInitializer ExportDeducedClassTypeInitializer(CppDependentDeducedClassTypePlaceholder placeholder);
    public IClosureTypeEntity ExportLambdaClosureType(CppLambdaClassResolveEntity source);
    public LambdaScope ExportScope(CppLambdaScopeResolveEntity source);
    public CppClassModuleEntityKind ComputeClassKind(ICppScopeModuleEntity targetParent, ICppClassResolveEntity source);
    public CppParameterListModuleEntityBase ExportParameterList(CppParameterListResolveEntity source);
    private CppFunctionParameterModuleEntity ExportFreeStandingFunctionParameter(ICppVariableDeclaratorResolveEntity source, CppParameterListResolveEntity sourceParamList, CppParameterListModuleEntity targetParamList);
    protected virtual ICppExpression ReApplyToTypeConstraint(ICppExpression source);
    protected virtual ICppEvaluationResult ReApplyToEnumeratorValue(ICppEnumValue value);
    protected virtual ICppEvaluationResult ReApplyToObjectValue(ICppObjectValue value);
    public CppModuleObjectValue Export(CppObjectValue value);
    public Dictionary`2<ICppVariableModuleEntity, ICppEvaluationResult> ExportObjectFields(Dictionary`2<ICppGroupedVariableDeclaratorResolveEntity, ICppEvaluationResult> source);
    protected virtual CppArrayValue ReApplyToArrayValue(CppArrayValue value);
    private CppModuleStringLiteralArrayValue ExportStringLiteralArrayValue(CppStringLiteralArrayValue source);
    private CppModuleRuntimeArrayValue ExportRuntimeArrayValue(CppRuntimeArrayValue source);
    protected virtual ICppEvaluationResult ReApplyToPointerValue(ICppPointerValue value);
    public ICppModuleEntity ExportReferencedDeclarator(ICppDeclaratorResolveEntity decl);
    protected virtual ICppEvaluationResult ReApplyToReferenceValue(ICppReferenceValue value);
    private ICppReferenceValue ReApplyToReferenceValueImpl(ICppReferenceValue value);
    private CppModuleReferenceToField ReApplyToReferenceToField(CppReferenceToField refToField);
    private CppModuleReferenceToDeclarator ReApplyToReferenceToDeclarator(CppReferenceToDeclarator referenceToDeclarator);
    protected virtual CppStringLiteralValue ReApplyToStringLiteral(CppStringLiteralValue value);
    public virtual CppUnknownEntityInfo Visit(CppUnknownTemplateDeductionInfo info);
    public virtual CppUnknownEntityInfo Visit(CppNontypeResolveEntityUsedAsTypeFailure info);
    public virtual CppUnknownEntityInfo Visit(CppNontypeModuleEntityUsedAsTypeFailure info);
    protected virtual ICppDesignation CreateDesignation(ICppDesignator designator, ICppExpression initializer, ICppDesignation source);
    public ICppModuleTemplateParameter FindTemplateParameter(ICppTemplateParameter t);
    public CppViewPos GlobalNamespaceViewPos();
    public CppModuleEntityType GetOrCreateType(ICppTypeModuleEntity entity);
    public void FinishExport();
    private static bool IsBuiltinEntity(ICppGroupedFunctionDeclaratorResolveEntity grouped);
    private static bool IsBuiltinEntity(ICppGroupedTypeDeclaratorResolveEntity grouped);
    private static bool IsNotGenerated(ICppDeclaratorResolveEntity ungrouped);
    public virtual ICppModuleTemplateArgument Visit(CppMonostate m, CppQualType sourceType);
    public virtual ICppModuleTemplateArgument Visit(CppMonostate m, CppTypeTemplateArgument source);
    public virtual ICppModuleTemplateArgument Visit(CppMonostate m, CppTypeTemplateArgumentPack csource);
    public virtual ICppModuleTemplateArgument Visit(CppMonostate m, CppExpressionTemplateArgument csource);
    public virtual ICppModuleTemplateArgument Visit(CppMonostate m, CppExpressionTemplateArgumentPack csource);
    public virtual ICppModuleTemplateArgument Visit(CppMonostate m, CppTemplateTemplateArgument arg);
    public virtual ICppModuleTemplateArgument Visit(CppMonostate m, CppTemplateTemplateArgumentPack arg);
    public virtual ICppModuleTemplateArgument Visit(CppMonostate m, CppLookupFailureTemplateArgument csource);
    public virtual ICppModuleTemplateArgument Visit(CppMonostate m, CppDependentTemplateArgument arg);
    public virtual ICppModuleTemplateArgument Visit(CppMonostate m, CppInjectedClassNameTemplateArgument arg);
    public virtual ICppModuleTemplateArgument Visit(CppMonostate m, CppExcessiveTemplateArgument arg);
    public virtual ICppModuleTemplateArgument Visit(CppMonostate m, CppQualifiedReferenceTemplateArgument source);
    public CppModuleTemplateTemplateArgument ExportTemplateTemplateArgument(CppTemplateTemplateArgument source);
    public object ExportTemplateTemplateArgumentData(CppTemplateTemplateArgument source);
    public virtual CppQualType Visit(CppResolvedClassType t, Qualifiers q);
    public virtual CppQualType Visit(CppResolvedEnumType t, Qualifiers q);
    public virtual CppQualType Visit(CppTemplateParameterType t, Qualifiers q);
    public virtual CppQualType Visit(CppGenericParameterType t, Qualifiers q);
    public virtual CppQualType Visit(CppResolvedAutoType t, Qualifiers q);
    public virtual CppQualType Visit(CppTypedefType t, Qualifiers q);
    public virtual CppQualType Visit(CppInstantiatedTemplateAliasType t, Qualifiers q);
    public virtual CppQualType Visit(CppPackExpansionType t, Qualifiers q);
    public virtual CppQualType Visit(CppDependentType t, Qualifiers q);
    public virtual CppQualType Visit(CppDependentInstantiatedTemplateAliasType t, Qualifiers q);
    public virtual CppQualType Visit(CppDeducedClassTypePlaceholder placeholder, Qualifiers q);
    public virtual CppQualType Visit(CppDeducedClassTypePlaceholderModuleType t, Qualifiers q);
    public virtual CppQualType Visit(CppNamedParameterType t, Qualifiers q);
    public CppConstrainedAutoTypeModuleEntity ExportConstrainedAutoType(CppQualifiedName name, ICppResolvedExpression constraint, bool isDecltypeAuto);
    public ICppConceptDefinitionModuleEntity GetReferencedConceptFromConstraint(CppResolvedQualifiedReferenceExpression qualRef);
    private ICppDecoratedFunctionParameter ReApply(ICppVariableDeclaratorResolveEntity ungroupedParameter);
    [CompilerGeneratedAttribute]
internal static CppFunctionParameterModuleEntity <ExportParameterList>g__CreateFunctionParameter|135_0(ICppVariableDeclaratorResolveEntity source);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleExpressionIndex : ValueType {
    public static int Size;
    private CppAbstractIndex`1<CppModuleExpressionKind> myStorage;
    internal int RawStorage { get; }
    public CppModuleExpressionIndex(CppModuleExpressionKind kind, int rawIndex);
    public CppModuleExpressionIndex(int rawStorage);
    public CppModuleExpressionKind GetKind();
    public int RawIndex();
    internal int get_RawStorage();
    public bool IsValid();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleExpressionKind : Enum {
    public byte value__;
    public static CppModuleExpressionKind Empty;
    public static CppModuleExpressionKind Literal;
    public static CppModuleExpressionKind QualifiedReference;
    public static CppModuleExpressionKind MemberAccess;
    public static CppModuleExpressionKind Cast;
    public static CppModuleExpressionKind Call;
    public static CppModuleExpressionKind BraceInitializedTemporary;
    public static CppModuleExpressionKind New;
    public static CppModuleExpressionKind Delete;
    public static CppModuleExpressionKind Paren;
    public static CppModuleExpressionKind Postfix;
    public static CppModuleExpressionKind Unary;
    public static CppModuleExpressionKind Binary;
    public static CppModuleExpressionKind Subscript;
    public static CppModuleExpressionKind Conditional;
    public static CppModuleExpressionKind BracedInitList;
    public static CppModuleExpressionKind SizeOf;
    public static CppModuleExpressionKind SizeOfEllipsis;
    public static CppModuleExpressionKind AlignOf;
    public static CppModuleExpressionKind MsUuidOf;
    public static CppModuleExpressionKind TypeId;
    public static CppModuleExpressionKind OffsetOf;
    public static CppModuleExpressionKind AddressOf;
    public static CppModuleExpressionKind MsAssume;
    public static CppModuleExpressionKind Throw;
    public static CppModuleExpressionKind MsNoop;
    public static CppModuleExpressionKind PackExpansion;
    public static CppModuleExpressionKind Noexcept;
    public static CppModuleExpressionKind This;
    public static CppModuleExpressionKind Fold;
    public static CppModuleExpressionKind GnuStatement;
    public static CppModuleExpressionKind SingleArgumentTypeTrait;
    public static CppModuleExpressionKind DoubleArgumentTypeTrait;
    public static CppModuleExpressionKind MultiArgumentTypeTrait;
    public static CppModuleExpressionKind UDL;
    public static CppModuleExpressionKind BuiltinConstantP;
    public static CppModuleExpressionKind GnuAddressOfLabel;
    public static CppModuleExpressionKind Designation;
    public static CppModuleExpressionKind Requires;
    public static CppModuleExpressionKind Lambda;
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleExpressionMarshaller : CppAbstractExpressionVisitorWithDefaults`1<CppMonostate> {
    private CppModuleMarshallingContext myContext;
    public CppBinaryStreamWriter Writer;
    public CppModuleExpressionMarshaller(CppModuleMarshallingContext context);
    public virtual CppMonostate VisitExpression(ICppExpression expr);
    public virtual CppMonostate Visit(ICppEmptyExpression expr);
    public virtual CppMonostate Visit(ICppResolvedLiteralExpression expr);
    private int MarshalValue(ICppValue value);
    public virtual CppMonostate Visit(ICppQualifiedReferenceExpression expr);
    public virtual CppMonostate Visit(ICppMemberAccessExpression expr);
    public virtual CppMonostate Visit(ICppCastExpression expr);
    public virtual CppMonostate Visit(ICppCallExpression expr);
    public virtual CppMonostate Visit(ICppBraceInitializedTemporaryExpression expr);
    public virtual CppMonostate Visit(ICppParenExpression expr);
    public virtual CppMonostate Visit(ICppNewExpression expr);
    public virtual CppMonostate Visit(ICppDeleteExpression delete);
    public virtual CppMonostate Visit(ICppPostfixExpression expr);
    public virtual CppMonostate Visit(ICppUnaryExpression expr);
    public virtual CppMonostate Visit(ICppBinaryExpression expr);
    public virtual CppMonostate Visit(ICppSubscriptExpression expr);
    public virtual CppMonostate Visit(ICppConditionalExpression conditional);
    public virtual CppMonostate Visit(ICppResolvedBracedInitListExpression expr);
    public virtual CppMonostate Visit(ICppSizeOfExpression expr);
    public virtual CppMonostate Visit(ICppSizeOfEllipsisExpression expr);
    public virtual CppMonostate Visit(ICppAlignOfExpression expr);
    public virtual CppMonostate Visit(ICppMSUuidOfExpression expr);
    public virtual CppMonostate Visit(ICppBuiltinAddressOfExpression expr);
    public virtual CppMonostate Visit(ICppBuiltinOffsetOfExpression expr);
    public virtual CppMonostate Visit(ICppMSAssumeExpression expr);
    public virtual CppMonostate Visit(ICppThrowExpression expr);
    public virtual CppMonostate Visit(ICppGnuBuiltinConstantPExpression expr);
    public virtual CppMonostate Visit(ICppGNUAddressOfLabelExpression expr);
    public virtual CppMonostate Visit(ICppTypeIdExpression expr);
    public virtual CppMonostate Visit(ICppPackExpansionExpression expr);
    public virtual CppMonostate Visit(ICppNoExceptExpression expr);
    public virtual CppMonostate Visit(ICppResolvedThisExpression this);
    public virtual CppMonostate Visit(ICppFoldExpression expr);
    public virtual CppMonostate Visit(ICppGnuStatementExpression expr);
    public virtual CppMonostate Visit(ICppSingleArgumentTypeTraitExpression typeTrait);
    public virtual CppMonostate Visit(ICppDoubleArgumentTypeTraitExpression typeTrait);
    public virtual CppMonostate Visit(ICppMultiArgumentTypeTraitExpression typeTrait);
    public virtual CppMonostate Visit(ICppUserDefinedLiteralExpression expr);
    public virtual CppMonostate Visit(ICppDesignation designation);
    public virtual CppMonostate Visit(ICppRequiresExpression expr);
    public virtual CppMonostate Visit(ICppLambdaExpression expr);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleExpressionSerializationDataProvider : CppAbstractExpressionVisitorWithDefaults`1<ValueTuple`2<CppModuleExpressionKind, int>> {
    public static CppModuleExpressionSerializationDataProvider Instance;
    private static CppModuleExpressionSerializationDataProvider();
    public virtual ValueTuple`2<CppModuleExpressionKind, int> VisitExpression(ICppExpression expr);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppEmptyExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppResolvedLiteralExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppQualifiedReferenceExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppMemberAccessExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppCastExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppCallExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppBraceInitializedTemporaryExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppNewExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppDeleteExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppParenExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppPostfixExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppUnaryExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppBinaryExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppSubscriptExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppConditionalExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppResolvedBracedInitListExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppSizeOfExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppSizeOfEllipsisExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppAlignOfExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppMSUuidOfExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppTypeIdExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppBuiltinAddressOfExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppBuiltinOffsetOfExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppMSAssumeExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppThrowExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppMSNoopExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppPackExpansionExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppNoExceptExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppResolvedThisExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppFoldExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppGnuStatementExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppSingleArgumentTypeTraitExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppDoubleArgumentTypeTraitExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppMultiArgumentTypeTraitExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppUserDefinedLiteralExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppGnuBuiltinConstantPExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppGNUAddressOfLabelExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppDesignation _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppRequiresExpression _);
    public virtual ValueTuple`2<CppModuleExpressionKind, int> Visit(ICppLambdaExpression _);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleExpressionTemplateArgumentPack : object {
    private ICppExpression[] myPacked;
    public CppModuleExpressionTemplateArgumentPack(ICppExpression[] packed);
    public sealed virtual ICppTemplateArgument Import(CppModuleImportingContext ctx);
    public sealed virtual CppModuleTemplateArgumentKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleExpressionTemplateParameter : CppModuleExpressionTemplateParameterOrPack {
    public CppModuleExpressionTemplateParameter(CppQualType type, CppQualifiedNamePart name, bool orphaned);
    public virtual ICppTemplateParameter Import(CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleExpressionTemplateParameterOrPack : CppModuleTemplateParameterBase {
    protected CppQualType Type;
    protected CppModuleExpressionTemplateParameterOrPack(CppQualType type, CppQualifiedNamePart name, bool orphaned);
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleExpressionTemplateParameterPack : CppModuleExpressionTemplateParameterOrPack {
    public CppModuleExpressionTemplateParameterPack(CppQualType type, CppQualifiedNamePart name, bool orphaned);
    public virtual ICppTemplateParameter Import(CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleFoldExpression : CppFoldExpression {
    public bool IsLeftFold;
    public CppModuleFoldExpression(ICppExpression leftArgument, ICppExpression rightArgument, CppOperatorKind operatorKind, bool isLeftFold);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleGnuStatementExpression : object {
    public CppCompoundStatementModuleEntity Parent;
    public CppCompoundStatementModuleEntity Statement;
    public CppModuleGnuStatementExpression(CppCompoundStatementModuleEntity parent, CppCompoundStatementModuleEntity statement);
    public sealed virtual CppCompoundStatementInExpressionSymbol GetStatementSymbol();
    public sealed virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleId : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Partition>k__BackingField;
    public string Name { get; public set; }
    public string Partition { get; public set; }
    public CppModuleId(string Name, string Partition);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Partition();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Partition(string value);
    public CppModuleId ResolveModulePartition(string currentModuleName);
    public bool IsValid();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CppModuleId left, CppModuleId right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CppModuleId left, CppModuleId right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CppModuleId other);
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Name, String& Partition);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleIdUtil : object {
    private static CppModuleId ourStdModule;
    private static CppModuleId ourStdCompatModule;
    private static CppModuleIdUtil();
    [ExtensionAttribute]
public static bool IsStdModule(CppModuleId moduleId);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleImportingContext : CppImportExportVisitorBase {
    private Dictionary`2<ICppModuleEntity, ICppResolveEntity> myAlreadyImported;
    private CppModuleImportMode myImportMode;
    private CppLocationAnchor myImportModuleChangePoint;
    private CppModule mySource;
    private CppModuleId mySourceId;
    private HashSet`1<CppClassOrEnumModuleEntity> myImportingRightNowClassSpecializations;
    [CompilerGeneratedAttribute]
private ICppRootFileResolveEntitiesCache <ResolveCache>k__BackingField;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <AnchorOfImport>k__BackingField;
    private bool myDropTypeDecorations;
    private static CppEvaluationFail InternalEvaluationError { get; }
    private CppGlobalNamespaceModuleEntity GlobalNamespace { get; }
    private Dictionary`2<ICppModuleEntity, string> OwningModule { get; }
    private CppFileLocation SourceFile { get; }
    private CppFileLocation TargetFile { get; }
    public CppModuleImportMode ImportMode { get; }
    public ICppRootFileResolveEntitiesCache ResolveCache { get; }
    public CppLocationAnchor AnchorOfImport { get; }
    public CppLocationAnchor AnchorAfterImportedModule { get; }
    public CppModuleImportingContext(ICppRootFileResolveEntitiesCache resolveCache, CppModule source, CppModuleId sourceId, CppGlobalNamespaceResolveEntity targetGlobalNS, CppLocationAnchor anchorOfImport, CppModuleImportMode importMode);
    public virtual ICppExpression Visit(ICppCastExpression source);
    public virtual ICppExpression Visit(ICppCallExpression source);
    public virtual ICppExpression Visit(ICppUnaryExpression source);
    public virtual ICppExpression Visit(ICppBinaryExpression source);
    public virtual ICppExpression Visit(ICppPostfixExpression source);
    public virtual ICppExpression Visit(ICppSubscriptExpression source);
    public virtual ICppExpression Visit(ICppConditionalExpression source);
    public virtual ICppExpression Visit(ICppParenExpression source);
    public virtual ICppExpression Visit(ICppSizeOfExpression source);
    public virtual ICppExpression Visit(ICppSizeOfEllipsisExpression source);
    public virtual ICppExpression Visit(ICppAlignOfExpression source);
    public virtual ICppExpression Visit(ICppNoExceptExpression source);
    public virtual ICppExpression Visit(ICppUserDefinedLiteralExpression source);
    public virtual ICppExpression Visit(ICppBraceInitializedTemporaryExpression source);
    public CppResolvedBraceInitializedTemporaryExpression ImportBraceInitializedTemporary(CppModuleBraceInitializedTemporaryExpression source);
    public virtual ICppExpression Visit(ICppSingleArgumentTypeTraitExpression source);
    public virtual ICppExpression Visit(ICppDoubleArgumentTypeTraitExpression source);
    public virtual ICppExpression Visit(ICppMultiArgumentTypeTraitExpression source);
    public virtual ICppExpression Visit(ICppBuiltinOffsetOfExpression source);
    public virtual ICppExpression Visit(ICppBuiltinAddressOfExpression source);
    public virtual ICppExpression Visit(ICppNewExpression source);
    public virtual ICppExpression Visit(ICppQualifiedReferenceExpression source);
    public virtual ICppExpression Visit(ICppMemberAccessExpression source);
    public virtual ICppExpression Visit(ICppFoldExpression source);
    public virtual ICppExpression Visit(ICppMSUuidOfExpression source);
    public virtual ICppExpression Visit(ICppPackExpansionExpression source);
    public virtual ICppExpression Visit(ICppGnuBuiltinConstantPExpression source);
    public virtual ICppExpression Visit(ICppGNUAddressOfLabelExpression source);
    public virtual ICppExpression Visit(ICppThrowExpression source);
    public virtual ICppExpression Visit(ICppTypeIdExpression source);
    public virtual ICppExpression Visit(ICppLambdaExpression source);
    public virtual ICppExpression Visit(ICppGnuStatementExpression source);
    public virtual ICppExpression Visit(ICppRequiresExpression source);
    protected virtual ICppExpression ReApplyToTypeConstraint(ICppExpression source);
    private static CppEvaluationFail get_InternalEvaluationError();
    protected virtual ICppEvaluationResult ReApplyToEnumeratorValue(ICppEnumValue value);
    protected virtual ICppEvaluationResult ReApplyToObjectValue(ICppObjectValue value);
    protected virtual CppArrayValue ReApplyToArrayValue(CppArrayValue value);
    private CppStringLiteralArrayValue ImportStringLiteralArrayValue(CppModuleStringLiteralArrayValue source);
    private CppRuntimeArrayValue ImportRuntimeArrayValue(CppModuleRuntimeArrayValue source);
    protected virtual ICppEvaluationResult ReApplyToPointerValue(ICppPointerValue value);
    protected virtual ICppEvaluationResult ReApplyToReferenceValue(ICppReferenceValue value);
    private ICppEvaluationResult ImportReferenceToField(CppModuleReferenceToField refToField);
    private CppReferenceToDeclarator ReApplyToReferenceToDeclarator(CppModuleReferenceToDeclarator refToDeclarator);
    protected virtual CppStringLiteralValue ReApplyToStringLiteral(CppStringLiteralValue value);
    private CppViewPos ViewPosForExpressions();
    private CppGlobalNamespaceModuleEntity get_GlobalNamespace();
    private Dictionary`2<ICppModuleEntity, string> get_OwningModule();
    private CppFileLocation get_SourceFile();
    private CppFileLocation get_TargetFile();
    internal void UpdateImportMode(CppModuleImportMode newMode);
    public CppModuleImportMode get_ImportMode();
    public CppModuleDescriptor GetDescriptor();
    public string GetOwningModule(ICppModuleEntity entity);
    public bool IsVisible(ICppTopLevelDeclaratorModuleEntity declarator, CppLocationAnchor anchor);
    private bool IsOurDeclaratorVisible(ICppTopLevelDeclaratorModuleEntity declarator);
    private bool BelowPointOfImport(CppLocationAnchor anchor);
    public ICppModuleEntity GetModuleEntity(CppModuleEntityKind kind, int index);
    public CppQualType ImportType(CppQualType type);
    public ICppResolvedExpression ImportExpression(ICppExpression expression);
    public CppQualifiedNamePart ImportNamePart(CppQualifiedNamePart name);
    private CppTemplateId ImportTemplateId(CppModuleTemplateId templId);
    public CppQualifiedName ImportQualifiedName(CppQualifiedName source);
    public CppTemplateParametersBase ImportTemplateParameters(CppModuleTemplateParameters source);
    public ICppTemplateArgument[] ImportTemplateArguments(CppSmallArray`1<ICppModuleTemplateArgument> source);
    public ICppTemplateArgument[] ImportDefaultTemplateArguments(CppQualifiedNamePart name);
    public CppLookupFailureTemplateArgument Import(CppLookupFailureTemplateArgument arg);
    public CppDeclaratorInitializer ImportInitializer(CppDeclaratorInitializer source);
    public CppConversionId ImportConversionId(CppConversionId convId);
    public CppImportResult`1<ICppClassResolveEntity> ImportClassOrEnumAutoParent(ICppClassOrRefClassModuleEntity source);
    public CppImportResult`1<ICppClassResolveEntity> ImportAndCache(CppReExportedClassOrEnumModuleEntity reExportedClass);
    private CppImportResult`1<ICppScopeResolveEntity> ImportClassParent(ICppClassOrRefClassModuleEntity source, Boolean& forceClassPacks);
    public CppImportResult`1<ICppMutableClassResolveEntity> ImportClassOrEnumHead(ICppScopeResolveEntity targetParent, CppClassOrEnumModuleEntity source, bool onlyFindExisting, bool addToNamespace);
    private CppImportResult`1<ICppMutableClassResolveEntity> ImportNonTemplateClassOrEnumHead(ICppScopeResolveEntity targetParent, CppClassOrEnumModuleEntity source, bool onlyFindExisting, bool addToNamespace);
    private CppImportResult`1<ICppMutableClassResolveEntity> ImportTemplateClassOrEnumHead(ICppScopeResolveEntity targetParent, CppClassOrEnumModuleEntity source, bool onlyFindExisting, bool addToNamespace);
    private string GetOwningModule(ICppResolveEntity clazz);
    private void SetOwningModule(ICppResolveEntity clazz, string module);
    [CanBeNullAttribute]
private ICppClassResolveEntity MergeSpecializations(CppClassOrEnumModuleEntity source, CppClassTemplateResolveEntityPack targetPack, CppQualifiedNamePart targetName);
    public CppImportResult`1<CppDependentResolveEntity> ImportDependentEntity(CppDependentModuleEntity dependent);
    public CppImportResult`1<ICppEnumeratorResolveEntity> ImportEnumeratorAutoParent(ICppEnumeratorModuleEntity source);
    public CppImportResult`1<ICppGroupedVariableDeclaratorResolveEntity> ImportVariableCandidate(CppVariableModuleEntity source);
    public CppImportResult`1<ICppGroupedVariableDeclaratorResolveEntity> ImportVariableCandidate(CppMemberVariableOfReferentialClassModuleEntity source);
    public CppCompoundStatementResolveEntity ImportCompoundStatement(CppCompoundStatementModuleEntity source, CppScopeResolveEntityBase targetParent);
    public void ImportNamespaceChild(CppNamespaceResolveEntity targetParent, ICppNamespaceModuleEntityChild source);
    private bool TryImportBlockShadersModuleEntity(CppNamespaceResolveEntity targetParent, ICppNamespaceModuleEntityChild source);
    public ICppResolveEntity FindAlreadyImported(ICppModuleEntity moduleEntity);
    public bool TryFindAlreadyImported(ICppModuleEntity moduleEntity, ICppResolveEntity& result);
    public bool IsAlreadyImported(ICppModuleEntity moduleEntity);
    public void AddToCache(ICppModuleEntity key, ICppResolveEntity value);
    public CppImportResult`1<ICppTypeTemplateDeclaratorResolveEntity> ImportTypeAliasTemplateAutoParent(ICppTypeAliasModuleEntity source);
    public CppImportResult`1<ICppClassResolveEntity> ImportClassOrEnum(ICppScopeResolveEntity targetParent, ICppClassOrRefClassModuleEntity source, bool onlyFindExisting, bool addToParentScope);
    public CppNamespaceAliasResolveEntity ImportNamespaceAlias(ICppScopeResolveEntity targetParent, CppNamespaceAliasModuleEntity source);
    public CppParameterListResolveEntity ImportParameterList(ICppScopeResolveEntity targetParent, CppParameterListModuleEntityBase source);
    public CppImportResult`1<ICppDependentTypeResolveEntity> ImportDependentTypeEntity(ICppTypeModuleEntity source);
    public CppImportResult`1<ICppGroupedFunctionDeclaratorResolveEntity> ImportGroupedFunction(ICppScopeResolveEntity targetParent, CppRegularNormalFunctionModuleEntity source, bool onlyFindExisting);
    public CppImportResult`1<ICppGroupedVariableDeclaratorResolveEntity> ImportGroupedVariable(ICppScopeResolveEntity targetParent, CppVariableModuleEntity source, bool onlyFindExisting);
    public CppImportResult`1<ICppGroupedTypeDeclaratorResolveEntity> ImportGroupedTypeAlias(ICppScopeResolveEntity targetParent, CppTypeAliasModuleEntity source, bool onlyFindExisting);
    public CppImportResult`1<ICppGroupedFunctionDeclaratorResolveEntity> ImportFunctionCandidate(CppRegularNormalFunctionModuleEntity source);
    public CppImportResult`1<ICppGroupedFunctionDeclaratorResolveEntity> ImportFunctionCandidate(CppMemberFunctionOfReferentialClassModuleEntity source);
    public CppImportResult`1<ICppGroupedTypeDeclaratorResolveEntity> ImportTypeAliasCandidate(CppTypeAliasModuleEntity source);
    public CppImportResult`1<ICppGroupedTypeDeclaratorResolveEntity> ImportTypeAliasCandidate(CppMemberTypedefOfReferentialClassModuleEntity source);
    public CppImportResult`1<ICppGroupedTypeDeclaratorResolveEntity> ImportTypeAliasCandidate(CppDecayBuiltinTypedefModuleEntity source);
    public CppImportResult`1<BlockShadersResolveEntity> ImportBlockShaderScopeAutoParent(IBlockShadersScopeModuleEntity source);
    public ICppResolvedCallExpression ImportCallExpression(CppModuleCallExpression call);
    public void InstantiateClass(ICppClassResolveEntity clazz);
    public CppViewPos PointAfterImportedModule();
    [CompilerGeneratedAttribute]
public ICppRootFileResolveEntitiesCache get_ResolveCache();
    [CompilerGeneratedAttribute]
public CppLocationAnchor get_AnchorOfImport();
    public CppLocationAnchor get_AnchorAfterImportedModule();
    public ICppTypeDeclaratorResolveEntity ImportTypeAlias(ICppScopeResolveEntity targetParent, CppTypeAliasModuleEntity source, bool onlyFindExisting);
    public ICppDeclaratorOrTemplateDeclaratorPack ImportMemberTypeAlias(ICppScopeResolveEntity targetParent, CppTypeAliasModuleEntity source);
    public CppImportResult`1<ICppFunctionDeclaratorResolveEntity> ImportFunction(ICppScopeResolveEntity targetParent, CppRegularNormalFunctionModuleEntity source, bool onlyFindExisting);
    private CppImportResult`1<ICppFunctionDeclaratorResolveEntity> ImportFunction(ICppScopeResolveEntity targetParent, CppRegularNormalFunctionModuleEntity source, CppDeclaratorResolveEntityPack pack);
    private CppImportResult`1<ICppFunctionDeclaratorResolveEntity> ImportRegularFunctionOrTemplateSpecialization(ICppScopeResolveEntity targetParent, CppRegularNormalFunctionModuleEntity source);
    private CppImportResult`1<ICppFunctionDeclaratorResolveEntity> ImportPrimaryTemplate(CppTemplateFunctionSpecializationModuleEntity specialization);
    public ICppFunctionOrTemplateDeclaratorResolveEntity ImportMemberFunction(ICppMutableClassResolveEntity targetParent, CppRegularNormalFunctionModuleEntity source);
    public CppImportResult`1<CppUndeterminedSpecializationResolveEntity> ImportUndeterminedSpecialization(CppUndeterminedSpecializationModuleEntity source);
    public CppParameterListResolveEntity ImportParameterListRecursively(CppParameterListModuleEntityBase source);
    public ICppTemplateArgument[] ImportDefaultTemplateArguments(CppModuleTemplateId templateId);
    public ICppTemplateArgument[] ImportDefaultTemplateArguments(ICppModuleTemplateArgument[] sourceDefaultTemplateArguments);
    public List`1<ICppTemplateParameter> ImportTemplateDependencies(ICppModuleTemplateParameter[] source);
    public virtual CppUnknownEntityInfo Visit(CppUnknownTemplateDeductionInfo info);
    public virtual CppUnknownEntityInfo Visit(CppNontypeResolveEntityUsedAsTypeFailure info);
    public virtual CppUnknownEntityInfo Visit(CppNontypeModuleEntityUsedAsTypeFailure info);
    protected virtual ICppResolvedTypeFactory GetTypeFactory();
    protected virtual CppQualifiedName ReApply(CppQualifiedName name);
    private ICppTemplateParameter ImportTemplateParameter(ICppModuleTemplateParameter source);
    private void ImportTemplateParameters(ICppModuleTemplateParameter[] source, CppTemplateParametersBase target);
    public CppImportResult`1<ICppFunctionDeclaratorResolveEntity> ImportFunctionAutoParent(CppRegularNormalFunctionModuleEntity source);
    private bool EnterParentScope(ICppResolveEntity targetParent);
    private ICppMutableClassResolveEntity CreateClassOrEnumHead(ICppResolveEntityParent targetParent, CppQualifiedNamePart targetName, CppClassOrEnumModuleEntity source);
    public void ImportClassModulePart(ICppResolveEntityParent targetParent, ICppMutableClassResolveEntity target, CppClassOrEnumModuleEntity source);
    public CppAttributeList ImportAttributeList(CppSmallArray`1<ICppAttribute> source);
    private void ImportVariable(CppNamespaceResolveEntity targetParent, CppVariableModuleEntity source);
    private CppImportedVariableDeclaratorResolveEntity ImportVariableOrTemplateSpecialization(ICppScopeResolveEntity targetParent, CppQualifiedNamePart name, CppVariableModuleEntity source);
    private ICppDeclaratorOrTemplateDeclaratorPack ImportMemberVariable(ICppMutableClassResolveEntity targetParent, CppVariableModuleEntity source);
    private CppImportResult`1<CppDeclaratorResolveEntityPack> FindPackForFunction(CppQualifiedNamePart innerName, ICppScopeResolveEntity targetParent, CppRegularFunctionModuleEntity source, bool onlyFindExisting);
    public CppImportResult`1<CppUsingEnumEnumeratorResolveEntity> ImportUsingEnumerator(ICppScopeResolveEntity targetParent, CppUsingEnumeratorModuleEntity usingEnum);
    private ICppMutableClassResolveEntity ImportClassOrEnumWithAnonymousNameHead(CppNamespaceResolveEntity ns, CppClassOrEnumModuleEntity source);
    internal CppConceptDefinitionResolveEntity ImportConceptDefinition(ICppScopeResolveEntity targetParent, CppConceptDefinitionModuleEntity source);
    private void RegisterImportedFunctionParameter(ICppVariableDeclaratorResolveEntity targetParam, CppParameterListResolveEntity target, ICppModuleEntity sourceParam);
    public CppNamespaceResolveEntity ImportNamespaceAutoParent(CppNamespaceModuleEntity source);
    public void ImportNamespaceIfNotAlready(CppNamespaceResolveEntity targetParent, CppNestedNamespaceModuleEntity source);
    private CppNamespaceResolveEntity ImportNamespaceHead(CppNamespaceResolveEntity targetParent, CppNestedNamespaceModuleEntity source);
    private ICppTypeDeclaratorResolveEntity ImportTypeAliasAutoParent(CppTypeAliasModuleEntity source);
    public CppImportResult`1<ICppResolveEntity> ImportClassChild(ICppMutableClassResolveEntity targetParent, ICppClassModuleEntityChild source);
    private ICppGroupedFunctionDeclaratorResolveEntity ImportSpecialMemberFunction(ICppMutableClassResolveEntity clazz, CppSpecialMemberFunctionModuleEntity source);
    public CppGroupedFunctionDeclaratorResolveEntity ImportUEClassImplicitlyGeneratedConstructor(ICppMutableClassResolveEntity cent, CppSpecialMemberFunctionKind kind);
    private CppResolveResult ImportResolveResult(CppModuleResolveResult source);
    public FrugalLocalList`1<ICppResolveEntity> ImportResolveResultCandidates(CppSmallArray`1<ICppModuleEntity> sourceCandidates, Boolean& someCandidateFailed);
    private CppImportResult`1<ICppResolveEntity> ImportCandidate(ICppModuleEntity source);
    public CppImportResult`1<ICppResolveEntity> ImportClassTemplatePack(CppClassTemplatePackModuleEntity source);
    private CppImportResult`1<CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity> ImportSubstitutedTypeTemplateDeclarator(CppSubstitutedTypeTemplateDeclaratorModuleEntity source);
    public ICppTemplateArgument[] ImportTemplateArguments(ICppTemplateResolveEntityBase template, CppViewPos viewPos, CppSmallArray`1<ICppModuleTemplateArgument> source);
    private CppDependentDecltypeResolveEntity Import(CppDependentDecltypeModuleEntity csource);
    private CppDependentStructuredBindingTypeResolveEntity Import(CppDependentStructuredBindingTypeModuleEntity source);
    private CppImportResult`1<ICppDependentScopeLikeResolveEntity> ImportDependentModuleEntityHead(ICppDependentModuleEntityHead source);
    public CppTemplateTemplateParameterWithAppliedArgumentsResolveEntity Import(CppSubstitutedTemplateTemplateParameterModuleEntity source);
    private ICppResolvedExpression CreateTypeConstraint(CppConceptDefinitionResolveEntity targetConcept, CppQualifiedNamePart conceptName, ICppTemplateArgument[] extraArgs, bool isVariadic);
    private CppImportResult`1<CppDeclaratorResolveEntityPack> FindOrCreateDeclaratorPack(ICppScopeResolveEntity scope, CppQualifiedNamePart name, bool onlyFindExisting);
    private CppImportResult`1<CppDeclaratorResolveEntityPack> FindOrCreateDeclaratorPack(ICppScopeResolveEntity scope, CppQualifiedNamePart name, bool onlyFindExisting, Boolean& hasBeenCreated);
    public ICppFunctionDeclaratorResolveEntity ImportFriendFunction(ICppClassResolveEntity targetClass, CppFriendFunctionModuleEntity source);
    private void ImportFunction(CppImportedFunctionDeclaratorResolveEntity target, CppRegularFunctionModuleEntity source);
    private CppParameterListResolveEntity ImportRequiresExpressionParameters(CppRequiresExpressionScopeResolveEntity parent, CppSmallArray`1<Parameter> source);
    private CppList`1<ICppRequiresExpressionItem> ImportRequiresExpressionItems(CppSmallArray`1<ICppRequiresExpressionItem> source);
    private ICppEvaluationResult Import(CppModuleObjectValue objectValue);
    public void ImportFunctionBody(CppCompoundStatementModuleEntity source, CppImportedFunctionDeclaratorResolveEntity targetFunc);
    private void ForceClassPacks(ICppScopeResolveEntity targetParent, ICppClassOrRefClassModuleEntity source);
    private ICppResolveEntity FindTemplateParameter(ICppModuleTemplateParameter source);
    private void AssertResolveMutexLocked();
    public static void ImportModule(ICppRootFileResolveEntitiesCache resolveCache, CppModule module, CppModuleId moduleId, CppModuleImportMode mode);
    private static bool IsMakeIntegerSeq(ICppTypeAliasModuleEntity source);
    public static CppQualifiedNamePart GetInnerIfModuleTemplateId(CppQualifiedNamePart name);
    private static bool IsInnerOf(CppList`1<ICppFunctionOrVariableDeclaratorResolveEntity> ungroupedDeclarators, ICppGroupedFunctionDeclaratorResolveEntity inner);
    private static bool IsInnerOf(CppSmallList`1<TUngrouped> ungroupedDeclarators, TGrouped inner);
    private static bool TheSameImportedDeclarator(ICppDeclaratorResolveEntity a, ICppGroupedDeclaratorResolveEntity b);
    private static ICppGroupedFunctionDeclaratorResolveEntity FindImportedFunctionInSubstitutedClass(CppDeclaratorResolveEntityPack pack, ICppGroupedFunctionDeclaratorResolveEntity inner);
    private static ICppGroupedVariableDeclaratorResolveEntity FindImportedVariableInSubstitutedClass(CppDeclaratorResolveEntityPack pack, ICppGroupedVariableDeclaratorResolveEntity inner);
    private static ICppGroupedTypeDeclaratorResolveEntity FindImportedTypeAliasInSubstitutedClass(CppDeclaratorResolveEntityPack pack, ICppGroupedTypeDeclaratorResolveEntity inner);
    private static ICppGroupedFunctionDeclaratorResolveEntity FindImportedFunctionInSubstitutedClass(ICppDeclaratorResolveEntityPack pack, ICppGroupedFunctionDeclaratorResolveEntity inner);
    [CanBeNullAttribute]
private static ICppVariableDeclaratorResolveEntity FindCachedVariable(Dictionary`2<ICppModuleEntity, ICppResolveEntity> cache, ICppVariableModuleEntity source);
    [CanBeNullAttribute]
public ICppGroupedVariableDeclaratorResolveEntity FindCachedGroupedVariable(ICppVariableModuleEntity source);
    [CanBeNullAttribute]
private static ICppFunctionDeclaratorResolveEntity FindCachedFunction(Dictionary`2<ICppModuleEntity, ICppResolveEntity> cache, ICppFunctionModuleEntity source);
    [CanBeNullAttribute]
public ICppGroupedFunctionDeclaratorResolveEntity FindGroupedCachedFunction(ICppFunctionModuleEntity source);
    [CanBeNullAttribute]
private static ICppTypeDeclaratorResolveEntity FindCachedTypeAlias(Dictionary`2<ICppModuleEntity, ICppResolveEntity> cache, ICppTypeAliasModuleEntity source);
    [CanBeNullAttribute]
public ICppGroupedTypeDeclaratorResolveEntity FindCachedGroupedTypeAlias(ICppTypeAliasModuleEntity source);
    private static ICppDeclaratorResolveEntityPack FindPackByDeclarator(ICppDeclaratorResolveEntity decl, bool isFunction);
    private static ICppGroupedVariableDeclaratorResolveEntity GetGroupedVariable(ICppDeclaratorResolveEntityPack pack, ICppVariableDeclaratorResolveEntity ungrouped);
    private static ICppGroupedFunctionDeclaratorResolveEntity GetGroupedFunction(CppDeclaratorResolveEntityPack pack, ICppFunctionDeclaratorResolveEntity ungrouped);
    private static ICppGroupedFunctionDeclaratorResolveEntity GetGroupedFunction(ICppDeclaratorResolveEntityPack pack, ICppFunctionDeclaratorResolveEntity ungrouped);
    private static ICppGroupedTypeDeclaratorResolveEntity GetGroupedTypeAlias(ICppDeclaratorResolveEntityPack pack, ICppTypeDeclaratorResolveEntity ungrouped);
    private static CppImportResult`1<ICppGroupedDeclaratorResolveEntity> ImportReferencedDeclarator(ICppModuleEntity decl, CppModuleImportingContext ctx);
    protected virtual ICppDesignation CreateDesignation(ICppDesignator designator, ICppExpression initializer, ICppDesignation source);
    private CppImportResult`1<ICppClassOrUndeterminedSpecializationResolveEntity> ImportClassOrUndeterminedSpecialization(ICppTypeModuleEntity entity);
    public virtual CppQualType Visit(CppAutoType t, Qualifiers q);
    public virtual CppQualType Visit(CppModuleEntityType t, Qualifiers q);
    public virtual CppQualType Visit(CppInstantiatedTemplateAliasModuleType t, Qualifiers q);
    public virtual CppQualType Visit(CppDependentInstantiatedTemplateAliasModuleType t, Qualifiers q);
    public virtual CppQualType Visit(CppTypedefModuleType t, Qualifiers q);
    public virtual CppQualType Visit(CppDeducedClassTypePlaceholder t, Qualifiers q);
    public virtual CppQualType Visit(CppDeducedClassTypePlaceholderModuleType t, Qualifiers q);
    public virtual CppQualType Visit(CppNamedParameterType t, Qualifiers q);
    private ICppDecoratedFunctionParameter ReApply(CppFunctionParameterModuleEntityWithName parameter);
    private ICppResolvedExpression ImportAutoConstraint(ICppConceptDefinitionModuleEntity sourceConcept, CppQualifiedNamePart conceptName, bool isVariadic);
    [CompilerGeneratedAttribute]
internal static CppClassOrEnumModuleEntity <ImportTemplateClassOrEnumHead>g__FindPrimaryTemplate|89_0(CppNamespaceModuleEntity ns, CppQualifiedNamePart name);
    [CompilerGeneratedAttribute]
internal static ICppGroupedFunctionDeclaratorResolveEntity <ImportSpecialMemberFunction>g__CreateCopyOrMoveConstructor|168_0(CppQualType classType, CppQualType parameterType, ICppResolvedTypeFactory typeFactory, ICppMutableClassResolveEntity clazz, CppSpecialMemberFunctionModuleEntity source, CppModuleImportingContext ctx);
    [CompilerGeneratedAttribute]
internal static ICppGroupedFunctionDeclaratorResolveEntity <ImportSpecialMemberFunction>g__CreateCopyOrMoveAssignment|168_1(CppQualType classType, CppQualType parameterType, ICppResolvedTypeFactory typeFactory, ICppMutableClassResolveEntity clazz, CppSpecialMemberFunctionModuleEntity source, CppModuleImportingContext ctx);
    [CompilerGeneratedAttribute]
internal static bool <ImportFunction>g__HasConstrainedInventedParams|184_0(ICppModuleTemplateParameter[] tparams);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleImportMode : Enum {
    public int value__;
    public static CppModuleImportMode ImportEverything;
    public static CppModuleImportMode ImportOnlyExplicitlyExported;
    public static CppModuleImportMode IgnoredByNamedLookup;
    public static CppModuleImportMode CompilerIntrinsics;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleInjectedClassNameTemplateArgument : object {
    private ICppClassOrRefClassModuleEntity myInjectedClassName;
    public CppModuleInjectedClassNameTemplateArgument(ICppClassOrRefClassModuleEntity injectedClassName);
    public sealed virtual ICppTemplateArgument Import(CppModuleImportingContext ctx);
    public sealed virtual CppModuleTemplateArgumentKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleInventedTypeTemplateParameter : CppModuleInventedTypeTemplateParameterOrPack {
    public virtual ICppTemplateParameter Import(CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleInventedTypeTemplateParameterOrPack : object {
    public abstract virtual ICppTemplateParameter Import(CppModuleImportingContext ctx);
    public sealed virtual bool IsOrphaned();
    public abstract virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleInventedTypeTemplateParameterPack : CppModuleInventedTypeTemplateParameterOrPack {
    public virtual ICppTemplateParameter Import(CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleLambdaExpression : object {
    public IClosureTypeEntity ClosureType;
    public CppModuleLambdaExpression(IClosureTypeEntity closureType);
    public sealed virtual CppLambdaSymbol GetLambdaSymbol();
    public sealed virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleMarshallingContext : object {
    private Dictionary`2<ICppModuleEntity, EntitySerializationStatus> myEntityStatus;
    private Dictionary`2<CppModuleEntityKind, CppOutputBinaryStream> mySerializedModuleEntities;
    private Dictionary`2<CppModuleTypeKind, CppOutputBinaryStream> mySerializedTypes;
    private Dictionary`2<CppType, CppModuleTypeIndex> myTypeCache;
    private Dictionary`2<ICppValue, int> myValueCache;
    private Dictionary`2<CppModuleExpressionKind, CppOutputBinaryStream> mySerializedExpressions;
    private Dictionary`2<CppModuleTemplateArgumentKind, CppOutputBinaryStream> mySerializedTemplateArguments;
    private Dictionary`2<CppModuleValueKind, CppOutputBinaryStream> mySerializedValues;
    private CppList`1<CppModuleEntityIndex> myModuleEntities;
    private CppList`1<CppSerializedModuleType> myQualTypes;
    private CppList`1<CppSerializedModuleTypeWithPackExpansion> myPackExpansionQualTypes;
    private CppList`1<CppSerializedModuleTypeWithPayload> myPayloadQualTypes;
    private CppList`1<CppModuleExpressionIndex> myExpressions;
    private CppList`1<CppModuleTemplateArgumentIndex> myTemplargs;
    private CppList`1<CppSerializedClassBase> myClassBases;
    private CppList`1<CppSerializedNonDependentClassBase> myNonDependentClassBases;
    private CppList`1<CppSerializedQualifiedName> myNameQualifiers;
    private CppList`1<CppSerializedModuleTemplateId> myTemplateIds;
    private CppList`1<CppSerializedModuleSubstitutionId> mySubstitutionIds;
    private CppList`1<CppSlice> myStructuredBingingIds;
    private CppList`1<CppSerializedStructuredBindingSymbol> myStructuredBindingSymbols;
    private CppList`1<CppSerializedNamespaceChildRecord> myNsChildren;
    private CppList`1<CppModuleUnknownInfoIndex> myUnknownEntityInfos;
    private CppList`1<int> myStringLiteralParts;
    private CppList`1<int> myRequiresExpressionItems;
    private CppList`1<int> myDefaultedTemplateArguments;
    private CppList`1<CompoundRequirement> myCompoundRequiresItems;
    private CppList`1<Designator> myDesignators;
    private CppList`1<CppSerializedModulePointerToArrayElementValue> myPointerToArrayElementValues;
    private CppList`1<CppSerializedModuleReferenceToFieldValue> myReferenceToFieldValues;
    private CppList`1<CppSerializedFunctionDeclaratorSymbol> myFunctionSymbols;
    private CppList`1<CppSerializedDeclaratorSymbol> myDeclaratorSymbols;
    private CppList`1<CppSerializedClassSymbol> myClassSymbols;
    private CppList`1<CppSerializedAutoTypeDeductionFailure> myAutoTypeDeductionFailures;
    private CppList`1<CppSerializedTypeConversionFailure> myTypeConversionFailures;
    private CppList`1<CppModuleAttributeIndex> myAttributes;
    private CppList`1<CppModuleSerializedSimpleAttribute> mySimpleAttributes;
    private CppList`1<CppModuleSerializedExpressionAttribute> myExpressionAttributes;
    private CppList`1<CppModuleSerializedTypeIdOrExpressionAttribute> myTypeIdOrExpressionAttributes;
    private CppList`1<CppModuleSerializedStringLiteralAttribute> myStringLiteralAttributes;
    private CppList`1<CppModuleSerializedDoubleStringLiteralAttribute> myDoubleStringLiteralAttributes;
    private CppList`1<CppModuleSerializedFormatAttribute> myFormatAttributes;
    private CppList`1<CppModuleSerializedUEAttribute> myUEAttributes;
    private CppList`1<Specifier> myUEAttributeSpecifiers;
    private int myInventedTemplateParamsCount;
    private Dictionary`2<string, int> myStringIndex;
    private CppModuleTypeMarshaller myQualTypeMarshaller;
    private CppModuleExpressionMarshaller myExpressionMarshaller;
    private CppList`1<BlockShadersModuleSerializedAttribute> myBSAttributes;
    private CppList`1<Parameter> myBSAttributeParameters;
    private CppList`1<ParameterValue> myBSAttributeParameterValues;
    private UnsafeWriter myWriter;
    public CppModuleMarshallingContext(UnsafeWriter writer);
    private void MarshalGlobalNamespace(CppGlobalNamespaceModuleEntity entity);
    public void Marshal(CppGlobalNamespaceModuleEntity module);
    public ValueTuple`2<StringWriter, int> DumpStatistics();
    private int GetTotalStringLength();
    private static void WriteStatistics(StringWriter sw, Int32& totalBytes, string title, Dictionary`2<TKind, CppOutputBinaryStream> dict);
    private static void CollectStatistics(List`1<StatByElement> result, string type, CppList`1<T> list);
    public CppModuleEntityIndex MarshalOptional(ICppModuleEntity entity, bool deep);
    public CppModuleEntityIndex Marshal(ICppModuleEntity entity, bool deep);
    public void MarshalShallow(CppModuleEntityKind kind, List`1<ICppModuleEntity> entities);
    public CppSlice Marshal(Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppNamespaceModuleEntityChild>> nsChildren);
    public CppSlice MarshalRange(TModuleEntity[] entities, bool deep);
    public CppSlice MarshalRange(CppSmallArray`1<TModuleEntity> entities, bool deep);
    public CppSlice MarshalRange(CppQualType[] types);
    public CppSlice MarshalBases(CppBasicBaseDescription`1[] bases);
    public CppSlice MarshalBases(CppBasicBaseDescription`1[] bases);
    public CppSlice MarshalRange(E[] args);
    public CppSlice MarshalRange(CppSmallArray`1<ICppExpression> args);
    public CppSlice MarshalRange(ICppEvaluationResult[] args);
    public CppSlice MarshalRange(CppSmallArray`1<ICppRequiresExpressionItem> items);
    private int Marshal(ICppRequiresExpressionItem item);
    private ValueTuple`2<CppRequiresExpressionItemKind, int> MarshalImpl(ICppRequiresExpressionItem item);
    public CppModuleNameIndex Marshal(CppQualifiedNamePart name);
    public CppSerializedQualifiedName MarshalOptional(CppQualifiedName qualName);
    public CppSerializedQualifiedName Marshal(CppQualifiedName qualName);
    public CppModuleTypeIndex Marshal(CppType internalType);
    public CppSerializedModuleType Marshal(CppQualType type);
    public CppSerializedModuleTypeWithPackExpansion Marshal(Element element);
    public CppSlice MarshalRange(CppList`1<Element> elements);
    public CppSlice MarshalRange(CppList`1<Element> elements);
    public CppSerializedModuleTypeWithPackExpansion Marshal(Element element);
    private void Marshal(ICppModuleEntity entity, int index, CppOutputBinaryStream output);
    public CppModuleExpressionIndex MarshalOptional(ICppExpression expr);
    public CppModuleExpressionIndex Marshal(ICppValue result);
    public CppModuleExpressionIndex Marshal(ICppEvaluationResult result);
    public CppModuleExpressionIndex Marshal(ICppExpression expr);
    public int Marshal(ICppDesignator designator);
    internal int MarshalValue(ICppValue value);
    private ValueTuple`2<int, CppModuleValueKind> MarshalValueImpl(ICppValue value);
    private int WriteValue(T data, CppModuleValueKind kind);
    private int MarshalObjectValue(CppModuleObjectValue value);
    private int MarshalArrayValue(CppArrayValue value);
    private CppSerializedModuleArrayValue SerializeArrayValue(CppArrayValue value);
    private CppSerializedModuleArrayValue SerializeSimpleArrayValue(CppSimpleArrayValue value);
    private CppSerializedModuleArrayValue SerializeRLEArrayValue(CppRLEArrayValue value);
    private CppSerializedModuleArrayValue SerializeStringLiteralArrayValue(CppModuleStringLiteralArrayValue value);
    private CppSerializedModuleArrayValue SerializeRuntimeArrayValue(CppModuleRuntimeArrayValue value);
    private int MarshalStringLiteralValue(CppStringLiteralValue value);
    public CppSlice MarshalStringLiteralParts(FrugalLocalList`1<string> parts);
    private int MarshalPointerValue(ICppPointerValue value);
    private int CreatePointerValueData(ICppPointerValue value);
    private int MarshalReferenceValue(ICppReferenceValue value);
    private int CreateReferenceValueData(ICppReferenceValue value);
    private int MarshalReferenceToDeclaratorValue(CppModuleReferenceToDeclarator referenceToDeclarator);
    private CppSerializedModuleObjectValue Marshal(CppModuleObjectValue obj);
    private int MarshalEnumValue(CppModuleEnumValue value);
    public CppModuleUnknownInfoIndex Marshal(CppUnknownEntityInfo info);
    public CppModuleTemplateArgumentIndex Marshal(ICppModuleTemplateArgument arg);
    public CppSlice Marshal(CppModuleTemplateTemplateArgument[] args);
    public CppSlice Marshal(CppSmallArray`1<ICppModuleTemplateArgument> args);
    public CppSlice Marshal(Int32[] defaultedTemplateArguments);
    private CppSlice Marshal(ICppModuleTemplateArgument[] args);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppQualifiedId qualified);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppDestructorTag destructor);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppAnonymousId name);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppDecltypeDestructorTag name);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppGlobalNamespaceId name);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppLambdaId name);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppConversionsPackId name);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppConversionId name);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppCliFinalizerTag name);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppDecltypeId name);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppTypeOfTypeId name);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppResolvedStructuredBindingId name);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppUnresolvedStructuredBindingId name);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppCliSimpleTypeId name);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppTemplateId name);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppSubstitutionId name);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppAnonymousLinkageId name);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppLinkageTemplateId name);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppMSSuperId name);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppOperatorId operator);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppUserDefinedLiteralId name);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppModuleTemplateId name);
    internal CppSerializedModuleTemplateParameters Marshal(CppModuleTemplateParameters parameters);
    public CppSlice MarshalFunctionSymbols(IEnumerable`1<ICppSymbol> symbols);
    public CppSlice MarshalDeclaratorSymbols(IEnumerable`1<ICppSymbol> symbols);
    public CppSlice MarshalClassSymbols(ICppClassOrDelegateSymbol[] symbols);
    private CppModuleNameIndex MarshalSymbolName(ICppParserSymbol symbol);
    private CppSlice MarshalSymbols(CppStructuredBindingSymbol[] symbols);
    public CppSlice MarshalAttributes(CppSmallArray`1<ICppAttribute> attrs);
    private CppModuleAttributeIndex MarshalAttribute(ICppAttribute attr);
    private CppModuleAttributeIndex MarshalSimpleAttribute(CppAttribute attr);
    private CppModuleAttributeIndex MarshalExpressionAttribute(CppAttributeWithArgument`1<ICppExpression> attr);
    private CppModuleAttributeIndex MarshalTypeIdOrExpressionAttribute(CppAttributeWithArgument`1<ICppTypeIdOrExpression> attr);
    private CppModuleAttributeIndex MarshalStringLiteralAttribute(CppAttributeWithArgument`1<CppStringLiteralValue> attr);
    private CppModuleAttributeIndex MarshalDoubleStringLiteralAttribute(CppAttributeWithArguments`1<CppStringLiteralValue> attr);
    private CppModuleAttributeIndex MarshalFormatAttribute(CppAttributeFormat attr);
    private CppModuleAttributeIndex MarshalUEAttribute(CppUE4Attribute attr);
    private CppSlice MarshalUEAttributeSpecifiers(SortedList`2<string, FrugalLocalHashSet`1<string>> specifiers);
    public CppSlice MarshalBlockShadersAttributesCppList(CppList`1<BSAttributeData> attrs);
    private CppModuleAttributeIndex MarshalBlockShadersAttribute(BSAttributeData attr);
    private CppSlice MarshalBlockShadersAttributeParameters(CppList`1<IBSAttributeParameter> parameters);
    private ParameterValue MarshalBlockShadersAttributeParameterValue(IBSAttributeParameterValue paramValue);
    public CppSlice MarshalUEAttributeSpecifierValues(FrugalLocalHashSet`1<string> parts);
    public sealed virtual CppModuleNameIndex Visit(CppMonostate data, CppModuleSubstitutionId name);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppInternalFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppLookupFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppRecursiveTypeCalculationFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppUnknownArraySizeFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppUnknownUE4TypeFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppExpressionEvaluationFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppInvalidFoldExpressionFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppStructuredBindingTypeDeductionFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppAutoTypeDeductionFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppTypeConversionFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppNontypeModuleEntityUsedAsTypeFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppSubstitutionFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppZeroOrNegativeArraySizeFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppNontypeResolveEntityUsedAsTypeFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppUnknownTemplateDeductionInfo info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppInvalidTypeFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppAutoTypeConstraintFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppLinkageUnknownTypeFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppInvalidNumberOfStructuredBindingsFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppInvalidStructuredBindingsInitializerClassFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppAggregateParenInitInfo info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppDeducedReturnTypeUsedBeforeFunctionDefinition info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppUnresolvedTypeInChangeSignature info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppUnknownEntityInfoWithReason info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppComparisonCategoryLookupFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppGenericAsTemplargFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppNonExpressionTemplateArgumentUsedAsExpressionFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppInvalidNonTypeTemplateArgumentValueFailure info);
    public sealed virtual CppModuleUnknownInfoIndex Visit(CppInvalidArgumentOfBuiltinTypeTraitFailure info);
    public void DumpRawData();
    public int WriteString(string s);
    private void MarshalDeferredModuleEntities();
    private void Dump(CppList`1<T> list);
    private void DumpStringIndex();
    private void Dump(Dictionary`2<TEnum, CppOutputBinaryStream> dict);
    private Dictionary`2<int, CppList`1<CppModuleEntityIndex>> Flatten(Dictionary`2<ICppModuleEntity, string> owningModule);
    private void Dump(Dictionary`2<int, CppList`1<CppModuleEntityIndex>> moduleToEntities);
    [CompilerGeneratedAttribute]
private ValueTuple`2<int, CppModuleValueKind> <MarshalValueImpl>g__MarshalSigned|91_0(CppSignedValueRepresentation repr, CppModuleValueKind kind);
    [CompilerGeneratedAttribute]
private ValueTuple`2<int, CppModuleValueKind> <MarshalValueImpl>g__MarshalUnsigned|91_1(CppUnsignedValueRepresentation repr, CppModuleValueKind kind);
    [CompilerGeneratedAttribute]
private ValueTuple`2<int, CppModuleValueKind> <MarshalValueImpl>g__MarshalFloating|91_2(CppFloatingValueRepresentation repr, CppModuleValueKind kind);
    [CompilerGeneratedAttribute]
private int <MarshalValueImpl>g__MarshalTrivial|91_3(T rawValue, CppModuleValueKind moduleKind);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleMemberAccessExpression : CppMemberAccessExpression {
    public CppModuleResolveResult ArrowResolveResult;
    public CppModuleResolveResult MemberResolveResult;
    public CppModuleMemberAccessExpression(ICppExpression leftArgument, CppQualifiedName rightArgument, CppMemberAccessType accessType, CppModuleResolveResult arrowResolveResult, CppModuleResolveResult memberResolveResult);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleNameIndex : ValueType {
    public static int Size;
    private CppAbstractIndex`1<CppModuleNameKind> myStorage;
    internal int RawStorage { get; }
    public CppModuleNameIndex(CppModuleNameKind kind, int rawIndex);
    public CppModuleNameIndex(int rawStorage);
    public CppModuleNameKind GetKind();
    public int RawIndex();
    internal int get_RawStorage();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleNameKind : Enum {
    public byte value__;
    public static CppModuleNameKind QualifiedId;
    public static CppModuleNameKind Anonymous;
    public static CppModuleNameKind Destructor;
    public static CppModuleNameKind DecltypeDestructor;
    public static CppModuleNameKind Operator;
    public static CppModuleNameKind GlobalNamespace;
    public static CppModuleNameKind Lambda;
    public static CppModuleNameKind MSSuper;
    public static CppModuleNameKind TemplateId;
    public static CppModuleNameKind SubstitutionId;
    public static CppModuleNameKind UserDefinedLiteral;
    public static CppModuleNameKind Decltype;
    public static CppModuleNameKind TypeOf;
    public static CppModuleNameKind TypeOfUnqual;
    public static CppModuleNameKind TypeOfTypeId;
    public static CppModuleNameKind TypeOfUnqualTypeId;
    public static CppModuleNameKind ConversionId;
    public static CppModuleNameKind ConversionsPack;
    public static CppModuleNameKind StructuredBindingId;
    public static CppModuleNameKind UnresolvedStructuredBindingId;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleNewExpression : CppNewExpression {
    public CppModuleResolveResult OperatorResolveResult;
    public CppModuleResolveResult ConstructorResolveResult;
    public CppDependentInfo DependentInfo;
    public CppModuleNewExpression(bool isGCNew, bool isFromGlobalNamespace, CppQualType qualType, ICppArgumentList operatorArgumentList, ICppArgumentList constructorArgumentList, CppModuleResolveResult operatorResolveResult, CppModuleResolveResult constructorResolveResult, CppDependentInfo dependentInfo);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleObjectValue : CppModuleValue {
    public ICppClassOrRefClassModuleEntity Class;
    public Dictionary`2<ICppVariableModuleEntity, ICppEvaluationResult> Fields;
    public CppModuleObjectValue(ICppClassOrRefClassModuleEntity clazz, Dictionary`2<ICppVariableModuleEntity, ICppEvaluationResult> fields);
}
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleOfBuiltins : object {
    private static Lazy`1<CppModule> ourInstance;
    public static CppFileLocation MODULE_OF_BUILTINS;
    private static CppModuleOfBuiltins();
    private static CppModule CreateModule();
    public static void Import(CppGlobalNamespaceResolveEntity globalNs);
    private static CppQualType CreateFunctionType(CppQualType returnType, CppQualType[] arguments, CppEllipsisKind ellipsis);
    private static CppQualType CreateFunctionType(CppQualType returnType, CppQualType[] arguments, ICppExceptionSpecification exceptionSpecification);
    private static CppQualType CreatePointerType(CppQualType pointee);
    private static CppQualType CreateTemplateParameterType(CppModuleTypeTemplateParameter param);
    private static CppModuleTypeTemplateParameter CreateTemplateParameter(string name);
    private static CppModuleTemplateId CreateTemplateId(CppQualifiedId inner, ICppModuleTemplateParameter[] tparams);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModulePointerOrReferenceToDeclarator : CppModuleValue {
    public ICppModuleEntity Declarator;
    protected CppModulePointerOrReferenceToDeclarator(ICppModuleEntity declarator);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModulePointerOrReferenceToTemplateParameterObject : CppModuleValue {
    public CppModuleObjectValue Object;
    protected CppModulePointerOrReferenceToTemplateParameterObject(CppModuleObjectValue object);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModulePointerToDeclarator : CppModulePointerOrReferenceToDeclarator {
    public CppModulePointerToDeclarator(ICppModuleEntity declarator);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModulePointerToReference : CppModuleValue {
    public ICppReferenceValue Pointee;
    public CppModulePointerToReference(ICppReferenceValue pointee);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModulePointerToTemplateParameterObject : CppModulePointerOrReferenceToTemplateParameterObject {
    public CppModulePointerToTemplateParameterObject(CppModuleObjectValue object);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModulePostfixExpression : CppPostfixExpression {
    public CppModuleResolveResult ResolveResult;
    public CppDependentInfo DependentInfo;
    public CppModulePostfixExpression(ICppExpression argument, CppOperatorKind operatorKind, CppModuleResolveResult resolveResult, CppDependentInfo dependentInfo);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleQualifiedReferenceExpression : CppQualifiedReferenceExpression {
    public CppModuleResolveResult ResolveResult;
    public CppDependentInfo DependentInfo;
    public ICppScopeModuleEntity ResolveScopeForDependencies;
    public CppModuleQualifiedReferenceExpression(CppQualifiedName nameHint, CppModuleResolveResult resolveResult, CppDependentInfo depInfo, ICppScopeModuleEntity resolveScopeForDependencies);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleReferenceToDeclarator : CppModulePointerOrReferenceToDeclarator {
    public CppModuleReferenceToDeclarator(ICppModuleEntity declarator);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleReferenceToField : CppModuleReferenceToDeclarator {
    public ICppValue Object;
    public bool DoDeref;
    public CppModuleReferenceToField(ICppModuleEntity declarator, ICppValue o, bool doDeref);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleReferenceToTemplateParameterObject : CppModulePointerOrReferenceToTemplateParameterObject {
    public CppModuleReferenceToTemplateParameterObject(CppModuleObjectValue object);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleRequiresExpression : CppRequiresExpression {
    public Scope _Scope;
    public CppSmallArray`1<ICppRequiresExpressionItem> Items;
    [CanBeNullAttribute]
public ICppModuleTemplateParameter[] TemplateDependencies;
    public CppModuleRequiresExpression(CppRequiresExpressionSymbol sym, Scope scope);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleResolveResult : ValueType {
    public Status Status;
    public CppSmallArray`1<ICppModuleEntity> Candidates;
    public CppModuleResolveResult(Status status, CppSmallArray`1<ICppModuleEntity> candidates);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleRuntimeArrayValue : CppArrayValue {
    public CppQualType ElementType;
    public int ArraySize;
    public CppModuleReferenceToDeclarator Declarator;
    public int Length { get; }
    public CppModuleRuntimeArrayValue(CppModuleReferenceToDeclarator declarator, CppQualType elementType, int arraySize);
    public virtual int get_Length();
    public virtual CppQualType GetElementType(ICppResolvedTypeFactory tf);
    public virtual bool ContainsEvaluationFail(CppEvaluationParams evalParams);
    public virtual CppDependentInfo GetDependentInfo();
    public virtual ICppEvaluationResult At(int index, ICppEvaluationErrorTracker errorTracker);
    public virtual CppTypeContext TryGetTypeContext();
    public virtual string Present(ICppPresenter p);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleSerializationUtil : object {
    public static int InitializerSize;
    public static int ResolveResultSize;
    public static int TypeIdOrExpressionSize;
    [ExtensionAttribute]
public static void Marshal(CppDeclaratorInitializer initializer, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    [ExtensionAttribute]
public static CppDeclaratorInitializer UnmarshalDeclaratorInitializer(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    [ExtensionAttribute]
public static void Marshal(CppModuleResolveResult rr, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    [ExtensionAttribute]
public static CppModuleResolveResult UnmarshalResolveResult(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    [ExtensionAttribute]
public static CppSerializedTypeIdOrExpression Marshal(ICppTypeIdOrExpression value, CppModuleMarshallingContext context);
    [ExtensionAttribute]
public static ICppTypeIdOrExpression UnmarshalTypeIdOrExpression(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    [ExtensionAttribute]
public static ICppTypeIdOrExpression UnmarshalTypeIdOrExpression(CppModuleUnmarshallingContext context, CppSerializedTypeIdOrExpression& data);
    [ExtensionAttribute]
public static ICppScopeModuleEntity UnmarshalModuleEntityParent(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    [ExtensionAttribute]
public static CppModuleSerializedAttributeName Marshal(CppAttributeName name, CppModuleMarshallingContext context);
    [ExtensionAttribute]
public static CppAttributeName Unmarshal(CppModuleUnmarshallingContext context, CppModuleSerializedAttributeName name);
    [ExtensionAttribute]
public static CppSerializedSymbolLocation Marshal(CppModuleMarshallingContext context, CppSymbolLocation symbolLocation);
    [ExtensionAttribute]
public static CppSymbolLocation UnmarshalSymbolLocation(CppModuleUnmarshallingContext context, CppSerializedSymbolLocation symbol);
    [ExtensionAttribute]
public static CppSerializedFileLocation Marshal(CppModuleMarshallingContext context, CppFileLocation file);
    [ExtensionAttribute]
public static CppFileLocation UnmarshalFileLocation(CppModuleUnmarshallingContext context, CppSerializedFileLocation file);
    [ExtensionAttribute]
public static CppSerializedModuleDescriptor Marshal(CppModuleMarshallingContext context, CppModuleDescriptor& module);
    [ExtensionAttribute]
public static CppModuleDescriptor UnmarshalModuleDescriptor(CppModuleUnmarshallingContext context, CppSerializedModuleDescriptor module);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleSerializedAttributeName : ValueType {
    public static int Size;
    public int Qualifier;
    public int Name;
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleSerializedDoubleStringLiteralAttribute : ValueType {
    public static int Size;
    public CppModuleSerializedAttributeName Name;
    public int FirstArgument;
    public int SecondArgument;
    public CppAttributeWithArguments`1<CppStringLiteralValue> Unmarshal(CppModuleUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleSerializedExpressionAttribute : ValueType {
    public static int Size;
    public CppModuleSerializedAttributeName Name;
    public CppModuleExpressionIndex Argument;
    public CppAttributeWithArgument`1<ICppExpression> Unmarshal(CppModuleUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleSerializedFormatAttribute : ValueType {
    public static int Size;
    public CppModuleSerializedAttributeName Name;
    public int Archetype;
    public CppModuleExpressionIndex StringIndex;
    public CppModuleExpressionIndex FirstToCheck;
    public CppAttributeFormat Unmarshal(CppModuleUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleSerializedSimpleAttribute : ValueType {
    public static int Size;
    public CppModuleSerializedAttributeName Name;
    public CppAttribute Unmarshal(CppModuleUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleSerializedStringLiteralAttribute : ValueType {
    public static int Size;
    public CppModuleSerializedAttributeName Name;
    public int Argument;
    public CppAttributeWithArgument`1<CppStringLiteralValue> Unmarshal(CppModuleUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleSerializedTypeIdOrExpressionAttribute : ValueType {
    public static int Size;
    public CppModuleSerializedAttributeName Name;
    public CppSerializedTypeIdOrExpression Argument;
    public CppAttributeWithArgument`1<ICppTypeIdOrExpression> Unmarshal(CppModuleUnmarshallingContext context);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleSerializedUEAttribute : ValueType {
    public static int Size;
    public CppModuleSerializedAttributeName Name;
    public CppSlice Specifiers;
    public int MetaSpecifiers;
    public CppUE4Attribute Unmarshal(CppModuleUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleSizeOfEllipsisExpression : CppSizeOfEllipsisExpression {
    public CppModuleResolveResult ResolvedArgument;
    public CppModuleSizeOfEllipsisExpression(CppQualifiedName unresolvedArgument, CppModuleResolveResult resolvedArgument);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleStringLiteralArrayValue : CppArrayValue {
    public FrugalLocalList`1<string> Literal;
    public CppQualType ElementType;
    public int ArraySize;
    public int Length { get; }
    public CppModuleStringLiteralArrayValue(FrugalLocalList`1<string> literal, CppQualType elementType, int arraySize);
    public virtual int get_Length();
    public virtual CppQualType GetElementType(ICppResolvedTypeFactory tf);
    public virtual bool ContainsEvaluationFail(CppEvaluationParams evalParams);
    public virtual CppDependentInfo GetDependentInfo();
    public virtual ICppEvaluationResult At(int index, ICppEvaluationErrorTracker errorTracker);
    public virtual CppTypeContext TryGetTypeContext();
    public virtual string Present(ICppPresenter p);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleSubscriptExpression : CppSubscriptExpression {
    public CppModuleResolveResult ResolveResult;
    public CppDependentInfo DependentInfo;
    public CppModuleSubscriptExpression(ICppExpression leftArgument, CppSmallArray`1<ICppExpression> indexArguments, CppModuleResolveResult resolveResult, CppDependentInfo dependentInfo);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleSubstitutionId : object {
    public CppQualifiedNamePart Inner;
    public CppSmallArray`1<ICppModuleTemplateArgument> Arguments;
    public CppModuleSubstitutionId(CppQualifiedNamePart inner, CppSmallArray`1<ICppModuleTemplateArgument> arguments);
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTemplateArgumentIndex : ValueType {
    public static int Size;
    private CppAbstractIndex`1<CppModuleTemplateArgumentKind> myStorage;
    internal int RawStorage { get; }
    public CppModuleTemplateArgumentIndex(CppModuleTemplateArgumentKind kind, int rawIndex);
    public CppModuleTemplateArgumentIndex(int rawStorage);
    public CppModuleTemplateArgumentKind GetKind();
    public int RawIndex();
    internal int get_RawStorage();
    public bool IsValid();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTemplateArgumentKind : Enum {
    public byte value__;
    public static CppModuleTemplateArgumentKind Type;
    public static CppModuleTemplateArgumentKind RawType;
    public static CppModuleTemplateArgumentKind TypePack;
    public static CppModuleTemplateArgumentKind Expression;
    public static CppModuleTemplateArgumentKind ExpressionPack;
    public static CppModuleTemplateArgumentKind TemplateTemplate;
    public static CppModuleTemplateArgumentKind TemplateTemplatePack;
    public static CppModuleTemplateArgumentKind InjectedClassName;
    public static CppModuleTemplateArgumentKind Excessive;
    public static CppModuleTemplateArgumentKind LookupFailure;
    public static CppModuleTemplateArgumentKind Dependent;
    public static CppModuleTemplateArgumentKind QualifiedReference;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTemplateId : object {
    public CppQualifiedNamePart Inner;
    public CppModuleTemplateParameters Parameters;
    public ICppModuleTemplateArgument[] Specialization;
    [CanBeNullAttribute]
public ICppModuleTemplateArgument[] DefaultTemplateArguments;
    public CppModuleTemplateId(CppQualifiedNamePart inner, CppModuleTemplateParameters parameters, ICppModuleTemplateArgument[] specialization);
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTemplateParameterBase : object {
    protected CppQualifiedNamePart Name;
    protected bool Orphaned;
    protected CppModuleTemplateParameterBase(CppQualifiedNamePart name, bool orphaned);
    public abstract virtual ICppTemplateParameter Import(CppModuleImportingContext ctx);
    public sealed virtual bool IsOrphaned();
    public abstract virtual CppModuleEntityKind Kind();
    public abstract virtual int SerializedSize();
    public abstract virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public abstract virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTemplateParameters : ValueType {
    public bool IsGeneric;
    public ICppModuleTemplateParameter[] List;
    [CanBeNullAttribute]
public ICppExpression RequiresClause;
    public virtual int GetHashCode();
    public sealed virtual bool Equals(CppModuleTemplateParameters other);
    public virtual bool Equals(object obj);
    public bool IsValid();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTemplateTemplateArgument : object {
    public static int StaticSerializedSize;
    private object myData;
    private bool myIsPackExpansion;
    public CppModuleTemplateTemplateArgument(object data, bool isPackExpansion);
    public sealed virtual ICppTemplateArgument Import(CppModuleImportingContext ctx);
    internal CppTemplateTemplateArgument ImportConcrete(CppModuleImportingContext ctx);
    public sealed virtual CppModuleTemplateArgumentKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    internal static CppModuleTemplateTemplateArgument Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    private static CppImportResult`1<ICppTypeTemplateResolveEntity> ImportTemplateTemplateArgumentData(object data, CppModuleImportingContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTemplateTemplateArgumentPack : object {
    private CppModuleTemplateTemplateArgument[] myPacked;
    public CppModuleTemplateTemplateArgumentPack(CppModuleTemplateTemplateArgument[] packed);
    public sealed virtual ICppTemplateArgument Import(CppModuleImportingContext ctx);
    public sealed virtual CppModuleTemplateArgumentKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTemplateTemplateParameter : CppModuleTemplateTemplateParameterOrPack {
    public CppModuleTemplateTemplateParameter(CppQualifiedNamePart name, bool orphaned, CppModuleTemplateParameters parameters);
    public virtual ICppTemplateParameter Import(CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTemplateTemplateParameterOrPack : CppModuleTemplateParameterBase {
    public CppModuleTemplateParameters Parameters;
    protected CppModuleTemplateTemplateParameterOrPack(CppQualifiedNamePart name, bool orphaned, CppModuleTemplateParameters parameters);
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTemplateTemplateParameterPack : CppModuleTemplateTemplateParameterOrPack {
    public CppModuleTemplateTemplateParameterPack(CppQualifiedNamePart name, bool orphaned, CppModuleTemplateParameters parameters);
    public virtual ICppTemplateParameter Import(CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTypeIndex : ValueType {
    public static int Size;
    private CppAbstractIndex`1<CppModuleTypeKind> myStorage;
    public int RawStorage { get; }
    public CppModuleTypeIndex(CppModuleTypeKind kind, int rawIndex);
    public CppModuleTypeIndex(int rawStorage);
    public CppModuleTypeKind GetKind();
    public int RawIndex();
    public int get_RawStorage();
    public sealed virtual bool Equals(CppModuleTypeIndex other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTypeKind : Enum {
    public byte value__;
    public static CppModuleTypeKind Auto;
    public static CppModuleTypeKind DecltypeAuto;
    public static CppModuleTypeKind Void;
    public static CppModuleTypeKind Nullptr;
    public static CppModuleTypeKind Numeric;
    public static CppModuleTypeKind Unknown;
    public static CppModuleTypeKind Pointer;
    public static CppModuleTypeKind MemberPointer;
    public static CppModuleTypeKind Array;
    public static CppModuleTypeKind Vector;
    public static CppModuleTypeKind Function;
    public static CppModuleTypeKind FunctionWithNoexceptSpec;
    public static CppModuleTypeKind FunctionWithDynamicSpec;
    public static CppModuleTypeKind FunctionWithBigDynamicSpec;
    public static CppModuleTypeKind PackExpansion;
    public static CppModuleTypeKind HlslMatrix;
    public static CppModuleTypeKind HlslVector;
    public static CppModuleTypeKind HlslSampler;
    public static CppModuleTypeKind BuiltinTypeTraitType;
    public static CppModuleTypeKind DecoratedBuiltinTypeTraitType;
    public static CppModuleTypeKind ModuleEntity;
    public static CppModuleTypeKind Typedef;
    public static CppModuleTypeKind InstantiatedTemplateAlias;
    public static CppModuleTypeKind DependentInstantiatedTemplateAlias;
    public static CppModuleTypeKind DeducedClassTypePlaceholder;
    public static CppModuleTypeKind NamedParameter;
    public static CppModuleTypeKind NameSuggestion;
    public static CppModuleTypeKind ScopeSuggestion;
    public static CppModuleTypeKind FunctionWithTrailingReturnType;
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTypeMarshaller : CppAbstractTypeVisitor`1<CppMonostate> {
    private CppModuleMarshallingContext myContext;
    public CppBinaryStreamWriter Writer;
    public CppModuleTypeMarshaller(CppModuleMarshallingContext context);
    public virtual CppMonostate VisitType(CppType t, Qualifiers q);
    public virtual CppMonostate Visit(HlslMatrixType t, Qualifiers q);
    public virtual CppMonostate Visit(HlslVectorType t, Qualifiers q);
    public virtual CppMonostate Visit(HlslSamplerType t, Qualifiers q);
    public virtual CppMonostate Visit(CppNumericType t, Qualifiers q);
    public virtual CppMonostate Visit(CppPackExpansionType t, Qualifiers q);
    public virtual CppMonostate Visit(CppUnknownType t, Qualifiers q);
    public virtual CppMonostate VisitTypeWithInnerType(CppTypeWithInnerType t, Qualifiers q);
    public virtual CppMonostate Visit(CppMemberPointerType t, Qualifiers q);
    public virtual CppMonostate Visit(CppArrayType t, Qualifiers q);
    public virtual CppMonostate Visit(CppVectorType t, Qualifiers q);
    public virtual CppMonostate Visit(CppFunctionType t, Qualifiers q);
    public virtual CppMonostate Visit(CppBuiltinTypeTraitType t, Qualifiers q);
    public virtual CppMonostate Visit(CppModuleEntityType t, Qualifiers q);
    public virtual CppMonostate Visit(CppTypedefModuleType t, Qualifiers q);
    public virtual CppMonostate Visit(CppInstantiatedTemplateAliasModuleType t, Qualifiers q);
    public virtual CppMonostate Visit(CppDependentInstantiatedTemplateAliasModuleType t, Qualifiers q);
    public virtual CppMonostate Visit(CppDeducedClassTypePlaceholderModuleType t, Qualifiers q);
    public virtual CppMonostate VisitReference(CppQualType innerType, ReferenceFlag r);
    public sealed virtual CppMonostate Visit(CppFunctionWithTrailingReturnType t, Qualifiers q);
    public sealed virtual CppMonostate Visit(CppInstantiatedTemplateAliasType t, Qualifiers q);
    public sealed virtual CppMonostate Visit(CppNamedParameterType t, Qualifiers q);
    public sealed virtual CppMonostate Visit(CppNameSuggestionType t, Qualifiers q);
    public sealed virtual CppMonostate Visit(CppScopeSuggestionType t, Qualifiers q);
    public sealed virtual CppMonostate Visit(CppDecoratedBuiltinTypeTraitType t, Qualifiers q);
    public sealed virtual CppMonostate Visit(CppTypedefType t, Qualifiers q);
    public sealed virtual CppMonostate Visit(CppNamedType t, Qualifiers q);
    public sealed virtual CppMonostate Visit(CppCEnumeratorType t, Qualifiers q);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTypeSerializationDataProvider : CppAbstractTypeVisitor`1<ValueTuple`2<CppModuleTypeKind, int>> {
    public static CppModuleTypeSerializationDataProvider Instance;
    private static CppModuleTypeSerializationDataProvider();
    public virtual ValueTuple`2<CppModuleTypeKind, int> VisitType(CppType t, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(HlslMatrixType t, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(HlslVectorType t, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(HlslSamplerType t, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> VisitReference(CppQualType innerType, ReferenceFlag r);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppVoidType _, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppNullptrType _, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppNumericType _, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppUnknownType _, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppPackExpansionType _, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppPointerType _, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppMemberPointerType _, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppArrayType _, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppVectorType _, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppModuleEntityType _, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppTypedefModuleType _, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppBuiltinTypeTraitType _, Qualifiers q);
    public sealed virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppDecoratedBuiltinTypeTraitType _, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppInstantiatedTemplateAliasModuleType t, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppDependentInstantiatedTemplateAliasModuleType t, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppDeducedClassTypePlaceholderModuleType t, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppFunctionType t, Qualifiers q);
    public virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppAutoType t, Qualifiers q);
    public sealed virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppNamedParameterType _, Qualifiers q);
    public sealed virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppNameSuggestionType _, Qualifiers q);
    public sealed virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppScopeSuggestionType _, Qualifiers q);
    public sealed virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppFunctionWithTrailingReturnType _, Qualifiers q);
    public sealed virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppNamedType t, Qualifiers q);
    public sealed virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppCEnumeratorType t, Qualifiers q);
    public sealed virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppTypedefType t, Qualifiers q);
    public sealed virtual ValueTuple`2<CppModuleTypeKind, int> Visit(CppInstantiatedTemplateAliasType t, Qualifiers q);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTypeTemplateArgumentPack : object {
    private CppQualType[] myPacked;
    public CppModuleTypeTemplateArgumentPack(CppQualType[] packed);
    public sealed virtual ICppTemplateArgument Import(CppModuleImportingContext ctx);
    public sealed virtual CppModuleTemplateArgumentKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTypeTemplateParameter : CppModuleTypeTemplateParameterOrPack {
    public CppModuleTypeTemplateParameter(CppQualifiedNamePart name, bool orphaned, CppTypeTemplateParameterKey key);
    public virtual ICppTemplateParameter Import(CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTypeTemplateParameterOrPack : CppModuleTypeTemplateParameterOrPackBase {
    protected CppTypeTemplateParameterKey Key;
    protected CppModuleTypeTemplateParameterOrPack(CppQualifiedNamePart name, bool orphaned, CppTypeTemplateParameterKey key);
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTypeTemplateParameterOrPackBase : CppModuleTemplateParameterBase {
    protected CppModuleTypeTemplateParameterOrPackBase(CppQualifiedNamePart name, bool orphaned);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleTypeTemplateParameterPack : CppModuleTypeTemplateParameterOrPack {
    public CppModuleTypeTemplateParameterPack(CppQualifiedNamePart name, bool orphaned, CppTypeTemplateParameterKey key);
    public virtual ICppTemplateParameter Import(CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleUnaryExpression : CppUnaryExpression {
    public CppModuleResolveResult ResolveResult;
    public CppDependentInfo DependentInfo;
    public CppModuleUnaryExpression(ICppExpression argument, CppOperatorKind operatorKind, CppModuleResolveResult resolveResult, CppDependentInfo dependentInfo);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleUnknownInfoIndex : ValueType {
    public static int Size;
    private CppAbstractIndex`1<CppModuleUnknownInfoKind> myStorage;
    internal int RawStorage { get; }
    public CppModuleUnknownInfoIndex(CppModuleUnknownInfoKind kind, int rawIndex);
    public CppModuleUnknownInfoIndex(int rawStorage);
    public CppModuleUnknownInfoKind GetKind();
    public int RawIndex();
    internal int get_RawStorage();
    public bool IsValid();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleUnknownInfoKind : Enum {
    public byte value__;
    public static CppModuleUnknownInfoKind Internal;
    public static CppModuleUnknownInfoKind Lookup;
    public static CppModuleUnknownInfoKind RecursiveTypeCalculation;
    public static CppModuleUnknownInfoKind UnknownArraySize;
    public static CppModuleUnknownInfoKind ZeroOrNegativeArraySize;
    public static CppModuleUnknownInfoKind UnknownUE4Type;
    public static CppModuleUnknownInfoKind NonTypeEntityUsedAsType;
    public static CppModuleUnknownInfoKind ExpressionEvaluation;
    public static CppModuleUnknownInfoKind InvalidFoldExpression;
    public static CppModuleUnknownInfoKind Substitution;
    public static CppModuleUnknownInfoKind AutoTypeDeduction;
    public static CppModuleUnknownInfoKind AutoTypeConstraint;
    public static CppModuleUnknownInfoKind DeducedReturnTypeUsedBeforeFunctionDefinition;
    public static CppModuleUnknownInfoKind TypeConversion;
    public static CppModuleUnknownInfoKind StructuredBindingTypeDeduction;
    public static CppModuleUnknownInfoKind InvalidNumberOfStructuredBindings;
    public static CppModuleUnknownInfoKind InvalidStructuredBindingsInitializerClass;
    public static CppModuleUnknownInfoKind InvalidType;
    public static CppModuleUnknownInfoKind WithReason;
    public static CppModuleUnknownInfoKind NonExpressionTemplateArgumentUsedAsExpressionFailure;
    public static CppModuleUnknownInfoKind ComparisonCategoryLookupFailure;
    public static CppModuleUnknownInfoKind InvalidNonTypeTemplateArgumentValueFailure;
    public static CppModuleUnknownInfoKind InvalidArgumentOfBuiltinTypeTraitFailure;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleUnmarshallingContext : ValueType {
    private Dictionary`2<CppModuleEntityKind, SerializedStorage> mySerializedModuleEntities;
    private Dictionary`2<CppModuleTypeKind, SerializedStorage> mySerializedTypes;
    private Dictionary`2<CppModuleExpressionKind, SerializedStorage> mySerializedExpressions;
    private Dictionary`2<CppModuleTemplateArgumentKind, SerializedStorage> mySerializedTemplargs;
    private Dictionary`2<CppModuleValueKind, SerializedStorage> mySerializedValues;
    private Dictionary`2<CppModuleEntityIndex, EntityDeserializationStatus> myAlreadyDeserialized;
    private Dictionary`2<CppModuleTypeIndex, CppType> myDeserializedTypes;
    private String[] myStrings;
    private Span`1<CppSerializedModuleTemplateId> myTemplateIds;
    private Span`1<CppSerializedModuleSubstitutionId> mySubstitutionIds;
    private Span`1<CppSlice> myStructuredBindingIds;
    private Span`1<CppSerializedStructuredBindingSymbol> myStructuredBindingSymbols;
    private Span`1<CppSerializedNamespaceChildRecord> myNsChildren;
    private Span`1<CppModuleEntityIndex> myModuleEntities;
    private Span`1<CppSerializedModuleType> myQualTypes;
    private Span`1<CppSerializedModuleTypeWithPackExpansion> myPackExpansionQualTypes;
    private Span`1<CppSerializedModuleTypeWithPayload> myPayloadQualTypes;
    private Span`1<CppModuleExpressionIndex> myExpressions;
    private Span`1<CppModuleTemplateArgumentIndex> myTemplargs;
    private Span`1<CppSerializedClassBase> myClassBases;
    private Span`1<CppSerializedNonDependentClassBase> myNonDependentClassBases;
    private Span`1<CppSerializedQualifiedName> myNameQualifiers;
    private Span`1<CppModuleUnknownInfoIndex> myUnknownEntityInfos;
    private Span`1<int> myStringLiteralParts;
    private Span`1<int> myRequiresExpressionItems;
    private Span`1<int> myDefaultedTemplateArguments;
    private Span`1<CompoundRequirement> myCompoundRequiresItems;
    private Span`1<Designator> myDesignators;
    private Span`1<CppSerializedModulePointerToArrayElementValue> myPointerToArrayElementValues;
    private Span`1<CppSerializedModuleReferenceToFieldValue> myReferenceToFieldValues;
    private Span`1<CppSerializedFunctionDeclaratorSymbol> myFunctionSymbols;
    private Span`1<CppSerializedDeclaratorSymbol> myDeclaratorSymbols;
    private Span`1<CppSerializedClassSymbol> myClassSymbols;
    private Span`1<CppSerializedAutoTypeDeductionFailure> myAutoTypeDeductionFailures;
    private Span`1<CppSerializedTypeConversionFailure> myTypeConversionFailures;
    private Span`1<CppModuleAttributeIndex> myAttributes;
    private Span`1<CppModuleSerializedSimpleAttribute> mySimpleAttributes;
    private Span`1<CppModuleSerializedExpressionAttribute> myExpressionAttributes;
    private Span`1<CppModuleSerializedTypeIdOrExpressionAttribute> myTypeIdOrExpressionAttributes;
    private Span`1<CppModuleSerializedStringLiteralAttribute> myStringLiteralAttributes;
    private Span`1<CppModuleSerializedDoubleStringLiteralAttribute> myDoubleStringLiteralAttributes;
    private Span`1<CppModuleSerializedFormatAttribute> myFormatAttributes;
    private Span`1<CppModuleSerializedUEAttribute> myUEAttributes;
    private Span`1<Specifier> myUEAttributeSpecifiers;
    private Span`1<BlockShadersModuleSerializedAttribute> myBSAttributes;
    private Span`1<Parameter> myBSAttributeParameters;
    private Span`1<ParameterValue> myBSAttributeParameterValues;
    private CppModuleUnmarshallingContext(UnsafeReader unsafeReader);
    private void UnmarshalGlobalNamespaceModuleEntity(Byte* globalNamespace, CppGlobalNamespaceModuleEntity result);
    private void Unmarshal(UnsafeReader reader, Dictionary`2<ICppModuleEntity, string> owningModule);
    public static CppGlobalNamespaceModuleEntity Unmarshal(UnsafeReader reader);
    public TEntity UnmarshalOptional(CppModuleEntityIndex index, bool deep);
    public TEntity Unmarshal(CppModuleEntityIndex index, bool deep);
    public void UnmarshalShallow(CppModuleEntityKind kind, List`1<ICppModuleEntity> entities);
    private static ICppModuleEntity CreateEmptyModuleEntity(CppModuleEntityKind kind);
    public TModuleEntity[] UnmarshalArray(CppSlice slice, bool deep);
    public CppSmallArray`1<TModuleEntity> UnmarshalSmallArray(CppSlice slice, bool deep);
    public CppSmallArray`1<ICppModuleEntity> UnmarshalSmallArray(CppSlice slice);
    public CppSmallArray`1<ICppRequiresExpressionItem> UnmarshalRequiresExpressionItems(CppSlice slice);
    private ICppRequiresExpressionItem[] UnmarshalArrayOfRequiresExpressionItems(CppSlice slice);
    private ICppRequiresExpressionItem UnmarshalRequiresExpressionItem(int data);
    private CppRequiresExpressionItemCompound Deserialize(CompoundRequirement serialized);
    private TModuleEntity[] UnmarshalBigArrayOrModuleEntities(CppSlice slice, bool deep);
    public CppQualType[] UnmarshalTypeArray(CppSlice slice);
    public CppBasicBaseDescription`1[] UnmarshalBases(CppSlice slice);
    public CppBasicBaseDescription`1[] UnmarshalNonDependentBases(CppSlice slice);
    public ICppExpression[] UnmarshalArrayOfExpressions(CppSlice slice);
    public CppSmallArray`1<ICppExpression> UnmarshalSmallArrayOfExpressions(CppSlice slice);
    private ICppExpression[] UnmarshalBigArrayOfExpressions(CppSlice slice);
    public void UnmarshalNsChildren(CppSlice slice, Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppNamespaceModuleEntityChild>> result);
    private CppSmallList`1<ICppNamespaceModuleEntityChild> UnmarshalBucketOfNsChildren(CppSlice slice);
    public CppQualifiedNamePart Unmarshal(CppModuleNameIndex index);
    private CppQualifiedId UnmarshalQualifiedId(int index);
    private CppDecltypeId DeserializeDecltypeId(int expressionIdx, CppDecltypeKind kind);
    public string GetString(int idx);
    public CppQualifiedName UnmarshalOptional(CppSerializedQualifiedName qualName);
    public CppQualifiedName Unmarshal(CppSerializedQualifiedName qualName);
    public ICppDesignator UnmarshalDesignator(int idx);
    public CppUnknownEntityInfo Unmarshal(CppModuleUnknownInfoIndex index);
    private static CppStructuredBindingTypeDeductionFailure Create(CppStructuredBindingTypeDeductionFailureKind kind);
    private static CppUnknownEntityInfoWithReason Create(CppUnknownEntityReason kind);
    private CppAutoTypeDeductionFailure UnmarshalAutoTypeDeductionFailure(CppSerializedAutoTypeDeductionFailure input);
    private CppTypeConversionFailure UnmarshalTypeConversionFailure(CppSerializedTypeConversionFailure input);
    private CppZeroOrNegativeArraySizeFailure UnmarshalZeroOrNegativeArraySizeFailure(CppModuleUnknownInfoIndex index);
    private static CppExpressionEvaluationFailure UnmarshalExpressionEvaluationFailure(CppModuleUnknownInfoIndex index);
    private CppSubstitutionFailure UnmarshalSubstitutionFailure(CppModuleUnknownInfoIndex index);
    private CppInvalidTypeFailure UnmarshalInvalidTypeFailure(CppSerializedModuleTypeWithPayload type);
    private CppInvalidNumberOfStructuredBindingsFailure UnmarshalInvalidNumberOfStructuredBindingsFailure(CppSerializedModuleTypeWithPayload type);
    public CppQualType Unmarshal(CppSerializedModuleType type);
    private void Unmarshal(ICppModuleEntity entity, CppModuleEntityIndex index);
    private CppModuleTemplateId Deserialize(CppSerializedModuleTemplateId templateId);
    internal CppModuleTemplateParameters Unmarshal(CppSerializedModuleTemplateParameters parameters);
    private CppModuleSubstitutionId Deserialize(CppSerializedModuleSubstitutionId substitutionId);
    [CanBeNullAttribute]
public ICppExpression UnmarshalOptional(CppModuleExpressionIndex index);
    public ICppExpression Unmarshal(CppModuleExpressionIndex index);
    private CppType Unmarshal(CppModuleTypeIndex index);
    private CppType UnmarshalTypeImpl(CppModuleTypeIndex index);
    private CppType Unmarshal(CppModuleTypeKind kind, CppBinaryStreamReader& input);
    private static CppType GetPredefinedType(CppNumericTypeKind nk);
    private CppMemberPointerType UnmarshalMemberPointerType(CppBinaryStreamReader& input);
    private CppArrayType UnmarshalArrayType(CppBinaryStreamReader& input);
    private CppVectorType UnmarshalVectorType(CppBinaryStreamReader& input);
    private CppInstantiatedTemplateAliasModuleType UnmarshalInstantiatedTemplateAliasModuleType(CppBinaryStreamReader& input);
    private CppDependentInstantiatedTemplateAliasModuleType UnmarshalDependentInstantiatedTemplateAliasModuleType(CppBinaryStreamReader& input);
    private CppNamedParameterType UnmarshalNamedParameterType(CppBinaryStreamReader& input);
    private CppNameSuggestionType UnmarshalNameSuggestionType(CppBinaryStreamReader& input);
    private CppScopeSuggestionType UnmarshalScopeSuggestionType(CppBinaryStreamReader& input);
    private ICppExpression Unmarshal(CppModuleExpressionKind kind, CppBinaryStreamReader& input);
    public Element UnmarshalDynamicExceptionSpecElement(CppSerializedModuleTypeWithPackExpansion serializedType);
    public CppList`1<Element> UnmarshalDynamicExceptionSpecElements(CppSlice slice);
    public CppList`1<Element> UnmarshalMultiArgumentTypeTraitElements(CppSlice slice);
    public Element UnmarshalMultiArgumentTypeTraitElement(CppSerializedModuleTypeWithPackExpansion serializedType);
    public CppSmallArray`1<ICppAttribute> UnmarshalAttributes(CppSlice slice);
    private ICppAttribute UnmarshalAttribute(CppModuleAttributeIndex index);
    public IEnumerable`1<ICppSymbol> UnmarshalFunctionSymbols(CppSlice slice);
    public IEnumerable`1<ICppSymbol> UnmarshalDeclaratorSymbols(CppSlice slice);
    private ICppDeclaratorSymbol UnmarshalFunctionSymbol(CppSerializedFunctionDeclaratorSymbol symbol);
    private ICppDeclaratorSymbol UnmarshalDeclaratorSymbol(CppSerializedDeclaratorSymbol symbol);
    public ICppClassOrDelegateSymbol[] UnmarshalClassSymbols(CppSlice slice);
    private ICppClassSymbol UnmarshalClassSymbol(CppSerializedClassSymbol symbol);
    private CppUnresolvedStructuredBindingId UnmarshalStructuredBindingId(CppSlice slice);
    private CppStructuredBindingSymbol UnmarshalStructuredBindingSymbol(CppSerializedStructuredBindingSymbol symbol);
    private ICppResolvedLiteralExpression UnmarshalLiteralExpression(int index);
    private ICppResolvedLiteralExpression UnmarshalLiteral(int index);
    public CppStringLiteralValue UnmarshalStringLiteralValue(int index);
    public FrugalLocalList`1<string> UnmarshalStringLiteral(CppSlice slice);
    private ICppPointerValue UnmarshalPointerValue(int data);
    private CppPointerToArrayElement UnmarshalPointerToArrayElement(CppSerializedModulePointerToArrayElementValue source);
    private CppReferenceToArrayElement UnmarshalReferenceToArrayElement(CppSerializedModulePointerToArrayElementValue source);
    private ICppReferenceValue UnmarshalReferenceValue(int data);
    private CppModuleReferenceToDeclarator UnmarshalReferenceToDeclarator(int index);
    private CppModuleReferenceToField UnmarshalReferenceToField(CppSerializedModuleReferenceToFieldValue source);
    private CppModuleObjectValue UnmarshalObjectValue(CppSerializedModuleObjectValue serialized);
    private CppArrayValue UnmarshalArrayValue(CppSerializedModuleArrayValue serialized);
    private CppSimpleArrayValue UnmarshalSimpleArrayValue(CppSerializedModuleArrayValue serialized);
    private CppRLEArrayValue UnmarshalRLEArrayValue(CppSerializedModuleArrayValue serialized);
    private CppModuleStringLiteralArrayValue UnmarshalStringLiteralArrayValue(CppSerializedModuleArrayValue serialized);
    private CppModuleRuntimeArrayValue UnmarshalRuntimeArrayValue(CppSerializedModuleArrayValue serialized);
    private ICppEvaluationResult[] UnmarshalArrayElements(CppSlice slice);
    private CppModuleEnumValue UnmarshalEnumValue(CppSerializedModuleEnumValue value);
    private CppSlice GetStringLiteralData(int index);
    private int GetPointerValue(int index);
    private int GetReferenceValue(int index);
    private CppSerializedModuleObjectValue GetObjectValue(int index);
    private CppSerializedModuleArrayValue GetArrayValue(int index);
    private CppSerializedModuleEnumValue GetEnumValue(int index);
    private T ReadValue(int index, CppModuleValueKind kind);
    private CppEmptyExpression UnmarshalEmptyExpression(CppModuleUnknownInfoIndex unknownEntity);
    private CppResolvedThisExpression UnmarshalThisExpression(CppBinaryStreamReader& input);
    private CppModuleSizeOfEllipsisExpression UnmarshalSizeOfEllipsisExpression(CppBinaryStreamReader& input);
    private CppModuleGnuStatementExpression UnmarshalGnuStatementExpression(CppBinaryStreamReader& input);
    private CppSingleArgumentTypeTraitExpression UnmarshalSingleArgumentTypeTrait(CppBinaryStreamReader& input);
    private CppDoubleArgumentTypeTraitExpression UnmarshalDoubleArgumentTypeTrait(CppBinaryStreamReader& input);
    private CppMultiArgumentTypeTraitExpression UnmarshalMultiArgumentTypeTrait(CppBinaryStreamReader& input);
    [CanBeNullAttribute]
private ICppModuleTemplateArgument[] UnmarshalArrayOfTemplateArguments(CppSlice slice);
    public CppSmallArray`1<ICppModuleTemplateArgument> UnmarshalTemplateArguments(CppSlice slice);
    public Int32[] UnmarshalDefaultedTemplateArguments(CppSlice slice);
    public CppModuleTemplateTemplateArgument[] UnmarshalTemplateTemplateArguments(CppSlice slice);
    private ICppModuleTemplateArgument[] UnmarshalBigArrayOfTemplateArguments(CppSlice slice);
    private ICppModuleTemplateArgument UnmarshalTemplateArgument(CppModuleTemplateArgumentIndex index);
    private ICppModuleTemplateArgument Unmarshal(CppModuleTemplateArgumentKind kind, CppBinaryStreamReader& input);
    public SortedList`2<string, FrugalLocalHashSet`1<string>> UnmarshalUEAttributeSpecifiers(CppSlice slice);
    private void Unmarshal(Specifier specifier, SortedList`2<string, FrugalLocalHashSet`1<string>> result);
    private FrugalLocalHashSet`1<string> UnmarshalUEAttributeSpecifierValues(CppSlice slice);
    public CppList`1<BSAttributeData> UnmarshalBlockShadersAttributes(CppSlice slice);
    private BSAttributeData UnmarshalBSAttribute(CppModuleAttributeIndex index);
    public CppList`1<IBSAttributeParameter> UnmarshalBSAttributeParameters(CppSlice slice);
    private IBSAttributeParameter UnmarshalBsAttributeParameter(Parameter param);
    private IBSAttributeParameterValue UnmarshalBSParameterValue(ParameterValue value);
    public void FinishUnmarshalling();
    private static String[] ReadStringArray(UnsafeReader unsafeReader);
    private static void ReadArray(UnsafeReader unsafeReader, Span`1& result);
    private static Dictionary`2<TEnum, SerializedStorage> ReadDictionary(UnsafeReader unsafeReader);
    [CompilerGeneratedAttribute]
internal static CppEvaluationFail <UnmarshalEmptyExpression>g__UnmarshalEvaluationFail|150_0(CppEvaluationFailureKind kind);
    [CompilerGeneratedAttribute]
internal static CppInvalidFoldExpressionFailure <UnmarshalEmptyExpression>g__UnmarshalInvalidFoldExpressionFailure|150_1(CppInvalidFoldExpressionFailureKind kind);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleUserDefinedLiteralExpression : CppUserDefinedLiteralExpression {
    public CppModuleResolveResult ResolveResult;
    public CppModuleUserDefinedLiteralExpression(ICppUserDefinedLiteralValue value, string suffix, CppModuleResolveResult resolveResult);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleValue : object {
    public sealed virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public virtual CppTypeContext TryGetTypeContext();
    public sealed virtual bool ContainsEvaluationFail(CppEvaluationParams _);
    public sealed virtual ICppLiteralValue GetValue();
    public sealed virtual Result Accept(ICppValueVisitor`1<Result> visitor);
}
internal enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppModuleValueKind : Enum {
    public int value__;
    public static CppModuleValueKind BOOL;
    public static CppModuleValueKind CHAR;
    public static CppModuleValueKind UNSIGNED_CHAR;
    public static CppModuleValueKind SIGNED_CHAR;
    public static CppModuleValueKind WCHAR_T16;
    public static CppModuleValueKind WCHAR_T32;
    public static CppModuleValueKind CHAR8_T;
    public static CppModuleValueKind CHAR16_T;
    public static CppModuleValueKind CHAR32_T;
    public static CppModuleValueKind SHORT;
    public static CppModuleValueKind UNSIGNED_SHORT;
    public static CppModuleValueKind INT;
    public static CppModuleValueKind UNSIGNED;
    public static CppModuleValueKind LONG32;
    public static CppModuleValueKind UNSIGNED_LONG32;
    public static CppModuleValueKind LONG64;
    public static CppModuleValueKind UNSIGNED_LONG64;
    public static CppModuleValueKind LONGLONG;
    public static CppModuleValueKind UNSIGNED_LONGLONG;
    public static CppModuleValueKind NULLPTR_T;
    public static CppModuleValueKind STRING_LITERAL;
    public static CppModuleValueKind HALF;
    public static CppModuleValueKind FLOAT;
    public static CppModuleValueKind DOUBLE;
    public static CppModuleValueKind LONG_DOUBLE;
    public static CppModuleValueKind REFERENCE;
    public static CppModuleValueKind POINTER;
    public static CppModuleValueKind ARRAY;
    public static CppModuleValueKind BRACED_INIT_LIST;
    public static CppModuleValueKind OBJECT;
    public static CppModuleValueKind ENUMERATOR;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppMSSuperId : object {
    public static CppMSSuperId INSTANCE;
    private static CppMSSuperId();
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppMultiArgumentTypeTraitExpressionBuilder : object {
    private CppList`1<Element> myArguments;
    public sealed virtual void LearnArgument(ICppDeclarationBuilder declBuilder, bool isPackExpansion);
    public CppList`1<Element> GetArguments();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppMutableLinkageTemplateParameterList : CppLinkageTemplateParameterList {
    public void SetOwner(ICppLinkageEntity owner);
    public void SetParameters(ICppLinkageTemplateParameter[] parameters);
    public void SetRequiresClause(ICppExpression clause);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNamedLambdaCapture : object {
    private CppQualifiedId myName;
    private bool myRef;
    public CppNamedLambdaCapture(CppQualifiedId name, bool ref);
    public CppQualifiedId GetName();
    public bool IsRef();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNamespaceAliasLinkageEntity : CppLinkageEntity {
    [CompilerGeneratedAttribute]
private ICppLinkageEntity <Target>k__BackingField;
    public ICppLinkageEntity Target { get; }
    public CppNamespaceAliasLinkageEntity(CppQualifiedNamePart name, ICppLinkageEntity parent, ICppLinkageEntity target);
    [CompilerGeneratedAttribute]
public ICppLinkageEntity get_Target();
    public virtual Result Accept(ICppLinkageEntityVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNamespaceAliasModuleEntity : object {
    public CppQualifiedNamePart Name;
    public ICppScopeModuleEntity Parent;
    [CanBeNullAttribute]
public CppNamespaceModuleEntity Target;
    private bool myExplicitlyExported;
    public CppNamespaceAliasModuleEntity(CppQualifiedNamePart name, ICppScopeModuleEntity parent, CppNamespaceModuleEntity target, bool explicitlyExported);
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual ICppScopeModuleEntity GetParent();
    public sealed virtual bool IsExplicitlyExported();
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNamespaceAliasResolveEntity : object {
    private ICppScopeResolveEntity myParent;
    private CppSmallList`1<PartDescription> myParts;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <LocationAnchor>k__BackingField;
    public CppLocationAnchor[] SymbolAnchors { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppNamespaceAliasResolveEntity(ICppScopeResolveEntity parentScope, CppQualifiedNamePart name, CppLocationAnchor anchor);
    public CppLocationAnchor[] get_SymbolAnchors();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    [CompilerGeneratedAttribute]
public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    [CompilerGeneratedAttribute]
public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public void AddSymbolPart(CppNamespaceAliasSymbol sym, CppQualifiedName targetName, CppLocationAnchor anchor);
    public void AddModulePart(ICppModuleEntity ment, CppLocationAnchor anchor, CppNamespaceResolveEntity target);
    public CppLocationAnchor GetAnchorBySymbol(ICppSymbol sym);
    public CppNamespaceResolveEntity GetTarget(CppViewPos& viewPos);
    public bool Export();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNamespaceAliasSymbol : CppParserSymbol {
    private CppQualifiedName myTarget;
    private bool myExport;
    public CppNamespaceAliasSymbol(CppQualifiedName name, CppComplexOffset loc, CppQualifiedName target, bool export);
    public CppQualifiedName GetTarget();
    public bool Export();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNamespaceBuilder : CppBuilderWithParent {
    private CppSymbolLocation myLocation;
    private CppQualifiedNamePart myName;
    private bool myExport;
    private bool myInline;
    private bool myNamespaceContextSymbol;
    private CppNamespaceSymbol myScopeSym;
    private CppNamespaceResolveEntity myResolveEnt;
    private CppAttributeList myUnresolvedAttributes;
    private CppAttributeList myReplacedAttributes;
    private CppNamespaceQualifierSymbol myNestedParentSymbol;
    private CppNamespaceResolveEntity myNestedParentResolveEntity;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public CppNamespaceBuilder(ICppBuilder parent, bool export);
    public bool IsExporting();
    public void LearnLocation(CppSymbolLocation location);
    public void LearnName(CppQualifiedNamePart name);
    public void LearnStartOffset(CppComplexOffset offset);
    public void LearnEndOffset(CppComplexOffset offset);
    public void LearnInline(bool isInline);
    public void LearnNamespaceContextSymbol();
    public void LearnAttributes(ICppAttributeListBuilder attrsBuilder);
    public CppNamespaceQualifierSymbol BuildNestedNamespace();
    public CppNamespaceSymbol BuildNamespace();
    public CppNamespaceAliasSymbol BuildNamespaceAlias(CppTwinQualifiedNameBuilder& targetNameBuilder);
    public virtual void AddChild(CppParserSymbol sym);
    public virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual ICppParserSymbol GetClassParentSymbol();
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNamespaceBuilderUtil : object {
    public static CppNamespaceResolveEntity CreateNamespaceResolveEntity(ICppScopeResolveEntity parentScope, CppQualifiedNamePart name, CppLocationAnchor anchor);
    public static CppNamespaceAliasResolveEntity CreateNamespaceAliasResolveEntity(ICppScopeResolveEntity parentScope, CppQualifiedNamePart name, CppLocationAnchor anchor);
    private static T FindResolveEntity(ICppScopeResolveEntity parentScope, CppQualifiedNamePart name, CppLocationAnchor anchor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNamespaceLinkageEntity : CppLinkageEntity {
    public static CppNamespaceLinkageEntity GLOBAL_NAMESPACE;
    [CompilerGeneratedAttribute]
private bool <IsInline>k__BackingField;
    public bool IsInline { get; }
    public CppNamespaceLinkageEntity(CppQualifiedNamePart name, ICppLinkageEntity parent, bool isInline);
    private static CppNamespaceLinkageEntity();
    [CompilerGeneratedAttribute]
public bool get_IsInline();
    public virtual Result Accept(ICppLinkageEntityVisitor`1<Result> visitor);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNamespaceModuleEntity : object {
    public Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppNamespaceModuleEntityChild>> Children;
    public CppNamespaceModuleEntity[] UsingDirectives;
    public CppNestedNamespaceModuleEntity[] InlineNamespaces;
    protected static int BaseSerializedSize;
    public void AddChild(ICppNamespaceModuleEntityChild child);
    public void AddChild(ICppNamespaceModuleEntityChild child, CppQualifiedNamePart name);
    public sealed virtual CppImportResult`1<ICppScopeResolveEntity> ImportScopeAutoParent(CppModuleImportingContext ctx);
    public sealed virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public abstract virtual bool IsInline();
    [CompilerGeneratedAttribute]
internal static CppQualifiedNamePart <AddChild>g__NamespaceChildName|3_0(CppQualifiedNamePart name);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNamespacePendingActions : object {
    private Dictionary`2<CppQualifiedNamePart, CppUnmergedActions> myActions;
    private ICppResolveEntity myScope;
    public CppNamespacePendingActions(ICppResolveEntity scope, Dictionary`2<CppQualifiedNamePart, CppUnmergedActions> actionsMap);
    public void AddAction(ICppFileResolveEntitiesCache cache, CppQualifiedNamePart name, ICppPendingMergingAction action);
    public void MergeActionsUpTo(ICppFileResolveEntitiesCache cache, CppQualifiedNamePart name, CppLocationAnchor anchor);
    public bool HasPendingActions(CppQualifiedNamePart name, CppLocationAnchor anchor);
    public bool HasPendingNonTemplateClassWithTag(CppQualifiedNamePart name, CppLocationAnchor anchor, CppClassTag tag);
    public void MergeAllActions(ICppFileResolveEntitiesCache resolveCache);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNamespaceQualifierSymbol : CppScopeSymbol {
    private bool myInline;
    private bool myExported;
    public CppNamespaceQualifierSymbol(CppQualifiedName name, CppSymbolLocation loc, bool inline_, bool exported);
    public sealed virtual bool IsInline();
    public sealed virtual bool IsExported();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNamespaceResolveEntity : CppScopeResolveEntityBase {
    private CppNamespacePendingActions myPendingActions;
    private CppAttributeList myAttributes;
    private CppList`1<ICppClassResolveEntity> myClassesWithAnonymousName;
    private CppList`1<CppNamespaceResolveEntity> myInlineNamespaces;
    private CppList`1<CppPartDescription> myParts;
    private CppList`1<ICppUsingDirectiveObject> myUsingDirectives;
    private CppGGDeclareHungarianDirectiveContainer modreq(System.Runtime.CompilerServices.IsVolatile) myGGDeclareHungarianDirectiveContainer;
    private CppList`1<ModulePart> myModuleParts;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor[] SymbolAnchors { get; }
    public CppAttributeList Attributes { get; }
    public CppNamespaceResolveEntity(ICppScopeResolveEntity parentScope, CppQualifiedNamePart name, CppLocationAnchor anchor, Dictionary`2<CppQualifiedNamePart, CppUnmergedActions> actionsMap);
    [CompilerGeneratedAttribute]
public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public CppLocationAnchor[] get_SymbolAnchors();
    public CppAttributeList get_Attributes();
    public virtual void AddUsingDirective(ICppUsingDirectiveObject obj);
    public virtual CppList`1<ICppUsingDirectiveObject> GetUsingDirectives();
    public virtual CppNamespaceResolveEntity GetTarget();
    public virtual bool ShouldDump();
    public void Dump(CppIndentationStringBuilder tw);
    private static void DumpUsingDirectiveObject(CppIndentationStringBuilder tw, ICppUsingDirectiveObject iobj);
    public void AddSymbolPart(ICppNamespaceSymbolOrModuleEntity sym, CppLocationAnchor anchor, CppAttributeList attributes);
    public void AddModulePart(CppNamespaceModuleEntity moduleEntity, CppModuleImportingContext ctx);
    private ISet`1<CppNamespaceResolveEntity> ImportAndDeduplicateWithExistingUsingDirectives(CppNamespaceModuleEntity[] sourceUsingDirectives, CppModuleImportingContext ctx);
    public CppList`1<CppNamespaceResolveEntity> GetInlineNamespaces();
    public virtual bool IsInline();
    public virtual CppList`1<ICppResolveEntity> GetChildren();
    public sealed virtual CppSmallList`1<ICppResolveEntity> ChildByName(CppQualifiedNamePart name, CppLocationAnchor anchor);
    public virtual CppSmallList`1<ICppResolveEntity> ChildByName(CppQualifiedNamePart name, CppLocationAnchor anchor, bool includeReachableButNotVisibleClasses);
    public CppSmallList`1<ICppResolveEntity> ImportModuleEntities(CppQualifiedNamePart name, CppLocationAnchor anchor, bool includeReachableButNotVisibleClasses);
    public void ImportAllClassSpecializations(CppQualifiedNamePart name, CppLocationAnchor anchor, ICppRootFileResolveEntitiesCache resolveCache);
    private void ImportModuleEntities(CppQualifiedNamePart name, CppSmallList`1<ICppNamespaceModuleEntityChild> moduleEntities, ModulePart part, bool importReachableButNotVisibleClasses, CppSmallList`1& result);
    private void ImportNamespaceChild(ICppNamespaceModuleEntityChild child, CppModuleImportingContext importingContext);
    private void ImportNonExportedClass(ICppModuleEntity moduleEntity, CppSmallList`1& result, CppModuleImportingContext ctx);
    private void ImportAllClassSpecializations(CppQualifiedNamePart name, CppSmallList`1<ICppNamespaceModuleEntityChild> moduleEntities, ICppRootFileResolveEntitiesCache resolveCache, CppModuleImportingContext importingContext, HashSet`1<CppQualifiedNamePart> alreadyImported);
    private void ImportImplicitlyExportedClassSpecialization(ICppModuleEntity moduleEntity, CppModuleImportingContext importingContext);
    private static bool ShouldBeImported(ICppNamespaceModuleEntityChild child, ICppRootFileResolveEntitiesCache resolveCache, CppModuleImportMode mode);
    public CppSmallList`1<ICppResolveEntity> GetExistingChildByName(CppQualifiedNamePart name);
    public CppPendingActionActivator AddPendingAction(ICppFileResolveEntitiesCache cache, CppQualifiedNamePart name, ICppPendingMergingAction action);
    public CppPendingActionWithResultActivator`1<TResult> AddPendingActionWithResult(ICppFileResolveEntitiesCache cache, CppQualifiedNamePart name, ICppPendingActionWithResult`1<TResult> action);
    public void MergePendingActionsUpTo(CppQualifiedNamePart name, CppLocationAnchor anchor);
    public bool HasPendingActions(CppQualifiedNamePart name, CppLocationAnchor anchor);
    public bool HasPendingNonTemplateClassWithTag(CppQualifiedNamePart name, CppLocationAnchor anchor, CppClassTag tag);
    public CppGGDeclareHungarianDirectiveContainer GetGGDeclareHungarianContrainer();
    public void AddGGDeclareHungarianDirective(CppGGDeclareHungarianSymbol symbol, CppQualType replacedType, CppLocationAnchor anchor);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public void Journaling_RollbackSymbol();
    public void Journaling_RollbackUsingDirective();
    public void Journaling_RollbackChildClassWithAnonymousName();
    public int PartCount();
    public CppList`1<ModulePart> GetModuleParts();
    public void Journaling_RollbackAttributes(int attributesCount);
    public void AddChildClassWithAnonymousName(ICppClassResolveEntity clazz);
    public CppList`1<ICppClassResolveEntity> GetChildClassesWithAnonymousName();
    public virtual string ToString();
    private void AddInlineNamespace(CppNamespaceResolveEntity ns);
    private void RollbackInlineNamespace(CppNamespaceResolveEntity ns);
    public void ForceModuleImport__FOR_TESTS__();
    [CompilerGeneratedAttribute]
internal static ICppResolveEntity <ImportNonExportedClass>g__GetClassOrTemplatePack|36_0(ICppClassResolveEntity clazz);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNamespaceSymbol : CppScopeSymbol {
    private bool myInline;
    private bool myNamespaceContextSymbol;
    private CppAttributeList myAttributes;
    private CppComplexOffset myBodyEndOffset;
    private CppComplexOffset myBodyStartOffset;
    private bool myExported;
    public CppNamespaceSymbol(CppQualifiedName name, CppSymbolLocation loc, bool inline_, bool exported, bool namespaceContextSymbol, CppAttributeList attributes);
    public sealed virtual bool IsInline();
    public sealed virtual bool IsExported();
    public sealed virtual void SetBodyStartOffset(CppComplexOffset endOffset);
    public sealed virtual CppComplexOffset GetBodyStartOffset();
    public sealed virtual void SetBodyEndOffset(CppComplexOffset endOffset);
    public sealed virtual CppComplexOffset GetBodyEndOffset();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public bool IsNamespaceContextSymbol();
    public CppAttributeList GetAttributes();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNavigateIntoUtil : object {
    [ExtensionAttribute]
public static bool CanNavigateInto(ICppResolveEntity input);
    [ExtensionAttribute]
public static ICppScopeLikeResolveEntity NavigateInto(ICppResolveEntity input, CppViewPos& viewPos);
    [CanBeNullAttribute]
public static CppNamespaceResolveEntity NavigateIntoNamespace(ICppResolveEntity input, CppViewPos& viewPos);
    private static ICppTypeTemplateResolveEntity GetTemplatePackForNavigateIntoErrorRecovery(ICppResolveEntity input);
    private static ICppScopeLikeResolveEntity NavigateIntoImpl(ICppResolveEntity input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNestedClassOrEnumModuleEntity : object {
    public ICppScopeModuleEntity Parent;
    public ICppClassOrRefClassModuleEntity Inner;
    public CppNestedClassOrEnumModuleEntity(ICppScopeModuleEntity parent, ICppClassOrRefClassModuleEntity inner);
    public sealed virtual ICppScopeModuleEntity GetParent();
    public sealed virtual CppClassModuleEntityKind GetKind();
    public sealed virtual bool IsExplicitlyExported();
    public sealed virtual CppImportResult`1<ICppClassResolveEntity> Import(CppModuleImportingContext ctx, ICppScopeResolveEntity targetParent, bool onlyFindExisting, bool addToParentScope);
    public sealed virtual CppImportResult`1<ICppScopeResolveEntity> ImportScopeAutoParent(CppModuleImportingContext ctx);
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNestedFileResolveEntitiesCache : object {
    private ICppFileResolveEntitiesCache myBase;
    private int myCurrent;
    [CompilerGeneratedAttribute]
private CppModuleId <CurrentModule>k__BackingField;
    public CppPPLocationAnchor CurrentPPAnchor { get; }
    public CppLocationAnchor CurrentAnchor { get; }
    public ICppRootFileResolveEntitiesCache RootCache { get; }
    public CppResolveMutex ResolveMutex { get; }
    public ICppResolvedTypeFactory TypeFactory { get; }
    public ICppResolvedTypeFactory VerboseTypeFactory { get; }
    public ICppResolvedTypeFactory VerboseNormalizingTypeFactory { get; }
    public CppRootInclusionContext InclusionContext { get; }
    public CppGlobalNamespaceResolveEntity GlobalNamespace { get; }
    public CppModuleId CurrentModule { get; }
    public bool AllowPendingActions { get; }
    public CppNestedFileResolveEntitiesCache(ICppFileResolveEntitiesCache base, CppLocationAnchor start, string moduleName);
    public sealed virtual void AddTemplateParametersMapping(ICppResolveEntity ent, Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> mapping);
    public sealed virtual Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> GetTemplateParametersMapping(ICppResolveEntity ent);
    public sealed virtual CppLocationAnchor IncrementCurrentAnchor(int delta);
    public sealed virtual CppLocationAnchor IncrementCurrentAnchor();
    public sealed virtual CppPPLocationAnchor IncrementCurrentPPAnchor();
    public sealed virtual CppPPLocationAnchor get_CurrentPPAnchor();
    public sealed virtual CppLocationAnchor get_CurrentAnchor();
    public sealed virtual ICppRootFileResolveEntitiesCache get_RootCache();
    public sealed virtual CppResolveMutex get_ResolveMutex();
    public sealed virtual ICppResolvedTypeFactory get_TypeFactory();
    public sealed virtual ICppResolvedTypeFactory get_VerboseTypeFactory();
    public sealed virtual ICppResolvedTypeFactory get_VerboseNormalizingTypeFactory();
    public sealed virtual CppRootInclusionContext get_InclusionContext();
    public sealed virtual CppGlobalNamespaceResolveEntity get_GlobalNamespace();
    public sealed virtual CppLanguageDialect GetDialect();
    [CompilerGeneratedAttribute]
public sealed virtual CppModuleId get_CurrentModule();
    public sealed virtual bool get_AllowPendingActions();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNestedNamespaceModuleEntity : CppNamespaceModuleEntity {
    public CppNamespaceModuleEntity Parent;
    public CppQualifiedNamePart Name;
    private bool myIsInline;
    public CppNestedNamespaceModuleEntity(CppNamespaceModuleEntity parent, CppQualifiedNamePart name, bool isInline);
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual ICppScopeModuleEntity GetParent();
    public sealed virtual bool IsExplicitlyExported();
    public virtual bool IsInline();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNewExpressionBuilder : ValueType {
    private bool myIsGCNew;
    private bool myIsFromGlobalNamespace;
    private CppQualType myType;
    private ICppArgumentList myOperatorArgumentList;
    private ICppArgumentList myConstructorArgumentList;
    public sealed virtual void LearnIsCliGCNew(bool gcn);
    public sealed virtual void LearnIsFromGlobalNamespace(bool isFromGlobalNamespace);
    public sealed virtual void LearnType(ICppDeclarationBuilder declBuilder);
    public sealed virtual void LearnOperatorArguments(CppFunctionArgumentListBuilder& funcArgList);
    public sealed virtual void LearnConstructorArguments(CppFunctionArgumentListBuilder& funcArgListBuilder);
    public sealed virtual void LearnBracedArguments(CppFunctionArgumentListBuilder& funcArgListBuilder);
    public bool IsCliGCNew();
    public bool IsFromGlobalNamespace();
    public CppQualType GetQualType();
    public ICppArgumentList GetOperatorArgumentList();
    public ICppArgumentList GetConstructorArgumentList();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNormalDeclaration0Builder : CppDeclaration0Builder {
    public CppNormalDeclaration0Builder(ICppBuilder parent, CppSymbolLocation loc, CppBuilderPool pool);
    public virtual ICppConceptDefinitionBuilder NewConceptDefinitionBuilder();
    protected virtual ICppDeclaratorBuilder NewDeclaratorBuilderImpl();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNormalDeclarator0Builder : CppDeclarator0Builder`2<CppDeclaratorSymbol, CppDeclaratorResolveEntityBase> {
    private bool myIsUsedInDeferredParsing;
    public CppNormalDeclarator0Builder(CppNormalDeclaration0Builder parent);
    public void Init(CppNormalDeclaration0Builder parent);
    public void Clear();
    public virtual void SetUsedInDeferredParsing();
    public bool IsUsedInDeferredParsing();
    public virtual void LearnFunctionBody(CppFunctionBodyBuilder builder);
    public virtual void LearnFunctionBody(CppDeclarationTrailingKind trailingKind);
    public virtual void LearnClosedBodyChameleon();
    public virtual void LearnCtorBlockWithoutBody();
    public virtual ICppBuilder CreateInitDeclaratorBuilder();
    public virtual void ComposeSymbolType(CppSymbolLocation loc);
    public virtual void LearnInitializer(KIND kind, CppSmallArray`1<ICppExpression> unresolvedArguments, CppSmallArray`1<ICppExpression> replacedArguments);
    private bool TryToShrinkBracedInitList(CppSmallArray`1<ICppExpression> unresolvedArguments, CppSmallArray`1<ICppExpression> replacedArguments, ICppExpression& newUnresolvedInitializer, ICppExpression& newReplacedInitializer);
    private bool IsArrayOfNumbers(CppQualType unresolvedType);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNullAttributeListBuilder : object {
    public static ICppAttributeListBuilder Instance;
    private static CppNullAttributeListBuilder();
    public sealed virtual void LearnAttribute(CppAttributeName name, ICppAttributeArgumentsBuilder builder);
    public sealed virtual void LearnAttribute(ICppAttribute unresolved, ICppAttribute replaced);
    public sealed virtual void LearnAttributeConstant(ICppAttribute _);
    public sealed virtual void Merge(ICppAttributeListBuilder _);
    public sealed virtual void Merge(CppAttributeList unresolved, CppAttributeList replaced);
    public sealed virtual CppAttributeList GetUnresolvedList();
    public sealed virtual CppAttributeList GetReplacedList();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNullCallingConventionBuilder : object {
    public static ICppCallingConventionBuilder Instance;
    private static CppNullCallingConventionBuilder();
    public sealed virtual void LearnCallingConvention(CppCallingConvention cc);
    public sealed virtual CppCallingConvention GetCallingConvention();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNullClassBaseClauseBuilder : object {
    private ICppBuilder myParent;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public CppNullClassBaseClauseBuilder(ICppBuilder parent);
    public sealed virtual void AddChild(CppParserSymbol sym);
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    public sealed virtual void LearnSpecifier(TokenNodeType tt);
    public sealed virtual void BaseType(CppNullQualifiedNameBuilder& name, bool expansion);
    public sealed virtual CppNullQualifiedNameBuilder CreateQualifiedNameBuilder();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNullConceptDefinitionBuilder : object {
    private ICppDeclarationBuilder myParent;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public CppConceptDefinitionSymbol Symbol { get; }
    public bool HasSymbol { get; }
    public CppNullConceptDefinitionBuilder(CppNullDeclarationBuilder parent);
    public CppNullConceptDefinitionBuilder(CppAbstractDeclarationBuilder parent);
    public sealed virtual void AddChild(CppParserSymbol _);
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    public sealed virtual ICppDeclarationBuilder GetDeclarationBuilder();
    public sealed virtual void LearnLocation(CppSymbolLocation _);
    public void LearnQualifiedName(CppTwinQualifiedNameBuilder& _);
    public sealed virtual void ComposeSymbol(CppSymbolLocation _);
    public sealed virtual void LearnExpression(CppTwinExpressionBuilder& _);
    public sealed virtual CppConceptDefinitionSymbol get_Symbol();
    public sealed virtual bool get_HasSymbol();
    private sealed virtual override void JetBrains.ReSharper.Psi.Cpp.Symbols.ICppConceptDefinitionBuilder.LearnQualifiedName(CppTwinQualifiedNameBuilder& modreq(System.Runtime.InteropServices.InAttribute) _);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNullConceptParameterBuilder : CppForwardingBuilder {
    public CppNullConceptParameterBuilder(CppNullTemplateHeaderBuilder parentBuilder);
    public sealed virtual void LearnLocation(CppSymbolLocation _);
    public sealed virtual void LearnConceptName(CppTwinQualifiedNameBuilder nameBuilder);
    public sealed virtual void LearnEllipsis();
    public sealed virtual void LearnName(string _);
    public sealed virtual bool LearnConcept(CppConceptDefinitionResolveEntity reference);
    public sealed virtual void LearnDefaultTypeArgument(ICppDeclarationBuilder _);
    public sealed virtual ICppTemplateParameterSymbol GetSymbol();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNullDeclarationBuilder : CppForwardingBuilder {
    private CppDeclarationSpecifiers myDeclSpecifiers;
    private bool myNeedTypename;
    private bool myCreateParameters;
    private CppBuilderPool myPool;
    public ICppDeclaratorBuilder LastDeclaratorBuilder { get; }
    public ICppAttributeListBuilder AttributeListBuilder { get; }
    public CppClassBuilder ClassBuilder { get; }
    public CppNullDeclarationBuilder(ICppBuilder parent, bool needTypename, bool createParameters);
    public CppNullDeclarationBuilder(ICppBuilder parent, bool needTypename, bool createParameters, CppBuilderPool pool);
    public void Init(ICppBuilder parent, bool needTypename, bool createParameters);
    public sealed virtual CppTemplateDeclarationBuilder TemplateDeclarationBuilder();
    public sealed virtual ICppDeclaratorBuilder get_LastDeclaratorBuilder();
    public sealed virtual ICppAttributeListBuilder get_AttributeListBuilder();
    public sealed virtual ICppUnresolvedDeclarationSpecifierTypeBuilder GetUnresolvedSpecifierTypeBuilder();
    public sealed virtual ICppResolvedDeclarationSpecifierTypeBuilder GetReplacedSpecifierTypeBuilder();
    public sealed virtual ICppAttributeListBuilder CreateAttributesBuilder();
    public sealed virtual ICppCallingConventionBuilder CreateCallingConventionBuilder();
    public sealed virtual ICppStructuredBindingDeclarationBuilder CreateStructuredBindingBuilder();
    public sealed virtual CppClassBuilder get_ClassBuilder();
    public sealed virtual void LearnSpecifier(TokenNodeType tt);
    public sealed virtual void LearnDeclspecProperty();
    public sealed virtual void LearnDecltypeAuto();
    public sealed virtual void LearnAttributes(ICppAttributeListBuilder _);
    public sealed virtual void LearnCallingConvention(ICppCallingConventionBuilder ccBuilder);
    public sealed virtual void ApplyImplicitIntType();
    public sealed virtual bool IsStandalone();
    public sealed virtual bool HasImplicitIntType();
    public sealed virtual CppDeclarationSpecifiers GetSpecifiers();
    public sealed virtual void LearnClassSpecifier(CppClassBuilder classBuilder);
    public sealed virtual ICppDeclaratorBuilder NewDeclaratorBuilder();
    public sealed virtual ICppConceptDefinitionBuilder NewConceptDefinitionBuilder();
    public sealed virtual bool NeedTypename();
    public sealed virtual void FinishDeclaration();
    public bool GetCreateParameters();
    public sealed virtual void LearnExplicitSpecifier();
    public sealed virtual void LearnExplicitSpecifier(CppTwinExpressionBuilder& exprBuilder);
    public sealed virtual void LearnExport();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNullDeclaratorBuilder : object {
    private CppNullDeclarationBuilder myParent;
    private ICppUnresolvedTypeBuilder myUnresolvedTypeBuilder;
    private ICppResolvedTypeBuilder myReplacedTypeBuilder;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public ICppDeclaratorSymbol Symbol { get; }
    public bool HasSymbol { get; }
    public bool IsParameterPackDeclarator { get; }
    public CppNullDeclaratorBuilder(CppNullDeclarationBuilder parent);
    public sealed virtual ICppDeclaratorBuilder GetDeclaratorBuilder();
    public sealed virtual ICppDeclarationBuilder GetDeclarationBuilder();
    public ICppBuilder CreateInitDeclaratorBuilder();
    public sealed virtual ICppAttributeListBuilder CreateAttributesBuilder();
    public sealed virtual ICppCallingConventionBuilder CreateCallingConventionBuilder();
    public sealed virtual ICppUnresolvedTypeBuilder GetUnresolvedTypeBuilder();
    public sealed virtual ICppResolvedTypeBuilder GetReplacedTypeBuilder();
    public sealed virtual void ComposeSymbolType(CppSymbolLocation _);
    public sealed virtual void LearnLocation(CppSymbolLocation location);
    public void LearnNavigationOffset(CppComplexOffset offset);
    public void LearnQualifiedName(CppTwinQualifiedNameBuilder& _);
    public sealed virtual void LearnQualifiedName(ICppStructuredBindingDeclarationBuilder _);
    public sealed virtual void LearnInitializer(KIND kind, CppSmallArray`1<ICppExpression> unresolvedArguments, CppSmallArray`1<ICppExpression> replacedArguments);
    public sealed virtual void LearnMainParameterList(ICppFunctionParameterListBuilder _);
    public sealed virtual ICppFunctionParameterListBuilder GetMainParameterListBuilder();
    public sealed virtual void LearnFunctionBody(CppDeclarationTrailingKind kind);
    public sealed virtual void LearnPureVirtualSpecifier(CppPureVirtualSpecifiers _);
    public sealed virtual ICppFunctionParameterListBuilder CreateParameterListBuilder();
    public sealed virtual void LearnEllipsis();
    public sealed virtual void LearnAttributes(ICppAttributeListBuilder _);
    public sealed virtual void LearnNoAttributes();
    public sealed virtual void LearnBitfieldSize(ICppExpression unresolvedSize, ICppExpression replacedSize);
    public sealed virtual void AddChild(CppParserSymbol _);
    public void LearnCxxCliOverrideSpecifier(CppTwinQualifiedNameBuilder& _);
    public sealed virtual void LearnRequiresClause(ICppExpression unresolved, ICppExpression replaced);
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    public sealed virtual ICppDeclaratorSymbol get_Symbol();
    public sealed virtual bool get_HasSymbol();
    public sealed virtual bool get_IsParameterPackDeclarator();
    private sealed virtual override void JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorBuilder.LearnQualifiedName(CppTwinQualifiedNameBuilder& modreq(System.Runtime.InteropServices.InAttribute) _);
    private sealed virtual override void JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorBuilder.LearnCxxCliOverrideSpecifier(CppTwinQualifiedNameBuilder& modreq(System.Runtime.InteropServices.InAttribute) _);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNullExceptionSpecificationBuilder : object {
    public static CppNullExceptionSpecificationBuilder Instance;
    private static CppNullExceptionSpecificationBuilder();
    public sealed virtual void LearnThrowAnySpecification();
    public sealed virtual void LearnNoExceptSpecification();
    public sealed virtual void LearnNoExceptSpecification(CppTwinExpressionBuilder& exprBuilder);
    public sealed virtual ICppDeclarationBuilder CreateDeclarationBuilderForDynamicExceptionSpecification(ICppBuilder parent, bool isDetectionMode);
    public sealed virtual void LearnDynamicExceptionSpecification();
    public sealed virtual void LearnDynamicExceptionSpecificationElement(ICppDeclarationBuilder _, bool isPackExpansion);
    public sealed virtual ICppExceptionSpecification GetUnresolvedExceptionSpecification();
    public sealed virtual ICppExceptionSpecification GetReplacedExceptionSpecification();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNullFileSymbolsCache : object {
    public static CppNullFileSymbolsCache Instance;
    public ICppBuilder RootBuilder { get; }
    public CppNamespaceSymbol GlobalNamespaceSymbol { get; }
    public ICppFileResolveEntitiesCache ResolveCache { get; }
    public CppFileLocation BaseFile { get; }
    public List`1<ICppSymbol> PreprocessorSymbols { get; public set; }
    public Nullable`1<UInt32> PragmaPackForChameleon { get; }
    private static CppNullFileSymbolsCache();
    public sealed virtual ICppBuilder get_RootBuilder();
    public CppNamespaceSymbol get_GlobalNamespaceSymbol();
    public sealed virtual ICppFileResolveEntitiesCache get_ResolveCache();
    public sealed virtual CppFileLocation get_BaseFile();
    public sealed virtual List`1<ICppSymbol> get_PreprocessorSymbols();
    public sealed virtual void set_PreprocessorSymbols(List`1<ICppSymbol> value);
    public sealed virtual void SetDetectionMode(bool value);
    public sealed virtual void RegisterPreprocessorSnapshot(CppComplexOffset o, CppInclusionContextSnapshot _);
    public sealed virtual void RegisterCacheSnapshot(CppComplexOffset o);
    public sealed virtual void RegisterAndIncrementAnchorForIncludeDirective(CppComplexOffset offset, bool localInclude);
    public sealed virtual ICppSymbol IgnorePPSymbol(CppComplexOffset offset);
    public CppLocationAnchor GetCurrentAnchor();
    public IEnumerable`1<ICppSymbol> GetSymbols();
    public sealed virtual bool HasCacheSnapshot();
    public sealed virtual Nullable`1<UInt32> get_PragmaPackForChameleon();
    public sealed virtual CppSymbolTypeIntern GetTypeIntern();
    public IEnumerable`1<ICppSymbol> GetFileSymbols();
    public sealed virtual void DisablePsiMode();
    public void CheckInvariant();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNullParameterListBuilder : CppForwardingBuilder {
    public CppNullParameterListBuilder(ICppBuilder parentBuilder);
    public void Finish();
    public sealed virtual void LearnExplicitThis();
    public sealed virtual void LearnEllipsis(CppEllipsisKind _);
    public sealed virtual void LearnRestrictionSpecifier(CppRestrictionSpecifiers _);
    public sealed virtual void LearnAutoParameter(ICppTypeTemplateParameterOrPack param);
    public sealed virtual ICppDeclarationBuilder CreateDeclarationBuilderForParameter(CppBuilderPool _);
    public sealed virtual void LearnParameter(ICppDeclarationBuilder _);
    public sealed virtual void LearnEndAnchor();
    public sealed virtual void LearnKnRStyleParamsStart();
    public sealed virtual CppEllipsisKind GetEllipsisKind();
    public sealed virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public sealed virtual CppParameterListResolveEntity GetResolveEntity();
    public sealed virtual CppList`1<CppParameterDeclaratorSymbol> GetParameterSymbols();
    public sealed virtual ICppDeclarationBuilder CreateDeclarationBuilderForTrailingReturnType();
    public sealed virtual void LearnTrailingReturnStartAnchor();
    public sealed virtual void LearnTrailingReturnType(ICppDeclarationBuilder _);
    public sealed virtual CppQualType GetUnresolvedTrailingReturnType();
    public sealed virtual CppQualType GetReplacedTrailingReturnType();
    public sealed virtual void LearnCVQualifier(TokenNodeType tt);
    public sealed virtual CVQualifiers GetFunctionCVQualifiers();
    public sealed virtual void LearnRefQualifier(TokenNodeType tt);
    public sealed virtual FuncRefQualifier GetFunctionRefQualifier();
    public sealed virtual ICppExceptionSpecificationBuilder CreateExceptionSpecificationBuilder(CppComplexOffset _);
    public sealed virtual void LearnExceptionSpecification(CppComplexOffset offset, ICppExceptionSpecificationBuilder builder);
    public sealed virtual ICppExceptionSpecification GetUnresolvedExceptionSpecification();
    public sealed virtual ICppExceptionSpecification GetReplacedExceptionSpecification();
    public sealed virtual bool HasOnlyParamsWithImplicitInt();
    public sealed virtual bool IsKnRParamListStarted();
    public sealed virtual void LearnMutable();
    public bool IsMutable();
    public sealed virtual void LearnConstexpr();
    public sealed virtual void LearnConsteval();
    public sealed virtual void LearnStatic();
    public sealed virtual void LearnIsMainParameterList(bool declaratorIsStatic);
    public CppTemplateParametersBase GetTemplateParameters();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNullQualifiedNameBuilder : ValueType {
    public sealed virtual void LearnId(string _);
    public sealed virtual void LearnAnonymousId();
    public sealed virtual void LearnDestructorTag(string _);
    public sealed virtual void LearnOperatorId(CppOperatorKind _);
    public sealed virtual void LearnConversionId(ICppDeclarationBuilder _);
    public sealed virtual void LearnUserDefinedLiteralId(string _);
    public sealed virtual ICppDeclarationBuilder CreateDeclarationBuilderForConversion(ICppBuilder parent);
    public sealed virtual void LearnDecltypeDestructorTag();
    public sealed virtual void LearnDecltype(CppExpressionBuilder exprBuilder, CppDecltypeKind kind);
    public sealed virtual void LearnDecltypeBoxed(ICppExpressionBuilder exprBuilder, CppDecltypeKind kind);
    public sealed virtual void LearnTypeOfType(ICppDeclarationBuilder _, CppDecltypeKind kind);
    public sealed virtual void LearnGlobalNamespaceId();
    public sealed virtual void LearnMSSuperId();
    public sealed virtual void LearnCliSimpleTypeId(CppQualType type);
    public sealed virtual void LearnCliFinalizerTag(string _);
    public sealed virtual void LearnTemplateArguments(CppNullTemplateArgumentsBuilder _);
    public sealed virtual void LearnTemplateArgumentsBoxed(ICppTemplateArgumentsBuilder builder);
    public CppQualifiedName GetRawName();
    public sealed virtual CppQualifiedName GetRawNameForLookup();
    public sealed virtual CppExpressionBuilder CreateExpressionBuilder(bool createSymbols);
    public sealed virtual ICppExpressionBuilder CreateExpressionBuilderBoxed(bool createSymbols);
    public sealed virtual CppNullTemplateArgumentsBuilder CreateTemplateArgumentsBuilder();
    public sealed virtual ICppTemplateArgumentsBuilder CreateTemplateArgumentsBuilderBoxed();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNullStringLiteralBuilder : ValueType {
    public sealed virtual void StartMsLPrefix();
    public sealed virtual void LearnStringLiteral(ITokenNode token);
    public void LearnFuncKeyword(CppFuncKeywordKind kind, CppViewPos& vp);
    public sealed virtual FrugalLocalList`1<string> GetStringParts();
    public sealed virtual string GetUserDefinedSuffix();
    public sealed virtual void LearnStringLiteralFromText(string text);
    private sealed virtual override void JetBrains.ReSharper.Psi.Cpp.Symbols.ICppStringLiteralBuilder.LearnFuncKeyword(CppFuncKeywordKind kind, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNullStructuredBindingBuilder : object {
    public static CppNullStructuredBindingBuilder Instance;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    private static CppNullStructuredBindingBuilder();
    public sealed virtual CppQualifiedNamePart CreateUnresolvedNamePart();
    public sealed virtual void AddChild(CppParserSymbol sym);
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    public sealed virtual CppStructuredBindingSymbol LearnId(string id, CppSymbolLocation location);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNullTemplateArgumentsBuilder : object {
    private static CppNullTemplateArgumentsBuilder INSTANCE;
    private static CppNullTemplateArgumentsBuilder();
    public static CppNullTemplateArgumentsBuilder Create();
    public sealed virtual ICppDeclarationBuilder CreateDeclarationBuilder(ICppBuilder parent, bool createParameters);
    public sealed virtual void LearnQualifiedReference(CppTwinQualifiedNameBuilder& builder, bool isPackExpansion, bool hadTypename);
    public sealed virtual void LearnTypeId(ICppDeclarationBuilder builder, bool isPackExpansion);
    public sealed virtual void LearnExpression(CppTwinExpressionBuilder& builder, bool isPackExpansion);
    public sealed virtual CppTwinExpressionBuilder CreateExpressionBuilder(bool createSymbols);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNullTemplateHeaderBuilder : CppForwardingBuilder {
    public CppNullTemplateHeaderBuilder(ICppBuilder parentBuilder);
    public sealed virtual CppNullTypeParameterBuilder CreateTypeParameterBuilder();
    public sealed virtual CppNullDeclarationBuilder CreateNonTypeParameterBuilder();
    public sealed virtual CppNullTemplateTemplateParameterBuilder CreateTemplateTemplateParameterBuilder();
    public sealed virtual CppNullConceptParameterBuilder CreateConceptParameterBuilder();
    public sealed virtual void LearnTypeParameter(CppNullTypeParameterBuilder _);
    public sealed virtual void LearnNonTypeParameter(CppNullDeclarationBuilder _);
    public sealed virtual void LearnTemplateTemplateParameter(CppNullTemplateTemplateParameterBuilder _);
    public sealed virtual void LearnGenericParameter(CppGenericParameterBuilder _);
    public sealed virtual void LearnConceptParameter(CppNullConceptParameterBuilder _);
    public sealed virtual void LearnRequiresClause(ICppExpression unresolved, ICppExpression replaced);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNullTemplateTemplateParameterBuilder : CppForwardingBuilder {
    public CppNullTemplateTemplateParameterBuilder(CppNullTemplateHeaderBuilder parentBuilder);
    public sealed virtual CppNullTemplateHeaderBuilder CreateTemplateHeaderBuilder();
    public sealed virtual void LearnTemplateHeader(CppNullTemplateHeaderBuilder _);
    public sealed virtual void LearnName(CppPsiBuilder _);
    public sealed virtual void LearnName(string _);
    public sealed virtual void LearnLocation(CppSymbolLocation _);
    public sealed virtual void LearnDefaultArgument(CppTwinQualifiedNameBuilder nameBuilder);
    public sealed virtual void LearnEllipsis();
    public sealed virtual ICppTemplateTemplateParameterSymbol GetSymbol();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppNullTypeParameterBuilder : CppForwardingBuilder {
    public CppNullTypeParameterBuilder(CppNullTemplateHeaderBuilder parentBuilder);
    public sealed virtual void LearnName(CppPsiBuilder _);
    public sealed virtual void LearnName(string _);
    public sealed virtual void LearnLocation(CppSymbolLocation _);
    public sealed virtual void LearnDefaultArgument(ICppDeclarationBuilder _);
    public sealed virtual void LearnKey(CppTypeTemplateParameterKey _);
    public sealed virtual void LearnEllipsis();
    public sealed virtual ICppTemplateParameterSymbol GetSymbol();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppOperatorId : object {
    public static CppOperatorId PLUS_OPERATOR_NAME;
    public static CppOperatorId MINUS_OPERATOR_NAME;
    public static CppOperatorId MUL_OPERATOR_NAME;
    public static CppOperatorId DIV_OPERATOR_NAME;
    public static CppOperatorId PERC_OPERATOR_NAME;
    public static CppOperatorId XOR_OPERATOR_NAME;
    public static CppOperatorId AND_OPERATOR_NAME;
    public static CppOperatorId OR_OPERATOR_NAME;
    public static CppOperatorId TILDE_OPERATOR_NAME;
    public static CppOperatorId EXCL_OPERATOR_NAME;
    public static CppOperatorId LT_OPERATOR_NAME;
    public static CppOperatorId GT_OPERATOR_NAME;
    public static CppOperatorId LTEQ_OPERATOR_NAME;
    public static CppOperatorId GTEQ_OPERATOR_NAME;
    public static CppOperatorId LTLT_OPERATOR_NAME;
    public static CppOperatorId GTGT_OPERATOR_NAME;
    public static CppOperatorId EQ_OPERATOR_NAME;
    public static CppOperatorId PLUSEQ_OPERATOR_NAME;
    public static CppOperatorId MINUSEQ_OPERATOR_NAME;
    public static CppOperatorId MULTEQ_OPERATOR_NAME;
    public static CppOperatorId DIVEQ_OPERATOR_NAME;
    public static CppOperatorId PERCEQ_OPERATOR_NAME;
    public static CppOperatorId XOREQ_OPERATOR_NAME;
    public static CppOperatorId ANDEQ_OPERATOR_NAME;
    public static CppOperatorId OREQ_OPERATOR_NAME;
    public static CppOperatorId GTGTEQ_OPERATOR_NAME;
    public static CppOperatorId LTLTEQ_OPERATOR_NAME;
    public static CppOperatorId EQEQ_OPERATOR_NAME;
    public static CppOperatorId EXCLEQ_OPERATOR_NAME;
    public static CppOperatorId ANDAND_OPERATOR_NAME;
    public static CppOperatorId OROR_OPERATOR_NAME;
    public static CppOperatorId PLUSPLUS_OPERATOR_NAME;
    public static CppOperatorId MINUSMINUS_OPERATOR_NAME;
    public static CppOperatorId COMMA_OPERATOR_NAME;
    public static CppOperatorId DEREFMUL_OPERATOR_NAME;
    public static CppOperatorId DEREF_OPERATOR_NAME;
    public static CppOperatorId NEW_OPERATOR_NAME;
    public static CppOperatorId DELETE_OPERATOR_NAME;
    public static CppOperatorId NEW_ARRAY_OPERATOR_NAME;
    public static CppOperatorId DELETE_ARRAY_OPERATOR_NAME;
    public static CppOperatorId PAREN_OPERATOR_NAME;
    public static CppOperatorId SUBSCRIPT_OPERATOR_NAME;
    public static CppOperatorId TERNARY_OPERATOR_NAME;
    public static CppOperatorId DOTMUL_OPERATOR_NAME;
    public static CppOperatorId CO_AWAIT_OPERATOR_NAME;
    public static CppOperatorId LTEQGT_OPERATOR_NAME;
    private CppOperatorKind myKind;
    private CppOperatorId(CppOperatorKind kind);
    private static CppOperatorId();
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public static CppOperatorId Create(CppOperatorKind kind);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
    public CppOperatorKind GetOperatorKind();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppOperatorKind : Enum {
    public int value__;
    public static CppOperatorKind PLUS;
    public static CppOperatorKind MINUS;
    public static CppOperatorKind MUL;
    public static CppOperatorKind DIV;
    public static CppOperatorKind PERC;
    public static CppOperatorKind XOR;
    public static CppOperatorKind AND;
    public static CppOperatorKind OR;
    public static CppOperatorKind TILDE;
    public static CppOperatorKind EXCL;
    public static CppOperatorKind LT;
    public static CppOperatorKind GT;
    public static CppOperatorKind LTEQ;
    public static CppOperatorKind GTEQ;
    public static CppOperatorKind LTLT;
    public static CppOperatorKind GTGT;
    public static CppOperatorKind LTEQGT;
    public static CppOperatorKind EQ;
    public static CppOperatorKind PLUSEQ;
    public static CppOperatorKind MINUSEQ;
    public static CppOperatorKind MULTEQ;
    public static CppOperatorKind DIVEQ;
    public static CppOperatorKind PERCEQ;
    public static CppOperatorKind XOREQ;
    public static CppOperatorKind ANDEQ;
    public static CppOperatorKind OREQ;
    public static CppOperatorKind GTGTEQ;
    public static CppOperatorKind LTLTEQ;
    public static CppOperatorKind EQEQ;
    public static CppOperatorKind EXCLEQ;
    public static CppOperatorKind ANDAND;
    public static CppOperatorKind OROR;
    public static CppOperatorKind PLUSPLUS;
    public static CppOperatorKind MINUSMINUS;
    public static CppOperatorKind COMMA;
    public static CppOperatorKind DEREFMUL;
    public static CppOperatorKind DEREF;
    public static CppOperatorKind NEW;
    public static CppOperatorKind DELETE;
    public static CppOperatorKind NEW_ARRAY;
    public static CppOperatorKind DELETE_ARRAY;
    public static CppOperatorKind PAREN;
    public static CppOperatorKind SUBSCRIPT;
    public static CppOperatorKind TERNARY;
    public static CppOperatorKind DOTMUL;
    public static CppOperatorKind CO_AWAIT;
    public static CppOperatorKind OPERATORS_COUNT;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppOperatorKindUtil : object {
    private static String[] ourReprArray;
    private static CppOperatorKindUtil();
    public static CppOperatorKind FromTokenType(TokenNodeType tok);
    [ExtensionAttribute]
public static CppOperatorKind FromCompoundAssignmentOpToBinaryOp(CppOperatorKind kind);
    [ExtensionAttribute]
public static CppOperatorKind FromBinaryOpToCompoundAssignmentOp(CppOperatorKind kind);
    [ExtensionAttribute]
public static string GetRepresentation(CppOperatorKind kind);
    [ExtensionAttribute]
public static bool IsBinaryOpWithAssignmentVersion(CppOperatorKind kind);
    [ExtensionAttribute]
public static bool IsBinaryAssignmentOp(CppOperatorKind kind);
    [ExtensionAttribute]
public static bool IsBinaryComparisonOp(CppOperatorKind kind);
    [ExtensionAttribute]
public static bool IsRelationalOp(CppOperatorKind kind);
    [ExtensionAttribute]
public static bool IsBinaryEqualityOp(CppOperatorKind kind);
    [ExtensionAttribute]
public static bool IsBinaryLazyLogicalOp(CppOperatorKind kind);
    [ExtensionAttribute]
public static bool IsMemberDereferenceOp(CppOperatorKind kind);
    [ExtensionAttribute]
public static bool IsIncrementOrDecrement(CppOperatorKind kind);
    [ExtensionAttribute]
public static bool IsMutatingBuiltinOp(CppOperatorKind kind);
    [ExtensionAttribute]
public static CppOperatorKind FlipBinaryComparisonOp(CppOperatorKind kind);
    [ExtensionAttribute]
public static bool IsNewOp(CppOperatorKind kind);
    [ExtensionAttribute]
public static bool IsDeleteOp(CppOperatorKind kind);
    [ExtensionAttribute]
public static bool IsFoldableOperator(CppOperatorKind kind);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppOutputBinaryStream : object {
    public Byte[] RawData;
    private int myElemsCount;
    public int EntrySize;
    public CppOutputBinaryStream(int entrySize);
    public int Count();
    public int AllocateNew();
    public void Expand(int n);
    public int UsedBytesCount();
    public void Dump(UnsafeWriter writer);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppParameterDeclarationBuilder : CppForwardingBuilder {
    private CppParameterDeclaratorBuilder myLastDeclaratorBuilder;
    private CppUnresolvedDeclarationSpecifierTypeBuilder myUnresolvedSpecifierTypeBuilder;
    private CppResolvedDeclarationSpecifierTypeBuilder myReplacedSpecifierTypeBuilder;
    private CppClassBuilder myClassBuilder;
    private CppDeclarationSpecifiers myDeclSpecifiers;
    private ICppAttributeListBuilder myAttributesBuilder;
    private CppBuilderPool myPool;
    private bool myHasImplicitIntType;
    private bool myLastDeclaratorBuilderInitialized;
    public ICppDeclaratorBuilder LastDeclaratorBuilder { get; }
    public CppClassBuilder ClassBuilder { get; }
    public ICppAttributeListBuilder AttributeListBuilder { get; }
    public CppParameterDeclarationBuilder(ICppParameterListBuilder parent, CppBuilderPool pool);
    public void Init(ICppParameterListBuilder parent);
    public void Clear();
    public sealed virtual CppTemplateDeclarationBuilder TemplateDeclarationBuilder();
    public sealed virtual ICppDeclaratorBuilder get_LastDeclaratorBuilder();
    public sealed virtual void LearnSpecifier(TokenNodeType tt);
    public sealed virtual void LearnDeclspecProperty();
    public sealed virtual void LearnDecltypeAuto();
    public sealed virtual void LearnAttributes(ICppAttributeListBuilder attributesBuilder);
    public sealed virtual void LearnCallingConvention(ICppCallingConventionBuilder ccBuilder);
    public sealed virtual void LearnClassSpecifier(CppClassBuilder classBuilder);
    public sealed virtual void ApplyImplicitIntType();
    public sealed virtual bool IsStandalone();
    public sealed virtual bool HasImplicitIntType();
    public sealed virtual CppDeclarationSpecifiers GetSpecifiers();
    public sealed virtual ICppUnresolvedDeclarationSpecifierTypeBuilder GetUnresolvedSpecifierTypeBuilder();
    public sealed virtual ICppResolvedDeclarationSpecifierTypeBuilder GetReplacedSpecifierTypeBuilder();
    public sealed virtual ICppAttributeListBuilder CreateAttributesBuilder();
    public sealed virtual ICppCallingConventionBuilder CreateCallingConventionBuilder();
    public sealed virtual ICppStructuredBindingDeclarationBuilder CreateStructuredBindingBuilder();
    public sealed virtual CppClassBuilder get_ClassBuilder();
    public sealed virtual ICppAttributeListBuilder get_AttributeListBuilder();
    public sealed virtual ICppDeclaratorBuilder NewDeclaratorBuilder();
    public sealed virtual ICppConceptDefinitionBuilder NewConceptDefinitionBuilder();
    public sealed virtual bool NeedTypename();
    public sealed virtual void FinishDeclaration();
    public sealed virtual void LearnExplicitSpecifier();
    public sealed virtual void LearnExplicitSpecifier(CppTwinExpressionBuilder& exprBuilder);
    public sealed virtual void LearnExport();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppParameterDeclaratorBuilder : object {
    private CppParameterDeclarationBuilder myParent;
    private CppUnresolvedTypeBuilder myUnresolvedTypeBuilder;
    private CppResolvedTypeBuilder myReplacedTypeBuilder;
    private CppSymbolLocation myLocation;
    private CppQualifiedNamePart myUnresolvedName;
    private CppQualifiedNamePart myReplacedName;
    private CppParameterDeclaratorSymbol myScopeSym;
    private ICppVariableDeclaratorResolveEntity myResolveEnt;
    private CppAttributeList myUnresolvedAttributes;
    private CppAttributeList myReplacedAttributes;
    private bool myParameterPack;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public ICppDeclaratorSymbol Symbol { get; }
    public bool HasSymbol { get; }
    public bool IsParameterPackDeclarator { get; }
    public CppParameterDeclaratorBuilder(CppParameterDeclarationBuilder parent);
    public void Init(CppParameterDeclarationBuilder parent);
    private void InitLocationAndBaseTypeAndAttributes();
    public void Clear();
    public ICppVariableDeclaratorResolveEntity GetDeclaratorResolveEntity();
    public sealed virtual ICppDeclaratorBuilder GetDeclaratorBuilder();
    public sealed virtual ICppDeclarationBuilder GetDeclarationBuilder();
    public sealed virtual ICppAttributeListBuilder CreateAttributesBuilder();
    public sealed virtual ICppCallingConventionBuilder CreateCallingConventionBuilder();
    public sealed virtual ICppUnresolvedTypeBuilder GetUnresolvedTypeBuilder();
    public sealed virtual ICppResolvedTypeBuilder GetReplacedTypeBuilder();
    public sealed virtual void ComposeSymbolType(CppSymbolLocation loc);
    public sealed virtual void LearnLocation(CppSymbolLocation location);
    public void LearnQualifiedName(CppTwinQualifiedNameBuilder& twinBuilder);
    public sealed virtual void LearnQualifiedName(ICppStructuredBindingDeclarationBuilder nameBuilder);
    public sealed virtual void LearnInitializer(KIND kind, CppSmallArray`1<ICppExpression> unresolvedArguments, CppSmallArray`1<ICppExpression> replacedArguments);
    public sealed virtual void LearnMainParameterList(ICppFunctionParameterListBuilder _);
    public sealed virtual ICppFunctionParameterListBuilder GetMainParameterListBuilder();
    public sealed virtual void LearnFunctionBody(CppDeclarationTrailingKind kind);
    public sealed virtual void LearnPureVirtualSpecifier(CppPureVirtualSpecifiers _);
    public sealed virtual ICppFunctionParameterListBuilder CreateParameterListBuilder();
    public sealed virtual void LearnEllipsis();
    public sealed virtual void LearnAttributes(ICppAttributeListBuilder attrsBuilder);
    public sealed virtual void LearnNoAttributes();
    public sealed virtual void LearnBitfieldSize(ICppExpression unresolvedSize, ICppExpression replacedSize);
    public void LearnCxxCliOverrideSpecifier(CppTwinQualifiedNameBuilder& _);
    public sealed virtual void LearnRequiresClause(ICppExpression unresolved, ICppExpression replaced);
    public sealed virtual void AddChild(CppParserSymbol _);
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    public sealed virtual ICppDeclaratorSymbol get_Symbol();
    public sealed virtual bool get_HasSymbol();
    public sealed virtual bool get_IsParameterPackDeclarator();
    public CppParameterDeclaratorSymbol GetSymbol();
    private sealed virtual override void JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorBuilder.LearnQualifiedName(CppTwinQualifiedNameBuilder& modreq(System.Runtime.InteropServices.InAttribute) _);
    private sealed virtual override void JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorBuilder.LearnCxxCliOverrideSpecifier(CppTwinQualifiedNameBuilder& modreq(System.Runtime.InteropServices.InAttribute) _);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppParameterDeclaratorData : ValueType {
    public CppComplexOffset ComplexOffset;
    public CppQualifiedNamePart Name;
    private object mySqueezedInitializerAndAttributes;
    private CppQualType myType;
    public CppQualType SymbolType { get; }
    public ICppExpression Initializer { get; }
    public CppParameterDeclaratorData(CppParameterDeclaratorSymbol symbol);
    public CppParameterDeclaratorData(CppComplexOffset offset, CppQualifiedNamePart name, CppAttributeList attributes, CppQualType qualType, ICppExpression initializer);
    private CppParameterDeclaratorData(CppComplexOffset offset, CppQualifiedNamePart name, object squeezedInitializerAndAttributes, CppQualType type);
    private static object Squeeze(ICppExpression initializer, CppAttributeList attributes);
    public CppQualType get_SymbolType();
    [IsReadOnlyAttribute]
public ICppExpression get_Initializer();
    [IsReadOnlyAttribute]
public CppAttributeList GetAttributes();
    [IsReadOnlyAttribute]
public void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public static bool Equals(CppParameterDeclaratorData lhsParam, CppParameterDeclaratorData rhsParam, ICppEqualityComparer comparer);
    public CppParameterDeclaratorData WithAnotherSymbolType(CppQualType newSymbolType);
    public int GetHashCode(HashCodeVisitor typeHashCodeVisitor);
    [IsReadOnlyAttribute]
public CppQualType GetTypeWithInputQualifiers();
    private static InputQualifiers GetInputQualifiers(object squeezedInitializerArgumentsAndAttributes);
    public bool IsParameterWithImplicitInt();
    internal void Marshal(CppMarshallingContext context);
    public static CppParameterDeclaratorData Unmarshal(CppUnmarshallingContext context);
    private static void MarshalSquezeedInitializerArgumentsAndAttributes(CppMarshallingContext context, object squeezedInitializerArgumentsAndAttributes);
    private static object UnmarshalSquezeedInitializerArgumentsAndAttributes(CppUnmarshallingContext context);
    private int GetInitializerHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppParameterDeclaratorsData : ValueType {
    public CppFileLocation ContainingFile;
    public UInt32 PackedIsParameterPack;
    public CppParameterDeclaratorData[] Parameters;
    public CppParameterDeclaratorsData(CppSmallArray`1<CppParameterDeclaratorSymbol> syms);
    public CppParameterDeclaratorsData(CppFileLocation containingFile, UInt32 packedIsParameterPack, CppParameterDeclaratorData[] params);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppParameterDeclaratorSymbol : CppSymbol {
    private CppQualifiedNamePart myNamePart;
    private CppQualType mySymbolType;
    private ICppExpression myInitializer;
    [CompilerGeneratedAttribute]
private CppFileLocation <ContainingFile>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<CppUnresolvedFunctionType, int> <OwningParameters>k__BackingField;
    public CppQualType RawType { get; }
    public CppQualifiedName Name { get; }
    public ICppParserSymbol Parent { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public bool IsExplicitInstantiation { get; }
    public CppFileLocation ContainingFile { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<CppUnresolvedFunctionType, int> OwningParameters { get; internal set; }
    protected CppParameterDeclaratorSymbol(CppQualifiedNamePart namePart, CppSymbolLocation loc, CppQualType type);
    public virtual CppQualType get_RawType();
    public virtual CppDeclaratorInitializer GetInitializer();
    public virtual CppQualifiedName get_Name();
    public virtual ICppParserSymbol get_Parent();
    public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public virtual CppSymbolTemplateParametersList ParamList();
    public virtual CppAttributeList Attributes();
    public virtual CppSmallList`1<CppQualifiedName> CxxCliOverrideSpecifiers();
    public virtual ICppExpression GetRequiresClause();
    public virtual CppDeclarationTrailingKind GetDeclarationTrailingKind();
    public virtual CppAccessibility GetAccessibility();
    public virtual bool IsFunction();
    public virtual bool IsParameterPack();
    public sealed virtual CppCompoundStatementSymbol GetFunctionBody();
    public virtual bool get_IsExplicitInstantiation();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public static CppParameterDeclaratorSymbol Create(CppQualifiedNamePart namePart, CppAttributeList attrList, CppSymbolLocation loc, CppQualType type, bool isParameterPack);
    public CppQualifiedNamePart GetNamePart();
    [CanBeNullAttribute]
public ICppExpression GetRawInitializer();
    public void SetInitializer(ICppExpression initializer);
    [CompilerGeneratedAttribute]
public virtual CppFileLocation get_ContainingFile();
    public virtual void ShiftLocation(int textOffsetDelta);
    [CompilerGeneratedAttribute]
private ValueTuple`2<CppUnresolvedFunctionType, int> get_OwningParameters();
    [CompilerGeneratedAttribute]
internal void set_OwningParameters(ValueTuple`2<CppUnresolvedFunctionType, int> value);
    public virtual string ToString();
    private string HasInitToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppParameterDeclaratorWithAttributesSymbol : CppParameterDeclaratorSymbol {
    private CppAttributeList myAttributes;
    public CppParameterDeclaratorWithAttributesSymbol(CppQualifiedNamePart namePart, CppAttributeList attrList, CppSymbolLocation loc, CppQualType type);
    public virtual CppAttributeList Attributes();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppParameterLinkageEntity : CppLinkageEntity {
    private CppQualType myType;
    private int myIndex;
    private int myDepth;
    public CppParameterLinkageEntity(CppQualifiedNamePart name, CppQualType type, int index, int depth);
    public sealed virtual int GetIndex();
    public sealed virtual int GetDepth();
    public virtual Result Accept(ICppLinkageEntityVisitor`1<Result> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppParameterListBuilder : CppBuilderWithParent {
    private CppParameterListResolveEntity myResolveEntity;
    private CppList`1<CppParameterDeclaratorSymbol> myParameterSymbols;
    private CppCVQualifiersBuilder myCVQualifierBuilder;
    private CppFuncRefQualifierBuilder myFuncRefQualifierBuilder;
    private CppQualType myUnresolvedTrailingReturnType;
    private CppQualType myReplacedTrailingReturnType;
    private CppEllipsisKind myEllipsisKind;
    private CppRestrictionSpecifiers myRestrictionSpecifiers;
    private ICppExceptionSpecification myUnresolvedExceptionSpecification;
    private ICppExceptionSpecification myReplacedExceptionSpecification;
    private bool myHasOnlyParamsWithImplicitInt;
    private bool myKnRParamsStarted;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public CppParameterListBuilder(ICppBuilder parentBuilder);
    public virtual void AddChild(CppParserSymbol sym);
    public virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual void LearnExplicitThis();
    public sealed virtual void LearnEllipsis(CppEllipsisKind kind);
    public sealed virtual void LearnRestrictionSpecifier(CppRestrictionSpecifiers restrictionSpecifiers);
    public sealed virtual ICppDeclarationBuilder CreateDeclarationBuilderForParameter(CppBuilderPool pool);
    public sealed virtual void LearnParameter(ICppDeclarationBuilder declBuilder);
    public sealed virtual void LearnEndAnchor();
    public sealed virtual void LearnKnRStyleParamsStart();
    public sealed virtual CppEllipsisKind GetEllipsisKind();
    public sealed virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public sealed virtual CppParameterListResolveEntity GetResolveEntity();
    public sealed virtual CppList`1<CppParameterDeclaratorSymbol> GetParameterSymbols();
    public sealed virtual ICppDeclarationBuilder CreateDeclarationBuilderForTrailingReturnType();
    public sealed virtual void LearnTrailingReturnStartAnchor();
    public sealed virtual void LearnTrailingReturnType(ICppDeclarationBuilder declBuilder);
    public sealed virtual CppQualType GetUnresolvedTrailingReturnType();
    public sealed virtual CppQualType GetReplacedTrailingReturnType();
    public sealed virtual void LearnCVQualifier(TokenNodeType tt);
    public sealed virtual CVQualifiers GetFunctionCVQualifiers();
    public sealed virtual void LearnRefQualifier(TokenNodeType tt);
    public sealed virtual FuncRefQualifier GetFunctionRefQualifier();
    public sealed virtual ICppExceptionSpecificationBuilder CreateExceptionSpecificationBuilder(CppComplexOffset offset);
    public sealed virtual void LearnExceptionSpecification(CppComplexOffset offset, ICppExceptionSpecificationBuilder builder);
    public sealed virtual ICppExceptionSpecification GetUnresolvedExceptionSpecification();
    public sealed virtual ICppExceptionSpecification GetReplacedExceptionSpecification();
    public sealed virtual bool HasOnlyParamsWithImplicitInt();
    public sealed virtual bool IsKnRParamListStarted();
    public sealed virtual void LearnIsMainParameterList(bool declaratorIsStatic);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppParameterListModuleEntity : CppParameterListModuleEntityBase {
    private CppSmallArray`1<CppFunctionParameterModuleEntity> myParameters;
    public CppSmallArray`1<CppFunctionParameterModuleEntity> Parameters { get; }
    public CppParameterListModuleEntity(ICppScopeModuleEntity parent, byte flags);
    public virtual CppSmallArray`1<CppFunctionParameterModuleEntity> get_Parameters();
    internal void SetParameters(CppFunctionParameterModuleEntity[] parameters);
    internal void SetParameter(CppFunctionParameterModuleEntity parameter);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppParameterListModuleEntityBase : object {
    public ICppScopeModuleEntity Parent;
    public byte Flags;
    protected static int BaseSerializedSize;
    public CppSmallArray`1<CppFunctionParameterModuleEntity> Parameters { get; }
    protected CppParameterListModuleEntityBase(ICppScopeModuleEntity parent, byte flags);
    public abstract virtual CppModuleEntityKind Kind();
    public abstract virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public sealed virtual CppImportResult`1<ICppScopeResolveEntity> ImportScopeAutoParent(CppModuleImportingContext ctx);
    public abstract virtual CppSmallArray`1<CppFunctionParameterModuleEntity> get_Parameters();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppParameterListResolveEntity : object {
    public static CppQualifiedId NAME;
    private ICppResolveEntity myStructuralParent;
    private CppList`1<CppFunctionParameterDeclaratorPack> myChildren;
    private CppLocationAnchor myEndAnchor;
    private CppLocationAnchor myExceptionSpecAnchor;
    private ICppFunctionDeclaratorResolveEntity myOwner;
    private CppList`1<ICppVariableDeclaratorResolveEntity> myParameters;
    private CppTemplateHeaders myTemplateHeaders;
    private CppLocationAnchor myTrailingReturnTypeAnchor;
    [CompilerGeneratedAttribute]
private byte <Flags>k__BackingField;
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppEllipsisKind EllipsisKind { get; }
    internal byte Flags { get; internal set; }
    private static CppParameterListResolveEntity();
    public CppParameterListResolveEntity(ICppScopeResolveEntity parentScope);
    public CppParameterListResolveEntity(ICppScopeResolveEntity parentScope, int paramCount);
    public sealed virtual bool IsMainParameterListOfStaticFunction();
    public sealed virtual bool IsMainParameterList();
    public sealed virtual bool IsRequiresExpressionParameterList();
    public sealed virtual CVQualifiers GetCVQualifiers();
    public sealed virtual CppLocationAnchor GetEndAnchor();
    public sealed virtual Nullable`1<CppLocationAnchor> GetExceptionSpecAnchor();
    public sealed virtual CppLocationAnchor GetTrailingReturnTypeAnchor();
    public sealed virtual CppList`1<ICppVariableDeclaratorResolveEntity> GetParameters();
    public void AddChild(CppFunctionParameterDeclaratorPack pack);
    public sealed virtual void AddChild(ICppResolveEntity ent);
    public sealed virtual void RemoveChild(ICppResolveEntity ent);
    public sealed virtual CppSmallList`1<ICppResolveEntity> ChildByName(CppQualifiedNamePart name, CppLocationAnchor anchor);
    public CppList`1<CppFunctionParameterDeclaratorPack> GetParameterDeclaratorPacks();
    public sealed virtual CppList`1<ICppResolveEntity> GetChildren();
    public sealed virtual void AddAnonymousClass(ICppClassResolveEntity ent);
    public sealed virtual CppList`1<ICppClassResolveEntity> AnonymousClasses();
    public sealed virtual ICppFunctionDeclaratorResolveEntity GetOwningDeclarator();
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public sealed virtual ICppResolveEntityParent get_RealParent();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual CppEllipsisKind get_EllipsisKind();
    public sealed virtual bool ContainsLambdas();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public void SetIsMainParameterList(bool value, bool declaratorIsStatic);
    public void SetIsRequiresExpressionParameterList(bool value);
    public void SetCVQualifiers(CVQualifiers value);
    public void SetEndAnchor(CppLocationAnchor anchor);
    public void SetExceptionSpecAnchor(CppLocationAnchor anchor);
    public void SetTrailingReturnTypeAnchor(CppLocationAnchor anchor);
    public void AddParameter(ICppVariableDeclaratorResolveEntity dent);
    public CppFunctionParameterDeclaratorPack AddParameterToPack(ICppGroupedVariableDeclaratorResolveEntity var);
    public void AddEllipsis(CppEllipsisKind kind);
    public bool HasOnlyParamsWithImplicitInt();
    public CppTemplateHeaders GetTemplateHeaders();
    public void SetTemplateHeaders(CppTemplateHeaders& templateHeaders);
    public void SetOwningDeclarator(ICppFunctionDeclaratorResolveEntity owner);
    public void MarkAsContainingLambdas();
    [CompilerGeneratedAttribute]
internal byte get_Flags();
    [CompilerGeneratedAttribute]
internal void set_Flags(byte value);
    internal static CppEllipsisKind GetEllipsisKind(byte flags);
    public virtual string ToString();
    private bool IsSet(Bit bit);
    private static bool IsSet(byte flags, Bit bit);
    private void Set(Bit bit, bool value);
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppParameterListWithSubstitution : object {
    private CppList`1<ICppVariableDeclaratorResolveEntity> myParameters;
    private Dictionary`2<CppQualifiedNamePart, CppFunctionParameterDeclaratorPack> myChildrenMap;
    private ICppResolveEntity myParent;
    private ICppParameterListResolveEntity myInner;
    private CppFunctionDeclaratorWithSubstitution myOwner;
    private CppSmallList`1<ICppResolveEntity> myLambdaClassChildren;
    private CppSmallList`1<ICppResolveEntity> myLambdaScopeChildren;
    public bool HasOnlyParamsWithImplicitInt { get; }
    public CppEllipsisKind EllipsisKind { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppParameterListWithSubstitution(ICppParameterListResolveEntity inner, CppFunctionDeclaratorWithSubstitution owner);
    public CppParameterListWithSubstitution(ICppResolveEntity parent, ICppParameterListResolveEntity inner, ICppSubstitutionContext subst, CppViewPos& pointOfInstantiation);
    public bool get_HasOnlyParamsWithImplicitInt();
    public sealed virtual CppList`1<ICppVariableDeclaratorResolveEntity> GetParameters();
    public sealed virtual bool IsMainParameterListOfStaticFunction();
    public sealed virtual bool IsMainParameterList();
    public sealed virtual bool IsRequiresExpressionParameterList();
    public sealed virtual ICppFunctionDeclaratorResolveEntity GetOwningDeclarator();
    public sealed virtual CVQualifiers GetCVQualifiers();
    public sealed virtual CppLocationAnchor GetEndAnchor();
    public sealed virtual Nullable`1<CppLocationAnchor> GetExceptionSpecAnchor();
    public sealed virtual CppLocationAnchor GetTrailingReturnTypeAnchor();
    public sealed virtual bool ContainsLambdas();
    public sealed virtual CppEllipsisKind get_EllipsisKind();
    public sealed virtual void AddChild(ICppResolveEntity ent);
    public sealed virtual void RemoveChild(ICppResolveEntity ent);
    public sealed virtual CppSmallList`1<ICppResolveEntity> ChildByName(CppQualifiedNamePart name, CppLocationAnchor anchor);
    public sealed virtual CppList`1<ICppResolveEntity> GetChildren();
    public sealed virtual void AddAnonymousClass(ICppClassResolveEntity c);
    public sealed virtual CppList`1<ICppClassResolveEntity> AnonymousClasses();
    public sealed virtual ICppResolveEntityParent get_RealParent();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public void SetOwner(CppFunctionDeclaratorWithSubstitution owner);
    public ICppParameterListResolveEntity GetInner();
    private void Init(ICppSubstitutionContext subst, CppViewPos& pointOfInstantiation);
    private void SubstituteParameter(ICppGroupedVariableDeclaratorResolveEntity param, ICppSubstitutionContext subst, CppViewPos& pointOfInstantiation);
    private void CreatePack(ICppGroupedVariableDeclaratorResolveEntity param);
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppParameterPackDeclaratorSymbol : CppParameterDeclaratorWithAttributesSymbol {
    public CppParameterPackDeclaratorSymbol(CppQualifiedNamePart namePart, CppAttributeList attrList, CppSymbolLocation loc, CppQualType type);
    public virtual bool IsParameterPack();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppParameterSymbolBase : CppSymbol {
    [CompilerGeneratedAttribute]
private CppFileLocation <ContainingFile>k__BackingField;
    public CppQualifiedName Name { get; }
    public ICppParserSymbol Parent { get; }
    public CppFileLocation ContainingFile { get; }
    public CppQualifiedNamePart NamePart { get; }
    protected CppParameterSymbolBase(CppSymbolLocation loc);
    public virtual CppQualifiedName get_Name();
    public virtual ICppParserSymbol get_Parent();
    [CompilerGeneratedAttribute]
public virtual CppFileLocation get_ContainingFile();
    public virtual bool NameEquals(CppQualifiedNamePart name);
    public abstract virtual CppQualifiedNamePart get_NamePart();
    public abstract virtual ICppTemplateArgument GetDefault();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppParserSymbol : CppSymbol {
    private ICppParserSymbol myParent;
    [CompilerGeneratedAttribute]
private CppQualifiedName <Name>k__BackingField;
    public CppQualifiedName Name { get; }
    public ICppParserSymbol Parent { get; public set; }
    public CppFileLocation ContainingFile { get; }
    protected CppParserSymbol(CppQualifiedName name, CppComplexOffset loc);
    [CompilerGeneratedAttribute]
public virtual CppQualifiedName get_Name();
    public virtual ICppParserSymbol get_Parent();
    public virtual void set_Parent(ICppParserSymbol value);
    public virtual CppFileLocation get_ContainingFile();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPendingActionActivator : ValueType {
    private CppNamespaceResolveEntity myScope;
    private CppQualifiedNamePart myName;
    private ICppPendingMergingAction myAction;
    private bool IsAnonymousActionActivator { get; }
    private CppPendingActionActivator(CppNamespaceResolveEntity ns, CppQualifiedNamePart name, ICppPendingMergingAction action);
    public static CppPendingActionActivator CreateAnonymousActivator(CppNamespaceResolveEntity ns, ICppPendingMergingAction action);
    public static CppPendingActionActivator CreateNamedActivator(CppNamespaceResolveEntity ns, CppQualifiedNamePart name, ICppPendingMergingAction action);
    public ICppPendingMergingAction ActivateAndGetAction();
    public CppLocationAnchor GetActionAnchor();
    public CppNamespaceResolveEntity GetScope();
    public CppQualifiedNamePart GetName();
    private bool get_IsAnonymousActionActivator();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPendingActionComparer : object {
    public static CppPendingActionComparer Instance;
    private static CppPendingActionComparer();
    public sealed virtual int Compare(ICppPendingMergingAction x, ICppPendingMergingAction y);
    public static int ComparePendingActionsByAnchor(ICppPendingMergingAction lhs, ICppPendingMergingAction rhs);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPendingActionsMapPool : AutoClearingThreadSafeObjectPool`1<Dictionary`2<CppQualifiedNamePart, CppUnmergedActions>> {
    public static int CheckPeriod;
    public CppPendingActionsMapPool(Lifetime lifetime);
    protected virtual Dictionary`2<CppQualifiedNamePart, CppUnmergedActions> CreateObject();
    protected virtual void ClearObject(Dictionary`2<CppQualifiedNamePart, CppUnmergedActions> actions);
    protected virtual void InitObject(Dictionary`2<CppQualifiedNamePart, CppUnmergedActions> actions);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPendingActionWithResultActivator`1 : ValueType {
    private CppPendingActionActivator myActivator;
    public static CppPendingActionWithResultActivator`1<TResult> CreateUnsafe(CppPendingActionActivator activator);
    public TResult Activate();
    public CppPendingActionActivator GetActivatorWithoutResult();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPickSpecializationUtil : object {
    public static KeyValuePair`2<ICppClassResolveEntity, CppSubstitutionContext> PickSpecialization(CppClassTemplateResolveEntityPack pack, ICppClassResolveEntityWithSubstitution substituted, CppViewPos& viewPos, CppLocationAnchor anchor);
    public static KeyValuePair`2<ICppGroupedVariableDeclaratorResolveEntity, CppSubstitutionContext> PickPrimaryTemplateOrPartialSpecializationOfVariable(IEnumerable`1<ICppGroupedVariableDeclaratorResolveEntity> specializations, ICppGroupedVariableDeclaratorResolveEntity primaryTemplate, CppViewPos& viewPos, ICppTemplateArgument[] args);
    private static ICppGroupedVariableDeclaratorResolveEntity PickMostSpecialized(List`1<ICppGroupedVariableDeclaratorResolveEntity> specializations, CppViewPos viewPos);
    private static ICppClassResolveEntity PickMostSpecialized(List`1<ICppClassResolveEntity> specializations, CppViewPos viewPos);
    private static bool IsInstantiated(ICppGroupedVariableDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool IsInstantiated(ICppClassResolveEntity clazz);
    private static KeyValuePair`2<TResolveEntity, CppSubstitutionContext> PickSpecializationImpl(IEnumerable`1<TResolveEntity> specializations, TResolveEntity primaryTemplate, CppViewPos& viewPos, ICppTemplateArgument[] args, Func`2<TResolveEntity, bool> isInstantiatedFunc, Func`3<List`1<TResolveEntity>, CppViewPos, TResolveEntity> pickMostSpecializedFunc);
}
internal enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppPointerValueKind : Enum {
    public byte value__;
    public static CppPointerValueKind Nullptr;
    public static CppPointerValueKind PointerToDeclarator;
    public static CppPointerValueKind PointerToTemplateParameterObject;
    public static CppPointerValueKind PointerToArrayElement;
    public static CppPointerValueKind PointerToReference;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPBuiltinOffsetOfBuilder : ValueType {
    public sealed virtual void LearnTypeArgument(ICppDeclarationBuilder _);
    public sealed virtual void LearnMemberDesignator(CppQualifiedNameBuilder& _);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPC11GenericExpressionBuilder : ValueType {
    public sealed virtual CppPPExpressionEvaluator CreateExpressionBuilder();
    public sealed virtual ICppDeclarationBuilder CreateInnerDeclarationBuilder(ICppBuilder parent);
    public sealed virtual void LearnControllingExpression(CppPPExpressionEvaluator& _);
    public sealed virtual void LearnDefault();
    public sealed virtual void LearnType(ICppDeclarationBuilder _);
    public sealed virtual void LearnExpression(CppPPExpressionEvaluator& _);
    public sealed virtual void ApplyClause();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPDefineSymbol : CppSymbol {
    public static string INVALID_NAME;
    public static string VA_ARGS_NAME;
    private byte myFlags;
    [CompilerGeneratedAttribute]
private CppFileLocation <ContainingFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Substitution>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ParameterNamesRaw>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public CppFileLocation ContainingFile { get; }
    public string Substitution { get; }
    public bool HasParameters { get; }
    public bool IsVariadic { get; }
    public bool IsAlias { get; }
    public bool SubstitutesToLiteral { get; }
    public bool IsRigVMMacro { get; }
    public bool IsMagical { get; }
    public IList`1<string> ParameterNames { get; }
    public String[] ParameterNamesRaw { get; }
    public string Name { get; }
    public CppPPDefineSymbol(string name, CppSymbolLocation location);
    public CppPPDefineSymbol(string name, String[] params, bool variadic, string substitution, CppSymbolLocation location, bool isAlias, bool substitutesToLiteral, bool isRigVMMacro, bool isMagical);
    internal CppPPDefineSymbol(string name, String[] params, string substitution, CppSymbolLocation location, byte flags);
    [CompilerGeneratedAttribute]
public virtual CppFileLocation get_ContainingFile();
    [CompilerGeneratedAttribute]
public string get_Substitution();
    public bool get_HasParameters();
    private bool HasFlag(Offset o);
    private static int GetFlag(Offset o, bool value);
    public bool get_IsVariadic();
    public bool get_IsAlias();
    public bool get_SubstitutesToLiteral();
    public bool get_IsRigVMMacro();
    public bool get_IsMagical();
    internal byte GetRawFlags();
    internal static void SanitizeFlagsAfterUnmarshalling(Byte& flags);
    public IList`1<string> get_ParameterNames();
    [CompilerGeneratedAttribute]
public String[] get_ParameterNamesRaw();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public bool IsValid();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPDefineSymbolComparer : object {
    public static CppPPDefineSymbolComparer Instance;
    private static CppPPDefineSymbolComparer();
    public sealed virtual bool Equals(CppPPDefineSymbol lhs, CppPPDefineSymbol rhs);
    public sealed virtual int GetHashCode(CppPPDefineSymbol sym);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPDefineSymbolUtil : object {
    public static CppPPDefineSymbol ParseFromDirectiveContent(string content, int startOffset, int endOffset, int mainFileStartOffset, CppFileLocation file, CppComplexOffset offset, bool VCTraditionalPreprocessor, ITokenIntern tokenIntern);
    public static CppPPDefineSymbol ParseDirectiveContent(string content);
    public static CppPPDefineSymbol ParseRigVMDirectiveContent(string name, string replacement, CppSymbolLocation location);
    public static CppPPDefineSymbol ParsePredefinedMacro(string content);
    private static CppPPDefineSymbol ParseFromDirectiveContentImpl(string content, int startOffset, int endOffset, int mainFileStartOffset, CppFileLocation file, CppComplexOffset hashDefineOffset, bool fromPredefinedMacros, bool VCTraditionalPreprocessor, ITokenIntern tokenIntern);
    public static CppPPDefineSymbol CreatePredefinedSymbol(string name, string substitution);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPDesignatorBuilder : ValueType {
    public sealed virtual CppPPExpressionEvaluator CreateExpressionBuilder();
    public sealed virtual void LearnSubscriptDesignator(CppPPExpressionEvaluator& index);
    public sealed virtual void LearnMemAccessDesignator(string name);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPDoubleArgumentTypeTraitExpressionBuilder : ValueType {
    public sealed virtual void LearnFirstArgument(ICppDeclarationBuilder _);
    public sealed virtual void LearnSecondArgument(ICppDeclarationBuilder _);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPExpressionEvaluator : ValueType {
    private ICppPPValue myCurrentValue;
    public ICppPPValue GetValue();
    public sealed virtual CppPPExpressionEvaluator CreateInnerExpressionBuilder();
    public sealed virtual ICppDeclarationBuilder CreateInnerDeclarationBuilder(ICppBuilder _);
    public sealed virtual CppQualifiedNameBuilder CreateInnerQualifiedNameBuilder();
    public sealed virtual CppPPFunctionArgumentListBuilder CreateInnerFunctionArgumentListBuilder();
    public sealed virtual CppPPDesignatorBuilder CreateDesignatorBuilder();
    public sealed virtual CppPPC11GenericExpressionBuilder CreateC11GenericExpressionBuilder();
    public sealed virtual void LearnEmptyExpression();
    public sealed virtual void ApplyThrowOperator();
    public sealed virtual void ApplyCStyleCast(ICppDeclarationBuilder _);
    public sealed virtual void LearnSizeOfExpression(ICppDeclarationBuilder _);
    public sealed virtual void LearnSizeOfEllipsisExpression(CppQualifiedNameBuilder& _);
    public sealed virtual void ApplySizeOf();
    public sealed virtual void LearnAlignOfExpression(ICppDeclarationBuilder _);
    public sealed virtual void ApplyAlignOf();
    public sealed virtual void LearnMSUuidOfExpression(ICppDeclarationBuilder _);
    public sealed virtual void LearnMSEventHookExpression(bool unhook, CppPPFunctionArgumentListBuilder& builder);
    public sealed virtual void ApplyMSUuidOf();
    public sealed virtual void ApplyMSAssume();
    public sealed virtual void ApplyNoExcept();
    public sealed virtual void ApplyBuiltinAddressOf();
    public sealed virtual void ApplyGnuBuiltinConstantP();
    public sealed virtual void LearnBuiltinOffsetOf(CppPPBuiltinOffsetOfBuilder builder);
    public sealed virtual void LearnNewExpression(CppPPNewExpressionBuilder builder);
    public sealed virtual void LearnC11GenericExpression(CppPPC11GenericExpressionBuilder& builder);
    public sealed virtual void ApplyDeleteOperator(bool isArrayKind);
    public sealed virtual void LearnSingleArgumentTypeTraitExpression(ICppDeclarationBuilder argumentTypeId, TokenNodeType kwToken);
    public sealed virtual void LearnDoubleArgumentTypeTraitExpression(CppPPDoubleArgumentTypeTraitExpressionBuilder builder, TokenNodeType kwToken);
    public sealed virtual void LearnMultiArgumentTypeTraitExpression(CppPPMultiArgumentTypeTraitExpressionBuilder builder, TokenNodeType kwToken);
    public sealed virtual void ApplyCast(TokenNodeType tt, ICppDeclarationBuilder declBuilder);
    public sealed virtual void LearnTypeIdExpression(ICppDeclarationBuilder declBuilder);
    public sealed virtual void ApplyTypeId();
    public sealed virtual void ApplyParen();
    public sealed virtual void LearnQualifiedReferenceExpression(CppQualifiedNameBuilder& _);
    public sealed virtual void LearnQualifiedReferenceExpression(CppTwinQualifiedNameBuilder& _);
    public sealed virtual void ApplyPostfixOperator(TokenNodeType _);
    public sealed virtual void ApplyDotOperator(TokenNodeType tt, CppQualifiedNameBuilder& name);
    public sealed virtual void ApplySubscriptionOperator(CppPPExpressionEvaluator _, bool isPackExpansion);
    public sealed virtual void ApplyMultiArgumentSubscriptionOperator(CppPPFunctionArgumentListBuilder& argListBuilder, bool cli);
    public sealed virtual void LearnCliTypeId(CppQualifiedNameBuilder& nameBuilder);
    public sealed virtual void ApplyUnaryOperator(TokenNodeType tok);
    public sealed virtual void ApplyBinaryOperator(CppOperatorKind k, CppPPExpressionEvaluator& rop);
    public sealed virtual void ApplyGnuBuiltinChooseExpr(CppFunctionArgumentListBuilder& argBuilder);
    public sealed virtual void ApplyUnaryLeftFoldExpression(CppOperatorKind kind);
    public sealed virtual void ApplyUnaryRightFoldExpression(CppOperatorKind kind);
    public sealed virtual void ApplyBinaryFoldExpression(CppOperatorKind kind, CppPPExpressionEvaluator& exprBuilder);
    public sealed virtual void ApplyConditionalOperator(CppPPExpressionEvaluator& secondArgument, CppPPExpressionEvaluator& thirdArgument, CppConditionalExprKind kind);
    public sealed virtual bool LearnLiteral(TokenNodeType tt, string text, CppLanguageDialect dialect);
    public sealed virtual void LearnLambdaExpression(CppLambdaBuilder builder);
    public sealed virtual void LearnRequiresExpression(CppRequiresExpressionBuilder builder);
    public sealed virtual void LearnGnuStatementExpression(CppCompoundStatementInExpressionBuilder builder);
    public sealed virtual bool LearnStringLiteral(CppStringLiteralBuilder& builder);
    public sealed virtual void LearnThis();
    public sealed virtual void LearnMSNoopExpression();
    public sealed virtual void LearnGNUAddressOfLabelExpression(string labelName);
    public sealed virtual void ApplyCallOperator(CppPPFunctionArgumentListBuilder& _);
    public sealed virtual void LearnCallToTypeId(CppUnresolvedDeclarationSpecifierTypeBuilder typeBuilder, CppPPFunctionArgumentListBuilder& argBuilder);
    public sealed virtual void LearnBracedInitializedTypeId(CppUnresolvedDeclarationSpecifierTypeBuilder typeBuilder, CppPPFunctionArgumentListBuilder& argBuilder);
    public sealed virtual void LearnBracedInitializedTypeIdDecl(ICppDeclarationBuilder declBuilder, CppPPFunctionArgumentListBuilder& argListBuilder);
    public sealed virtual void ApplyBracedInitializer(CppPPFunctionArgumentListBuilder& _);
    public sealed virtual void LearnBracedInitList(CppPPFunctionArgumentListBuilder& _);
    public void ApplyPackExpansion();
    public sealed virtual void ApplyCoAwaitExpression();
    public sealed virtual void ApplyCoYieldExpression();
    public sealed virtual void LearnDesignation(CppPPDesignatorBuilder& designator, CppPPExpressionEvaluator& initializer, InitializerKind kind);
    public CppPPExpressionEvaluator CreateExpressionBuilder(bool createSymbols);
    public sealed virtual CppQualifiedNameBuilder CreateQualifiedNameBuilder();
    public sealed virtual CppStringLiteralBuilder CreateStringLiteralBuilder();
    public sealed virtual CppPPFunctionArgumentListBuilder CreateFunctionArgumentListBuilder(bool createSymbols);
    public sealed virtual CppPPNewExpressionBuilder CreateNewExpressionBuilder();
    public sealed virtual CppPPDoubleArgumentTypeTraitExpressionBuilder CreateDoubleArgumentTypeTraitExpressionBuilder();
    public sealed virtual CppPPMultiArgumentTypeTraitExpressionBuilder CreateMultiArgumentTypeTraitExpressionBuilder();
    public sealed virtual CppPPBuiltinOffsetOfBuilder CreateBuiltinOffsetOfBuilder();
    public sealed virtual ICppExpression GetExpressionForLookup();
    private void ResetCurrentValue();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPFunctionArgumentListBuilder : ValueType {
    public CppPPFunctionArgumentListBuilder(bool _);
    public sealed virtual CppPPExpressionEvaluator CreateExpressionBuilder();
    public sealed virtual void LearnArgument(CppPPExpressionEvaluator& _, bool isPackExpansion);
    public IList`1<ICppExpression> GetArguments();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPImportSymbol : CppPPIncludeSymbol {
    [CompilerGeneratedAttribute]
private string <Output>k__BackingField;
    public string Output { get; }
    public CppPPImportSymbol(CppFileLocation target, string fileName, bool isLocal, CppFileLocation file, CppComplexOffset offset, string output);
    [CompilerGeneratedAttribute]
public string get_Output();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPIncludeSymbol : CppSymbol {
    private CppPPIncludeSymbolFlags myFlags;
    private CppFileLocation myTarget;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <SearchPath>k__BackingField;
    [CompilerGeneratedAttribute]
private CppFileLocation <ContainingFile>k__BackingField;
    public CppFileLocation Target { get; }
    public bool IsLocal { get; }
    public bool IsPchInclude { get; }
    public bool IsIncludeNext { get; }
    public string FileName { get; }
    public VirtualFileSystemPath SearchPath { get; }
    public CppFileLocation ContainingFile { get; }
    public CppPPIncludeSymbol(CppFileLocation target, VirtualFileSystemPath searchPath, string fileName, bool isLocal, bool isPchInclude, bool isIncludeNext, CppFileLocation file, CppComplexOffset offset);
    public CppFileLocation get_Target();
    public bool get_IsLocal();
    public bool get_IsPchInclude();
    public bool get_IsIncludeNext();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_SearchPath();
    public bool IsValid();
    [CompilerGeneratedAttribute]
public virtual CppFileLocation get_ContainingFile();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual string ToString();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPIncludeSymbolFlags : Enum {
    public byte value__;
    public static CppPPIncludeSymbolFlags NONE;
    public static CppPPIncludeSymbolFlags IS_LOCAL;
    public static CppPPIncludeSymbolFlags IS_PCH_INCLUDE;
    public static CppPPIncludeSymbolFlags IS_INCLUDE_NEXT;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPLocationAnchor : ValueType {
    private int myLocation;
    public int AnchorLocation { get; public set; }
    public CppPPLocationAnchor Next { get; }
    public CppPPLocationAnchor(int location);
    public sealed virtual int get_AnchorLocation();
    public void set_AnchorLocation(int value);
    public sealed virtual CppPPLocationAnchor get_Next();
    public sealed virtual int CompareTo(CppPPLocationAnchor rhs);
    public sealed virtual bool Equals(CppPPLocationAnchor rhs);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public static CppPPLocationAnchor TopMost();
    public static CppPPLocationAnchor BottomMost();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPMacroParameterSymbol : CppSymbol {
    public static CppPPMacroParameterSymbol INVALID;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CppFileLocation <ContainingFile>k__BackingField;
    public string Name { get; }
    public CppFileLocation ContainingFile { get; }
    private CppPPMacroParameterSymbol(string name);
    public CppPPMacroParameterSymbol(string name, CppFileLocation file, CppComplexOffset offset);
    private static CppPPMacroParameterSymbol();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual CppFileLocation get_ContainingFile();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPMultiArgumentTypeTraitExpressionBuilder : object {
    public sealed virtual void LearnArgument(ICppDeclarationBuilder declBuilder, bool isPackExpansion);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPNewExpressionBuilder : ValueType {
    public sealed virtual void LearnIsCliGCNew(bool _);
    public sealed virtual void LearnIsFromGlobalNamespace(bool _);
    public sealed virtual void LearnType(ICppDeclarationBuilder _);
    public sealed virtual void LearnOperatorArguments(CppPPFunctionArgumentListBuilder& _);
    public sealed virtual void LearnConstructorArguments(CppPPFunctionArgumentListBuilder& _);
    public sealed virtual void LearnBracedArguments(CppPPFunctionArgumentListBuilder& _);
    public CppQualType GetQualType();
    public IList`1<ICppExpression> GetOperatorArguments();
    public IList`1<ICppExpression> GetConstructorArguments();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPPragmaIncludeAliasSymbol : CppPPPragmaSymbol {
    [CompilerGeneratedAttribute]
private CppIncludeDirectiveContent <AliasName>k__BackingField;
    [CompilerGeneratedAttribute]
private CppIncludeDirectiveContent <TargetName>k__BackingField;
    public CppIncludeDirectiveContent AliasName { get; }
    public CppIncludeDirectiveContent TargetName { get; }
    public CppPPPragmaIncludeAliasSymbol(CppIncludeDirectiveContent aliasName, CppIncludeDirectiveContent targetName, CppFileLocation file, CppComplexOffset offset);
    [CompilerGeneratedAttribute]
public CppIncludeDirectiveContent get_AliasName();
    [CompilerGeneratedAttribute]
public CppIncludeDirectiveContent get_TargetName();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPPragmaPackPopSymbol : CppPPPragmaSymbol {
    public CppPPPragmaPackPopSymbol(CppFileLocation file, CppComplexOffset offset);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPPragmaPackPushSymbol : CppPPPragmaSymbol {
    public Nullable`1<UInt32> PackValue;
    public CppPPPragmaPackPushSymbol(Nullable`1<UInt32> packValue, CppFileLocation file, CppComplexOffset offset);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPPragmaPackSymbol : CppPPPragmaSymbol {
    public Nullable`1<UInt32> PackValue;
    public CppPPPragmaPackSymbol(Nullable`1<UInt32> packValue, CppFileLocation file, CppComplexOffset offset);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPPragmaPopSymbol : CppPPPragmaSymbol {
    [CompilerGeneratedAttribute]
private string <MacroName>k__BackingField;
    public string MacroName { get; }
    public CppPPPragmaPopSymbol(string macro, CppFileLocation file, CppComplexOffset offset);
    [CompilerGeneratedAttribute]
public string get_MacroName();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPPragmaPushSymbol : CppPPPragmaSymbol {
    [CompilerGeneratedAttribute]
private string <MacroName>k__BackingField;
    public string MacroName { get; }
    public CppPPPragmaPushSymbol(string macro, CppFileLocation file, CppComplexOffset offset);
    [CompilerGeneratedAttribute]
public string get_MacroName();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPPragmaSymbol : CppSymbol {
    [CompilerGeneratedAttribute]
private CppFileLocation <ContainingFile>k__BackingField;
    public CppFileLocation ContainingFile { get; }
    public CppPPPragmaSymbol(CppFileLocation file, CppComplexOffset offset);
    [CompilerGeneratedAttribute]
public virtual CppFileLocation get_ContainingFile();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPPragmaWarningSymbol : CppPPPragmaSymbol {
    public int Code;
    public CppPragmaWarningMode Mode;
    public CppPPPragmaWarningSymbol(int code, CppPragmaWarningMode mode, CppFileLocation file, CppComplexOffset offset);
    public virtual string ToString();
    private static string Stringize(CppPragmaWarningMode mode);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPPUndefSymbol : CppSymbol {
    public static string INVALID_NAME;
    private string myName;
    [CompilerGeneratedAttribute]
private CppFileLocation <ContainingFile>k__BackingField;
    public string Name { get; }
    public CppFileLocation ContainingFile { get; }
    public CppPPUndefSymbol(string name, CppFileLocation file, CppComplexOffset offset);
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual CppFileLocation get_ContainingFile();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public bool IsValid();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPreciseDumpingUtil : object {
    [ExtensionAttribute]
public static void DumpTemplateParameter(CppIndentationStringBuilder tw, CppTemplateParametersBase params);
    [ExtensionAttribute]
public static void DumpTemplateArguments(CppIndentationStringBuilder tw, ICppTemplateArgument[] args);
    [ExtensionAttribute]
public static void DumpQualifiedName(CppIndentationStringBuilder tw, CppQualifiedNamePart name);
    [ExtensionAttribute]
public static void DumpQualifiedName(CppIndentationStringBuilder tw, CppQualifiedName name);
    [ExtensionAttribute]
public static void DumpAttributeList(CppIndentationStringBuilder tw, CppAttributeList attributes);
    [ExtensionAttribute]
public static void DumpSymbol(CppIndentationStringBuilder tw, ICppSymbol sym);
    [ExtensionAttribute]
public static void DumpLocationAnchor(CppIndentationStringBuilder tw, CppLocationAnchor anchor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPreprocessorConditionalBuilder : object {
    private CppFileSymbolsCache mySymbolBuilder;
    private CppGlobalNamespaceResolveEntity myResolveEnt;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public CppPreprocessorConditionalBuilder(CppGlobalNamespaceResolveEntity ent);
    public sealed virtual void AddChild(CppParserSymbol sym);
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    public CppFileSymbolsCache GetOwner();
    public void SetOwner(CppFileSymbolsCache owner);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPropertyDeclaration0Builder : CppDeclaration0Builder {
    public CppPropertyDeclaration0Builder(ICppBuilder parent, CppSymbolLocation loc);
    public CppPropertyDeclaration0Builder(ICppBuilder parent, CppSymbolLocation loc, CppBuilderPool pool);
    public virtual ICppConceptDefinitionBuilder NewConceptDefinitionBuilder();
    protected virtual ICppDeclaratorBuilder NewDeclaratorBuilderImpl();
    public static CppTemplateDeclarationBuilder GetTemplateDeclarationBuilder(ICppBuilder _);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPropertyDeclarator0Builder : CppDeclarator0Builder`2<CppCxxCliPropertySymbol, CppCxxCliPropertyResolveEntity> {
    public CppPropertyDeclarator0Builder(CppPropertyDeclaration0Builder parent);
    public virtual void LearnFunctionBody(CppFunctionBodyBuilder _);
    public virtual void LearnFunctionBody(CppDeclarationTrailingKind trailingKind);
    public virtual void LearnClosedBodyChameleon();
    public virtual void LearnCtorBlockWithoutBody();
    public virtual ICppBuilder CreateInitDeclaratorBuilder();
    public virtual void ComposeSymbolType(CppSymbolLocation loc);
    public virtual void LearnInitializer(KIND kind, CppSmallArray`1<ICppExpression> unresolvedArguments, CppSmallArray`1<ICppExpression> replacedArguments);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPseudoFunctionBodyResolveEntity : CppCodeFragmentCompoundStatementResolveEntity {
    public CppPseudoFunctionBodyResolveEntity(ICppResolveEntity structuralParent, CppLocationAnchor outerAnchor, ICppFileResolveEntitiesCache cache);
    public virtual Kind GetKind();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppPureVirtualSpecifiers : Enum {
    public ushort value__;
    public static CppPureVirtualSpecifiers None;
    public static CppPureVirtualSpecifiers Pure;
    public static CppPureVirtualSpecifiers Override;
    public static CppPureVirtualSpecifiers Final;
    public static CppPureVirtualSpecifiers Sealed;
    public static CppPureVirtualSpecifiers Abstract;
    public static CppPureVirtualSpecifiers New;
    public static CppPureVirtualSpecifiers All;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppPureVirtualSpecifiersUtil : object {
    [ExtensionAttribute]
public static bool IsPure(CppPureVirtualSpecifiers spec);
    [ExtensionAttribute]
public static bool IsOverride(CppPureVirtualSpecifiers spec);
    [ExtensionAttribute]
public static bool IsFinal(CppPureVirtualSpecifiers spec);
    [ExtensionAttribute]
public static bool IsSealed(CppPureVirtualSpecifiers spec);
    [ExtensionAttribute]
public static bool IsFinalOrSealed(CppPureVirtualSpecifiers spec);
    [ExtensionAttribute]
public static bool IsAbstract(CppPureVirtualSpecifiers spec);
    [ExtensionAttribute]
public static bool IsNew(CppPureVirtualSpecifiers spec);
    [ExtensionAttribute]
public static bool IsPureOrAbstract(CppPureVirtualSpecifiers spec);
    [ExtensionAttribute]
public static string PureVirtualSpecifiersToString(CppPureVirtualSpecifiers specs);
    [ExtensionAttribute]
public static void PureVirtualSpecifiersToString(CppPureVirtualSpecifiers specs, StringBuilder sb);
    [ExtensionAttribute]
public static string PureVirtualSpecifiersToPresentationString(CppPureVirtualSpecifiers specs);
    [ExtensionAttribute]
public static void PureVirtualSpecifiersToPresentationString(CppPureVirtualSpecifiers specs, StringBuilder sb);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppQualifiedId : ValueType {
    public static CppQualifiedId STD_NAME;
    public static CppQualifiedId CLI_NAME;
    public static CppQualifiedId INTERIOR_PTR_NAME;
    public static CppQualifiedId PIN_PTR_NAME;
    public static CppQualifiedId INVOKE_NAME;
    public static CppQualifiedId SYSTEM_NAME;
    public static CppQualifiedId STRING_NAME;
    public static CppQualifiedId OBJECT_NAME;
    public static CppQualifiedId VALUETYPE_NAME;
    public static CppQualifiedId IDISPOSABLE_NAME;
    public static CppQualifiedId ENUM_NAME;
    public static CppQualifiedId TYPE_NAME;
    public static CppQualifiedId DEFAULT_NAME;
    public static CppQualifiedId ARRAY_NAME;
    public static CppQualifiedId ARRAY2_NAME;
    public static CppQualifiedId MULTICAST_DELEGATE_NAME;
    public static CppQualifiedId RANK_NAME;
    public static CppQualifiedId COLLECTIONS_NAME;
    public static CppQualifiedId GENERIC_NAME;
    public static CppQualifiedId IENUMERABLE_NAME;
    public static CppQualifiedId VOID_NAME;
    public static CppQualifiedId CAP_G_GET_NAME;
    public static CppQualifiedId GET_NAME;
    public static CppQualifiedId SET_NAME;
    public static CppQualifiedId DATA_NAME;
    public static CppQualifiedId VALUE_NAME;
    public static CppQualifiedId TO_STRING_NAME;
    public static CppQualifiedId TOSTRING_NAME;
    public static CppQualifiedId BOOST_NAME;
    public static CppQualifiedId ADD_NAME;
    public static CppQualifiedId REMOVE_NAME;
    public static CppQualifiedId RAISE_NAME;
    public static CppQualifiedId RANGES_NAME;
    public static CppQualifiedId VIEWS_NAME;
    public static CppQualifiedId BEGIN_NAME;
    public static CppQualifiedId END_NAME;
    public static CppQualifiedId VECTOR;
    public static CppQualifiedId ITERATOR;
    public static CppQualifiedId CONST_ITERATOR;
    public static CppQualifiedId CONCEPT_NAME;
    public static CppQualifiedId PTR_ARRAY_NAME;
    public static CppQualifiedId Rs__func__;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public CppQualifiedId(string name);
    private static CppQualifiedId();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    public bool Equals(CppQualifiedNamePart rhs);
    public virtual bool Equals(object rhs);
    public bool Equals(CppQualifiedId that);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppQualifiedName : ValueType {
    public static CppQualifiedName LAMBDA;
    public static CppQualifiedName DEFAULT;
    public static CppQualifiedName RANK;
    private object myParent;
    private CppQualifiedNamePart myName;
    public CppQualifiedNamePart Name { get; }
    public CppQualifiedName Qualifier { get; }
    public string DbgDescription { get; }
    private CppQualifiedName(object parent, CppQualifiedNamePart name);
    private static CppQualifiedName();
    public static CppQualifiedName Create(CppQualifiedName parent, CppQualifiedNamePart name);
    public static CppQualifiedName Create(CppQualifiedNamePart parent, CppQualifiedNamePart name);
    public static CppQualifiedName Create(CppQualifiedNamePart name);
    public bool IsValid();
    public CppQualifiedNamePart get_Name();
    public CppQualifiedName get_Qualifier();
    public bool HasQualifier();
    public virtual bool Equals(object rhs);
    public sealed virtual bool Equals(CppQualifiedName other);
    public bool ReferentiallyEquals(CppQualifiedName other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string get_DbgDescription();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppQualifiedNameBuilder : ValueType {
    private CppQualifiedName myName;
    private bool myIgnoreConversionType;
    public CppQualifiedNameBuilder(bool ignoreConversionType);
    public CppQualifiedNameBuilder(CppQualifiedName name);
    public sealed virtual void LearnId(string id);
    public sealed virtual void LearnAnonymousId();
    public sealed virtual void LearnDestructorTag(string tag);
    public sealed virtual void LearnOperatorId(CppOperatorKind kind);
    public void LearnConversionId(CppQualType convType);
    public sealed virtual void LearnConversionId(ICppDeclarationBuilder declBuilder);
    public sealed virtual void LearnUserDefinedLiteralId(string id);
    public sealed virtual ICppDeclarationBuilder CreateDeclarationBuilderForConversion(ICppBuilder parent);
    public sealed virtual void LearnDecltypeDestructorTag();
    public sealed virtual void LearnDecltype(CppExpressionBuilder exprBuilder, CppDecltypeKind kind);
    public sealed virtual void LearnDecltypeBoxed(ICppExpressionBuilder exprBuilder, CppDecltypeKind kind);
    public void LearnDecltype(ICppExpression expr, CppDecltypeKind kind);
    public sealed virtual void LearnTypeOfType(ICppDeclarationBuilder declBuilder, CppDecltypeKind kind);
    public void LearnTypeOfType(CppQualType qualType, CppDecltypeKind kind);
    public sealed virtual void LearnGlobalNamespaceId();
    public sealed virtual void LearnMSSuperId();
    public sealed virtual void LearnCliSimpleTypeId(CppQualType type);
    public sealed virtual void LearnCliFinalizerTag(string tag);
    public void LearnNamePart(CppQualifiedNamePart part);
    public sealed virtual void LearnTemplateArguments(CppTemplateArgumentsBuilder templArgsBuilder);
    public sealed virtual void LearnTemplateArgumentsBoxed(ICppTemplateArgumentsBuilder builder);
    public void LearnTemplateArguments(ICppTemplateArgument[] args);
    public CppQualifiedName GetRawName();
    public sealed virtual CppExpressionBuilder CreateExpressionBuilder(bool createSymbols);
    public sealed virtual ICppExpressionBuilder CreateExpressionBuilderBoxed(bool createSymbols);
    public sealed virtual CppTemplateArgumentsBuilder CreateTemplateArgumentsBuilder();
    public sealed virtual ICppTemplateArgumentsBuilder CreateTemplateArgumentsBuilderBoxed();
    public sealed virtual CppQualifiedName GetRawNameForLookup();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppQualifiedNameBuilderUtil : object {
    [ExtensionAttribute]
public static CppQualifiedName NameForEntity(CppQualifiedName name);
    [ExtensionAttribute]
public static CppQualifiedName NameForReference(CppQualifiedName name);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppQualifiedNamePart : ValueType {
    public object Representation;
    public static CppQualifiedNamePart FromRepresentation(object repr);
    public Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public sealed virtual bool Equals(CppQualifiedNamePart other);
    public bool Equals(CppQualifiedId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CppQualifiedNamePart op_Implicit(CppQualifiedId name);
    public static CppQualifiedNamePart op_Implicit(CppAnonymousId name);
    public static CppQualifiedNamePart op_Implicit(CppDestructorTag name);
    public static CppQualifiedNamePart op_Implicit(CppOperatorId name);
    public static CppQualifiedNamePart op_Implicit(CppUserDefinedLiteralId name);
    public static CppQualifiedNamePart op_Implicit(CppDecltypeDestructorTag name);
    public static CppQualifiedNamePart op_Implicit(CppGlobalNamespaceId name);
    public static CppQualifiedNamePart op_Implicit(CppMSSuperId name);
    public static CppQualifiedNamePart op_Implicit(CppLambdaId name);
    public static CppQualifiedNamePart op_Implicit(CppConversionsPackId name);
    public static CppQualifiedNamePart op_Implicit(CppCliFinalizerTag name);
    public static CppQualifiedNamePart op_Implicit(CppConversionId name);
    public static CppQualifiedNamePart op_Implicit(CppDecltypeId name);
    public static CppQualifiedNamePart op_Implicit(CppTypeOfTypeId name);
    public static CppQualifiedNamePart op_Implicit(CppResolvedStructuredBindingId name);
    public static CppQualifiedNamePart op_Implicit(CppUnresolvedStructuredBindingId name);
    public static CppQualifiedNamePart op_Implicit(CppCliSimpleTypeId name);
    public static CppQualifiedNamePart op_Implicit(CppTemplateId name);
    public static CppQualifiedNamePart op_Implicit(CppSubstitutionId name);
    public static CppQualifiedNamePart op_Implicit(CppAnonymousLinkageId name);
    public static CppQualifiedNamePart op_Implicit(CppLinkageTemplateId name);
    public static CppQualifiedNamePart op_Implicit(CppModuleTemplateId name);
    public static CppQualifiedNamePart op_Implicit(CppModuleSubstitutionId name);
    public static CppQualifiedNamePart op_Implicit(CppDecoratedNamePart name);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppQualifiedNamePartUtil : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static Nullable`1<CppQualifiedId> AsQualifiedId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[CanBeNullAttribute]
[DebuggerStepThroughAttribute]
public static string GetQualifiedIdValue(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppQualifiedId CastToQualifiedId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsQualifiedId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppDestructorTag AsDestructorTag(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppDestructorTag CastToDestructorTag(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsDestructorTag(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsAnonymousId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppOperatorId AsOperatorId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppOperatorId CastToOperatorId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsOperatorId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppUserDefinedLiteralId AsUserDefinedLiteralId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppUserDefinedLiteralId CastToUserDefinedLiteralId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsUserDefinedLiteralId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsDecltypeDestructorTag(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsGlobalNamespaceId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsMSSuperId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsLambdaId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsConversionsPackId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppCliFinalizerTag AsCliFinalizerTag(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppCliFinalizerTag CastToCliFinalizerTag(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsCliFinalizerTag(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppConversionId AsConversionId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppConversionId CastToConversionId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsConversionId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppDecltypeId AsDecltypeId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppDecltypeId CastToDecltypeId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsDecltypeId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppTypeOfTypeId AsTypeOfTypeId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppTypeOfTypeId CastToTypeOfTypeId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsTypeOfTypeId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppResolvedStructuredBindingId AsResolvedStructuredBindingId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppResolvedStructuredBindingId CastToResolvedStructuredBindingId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsResolvedStructuredBindingId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppUnresolvedStructuredBindingId AsUnresolvedStructuredBindingId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppUnresolvedStructuredBindingId CastToUnresolvedStructuredBindingId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsUnresolvedStructuredBindingId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppCliSimpleTypeId AsCliSimpleTypeId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppCliSimpleTypeId CastToCliSimpleTypeId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsCliSimpleTypeId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppTemplateId AsTemplateId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppTemplateId CastToTemplateId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsTemplateId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppSubstitutionId AsSubstitutionId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppSubstitutionId CastToSubstitutionId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsSubstitutionId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppAnonymousLinkageId AsAnonymousLinkageId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppAnonymousLinkageId CastToAnonymousLinkageId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsAnonymousLinkageId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppLinkageTemplateId AsLinkageTemplateId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppLinkageTemplateId CastToLinkageTemplateId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsLinkageTemplateId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppModuleTemplateId AsModuleTemplateId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppModuleTemplateId CastToModuleTemplateId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsModuleTemplateId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppModuleSubstitutionId AsModuleSubstitutionId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppModuleSubstitutionId CastToModuleSubstitutionId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsModuleSubstitutionId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppDecoratedNamePartWithData`1<T> AsDecoratedNamePartWithData(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppDecoratedNamePartWithData`1<T> CastToDecoratedNamePartWithData(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsDecoratedNamePartWithData(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsNull(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsNotNull(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsNull(CppQualifiedId name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsNotNull(CppQualifiedId name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool RepresentationReferenceEquals(CppQualifiedNamePart lhs, CppQualifiedNamePart rhs);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppQualifiedNameSymbolComparer : object {
    public static CppQualifiedNameSymbolComparer INSTANCE;
    private static CppQualifiedNameSymbolComparer();
    public sealed virtual bool Equals(ICppParserSymbol lhs, ICppParserSymbol rhs);
    public sealed virtual int GetHashCode(ICppParserSymbol obj);
    public static bool QualifiedNameEquals(ICppSymbol lhs, ICppSymbol rhs);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppQualifiedNameSymbolEqualsVisitor : CppSymbolEqualsVisitor {
    public CppQualifiedNameSymbolEqualsVisitor(ICppSymbol symbol, ICppEqualityComparer engine);
    protected virtual bool VisitScopeSymbol(CppScopeSymbol lhs);
    protected virtual bool VisitParserSymbol(ICppParserSymbol lhs);
    protected virtual bool VisitSymbol(ICppSymbol lhs);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppQualifiedNameUtil : object {
    [ExtensionAttribute]
public static bool IsQualifiedIdWithName(CppQualifiedNamePart namePart, string name);
    [ExtensionAttribute]
public static bool IsQualifiedIdWithName(CppQualifiedName qualName, string name);
    [ExtensionAttribute]
public static bool IsPrefixName(CppQualifiedName namePart, CppQualifiedName prefix);
    [ExtensionAttribute]
public static bool IsNewOperator(CppQualifiedNamePart namePart);
    [ExtensionAttribute]
public static CppQualifiedName DropLastSubstitutionId(CppQualifiedName name);
    [ExtensionAttribute]
public static CppQualifiedName DropLastTemplateId(CppQualifiedName name);
    [ExtensionAttribute]
public static CppQualifiedNamePart DropFirstArgument(CppSubstitutionId name);
    [ExtensionAttribute]
public static string GetShortName(CppQualifiedNamePart name);
    [ExtensionAttribute]
public static string GetShortNameForDeclaredElement(CppQualifiedNamePart name);
    [ExtensionAttribute]
public static int GetNameLength(CppQualifiedName name);
    [ExtensionAttribute]
public static bool HasLength(CppQualifiedName name, int n);
    [ExtensionAttribute]
public static bool IsGlobalNamespace(CppQualifiedName name);
    [ExtensionAttribute]
public static CppQualifiedName DropGlobalNamespace(CppQualifiedName name);
    [ExtensionAttribute]
public static CppQualifiedName DropAnonymousNamespace(CppQualifiedName name);
    [ExtensionAttribute]
public static CppQualifiedName Append(CppQualifiedName head, CppQualifiedName tail);
    [ExtensionAttribute]
public static CppQualifiedName GetTail(CppQualifiedName name, int numParts);
    [ExtensionAttribute]
public static CppQualifiedNamePart GetConstructorNameByClass(CppQualifiedNamePart name);
    [ExtensionAttribute]
public static CppQualifiedNamePart GetDestructorNameByClass(CppQualifiedNamePart name);
    [ExtensionAttribute]
public static CppQualifiedNamePart GetFinalizerNameByClass(CppQualifiedNamePart name);
    [ExtensionAttribute]
public static CppQualifiedName DropLastPartIfAnonymousId(CppQualifiedName name);
    [ExtensionAttribute]
public static CppQualifiedName PrependName(CppQualifiedName prefix, CppQualifiedName suffix);
    [ExtensionAttribute]
public static CppQualifiedName PrependNamePart(CppQualifiedNamePart prefix, CppQualifiedName suffix);
    [ExtensionAttribute]
public static CppQualifiedName ReplaceLastPart(CppQualifiedName name, CppQualifiedNamePart part);
    public static string GetUserDefinedLiteralShortName(string suffix);
    [ExtensionAttribute]
public static bool IsUserDefinedLiteralIdOrTemplate(CppQualifiedNamePart name);
    [ExtensionAttribute]
public static bool IsOperatorIdOrTemplate(CppQualifiedNamePart namePart);
    [ExtensionAttribute]
public static bool CanBePresented(CppQualifiedName name);
    [ExtensionAttribute]
public static bool IsCatchTemplateTestName(CppQualifiedNamePart name);
    [ExtensionAttribute]
public static bool IsDoctestSuiteName(CppQualifiedNamePart name);
    [ExtensionAttribute]
public static bool IsDoctestTestCaseTemplateName(CppQualifiedNamePart name);
    [ExtensionAttribute]
public static bool ClassNameAllowsDestructors(CppQualifiedNamePart name);
    [ExtensionAttribute]
public static bool EqualsToDestructorNameForClass(CppQualifiedNamePart declaratorName, CppQualifiedNamePart className);
    [ExtensionAttribute]
public static bool EqualsToFinalizerNameForClass(CppQualifiedNamePart declaratorName, CppQualifiedNamePart className);
    public static CppQualifiedName NameForOperator(CppOperatorKind kind);
    [ExtensionAttribute]
public static CppQualifiedNamePart FlattenIfSubstitutionId(CppQualifiedNamePart name);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppQualifiedNameWithTag : ValueType {
    public CppClassTag Tag;
    public CppQualifiedName QualName;
    public CppQualifiedNameWithTag(CppClassTag tag, CppQualifiedName name);
    public CppQualifiedNameWithTag(CppQualifiedName name);
    public CppQualifiedNameWithTag WithChangedTag(CppClassTag newTag);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppQualifiedReferenceTemplateArgument : object {
    private CppQualifiedName myQualName;
    [CompilerGeneratedAttribute]
private bool <PackExpansion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HadTypename>k__BackingField;
    public bool PackExpansion { get; }
    public bool HadTypename { get; }
    public CppQualifiedReferenceTemplateArgument(CppQualifiedName qualName, bool isPackExpansion, bool hadTypename);
    [CompilerGeneratedAttribute]
public bool get_PackExpansion();
    [CompilerGeneratedAttribute]
public bool get_HadTypename();
    public sealed virtual Result Accept(Data data, ICppTemplateArgumentVisitor`2<Result, Data> visitor);
    public IEnumerable`1<ICppTemplateArgument> Unpack();
    public CppQualifiedName GetQualName();
    public virtual string ToString();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public sealed virtual ICppTemplateArgument Import(CppModuleImportingContext ctx);
    public sealed virtual CppModuleTemplateArgumentKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    internal static CppQualifiedReferenceTemplateArgument Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReExportedClassModuleEntity : CppReExportedClassOrEnumModuleEntity {
    public CppReExportedClassModuleEntity(CppModuleDescriptor definitionModule, int index);
    public virtual CppModuleEntityKind Kind();
    protected virtual CppModuleEntityKind InnerEntityKind();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReExportedClassOrEnumModuleEntity : CppReExportedModuleEntity {
    protected CppReExportedClassOrEnumModuleEntity(CppModuleDescriptor definitionModule, int index);
    public sealed virtual CppImportResult`1<ICppScopeResolveEntity> ImportScopeAutoParent(CppModuleImportingContext ctx);
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual ICppScopeModuleEntity GetParent();
    public sealed virtual bool IsExplicitlyExported();
    public sealed virtual CppClassModuleEntityKind GetKind();
    public sealed virtual CppImportResult`1<ICppClassResolveEntity> Import(CppModuleImportingContext ctx, ICppScopeResolveEntity targetParent, bool onlyFindExisting, bool addToParentScope);
    public CppImportResult`1<ICppClassResolveEntity> Import(CppModuleImportingContext ctx);
    protected abstract virtual CppModuleEntityKind InnerEntityKind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReExportedConceptDefinitionModuleEntity : CppReExportedModuleEntity {
    public CppReExportedConceptDefinitionModuleEntity(CppModuleDescriptor definitionModule, int index);
    public virtual CppModuleEntityKind Kind();
    public sealed virtual CppConceptDefinitionResolveEntity Import(CppModuleImportingContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReExportedEnumModuleEntity : CppReExportedClassOrEnumModuleEntity {
    public CppReExportedEnumModuleEntity(CppModuleDescriptor definitionModule, int index);
    public virtual CppModuleEntityKind Kind();
    protected virtual CppModuleEntityKind InnerEntityKind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReExportedFriendFunctionModuleEntity : CppReExportedModuleEntity {
    public CppReExportedFriendFunctionModuleEntity(CppModuleDescriptor definitionModule, int index);
    public virtual CppModuleEntityKind Kind();
    public sealed virtual CppImportResult`1<ICppFunctionDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReExportedFunctionModuleEntityBase : CppReExportedModuleEntity {
    protected CppReExportedFunctionModuleEntityBase(CppModuleDescriptor definitionModule, int index);
    public sealed virtual CppImportResult`1<ICppGroupedFunctionDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
    public CppImportResult`1<ICppFunctionDeclaratorResolveEntity> ImportUngrouped(CppModuleImportingContext ctx);
    protected abstract virtual CppModuleEntityKind InnerEntityKind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReExportedFunctionWithTypeModuleEntity : CppReExportedFunctionModuleEntityBase {
    public CppReExportedFunctionWithTypeModuleEntity(CppModuleDescriptor definitionModule, int index);
    public virtual CppModuleEntityKind Kind();
    protected virtual CppModuleEntityKind InnerEntityKind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReExportedFunctionWithTypePartsModuleEntity : CppReExportedFunctionModuleEntityBase {
    public CppReExportedFunctionWithTypePartsModuleEntity(CppModuleDescriptor definitionModule, int index);
    public virtual CppModuleEntityKind Kind();
    protected virtual CppModuleEntityKind InnerEntityKind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReExportedFunctionWithTypePartsWithOptionalDataModuleEntity : CppReExportedFunctionModuleEntityBase {
    public CppReExportedFunctionWithTypePartsWithOptionalDataModuleEntity(CppModuleDescriptor definitionModule, int index);
    public virtual CppModuleEntityKind Kind();
    protected virtual CppModuleEntityKind InnerEntityKind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReExportedFunctionWithTypeWithOptionalDataModuleEntity : CppReExportedFunctionModuleEntityBase {
    public CppReExportedFunctionWithTypeWithOptionalDataModuleEntity(CppModuleDescriptor definitionModule, int index);
    public virtual CppModuleEntityKind Kind();
    protected virtual CppModuleEntityKind InnerEntityKind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReExportedLambdaCloseTypeModuleEntity : CppReExportedClassOrEnumModuleEntity {
    private CppLambdaSymbol mySymbol;
    public CppReExportedLambdaCloseTypeModuleEntity(CppModuleDescriptor definitionModule, int index, CppLambdaSymbol symbol);
    public virtual CppModuleEntityKind Kind();
    protected virtual CppModuleEntityKind InnerEntityKind();
    public sealed virtual CppLambdaSymbol GetSymbol();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReExportedModuleEntity : object {
    private CppModuleDescriptor myDefinitionModule;
    private int myIndex;
    protected CppReExportedModuleEntity(CppModuleDescriptor definitionModule, int index);
    protected InnerImportResult`1<TModuleEntity> InnerImport(CppModuleEntityKind kind, CppModuleImportingContext currentlyImportingModule);
    private CppModuleImportingContext GetImportContextForInnerEntity(CppModuleImportingContext currentlyImportingModule);
    public abstract virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReExportedTemplateFunctionSpecializationModuleEntity : CppReExportedFunctionModuleEntityBase {
    public CppReExportedTemplateFunctionSpecializationModuleEntity(CppModuleDescriptor definitionModule, int index);
    public virtual CppModuleEntityKind Kind();
    protected virtual CppModuleEntityKind InnerEntityKind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReExportedTemplateVariableSpecializationModuleEntity : CppReExportedModuleEntity {
    public CppReExportedTemplateVariableSpecializationModuleEntity(CppModuleDescriptor definitionModule, int index);
    public virtual CppModuleEntityKind Kind();
    public sealed virtual CppImportResult`1<ICppGroupedVariableDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReExportedTypeAliasModuleEntity : CppReExportedModuleEntity {
    public CppReExportedTypeAliasModuleEntity(CppModuleDescriptor definitionModule, int index);
    public virtual CppModuleEntityKind Kind();
    public sealed virtual CppImportResult`1<ICppGroupedTypeDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReExportedVariableModuleEntity : CppReExportedModuleEntity {
    public CppReExportedVariableModuleEntity(CppModuleDescriptor definitionModule, int index);
    public virtual CppModuleEntityKind Kind();
    public sealed virtual CppImportResult`1<ICppGroupedVariableDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRefConstraint : object {
    public static CppRefConstraint INSTANCE;
    private static CppRefConstraint();
    public virtual string ToString();
}
internal enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppReferenceValueKind : Enum {
    public byte value__;
    public static CppReferenceValueKind ReferenceToDeclarator;
    public static CppReferenceValueKind ReferenceToField;
    public static CppReferenceValueKind ReferenceToTemplateParameterObject;
    public static CppReferenceValueKind ReferenceToArrayElement;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReferentialClassOrEnumModuleEntity : object {
    public ICppClassOrRefClassModuleEntity PrimaryTemplate;
    public CppSmallArray`1<ICppModuleTemplateArgument> TemplateArguments;
    public ICppClassOrDelegateSymbol[] AdditionalSymbols;
    public CppReferentialClassOrEnumModuleEntity(ICppClassOrRefClassModuleEntity primaryTemplate, CppSmallArray`1<ICppModuleTemplateArgument> templargs);
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual ICppScopeModuleEntity GetParent();
    public sealed virtual CppClassModuleEntityKind GetKind();
    public sealed virtual bool IsExplicitlyExported();
    public virtual CppImportResult`1<ICppClassResolveEntity> Import(CppModuleImportingContext ctx, ICppScopeResolveEntity targetParent, bool onlyFindExisting, bool addToParentScope);
    protected virtual CppImportResult`1<ICppClassResolveEntity> ImportPrimaryTemplate(CppModuleImportingContext ctx, ICppScopeResolveEntity targetParent, bool onlyFindExisting, bool addToParentScope);
    public sealed virtual CppImportResult`1<ICppScopeResolveEntity> ImportScopeAutoParent(CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReferentialEnumeratorModuleEntity : object {
    public ICppReferentialClassOrEnumModuleEntity Parent;
    public CppQualifiedNamePart Name;
    public CppReferentialEnumeratorModuleEntity(ICppReferentialClassOrEnumModuleEntity parent, CppQualifiedNamePart name);
    public sealed virtual ICppClassOrRefClassModuleEntity GetParent();
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRegularFunctionModuleEntity : object {
    public CppQualifiedNamePart Name;
    private UInt32 myFlags;
    public IEnumerable`1<ICppSymbol> Symbols;
    [CanBeNullAttribute]
public CppParameterListModuleEntityBase ParamList;
    public int Index;
    private static int HasFriendAndNonFriendPartsOffset;
    private static int GeneratedFunctionKindOffset;
    private static int IsExplicitlyExportedOffset;
    private static int AccessibilityOffset;
    private static int PureVirtualSpecifiersOffset;
    private static int DeclarationSpecifiersOffset;
    [CanBeNullAttribute]
public ICppExpression RequiresClause { get; }
    [CanBeNullAttribute]
public CppCompoundStatementModuleEntity Body { get; }
    public CppSmallArray`1<ICppAttribute> Attributes { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; public set; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAccessibility Accessibility { get; }
    public bool HasFriendAndNonFriendParts { get; public set; }
    protected CppRegularFunctionModuleEntity(int index, CppQualifiedNamePart name, CppDeclarationSpecifiers declarationSpecifiers, CppPureVirtualSpecifiers pureVirtualSpecifiers, CppAccessibility accessibility, IEnumerable`1<ICppSymbol> symbols);
    protected CppRegularFunctionModuleEntity(int index);
    public virtual ICppExpression get_RequiresClause();
    public virtual CppCompoundStatementModuleEntity get_Body();
    public virtual CppSmallArray`1<ICppAttribute> get_Attributes();
    internal abstract virtual void SetBody(CppCompoundStatementModuleEntity body);
    public CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public void set_DeclarationSpecifiers(CppDeclarationSpecifiers value);
    public CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public CppAccessibility get_Accessibility();
    private bool GetFlag(int offset);
    private void SetFlag(int offset, bool value);
    public CppGeneratedResolveEntityType GetGeneratedFunctionKind();
    public void SetGeneratedFunctionKind(CppGeneratedResolveEntityType type);
    internal void SetGeneratedFunctionKind(GeneratedFunctionKind value);
    public bool get_HasFriendAndNonFriendParts();
    public void set_HasFriendAndNonFriendParts(bool value);
    public sealed virtual bool IsExplicitlyExported();
    public void SetExplicitlyExported(bool value);
    public sealed virtual CppQualifiedNamePart GetName();
    public abstract virtual CppQualType ImportType(CppModuleImportingContext ctx);
    public abstract virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
internal static void AssertNameIsTemplateId(ICppFunctionModuleEntity func);
    public abstract virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
internal static CppRegularFunctionModuleEntity <AssertNameIsTemplateId>g__GetInnerRegularFunction|42_0(ICppFunctionModuleEntity func, Boolean& isReExportedFunction);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRegularFunctionModuleEntityWithType : CppRegularNormalFunctionModuleEntity {
    public CppQualType Type;
    public CppRegularFunctionModuleEntityWithType(int index, ICppScopeModuleEntity parent, CppQualifiedNamePart name, CppDeclarationSpecifiers declarationSpecifiers, CppPureVirtualSpecifiers pureVirtualSpecifiers, CppAccessibility accessibility, IEnumerable`1<ICppSymbol> symbols);
    internal CppRegularFunctionModuleEntityWithType(int index);
    internal virtual void SetRequiresClause(ICppExpression requiresClause);
    internal virtual void SetBody(CppCompoundStatementModuleEntity body);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public virtual CppQualType ImportType(CppModuleImportingContext ctx);
    public virtual CppQualType[] GetParameterTypes();
    public virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRegularFunctionModuleEntityWithTypeParts : CppRegularNormalFunctionModuleEntity {
    public CppQualType[] ParameterTypes;
    private CppType myUnqualifiedReturnType;
    private ushort myReturnTypePackedQuals;
    private ushort myReturnTypeDeclSpecPlacement;
    private UInt32 myFlags;
    private static int QualifiersOffset;
    private static int CallingConventionOffset;
    private static int HasTrailingReturnTypeOffset;
    public CppQualType ReturnType { get; public set; }
    public CppRegularFunctionModuleEntityWithTypeParts(int index, ICppScopeModuleEntity parent, CppQualifiedNamePart name, CppDeclarationSpecifiers declarationSpecifiers, CppPureVirtualSpecifiers pureVirtualSpecifiers, CppAccessibility accessibility, IEnumerable`1<ICppSymbol> symbols);
    internal CppRegularFunctionModuleEntityWithTypeParts(int index);
    public CppQualType get_ReturnType();
    public void set_ReturnType(CppQualType value);
    internal void Pack(CppCallingConvention callingConvention, CppRestrictionSpecifiers restrictionSpecifiers, bool hasTrailingReturnType, Qualifiers qualifiers);
    internal virtual void SetRequiresClause(ICppExpression requiresClause);
    internal virtual void SetBody(CppCompoundStatementModuleEntity body);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public virtual CppQualType ImportType(CppModuleImportingContext ctx);
    public virtual CppQualType[] GetParameterTypes();
    private CppQualType[] ImportFunctionParameterTypes(CppModuleImportingContext ctx);
    public sealed virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRegularFunctionModuleEntityWithTypePartsWithOptionalData : CppRegularFunctionModuleEntityWithTypeParts {
    private OptionalData myOptionalData;
    public ICppExpression RequiresClause { get; }
    public CppCompoundStatementModuleEntity Body { get; }
    public CppSmallArray`1<ICppAttribute> Attributes { get; }
    public CppRegularFunctionModuleEntityWithTypePartsWithOptionalData(int index, ICppScopeModuleEntity parent, CppQualifiedNamePart name, CppDeclarationSpecifiers declarationSpecifiers, CppPureVirtualSpecifiers pureVirtualSpecifiers, CppAccessibility accessibility, IEnumerable`1<ICppSymbol> symbols, CppSmallArray`1<ICppAttribute> attributes);
    internal CppRegularFunctionModuleEntityWithTypePartsWithOptionalData(int index);
    internal virtual void SetRequiresClause(ICppExpression requiresClause);
    internal virtual void SetBody(CppCompoundStatementModuleEntity body);
    public virtual ICppExpression get_RequiresClause();
    public virtual CppCompoundStatementModuleEntity get_Body();
    public virtual CppSmallArray`1<ICppAttribute> get_Attributes();
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRegularFunctionModuleEntityWithTypeWithOptionalData : CppRegularFunctionModuleEntityWithType {
    private OptionalData myOptionalData;
    public ICppExpression RequiresClause { get; }
    public CppCompoundStatementModuleEntity Body { get; }
    public CppSmallArray`1<ICppAttribute> Attributes { get; }
    public CppRegularFunctionModuleEntityWithTypeWithOptionalData(int index, ICppScopeModuleEntity parent, CppQualifiedNamePart name, CppDeclarationSpecifiers declarationSpecifiers, CppPureVirtualSpecifiers pureVirtualSpecifiers, CppAccessibility accessibility, IEnumerable`1<ICppSymbol> symbols);
    internal CppRegularFunctionModuleEntityWithTypeWithOptionalData(int index);
    internal virtual void SetRequiresClause(ICppExpression requiresClause);
    internal virtual void SetBody(CppCompoundStatementModuleEntity body);
    internal void SetAttributes(CppSmallArray`1<ICppAttribute> attributes);
    public virtual ICppExpression get_RequiresClause();
    public virtual CppCompoundStatementModuleEntity get_Body();
    public virtual CppSmallArray`1<ICppAttribute> get_Attributes();
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRegularNormalFunctionModuleEntity : CppRegularFunctionModuleEntity {
    public ICppScopeModuleEntity Parent;
    protected CppRegularNormalFunctionModuleEntity(int index, ICppScopeModuleEntity parent, CppQualifiedNamePart name, CppDeclarationSpecifiers declarationSpecifiers, CppPureVirtualSpecifiers pureVirtualSpecifiers, CppAccessibility accessibility, IEnumerable`1<ICppSymbol> symbols);
    internal CppRegularNormalFunctionModuleEntity(int index);
    public sealed virtual ICppScopeModuleEntity GetParent();
    internal abstract virtual void SetRequiresClause(ICppExpression requiresClause);
    public sealed virtual CppImportResult`1<ICppGroupedFunctionDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
    public abstract virtual CppQualType[] GetParameterTypes();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReplacedBaseTypeConstraint : object {
    private CppViewPos myViewPos;
    private CppQualType myBaseType;
    public CppReplacedBaseTypeConstraint(CppQualType baseType, CppViewPos& viewPos);
    public virtual string ToString();
    public CppQualType GetBaseType();
    public CppViewPos GetViewPos();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionBuilder : object {
    private CppRequiresExpressionSymbol mySymbol;
    private CppRequiresExpressionScopeResolveEntity myScopeResolveEntity;
    private ICppBuilder myParent;
    private CppParameterListBuilder myParamListBuilder;
    private CppLocationAnchor myBodyStartAnchor;
    private CppList`1<CppRequiresExpressionItemSymbol> myItemSymbols;
    private CppList`1<CppRequiresExpressionItemResolveEntity> myItemEntities;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public CppRequiresExpressionBuilder(ICppBuilder parent);
    public CppRequiresExpressionSymbol GetSymbol();
    public CppRequiresExpressionScopeResolveEntity GetScopeResolveEntity();
    public ICppBuilder GetParent();
    public CppParameterListBuilder GetParameterListBuilder();
    public void LearnLocation(CppSymbolLocation location);
    public void LearnParameterList(CppParameterListBuilder paramListBuilder);
    public void BeginBody();
    public void LearnItem(CppRequiresExpressionItemBuilder& builder);
    public void Finish();
    public sealed virtual void AddChild(CppParserSymbol _);
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionItemBuilder : ValueType {
    private CppComplexOffset myLocation;
    private CppLocationAnchor myLocationAnchor;
    private ICppExpression myUnresolvedExpression;
    private ICppExpression myReplacedExpression;
    private bool myNoExcept;
    private CppQualifiedName myUnresolvedName;
    private CppQualifiedName myReplacedName;
    private CppQualType myUnresolvedReturnType;
    private CppQualType myReplacedReturnType;
    private CppRequiresExpressionItemSymbol mySymbol;
    private CppRequiresExpressionItemResolveEntity myEntity;
    private CppRequiresExpressionBuilder myParent;
    public CppRequiresExpressionItemBuilder(CppRequiresExpressionBuilder parent);
    public CppRequiresExpressionItemSymbol GetSymbol();
    public CppRequiresExpressionItemResolveEntity GetEntity();
    public void LearnLocation(CppComplexOffset location);
    public void LearnExpression(CppTwinExpressionBuilder& builder);
    public void LearnNoExcept();
    public void LearnQualifiedName(CppTwinQualifiedNameBuilder& builder);
    public void LearnReturnTypeConstraint(CppTwinQualifiedNameBuilder& builder);
    public void LearnReturnType(ICppDeclarationBuilder builder);
    public void BuildSimple();
    public void BuildTypename();
    public void BuildNested();
    public void BuildCompound();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionItemCompoundResolveEntity : CppRequiresExpressionItemResolveEntityExpr {
    private CppQualType myReturnType;
    private CppRequiresExpressionReturnTypeParameter myReturnTypeConstraint;
    [CompilerGeneratedAttribute]
private bool <NoExcept>k__BackingField;
    public bool NoExcept { get; }
    public ICppExpression ReturnTypeConstraint { get; }
    public CppQualType ReturnType { get; }
    public CppRequiresExpressionItemCompoundResolveEntity(ICppRequiresExpressionScopeResolveEntity parent, CppLocationAnchor location, CppRequiresExpressionItemSymbol symbol, ICppExpression expr, bool noExcept, CppQualifiedName returnTypeCon, CppQualType returnType);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NoExcept();
    public sealed virtual ICppExpression get_ReturnTypeConstraint();
    public sealed virtual CppQualType get_ReturnType();
    public virtual Result Accept(ICppRequiresExpressionItemVisitor`1<Result> visitor);
    public virtual string ToString();
    public virtual ICppRequiresExpressionItem Resolve();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionItemCompoundSymbol : CppRequiresExpressionItemSymbolExpr {
    [CompilerGeneratedAttribute]
private bool <NoExcept>k__BackingField;
    [CompilerGeneratedAttribute]
private CppQualifiedName <ReturnTypeConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private CppQualType <ReturnType>k__BackingField;
    public bool NoExcept { get; }
    public CppQualifiedName ReturnTypeConstraint { get; }
    public CppQualType ReturnType { get; }
    public CppRequiresExpressionItemCompoundSymbol(CppComplexOffset loc, ICppExpression expr, bool noExcept, CppQualifiedName returnTypeCon, CppQualType returnType);
    [CompilerGeneratedAttribute]
public bool get_NoExcept();
    [CompilerGeneratedAttribute]
public CppQualifiedName get_ReturnTypeConstraint();
    [CompilerGeneratedAttribute]
public CppQualType get_ReturnType();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual TResult Accept(ICppRequiresExpressionItemSymbolVisitor`1<TResult> visitor);
}
internal enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionItemKind : Enum {
    public byte value__;
    public static CppRequiresExpressionItemKind Simple;
    public static CppRequiresExpressionItemKind Typename;
    public static CppRequiresExpressionItemKind Nested;
    public static CppRequiresExpressionItemKind Compound;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionItemNestedResolveEntity : CppRequiresExpressionItemResolveEntityExpr {
    public CppRequiresExpressionItemNestedResolveEntity(ICppRequiresExpressionScopeResolveEntity parent, CppLocationAnchor location, CppRequiresExpressionItemSymbol symbol, ICppExpression expr);
    public virtual Result Accept(ICppRequiresExpressionItemVisitor`1<Result> visitor);
    public virtual string ToString();
    public virtual ICppRequiresExpressionItem Resolve();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionItemNestedSymbol : CppRequiresExpressionItemSymbolExpr {
    public CppRequiresExpressionItemNestedSymbol(CppComplexOffset loc, ICppExpression expr);
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual TResult Accept(ICppRequiresExpressionItemSymbolVisitor`1<TResult> visitor);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionItemResolveEntity : object {
    private static CppQualifiedNamePart ourName;
    private ICppRequiresExpressionScopeResolveEntity myParent;
    private CppRequiresExpressionItemSymbol mySymbol;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <LocationAnchor>k__BackingField;
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    protected CppRequiresExpressionItemResolveEntity(ICppRequiresExpressionScopeResolveEntity parent, CppLocationAnchor location, CppRequiresExpressionItemSymbol symbol);
    private static CppRequiresExpressionItemResolveEntity();
    public abstract virtual Result Accept(ICppRequiresExpressionItemVisitor`1<Result> visitor);
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    [CompilerGeneratedAttribute]
public virtual CppLocationAnchor get_LocationAnchor();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public ICppRequiresExpressionScopeResolveEntity GetParent();
    public CppRequiresExpressionItemSymbol GetSymbol();
    public virtual string ToString();
    public abstract virtual ICppRequiresExpressionItem Resolve();
    protected CppViewPos GetViewPos();
    protected CppTypeContext GetTypeContext();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionItemResolveEntityExpr : CppRequiresExpressionItemResolveEntity {
    [CompilerGeneratedAttribute]
private ICppExpression <Expression>k__BackingField;
    public ICppExpression Expression { get; }
    protected CppRequiresExpressionItemResolveEntityExpr(ICppRequiresExpressionScopeResolveEntity parent, CppLocationAnchor location, CppRequiresExpressionItemSymbol symbol, ICppExpression expr);
    [CompilerGeneratedAttribute]
public virtual ICppExpression get_Expression();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionItemSimpleResolveEntity : CppRequiresExpressionItemResolveEntityExpr {
    public CppRequiresExpressionItemSimpleResolveEntity(ICppRequiresExpressionScopeResolveEntity parent, CppLocationAnchor location, CppRequiresExpressionItemSymbol symbol, ICppExpression expr);
    public virtual Result Accept(ICppRequiresExpressionItemVisitor`1<Result> visitor);
    public virtual string ToString();
    public virtual ICppRequiresExpressionItem Resolve();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionItemSimpleSymbol : CppRequiresExpressionItemSymbolExpr {
    public CppRequiresExpressionItemSimpleSymbol(CppComplexOffset loc, ICppExpression expr);
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual TResult Accept(ICppRequiresExpressionItemSymbolVisitor`1<TResult> visitor);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionItemSymbol : CppParserSymbol {
    private static CppQualifiedName NAME;
    protected CppRequiresExpressionItemSymbol(CppComplexOffset loc);
    private static CppRequiresExpressionItemSymbol();
    public abstract virtual TResult Accept(ICppRequiresExpressionItemSymbolVisitor`1<TResult> visitor);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionItemSymbolExpr : CppRequiresExpressionItemSymbol {
    [CompilerGeneratedAttribute]
private ICppExpression <Expression>k__BackingField;
    public ICppExpression Expression { get; }
    protected CppRequiresExpressionItemSymbolExpr(CppComplexOffset loc, ICppExpression expr);
    [CompilerGeneratedAttribute]
public ICppExpression get_Expression();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionItemTypenameResolveEntity : CppRequiresExpressionItemResolveEntity {
    private CppQualType myType;
    public CppQualType Type { get; }
    public CppRequiresExpressionItemTypenameResolveEntity(ICppRequiresExpressionScopeResolveEntity parent, CppLocationAnchor location, CppRequiresExpressionItemSymbol symbol, CppQualType type);
    public sealed virtual CppQualType get_Type();
    public virtual Result Accept(ICppRequiresExpressionItemVisitor`1<Result> visitor);
    public virtual string ToString();
    public virtual ICppRequiresExpressionItem Resolve();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionItemTypenameSymbol : CppRequiresExpressionItemSymbol {
    [CompilerGeneratedAttribute]
private CppQualType <Type>k__BackingField;
    public CppQualType Type { get; }
    public CppRequiresExpressionItemTypenameSymbol(CppComplexOffset loc, CppQualType type);
    [CompilerGeneratedAttribute]
public CppQualType get_Type();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual TResult Accept(ICppRequiresExpressionItemSymbolVisitor`1<TResult> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionReturnTypeParameter : CppInventedConceptTypeTemplateParameter {
    public CppRequiresExpressionReturnTypeParameter(CppViewPos& viewPos, CppQualifiedName conceptName);
    public virtual CppTemplateParameterTag GetTag();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionScopeResolveEntity : CppScopeResolveEntityBase {
    private static string ourRawName;
    public static CppQualifiedNamePart StaticName;
    private CppRequiresExpressionSymbol myRequiresSymbol;
    [CanBeNullAttribute]
private List`1<ICppTemplateParameter> myTemplateDependencies;
    private Ref`1<CppList`1<ICppRequiresExpressionItem>> myCachedResolvedItems;
    private ICppParameterListResolveEntity myParameterList;
    private CppList`1<CppRequiresExpressionItemResolveEntity> myReplacedItems;
    public CppList`1<CppRequiresExpressionItemResolveEntity> ReplacedItems { get; public set; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppQualifiedNamePart Name { get; }
    public CppRequiresExpressionScopeResolveEntity(ICppResolveEntity parentScope, CppRequiresExpressionSymbol sym, CppLocationAnchor loc, List`1<ICppTemplateParameter> templateDependencies);
    private static CppRequiresExpressionScopeResolveEntity();
    internal void SetResolvedItems(CppList`1<ICppRequiresExpressionItem> items);
    public CppList`1<CppRequiresExpressionItemResolveEntity> get_ReplacedItems();
    public void set_ReplacedItems(CppList`1<CppRequiresExpressionItemResolveEntity> value);
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetExtraChildrenForDump();
    public sealed virtual CppRequiresExpressionSymbol GetRequiresSymbol();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual ICppParameterListResolveEntity GetParameterList();
    public sealed virtual int GetItemsCount();
    public virtual FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public sealed virtual CppList`1<ICppRequiresExpressionItem> GetResolvedItems();
    public virtual CppQualifiedNamePart get_Name();
    public sealed virtual List`1<ICppTemplateParameter> GetTemplateDependencies();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual TriBool Evaluate(CppExpressionEvaluator evaluator);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual string ToString();
    public void SetParameterList(ICppParameterListResolveEntity list);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionScopeResolveEntityWithSubstitution : CppScopeResolveEntityBase {
    private CppViewPos myPointOfInstantiation;
    private ICppRequiresExpressionScopeResolveEntity myInner;
    private CppSubstitutionContext mySubst;
    private List`1<ICppTemplateParameter> myTemplateDependencies;
    private CppParameterListWithSubstitution modreq(System.Runtime.CompilerServices.IsVolatile) myParameterList;
    private int myItemsCount;
    private bool myInProcessOfEvaluation;
    private CppList`1<ICppRequiresExpressionItem> myItems;
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppQualifiedNamePart Name { get; }
    public CppRequiresExpressionScopeResolveEntityWithSubstitution(ICppResolveEntity parentScope, CppViewPos& pointOfInstantiation, ICppRequiresExpressionScopeResolveEntity inner, CppSubstitutionContext subst);
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetExtraChildrenForDump();
    public sealed virtual CppRequiresExpressionSymbol GetRequiresSymbol();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual int GetItemsCount();
    public sealed virtual ICppParameterListResolveEntity GetParameterList();
    private void InstantiateParameterList(ICppFileResolveEntitiesCache resolveCache);
    public sealed virtual CppList`1<ICppRequiresExpressionItem> GetResolvedItems();
    private bool NotAllItemsAreInstantiated();
    private void InstantiateItems();
    public virtual CppQualifiedNamePart get_Name();
    public sealed virtual List`1<ICppTemplateParameter> GetTemplateDependencies();
    public sealed virtual CppViewPos GetViewPos();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual string ToString();
    [DebuggerStepThroughAttribute]
public CppSubstitutionContext GetSubstitution();
    [DebuggerStepThroughAttribute]
public ICppRequiresExpressionScopeResolveEntity GetInner();
    public sealed virtual TriBool Evaluate(CppExpressionEvaluator evaluator);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRequiresExpressionSymbol : CppParserSymbol {
    private static CppQualifiedName NAME;
    private int myAnchorDelta;
    [CompilerGeneratedAttribute]
private CppFileLocation <ContainingFile>k__BackingField;
    [CompilerGeneratedAttribute]
private CppParameterDeclaratorsData <ParametersData>k__BackingField;
    [CompilerGeneratedAttribute]
private CppSmallArray`1<CppRequiresExpressionItemSymbol> <Items>k__BackingField;
    public CppFileLocation ContainingFile { get; }
    public CppParameterDeclaratorsData ParametersData { get; public set; }
    public CppSmallArray`1<CppRequiresExpressionItemSymbol> Items { get; public set; }
    public CppRequiresExpressionSymbol(CppSymbolLocation loc);
    private static CppRequiresExpressionSymbol();
    [CompilerGeneratedAttribute]
public virtual CppFileLocation get_ContainingFile();
    [CompilerGeneratedAttribute]
public CppParameterDeclaratorsData get_ParametersData();
    [CompilerGeneratedAttribute]
public void set_ParametersData(CppParameterDeclaratorsData value);
    [CompilerGeneratedAttribute]
public CppSmallArray`1<CppRequiresExpressionItemSymbol> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(CppSmallArray`1<CppRequiresExpressionItemSymbol> value);
    public int GetAnchorDelta();
    public void SetAnchorDelta(int anchorDelta);
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveCheckerFuncFactory : object {
    public static Func`2<CppResolveResult, bool> CreateStrictChecker(ICppResolveEntity target, CppViewPos& vp);
    public static Func`2<CppResolveResult, bool> CreateAliasesIgnoringStrictChecker(ICppResolveEntity target, CppViewPos& vp);
    public static Func`2<CppResolveResult, bool> CreateResultContainsEntityChecker(ICppResolveEntity target, CppViewPos& vp);
    public static Func`2<CppResolveResult, bool> CreateResultContainsEntityChecker(ICppLinkageEntity target);
    public static Func`2<CppResolveResult, bool> CreateResolveResultIsEqualChecker(CppResolveResult& target);
    public static bool CheckResolveResultIsSameAsEntity(ICppResolveEntity entity, CppResolveResult& rr, CppViewPos& vp);
    private static bool CheckEntityIsContainedInResolveResult(ICppResolveEntity ent, CppResolveResult& rr, CppViewPos& vp);
    private static bool CheckEntityIsContainedInResolveResult(ICppLinkageEntity linkageEnt, CppResolveResult& rr);
    [ExtensionAttribute]
public static bool ResolveEntityMatchesLinkageEntity(ICppResolveEntity resolveEnt, ICppLinkageEntity linkageEnt);
    public static bool CheckResolveResultIsSameAsEntityIgnoringAliases(ICppResolveEntity entity, CppResolveResult& rr, CppViewPos& vp);
    private static bool IsSameResolveEntity(ICppResolveEntity fromResolveResult, ICppResolveEntity target, CppViewPos& viewPos);
    private static bool TryReResolveDependentNameFromCurrentInstantiation(ICppResolveEntity fromResolveResult, ICppResolveEntity target, CppViewPos& viewPos);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolvedStructuredBindingId : object {
    public CppUnresolvedStructuredBindingId Inner;
    public CppResolvedStructuredBindingId(CppUnresolvedStructuredBindingId inner);
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolvedTypeFunctionWithSubstitution : CppFunctionDeclaratorWithSubstitution {
    private CppQualType myResolvedType;
    public CppResolvedTypeFunctionWithSubstitution(ICppResolveEntityParent structuralParent, CppViewPos& vp, CppQualifiedNamePart name, ICppFunctionDeclaratorResolveEntity inner, ICppSubstitutionContext subst, CppQualType resolvedType);
    public sealed virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
    public CppQualType GetCachedType();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveEntitiesDetachedData : object {
    private ConcurrentDictionary`2<ICppClassResolveEntity, CppClassInheritanceInfo> myClassInheritanceInfoMap;
    private ConcurrentDictionary`2<ICppDeclaratorResolveEntity, TriBool> myIsDeclaratorOverrideMap;
    private ConcurrentDictionary`2<ICppDeclaratorResolveEntity, TriBool> myIsDeclaratorVirtualMap;
    private ConcurrentDictionary`2<ICppClassResolveEntity, CppSizeAndAlignment> mySizeAndAlignmentForClassWithoutVBasesMap;
    private ConcurrentDictionary`2<ICppClassResolveEntity, CppSizeAndAlignment> mySizeAndAlignmentForClassWithVBasesMap;
    private ICppRootFileResolveEntitiesCache myRootResolveCache;
    private Dictionary`2<Pair`2<CppQualType, CppQualType>, CppFunctionTraits> myAssignmentTraits;
    private ConcurrentDictionary`2<ICppClassResolveEntity, ICppGroupedVariableDeclaratorResolveEntity> myClassUuid;
    private ConcurrentDictionary`2<ICppScopeResolveEntity, CppScopeDepKillingResult> myScopeSubstitution;
    private Dictionary`2<CppClassTemplateResolveEntityPack, HashSet`1<ICppClassResolveEntity>> myClassPackToCustomSpecializations;
    private ConcurrentDictionary`2<ICppResolveEntity, string> myEntityToOwningModule;
    private Dictionary`2<ICppGroupedFunctionDeclaratorResolveEntity, Int32[]> myFunctionToDefaultedTemplateArguments;
    public CppResolveEntitiesDetachedData(ICppRootFileResolveEntitiesCache rootResolveCache);
    public IEnumerable`1<KeyValuePair`2<ICppDeclaratorResolveEntity, TriBool>> Journaling_QueryDeclaratorVirtualMap();
    public IEnumerable`1<KeyValuePair`2<ICppDeclaratorResolveEntity, TriBool>> Journaling_QueryDeclaratorOverrideMap();
    public bool TryGetIsDeclaratorVirtual(ICppDeclaratorResolveEntity entity, TriBool& isVirtual);
    public void SetIsDeclaratorVirtual(ICppDeclaratorResolveEntity entity, TriBool isVirtual);
    public bool TryGetIsDeclaratorOverride(ICppDeclaratorResolveEntity entity, TriBool& isOverride);
    public void SetIsDeclaratorOverride(ICppDeclaratorResolveEntity entity, TriBool isOverride);
    public bool TryGetSizeAndAlignmentForClassWithoutVBases(ICppClassResolveEntity entity, CppSizeAndAlignment& result);
    public CppSizeAndAlignment SetSizeAndAlignmentForClassWithoutVBases(ICppClassResolveEntity entity, CppSizeAndAlignment val);
    public bool TryGetSizeAndAlignmentForCompleteClassWithVBases(ICppClassResolveEntity entity, CppSizeAndAlignment& result);
    public CppSizeAndAlignment SetSizeAndAlignmentForCompleteClassWithVBases(ICppClassResolveEntity entity, CppSizeAndAlignment val);
    public bool TryGetClassInheritanceInfo(ICppClassResolveEntity entity, CppClassInheritanceInfo& result);
    public object SetClassInheritanceInfo(ICppClassResolveEntity entity, CppClassInheritanceInfo val);
    [CanBeNullAttribute]
public ICppGroupedVariableDeclaratorResolveEntity TryGetUuidOfClass(ICppClassResolveEntity clazz);
    public ICppGroupedVariableDeclaratorResolveEntity SetUuidOfClass(ICppClassResolveEntity clazz, ICppGroupedVariableDeclaratorResolveEntity uuid);
    public Nullable`1<CppScopeDepKillingResult> TryGetSubstitutionForDepKiller(ICppScopeResolveEntity scope);
    public CppScopeDepKillingResult SetSubstitutionForDepKiller(ICppScopeResolveEntity scope, CppScopeDepKillingResult subst);
    public bool TryGetAssignmentTraits(Pair`2<CppQualType, CppQualType> key, CppFunctionTraits& value);
    public void SetAssignmentTraits(Pair`2<CppQualType, CppQualType> key, CppFunctionTraits value);
    public void RemoveAssignmentTraits(Pair`2<CppQualType, CppQualType> key);
    public void AddCustomClassPackAndSpecialization(CppClassTemplateResolveEntityPack pack, ICppClassResolveEntity spec);
    public HashSet`1<ICppClassResolveEntity> GetCustomSpecializations(CppClassTemplateResolveEntityPack pack);
    public bool IsCustomSpecialization(ICppClassResolveEntity spec);
    internal void SetOwningModule(ICppResolveEntity entity, string module);
    [CanBeNullAttribute]
public string GetOwningModule(ICppResolveEntity entity);
    public void SetDefaultedTemplateArguments(ICppGroupedFunctionDeclaratorResolveEntity func, Int32[] defaultedTemplateArguments);
    public Int32[] GetDefaultedTemplateArguments(ICppGroupedFunctionDeclaratorResolveEntity func);
    private void AddJournalEntry(Dictionary`2<Key, Value> cache, Key key);
    private void AddJournalEntry(ConcurrentDictionary`2<Key, Value> cache, Key key);
    private void AddJournalEntry(HashSet`1<Key> cache, Key key);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveEntityAnchorComparer : object {
    public static CppResolveEntityAnchorComparer`1<ICppResolveEntity> Instance;
    private static CppResolveEntityAnchorComparer();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveEntityAnchorComparer`1 : object {
    public sealed virtual int Compare(TResolveEntity lhs, TResolveEntity rhs);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveEntityBase : object {
    private ICppResolveEntityParent myParent;
    private CppQualifiedNamePart myName;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <LocationAnchor>k__BackingField;
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    protected CppResolveEntityBase(ICppResolveEntityParent parent, CppQualifiedNamePart name, CppLocationAnchor anchor);
    public virtual ICppResolveEntityParent get_RealParent();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    [CompilerGeneratedAttribute]
public virtual CppLocationAnchor get_LocationAnchor();
    public abstract virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public abstract virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    protected void ReplaceName(CppQualifiedNamePart name);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveEntityCondition : ValueType {
    public ICppExpression ReplacedExpression;
    public CppLocationAnchor Location;
    private ICppResolvedExpression myCachedResolvedCondition;
    public ICppResolvedExpression GetResolvedExpression(ICppMutableStatementWithConditionResolveEntity scope);
    public void SetResolvedExpression(ICppResolvedExpression condition);
    public CppViewPos GetViewPos(ICppScopeResolveEntity scope, ICppFileResolveEntitiesCache resolveCache);
    private ICppResolvedExpression CalculateResolvedExpression(ICppScopeResolveEntity scope);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveEntityParentUtil : object {
    [ExtensionAttribute]
public static ICppResolveEntity QueryStructuralParent(ICppResolveEntityParent parent);
    [ExtensionAttribute]
public static ICppScopeResolveEntity QueryStructuralParent(ICppResolveEntityParentScope parent);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveEntitySemanticEqualityComparer : object {
    public static CppResolveEntitySemanticEqualityComparer Instance;
    private static CppResolveEntitySemanticEqualityComparer();
    public sealed virtual int GetHashCode(ICppResolveEntity ent);
    public sealed virtual bool Equals(ICppResolveEntity lhs, ICppResolveEntity rhs);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveEntityTraits : object {
    [ExtensionAttribute]
public static bool HasCtorAndDtorWithSideEffects(ICppClassResolveEntity ent);
    [ExtensionAttribute]
public static bool HasCtorAndDtorWithSideEffects(CppQualType qualType);
    [ExtensionAttribute]
public static bool HasCtorAndDtorWithSideEffectsRecursive(ICppClassResolveEntity clazz);
    [ExtensionAttribute]
public static bool HasCtorAndDtorWithSideEffectsRecursive(CppQualType type);
    [ExtensionAttribute]
public static bool IsStdByte(CppQualType type);
    [ExtensionAttribute]
private static bool IsBasicString(ICppClassResolveEntity ent, CppTypeContext& tc, CppQualType& valueType);
    [ExtensionAttribute]
public static bool IsBasicString(CppQualType type, CppTypeContext& tc, CppQualType& valueType);
    [ExtensionAttribute]
public static bool IsRawString(CppQualType type, CppQualType& valueType);
    [ExtensionAttribute]
public static bool IsCString(ICppClassResolveEntity ent, CppTypeContext& tc, CppQualType& valueType);
    [ExtensionAttribute]
public static bool IsStdMoveFunction(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsUE4MoveFunction(ICppResolveEntity ent, bool isUE4Solution);
    [ExtensionAttribute]
public static bool IsStdOrUE4MoveFunction(ICppResolveEntity ent, bool isUE4Solution);
    [ExtensionAttribute]
public static bool IsStdForwardFunction(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsUE4ForwardFunction(ICppResolveEntity ent, bool isUE4Solution);
    [ExtensionAttribute]
public static bool IsStdOrUE4ForwardFunction(ICppResolveEntity ent, bool isUE4Solution);
    [ExtensionAttribute]
public static bool IsStdVector(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsStdArray(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsStdFunction(ICppClassResolveEntity clazz);
    [ExtensionAttribute]
public static bool IsUEFunction(ICppClassResolveEntity clazz);
    [ExtensionAttribute]
public static bool IsUEFunctionRef(ICppClassResolveEntity clazz);
    [ExtensionAttribute]
public static bool IsStdUniquePointer(ICppTypeTemplateInstantiationResolveEntity ent);
    [ExtensionAttribute]
public static bool IsUE4UniquePointer(ICppTypeTemplateInstantiationResolveEntity ent);
    [ExtensionAttribute]
public static bool IsStdSharedPointer(ICppTypeTemplateInstantiationResolveEntity ent);
    [ExtensionAttribute]
public static bool IsUE4SharedPointer(ICppTypeTemplateInstantiationResolveEntity ent);
    [ExtensionAttribute]
public static bool IsUE4SharedRef(ICppTypeTemplateInstantiationResolveEntity ent);
    [ExtensionAttribute]
public static bool IsStdOrUE4SmartPointer(ICppTypeTemplateInstantiationResolveEntity ent, bool isUE4Solution);
    [ExtensionAttribute]
public static bool IsUEClassOrObjectFinder(CppQualType type);
    [ExtensionAttribute]
public static bool IsStdPointerCast(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsUE4PointerCast(ICppResolveEntity ent, bool isUE4Solution);
    [ExtensionAttribute]
public static bool IsUEGetOnlineSubsystemDeprecated(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsBoostFormat(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsBoostFormatStr(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsBoostStr(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsMainFunction(ICppFunctionDeclaratorResolveEntity decl);
    [ExtensionAttribute]
public static bool IsEnableIfTemplate(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsStdInitilializerList(ICppTypeTemplateInstantiationResolveEntity typeTemplate, CppQualType& outTemplArg);
    [ExtensionAttribute]
public static bool IsStdInitilializerListTemplate(ICppTypeTemplateResolveEntity cls);
    [ExtensionAttribute]
public static bool IsNamespaceWithName(ICppResolveEntity ent, CppQualifiedNamePart name);
    [ExtensionAttribute]
public static bool IsTopLevelNamespaceWithName(ICppResolveEntity ent, CppQualifiedNamePart name);
    [ExtensionAttribute]
public static bool IsStdNamespace(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsBoostNamespace(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsInternalStlEntity(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsInsideStdNamespace(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool HasUnusedAttribute(ICppDeclaratorResolveEntity decl);
    [ExtensionAttribute]
public static bool HasUnusedAttribute(ICppClassResolveEntity clazz);
    private static bool HasUnusedAttribute(CppAttributeList attributes);
    [ExtensionAttribute]
public static bool HasSideEffectsAttribute(ICppDeclaratorResolveEntity decl);
    private static bool HasSideEffectsAttribute(CppAttributeList attributes);
    [ExtensionAttribute]
public static bool HasConstructorOrDestructorAttribute(ICppDeclaratorResolveEntity decl);
    private static bool HasConstructorAttribute(CppAttributeList attributes);
    private static bool HasDestructorAttribute(CppAttributeList attributes);
    [ExtensionAttribute]
public static bool IsSystemValueType(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsSystemString(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsSystemObject(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsSystemNullable(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsSystemIEquatable(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsSystemIDisposable(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsSystemAnyDelegate(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsUE4TAtomic(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsUE4TAttribute(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsUE4TOptional(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsUE4TGuardValue(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsUE4FThreadSafeBool(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsUE4AutoConsoleVariable(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsUE4FLogCategory(ICppResolveEntity ent);
    [CanBeNullAttribute]
public static ICppGroupedTypeDeclaratorResolveEntity TryGetTypedefSynonimForStlBasicEntity(ICppClassResolveEntity classEnt);
    private static bool ThisEntityNameIs(ICppResolveEntity ent, string name);
    private static bool EntityNameIs(ICppResolveEntity ent, string name);
    private static bool EntityNameIs(ICppResolveEntity ent, string qual1, string name);
    private static bool EntityNameIsMemberFunction(ICppResolveEntity ent, string qual1, string classname, string name);
    private static bool EntityNameIsConstructor(ICppResolveEntity ent, string qual1, string name);
    private static CppQualifiedId TryGetTypedefSynonimNameForStlBasicEntity(CppSubstitutionId substId);
    private static string GetRawName(CppSubstitutionId name);
    private static ICppTypeTemplateArgument GetSingleTypeArgument(CppSubstitutionId name);
    private static ICppTypeTemplateArgument GetStdClassSingleTypeArgument(ICppTypeTemplateArgument typeArg, CppNamespaceResolveEntity std, string rawName);
    private static ICppTypeTemplateArgument GetElementType(ICppTypeTemplateArgument typeArg, CppNamespaceResolveEntity std);
    private static ICppGroupedTypeDeclaratorResolveEntity TryGetTypedef(ICppTypeTemplateArgument arg, CppNamespaceResolveEntity std, CppQualifiedId iterator);
    private static ICppGroupedTypeDeclaratorResolveEntity TryGetTypedefIterator(CppSubstitutionId name, CppNamespaceResolveEntity std);
    [ExtensionAttribute]
public static bool StdSymbolIsVisible(CppGlobalNamespaceResolveEntity globalNamespace, CppQualifiedId name);
    [CanBeNullAttribute]
public static ICppClassResolveEntity GetTypeInfo(CppViewPos viewPos);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveEntityUtil : object {
    [ExtensionAttribute]
public static CppAccessibility GetAccessibility(ICppParserSymbol symbol);
    [ExtensionAttribute]
public static CppAccessibility GetAccessibilityAt(ICppDeclaratorResolveEntity entity, ICppClassResolveEntity scope, CppViewPos& viewPos);
    [ExtensionAttribute]
public static bool IsAccessible(ICppResolveEntity e, ICppFriendDeclTargetResolveEntity accessScope, CppViewPos& viewPos);
    public static bool IsConversionAccessibleFrom(ICppClassResolveEntity derived, ICppClassResolveEntity base, CppViewPos& viewPos);
    public static bool IsConversionAccessibleFrom(ICppClassResolveEntity derived, ICppClassResolveEntity base, ICppFriendDeclTargetResolveEntity scope, CppViewPos& viewPos);
    private static CppAccessibility GetAccessibilityOfInventedPublicMember(ICppClassResolveEntity derived, IList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> chain);
    [ExtensionAttribute]
public static ICppClassResolveEntity GetNamingClass(ICppResolveEntity e);
    [ExtensionAttribute]
public static TriBool IsAccessibleFrom(ICppResolveEntity e, ICppClassResolveEntity& namingClass, ICppClassResolveEntity owningClass, ICppFriendDeclTargetResolveEntity scope, CppViewPos& viewPos);
    public static bool IsFriendFor(ICppClassResolveEntity cls, ICppFriendDeclTargetResolveEntity ent, CppViewPos& viewPos);
    private static bool IsFriendFor(ICppClassResolveEntity cls, ICppFunctionDeclaratorResolveEntity decl);
    private static bool IsFriendFor(ICppClassResolveEntity one, ICppClassResolveEntity other);
    [CanBeNullAttribute]
private static ICppClassResolveEntity DeriveEmbracingClassScope(ICppFriendDeclTargetResolveEntity scope);
    private static bool IsMemberOrFriendFor(ICppClassResolveEntity klass, ICppFriendDeclTargetResolveEntity scope, CppViewPos& viewPos);
    [ExtensionAttribute]
public static ICppClassResolveEntity GetEmbracingClassScope(ICppFriendDeclTargetResolveEntity scope, bool forceParent);
    private static ICppFriendDeclTargetResolveEntity GetOutermostNonLocalScope(ICppFriendDeclTargetResolveEntity scope);
    private static ICppClassResolveEntity DeriveOwningClass(ICppResolveEntity e);
    private static CppAccessibility GetAccessibilityAt(ResolveEntity entity, CppAccessibility acc, ICppClassResolveEntity classScope, CppViewPos& viewPos, Boolean& definedInClassOrAccessibleBase);
    private static ICppClassResolveEntity DeriveOwningClassHelper(ICppResolveEntity e, CppViewPos& viewPos, ICppFriendDeclTargetResolveEntity scope);
    [ExtensionAttribute]
public static CppQualifiedNameWithTag GetFullNameForEntity(ICppResolveEntity ent, CppViewPos& viewPos, ICppResolveEntity& resultEntity);
    [ExtensionAttribute]
public static CppQualifiedNameWithTag GetFullNameForEntity(ICppResolveEntity ent, CppViewPos& viewPos);
    [ExtensionAttribute]
public static CppQualifiedNameWithTag GetFullNameForEntity(ICppResolveEntity ent);
    [ExtensionAttribute]
public static CppQualifiedNameWithTag GetFullInnerNameForEntity(ICppResolveEntity ent, CppViewPos& viewPos);
    [ExtensionAttribute]
public static CppQualifiedNameWithTag GetFullInnerNameForEntity(ICppResolveEntity ent);
    [ExtensionAttribute]
public static CppQualifiedName GetNestedNameForEntity(ICppResolveEntity ent, CppViewPos& viewPos);
    [ExtensionAttribute]
public static CppQualifiedName GetNestedNameForEntity(ICppResolveEntity ent);
    public static CppQualifiedName GetFullNameForExclusionList(ICppResolveEntity ent);
    public static CppQualifiedNameWithTag FindSomeNameForPresentation(ICppResolveEntity& ent, CppViewPos& vp, CppSuggestedScopesCollection suggestedScopes, bool addWellKnownOrAssociatedTypeSynonyms, bool forceTag);
    public static CppQualifiedNameWithTag FindShortName(CppQualifiedNameWithTag baseName, Func`2<CppQualifiedNameWithTag, CppResolveResult> lookuper, Func`2<CppResolveResult, bool> resolveChecker, bool couldReturnTypedefInsteadOfClass);
    public static CppQualifiedNameWithTag FindShortName(CppQualifiedNameWithTag baseName, Func`2<CppQualifiedNameWithTag, CppResolveResult> lookuper, Func`2<CppResolveResult, bool> resolveChecker, bool couldReturnTypedefInsteadOfClass, int minQualifierLength);
    [ExtensionAttribute]
public static CppQualifiedName FindShortNameWithPrincipalLookup(ICppResolveEntity ent, CppViewPos& viewPos);
    [ExtensionAttribute]
public static CppQualifiedName FindShortNameWithHint(ICppResolveEntity ent, CppQualifiedName hint, CppViewPos& viewPos);
    public static CppQualifiedNamePart GetNameHandlingDefaultArgs(ICppResolveEntity ent, CppViewPos& vp);
    private static CppViewPos GetViewPosForFullName(ICppResolveEntity ent);
    private static CppQualifiedName PrependNameForGetFullName(CppQualifiedName prefix, CppQualifiedName suffix);
    private static CppQualifiedNameWithTag GetFullNameForEntityImpl(ICppResolveEntity ent, CppViewPos& viewPos, bool stopAtNamespace, bool getInnerNames, ICppResolveEntity& resultEntity, bool addWellKnownTypeSynonyms, CppSuggestedScopesCollection suggestedScopes, bool skipInlineNamespaces);
    public static CppQualifiedNamePart PresentClassNamePartInViewPos(ICppTypeTemplateInstantiationResolveEntity ent, CppViewPos& viewPos);
    private static CppSubstitutionContext GetSubstitution(ICppTypeTemplateInstantiationResolveEntity ent, ICppTemplateArgument[] args);
    private static ICppTemplateArgument[] ShrinkTemplateArguments(ICppTemplateArgument[] args, ICppTemplateArgument[] defaultArgs);
    [ExtensionAttribute]
public static ISolution GetSolution(ICppResolveEntity ent);
    [ExtensionAttribute]
public static ICppResolveEntity TryFindAlias(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsTopLevel(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsStatementChild(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsInsideCodeFragmentOrFunction(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool HasEntityAsParent(ICppResolveEntity ent, ICppScopeResolveEntity parent);
    [ExtensionAttribute]
public static ICppScopeResolveEntity GetLookupParent(ICppResolveEntity scope, bool skipProperty);
    [ExtensionAttribute]
public static ICppScopeResolveEntity GetLookupScopeForUnscopedEnumerator(ICppClassResolveEntity enumClass);
    public static ICppScopeResolveEntity GetLocalScopeOrGlobalNamespace(ICppScopeResolveEntity lexicalParent, ICppFileResolveEntitiesCache resolveCache);
    private static ICppScopeResolveEntity GetContainingLocalScope(ICppScopeResolveEntity scope);
    private static bool IsStatement(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsAncestorOf(ICppResolveEntity ent, ICppScopeResolveEntity scope);
    [ExtensionAttribute]
public static bool AreInTheSameFile(ICppResolveEntity lhs, ICppResolveEntity rhs);
    [ExtensionAttribute]
public static TriBool IsGeneratedOrBuiltinResolveEntity(ICppResolveEntity ent);
    private static bool IsGenerated(ICppDeclaratorResolveEntity ungrouped);
    [ExtensionAttribute]
public static bool IsAutomaticStorageDurationObject(ICppDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static int Height(ICppScopeResolveEntity a);
    public static ICppScopeResolveEntity GetCommonParent(ICppScopeResolveEntity a, ICppScopeResolveEntity b);
    [ExtensionAttribute]
public static ICppScopeResolveEntity GetGlobalNamespace(ICppResolveEntity scope);
    public static ICppScopeResolveEntity GetNamespaceForClass(ICppResolveEntity scope);
    [ExtensionAttribute]
public static ICppClrElementResolveEntity FindClrElement(ICppResolveEntity entity);
    [ExtensionAttribute]
public static void ProcessWithChildren(ICppResolveEntity ent, Action`1<ICppResolveEntity> action);
    [ExtensionAttribute]
public static void ProcessWithChildren(ICppResolveEntity ent, Func`2<ICppResolveEntity, bool> action);
    [ExtensionAttribute]
public static bool ResolveEntityMatchesLinkageEntity(ICppResolveEntity resolveEnt, ICppLinkageEntity linkageEnt);
    [ExtensionAttribute]
public static ICppClassResolveEntity GetResolvedClassTypeEntityFromTypedef(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsTypeDeduced(ICppDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static CppNamespaceResolveEntity GetEnclosingNamespace(ICppResolveEntity e, bool returnEntity);
    [ExtensionAttribute]
public static CppNamespaceResolveEntity GetEnclosingNonInlineNamespace(CppNamespaceResolveEntity e);
    [ExtensionAttribute]
public static ICppResolveEntity SkipInlineNamespaces(ICppResolveEntity ent);
    [ExtensionAttribute]
public static CppQualType GetVerboseType(ICppDeclaratorResolveEntity decl);
    [ExtensionAttribute]
public static bool PropertyOrEventHasDefinitionSymbol(ICppDeclaratorResolveEntity entity);
    [ExtensionAttribute]
public static ICppResolveEntity GetResolveEntityOrPrimaryTemplate(ICppResolveEntity ent);
    [ExtensionAttribute]
public static ICppFunctionDeclaratorResolveEntity GetFunctionOrPrimaryTemplate(ICppResolveEntity ent);
    [ExtensionAttribute]
public static ICppGroupedDeclaratorResolveEntity GetPrimaryDeclaratorTemplate(ICppDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static ICppGroupedFunctionDeclaratorResolveEntity GetPrimaryTemplateOrThis(ICppGroupedFunctionDeclaratorResolveEntity decl);
    [ExtensionAttribute]
public static TriBool HasArrayMembers(ICppClassResolveEntity cls, CppViewPos& vp);
    private static TriBool HasArrayMembersImpl(ICppClassResolveEntity cls, CppViewPos& vp, JetHashSet`1<ICppClassResolveEntity> visited);
    private static TriBool HasArrayMembersDontCheckBases(ICppClassResolveEntity cls, CppViewPos& vp, JetHashSet`1<ICppClassResolveEntity> visited);
    [ExtensionAttribute]
public static IEnumerable`1<CppMemInitEntity> GetClassMemberInitializersOrdered(ICppClassResolveEntity cls, CppViewPos& vp);
    private static void CollectVirtualBasesInDfsLeftToRightOrder(ICppClassResolveEntity cls, CppViewPos& vp, List`1<CppMemInitEntity> output);
    [ExtensionAttribute]
public static bool CanDeduceTemplateArguments(ICppDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool CanDeduceTemplateArguments(ICppGroupedFunctionDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static CppTemplateParametersBase GetDirectTemplateParameters(ICppResolveEntity resolveEntity);
    [ExtensionAttribute]
public static CppTemplateParametersBase GetTemplateParametersOfResolveEntity(ICppResolveEntity resolveEntity);
    [ExtensionAttribute]
public static ICppTemplateArgument[] GetDefaultTemplateArgumentsOfResolveEntity(ICppResolveEntity resolveEntity, CppViewPos& vp);
    [ExtensionAttribute]
public static bool IsSpecialization(ICppClassResolveEntity resolveEntity);
    [ExtensionAttribute]
public static bool IsSpecialization(ICppDeclaratorResolveEntity resolveEntity);
    public static bool IsSpecializationOf(ICppClassResolveEntity t, ICppClassResolveEntity s);
    [ExtensionAttribute]
public static bool IsRealSpecialization(ICppResolveEntity ent);
    [ExtensionAttribute]
public static ICppTemplateArgument[] GetTemplateArgumentsIfSpecialization(ICppResolveEntity resolveEntity, CppViewPos& vp);
    [ExtensionAttribute]
public static CppQualRefEntities ClassifyResolveEntity(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsScopeHidingEntity(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsSubobjectAgnostic(ICppResolveEntity input);
    [ExtensionAttribute]
public static bool CanHaveConstexprSpecifier(ICppGroupedVariableDeclaratorResolveEntity ent, bool forceAllowForStructuredBindings);
    [ExtensionAttribute]
public static bool HasApplicableStructuralParent(ICppResolveEntity ent);
    [ExtensionAttribute]
public static CppQualType GetCppType(ICppDeclaratorResolveEntity decl);
    [ExtensionAttribute]
public static CppQualType GetCppTypeWithFixedTemplateDependencies(ICppDeclaratorResolveEntity decl, CppTypeContext& tc);
    [ExtensionAttribute]
public static void InstantiateAtFullGlobalNamespaceViewPos(ICppResolveEntity ent);
    [ExtensionAttribute]
public static ICppResolveEntity InstantiateAndRemoveSubstitutionForSearch(ICppResolveEntity ent);
    [ExtensionAttribute]
public static ICppResolveEntity RemoveSubstitution(ICppResolveEntity ent);
    [ExtensionAttribute]
public static ICppDeclaratorResolveEntity RemoveSubstitution(ICppGroupedDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static ICppFunctionDeclaratorResolveEntity RemoveSubstitutionForFunction(CppGroupedFunctionDeclaratorResolveEntity func);
    private static ICppVariableDeclaratorResolveEntity RemoveSubstitutionForVariable(CppGroupedVariableDeclaratorResolveEntity var);
    private static CppGroupedTypeDeclaratorResolveEntity RemoveSubstitutionForType(CppGroupedTypeDeclaratorResolveEntity type);
    private static ICppCxxCliPropertyDeclaratorResolveEntity RemoveSubstitutionForCliProperty(CppCxxCliPropertyDeclaratorResolveEntityWithSubstitution property);
    [ExtensionAttribute]
public static bool IsLambdaParenOperator(ICppFunctionDeclaratorResolveEntity func);
    [ExtensionAttribute]
public static bool IsLambdaConversionToFunctionPointer(ICppDeclaratorResolveEntity func);
    [ExtensionAttribute]
public static bool IsLambdaParenOperatorWithDeducedReturnType(ICppFunctionDeclaratorResolveEntity func);
    [ExtensionAttribute]
public static ICppResolveEntity GetStructuralParentSafe(ICppResolveEntity ent);
    [ExtensionAttribute]
public static ICppResolveEntity GetStructuralParentSkippingEnum(ICppResolveEntity ent);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppClassResolveEntity GetClassByMember(ICppResolveEntity scope);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppClassResolveEntity GetClassByMemberThroughStronglyTypedEnums(ICppResolveEntity e);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppClassResolveEntity GetClassByMemberOrInnerFriend(ICppResolveEntity scope);
    [ExtensionAttribute]
public static CppAttributeList GetAttributes(ICppClassResolveEntity entity, CppViewPos& viewPos);
    public static CppSubstitutionContext CreateAutoSubstitution(CppQualType autoReplacement);
    public static CppSubstitutionContext CreateDecltypeAutoSubstitution(CppQualType decltypeAutoReplacement);
    [ExtensionAttribute]
public static bool HasSubstitutionFailure(ICppResolveEntity ent);
    [ExtensionAttribute]
public static IEnumerable`1<ICppResolveEntity> UnpackManyEntities(IEnumerable`1<ICppResolveEntity> ents);
    [ExtensionAttribute]
public static CppRestrictionSpecifiers GetRestrictionSpecifiers(ICppResolveEntity scope);
    [ExtensionAttribute]
public static CppRestrictionSpecifiers GetRestrictionSpecifiers(CppViewPos& viewPos);
    [ExtensionAttribute]
public static CppRestrictionSpecifiers ComputeRestrictionSpecifiersForVariable(CppVariableDeclaratorResolveEntity func);
    [ExtensionAttribute]
public static CppRestrictionSpecifiers ComputeRestrictionSpecifiersForFunction(ICppFunctionDeclaratorResolveEntity func, CppQualType replacedType);
    [ExtensionAttribute]
public static ICppFriendDeclTargetResolveEntity GetFriendDeclTargetEnclosing(ICppResolveEntity ent);
    [ExtensionAttribute]
public static CppMinMaxArgCountResult GetMinMaxArgCount(ICppFunctionDeclaratorResolveEntity ent, CppQualType funcType);
    [ExtensionAttribute]
public static bool ContainsNonStaticField(ICppClassResolveEntity clazz);
    [ExtensionAttribute]
public static bool CtorCanBeCalledWith(ICppFunctionOrTemplateDeclaratorResolveEntity decl, int argCount);
    [ExtensionAttribute]
public static bool CtorCanBeCalledWith(ICppGroupedFunctionDeclaratorResolveEntity funcDecl, int argCount);
    [ExtensionAttribute]
public static bool CtorCanBeCalledWith(ICppFunctionDeclaratorResolveEntity funcDecl, int argCount);
    [ExtensionAttribute]
public static CppSmallList`1<ICppResolveEntity> GetChildrenByNameHandlingSpecialClassMembers(ICppScopeResolveEntity scope, CppQualifiedNamePart name, bool isStatic, bool isFunction, CppLocationAnchor anchor);
    [ExtensionAttribute]
public static ICppDeclaratorResolveEntityPack TryFindPackByDeclarator(ICppDeclaratorResolveEntity decl);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppGroupedDeclaratorResolveEntity FindGroupedDeclarator(ICppDeclaratorResolveEntity decl);
    [ExtensionAttribute]
public static ICppDeclaratorResolveEntity TryFindGroupedDeclarator(ICppDeclaratorResolveEntity decl);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppGroupedFunctionDeclaratorResolveEntity FindGroupedFunction(ICppDeclaratorResolveEntity decl);
    [ExtensionAttribute]
public static ICppGroupedVariableDeclaratorResolveEntity FindGroupedParameter(ICppParameterListResolveEntity paramList, ICppVariableDeclaratorResolveEntity ungrouped);
    [ExtensionAttribute]
public static ICppResolveEntity GetGroupedResolveEntityIfKnRParameter(ICppResolveEntity ent);
    [ExtensionAttribute]
public static CppClassTemplateResolveEntityPack GetPackByTemplateClass(ICppClassResolveEntity cent);
    [ExtensionAttribute]
public static CppClassTemplateResolveEntityPack GetPackOfTemplateClassOrSubstitution(ICppClassOrUndeterminedSpecializationResolveEntity ent);
    [ExtensionAttribute]
public static ICppSymbol GetClassMemberDeclarationSymbol(ICppResolveEntity entity);
    public static ICppSymbol GetFirstNonQualifiedSymbol(ICppResolveEntity entity);
    [ExtensionAttribute]
public static ICppResolveEntity GetLexicalParent(ICppResolveEntity ent);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppClassResolveEntity GetEnclosingClass(ICppResolveEntity scope, bool returnEntity);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICppClassResolveEntity GetOutermostEnclosingClass(ICppClassResolveEntity clazz);
    public static bool IsLookupParentOf(ICppResolveEntity ent, CppViewPos& viewPos);
    [ExtensionAttribute]
public static bool IsParentOf(ICppScopeResolveEntity scope, ICppResolveEntity ent);
    [ExtensionAttribute]
public static ICppResolveEntity GetPrimaryTemplate(ICppResolveEntity ent);
    [ExtensionAttribute]
public static ICppClassResolveEntity GetPrimaryClassTemplate(ICppClassOrUndeterminedSpecializationResolveEntity ent);
    public static CppDependentInfo GetDependentInfo(ICppResolveEntity ent);
    public static CppDependentInfo GetDependentInfo(ICppClassResolveEntity cls);
    [ExtensionAttribute]
public static bool HasTemplateDependencies(ICppRequiresExpressionScopeResolveEntity requiresExpression);
    [ExtensionAttribute]
public static bool HasTemplateParents(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool HasNonGenericTemplateParents(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool HasTemplateOrSubstitutionParents(ICppResolveEntity ent);
    private static bool HasTemplateOrSubstitutionParentsImpl(ICppResolveEntity ent, bool returnTrueOnSubstitutions, bool skipGenerics);
    private static bool HasTemplateOrSubstitutionParentsImpl(ICppResolveEntity ent, bool returnTrueOnSubstitutions, bool skipGenerics, Nullable`1& containsDepKiller);
    [ExtensionAttribute]
public static List`1<ICppTemplateParameter> GetAllTemplateParametersFromParents(ICppResolveEntity ent);
    [ExtensionAttribute]
public static List`1<CppTemplateParameterTag> GetAllTemplateParameterTagsFromParents(ICppResolveEntity ent);
    public static ICppClassResolveEntity GetClassByMemberParameterList(ICppParameterListResolveEntity paramList);
    [ExtensionAttribute]
public static ICppClassResolveEntity GetObjectParameterClassOfFunction(ICppFunctionDeclaratorResolveEntity funcDecl);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppFunctionDeclaratorResolveEntity GetEnclosingFunction(ICppResolveEntity resolveEntity, bool returnEntity);
    [CanBeNullAttribute]
public static ICppFunctionDeclaratorResolveEntity GetEnclosingFunction(CppViewPos& viewPos, bool returnEntity);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppFunctionBodyResolveEntity GetEnclosingFunctionBody(ICppResolveEntity resolveEntity);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppParameterListResolveEntity GetEnclosingParameterList(ICppDeclaratorResolveEntity parameter);
    [ExtensionAttribute]
public static int GetParameterIndex(ICppParameterListResolveEntity paramList, ICppDeclaratorResolveEntity parameter);
    [ExtensionAttribute]
public static int GetParameterListDepth(ICppResolveEntity entity);
    public static ICppDeclaratorResolveEntity GetEnclosingMember(CppViewPos& viewPos);
    public static ICppParameterListResolveEntity GetEnclosingParameterListForThisCVQuals(CppViewPos& viewPos, bool skipLambda);
    [ExtensionAttribute]
public static ICppResolveEntity GetSearchScopeForLocalEntity(ICppResolveEntity ent);
    [ExtensionAttribute]
public static CppCallingConvention GetDefaultCallingConvention(ICppResolveEntity ent);
    [ExtensionAttribute]
public static ICppResolvedExpression GetResolvedRequiresClause(ICppDeclaratorResolveEntity declEntity);
    [ExtensionAttribute]
public static ICppClassResolveEntity FindClass(ICppScopeResolveEntity parent, CppQualifiedId nameOfType, CppLocationAnchor anchor);
    [ExtensionAttribute]
public static CppClassTemplateResolveEntityPack FindClassPack(ICppScopeResolveEntity parent, CppQualifiedId nameOfType, CppLocationAnchor anchor);
    public static CppExpressionStatementResolveEntityBase FindLastStatement(ICppScopeStatementResolveEntity scope);
    [ExtensionAttribute]
public static bool IsEnumeratorInEnumerationScope(ICppScopeResolveEntity resolveScope, ICppEnumeratorResolveEntity enumerator);
    [ExtensionAttribute]
public static ICppGroupedFunctionDeclaratorResolveEntity GetDeletedDestructor(ICppClassResolveEntity classEntity);
    [ExtensionAttribute]
public static ICppGroupedFunctionDeclaratorResolveEntity GetDeletedFunctionCalledByConvertingFunction(ICppGroupedFunctionDeclaratorResolveEntity func);
    [ExtensionAttribute]
public static bool HasDependentBase(ICppClassResolveEntity cls);
    private static bool IsExplicit(ICppFunctionDeclaratorResolveEntity declEntity, CppAttributeList attributes);
    [ExtensionAttribute]
public static bool IsExplicit(ICppFunctionDeclaratorResolveEntity declEntity);
    [ExtensionAttribute]
public static bool IsExplicit(ICppGroupedFunctionDeclaratorResolveEntity declEntity);
    [ExtensionAttribute]
public static ICppResolvedExpression GetExplicitExpression(CppAttributeList attrList);
    [ExtensionAttribute]
public static ICppResolvedExpression GetExplicitExpression(ICppDeclaratorResolveEntity declEntity);
    [ExtensionAttribute]
public static CppQualType GetTypeWithImplicitObjectParameter(ICppFunctionDeclaratorResolveEntity declEnt, ICppResolvedTypeFactory tf);
    public static bool DeclaratorNeedsInlineSpecifier(ICppDeclaratorResolveEntity groupedEntity, ICppSymbol symbol);
    [ExtensionAttribute]
public static bool FunctionDefinitionNeedsInlineSpecifier(ICppDeclaratorResolveEntity entity);
    [ExtensionAttribute]
public static CppList`1<ICppGroupedVariableDeclaratorResolveEntity> GetNonStaticClassDataMembers(ICppClassResolveEntity cls, bool withAnonymousUnionMembers, bool withAnonymousClassMembers);
    [ExtensionAttribute]
public static CppList`1<ICppGroupedVariableDeclaratorResolveEntity> GetNonStaticClassDataMembers(ICppClassResolveEntity cls);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveEntityUtil/<EnumerateNonStaticClassDataMembers>d__185")]
[ExtensionAttribute]
public static IEnumerable`1<ICppGroupedVariableDeclaratorResolveEntity> EnumerateNonStaticClassDataMembers(ICppClassResolveEntity cls, bool withAnonymousUnionMembers, bool withAnonymousClassMembers);
    [ExtensionAttribute]
public static ICppResolveEntity TryGetThisPtrScope(ICppResolveEntity scope);
    [ExtensionAttribute]
public static InputQualifiers GetHlslInputQualifiers(ICppDeclaratorResolveEntity declEntity);
    [ExtensionAttribute]
public static bool IsHlslInoutParameter(ICppDeclaratorResolveEntity declEntity);
    [ExtensionAttribute]
public static bool IsHlslOutParameter(ICppDeclaratorResolveEntity declEntity);
    [ExtensionAttribute]
public static ICppFunctionDeclaratorResolveEntity GetThreeWayComparisonFromImplicitEquality(ICppResolveEntity ent);
    [ExtensionAttribute]
public static IGenericSymbolNode TryGetDeclarator(ICppDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static TriBool IsEmptyClass(ICppClassResolveEntity cls, CppViewPos& vp);
    public static ICppBaseQualifiedReferenceBuilder GetQualifiedReferenceBuilderByNodeType(NodeType nt);
    public static ICppNonAbstractDeclaratorNode TryGetClassMemberDeclarator(IClassOrEnumWithBodySpecifier classSpec, ICppGroupedVariableDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool IsInjectedCodeFragment(ICppResolveEntity ent);
    [CompilerGeneratedAttribute]
internal static bool <IsMemberOrFriendFor>g__IsEqualOrSpecializationOf|12_0(ICppClassResolveEntity a, ICppClassResolveEntity b);
    [CompilerGeneratedAttribute]
internal static bool <IsMemberOrFriendFor>g__GetPrimaryTemplateIfSpecialization|12_1(ICppClassResolveEntity& clazz);
    [CompilerGeneratedAttribute]
internal static ICppResolveEntity <GetEnclosingParameterListForThisCVQuals>g__GetEnclosingScope|164_0(ICppResolveEntity scope);
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveEntityUtilConstants : object {
    public static CppQualifiedId ourStdInitializerListName;
    public static CppQualifiedId ourTupleSizeName;
    public static CppQualifiedId ourTupleElementName;
    public static CppQualifiedId ourTypeName;
    public static CppQualifiedId ourValueName;
    public static CppQualifiedId ourPiecewiseConstructName;
    public static CppQualifiedId ourViewableRangeName;
    public static CppQualifiedName ourStdName;
    private static CppResolveEntityUtilConstants();
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveEntityViewPos : object {
    public static CppViewPos GetViewPosForDeclarationSpecifiers(ICppDeclaratorResolveEntity e);
    public static CppViewPos GetViewPosForDeclarator(ICppDeclaratorResolveEntity e);
    private static CppViewPos GetViewPosForStandardDeclarator(Declarator ent);
    public static CppViewPos GetViewPosForDeclaratorRequiresClause(ICppFunctionDeclaratorResolveEntity decl);
    public static CppViewPos GetViewPosForExceptionSpecification(CppParameterListResolveEntity params, bool isNoExcept);
    public static CppViewPos GetViewPosForClassName(ICppScopeResolveEntity lexicalParent, ICppClassResolveEntity e, CppLocationAnchor anchor);
    public static CppViewPos GetViewPosForDeclaratorName(ICppScopeResolveEntity lexicalParent, ICppDeclaratorResolveEntity e, ICppSymbol sym);
    public static CppViewPos GetViewPosForNameForConversionTypeId(ICppDeclaratorResolveEntity e, ICppSymbol sym);
    public static CppViewPos GetViewPosForAliasDeclarationTypeId(CppAliasDeclarationResolveEntity ent);
    public static CppViewPos GetViewPosForConceptDefinition(ICppConceptDefinitionResolveEntity ent);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveEntityWithSubstitution : object {
    private ICppResolveEntityParent myStructuralParent;
    private ICppSubstitutionContext mySubst;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    protected CppResolveEntityWithSubstitution(ICppResolveEntityParent structuralParent, CppQualifiedNamePart name, ICppSubstitutionContext subst);
    public virtual ICppResolveEntityParent get_RealParent();
    public virtual ICppResolveEntity get_StructuralParent();
    [CompilerGeneratedAttribute]
public virtual CppQualifiedNamePart get_Name();
    public abstract virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public abstract virtual CppLocationAnchor get_LocationAnchor();
    public abstract virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    [DebuggerStepThroughAttribute]
public sealed virtual ICppSubstitutionContext GetSubstitution();
    protected void SetSubstitution(ICppSubstitutionContext subst);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
private void AssertSubstitutionContextNonEmpty();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveLockGuard : ValueType {
    private CppResolveMutex myMutex;
    public CppResolveLockGuard(CppResolveMutex mutex);
    public sealed virtual void Dispose();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveMutex : object {
    private IShellLocks myShellLocks;
    private CppPriorityMutex myPrioMutex;
    public CppResolveMutex(IShellLocks shellLocks);
    public void Lock();
    public void Unlock();
    public bool IsLocked();
    public bool PrioritisedLockRequested();
    private Priority ThreadPriority();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveMutexInterruptCookie : ValueType {
    private InterruptionSourceCookie myCookie;
    public CppResolveMutexInterruptCookie(CppFile file);
    public CppResolveMutexInterruptCookie(CppResolveMutex mutex);
    public sealed virtual void Dispose();
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveNameFuncFactory : object {
    public static Func`2<CppQualifiedNameWithTag, CppResolveResult> CreateResolverForReferenceNode(BaseQualifiedReference ref);
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveNameFuncFactory2 : object {
    public static Func`2<CppQualifiedNameWithTag, CppResolveResult> CreateLookupPrincipalEntityResolver(CppViewPos& vp);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppRestrictionSpecifiers : Enum {
    public byte value__;
    public static CppRestrictionSpecifiers None;
    public static CppRestrictionSpecifiers Cpu;
    public static CppRestrictionSpecifiers Amp;
    public static CppRestrictionSpecifiers All;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRestrictionSpecifiersBuilder : ValueType {
    private CppRestrictionSpecifiers myRestrictionSpecifiers;
    public bool LearnTokenText(string tokenText);
    public CppRestrictionSpecifiers GetRestrictionSpecifiers();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppRestrictionSpecifiersUtil : object {
    [ExtensionAttribute]
public static bool IsCallableIn(CppRestrictionSpecifiers funcSpecs, CppRestrictionSpecifiers scopeSpecs);
    [ExtensionAttribute]
public static string SpecsToString(CppRestrictionSpecifiers specs);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReturnStatementBuilder : ValueType {
    private CppComplexOffset myLocation;
    private ICppScopeStatementBuilder myParent;
    public CppReturnStatementBuilder(CppComplexOffset loc, ICppScopeStatementBuilder parentBuilder);
    public void Learn();
    public void Learn(CppTwinExpressionBuilder& exprBuilder);
    private void LearnImpl(ICppExpression unresolved, ICppExpression replaced);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReturnStatementModuleEntity : CppStatementModuleEntityBase {
    [CanBeNullAttribute]
private ICppExpression myArgument;
    public CppReturnStatementModuleEntity(ICppExpression argument, CppLocationAnchor anchor);
    public virtual ICppStatementResolveEntity Import(CppScopeResolveEntityBase targetParent, CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReturnStatementResolveEntity : object {
    private static CppQualifiedNamePart ourName;
    private CppLocationAnchor myLocationAnchor;
    private CppScopeStatementResolveEntity myParent;
    [CanBeNullAttribute]
private ICppExpression myReplacedExpression;
    private CppReturnStatementSymbol mySymbol;
    private ICppResolvedExpression myResolvedExpression;
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppReturnStatementResolveEntity(CppScopeStatementResolveEntity parent, CppReturnStatementSymbol symbol, CppLocationAnchor location, ICppExpression replacedExpression);
    public CppReturnStatementResolveEntity(CppScopeStatementResolveEntity parent, CppLocationAnchor location, ICppResolvedExpression argument);
    private static CppReturnStatementResolveEntity();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual ICppResolvedExpression GetExpression();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReturnStatementResolveEntityWithSubstitution : object {
    private ICppReturnStatementResolveEntity myInner;
    private CppSubstitutionDriver myDriver;
    private CppCachedReference`1<ICppResolvedExpression> myCachedExpression;
    [CompilerGeneratedAttribute]
private ICppResolveEntity <StructuralParent>k__BackingField;
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppReturnStatementResolveEntityWithSubstitution(ICppResolveEntity parent, ICppReturnStatementResolveEntity inner, CppSubstitutionDriver driver);
    [CompilerGeneratedAttribute]
public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual ICppResolvedExpression GetExpression();
    private ICppResolvedExpression CalculateExpression();
    public void SubstituteExpressionIfItContainsLambda();
    private ICppResolvedExpression CalculateInnerExpression(ICppResolvedExpression innerExpression);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppReturnStatementSymbol : CppParserSymbol {
    private static CppQualifiedName NAME;
    [CanBeNullAttribute]
public ICppExpression Expression;
    public CppReturnStatementSymbol(CppComplexOffset loc, ICppExpression expression);
    private static CppReturnStatementSymbol();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSanitizeTemplateArgumentsUtil : object {
    public static ICppTypeTemplateArgument SanitizeAutoTemplateArgument(ICppResolvedTypeFactory typeFactory, ICppTemplateArgument arg);
    public static ICppTypeTemplateArgumentOrPack SanitizeTypeTemplateArgument(ICppTypeTemplateParameterOrPack templateParameter, ICppResolvedTypeFactory typeFactory, ICppTemplateArgument arg);
    internal static ICppTypeTemplateArgument SanitizeTypeTemplateArgumentWithoutWrappingInPack(ICppTypeTemplateParameterOrPack templateParameter, ICppResolvedTypeFactory typeFactory, ICppTemplateArgument arg);
    public static ICppTemplateArgument SanitizeGenericTemplateArgument(ICppGenericParameter p, ICppResolvedTypeFactory typeFactory, ICppTemplateArgument arg);
    public static ICppExpressionTemplateArgument SanitizeExpressionTemplateArgument(ICppExpressionTemplateParameterOrPack templateParameter, CppTypeContext& typeContext, CppSubstitutionContext substitutionContext, ICppTemplateArgument arg);
    internal static ICppExpressionTemplateArgument SanitizeExpressionTemplateArgumentWithoutWrappingInPack(ICppExpressionTemplateParameterOrPack templateParameter, CppTypeContext& typeContext, CppSubstitutionContext substitutionContext, ICppTemplateArgument arg);
    private static bool VerifyCompatibleTemplateTemplateParameters(CppTemplateParametersBase paramParams, CppTemplateParametersBase argParams, ICppTemplateArgument[] argDefaults);
    private static ICppTemplateTemplateArgument VerifyTemplateTemplateArgument(ICppTemplateTemplateParameterOrPack templateParameter, ICppTemplateTemplateArgument arg, CppTypeContext& typeContext);
    public static ICppTemplateTemplateArgument SanitizeTemplateTemplateArgument(ICppTemplateTemplateParameterOrPack templateParameter, CppTypeContext& typeContext, ICppTemplateArgument arg);
    public static ICppTemplateTemplateArgument SanitizeTemplateTemplateArgumentWithoutWrappingInPack(ICppTemplateTemplateParameterOrPack templateParameter, CppTypeContext& typeContext, ICppTemplateArgument arg);
    public static ICppTemplateArgument SanitizeTemplateArgument(ICppTemplateParameter parameter, CppTypeContext& typeContext, CppSubstitutionContext substitutionContext, ICppTemplateArgument arg);
    public static ICppTemplateArgument[] SanitizeTemplateArguments(CppTemplateParametersBase templateParameters, CppTypeContext& typeContext, ICppTemplateArgument[] defaultArgs, ReadOnlySpan`1<ICppTemplateArgument> args);
    public static ICppTemplateArgument[] SanitizeTemplateArguments(CppClassTemplateResolveEntityPack pack, CppViewPos& viewPos, ReadOnlySpan`1<ICppTemplateArgument> args);
    private static ICppTypeTemplateArgument SanitizeTypeTemplateArgumentInner(ICppResolvedTypeFactory typeFactory, ICppTemplateArgument arg);
    private static CppUnknownEntityInfo GetInfoForNonEvaluatedExpression(ICppResolvedExpression expression);
    private static bool IsValidExprTemplArrayValue(CppArrayValue value);
    private static bool IsValidExprTemplArgResult(ICppValue result, CppLanguageDialect dialect);
    private static ICppResolvedExpression EvaluateExprTemplArg(CppQualType targetType, ICppResolvedExpression expression, CppTypeContext& typeContext);
    private static bool IsValidNonTypeTemplateParameterType(CppQualType qualType, CppViewPos& viewPos);
    private static CppQualType NormalizeType(CppQualType type, ICppResolvedTypeFactory typeFactory);
    private static void AddMissingTemplateArguments(CppTemplateParametersBase parameters, CppList`1& resultList);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppScopeChildrenMapPool : AutoClearingThreadSafeObjectPool`1<Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>>> {
    public static int CheckPeriod;
    public CppScopeChildrenMapPool(Lifetime lifetime);
    protected virtual Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>> CreateObject();
    protected virtual void ClearObject(Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>> children);
    protected virtual void InitObject(Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>> children);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppScopeDepKillingResult : ValueType {
    public ICppGroupedFunctionDeclaratorResolveEntity Function;
    public CppSubstitutionContext Substitution;
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CppScopeDepKillingResult left, CppScopeDepKillingResult right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CppScopeDepKillingResult left, CppScopeDepKillingResult right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CppScopeDepKillingResult other);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppScopeFreezeGuard : ValueType {
    public CppScopeFreezeGuard(ICppScopeResolveEntity e);
    public sealed virtual void Dispose();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppScopeLookupTemplateParametersContext : ValueType {
    private List`1<CppTemplateParametersBase> myParamList;
    private int myCurrent;
    public CppScopeLookupTemplateParametersContext(List`1<CppTemplateParametersBase> paramList);
    public int Left();
    public bool Eof();
    public CppTemplateParametersBase Current();
    public void Advance();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppScopeResolveEntityBase : object {
    private ICppResolveEntityParent myParent;
    private CppList`1<ICppClassResolveEntity> myAnonymousClasses;
    private Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>> myChildren;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <LocationAnchor>k__BackingField;
    public string DbgDescription { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    protected CppScopeResolveEntityBase(ICppResolveEntityParent parent, CppLocationAnchor anchor);
    public string get_DbgDescription();
    public virtual void AddChild(ICppResolveEntity ent);
    public virtual void RemoveChild(ICppResolveEntity ent);
    public virtual CppSmallList`1<ICppResolveEntity> ChildByName(CppQualifiedNamePart name, CppLocationAnchor anchor);
    public virtual CppList`1<ICppResolveEntity> GetChildren();
    public virtual FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public virtual void AddAnonymousClass(ICppClassResolveEntity cent);
    public virtual CppList`1<ICppClassResolveEntity> AnonymousClasses();
    public virtual ICppResolveEntityParent get_RealParent();
    public virtual ICppResolveEntity get_StructuralParent();
    public abstract virtual CppQualifiedNamePart get_Name();
    public abstract virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    [CompilerGeneratedAttribute]
public virtual CppLocationAnchor get_LocationAnchor();
    public abstract virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    private void AssertNotFrozen();
    public virtual bool HasExistingChildrenWithName(CppQualifiedNamePart name);
    public virtual bool HasUsingDeclarationWithName(CppQualifiedNamePart name);
    [CanBeNullAttribute]
public Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>> GetRawChildren();
    protected virtual void AddChildWithoutJournaling(ICppResolveEntity ent);
    protected void InitChildrenMap(Dictionary`2<CppQualifiedNamePart, CppSmallList`1<ICppResolveEntity>> children);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppScopeStatementBuilder`2 : CppScopeStatementBuilderBase {
    private TSymbol mySymbol;
    private TResolveEntity myResolveEnt;
    protected CppScopeStatementBuilder`2(ICppBuilder parent);
    public void LearnLocation(CppSymbolLocation location);
    public virtual CppScopeSymbol GetSymbol();
    public virtual CppScopeStatementResolveEntity GetResolveEntity();
    protected abstract virtual TSymbol CreateSymbol(CppSymbolLocation location);
    protected abstract virtual TResolveEntity CreateResolveEntity(ICppScopeResolveEntity parent, CppLocationAnchor anchor);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppScopeStatementBuilderBase : object {
    private ICppBuilder myParent;
    public ICppBuilder Parent { get; }
    public ICppScopeResolveEntity ResolveEntity { get; }
    protected CppScopeStatementBuilderBase(ICppBuilder parent);
    public virtual ICppBuilder get_Parent();
    public virtual void AddChild(CppParserSymbol symbol);
    public virtual ICppScopeResolveEntity get_ResolveEntity();
    public virtual CppAccessibility GetAccessibility();
    public virtual ICppParserSymbol GetClassParentSymbol();
    public virtual void AddGotoStatement(CppComplexOffset loc, CppGotoStatementKind kind);
    public abstract virtual CppScopeSymbol GetSymbol();
    public abstract virtual CppScopeStatementResolveEntity GetResolveEntity();
    protected static void AddGotoStatement(CppComplexOffset loc, CppGotoStatementKind kind, CppScopeSymbol parentSymbol, CppScopeStatementResolveEntity parentResolveEntity, CppFileSymbolsCache owner);
    private CppScopeStatementBuilderBase FindBodyBuilder();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppScopeStatementModuleEntity : CppStatementModuleEntityBase {
    public CppRegularFunctionModuleEntity Function;
    public ICppModuleEntity[] Children;
    protected CppScopeStatementModuleEntity(CppLocationAnchor anchor, CppRegularFunctionModuleEntity function);
    public void ImportScopeStatementChildren(CppScopeResolveEntityBase targetParent, CppModuleImportingContext ctx);
    private static CppImportResult`1<ICppResolveEntity> ImportChild(ICppModuleEntity source, CppScopeResolveEntityBase targetParent, CppModuleImportingContext ctx);
    public sealed virtual CppImportResult`1<ICppScopeResolveEntity> ImportScopeAutoParent(CppModuleImportingContext ctx);
    private CppImportResult`1<ICppFunctionDeclaratorResolveEntity> ImportFunction(CppModuleImportingContext ctx);
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppScopeStatementResolveEntity : CppScopeResolveEntityBase {
    private CppList`1<ICppUsingDirectiveObject> myUsingDirectives;
    [CanBeNullAttribute]
private List`1<ICppResolveEntity> myCachedSortedChildren;
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    protected CppScopeStatementResolveEntity(ICppResolveEntity parentScope, CppLocationAnchor location);
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual void AddUsingDirective(ICppUsingDirectiveObject obj);
    public virtual CppList`1<ICppUsingDirectiveObject> GetUsingDirectives();
    public virtual void AddChild(ICppResolveEntity child);
    public virtual void RemoveChild(ICppResolveEntity e);
    public virtual List`1<ICppResolveEntity> GetSortedChildren();
    internal static List`1<ICppResolveEntity> CalculateSortedChildren(CppList`1<ICppResolveEntity> children);
    internal void SetSortedChildren(List`1<ICppResolveEntity> sortedChildren);
    public sealed virtual List`1<ICppResolveEntity> GetCachedSortedChildren();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppScopeStatementResolveEntityWithSubstitutionBuilder : ValueType {
    private ICppScopeStatementResolveEntity myContext;
    public CppScopeStatementResolveEntityWithSubstitutionBuilder(ICppScopeStatementResolveEntity context);
    public void AddChildren(ICppScopeStatementResolveEntity input, ICppScopeStatementResolveEntity parent, CppSubstitutionDriver driver, bool forceExpressionSubstitution);
    private List`1<ICppResolveEntity> CollectChildren(List`1<ICppResolveEntity> input, ICppScopeStatementResolveEntity parent, CppSubstitutionDriver driver);
    private List`1<ICppResolveEntity> CopyFrom(List`1<ICppResolveEntity> input, ICppScopeStatementResolveEntity parent, int start, CppSubstitutionDriver driver);
    private void CreateSubstitution(ICppResolveEntity ent, ICppScopeStatementResolveEntity parent, CppSubstitutionDriver driver, bool forceExpressionSubstitution);
    private static void AddChild(ICppScopeStatementResolveEntity scope, ICppResolveEntity ent);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppScopeStatementSymbol : CppScopeSymbol {
    private static CppQualifiedName NAME;
    protected CppScopeStatementSymbol(CppSymbolLocation loc);
    private static CppScopeStatementSymbol();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppScopeSymbol : CppParserSymbol {
    private CppList`1<ICppSymbol> myChildren;
    [CompilerGeneratedAttribute]
private CppFileLocation <ContainingFile>k__BackingField;
    public CppFileLocation ContainingFile { get; }
    public CppList`1<ICppSymbol> Children { get; }
    public bool Childless { get; }
    public string DbgDescription { get; }
    protected CppScopeSymbol(CppQualifiedName name, CppSymbolLocation loc);
    [CompilerGeneratedAttribute]
public virtual CppFileLocation get_ContainingFile();
    public CppList`1<ICppSymbol> get_Children();
    public bool get_Childless();
    public virtual string get_DbgDescription();
    public void AddChild(ICppSymbol sym);
    public void SetChildrenRaw(CppList`1<ICppSymbol> children);
    public void RemoveChild(ICppSymbol sym);
    public void RemoveChildenAfterOffset(int textOffset);
    public void ClearChildren();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedAutoTypeDeductionFailure : ValueType {
    public static int Size;
    public CppSerializedModuleType PatternType;
    public CppModuleExpressionIndex Initializer;
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedClassBase : ValueType {
    public static int Size;
    public CppSerializedModuleType Entity;
    public byte Specifiers;
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedClassSymbol : ValueType {
    public static int Size;
    public CppSerializedSymbolLocation Location;
    public CppModuleNameIndex Name;
    public byte Key;
    public byte VirtualSpecifiers;
    public byte Flags;
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedDeclaratorSymbol : ValueType {
    public static int Size;
    public CppSerializedSymbolLocation Location;
    public CppModuleNameIndex Name;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedFileLocation : ValueType {
    public static int Size;
    public int PathIndex;
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedFunctionDeclaratorSymbol : ValueType {
    public static int Size;
    public CppSerializedSymbolLocation Location;
    public CppModuleNameIndex Name;
    public byte DeclarationTrailingKind;
}
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedFunctionType : object {
    public static int Size;
    public static void Marshal(CppFunctionType type, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public static CppFunctionType Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input, CppModuleTypeKind typeKind);
    private static void Marshal(ICppExceptionSpecification spec, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    [CanBeNullAttribute]
private static ICppExceptionSpecification Unmarshal(ExceptionSpecKind kind, CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleArrayValue : ValueType {
    public static int Size;
    public Kind ValueKind;
    public CppSerializedModuleType ElementType;
    public CppSlice Elements;
    public int ActualArraySize;
    public CppModuleExpressionIndex DefaultValue;
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleBinaryExpression : object {
    public static int Size;
    [ExtensionAttribute]
public static void Marshal(CppModuleBinaryExpression binary, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public static CppModuleBinaryExpression Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleBracedInitList : object {
    public static int Size;
    [ExtensionAttribute]
public static void Marshal(ICppResolvedBracedInitListExpression expr, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public static CppResolvedBracedInitListExpression Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleBraceInitializedTemporary : object {
    public static int Size;
    [ExtensionAttribute]
public static void Marshal(CppModuleBraceInitializedTemporaryExpression braceInitializedTemporary, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public static CppModuleBraceInitializedTemporaryExpression Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleCallExpression : object {
    public static int Size;
    [ExtensionAttribute]
public static void Marshal(CppModuleCallExpression call, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public static CppModuleCallExpression Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleCastExpression : object {
    public static int Size;
    [ExtensionAttribute]
public static void Marshal(CppModuleCastExpression cast, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public static CppModuleCastExpression Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleConditionalExpression : object {
    public static int Size;
    [ExtensionAttribute]
public static void Marshal(ICppConditionalExpression conditional, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public static CppConditionalExpression Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleDescriptor : ValueType {
    public static int Size;
    public int Part1;
    public int Part2;
    public bool IsNamedModule;
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleDesignation : object {
    public static int Size;
    [ExtensionAttribute]
public static void Marshal(ICppDesignation designation, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public static CppDesignation Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleEnumValue : ValueType {
    public static int Size;
    public CppModuleExpressionIndex UnderlyingValue;
    public CppModuleEntityIndex Enumeration;
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleFoldExpression : object {
    public static int Size;
    [ExtensionAttribute]
public static void Marshal(CppModuleFoldExpression fold, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public static CppModuleFoldExpression Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleMemberAccess : object {
    public static int Size;
    [ExtensionAttribute]
public static void Marshal(CppModuleMemberAccessExpression memAccess, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public static CppModuleMemberAccessExpression Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleNewExpression : object {
    private static int ArgumentListSize;
    public static int Size;
    [ExtensionAttribute]
public static void Marshal(CppModuleNewExpression newExpr, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public static CppModuleNewExpression Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    private static void Marshal(ICppArgumentList argumentList, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    [CanBeNullAttribute]
private static ICppArgumentList UnmarshalArgumentList(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleObjectValue : ValueType {
    public static int Size;
    public CppModuleEntityIndex Class;
    public int KeysStart;
    public int ValuesStart;
    public int FieldsCount;
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModulePointerToArrayElementValue : ValueType {
    public static int Size;
    public int Index;
    public int Array;
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModulePostfixExpression : object {
    public static int Size;
    [ExtensionAttribute]
public static void Marshal(CppModulePostfixExpression postfix, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public static CppModulePostfixExpression Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleQualifiedReference : object {
    public static int Size;
    [ExtensionAttribute]
public static void Marshal(CppModuleQualifiedReferenceExpression qualRef, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public static CppModuleQualifiedReferenceExpression Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleReferenceToFieldValue : ValueType {
    public static int Size;
    public CppModuleEntityIndex Declarator;
    public int Object;
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleRequiresExpression : object {
    public static int Size;
    [ExtensionAttribute]
public static void Marshal(CppModuleRequiresExpression requires, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public static CppModuleRequiresExpression Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleSubscriptExpression : object {
    public static int Size;
    [ExtensionAttribute]
public static void Marshal(CppModuleSubscriptExpression binary, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public static CppModuleSubscriptExpression Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleSubstitutionId : ValueType {
    public static int Size;
    public CppModuleNameIndex Inner;
    public CppSlice Arguments;
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleTemplateId : ValueType {
    public static int Size;
    public CppModuleNameIndex Inner;
    public CppSlice Specialization;
    public CppSlice DefaultTemplateArguments;
    public CppSerializedModuleTemplateParameters Parameters;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleTemplateParameters : ValueType {
    public static int Size;
    public CppSlice List;
    public CppModuleExpressionIndex RequiresClause;
    public bool IsGeneric;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleType : ValueType {
    public static int Size;
    public CppModuleTypeIndex Index;
    public ushort PackedQuals;
    public ushort DeclSpecPlacement;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleTypeWithPackExpansion : ValueType {
    public static int Size;
    public CppSerializedModuleType Type;
    public bool IsPackExpansion;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleTypeWithPayload : ValueType {
    public static int Size;
    public CppSerializedModuleType Type;
    public byte Payload;
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleUDL : object {
    private static int IntSize;
    private static int FloatSize;
    private static int CharSize;
    private static int StrSize;
    private static int MaxSize;
    public static int Size;
    [ExtensionAttribute]
public static void Marshal(CppModuleUserDefinedLiteralExpression expression, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public static CppModuleUserDefinedLiteralExpression Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedModuleUnaryExpression : object {
    public static int Size;
    [ExtensionAttribute]
public static void Marshal(CppModuleUnaryExpression unary, CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public static CppModuleUnaryExpression Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedNamespaceChildRecord : ValueType {
    public static int Size;
    public CppModuleNameIndex Name;
    public CppSlice Values;
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedNonDependentClassBase : ValueType {
    public static int Size;
    public CppModuleEntityIndex Entity;
    public int Specifiers;
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedQualifiedName : ValueType {
    public static int InvalidQualifier;
    public static int Size;
    public static CppSerializedQualifiedName Invalid;
    public CppModuleNameIndex Name;
    public int Qualifier;
    public CppSerializedQualifiedName(CppModuleNameIndex name, int qualifier);
    private static CppSerializedQualifiedName();
    public bool IsValid();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedStructuredBindingSymbol : ValueType {
    public static int Size;
    public CppSerializedSymbolLocation Location;
    public CppModuleNameIndex Name;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedSymbolLocation : ValueType {
    public static int Size;
    public CppSerializedFileLocation FileLocation;
    public int TextOffset;
    public int OffsetInSubstitution;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedTypeConversionFailure : ValueType {
    public static int Size;
    public CppSerializedModuleType Type;
    public CppModuleExpressionIndex Expression;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSerializedTypeIdOrExpression : ValueType {
    public static int Size;
    public CppSerializedModuleType Type;
    public bool IsExpression;
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppShadowDeclaratorResolveEntity`2 : CppShadowResolveEntity {
    protected Template myTemplateDecl;
    private GroupedDeclarator myInner;
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    protected CppShadowDeclaratorResolveEntity`2(GroupedDeclarator inner, Template templateDecl, ICppUsingDeclarationResolveEntity usingDecl, ICppClassResolveEntity owner);
    public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public virtual CppAttributeList get_Attributes();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public virtual CppDependentInfo GetDependentInfo();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public virtual bool Contains(ICppDeclaratorResolveEntity decl);
    public virtual ICppResolveEntityWithParent GetInner();
    public GroupedDeclarator GetInnerDeclarator();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppShadowFunctionDeclaratorResolveEntity : CppShadowDeclaratorResolveEntity`2<CppShadowFunctionTemplateDeclaratorResolveEntity, ICppGroupedFunctionDeclaratorResolveEntity> {
    public CppFunctionTraits Traits { get; }
    public ICppFunctionBodyResolveEntity Body { get; }
    public int BodyChameleonVersion { get; }
    public CppShadowFunctionDeclaratorResolveEntity(ICppGroupedFunctionDeclaratorResolveEntity inner, CppShadowFunctionTemplateDeclaratorResolveEntity templateDecl, ICppUsingDeclarationResolveEntity usingDecl, ICppClassResolveEntity owner);
    public sealed virtual ICppFunctionTemplateDeclaratorResolveEntity GetTemplateDeclaration();
    public sealed virtual CppFunctionTraits get_Traits();
    public sealed virtual ICppFunctionBodyResolveEntity get_Body();
    public sealed virtual int get_BodyChameleonVersion();
    public sealed virtual ICppParameterListResolveEntity GetMainParameterList();
    public sealed virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public sealed virtual int GetFirstDefaultArgIndex();
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetResolvedCxxCliOverrideSpecifierTargets();
    public sealed virtual ICppResolvedExpression GetResolvedRequiresClause();
    public bool InstantiateFunctionBody(CppViewPos& vp, bool forceChameleonInstantiation);
    public sealed virtual ICppFunctionDeclaratorResolveEntity GetUngroupedThatProvidingBody();
    public sealed virtual ICppFunctionOrVariableDeclaratorResolveEntity GetFirstUngrouped();
    public sealed virtual CppList`1<ICppFunctionOrVariableDeclaratorResolveEntity> GetUngroupedDeclarators();
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Resolve.ICppGroupedFunctionDeclaratorResolveEntity.InstantiateFunctionBody(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp, bool forceChameleonInstantiation);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppShadowFunctionTemplateDeclaratorResolveEntity : CppShadowTemplateDeclaratorResolveEntity`1<ICppGroupedFunctionDeclaratorResolveEntity> {
    private ICppFunctionTemplateDeclaratorResolveEntity myInner;
    public CppShadowFunctionTemplateDeclaratorResolveEntity(ICppFunctionTemplateDeclaratorResolveEntity inner, ICppUsingDeclarationResolveEntity usingDecl, ICppClassResolveEntity owner);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public CppPickFunctionSpecializationResult PickSpecializationInSFINAEContext(CppTypeContext& tc, CppSubstitutionContext subst, ICppTemplateFunctionCallDeductionErrorConsumer errorConsumer, ICppResolvedExpression& constraint);
    public CppPickFunctionSpecializationResult PickSpecialization(CppTypeContext& tc, CppSubstitutionContext subst);
    public sealed virtual CppPickFunctionSpecializationResult PickCachedSpecialization(CppSubstitutionContext subst);
    public sealed virtual IList`1<ICppGroupedFunctionDeclaratorResolveEntity> GetCachedSpecializations();
    public sealed virtual ICppTemplateArgument[] FindSubstitutionTemplateArguments(ICppFunctionDeclaratorResolveEntity substituted);
    public sealed virtual CppQualType GetTemplateType(ICppResolvedTypeFactory tf);
    public sealed virtual ICppParameterListResolveEntity GetMainParameterList();
    public sealed virtual void Dump(CppIndentationStringBuilder tw);
    protected virtual ICppGroupedFunctionDeclaratorResolveEntity CreateShadowSpecializationOrSubstitution(ICppGroupedFunctionDeclaratorResolveEntity innerSpec);
    private sealed virtual override CppPickFunctionSpecializationResult JetBrains.ReSharper.Psi.Cpp.Resolve.ICppFunctionTemplateDeclaratorResolveEntity.PickSpecialization(CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc, CppSubstitutionContext subst);
    private sealed virtual override CppPickFunctionSpecializationResult JetBrains.ReSharper.Psi.Cpp.Resolve.ICppFunctionTemplateLikeDeducibleResolveEntity.PickSpecializationInSFINAEContext(CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc, CppSubstitutionContext subst, ICppTemplateFunctionCallDeductionErrorConsumer consumer, ICppResolvedExpression& constraint);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppShadowResolveEntity : object {
    private ICppClassResolveEntity myOwner;
    [CompilerGeneratedAttribute]
private ICppUsingDeclarationResolveEntity <UsingDeclarationEntity>k__BackingField;
    public ICppResolveEntityParent RealParent { get; }
    public ICppUsingDeclarationResolveEntity UsingDeclarationEntity { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    protected CppShadowResolveEntity(ICppUsingDeclarationResolveEntity usingDecl, ICppClassResolveEntity owner);
    public virtual ICppResolveEntityParent get_RealParent();
    [CompilerGeneratedAttribute]
public ICppUsingDeclarationResolveEntity get_UsingDeclarationEntity();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public abstract virtual ICppResolveEntityWithParent GetInner();
    public ICppClassResolveEntity GetOwner();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppShadowResolveEntityUtil : object {
    [ExtensionAttribute]
public static FrugalLocalList`1<ICppResolveEntity> UnwrapShadowResolveEntities(FrugalLocalList`1<ICppResolveEntity> ents);
    [ExtensionAttribute]
public static void WrapShadowResolveEntities(LocalHashSet`1<ICppResolveEntity> ents, ICppClassResolveEntity owner, Dictionary`2<ICppResolveEntity, ICppUsingDeclarationResolveEntity> map, FrugalLocalList`1& res);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppShadowTemplateDeclaratorResolveEntity`1 : CppShadowResolveEntity {
    private ICppTemplateDeclaratorResolveEntity`1<TInnerEntity> myInner;
    public TInnerEntity PrimaryTemplateDeclaration { get; }
    public IEnumerable`1<TInnerEntity> Specializations { get; }
    protected CppShadowTemplateDeclaratorResolveEntity`1(ICppTemplateDeclaratorResolveEntity`1<TInnerEntity> inner, ICppUsingDeclarationResolveEntity usingDecl, ICppClassResolveEntity owner);
    public virtual TInnerEntity get_PrimaryTemplateDeclaration();
    public virtual IEnumerable`1<TInnerEntity> get_Specializations();
    public virtual CppTemplateParametersBase GetParameters();
    public virtual ICppTemplateArgument[] GetDefaults(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual IEnumerable`1<ICppResolveEntity> GetAllSpecializations();
    public virtual ICppResolveEntityWithParent GetInner();
    protected abstract virtual TInnerEntity CreateShadowSpecializationOrSubstitution(TInnerEntity innerSpec);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppShadowTypeDeclaratorResolveEntity : CppShadowDeclaratorResolveEntity`2<ICppTypeTemplateDeclaratorResolveEntity, ICppGroupedTypeDeclaratorResolveEntity> {
    public CppShadowTypeDeclaratorResolveEntity(ICppGroupedTypeDeclaratorResolveEntity inner, ICppTypeTemplateDeclaratorResolveEntity templateDecl, ICppUsingDeclarationResolveEntity usingDecl, ICppClassResolveEntity owner);
    public sealed virtual CppSmallList`1<ICppTypeDeclaratorResolveEntity> GetUngroupedDeclarators();
    public sealed virtual ICppTypeDeclaratorResolveEntity GetAnyUngrouped();
    public sealed virtual ICppTypeTemplateDeclaratorResolveEntity GetTemplateDeclaration();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppShadowTypeTemplateDeclaratorResolveEntity : CppShadowTemplateDeclaratorResolveEntity`1<ICppGroupedTypeDeclaratorResolveEntity> {
    private ICppTypeTemplateDeclaratorResolveEntity myInner;
    public CppShadowTypeTemplateDeclaratorResolveEntity(ICppTypeTemplateDeclaratorResolveEntity inner, ICppUsingDeclarationResolveEntity usingDecl, ICppClassResolveEntity owner);
    public CppQualType InstantiateTemplateDeclarator(CppTypeContext& tc, ICppTemplateArgument[] args, bool forDeduce, CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity source, bool decorateReturnType);
    public ICppTypeTemplateDeclaratorResolveEntity GetInnerTypeTemplateDeclarator();
    protected virtual ICppGroupedTypeDeclaratorResolveEntity CreateShadowSpecializationOrSubstitution(ICppGroupedTypeDeclaratorResolveEntity innerSpec);
    private sealed virtual override CppQualType JetBrains.ReSharper.Psi.Cpp.Resolve.ICppTypeTemplateDeclaratorResolveEntity.InstantiateTemplateDeclarator(CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc, ICppTemplateArgument[] args, bool forDeduce, CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity source, bool decorateReturnType);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppShadowVariableDeclaratorResolveEntity : CppShadowDeclaratorResolveEntity`2<CppShadowVariableTemplateDeclaratorResolveEntity, ICppGroupedVariableDeclaratorResolveEntity> {
    public bool IsParameterPack { get; }
    public CppShadowVariableDeclaratorResolveEntity(ICppGroupedVariableDeclaratorResolveEntity inner, CppShadowVariableTemplateDeclaratorResolveEntity templateDecl, ICppUsingDeclarationResolveEntity usingDecl, ICppClassResolveEntity owner);
    public sealed virtual ICppVariableTemplateDeclaratorResolveEntity GetTemplateDeclaration();
    public sealed virtual CppSmallList`1<ICppVariableDeclaratorResolveEntity> GetUngroupedDeclarators();
    public sealed virtual ICppVariableDeclaratorResolveEntity GetAnyUngrouped();
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual bool HasInitializer();
    public sealed virtual ICppEvaluationResult GetValue(CppEvaluationParams evalParams, ICppEvaluationErrorTracker errorTracker);
    public sealed virtual bool get_IsParameterPack();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppShadowVariableTemplateDeclaratorResolveEntity : CppShadowTemplateDeclaratorResolveEntity`1<ICppGroupedVariableDeclaratorResolveEntity> {
    private ICppVariableTemplateDeclaratorResolveEntity myInner;
    public CppShadowVariableTemplateDeclaratorResolveEntity(ICppVariableTemplateDeclaratorResolveEntity inner, ICppUsingDeclarationResolveEntity usingDecl, ICppClassResolveEntity owner);
    public ICppResolveEntity InstantiateTemplate(ReadOnlySpan`1<ICppTemplateArgument> args, CppViewPos& vp);
    protected virtual ICppGroupedVariableDeclaratorResolveEntity CreateShadowSpecializationOrSubstitution(ICppGroupedVariableDeclaratorResolveEntity innerSpec);
    private sealed virtual override ICppResolveEntity JetBrains.ReSharper.Psi.Cpp.Resolve.ICppVariableTemplateDeclaratorResolveEntity.InstantiateTemplate(ReadOnlySpan`1<ICppTemplateArgument> args, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSimpleDeclaratorSymbol : CppDeclaratorSymbol {
    private CppType myRawType;
    public CppQualType RawType { get; }
    public CppSimpleDeclaratorSymbol(CppQualifiedName name, CppComplexOffset loc, CppDeclarationSpecifiers specifiers, bool isExplicitInstantiation, CppAccessibility accessibility, CppType type, CppModuleAttachment moduleAttachment, CppLazyMergingDataConsumer lazyMergingInfo);
    internal CppSimpleDeclaratorSymbol(RawData& data, CppType type);
    internal CppType GetUnqualifiedType();
    public sealed virtual CppQualType get_RawType();
    public virtual CppSmallList`1<ICppClassSymbol> GetAffectedSymbols();
    internal void InitLazyMergingInfo();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSimpleDeclaratorSymbolWithAffectedSymbols : CppSimpleDeclaratorSymbolWithQualifiedType {
    private CppSmallList`1<ICppClassSymbol> myAffectedSymbols;
    public CppSimpleDeclaratorSymbolWithAffectedSymbols(CppQualifiedName name, CppComplexOffset loc, CppDeclarationSpecifiers specifiers, bool isExplicitInstantiation, CppAccessibility accessibility, CppQualType type, CppModuleAttachment moduleAttachment, CppLazyMergingDataConsumer lazyMergingInfo);
    internal CppSimpleDeclaratorSymbolWithAffectedSymbols(RawData& data, CppQualType type);
    public virtual CppSmallList`1<ICppClassSymbol> GetAffectedSymbols();
    internal void InitLazyMergingInfo();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSimpleDeclaratorSymbolWithQualifiedType : CppDeclaratorSymbol {
    [CompilerGeneratedAttribute]
private CppQualType <RawType>k__BackingField;
    public CppQualType RawType { get; }
    public CppSimpleDeclaratorSymbolWithQualifiedType(CppQualifiedName name, CppComplexOffset loc, CppDeclarationSpecifiers specifiers, bool isExplicitInstantiation, CppAccessibility accessibility, CppQualType type, CppModuleAttachment moduleAttachment, CppLazyMergingDataConsumer lazyMergingInfo);
    internal CppSimpleDeclaratorSymbolWithQualifiedType(RawData& data, CppQualType type);
    [CompilerGeneratedAttribute]
public sealed virtual CppQualType get_RawType();
    public virtual CppSmallList`1<ICppClassSymbol> GetAffectedSymbols();
    internal void InitLazyMergingInfo();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSimpleExpressionTemplateParameterBase : CppExpressionTemplateParameterBase {
    private CppQualType myUnresolvedType;
    protected CppSimpleExpressionTemplateParameterBase(ICppExpressionTemplateParameterSymbol sym, CppViewPos& viewPos, CppQualType type);
    public virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
    public CppQualType GetUnresolvedType();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSimpleTemplateTemplateParameterBase : CppTemplateTemplateParameterBase {
    private CppTemplateParametersBase myParameters;
    protected CppSimpleTemplateTemplateParameterBase(ICppTemplateTemplateParameterSymbol sym, CppTemplateParametersBase params, CppViewPos& viewPos);
    public virtual CppTemplateParametersBase GetParameters();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSizeAndAlignment : ValueType {
    public int Size;
    public int Alignment;
    public CppSizeAndAlignment(int sizeAlignment);
    public CppSizeAndAlignment(int size, int alignment);
    public static CppSizeAndAlignment Error();
    public bool IsValid();
    public CppSizeAndAlignment Adjust();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSlice : ValueType {
    public static int Size;
    public static CppSlice Invalid;
    public int First;
    public int Count;
    public CppSlice(int first, int count);
    private static CppSlice();
    public bool IsEmpty();
    public bool IsValid();
    public static CppSlice FromRange(int start, int end);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppSpecialMemberFunctionKind : Enum {
    public int value__;
    public static CppSpecialMemberFunctionKind DefaultCtor;
    public static CppSpecialMemberFunctionKind CopyCtor;
    public static CppSpecialMemberFunctionKind MoveCtor;
    public static CppSpecialMemberFunctionKind CopyAssignment;
    public static CppSpecialMemberFunctionKind MoveAssignment;
    public static CppSpecialMemberFunctionKind Destructor;
    public static CppSpecialMemberFunctionKind EqualityOperator;
    public static CppSpecialMemberFunctionKind FriendEqualityOperator;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSpecialMemberFunctionModuleEntity : object {
    private CppClassModuleEntity myClass;
    private CppSpecialMemberFunctionKind myMemberKind;
    public CppSpecialMemberFunctionKind MemberKind { get; }
    public CppSpecialMemberFunctionModuleEntity(CppClassModuleEntity class, CppSpecialMemberFunctionKind memberKind);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public CppSpecialMemberFunctionKind get_MemberKind();
    public sealed virtual CppImportResult`1<ICppGroupedFunctionDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
    internal static ICppGroupedFunctionDeclaratorResolveEntity Import(ICppClassResolveEntity clazz, CppSpecialMemberFunctionKind kind, CppModuleImportingContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSpecialMemberFunctionOfReferentialClassModuleEntity : object {
    public ICppClassOrRefClassModuleEntity Class;
    public CppSpecialMemberFunctionKind MemberKind;
    public CppSpecialMemberFunctionOfReferentialClassModuleEntity(ICppClassOrRefClassModuleEntity class, CppSpecialMemberFunctionKind memberKind);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public sealed virtual CppImportResult`1<ICppGroupedFunctionDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSpecialMemberTraitsCalculation : object {
    [ExtensionAttribute]
public static CppFunctionTraits CalculateSpecialMemberTraits(ICppFunctionDeclaratorResolveEntity func);
    private static CppFunctionTraits BaseDestructorTraits(ICppClassResolveEntity base, ICppClassResolveEntity clazz, CppViewPos& vp);
    private static CppFunctionTraits CopyCtorTraits(ICppClassResolveEntity scope, ICppClassResolveEntity clazz, CppTypeContext& tc);
    private static bool CtorPropertiesWasCalculated(CppGroupedFunctionDeclaratorResolveEntity ctor);
    [ExtensionAttribute]
public static bool ClassHasNonDeletedAccessibleFromScopeDestructor(ICppClassResolveEntity clazz, ICppFriendDeclTargetResolveEntity scope, CppViewPos& viewPos);
    private static CppFunctionTraits MoveCtorTraits(ICppClassResolveEntity scope, ICppClassResolveEntity clazz, CppTypeContext& tc);
    private static bool IsAssignmentOperator(CppGroupedFunctionDeclaratorResolveEntity assignment, CppQualType& param, ICppClassResolveEntity clazz, ICppResolvedTypeFactory tf);
    private static CppFunctionTraits CopyAssignmentTraits(ICppClassResolveEntity scope, ICppClassResolveEntity clazz, CppTypeContext& tc);
    private static CppFunctionTraits MoveAssignmentTraits(ICppClassResolveEntity scope, ICppClassResolveEntity clazz, CppTypeContext& tc);
    private static CppTypeContext TypeContextForSpecialMemberCheck(ICppClassResolveEntity clazz);
    private static CppFunctionTraits CalculateDefaultConstructorTraits(ICppClassResolveEntity clazz, CppTypeContext& tc);
    private static CppFunctionTraits CopyMoveConstructorTraits(ICppClassResolveEntity clazz, CppViewPos& vp, bool subobjectsConstructionAreTrivial);
    private static CppFunctionTraits CalculateCopyConstructorTraitsWithoutRegardToDestructor(ICppClassResolveEntity clazz, CppTypeContext& tc, Boolean& subobjectsConstructionAreTrivial);
    private static CppFunctionTraits CalculateCopyConstructorTraits(ICppClassResolveEntity clazz, CppTypeContext& tc);
    private static CppFunctionTraits CalculateMoveConstructorTraitsWithoutRegardToDestructor(ICppClassResolveEntity clazz, CppTypeContext& tc, Boolean& subobjectsConstructionAreTrivial);
    private static CppFunctionTraits CalculateMoveConstructorTraits(ICppClassResolveEntity clazz, CppTypeContext& tc);
    private static CppFunctionTraits CalculateCopyAssignmentTraits(ICppClassResolveEntity clazz, CppTypeContext& tc);
    private static CppFunctionTraits CalculateMoveAssignmentTraits(ICppClassResolveEntity clazz, CppTypeContext& tc);
    private static CppFunctionTraits CalculateDestructorTraits(ICppClassResolveEntity clazz, CppTypeContext& tc);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppStatementModuleEntityBase : object {
    public CppLocationAnchor Anchor;
    protected CppStatementModuleEntityBase(CppLocationAnchor anchor);
    public abstract virtual ICppStatementResolveEntity Import(CppScopeResolveEntityBase targetParent, CppModuleImportingContext ctx);
    public abstract virtual CppModuleEntityKind Kind();
    public abstract virtual int SerializedSize();
    public abstract virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public abstract virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppStatementWithConditionBuilder : object {
    private ICppBuilder myParent;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    protected CppStatementWithConditionBuilder(ICppBuilder parent);
    public void LearnCondition(CppTwinExpressionBuilder& builder);
    public void LearnCondition(CppNormalDeclarator0Builder declaratorBuilder);
    public virtual void AddChild(CppParserSymbol symbol);
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
    public sealed virtual ICppParserSymbol GetClassParentSymbol();
    protected abstract virtual ICppMutableStatementWithConditionResolveEntity GetResolveEntity();
    protected abstract virtual CppStatementWithConditionSymbol GetSymbol();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppStatementWithConditionSymbol : CppScopeStatementSymbol {
    private ICppExpression myCondition;
    protected CppStatementWithConditionSymbol(CppSymbolLocation loc);
    public ICppExpression GetCondition();
    public void SetCondition(ICppExpression expr);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppStringLiteralBuilder : ValueType {
    private bool myIsInsideLPrefix;
    private string myUserDefinedSuffix;
    private FrugalLocalList`1<string> myStringParts;
    public sealed virtual void StartMsLPrefix();
    public sealed virtual void LearnStringLiteral(ITokenNode token);
    public void LearnFuncKeyword(CppFuncKeywordKind kind, CppViewPos& vp);
    public sealed virtual FrugalLocalList`1<string> GetStringParts();
    public sealed virtual string GetUserDefinedSuffix();
    public sealed virtual void LearnStringLiteralFromText(string text);
    private sealed virtual override void JetBrains.ReSharper.Psi.Cpp.Symbols.ICppStringLiteralBuilder.LearnFuncKeyword(CppFuncKeywordKind kind, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppStringLiteralTransform : object {
    public static void UnscreenStringAsInLiteral(StringSlice input, StringBuilder sb);
    public static void UnscreenStringAndTellOffsets(string input, int startpos, StringBuilder sb, ITextRangesBuilder positions);
    public static string StringLiteralToString(string input);
    public static void StringLiteralToString(string input, StringBuilder out);
    public static bool StringLiteralHasSuffix(string input);
    public static string StringLiteralGetSuffix(string input);
    public static void StringLiteralToStringAndOffsets(string input, int startpos, StringBuilder sb, ITextRangesBuilder positions);
    public static string ScreenStringAsInLiteral(string input);
    public static string StringToStringLiteral(string input);
    private static void EatOctalNumber(StringSlice input, Int32& i, StringBuilder sb);
    private static bool IsHexadecimalDigit(char c);
    private static int HexadecimalDigitAsInt(char c);
    private static void EatHexadecimalNumber(StringSlice input, Int32& i, StringBuilder sb);
    private static void AppendCodePoint(StringBuilder sb, int cp);
    private static void EatCodePoint(StringSlice input, Int32& i, int n, StringBuilder sb);
    private static void PrintString(string input, StringBuilder sb);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppStructuredBindingBuilder : object {
    private ICppDeclarationBuilder myParent;
    private CppList`1<CppStructuredBindingSymbol> mySymbols;
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public CppStructuredBindingBuilder(ICppDeclarationBuilder parent);
    public sealed virtual CppStructuredBindingSymbol LearnId(string id, CppSymbolLocation location);
    public sealed virtual CppQualifiedNamePart CreateUnresolvedNamePart();
    public sealed virtual void AddChild(CppParserSymbol _);
    public sealed virtual ICppScopeResolveEntity get_ResolveEntity();
    public sealed virtual ICppBuilder get_Parent();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppStructuredBindingResolveEntity : object {
    private CppUnknownType DeclarationRequiresInitializerType;
    private ICppResolveEntityParentScope myStructuralParent;
    private CppStructuredBindingSymbol mySymbol;
    private CppVariableDeclaratorResolveEntity myStructuredBindingDeclaration;
    private int myElementIndex;
    private int myNumElements;
    private CppCachedValue`1<Pair`2<CppDeclaratorInitializer, bool>> myCachedResolvedInitializer;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <LocationAnchor>k__BackingField;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Name>k__BackingField;
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public bool IsParameterPack { get; }
    public CppStructuredBindingResolveEntity(ICppResolveEntityParentScope parent, CppQualifiedNamePart name, CppStructuredBindingSymbol sym, CppLocationAnchor anchor, CppVariableDeclaratorResolveEntity declaration, int elementIndex, int numElements);
    public sealed virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
    public sealed virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public sealed virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public sealed virtual CppAttributeList get_Attributes();
    public sealed virtual ICppResolveEntityParent get_RealParent();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    [CompilerGeneratedAttribute]
public sealed virtual CppLocationAnchor get_LocationAnchor();
    [CompilerGeneratedAttribute]
public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public sealed virtual bool HasInitializer();
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual CppViewPos GetViewPosForEvaluation();
    public sealed virtual bool get_IsParameterPack();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public CppVariableDeclaratorResolveEntity GetStructuredBindingDeclaration();
    public virtual string ToString();
    public bool IsLValueReference();
    public int GetElementIndex();
    public int GetNumElements();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppStructuredBindingSymbol : CppParserSymbol {
    [CompilerGeneratedAttribute]
private CppFileLocation <ContainingFile>k__BackingField;
    public CppFileLocation ContainingFile { get; }
    public CppStructuredBindingSymbol(CppQualifiedName name, CppSymbolLocation loc);
    [CompilerGeneratedAttribute]
public virtual CppFileLocation get_ContainingFile();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppStructuredBindingUtil : object {
    public static CppQualType ResolveStructuredBindingType(ICppVariableDeclaratorResolveEntity declaration, CppQualType declarationType, int elementIndex, int numElements, CppTypeContext& tc);
    public static CppDeclaratorInitializer CreateStructuredBindingInitializer(ICppVariableDeclaratorResolveEntity declaration, int elementIndex, CppTypeContext& tc, CppDependentInfo dependentInfo, ICppFileResolveEntitiesCache fileCache, Boolean& isLValueReference);
    private static string CollectPublicDataMembers(ICppClassResolveEntity cls, CppViewPos& vp, JetHashSet`1<ICppClassResolveEntity> visited, List`1<ICppVariableDeclaratorResolveEntity> members, ICppPresenter presenter);
    private static ICppVariableDeclaratorResolveEntity GetDataMemberByIndex(ICppClassResolveEntity cls, int elementIndex, CppTypeContext& tc);
    private static CppQualType ResolveTypeFromPublicDataMembers(ICppClassResolveEntity cls, int elementIndex, int numElements, CppQualType declarationType, CppTypeContext& tc);
    private static CppQualifiedName CreateTupleSizeValueName(CppQualType declarationType);
    private static Nullable`1<ulong> GetTupleSizeValue(CppQualType declarationType, CppTypeContext& tc);
    private static CppQualifiedName CreateTupleElementTypeName(int elementIndex, CppQualType declarationType);
    private static bool ResolveTypeUsingTupleProtocol(int elementIndex, int numElements, CppQualType declarationType, CppTypeContext& tc, CppQualType& resultType);
    private static CppQualType ResolveTypeFromArrayType(CppQualType arrayType, CVQualifiers cvQuals, int numElements, CppTypeContext& tc);
    private static CppQualType ResolveTypeFromVectorType(CppQualType vectorQualifiedType, CVQualifiers cvQuals, int numElements, CppTypeContext& tc);
    private static bool HasValidMemberGet(CppLookupResult getLookupResult);
    private static CppQualType ResolveStructuredBindingTypeImpl(CppVariableDeclaratorResolveEntity declaration, int elementIndex, int numElements, ICppResolvedTypeFactory tf);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSubstitutedConceptModuleEntity : object {
    public ICppConceptDefinitionModuleEntity ConceptDefinition;
    public CppSmallArray`1<ICppModuleTemplateArgument> TemplateArguments;
    public CppSubstitutedConceptModuleEntity(ICppConceptDefinitionModuleEntity conceptDefinition, CppSmallArray`1<ICppModuleTemplateArgument> templargs);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSubstitutedCondition : ValueType {
    private CppCachedReference`1<ICppResolvedExpression> myCachedCondition;
    [CompilerGeneratedAttribute]
private CppSubstitutionDriver <Driver>k__BackingField;
    public CppSubstitutionDriver Driver { get; }
    public CppSubstitutedCondition(CppSubstitutionDriver driver);
    public ICppResolvedExpression Get(ICppStatementWithConditionResolveEntity inner);
    private ICppResolvedExpression Calculate(ICppStatementWithConditionResolveEntity inner);
    public CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) GetViewPos();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CppSubstitutionDriver get_Driver();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSubstitutedFriendFunctionModuleEntity : object {
    public ICppFriendFunctionModuleEntity Inner;
    private ICppClassOrRefClassModuleEntity myLexicalParent;
    public CppSubstitutedFriendFunctionModuleEntity(ICppFriendFunctionModuleEntity inner, ICppClassOrRefClassModuleEntity lexicalParent);
    private sealed virtual override CppImportResult`1<ICppFunctionDeclaratorResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFriendFunctionModuleEntity.Import(CppModuleImportingContext ctx);
    public sealed virtual CppImportResult`1<ICppGroupedFunctionDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSubstitutedFunctionBodyModuleEntity : object {
    private ICppFunctionModuleEntity myFunction;
    public CppSubstitutedFunctionBodyModuleEntity(ICppFunctionModuleEntity function);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public sealed virtual CppImportResult`1<ICppScopeResolveEntity> ImportScopeAutoParent(CppModuleImportingContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSubstitutedFunctionModuleEntity : object {
    public ICppFunctionModuleEntity PrimaryTemplate;
    public CppSmallArray`1<ICppModuleTemplateArgument> TemplateArguments;
    public Int32[] DefaultedTemplateArguments;
    public CppSubstitutedFunctionModuleEntity(ICppFunctionModuleEntity primaryTemplate, CppSmallArray`1<ICppModuleTemplateArgument> templateArguments, Int32[] defaultedTemplateArguments);
    public sealed virtual CppImportResult`1<ICppGroupedFunctionDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
    private ICppTemplateArgument[] UnpackTemplateArguments(CppModuleImportingContext ctx, ICppFunctionTemplateDeclaratorResolveEntity functionTemplate);
    private void FillHoles(CppTemplateParametersBase parameters, ICppTemplateArgument[] result, ICppTemplateArgument[] defaults, CppTypeContext& typeContext);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSubstitutedLambdaClassModuleEntity : object {
    public ICppScopeModuleEntity Parent;
    public ICppClassOrRefClassModuleEntity Inner;
    public CppSmallArray`1<ICppModuleTemplateArgument> TemplateArguments;
    public CppSubstitutedLambdaClassModuleEntity(ICppScopeModuleEntity parent, ICppClassOrRefClassModuleEntity inner, CppSmallArray`1<ICppModuleTemplateArgument> templateArguments);
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual ICppScopeModuleEntity GetParent();
    public sealed virtual CppClassModuleEntityKind GetKind();
    public sealed virtual bool IsExplicitlyExported();
    public sealed virtual CppImportResult`1<ICppClassResolveEntity> Import(CppModuleImportingContext ctx, ICppScopeResolveEntity targetParent, bool onlyFindExisting, bool addToParentScope);
    private static CppSubstitutionContext CreateSubstitution(List`1<ICppTemplateParameter> deps, ICppTemplateArgument[] args);
    public sealed virtual CppImportResult`1<ICppScopeResolveEntity> ImportScopeAutoParent(CppModuleImportingContext ctx);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSubstitutedParameterListModuleEntity : object {
    public ICppFunctionModuleEntity Owner;
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public sealed virtual CppImportResult`1<ICppScopeResolveEntity> ImportScopeAutoParent(CppModuleImportingContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSubstitutedScopeStatementModuleEntity : object {
    public ICppScopeModuleEntity Parent;
    public CppLocationAnchor Anchor;
    public CppSubstitutedScopeStatementModuleEntity(ICppScopeModuleEntity parent, CppLocationAnchor anchor);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public sealed virtual CppImportResult`1<ICppScopeResolveEntity> ImportScopeAutoParent(CppModuleImportingContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSubstitutedTemplateTemplateParameterModuleEntity : object {
    public CppModuleTemplateTemplateParameterOrPack Parameter;
    public CppSmallArray`1<ICppModuleTemplateArgument> Arguments;
    public CppSubstitutedTemplateTemplateParameterModuleEntity(CppModuleTemplateTemplateParameterOrPack parameter, CppSmallArray`1<ICppModuleTemplateArgument> arguments);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSubstitutedTypeTemplateDeclaratorModuleEntity : object {
    public ICppTypeAliasModuleEntity TypeDeclarator;
    public CppSmallArray`1<ICppModuleTemplateArgument> Arguments;
    public CppSubstitutedTypeTemplateDeclaratorModuleEntity(ICppTypeAliasModuleEntity typeDeclarator, CppSmallArray`1<ICppModuleTemplateArgument> arguments);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSubstitutedVariableModuleEntity : CppSubstitutedVariableOrUndeterminedSpecializationModuleEntity {
    public CppSubstitutedVariableModuleEntity(CppSmallArray`1<ICppVariableModuleEntity> specializations, CppSmallArray`1<ICppModuleTemplateArgument> arguments);
    public sealed virtual CppImportResult`1<ICppGroupedVariableDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSubstitutedVariableOrUndeterminedSpecializationModuleEntity : object {
    private CppSmallArray`1<ICppVariableModuleEntity> mySpecializations;
    private CppSmallArray`1<ICppModuleTemplateArgument> myArguments;
    protected CppSubstitutedVariableOrUndeterminedSpecializationModuleEntity(CppSmallArray`1<ICppVariableModuleEntity> specializations, CppSmallArray`1<ICppModuleTemplateArgument> arguments);
    protected ValueTuple`2<CppImportResult`1<ICppVariableTemplateDeclaratorResolveEntity>, ICppTemplateArgument[]> Import(CppModuleImportingContext ctx);
    public abstract virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSubstitutionContext : object {
    private static int DICT_MAPPING_MIN_SIZE;
    public static CppSubstitutionContext Empty;
    [CanBeNullAttribute]
private Dictionary`2<ICppParameterListResolveEntity, CppParameterListWithSubstitution> myFParamMapping;
    private ICppSubstitutionMapping mySubstitutionMapping;
    public IEnumerable`1<CppTemplateParameterTag> Tags { get; }
    public ICppTemplateArgument Item { get; public set; }
    public int Count { get; }
    public CppSubstitutionContext(int capacity);
    private CppSubstitutionContext(ICppSubstitutionMapping substitutionMapping, Dictionary`2<ICppParameterListResolveEntity, CppParameterListWithSubstitution> fParamMapping);
    private static CppSubstitutionContext();
    public IEnumerable`1<CppTemplateParameterTag> get_Tags();
    public ICppTemplateArgument get_Item(CppTemplateParameterTag tag);
    public void set_Item(CppTemplateParameterTag tag, ICppTemplateArgument value);
    public int get_Count();
    public virtual bool TryGetSubstitution(CppTemplateParameterTag tag, ICppTemplateArgument& a);
    public virtual bool ContainsSubstitutionFor(CppTemplateParameterTag p);
    public virtual bool TryGetExpansion(CppTemplateParameterTag tag, ICppTemplateArgument& a);
    public virtual bool ContainsExpansionFor(CppTemplateParameterTag p);
    public virtual ICppSubstitutionContext ReplaceTags(CppTemplateParametersBase old, CppTemplateParametersBase new_);
    public virtual CppSubstitutionContext Reinstate();
    public static CppSubstitutionContext CreateFrom(CppTemplateParametersBase params, ICppTemplateArgument[] args);
    public void Add(CppTemplateParameterTag p, ICppTemplateArgument a);
    public CppSubstitutionContext Clone();
    public void AddSubstitutionForParameterList(ICppParameterListResolveEntity original, CppParameterListWithSubstitution substituted);
    public void RemoveSubstitutionForParameterList(ICppParameterListResolveEntity original);
    public CppParameterListWithSubstitution GetSubstitutionForParameterList(ICppParameterListResolveEntity original);
    public bool ContainsSubstitutionForParameterList(ICppParameterListResolveEntity original);
    public static ICppSubstitutionMapping CreateSubstitutionMapping(int capacity);
    private static ICppTemplateArgument CloneTemplateArgument(ICppTemplateArgument value);
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSubstitutionContextUtil : object {
    public static CppSubstitutionContext MergeSubstitutionDicts(CppSubstitutionContext first, CppSubstitutionContext second, CppSubstitutionDriver driver);
    public static CppTemplateParametersSubstitutionContext GetSubstitutionDictForTemplateParameters(ICppResolvedTypeFactory tf, CppTemplateParametersBase from, CppTemplateParametersBase to, bool safe);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSubstitutionContextWithoutExpansion : CppSubstitutionContext {
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSubstitutionId : object {
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppTemplateArgument[] <Arguments>k__BackingField;
    public CppQualifiedNamePart Inner { get; }
    public ICppTemplateArgument[] Arguments { get; }
    public CppSubstitutionId(CppQualifiedNamePart inner, ICppTemplateArgument[] args);
    [CompilerGeneratedAttribute]
public CppQualifiedNamePart get_Inner();
    [CompilerGeneratedAttribute]
public ICppTemplateArgument[] get_Arguments();
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual string ToString();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSubstitutionUtil : object {
    public static ICppClassOrUndeterminedSpecializationResolveEntity DoSubstituteClassAndGetResult(ICppClassResolveEntity cent, CppTypeContext& tc, ICppSubstitutionContext context);
    public static CppDoSubstituteResult`1<ICppClassOrUndeterminedSpecializationResolveEntity> DoSubstituteClass(ICppClassResolveEntity e, CppTypeContext& tc, ICppSubstitutionContext subst);
    public static CppDoSubstituteResult`1<CppClassTemplateResolveEntityPack> DoSubstituteClassPack(CppClassTemplateResolveEntityPack e, CppSubstitutionDriver driver);
    public static CppDoSubstituteResult`1<CppClassTemplateResolveEntityPack> DoSubstituteClassPack(CppClassTemplateResolveEntityPack e, CppTypeContext& tc, ICppSubstitutionContext subst);
    public static CppDoSubstituteResult`1<TTemplate> DoSubstituteTemplateDeclarator(TTemplate groupedDeclarator, CppSubstitutionDriver driver);
    public static CppDoSubstituteResult`1<TTemplate> DoSubstituteTemplateDeclarator(TTemplate groupedDeclarator, CppTypeContext& tc, ICppSubstitutionContext subst);
    public static CppDoSubstituteResult`1<T> DoSubstituteGroupedDeclaratorNonTemplate(T groupedDeclarator, CppTypeContext& tc, ICppSubstitutionContext subst);
    public static CppDoSubstituteResult`1<ICppEnumeratorResolveEntity> DoSubstituteEnumerator(ICppEnumeratorResolveEntity e, CppTypeContext& tc, ICppSubstitutionContext subst);
    public static CppDoSubstituteResult`1<ICppTypeTemplateResolveEntity> DoSubstituteTypeTemplateResolveEntity(ICppTypeTemplateResolveEntity e, CppSubstitutionDriver driver);
    public static CppDoSubstituteResult`1<ICppStatementResolveEntity> DoSubstituteStatement(ICppStatementResolveEntity stmt, CppTypeContext& tc, ICppSubstitutionContext subst);
    public static CppDoSubstituteResult`1<ICppParameterListResolveEntity> DoSubstituteParameterList(ICppParameterListResolveEntity params, CppSubstitutionDriver driver);
    public static CppSmallList`1<ICppResolveEntity> DoSubstituteResolveEntity(ICppResolveEntity e, CppSubstitutionDriver driver);
    public static TTemplate FindSubstitutedTemplateDeclarator(TTemplate groupedDeclarator, CppClassResolveEntityWithSubstitution substitutedParent);
    private static TTemplate FindSubstitutedTemplateDeclaratorInPack(TTemplate groupedDeclarator, ICppDeclaratorResolveEntityPack declaratorGroup);
    private static ICppResolveEntity DoSubstituteUndeterminedVariableSpec(CppUndeterminedTemplateVariableSpecializationResolveEntity spec, CppSubstitutionDriver driver);
    private static TResolveEntity FindEntityInSubstitutionByOriginal(CppClassResolveEntityWithSubstitution subst, ICppResolveEntity e, bool substComesFromGeneric, CppViewPos& vp, Func`2<TResolveEntity, ICppResolveEntity> getInner);
    private static ICppClassResolveEntity FindEntityInSubstitutionByOriginal(CppClassTemplateResolveEntityPackWithSubstitution pack, ICppClassResolveEntity e, CppViewPos& viewPos);
    private static TResolveEntity FindLocalEntitySubstitution(ICppResolveEntity e, List`1<ICppScopeResolveEntity> scopes, ICppScopeResolveEntity substitutedScope, ICppSubstitutionContext subst);
    private static TResolveEntity FindLocalEntitySubstitution(ICppResolveEntity e, List`1<ICppScopeResolveEntity> scopes, ICppFunctionDeclaratorResolveEntity substitutedFunc, ICppSubstitutionContext subst);
    private static bool ContainsSubstitutionForAllParameters(ICppSubstitutionContext subst, CppTemplateParametersBase templParams);
    private static bool ContextContainsSubstitutionForParameter(ICppSubstitutionContext subst, IList`1<ICppTemplateParameter> templParams, HashSet`1<CppTemplateParameterTag> tagsWeDontDepend);
    private static bool DependsOn(ICppFunctionDeclaratorResolveEntity func, ICppSubstitutionContext subst);
    [CanBeNullAttribute]
private static ICppGroupedFunctionDeclaratorResolveEntity FindGroupedFunctionInSpecializations(ICppFunctionTemplateDeclaratorResolveEntity funcTempl, ICppFunctionDeclaratorResolveEntity ungroupedFunc);
    [CanBeNullAttribute]
public static ICppGroupedFunctionDeclaratorResolveEntity FindGroupedFunction(ICppFunctionDeclaratorResolveEntity ungroupedFunc, CppViewPos& vp);
    private static CppDoSubstituteResult`1<ICppClassResolveEntity> GetFriendFunctionLookupParent(ICppFunctionDeclaratorResolveEntity func, ICppResolvedTypeFactory tf);
    private static CppDoSubstituteResult`1<ICppFunctionDeclaratorResolveEntity> FindSubstitutedFunction(ICppGroupedFunctionDeclaratorResolveEntity groupedFunc, CppTypeContext& tc, ICppSubstitutionContext subst, bool canReturnNull);
    private static CppDoSubstituteResult`1<ICppFunctionDeclaratorResolveEntity> FindSubstitutedForFriendFunction(ICppFunctionDeclaratorResolveEntity ungroupedFunc, CppTypeContext& tc, ICppSubstitutionContext subst);
    private static CppDoSubstituteResult`1<ICppFunctionDeclaratorResolveEntity> FindSubstitutedFunction(ICppFunctionDeclaratorResolveEntity ungroupedFunc, CppTypeContext& tc, ICppSubstitutionContext subst, bool canReturnNull);
    private static ICppParameterListResolveEntity TryFindParameterListOverCurrentSubstituted(ICppGroupedFunctionDeclaratorResolveEntity owningFunc, CppTypeContext& tc, ICppSubstitutionContext subst);
    [CanBeNullAttribute]
private static ICppGroupedVariableDeclaratorResolveEntity FindSubstitutedParameter(ICppParameterListResolveEntity substitutedParamList, ICppDeclaratorResolveEntity groupedDeclarator, ICppSubstitutionContext subst);
    private static CppDoSubstituteResult`1<TOutResolveEntity> FindLocalEntitySubstitution(TInResolveEntity e, ICppScopeResolveEntity parent, CppTypeContext& tc, ICppSubstitutionContext subst);
    private static bool SubstitutionsAreEqual(CppSubstitutionContext a, ICppSubstitutionContext b);
    private static bool IsSubstitutionOfGenericClass(ICppClassResolveEntity clazz);
    private static T FindSubstitutedGroupedDeclarator(ICppDeclaratorResolveEntityPack pack, T groupedDeclarator);
    private static T FindSubstitutedGroupedDeclaratorWithoutImplicits(ICppDeclaratorResolveEntityPack pack, T groupedDeclarator);
    private static CppSmallList`1<ICppResolveEntity> ToList(CppDoSubstituteResult`1<TResolveEntity> r);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSuperModuleEntity : object {
    public ICppTypeModuleEntity ClassEntity;
    public CppDependentInfo DependentInfo;
    public CppSuperModuleEntity(ICppTypeModuleEntity classEntity, CppDependentInfo dependentInfo);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSuperResolveEntity : object {
    private ICppClassOrUndeterminedSpecializationResolveEntity myCent;
    private CppDependentInfo myDepInfo;
    public CppDependentInfo DependentInfo { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppSuperResolveEntity(ICppClassOrUndeterminedSpecializationResolveEntity cent, CppViewPos& viewPos);
    public CppSuperResolveEntity(ICppClassOrUndeterminedSpecializationResolveEntity cent, CppDependentInfo depInfo);
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public sealed virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public sealed virtual CppDependentInfo get_DependentInfo();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public ICppClassOrUndeterminedSpecializationResolveEntity GetClassResolveEntity();
    public IEnumerable`1<ICppClassResolveEntity> GetEntities();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    private static CppDependentInfo CalculateDependentInfo(ICppClassOrUndeterminedSpecializationResolveEntity cent, CppViewPos& viewPos);
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSwitchStatementBuilder : CppScopeStatementBuilder`2<CppSwitchStatementSymbol, CppSwitchStatementResolveEntity> {
    public CppSwitchStatementBuilder(ICppBuilder parent);
    protected virtual CppSwitchStatementSymbol CreateSymbol(CppSymbolLocation location);
    protected virtual CppSwitchStatementResolveEntity CreateResolveEntity(ICppScopeResolveEntity parent, CppLocationAnchor anchor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSwitchStatementModuleEntity : CppControlStructureStatementModuleEntity {
    public CppSwitchStatementModuleEntity(CppLocationAnchor anchor, CppRegularFunctionModuleEntity function);
    public virtual ICppStatementResolveEntity Import(CppScopeResolveEntityBase targetParent, CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSwitchStatementResolveEntity : CppControlStructureScopeResolveEntity {
    private static CppQualifiedId ourName;
    public CppQualifiedNamePart Name { get; }
    public CppSwitchStatementResolveEntity(ICppResolveEntity parentScope, CppLocationAnchor loc);
    private static CppSwitchStatementResolveEntity();
    public virtual CppQualifiedNamePart get_Name();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSwitchStatementResolveEntityWithSubstitution : CppSwitchStatementResolveEntity {
    public CppSwitchStatementResolveEntityWithSubstitution(ICppResolveEntity parentScope, CppLocationAnchor loc);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSwitchStatementSymbol : CppScopeStatementSymbol {
    public CppSwitchStatementSymbol(CppSymbolLocation loc);
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSymbol : object {
    [CompilerGeneratedAttribute]
private CppComplexOffset <ComplexOffset>k__BackingField;
    public CppSymbolLocation Location { get; }
    public CppFileLocation ContainingFile { get; }
    public CppComplexOffset ComplexOffset { get; private set; }
    public string DbgDescription { get; }
    protected CppSymbol(CppComplexOffset offset);
    public sealed virtual CppSymbolLocation get_Location();
    public abstract virtual CppFileLocation get_ContainingFile();
    [CompilerGeneratedAttribute]
public sealed virtual CppComplexOffset get_ComplexOffset();
    [CompilerGeneratedAttribute]
private void set_ComplexOffset(CppComplexOffset value);
    public virtual void ShiftLocation(int textOffsetDelta);
    public virtual TextRange LocateTextRange();
    public virtual DocumentRange LocateDocumentRange(ISolution solution);
    public abstract virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual string get_DbgDescription();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSymbolConstraintClause : ValueType {
    public string Name;
    public CppList`1<ICppGenericConstraint> Constraints;
    public CppSymbolConstraintClause(string name, CppList`1<ICppGenericConstraint> constraints);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSymbolDataIntern : object {
    private static ICppSymbolDataInternStrategy modreq(System.Runtime.CompilerServices.IsVolatile) myInternStrategy;
    private static CppSymbolDataIntern();
    public static string Intern(string str);
    public static CppQualifiedNamePart Intern(CppQualifiedNamePart namePart);
    public static void SetInternMode(bool allowIntern);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSymbolEqualityComparer : object {
    public static CppSymbolEqualityComparer INSTANCE;
    private static CppSymbolEqualityComparer();
    public sealed virtual bool Equals(ICppSymbol lhs, ICppSymbol rhs);
    public sealed virtual int GetHashCode(ICppSymbol obj);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSymbolEqualsVisitor : object {
    [CompilerGeneratedAttribute]
private ICppEqualityComparer <Engine>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppSymbol <Rhs>k__BackingField;
    protected ICppEqualityComparer Engine { get; }
    protected ICppSymbol Rhs { get; private set; }
    public CppSymbolEqualsVisitor(ICppSymbol symbol, ICppEqualityComparer engine);
    [CompilerGeneratedAttribute]
protected ICppEqualityComparer get_Engine();
    [CompilerGeneratedAttribute]
protected ICppSymbol get_Rhs();
    [CompilerGeneratedAttribute]
private void set_Rhs(ICppSymbol value);
    public virtual bool Visit(CppClassSymbol lhs);
    public virtual bool Visit(CppFwdClassSymbol lhs);
    public sealed virtual bool Visit(CppDeserializedFromModuleClassSymbol lhs);
    public virtual bool Visit(CppEnumWithBaseSymbol lhs);
    public virtual bool Visit(CppFwdEnumWithBaseSymbol lhs);
    public virtual bool Visit(CppDeclarationSymbol lhs);
    public virtual bool Visit(ICppDeclaratorSymbol lhs);
    public virtual bool Visit(CppParameterDeclaratorSymbol lhs);
    public virtual bool Visit(CppEnumeratorSymbol lhs);
    public virtual bool Visit(CppNamespaceSymbol lhs);
    public virtual bool Visit(CppNamespaceAliasSymbol lhs);
    public virtual bool Visit(CppNamespaceQualifierSymbol lhs);
    public sealed virtual bool Visit(CppExportBlockSymbol lhs);
    public sealed virtual bool Visit(CppLinkageSpecSymbol lhs);
    public virtual bool Visit(CppTypeTemplateParameterSymbol lhs);
    public virtual bool Visit(CppTypeTemplateParameterPackSymbol lhs);
    public virtual bool Visit(CppExpressionTemplateParameterSymbol lhs);
    public virtual bool Visit(CppExpressionTemplateParameterPackSymbol lhs);
    public virtual bool Visit(CppTemplateTemplateParameterSymbol lhs);
    public virtual bool Visit(CppTemplateTemplateParameterPackSymbol lhs);
    public virtual bool Visit(CppGenericParameterSymbol lhs);
    public virtual bool Visit(CppConceptTypeTemplateParameterSymbol lhs);
    public virtual bool Visit(CppConceptTypeTemplateParameterPackSymbol lhs);
    public virtual bool Visit(CppUsingDeclarationSymbol lhs);
    public virtual bool Visit(CppUsingDirectiveSymbol lhs);
    public virtual bool Visit(CppUsingEnumDeclarationSymbol lhs);
    public virtual bool Visit(CppAliasDeclarationSymbol lhs);
    public virtual bool Visit(CppLambdaSymbol lhs);
    public virtual bool Visit(CppConceptDefinitionSymbol lhs);
    public sealed virtual bool Visit(CppAnonymousCStructDeclarationSymbol lhs);
    public virtual bool Visit(CppRequiresExpressionSymbol lhs);
    public virtual bool Visit(CppRequiresExpressionItemSimpleSymbol lhs);
    public virtual bool Visit(CppRequiresExpressionItemNestedSymbol lhs);
    public virtual bool Visit(CppRequiresExpressionItemTypenameSymbol lhs);
    public virtual bool Visit(CppRequiresExpressionItemCompoundSymbol lhs);
    public virtual bool Visit(CppGGDeclareHungarianSymbol lhs);
    public virtual bool Visit(CppLambdaInitCaptureSymbol lhs);
    public virtual bool Visit(CppCxxCliPropertySymbol lhs);
    public virtual bool Visit(CppCxxCliDelegateSymbol lhs);
    public virtual bool Visit(CppCatchBlockSymbol symbol);
    public virtual bool Visit(CppCompoundStatementSymbol symbol);
    public virtual bool Visit(CppSwitchStatementSymbol symbol);
    public virtual bool Visit(CppIfStatementSymbol lhs);
    public virtual bool Visit(CppDoStatementSymbol lhs);
    public virtual bool Visit(CppWhileStatementSymbol lhs);
    public virtual bool Visit(CppForStatementSymbol lhs);
    public virtual bool Visit(CppReturnStatementSymbol lhs);
    public virtual bool Visit(CppGotoStatementSymbol lhs);
    public virtual bool Visit(CppCtorInitializerStatementSymbol lhs);
    public virtual bool Visit(CppExpressionStatementSymbol lhs);
    public virtual bool Visit(CppStructuredBindingSymbol symbol);
    public virtual bool Visit(CppHLSLBufferSymbol lhs);
    public virtual bool Visit(CppPPDefineSymbol lhs);
    public virtual bool Visit(CppPPMacroParameterSymbol lhs);
    public virtual bool Visit(CppModuleDirectiveSymbol lhs);
    public virtual bool Visit(CppImportHeaderUnitDirectiveSymbol lhs);
    public virtual bool Visit(CppImportModuleDirectiveSymbol lhs);
    public virtual bool Visit(CppPPUndefSymbol lhs);
    public virtual bool Visit(CppPPIncludeSymbol lhs);
    public virtual bool Visit(CppPPPragmaSymbol lhs);
    public bool VisitConceptTemplateParameterSymbol(CppConceptTemplateParameterSymbolBase lhs, CppConceptTemplateParameterSymbolBase rhs);
    public bool VisitLoopStatement(Symbol lhs);
    private static bool VisitDefinitionClassSymbol(ICppDefinitionClassSymbol lhs, ICppDefinitionClassSymbol rhs);
    private static bool AnchorDeltaAreEqual(ICppClassSymbol lhs, ICppClassSymbol rhs);
    protected virtual bool VisitScopeSymbol(CppScopeSymbol lhs);
    protected virtual bool VisitParserSymbol(ICppParserSymbol lhs);
    protected virtual bool VisitSymbol(ICppSymbol lhs);
    protected bool CompareWithDeclaratorSymbolIgnoringType(ICppDeclaratorSymbol lhs);
    protected bool ReApply(ICppSymbol lhs, ICppSymbol newRhs);
    protected bool BaseDescriptionsAreEqual(CppBasicBaseDescription`1<CppQualifiedName> lhs, CppBasicBaseDescription`1<CppQualifiedName> rhs);
    protected bool BaseDescriptionListsAreEqual(CppList`1<CppBasicBaseDescription`1<CppQualifiedName>> lhs, CppList`1<CppBasicBaseDescription`1<CppQualifiedName>> rhs);
    protected bool TemplateParameterSymbolsAreEqual(CppSymbolTemplateParameters lhs, CppSymbolTemplateParameters rhs);
    protected bool TemplateParameterSymbolsListsAreEqual(CppSymbolTemplateParametersList lhs, CppSymbolTemplateParametersList rhs);
    public sealed virtual bool Visit(BSBlockSymbol lhs);
    public sealed virtual bool Visit(BSBlockShaderSymbol lhs);
    public sealed virtual bool Visit(BSBlockShaderInterfaceSymbol lhs);
    public sealed virtual bool Visit(BSCustomizationPointSymbol lhs);
    public sealed virtual bool Visit(BSCustomizationPointImplementationSymbol lhs);
    public sealed virtual bool Visit(BSTemplateSymbol lhs);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSymbolLocation : ValueType {
    public static CppSymbolLocation INVALID;
    private CppComplexOffset myOffset;
    [CompilerGeneratedAttribute]
private CppFileLocation <ContainingFile>k__BackingField;
    public CppFileLocation ContainingFile { get; }
    public int TextOffset { get; }
    public int OffsetInSubstitution { get; }
    public CppComplexOffset ComplexOffset { get; }
    public bool IsInvalid { get; }
    public CppSymbolLocation(CppFileLocation file, CppComplexOffset offset);
    private static CppSymbolLocation();
    [CompilerGeneratedAttribute]
public CppFileLocation get_ContainingFile();
    public int get_TextOffset();
    public int get_OffsetInSubstitution();
    public CppComplexOffset get_ComplexOffset();
    public bool get_IsInvalid();
    public sealed virtual bool Equals(CppSymbolLocation rhs);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSymbolLocator : object {
    private ICppRootFileResolveEntitiesCache myFileCache;
    private OneToSetMap`2<ICppParserSymbol, ICppScopeResolveEntity> myTopLevelSymbolToParentScopes;
    private OneToListMap`2<ICppParserSymbol, CppPendingActionWithResultActivator`1<ICppClassResolveEntity>> myAnonymousClassPendingActions;
    private CppResolveEntitySearcher myCurrentSearcher;
    public CppSymbolLocator(ICppRootFileResolveEntitiesCache fileCache);
    public OneToSetMap`2<ICppParserSymbol, ICppResolveEntity> FindResolveEntities(IEnumerable`1<ICppParserSymbol> symbols);
    public void LearnClassPendingActionAdded(CppPendingActionWithResultActivator`1<ICppClassResolveEntity> activator, ICppClassSymbol sym, ICppScopeResolveEntity lexicalScope, ICppScopeResolveEntity structuralParent);
    public void LearnSymbolAddedInsideScope(ICppParserSymbol symbol, ICppScopeResolveEntity lexicalScope, ICppScopeResolveEntity structuralParent);
    public void LearnSymbolPartAdded(ICppParserSymbol symbol, ICppScopeResolveEntity lexicalScope, ICppResolveEntity ent);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSymbolPartAddedToClass : object {
    private ICppMutableClassResolveEntity myCent;
    private bool myIsDefinition;
    private int myAttributesCount;
    private CppClassVirtualSpecifiers myVirtualSpecifiers;
    public CppSymbolPartAddedToClass(ICppMutableClassResolveEntity cent, bool isDefinition, int attributesCount, CppClassVirtualSpecifiers virtualSpecifiers);
    public sealed virtual void Rollback();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSymbolTableMergerUtil : object {
    [ExtensionAttribute]
public static int ComputeAnchorDeltaForPendingAction(ICppClassSymbol cls);
    [ExtensionAttribute]
public static int ComputeAnchorDeltaForPendingAction(CppDeclaratorSymbol dsym);
    [ExtensionAttribute]
public static bool CanSymbolCreateNamedClassInOuterNamespace(ICppClassSymbol cls);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSymbolTemplateParameters : ValueType {
    public CppTemplateHeaderType HeaderType;
    public CppSmallArray`1<ICppTemplateParameterSymbol> Parameters;
    public ICppExpression RequiresClause;
    public CppSymbolTemplateParameters(CppTemplateHeaderType headerType, ICppTemplateParameterSymbol single);
    public CppSymbolTemplateParameters(CppTemplateParameterSymbols header);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSymbolTemplateParametersList : object {
    public FrugalLocalList`1<CppSymbolTemplateParameters> Headers;
    public CppSymbolConstraintClause[] WhereList;
    public CppSymbolTemplateParametersList(CppSymbolTemplateParameters[] headers, CppSymbolConstraintClause[] whereList);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSymbolTemplateParametersListUtil : object {
    public static string TemplateParameterSymbolsToString(CppSymbolTemplateParametersList list);
    public static string TemplateParameterSymbolsToString(CppSymbolTemplateParameters list);
    public static CppSymbolTemplateParametersList CreateSymbolTemplateParameters(List`1<CppTemplateParameterSymbols> paramList, CppList`1<CppSymbolConstraintClause> whereClauses);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppSymbolUtil : object {
    public static string GetAnonymousSymbolName(int locationHash);
    [ExtensionAttribute]
public static void ProcessWithChildren(ICppSymbol symbol, Action`1<ICppSymbol> action);
    [ExtensionAttribute]
public static ICppParserSymbol GetStructuralParent(ICppParserSymbol symbol);
    [ExtensionAttribute]
public static ICppParserSymbol GetParentSkippingTopLevelBlocks(ICppParserSymbol symbol);
    [ExtensionAttribute]
public static ICppParserSymbol SkipTopLevelBlocks(ICppParserSymbol symbol);
    [ExtensionAttribute]
public static CppDeclaratorSymbol GetEnclosingDeclarator(ICppParserSymbol sym, bool returnSymbol);
    [ExtensionAttribute]
public static ICppNamespaceSymbol GetEnclosingNamespace(ICppParserSymbol sym, bool returnSymbol);
    [ExtensionAttribute]
public static ICppClassSymbol GetEnclosingClass(ICppParserSymbol symbol, bool returnSymbol);
    [ExtensionAttribute]
public static ICppClassSymbol GetClassByMember(ICppParserSymbol symbol);
    [ExtensionAttribute]
public static ICppParserSymbol GetRootSymbol(ICppParserSymbol symbol);
    [ExtensionAttribute]
public static CppSymbolTemplateParametersList GetParamList(ICppParserSymbol symbol);
    [ExtensionAttribute]
public static string PresentSymbol(ICppParserSymbol symbol);
    [ExtensionAttribute]
public static string PresentPPSymbol(ICppPPSymbol symbol);
    [ExtensionAttribute]
public static String[] PresentTemplateParametersAsArray(ICppParserSymbol symbol);
    [ExtensionAttribute]
public static string PresentTemplateParameterSymbol(ICppTemplateParameterSymbol symbol);
    public static string PresentTemplateParameterSymbols(IList`1<ICppTemplateParameterSymbol> symbols);
    [ExtensionAttribute]
public static void CollectSymbols(ICppSymbol symbol, ICollection`1<ICppSymbol> output);
    [ExtensionAttribute]
public static HashSet`1<ICppSymbol> CollectSymbols(ICppSymbol symbol);
    [ExtensionAttribute]
public static CppQualifiedName GetQualifiedName(ICppParserSymbol symbol);
    [ExtensionAttribute]
public static CppQualifiedName GetQualifiedInnerName(ICppParserSymbol symbol);
    [ExtensionAttribute]
public static CppQualifiedName GetNestedName(ICppParserSymbol sym);
    private static CppQualifiedName GetQualifiedNameImpl(ICppParserSymbol sym, CppQualifiedName currentName, bool stopAtNamespace);
    private static CppQualifiedName GetQualifiedInnerNameImpl(ICppParserSymbol sym, CppQualifiedName currentName);
    public static CppComplexOffset ComplexOffsetBySymbol(ICppSymbol symbol);
    public static ICppSymbol FindSymbolByOffset(ICppSymbol[] list, CppComplexOffset offset);
    [ExtensionAttribute]
public static string GetShortName(ICppSymbol symbol);
    [ExtensionAttribute]
public static bool IsTypeSymbol(ICppParserSymbol sym);
    [ExtensionAttribute]
public static bool IsTopLevelSymbol(ICppParserSymbol symbol);
    [ExtensionAttribute]
public static bool IsDeclaration(ICppSymbol symbol);
    [ExtensionAttribute]
public static bool IsDefinition(ICppSymbol symbol);
    [ExtensionAttribute]
public static bool ContainsDefinition(IEnumerable`1<ICppParserSymbol> symbols);
    [ExtensionAttribute]
public static bool IsTypedef(ICppSymbol symbol);
    [ExtensionAttribute]
public static bool IsNonStableFwdClassSymbol(ICppSymbol symbol);
    [ExtensionAttribute]
public static bool IsExplicitInstantiation(ICppSymbol symbol);
    [ExtensionAttribute]
public static bool IsFwdClassExplicitInstantiation(ICppSymbol sym);
    [ExtensionAttribute]
public static bool IsNamespaceSymbol(ICppSymbol symbol);
    [ExtensionAttribute]
public static bool IsFriend(ICppParserSymbol symbol);
    [ExtensionAttribute]
public static bool IsSpecialization(ICppParserSymbol symbol);
    [ExtensionAttribute]
public static void FindSymbolsByOffset(ICppSymbol root, CppComplexOffset offset, List`1<ICppSymbol> result);
    [ExtensionAttribute]
public static void ProcessNestedSymbols(ICppSymbol symbol, Action`1<ICppSymbol> action);
    public static T FindSymbol(CppSymbolLocation loc, ISolution solution);
    public static ICppSymbol FindContainingChildOf(ICppParserSymbol source, ICppParserSymbol parent);
    public static bool IsSymbolValid(CppGlobalSymbolCache globalCache, ICppParserSymbol symbol);
    public static bool IsSymbolValid(CppGlobalSymbolCache globalCache, ICppPPSymbol symbol);
    [ExtensionAttribute]
public static bool HasSourceFile(ICppSymbol sym, ISolution solution);
    public static ICollection`1<string> GetNamesOfSymbolTemplateParameters(CppSymbolTemplateParametersList paramList);
}
[DefaultMemberAttribute("Item")]
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateArgumentPackBase`1 : CppTemplateArgumentPackNonGenericBase {
    protected CppList`1<TArg> myPacked;
    public int Cardinality { get; }
    public ICppTemplateArgument Item { get; }
    protected CppTemplateArgumentPackBase`1(TArg[] packed);
    public virtual int get_Cardinality();
    public virtual ICppTemplateArgument get_Item(int i);
    public virtual IEnumerable`1<ICppTemplateArgument> Unpack();
    public virtual void IncreaseCardinality(int val);
    public virtual void SetElement(int index, ICppTemplateArgument value);
    public virtual void Push(ICppTemplateArgument arg);
}
[DefaultMemberAttribute("Item")]
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateArgumentPackNonGenericBase : object {
    public int Cardinality { get; }
    public ICppTemplateArgument Item { get; }
    public abstract virtual int get_Cardinality();
    public abstract virtual ICppTemplateArgument get_Item(int i);
    public abstract virtual IEnumerable`1<ICppTemplateArgument> Unpack();
    public abstract virtual void IncreaseCardinality(int val);
    public abstract virtual void SetElement(int index, ICppTemplateArgument value);
    public abstract virtual void Push(ICppTemplateArgument arg);
    public abstract virtual ICppTemplateArgument MakeInvalidElement();
    public abstract virtual ICppTemplateArgumentPack New(int cardinality);
    public abstract virtual ICppTemplateArgumentPack Clone();
    public abstract virtual Result Accept(Data data, ICppTemplateArgumentVisitor`2<Result, Data> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateArgumentsBuilder : object {
    private CppList`1<ICppTemplateArgument> myArgs;
    public static CppTemplateArgumentsBuilder Create();
    public sealed virtual ICppDeclarationBuilder CreateDeclarationBuilder(ICppBuilder parent, bool createParameters);
    public sealed virtual void LearnQualifiedReference(CppQualifiedNameBuilder& nameBuilder, bool isPackExpansion, bool hadTypename);
    public sealed virtual void LearnQualifiedReference(CppTwinQualifiedNameBuilder& nameBuilder, bool isPackExpansion, bool hadTypename);
    public void LearnQualifiedReference(CppQualifiedName qualName, bool isPackExpansion, bool hadTypename);
    public sealed virtual void LearnTypeId(ICppDeclarationBuilder declBuilder, bool isPackExpansion);
    public void LearnTypeId(CppQualType type, bool isPackExpansion);
    public sealed virtual void LearnExpression(CppExpressionBuilder& exprBuilder, bool isPackExpansion);
    public void LearnExpression(ICppExpression expr, bool isPackExpansion);
    public sealed virtual CppExpressionBuilder CreateExpressionBuilder(bool createSymbols);
    public ICppTemplateArgument[] Arguments();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateArgumentsComparator : object {
    public static CppTemplateArgumentsComparator INSTANCE;
    private ICppEqualityComparer myComparer;
    private CppTemplateArgumentsComparator(ICppEqualityComparer symbolComparer);
    private static CppTemplateArgumentsComparator();
    public sealed virtual bool Equals(ICppTemplateArgument[] a, ICppTemplateArgument[] b);
    public sealed virtual int GetHashCode(ICppTemplateArgument[] a);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateArgumentUtil : object {
    [ExtensionAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertTemplateArgumentsNotNull(ReadOnlySpan`1<ICppTemplateArgument> args);
    [ExtensionAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertTemplateArgumentsNotNull(ICppTemplateArgument[] args);
    [ExtensionAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertTemplateArgumentsIsResolved(ICppTemplateArgument[] args);
    [ExtensionAttribute]
public static int FlattenedLength(ICppTemplateArgument[] args);
    [ExtensionAttribute]
public static ICppTemplateArgument[] Flatten(ICppTemplateArgument[] args);
    [ExtensionAttribute]
public static ICppTemplateArgument[] FlattenIfContainsPacks(ICppTemplateArgument[] args);
    [ExtensionAttribute]
public static bool ContainsPack(ICppTemplateArgument[] args);
    [ExtensionAttribute]
public static bool ContainsPack(ReadOnlySpan`1<ICppTemplateArgument> args);
    [ExtensionAttribute]
public static CppList`1<ICppTemplateArgument> Flatten(IList`1<ICppTemplateArgument> args);
    public static bool TemplateArgumentsListsAreStructurallyEqual(ICppTemplateArgument[] a, ICppTemplateArgument[] b);
    [ExtensionAttribute]
public static ICppTemplateArgument[] ResolveTemplateArguments(ReadOnlySpan`1<ICppTemplateArgument> args, CppTypeContext& tc, ICppFileResolveEntitiesCache fileCache);
    [ExtensionAttribute]
public static ICppTemplateArgument[] ResolveTemplateArguments(ICppTemplateArgument[] args, CppTypeContext& tc, ICppFileResolveEntitiesCache fileCache);
    public static ICppTemplateArgument CreateUnknownArgumentForParameter(ICppTemplateParameter par);
    public static ICppTemplateArgument CreateUnknownArgumentForAuto();
    public static CppList`1<ICppTemplateArgument> CreateArgumentsFromSubstitution(CppTypeContext& tc, CppTemplateId id, CppSubstitutionContext subst);
    public static ICppTemplateArgument ResolveTemplateArgument(ICppTemplateArgument arg, CppTypeContext& tc, ICppFileResolveEntitiesCache fileCache);
    private static ICppTemplateArgument ResolveTypeTemplateArgument(CppQualType type, CppTypeContext& tc);
    private static CppExpressionTemplateArgument ResolveExpressionTemplateArgument(CppExpressionTemplateArgument exprArg, CppTypeContext& tc, ICppFileResolveEntitiesCache fileCache);
    public static ICppTemplateArgument[] ResolveTemplateArguments(CppViewPos& viewPos, ICppTemplateArgument[] args);
    public static ICppTemplateArgument CreateClassAndReplaceClassType(ICppTemplateArgument arg, CppCreateClassAndReplaceClassTypeContext& ctx);
    public static ICppTemplateArgument[] CreateClassAndReplaceClassType(ICppTemplateArgument[] args, CppCreateClassAndReplaceClassTypeContext& ctx);
    [ExtensionAttribute]
public static string TemplateArgumentsToString(ICppTemplateArgument[] args);
    [ExtensionAttribute]
public static CppDependentInfo GetDependentInfo(ICppTemplateArgument arg);
    [ExtensionAttribute]
public static CppDependentInfo GetDependentInfo(ICppTemplateArgument[] args);
    [ExtensionAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertTypeClass(ICppTemplateArgument arg, CppTypeClasses typec);
    [ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertTypeClass(ICppTemplateArgument[] args, CppTypeClasses typec);
    [ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertTypeClass(ReadOnlySpan`1<ICppTemplateArgument> args, CppTypeClasses typec);
    public static void UpdateLazyMergingInfo(ICppTemplateArgument[] args, ICppLazyMergingDataConsumer resultConsumer);
    public static void UpdateLazyMergingInfo(ICppTemplateArgument arg, ICppLazyMergingDataConsumer resultConsumer);
    [ExtensionAttribute]
public static bool IsSubstitutionFailureTemplateArguments(ICppTemplateArgument[] args);
    [ExtensionAttribute]
public static bool IsSubstitutionFailureTemplateArgument(ICppTemplateArgument arg);
    [ExtensionAttribute]
public static bool IsPackExpansionTemplateArgument(ICppTemplateArgument arg);
    [ExtensionAttribute]
public static ICppTemplateArgument DropPackExpansionTemplateArgument(ICppTemplateArgument arg);
    [ExtensionAttribute]
public static ICppTemplateArgument LookupResultToTemplateArgument(CppLookupResult pp, CppTypeContext& tc, bool isPackExpansion);
    [ExtensionAttribute]
public static ICppTemplateArgument LookupResultToTemplateArgument(CppLookupResult pp, CppTypeContext& tc, bool isPackExpansion, CppQualifiedName lookedUpName, bool hadTypename);
    private static CppQualType GetUnknownLookupFailureType(CppQualifiedName lookedupName, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static ICppTemplateArgument ResolveEntityToTemplateArgument(ICppResolveEntity ent, CppTypeContext& tc, bool isPackExpansion, CppQualifiedName name, bool hadTypename);
    [CompilerGeneratedAttribute]
internal static bool <TemplateArgumentsListsAreStructurallyEqual>g__SpansAreEqual|9_0(ReadOnlySpan`1<ICppTemplateArgument> a, ReadOnlySpan`1<ICppTemplateArgument> b);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateDeclarationBuilder : CppForwardingBuilder {
    private bool myIsExplicitInstantiation;
    private List`1<CppTemplateParameterSymbols> mySymbolsParamList;
    private List`1<CppTemplateParametersBase> myResolveEntitiesParamList;
    private CppList`1<CppSymbolConstraintClause> myUnresolvedWhereClauses;
    public CppTemplateDeclarationBuilder(ICppBuilder parentBuilder);
    public void LearnExplicitInstantiation();
    public void LearnTemplateHeader(CppTemplateHeaderBuilder templateHeaderBuilder);
    public void LearnWhereClause(WhereClauseBuilder whereClauseBuilder);
    public bool IsExplicitInstantiation();
    public List`1<CppTemplateParameterSymbols> SymbolsParamList();
    public List`1<CppTemplateParametersBase> ResolveEntitiesParamList();
    public CppList`1<CppSymbolConstraintClause> UnresolvedWhereClauses();
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateDeclarationBuilderUtil : object {
    public static CppSymbolTemplateParametersList GetSymbolsParamList(CppTemplateDeclarationBuilder templDeclBuilder);
    public static List`1<CppTemplateParametersBase> GetResolveEntitiesParamList(CppTemplateDeclarationBuilder templDeclBuilder);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateFunctionSpecializationModuleEntity : CppRegularFunctionModuleEntityWithTypeWithOptionalData {
    public ICppFunctionModuleEntity PrimaryTemplate;
    public CppTemplateFunctionSpecializationModuleEntity(int index, ICppScopeModuleEntity parent, CppQualifiedNamePart name, CppDeclarationSpecifiers declarationSpecifiers, CppPureVirtualSpecifiers pureVirtualSpecifiers, CppAccessibility accessibility, IEnumerable`1<ICppSymbol> symbols, CppSmallArray`1<ICppAttribute> attributes);
    internal CppTemplateFunctionSpecializationModuleEntity(int index);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateHeaderBuilder : CppForwardingBuilder {
    private Result myResult;
    public CppTemplateHeaderBuilder(ICppBuilder parentBuilder, CppTemplateHeaderType type);
    public sealed virtual CppTypeParameterBuilder CreateTypeParameterBuilder();
    public sealed virtual CppExpressionTemplateParameterDeclarationBuilder CreateNonTypeParameterBuilder();
    public sealed virtual CppTemplateTemplateParameterBuilder CreateTemplateTemplateParameterBuilder();
    public sealed virtual CppConceptParameterBuilder CreateConceptParameterBuilder();
    public sealed virtual void LearnTypeParameter(CppTypeParameterBuilder typeParamBuilder);
    public sealed virtual void LearnNonTypeParameter(CppExpressionTemplateParameterDeclarationBuilder declBuilder);
    public sealed virtual void LearnTemplateTemplateParameter(CppTemplateTemplateParameterBuilder builder);
    public sealed virtual void LearnGenericParameter(CppGenericParameterBuilder builder);
    public sealed virtual void LearnConceptParameter(CppConceptParameterBuilder builder);
    public sealed virtual void LearnRequiresClause(ICppExpression unresolvedExpr, ICppExpression replacedExpr);
    public Result Build();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateHeaders : ValueType {
    public CppListSlice`1<CppTemplateParametersBase> PriorTemplateHeaders;
    public CppTemplateParametersSlice LastTemplateParameters;
    public CppTemplateHeaders(CppListSlice`1& priorTemplateHeaders, CppTemplateParametersSlice& lastTemplateParameters);
    public static CppTemplateHeaders ByOneHeader(CppTemplateParametersBase p);
    public static CppTemplateHeaders ByListOfHeaders(List`1<CppTemplateParametersBase> lp);
    public bool IsEmpty();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateHeadersUtil : object {
    [ExtensionAttribute]
public static List`1<ICppTemplateParameter> GetTemplateDependencies(CppTemplateHeaders& templateHeaders);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateId : object {
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
private CppTemplateParametersBase <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppTemplateArgument[] <Specialization>k__BackingField;
    public CppQualifiedNamePart Inner { get; }
    public CppTemplateParametersBase Parameters { get; }
    public ICppTemplateArgument[] Specialization { get; }
    public CppTemplateId(CppQualifiedNamePart inner, CppTemplateParametersBase parameters, ICppTemplateArgument[] specialization);
    [CompilerGeneratedAttribute]
public CppQualifiedNamePart get_Inner();
    [CompilerGeneratedAttribute]
public CppTemplateParametersBase get_Parameters();
    [CompilerGeneratedAttribute]
public ICppTemplateArgument[] get_Specialization();
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateIdUtil : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsTemplateOrSubstitutionId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsGenericTemplateId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsNonGenericTemplateId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsNonGenericTemplateOrSubstitutionId(CppQualifiedNamePart name);
    public static bool IsMatchingGenericId(CppQualifiedNamePart a, CppQualifiedNamePart b);
    [ExtensionAttribute]
public static bool IsPrimaryTemplateClassId(CppTemplateId entName);
    [ExtensionAttribute]
public static bool IsExplicitSpecializationClassId(CppQualifiedNamePart entName);
    [ExtensionAttribute]
public static bool IsPrimaryTemplateFunctionId(CppTemplateId entName);
    [ExtensionAttribute]
public static bool IsExplicitSpecializationFunctionId(CppTemplateId entName);
    [ExtensionAttribute]
public static bool IsExplicitSpecializationFunctionId(CppQualifiedNamePart entName);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppQualifiedNamePart GetInnerIfTemplateId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppQualifiedNamePart GetInnerIfSubstitutionId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppQualifiedNamePart GetInnerIfTemplateOrSubstitutionId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppGenericParameters GetGenericParametersIfTemplateId(CppQualifiedNamePart name);
    [ExtensionAttribute]
public static ICppTemplateArgument[] CreateIdentityArguments(CppTemplateParametersBase parameters, CppTypeContext& tc);
    [ExtensionAttribute]
public static ICppTemplateArgument CreateIdentityArgumentForParameter(ICppTemplateParameter par, ICppResolvedTypeFactory tf, CppViewPos& vp);
    [ExtensionAttribute]
public static CppQualifiedNamePart ResolveNamePart(CppQualifiedNamePart name, CppViewPos& viewPos);
    [ExtensionAttribute]
public static CppQualifiedNamePart ResolveNamePart(CppQualifiedNamePart name, CppViewPos& viewPosForEverything, CppViewPos& viewPosForConversions, ICppFileResolveEntitiesCache fileCache, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualifiedName ResolveQualifiedName(CppQualifiedName name, CppViewPos& viewPos);
    [ExtensionAttribute]
public static CppQualifiedName ResolveQualifiedName(CppQualifiedName name, CppTypeContext& tc);
    [ExtensionAttribute]
public static CppQualifiedName ResolveQualifiedName(CppQualifiedName name, CppTypeContext& tc, ICppFileResolveEntitiesCache fileCache);
    private static CppQualifiedName ResolveQualifiedNameInternal(CppQualifiedName name, CppTypeContext& tc, ICppFileResolveEntitiesCache fileCache);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static ICppTemplateArgument[] GetTemplateArgumentsIfTemplateOrSubstitutionId(CppQualifiedNamePart name, CppTypeContext& tc);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static CppTemplateParametersBase GetTemplateParametersIfTemplateId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static ICppTemplateArgument[] GetTemplateArgumentsIfSubstitutionId(CppQualifiedNamePart name);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static ICppTemplateArgument[] GetTemplateArgumentsIfSubstitutionOrSpecializationId(CppQualifiedNamePart name);
    [ExtensionAttribute]
public static CppQualifiedNamePart ChangeTemplateToSubstitutionId(CppQualifiedNamePart name, ICppResolvedTypeFactory tf, CppViewPos& vp);
    private static ICppTemplateArgument[] GetArumentsForChangingTemplateIdToSubstitutionId(CppTemplateId name, ICppResolvedTypeFactory tf, CppViewPos& vp);
    [ExtensionAttribute]
public static CppQualifiedName CreateClassAndReplaceClassType(CppQualifiedName iname, CppCreateClassAndReplaceClassTypeContext& ctx);
    [ExtensionAttribute]
public static CppQualifiedNamePart CreateClassAndReplaceClassType(CppQualifiedNamePart name, CppCreateClassAndReplaceClassTypeContext& ctx);
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertTypeClass(CppQualifiedNamePart name, CppTypeClasses typec);
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertTypeClass(CppQualifiedName iname, CppTypeClasses typec);
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertNameIsValidForLookup(CppQualifiedName name);
    [ExtensionAttribute]
public static void UpdateLazyMergingInfo(CppQualifiedNamePart name, ICppLazyMergingDataConsumer resultConsumer);
    [ExtensionAttribute]
public static void UpdateLazyMergingInfo(CppQualifiedName name, ICppLazyMergingDataConsumer resultConsumer);
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateNameResolving : object {
    public static CppTemplateId CalculateUnqualifiedTailName(ICppScopeResolveEntity lexicalParent, CppQualifiedNamePart name, CppLocationAnchor anchor, List`1<CppTemplateParametersBase> templParams);
    public static NameAndStructuralParent CalculateNameAndStructuralParentForResolveEntity(ICppScopeResolveEntity lexicalParent, CppQualifiedName replacedName, CppLocationAnchor anchor, List`1<CppTemplateParametersBase> templParams, bool friendOrElaborated, bool class_, bool isExplicitInstantiation);
    private static bool IsIncompleteClass(ICppScopeResolveEntity scope, CppViewPos& viewPos);
    private static ICppScopeResolveEntity GetClosestStructuralParentOutsideParameterList(ICppScopeResolveEntity lexicalParent);
    private static ICppScopeResolveEntity GetStructuralParentForClassInC(ICppScopeResolveEntity lexicalParent, CppQualifiedNamePart className, ICppFileResolveEntitiesCache resolveCache);
    private static void OrphanAllTemplateParameters(CppTemplateParametersBase templParams);
    private static void OrphanAllTemplateParameters(List`1<CppTemplateParametersBase> templParams);
    private static CppQualifiedNamePart CalculateTailName(CppQualifiedNamePart tail, CppScopeLookupTemplateParametersContext& templCtx, bool nameForClass, bool isExplicitInstantiation, bool isFriend);
    private static bool IsStructuralParentValidForLexicalParent(ICppScopeLikeResolveEntity structuralParent, ICppScopeResolveEntity lexicalParent, bool friend_);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateParameterDependentLinkageEntity : object {
    private CppQualifiedName myName;
    [CompilerGeneratedAttribute]
private ICppLinkageTemplateParameter <TemplateParameter>k__BackingField;
    public ICppLinkageTemplateParameter TemplateParameter { get; }
    public CppQualifiedName Tail { get; }
    public CppQualifiedName DebugQualifiedName { get; }
    public CppTemplateParameterDependentLinkageEntity(ICppLinkageTemplateParameter head, CppQualifiedName name);
    [CompilerGeneratedAttribute]
public ICppLinkageTemplateParameter get_TemplateParameter();
    public CppQualifiedName get_Tail();
    public sealed virtual CppQualifiedName get_DebugQualifiedName();
    public sealed virtual string Present(ICppPresenter presenter);
    public sealed virtual Result Accept(ICppDependentLinkageEntityVisitor`1<Result> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateParameters : CppTemplateParametersHeader {
    private CppCachedReference`1<ICppResolvedExpression> myCachedResolvedRequiresClause;
    private ICppExpression myReplacedRequiresClause;
    public ICppExpression ReplacedRequiresClause { get; public set; }
    public CppTemplateParameters(IEnumerable`1<ICppTemplateParameter> params);
    public ICppExpression get_ReplacedRequiresClause();
    public void set_ReplacedRequiresClause(ICppExpression value);
    public virtual string ToString();
    public virtual ICppResolvedExpression GetResolvedRequiresClause();
    private ICppResolvedExpression CalculateResolvedRequiresClause();
    public void SetResolvedRequiresClause(ICppResolvedExpression value);
}
[DefaultMemberAttribute("Item")]
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateParametersBase : object {
    private static int INDEX_MAP_MIN_SIZE;
    [CanBeNullAttribute]
private OneToListMap`2<CppQualifiedNamePart, int> myNameToIndices;
    private CppList`1<ICppTemplateParameter> myParams;
    [CompilerGeneratedAttribute]
private CppViewPos <ViewPos>k__BackingField;
    public CppViewPos ViewPos { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICppTemplateParameter Item { get; public set; }
    protected CppTemplateParametersBase(IEnumerable`1<ICppTemplateParameter> params);
    [CompilerGeneratedAttribute]
public CppViewPos get_ViewPos();
    [CompilerGeneratedAttribute]
public void set_ViewPos(CppViewPos value);
    public virtual void Add(ICppTemplateParameter p);
    public virtual void Clear();
    public virtual bool Contains(ICppTemplateParameter p);
    public virtual void CopyTo(ICppTemplateParameter[] dest, int idx);
    public virtual bool Remove(ICppTemplateParameter p);
    public virtual int IndexOf(ICppTemplateParameter p);
    public virtual void Insert(int i, ICppTemplateParameter p);
    public virtual void RemoveAt(int i);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual ICppTemplateParameter get_Item(int i);
    public virtual void set_Item(int i, ICppTemplateParameter value);
    private sealed virtual override IEnumerator`1<ICppTemplateParameter> System.Collections.Generic.IEnumerable<JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateParameter>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void CopyTo(int index, ICppTemplateParameter[] array, int arrayIndex, int count);
    public bool ContainsName(CppQualifiedNamePart name);
    public IEnumerable`1<int> NameToIndices(CppQualifiedNamePart name);
    public CppList`1<ICppResolveEntity> Lookup(CppQualifiedNamePart name);
    public CppListEnumerator`1<ICppTemplateParameter> GetEnumerator();
    public virtual string ToString();
    public bool AllParametersAreInvented();
    private void FillIndexMap();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateParametersComparer : CppSemanticalEqualityComparerIgnoringDependentTemplateAliasTypes {
    private CompactMap`2<CppTemplateParameterTag, int> myFunctionTemplateParameterToIndex;
    public void AddTemplateParameters(CppTemplateParametersBase params);
    public virtual bool ReApply(ICppResolveEntity lhs, ICppResolveEntity rhs);
    public virtual int ReApplyHashCode(ICppResolveEntity ent);
    private int HashCodeOfTemplateParameter(ICppTemplateParameter tparam);
    private int HashCodeOfTemplateInstantiation(ICppTemplateInstantiationResolveEntity instantiation);
    public bool TemplateParameterListsAreStructurallyEqual(CppTemplateParametersBase lhs, CppTemplateParametersBase rhs);
    protected virtual int ReApply(CppResolveResult& modreq(System.Runtime.InteropServices.InAttribute) rr);
    private bool CheckTemplateParametersForEquality(ICppTemplateParameter lhs, ICppTemplateParameter rhs);
    private bool TemplateParametersAreStructurallyEqual(ICppTemplateParameter lhs, ICppTemplateParameter rhs);
    private void AddTemplateParametersImpl(CppTemplateParametersBase params, Int32& index);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateParametersHeader : CppTemplateParametersBase {
    protected CppTemplateParametersHeader(IEnumerable`1<ICppTemplateParameter> params);
    public abstract virtual ICppResolvedExpression GetResolvedRequiresClause();
    public static ICppResolvedExpression TryGetResolvedRequiresClause(CppTemplateParametersBase params);
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateParametersHelpers : object {
    public static CppList`1<CppBasicBaseDescription`1<ICppClassOrGenericParameterResolveEntity>> ComputeNonDependentBasesOfGenericParameter(ICppGenericParameter param);
    public static ICppScopeLikeResolveEntity DoSubstitutionGetScopeLikeHelper(ICppTypeTemplateParameter param, CppSubstitutionDriver driver);
    public static ICppScopeLikeResolveEntity DoSubstitutionGetScopeLikeHelper(ICppTypeTemplateParameterPack param, CppSubstitutionDriver driver);
    public static ICppScopeLikeResolveEntity DoSubstitutionGetScopeLikeHelper(ICppGenericParameter param, CppSubstitutionDriver driver);
    public static CppQualType DoSubstitutionGetTypeHelper(ICppTypeTemplateParameterOrPackOrGenericParameter param, CppSubstitutionDriver driver);
    public static CppQualType DoSubstitutionGetTypeHelper(ICppTypeTemplateParameter param, CppSubstitutionDriver driver);
    public static CppQualType DoSubstitutionGetTypeHelper(ICppTypeTemplateParameterPack param, CppSubstitutionDriver driver);
    public static CppQualType DoSubstitutionGetTypeHelper(ICppGenericParameter param, CppSubstitutionDriver driver);
    public static ICppResolvedExpression DoExpressionTemplateParameterSubstitutionHelpers(ICppExpressionTemplateParameter param, CppSubstitutionDriver driver);
    public static ICppResolvedExpression DoExpressionTemplateParameterSubstitutionHelpers(ICppExpressionTemplateParameterPack param, CppSubstitutionDriver driver);
    public static ICppTypeTemplateResolveEntity DoSubstitutionGetTypeTemplateHelper(ICppTemplateTemplateParameter param, CppSubstitutionDriver driver);
    public static CppQualType PatchUpNonTypeTemplateParameterType(CppQualType type, ICppResolvedTypeFactory tf);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateParametersSlice : ValueType {
    private CppListSlice`1<ICppTemplateParameter> mySlice;
    public int Count { get; }
    public CppTemplateParametersSlice(CppTemplateParametersBase params, int base, int bound);
    public static CppTemplateParametersSlice Snapshot(CppTemplateParametersBase p);
    public int get_Count();
    public bool IsEmpty();
    public IEnumerable`1<ICppResolveEntity> Lookup(CppQualifiedNamePart name);
    public sealed virtual IEnumerator`1<ICppTemplateParameter> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateParametersSubstitutionContext : CppSubstitutionContextWithoutExpansion {
    public virtual bool TryGetExpansion(CppTemplateParameterTag tag, ICppTemplateArgument& result);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateParametersUtil : object {
    [ExtensionAttribute]
public static ParameterKind GetParameterKind(ICppTemplateParameter param);
    public static void ReplaceTemplateParameterTags(CppTemplateParametersBase templParams, CppTemplateId originalSpecializationName);
    public static void BorrowGenericParameterConstraints(CppTemplateParametersBase templParams, CppTemplateId originalSpecializationName);
    [ExtensionAttribute]
public static ICppTemplateParameter UnwrapSubstitution(ICppTemplateParameter param);
    public static int GetFirstTemplateParameterPackIndex(CppTemplateParametersBase parameters);
    public static CppTemplateParametersBase Flatten(IList`1<CppTemplateParametersBase> parameters);
    public static bool HasConstraints(CppTemplateParametersBase parameters);
    public static TriBool IsSubstitutionMatchingConstraints(CppTemplateParametersBase parameters, ICppSubstitutionContext subst, CppTypeContext& ctx, ICppResolvedExpression& constraint);
    public static TriBool IsSubstitutionMatchingConstraints(CppTemplateParametersBase parameters, ICppSubstitutionContext subst, CppTypeContext& ctx, ICppResolvedExpression& constraint, Int32& badArg);
    public static List`1<ICppResolvedExpression> GetConstraintExpressionList(CppTemplateParametersBase parameters, ICppResolvedExpression extra);
    public static CppTemplateParametersBase CreateTemplateParameterResolveEntities(ICppScopeResolveEntity lexicalParent, CppLocationAnchor anchor, IList`1<CppTemplateParametersBase> priors, CppSymbolTemplateParameters syms, CppCreateClassAndReplaceClassTypeContext emptyContext);
    public static List`1<CppTemplateParametersBase> CreateTemplateParameterResolveEntities(ICppScopeResolveEntity lexicalParent, CppLocationAnchor anchor, CppSymbolTemplateParametersList syms, CppCreateClassAndReplaceClassTypeContext emptyContext);
    private static ICppTemplateParameter CreateTemplateParameterResolveEntity(ICppScopeResolveEntity lexicalParent, CppLocationAnchor anchor, IList`1<CppTemplateParametersBase> priors, CppTemplateParametersBase currentHeader, ICppTemplateParameterSymbol sym, CppCreateClassAndReplaceClassTypeContext emptyContext);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateParametersWithSubstitution : CppTemplateParametersHeader {
    private CppTemplateParametersHeader myInner;
    private CppViewPos myPointOfInstantiation;
    private ICppSubstitutionContext mySubstitution;
    private CppCachedReference`1<ICppResolvedExpression> myCachedResolvedRequiresClause;
    public CppTemplateParametersWithSubstitution(CppTemplateParametersHeader inner, CppViewPos& pointOfInstantiation, ICppSubstitutionContext subst);
    public virtual string ToString();
    public CppTemplateParametersHeader GetInner();
    public CppViewPos GetPointOfInstantiation();
    public virtual ICppResolvedExpression GetResolvedRequiresClause();
    private ICppResolvedExpression CalculateResolvedRequiresClause();
    private ICppResolvedExpression SubstituteRequiresClause(ICppFileResolveEntitiesCache cache);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateParameterSymbols : object {
    public CppTemplateHeaderType HeaderType;
    public CppList`1<ICppTemplateParameterSymbol> Parameters;
    public ICppExpression RequiresClause;
    public CppTemplateParameterSymbols(CppTemplateHeaderType headerType);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateParameterTag : object {
    public static CppTemplateParameterTag AutoParameterTag;
    public static CppTemplateParameterTag OrphanedParameterTag;
    public static CppTemplateParameterTag DecltypeAutoParameterTag;
    public static CppTemplateParameterTag ReturnTypeParameterTag;
    private static CppTemplateParameterTag();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateParameterWithSubstitutionBase`1 : object {
    private Inner myInner;
    private CppViewPos myPointOfInstantiation;
    private ICppSubstitutionContext mySubst;
    private CppTemplateParameterTag myTag;
    private CppCachedReference`1<ICppResolvedExpression> myCachedResolvedConceptExpression;
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    protected CppTemplateParameterWithSubstitutionBase`1(Inner inner, CppViewPos& pointOfInstantiation, ICppSubstitutionContext subst);
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual ICppTemplateParameter GetInner();
    public virtual CppViewPos PointOfInstantiation();
    public Inner GetTypedInner();
    public virtual ICppTemplateArgument GetDefault(ICppResolvedTypeFactory tf);
    public virtual bool NameEquals(CppQualifiedNamePart name);
    public virtual ICppSymbol GetSymbol();
    public virtual ICppFileResolveEntitiesCache GetResolveCache();
    public virtual CppTemplateParameterTag GetTag();
    public virtual void ReplaceTag(CppTemplateParameterTag tag);
    public virtual bool IsConcept();
    public virtual bool IsInvented();
    public virtual ICppResolvedExpression GetResolvedConceptExpression();
    private ICppResolvedExpression CalculateResolvedConceptExpression(ICppFileResolveEntitiesCache cache);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateRewritingContext : object {
    private ICppResolvedTypeFactory myTypeFactory;
    private CppTemplateRewritingContext myParentalContext;
    private CppSubstitutionContext myFirstToSecondMapping;
    public CppTemplateRewritingContext(ICppResolvedTypeFactory typeFactory);
    private CppTemplateRewritingContext(CppTemplateRewritingContext parentalContext);
    public bool CompareTemplateParameters(CppViewPos& viewPos, CppTemplateParametersBase p1, CppTemplateParametersBase p2);
    public CppQualType TransformType(CppViewPos& viewPos, CppQualType qualType);
    private bool CompareTemplateParameter(CppViewPos& viewPos, ICppTemplateParameter p1, ICppTemplateParameter p2);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateTemplateArgument : object {
    private ICppTypeTemplateResolveEntity myResolveEntity;
    private CppUnknownEntityInfo myUnknownInfo;
    [CompilerGeneratedAttribute]
private bool <PackExpansion>k__BackingField;
    public bool PackExpansion { get; }
    public CppTemplateTemplateArgument(ICppTypeTemplateResolveEntity ent, bool isPackExpansion);
    public CppTemplateTemplateArgument(CppUnknownEntityInfo info);
    [CompilerGeneratedAttribute]
public bool get_PackExpansion();
    public sealed virtual IEnumerable`1<CppTemplateTemplateArgument> UnpackTemplateArgs();
    public sealed virtual Result Accept(Data data, ICppTemplateArgumentVisitor`2<Result, Data> visitor);
    [CanBeNullAttribute]
public ICppTypeTemplateResolveEntity GetResolveEntity();
    [CanBeNullAttribute]
public CppUnknownEntityInfo GetUnknownInfo();
    public virtual string ToString();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateTemplateArgumentPack : CppTemplateArgumentPackBase`1<CppTemplateTemplateArgument> {
    public CppList`1<CppTemplateTemplateArgument> Packed { get; }
    public CppTemplateTemplateArgumentPack(CppTemplateTemplateArgument[] packed);
    public CppList`1<CppTemplateTemplateArgument> get_Packed();
    public sealed virtual IEnumerable`1<CppTemplateTemplateArgument> UnpackTemplateArgs();
    public virtual Result Accept(Data data, ICppTemplateArgumentVisitor`2<Result, Data> visitor);
    public virtual ICppTemplateArgumentPack Clone();
    public virtual ICppTemplateArgument MakeInvalidElement();
    public virtual ICppTemplateArgumentPack New(int cardinality);
    public virtual string ToString();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateTemplateParameter : CppSimpleTemplateTemplateParameterBase {
    private ICppTemplateArgument myUnresolvedDefault;
    public CppTemplateTemplateParameter(CppTemplateTemplateParameterSymbol sym, CppTemplateParametersBase param, CppViewPos& viewPos, ICppTemplateArgument def);
    public virtual ICppTemplateArgument GetDefault(ICppResolvedTypeFactory tf);
    public virtual ICppTemplateArgument[] GetDefaults(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual ICppTypeTemplateResolveEntity DoSubstitutionGetTypeTemplate(CppSubstitutionDriver substDriver);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateTemplateParameterBase : object {
    private ICppAnyTemplateTemplateParameterSymbol mySymbol;
    protected CppTemplateParameterTag myTag;
    protected CppViewPos myViewPos;
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    protected CppTemplateTemplateParameterBase(ICppAnyTemplateTemplateParameterSymbol sym, CppViewPos& viewPos);
    public virtual CppViewPos GetViewPos();
    public virtual ICppFileResolveEntitiesCache GetResolveCache();
    public abstract virtual CppTemplateParametersBase GetParameters();
    public virtual CppTemplateParameterTag GetTag();
    public virtual void ReplaceTag(CppTemplateParameterTag tag);
    public virtual bool IsConcept();
    public virtual bool IsInvented();
    public virtual ICppResolvedExpression GetResolvedConceptExpression();
    public virtual bool NameEquals(CppQualifiedNamePart name);
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public virtual ICppSymbol GetSymbol();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual ICppTemplateArgument GetDefault(ICppResolvedTypeFactory tf);
    public virtual ICppTemplateArgument[] GetDefaults(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public virtual IEnumerable`1<ICppResolveEntity> GetAllSpecializations();
    public abstract virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateTemplateParameterBuilder : CppForwardingBuilder {
    private Result myParams;
    private CppQualifiedNamePart myName;
    private CppSymbolLocation myLocation;
    private CppQualifiedName myUnresolvedDefault;
    private CppQualifiedName myReplacedDefault;
    private bool myWasBuilt;
    private bool myHasEllipsis;
    private ICppTemplateTemplateParameterSymbol mySymbol;
    private ICppTemplateTemplateParameterOrPack myEntity;
    public CppTemplateTemplateParameterBuilder(CppTemplateHeaderBuilder parentBuilder);
    public sealed virtual CppTemplateHeaderBuilder CreateTemplateHeaderBuilder();
    public sealed virtual void LearnTemplateHeader(CppTemplateHeaderBuilder templateHeaderBuilder);
    public sealed virtual void LearnName(CppPsiBuilder psi);
    public sealed virtual void LearnName(string name);
    public sealed virtual void LearnLocation(CppSymbolLocation loc);
    public sealed virtual void LearnDefaultArgument(CppTwinQualifiedNameBuilder nameBuilder);
    public sealed virtual void LearnEllipsis();
    public sealed virtual ICppTemplateTemplateParameterSymbol GetSymbol();
    public ICppTemplateParameter GetResolveEntity();
    private void Build();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateTemplateParameterPack : CppSimpleTemplateTemplateParameterBase {
    public CppTemplateTemplateParameterPack(CppTemplateTemplateParameterPackSymbol sym, CppTemplateParametersBase param, CppViewPos& viewPos);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual ICppTemplateArgumentPack CreateEmptyMatchingArgumentPack();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateTemplateParameterPackSymbol : CppTemplateTemplateParameterSymbolBase {
    public CppTemplateTemplateParameterPackSymbol(CppQualifiedNamePart name, CppSymbolLocation loc, CppSymbolTemplateParameters parameters);
    public virtual ICppTemplateArgument GetDefault();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateTemplateParameterPackWithSubstitution : CppTemplateTemplateParameterWithSubstitutionBase`1<ICppTemplateTemplateParameterPack> {
    public CppTemplateTemplateParameterPackWithSubstitution(ICppTemplateTemplateParameterPack inner, CppViewPos& pointOfInstantiation, ICppSubstitutionContext subst, CppTemplateParametersBase params);
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual ICppTemplateArgumentPack CreateEmptyMatchingArgumentPack();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateTemplateParameterSymbol : CppTemplateTemplateParameterSymbolBase {
    private CppQualifiedReferenceTemplateArgument myDefault;
    public CppTemplateTemplateParameterSymbol(CppQualifiedNamePart name, CppSymbolLocation loc, CppSymbolTemplateParameters params, CppQualifiedReferenceTemplateArgument def);
    public virtual ICppTemplateArgument GetDefault();
    public CppQualifiedReferenceTemplateArgument GetDefaultTemplate();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateTemplateParameterSymbolBase : CppParameterSymbolBase {
    private CppSymbolTemplateParameters myParameters;
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <NamePart>k__BackingField;
    public CppQualifiedNamePart NamePart { get; }
    protected CppTemplateTemplateParameterSymbolBase(CppQualifiedNamePart name, CppSymbolLocation loc, CppSymbolTemplateParameters parameters);
    public virtual CppSymbolTemplateParameters GetParameters();
    [CompilerGeneratedAttribute]
public virtual CppQualifiedNamePart get_NamePart();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateTemplateParameterWithAppliedArgumentsLinkageEntity : object {
    private int myHashCode;
    [CompilerGeneratedAttribute]
private ICppLinkageTemplateParameter <TemplateParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppLinkageTemplateArgument[] <Arguments>k__BackingField;
    public ICppLinkageTemplateParameter TemplateParameter { get; }
    public ICppLinkageTemplateArgument[] Arguments { get; }
    public CppQualifiedName DebugQualifiedName { get; }
    public CppTemplateTemplateParameterWithAppliedArgumentsLinkageEntity(ICppLinkageTemplateParameter param, ICppLinkageTemplateArgument[] args);
    [CompilerGeneratedAttribute]
public ICppLinkageTemplateParameter get_TemplateParameter();
    [CompilerGeneratedAttribute]
public ICppLinkageTemplateArgument[] get_Arguments();
    public sealed virtual CppQualifiedName get_DebugQualifiedName();
    public sealed virtual Result Accept(ICppDependentLinkageEntityVisitor`1<Result> visitor);
    public sealed virtual string Present(ICppPresenter presenter);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateTemplateParameterWithAppliedArgumentsResolveEntity : CppTemplateWithAppliedArgumentsResolveEntityBase {
    public CppDependentInfo DependentInfo { get; }
    public CppTemplateTemplateParameterWithAppliedArgumentsResolveEntity(ICppTemplateTemplateParameterOrPack p, ICppTemplateArgument[] args);
    public sealed virtual CppDependentInfo get_DependentInfo();
    public sealed virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public sealed virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& vp, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public virtual string ToString();
    public ICppTemplateTemplateParameterOrPack GetTemplateParameter();
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateTemplateParameterWithSubstitution : CppTemplateTemplateParameterWithSubstitutionBase`1<ICppTemplateTemplateParameter> {
    public CppTemplateTemplateParameterWithSubstitution(ICppTemplateTemplateParameter inner, CppViewPos& pointOfInstantiation, ICppSubstitutionContext subst, CppTemplateParametersBase params);
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual ICppTypeTemplateResolveEntity DoSubstitutionGetTypeTemplate(CppSubstitutionDriver substDriver);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateTemplateParameterWithSubstitutionBase`1 : CppTemplateParameterWithSubstitutionBase`1<Inner> {
    private CppTemplateParametersBase myParameters;
    protected CppTemplateTemplateParameterWithSubstitutionBase`1(Inner inner, CppViewPos& pointOfInstantiation, ICppSubstitutionContext subst, CppTemplateParametersBase params);
    public virtual CppTemplateParametersBase GetParameters();
    public virtual ICppTemplateArgument[] GetDefaults(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    public virtual IEnumerable`1<ICppResolveEntity> GetAllSpecializations();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateVariableSpecializationModuleEntity : CppVariableModuleEntity {
    public ICppVariableModuleEntity PrimaryTemplate;
    public CppTemplateVariableSpecializationModuleEntity(int index, ICppScopeModuleEntity parent, CppDeclarationSpecifiers declarationSpecifiers, IEnumerable`1<ICppSymbol> symbols, bool hasDefinition, CppAccessibility accessibility, bool explicitlyExported);
    internal CppTemplateVariableSpecializationModuleEntity(int index);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateWithAppliedArgumentsResolveEntityBase : object {
    private ICppTemplateArgument[] myArgs;
    private ICppTemplateResolveEntity myTempl;
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    protected CppTemplateWithAppliedArgumentsResolveEntityBase(ICppTemplateResolveEntity templ, ICppTemplateArgument[] args);
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual bool IsTemplateInstantiation();
    public virtual ICppTemplateResolveEntity GetTemplate();
    public virtual ICppTemplateArgument[] GetArguments();
    public abstract virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public ICppFileResolveEntitiesCache GetResolveCache();
    public sealed virtual bool Equals(object rhs);
    public sealed virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppThisByValueLambdaCapture : object {
    public static CppThisByValueLambdaCapture INSTANCE;
    private static CppThisByValueLambdaCapture();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppThisLambdaCapture : object {
    public static CppThisLambdaCapture INSTANCE;
    private static CppThisLambdaCapture();
}
internal abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTopLevelBlockBuilder : CppForwardingBuilder {
    protected CppTopLevelBlockBuilder(ICppBuilder parent);
    protected abstract virtual CppTopLevelBlockSymbol GetSymbol();
    public sealed virtual ICppParserSymbol GetClassParentSymbol();
    public void LearnEndOffset(CppComplexOffset offset);
    public virtual void AddChild(CppParserSymbol sym);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTopLevelBlockSymbol : CppScopeSymbol {
    private CppComplexOffset myBodyEndOffset;
    protected CppTopLevelBlockSymbol(CppSymbolLocation loc);
    public CppComplexOffset GetBodyEndOffset();
    public void SetBodyEndOffset(CppComplexOffset endOffset);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTwinBuiltinOffsetOfBuilder : ValueType {
    private CppQualType myUnresolvedTypeArgument;
    private CppQualType myReplacedTypeArgument;
    private CppQualifiedName myMemberDesignator;
    public sealed virtual void LearnTypeArgument(ICppDeclarationBuilder declBuilder);
    public sealed virtual void LearnMemberDesignator(CppTwinQualifiedNameBuilder& nameBuilder);
    public CppQualType GetUnresolvedTypeArgument();
    public CppQualType GetReplacedTypeArgument();
    public CppQualifiedName GetMemberDesignator();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTwinC11GenericExpressionBuilder : ValueType {
    private bool myCreateSymbols;
    private ICppExpression myUnresolvedControllingExpression;
    private ICppExpression myReplacedControllingExpression;
    private CppList`1<CppC11GenericExpressionClause> myUnresolvedClauses;
    private CppList`1<CppC11GenericExpressionClause> myReplacedClauses;
    private bool myIsDefault;
    private CppQualType myUnresolvedType;
    private CppQualType myReplacedType;
    private ICppExpression myUnresolvedExpression;
    private ICppExpression myReplacedExpression;
    public CppTwinC11GenericExpressionBuilder(bool createSymbols);
    public sealed virtual CppTwinExpressionBuilder CreateExpressionBuilder();
    public sealed virtual ICppDeclarationBuilder CreateInnerDeclarationBuilder(ICppBuilder parent);
    public sealed virtual void LearnControllingExpression(CppTwinExpressionBuilder& builder);
    public sealed virtual void LearnDefault();
    public sealed virtual void LearnType(ICppDeclarationBuilder builder);
    public sealed virtual void LearnExpression(CppTwinExpressionBuilder& builder);
    public sealed virtual void ApplyClause();
    public ICppExpression GetUnresolvedExpression();
    public ICppExpression GetReplacedExpression();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTwinDesignatorBuilder : ValueType {
    private CppTwinExpressionBuilder myExpressionBuilder;
    private ICppDesignator myUnresolvedDesignator;
    private ICppDesignator myReplacedDesignator;
    public CppTwinDesignatorBuilder(CppTwinExpressionBuilder exprBuilder);
    public sealed virtual CppTwinExpressionBuilder CreateExpressionBuilder();
    public sealed virtual void LearnSubscriptDesignator(CppTwinExpressionBuilder& index);
    public sealed virtual void LearnMemAccessDesignator(string name);
    public ICppDesignator GetUnresolvedDesignator();
    public ICppDesignator GetReplacedDesignator();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTwinDoubleArgumentTypeTraitExpressionBuilder : ValueType {
    private CppQualType myUnresolvedFirstArgument;
    private CppQualType myReplacedFirstArgument;
    private CppQualType myUnresolvedSecondArgument;
    private CppQualType myReplacedSecondArgument;
    public sealed virtual void LearnFirstArgument(ICppDeclarationBuilder declBuilder);
    public sealed virtual void LearnSecondArgument(ICppDeclarationBuilder declBuilder);
    public CppQualType GetUnresolvedFirstArgument();
    public CppQualType GetReplacedFirstArgument();
    public CppQualType GetUnresolvedSecondArgument();
    public CppQualType GetReplacedSecondArgument();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTwinExpressionBuilder : ValueType {
    private ICppExpression myUnresolvedExpr;
    private ICppExpression myReplacedExpr;
    private bool myCreateSymbols;
    public CppTwinExpressionBuilder(bool createSymbols);
    public ICppExpression GetUnresolvedExpression();
    public ICppExpression GetReplacedExpression();
    public sealed virtual CppTwinExpressionBuilder CreateInnerExpressionBuilder();
    public sealed virtual ICppDeclarationBuilder CreateInnerDeclarationBuilder(ICppBuilder parent);
    public sealed virtual CppTwinQualifiedNameBuilder CreateInnerQualifiedNameBuilder();
    public sealed virtual CppTwinFunctionArgumentListBuilder CreateInnerFunctionArgumentListBuilder();
    public sealed virtual CppTwinDesignatorBuilder CreateDesignatorBuilder();
    public sealed virtual CppTwinC11GenericExpressionBuilder CreateC11GenericExpressionBuilder();
    public sealed virtual void LearnEmptyExpression();
    public sealed virtual void ApplyThrowOperator();
    public sealed virtual void ApplyCStyleCast(ICppDeclarationBuilder declBuilder);
    public sealed virtual void ApplyUnaryOperator(TokenNodeType tok);
    public sealed virtual void ApplyMSAssume();
    public sealed virtual void LearnSizeOfExpression(ICppDeclarationBuilder builder);
    public sealed virtual void LearnSizeOfEllipsisExpression(CppTwinQualifiedNameBuilder& builder);
    public sealed virtual void ApplySizeOf();
    public sealed virtual void LearnAlignOfExpression(ICppDeclarationBuilder builder);
    public sealed virtual void ApplyAlignOf();
    public sealed virtual void LearnMSUuidOfExpression(ICppDeclarationBuilder builder);
    public sealed virtual void ApplyMSUuidOf();
    public sealed virtual void LearnMSEventHookExpression(bool unhook, CppTwinFunctionArgumentListBuilder& builder);
    public sealed virtual void ApplyNoExcept();
    public sealed virtual void ApplyBuiltinAddressOf();
    public sealed virtual void ApplyGnuBuiltinConstantP();
    public sealed virtual void LearnBuiltinOffsetOf(CppTwinBuiltinOffsetOfBuilder builder);
    public sealed virtual void LearnNewExpression(CppTwinNewExpressionBuilder builder);
    public sealed virtual void ApplyDeleteOperator(bool isArrayKind);
    public sealed virtual void LearnSingleArgumentTypeTraitExpression(ICppDeclarationBuilder argumentTypeId, TokenNodeType kwToken);
    public sealed virtual void LearnDoubleArgumentTypeTraitExpression(CppTwinDoubleArgumentTypeTraitExpressionBuilder builder, TokenNodeType kwToken);
    public sealed virtual void LearnMultiArgumentTypeTraitExpression(CppTwinMultiArgumentTypeTraitExpressionBuilder builder, TokenNodeType kwToken);
    public sealed virtual void ApplyCast(TokenNodeType tt, ICppDeclarationBuilder declBuilder);
    public sealed virtual void LearnTypeIdExpression(ICppDeclarationBuilder declBuilder);
    public sealed virtual void ApplyTypeId();
    public sealed virtual void ApplyParen();
    public sealed virtual void LearnQualifiedReferenceExpression(CppTwinQualifiedNameBuilder& qualNameBuilder);
    public sealed virtual void ApplyPostfixOperator(TokenNodeType tt);
    public sealed virtual void ApplyDotOperator(TokenNodeType tt, CppTwinQualifiedNameBuilder& qualNameBuilder);
    public sealed virtual void ApplySubscriptionOperator(CppTwinExpressionBuilder exprBuilder, bool isPackExpansion);
    public sealed virtual void ApplyMultiArgumentSubscriptionOperator(CppTwinFunctionArgumentListBuilder& argListBuilder, bool cli);
    public sealed virtual void LearnCliTypeId(CppTwinQualifiedNameBuilder& nameBuilder);
    public sealed virtual void ApplyBinaryOperator(CppOperatorKind kind, CppTwinExpressionBuilder& exprBuilder);
    public sealed virtual void ApplyConditionalOperator(CppTwinExpressionBuilder& secondArgumentBuilder, CppTwinExpressionBuilder& thirdArgumentBuilder, CppConditionalExprKind kind);
    public sealed virtual void ApplyGnuBuiltinChooseExpr(CppFunctionArgumentListBuilder& argBuilder);
    public sealed virtual void ApplyUnaryLeftFoldExpression(CppOperatorKind kind);
    public sealed virtual void ApplyUnaryRightFoldExpression(CppOperatorKind kind);
    public sealed virtual void ApplyBinaryFoldExpression(CppOperatorKind kind, CppTwinExpressionBuilder& exprBuilder);
    public sealed virtual void LearnLambdaExpression(CppLambdaBuilder builder);
    public sealed virtual void LearnRequiresExpression(CppRequiresExpressionBuilder builder);
    public sealed virtual void LearnC11GenericExpression(CppTwinC11GenericExpressionBuilder& builder);
    public sealed virtual void LearnGnuStatementExpression(CppCompoundStatementInExpressionBuilder builder);
    public sealed virtual bool LearnLiteral(TokenNodeType tt, string text, CppLanguageDialect dialect);
    public sealed virtual bool LearnStringLiteral(CppStringLiteralBuilder& builder);
    public sealed virtual void LearnThis();
    public sealed virtual void LearnMSNoopExpression();
    public sealed virtual void LearnGNUAddressOfLabelExpression(string labelName);
    public sealed virtual void ApplyCallOperator(CppTwinFunctionArgumentListBuilder& builder);
    public sealed virtual void LearnCallToTypeId(CppUnresolvedDeclarationSpecifierTypeBuilder typeBuilder, CppTwinFunctionArgumentListBuilder& argBuilder);
    public sealed virtual void LearnBracedInitializedTypeId(CppUnresolvedDeclarationSpecifierTypeBuilder typeBuilder, CppTwinFunctionArgumentListBuilder& argBuilder);
    public sealed virtual void LearnBracedInitializedTypeIdDecl(ICppDeclarationBuilder declBuilder, CppTwinFunctionArgumentListBuilder& argBuilder);
    public sealed virtual void ApplyBracedInitializer(CppTwinFunctionArgumentListBuilder& argBuilder);
    public sealed virtual void LearnBracedInitList(CppTwinFunctionArgumentListBuilder& builder);
    public sealed virtual void ApplyCoAwaitExpression();
    public sealed virtual void ApplyCoYieldExpression();
    public sealed virtual void LearnDesignation(CppTwinDesignatorBuilder& designator, CppTwinExpressionBuilder& initializer, InitializerKind initializerKind);
    public CppTwinExpressionBuilder CreateExpressionBuilder(bool createSymbols);
    public sealed virtual CppTwinQualifiedNameBuilder CreateQualifiedNameBuilder();
    public sealed virtual CppStringLiteralBuilder CreateStringLiteralBuilder();
    public sealed virtual CppTwinFunctionArgumentListBuilder CreateFunctionArgumentListBuilder(bool createSymbols);
    public sealed virtual CppTwinNewExpressionBuilder CreateNewExpressionBuilder();
    public sealed virtual CppTwinDoubleArgumentTypeTraitExpressionBuilder CreateDoubleArgumentTypeTraitExpressionBuilder();
    public sealed virtual CppTwinMultiArgumentTypeTraitExpressionBuilder CreateMultiArgumentTypeTraitExpressionBuilder();
    public sealed virtual CppTwinBuiltinOffsetOfBuilder CreateBuiltinOffsetOfBuilder();
    public sealed virtual ICppExpression GetExpressionForLookup();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTwinFunctionArgumentListBuilder : ValueType {
    private CppList`1<ICppExpression> myUnresolvedArguments;
    private CppList`1<ICppExpression> myReplacedArguments;
    private bool myCreateSymbols;
    public CppTwinFunctionArgumentListBuilder(bool createSymbols);
    public sealed virtual CppTwinExpressionBuilder CreateExpressionBuilder();
    public sealed virtual void LearnArgument(CppTwinExpressionBuilder& exprBuilder, bool isPackExpansion);
    public ICppExpression[] GetUnresolvedArguments();
    public ICppExpression[] GetReplacedArguments();
    public CppSmallArray`1<ICppExpression> GetUnresolvedArgumentsSmallArray();
    public CppSmallArray`1<ICppExpression> GetReplacedArgumentsSmallArray();
    public bool IsEmpty();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTwinMultiArgumentTypeTraitExpressionBuilder : object {
    private CppList`1<Element> myUnresolvedArguments;
    private CppList`1<Element> myReplacedArguments;
    public sealed virtual void LearnArgument(ICppDeclarationBuilder declBuilder, bool isPackExpansion);
    public CppList`1<Element> GetUnresolvedArguments();
    public CppList`1<Element> GetReplacedArguments();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTwinNewExpressionBuilder : ValueType {
    private bool myIsGCNew;
    private bool myIsFromGlobalNamespace;
    private CppQualType myUnresolvedType;
    private CppQualType myReplacedType;
    private ICppArgumentList myUnresolvedOperatorArgumentList;
    private ICppArgumentList myReplacedOperatorArgumentList;
    private ICppArgumentList myUnresolvedConstructorArgumentList;
    private ICppArgumentList myReplacedConstructorArgumentList;
    public sealed virtual void LearnIsCliGCNew(bool gcn);
    public sealed virtual void LearnIsFromGlobalNamespace(bool isFromGlobalNamespace);
    public sealed virtual void LearnType(ICppDeclarationBuilder declBuilder);
    public sealed virtual void LearnOperatorArguments(CppTwinFunctionArgumentListBuilder& funcArgList);
    public sealed virtual void LearnConstructorArguments(CppTwinFunctionArgumentListBuilder& funcArgList);
    public sealed virtual void LearnBracedArguments(CppTwinFunctionArgumentListBuilder& funcArgList);
    public bool IsCliGCNew();
    public bool IsFromGlobalNamespace();
    public CppQualType GetUnresolvedQualType();
    public CppQualType GetReplacedQualType();
    public ICppArgumentList GetUnresolvedOperatorArgumentList();
    public ICppArgumentList GetReplacedOperatorArgumentList();
    public ICppArgumentList GetUnresolvedConstructorArgumentList();
    public ICppArgumentList GetReplacedConstructorArgumentList();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTwinQualifiedNameBuilder : ValueType {
    private CppQualifiedName myUnresolvedName;
    private CppQualifiedName myReplacedName;
    public sealed virtual void LearnId(string id);
    public sealed virtual void LearnAnonymousId();
    public sealed virtual void LearnDestructorTag(string tag);
    public sealed virtual void LearnOperatorId(CppOperatorKind kind);
    public sealed virtual void LearnConversionId(ICppDeclarationBuilder declBuilder);
    public sealed virtual void LearnUserDefinedLiteralId(string id);
    public sealed virtual ICppDeclarationBuilder CreateDeclarationBuilderForConversion(ICppBuilder parent);
    public sealed virtual void LearnDecltypeDestructorTag();
    public sealed virtual void LearnDecltype(CppTwinExpressionBuilder builder, CppDecltypeKind kind);
    public sealed virtual void LearnDecltypeBoxed(ICppExpressionBuilder exprBuilder, CppDecltypeKind kind);
    public sealed virtual void LearnTypeOfType(ICppDeclarationBuilder declBuilder, CppDecltypeKind kind);
    public sealed virtual void LearnGlobalNamespaceId();
    public sealed virtual void LearnMSSuperId();
    public sealed virtual void LearnCliSimpleTypeId(CppQualType type);
    public sealed virtual void LearnCliFinalizerTag(string tag);
    public sealed virtual void LearnTemplateArguments(CppTwinTemplateArgumentsBuilder builder);
    public sealed virtual void LearnTemplateArgumentsBoxed(ICppTemplateArgumentsBuilder builder);
    [IsReadOnlyAttribute]
public CppQualifiedName GetUnresolvedRawName();
    [IsReadOnlyAttribute]
public CppQualifiedName GetReplacedRawName();
    public CppQualifiedName GetRawName();
    public sealed virtual CppTwinExpressionBuilder CreateExpressionBuilder(bool createSymbols);
    public sealed virtual ICppExpressionBuilder CreateExpressionBuilderBoxed(bool createSymbols);
    public sealed virtual CppTwinTemplateArgumentsBuilder CreateTemplateArgumentsBuilder();
    public sealed virtual ICppTemplateArgumentsBuilder CreateTemplateArgumentsBuilderBoxed();
    public sealed virtual CppQualifiedName GetRawNameForLookup();
    private void AddNewTail(CppQualifiedNamePart tail);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTwinTemplateArgumentsBuilder : object {
    private CppList`1<ICppTemplateArgument> myUnresolvedArgs;
    private CppList`1<ICppTemplateArgument> myReplacedArgs;
    public static CppTwinTemplateArgumentsBuilder Create();
    public sealed virtual ICppDeclarationBuilder CreateDeclarationBuilder(ICppBuilder parent, bool createParameters);
    public sealed virtual void LearnQualifiedReference(CppTwinQualifiedNameBuilder& nameBuilder, bool isPackExpansion, bool hadTypename);
    public sealed virtual void LearnTypeId(ICppDeclarationBuilder declBuilder, bool isPackExpansion);
    public sealed virtual void LearnExpression(CppTwinExpressionBuilder& exprBuilder, bool isPackExpansion);
    public sealed virtual CppTwinExpressionBuilder CreateExpressionBuilder(bool createSymbols);
    public ICppTemplateArgument[] UnresolvedArguments();
    public ICppTemplateArgument[] ReplacedArguments();
    private static ICppTemplateArgument WrapTypeArgumentInPack(CppQualType qualType, bool isPackExpansion);
    private static ICppTemplateArgument WrapExpressionArgumentInPack(ICppExpression expr, bool isPackExpansion);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeAliasModuleEntity : object {
    public CppQualifiedNamePart Name;
    public ICppScopeModuleEntity Parent;
    public IEnumerable`1<ICppSymbol> Symbols;
    public CppQualType Type;
    public CppDeclarationSpecifiers DeclarationSpecifiers;
    public CppAccessibility Accessibility;
    public int Index;
    public CppTypeAliasModuleEntity(int index, ICppScopeModuleEntity parent, CppQualifiedNamePart name, IEnumerable`1<ICppSymbol> symbols, CppDeclarationSpecifiers declarationSpecifiers, CppAccessibility accessibility);
    internal CppTypeAliasModuleEntity(int index);
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual ICppScopeModuleEntity GetParent();
    public sealed virtual bool IsExplicitlyExported();
    public virtual CppGeneratedResolveEntityType GetEntityType();
    public virtual CppImportResult`1<ICppGroupedTypeDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeAliasTemplateModuleEntity : object {
    public ICppTypeAliasModuleEntity PrimaryTemplate;
    public CppTypeAliasTemplateModuleEntity(ICppTypeAliasModuleEntity primaryTemplate);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeDeclaratorResolveEntity : CppDeclaratorResolveEntityBase {
    public CppTypeDeclaratorResolveEntity(ICppResolveEntityParentScope parent, CppQualifiedNamePart name, ICppDeclaratorSymbol sym, CppLocationAnchor anchor, CppQualType replacedType, CppAttributeList attrs);
    public virtual bool HasDefinition();
    protected virtual CppQualType GetNonNormalizedType(ICppResolvedTypeFactory typeFactory, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPosForDeclSpecs, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPosForDeclarator);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeDeclaratorResolveEntityWithSubstitution : CppDeclaratorResolveEntityWithSubstitutionBase`1<ICppGroupedTypeDeclaratorResolveEntity> {
    public CppTypeDeclaratorResolveEntityWithSubstitution(ICppResolveEntityParent structuralParent, CppViewPos& vp, CppQualifiedNamePart name, ICppGroupedTypeDeclaratorResolveEntity inner, ICppSubstitutionContext subst);
    public virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeGenericParameter : CppTypeTemplateParameterBase {
    private static UInt32 FLAGS_ARE_CACHED;
    private CppGenericParameters myParentParameters;
    private int myIndex;
    private CppList`1<ICppGenericConstraint> myReplacedConstraints;
    private CppBasicBaseDescription`1[] myResolvedBases;
    private CppList`1<CppBasicBaseDescription`1<ICppClassOrGenericParameterResolveEntity>> myResolvedNonDependentBases;
    private UInt32 modreq(System.Runtime.CompilerServices.IsVolatile) myFlags;
    public CppTypeGenericParameter(CppGenericParameterSymbol sym, CppViewPos& viewPos, CppGenericParameters parentParameters, int index);
    public sealed virtual CppBasicBaseDescription`1[] GetBases();
    public sealed virtual CppList`1<CppBasicBaseDescription`1<ICppClassOrGenericParameterResolveEntity>> GetNonDependentBases();
    public sealed virtual CppGenericParameterFlags GetFlags();
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public void AddConstraint(ICppGenericConstraint constraint);
    public virtual string ToString();
    private ICppGenericParameter GetConstraintsSource();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeOfTypeId : object {
    private CppQualType myType;
    private CppDecltypeKind myKind;
    public CppTypeOfTypeId(CppQualType type, CppDecltypeKind kind);
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public CppQualType GetQualType();
    public CppDecltypeKind GetKind();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeOfTypeResolveEntity : object {
    private CppQualType myType;
    private CppDecltypeKind myKind;
    private ICppFileResolveEntitiesCache myResolveCache;
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppTypeOfTypeResolveEntity(CppQualType type, CppDecltypeKind kind, ICppFileResolveEntitiesCache resolveCache);
    public FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public CppQualType GetQualType();
    public ICppFileResolveEntitiesCache GetResolveCache();
    private sealed virtual override FrugalLocalList`1<ICppResolveEntity> JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity.Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeParameterBuilder : CppForwardingBuilder {
    private string myName;
    private CppSymbolLocation myLocation;
    private ICppTypeTemplateArgument myUnresolvedDefault;
    private CppQualType myReplacedDefault;
    private CppTypeTemplateParameterKey myKey;
    private bool myWasBuilt;
    private bool myHasEllipsis;
    private ICppTypeTemplateParameterSymbol mySymbol;
    private ICppTypeTemplateParameterOrPack myEntity;
    public CppTypeParameterBuilder(CppTemplateHeaderBuilder parentBuilder);
    public sealed virtual void LearnName(CppPsiBuilder psi);
    public sealed virtual void LearnName(string name);
    public sealed virtual void LearnLocation(CppSymbolLocation loc);
    public sealed virtual void LearnDefaultArgument(ICppDeclarationBuilder declBuilder);
    public sealed virtual void LearnKey(CppTypeTemplateParameterKey key);
    public sealed virtual void LearnEllipsis();
    public sealed virtual ICppTemplateParameterSymbol GetSymbol();
    public ICppTemplateParameter GetResolveEntity();
    private void Build();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeTemplateArgument : object {
    private CppQualType myQualType;
    private CppTypeTemplateArgument(CppQualType type);
    internal static CppTypeTemplateArgument CreateFromDeserialization(CppQualType type);
    public static ICppTypeTemplateArgument Create(CppQualType type);
    public static ICppModuleTemplateArgument CreateModuleTemplateArgument(CppQualType type);
    public sealed virtual Result Accept(Data data, ICppTemplateArgumentVisitor`2<Result, Data> visitor);
    public sealed virtual CppQualType GetQualType();
    public IEnumerable`1<ICppTemplateArgument> Unpack();
    public sealed virtual CppModuleTemplateArgumentKind Kind();
    public sealed virtual ICppTemplateArgument Import(CppModuleImportingContext ctx);
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual string ToString();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeTemplateArgumentPack : CppTemplateArgumentPackBase`1<ICppTypeTemplateArgument> {
    public CppList`1<ICppTypeTemplateArgument> Packed { get; }
    public CppTypeTemplateArgumentPack(ICppTypeTemplateArgument[] packed);
    public CppList`1<ICppTypeTemplateArgument> get_Packed();
    public IEnumerable`1<ICppTypeTemplateArgument> UnpackTypeArgs();
    public virtual Result Accept(Data data, ICppTemplateArgumentVisitor`2<Result, Data> visitor);
    public virtual ICppTemplateArgumentPack Clone();
    public virtual ICppTemplateArgument MakeInvalidElement();
    public virtual ICppTemplateArgumentPack New(int cardinality);
    public virtual string ToString();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity : CppTemplateWithAppliedArgumentsResolveEntityBase {
    private CppViewPos myViewPos;
    public CppDependentInfo DependentInfo { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity(ICppTypeTemplateDeclaratorResolveEntity templ, ICppTemplateArgument[] args, CppViewPos& viewPos);
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public virtual CppDependentInfo get_DependentInfo();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public ICppTypeTemplateDeclaratorResolveEntity GetTemplateDeclarator();
    public CppViewPos GetViewPos();
    public CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity DoSubstitutionGetResolveEntity(CppSubstitutionDriver substDriver);
    public virtual string ToString();
    public virtual CppQualType GetInstantiatedType(ICppResolvedTypeFactory tf, bool forDeduce);
    public virtual bool HasSubstitutionFailure();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeTemplateDeclaratorWithBadAppliedArgumentsResolveEntity : CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity {
    private ICppResolvedExpression myFailedConstraint;
    public CppDependentInfo DependentInfo { get; }
    public CppTypeTemplateDeclaratorWithBadAppliedArgumentsResolveEntity(ICppTypeTemplateDeclaratorResolveEntity templ, ICppTemplateArgument[] args, CppViewPos& viewPos, ICppResolvedExpression constraint);
    public virtual CppDependentInfo get_DependentInfo();
    public sealed virtual ICppResolvedExpression GetFailedConstraint();
    public virtual CppQualType GetInstantiatedType(ICppResolvedTypeFactory tf, bool forDeduce);
    public virtual bool HasSubstitutionFailure();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeTemplateParameter : CppTypeTemplateParameterBase {
    private ICppTemplateArgument myResolvedDefault;
    public CppTypeTemplateParameter(CppTypeTemplateParameterSymbol sym, CppViewPos& viewPos, CppQualType unresolvedDefault);
    public virtual ICppTemplateArgument GetDefault(ICppResolvedTypeFactory tf);
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeTemplateParameterBase : object {
    protected ICppTypeTemplateParameterSymbol mySymbol;
    protected CppViewPos myViewPos;
    protected CppTemplateParameterTag myTag;
    public CppTypeTemplateParameterKey Key { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppDependentInfo DependentInfo { get; }
    protected CppTypeTemplateParameterBase(ICppTypeTemplateParameterSymbol sym, CppViewPos& viewPos);
    public virtual CppViewPos GetViewPos();
    public virtual ICppTemplateArgument GetDefault(ICppResolvedTypeFactory tf);
    public virtual ICppFileResolveEntitiesCache GetResolveCache();
    public virtual CppTemplateParameterTag GetTag();
    public virtual void ReplaceTag(CppTemplateParameterTag tag);
    public abstract virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public abstract virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public virtual bool IsConcept();
    public virtual bool IsInvented();
    public virtual ICppResolvedExpression GetResolvedConceptExpression();
    public virtual FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public virtual bool NameEquals(CppQualifiedNamePart name);
    public virtual CppTypeTemplateParameterKey get_Key();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public virtual ICppSymbol GetSymbol();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual CppDependentInfo get_DependentInfo();
    public abstract virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeTemplateParameterKey : Enum {
    public int value__;
    public static CppTypeTemplateParameterKey TYPENAME;
    public static CppTypeTemplateParameterKey CLASS;
    public static CppTypeTemplateParameterKey AUTO;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeTemplateParameterKeyUtil : object {
    [ExtensionAttribute]
public static string TypeTemplateParameterKeyAsString(CppTypeTemplateParameterKey key);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeTemplateParameterPack : CppTypeTemplateParameterBase {
    public CppTypeTemplateParameterPack(CppTypeTemplateParameterPackSymbol sym, CppViewPos& viewPos);
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual ICppTemplateArgumentPack CreateEmptyMatchingArgumentPack();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeTemplateParameterPackSymbol : CppTypeTemplateParameterSymbolBase {
    public CppTypeTemplateParameterPackSymbol(string name, CppTypeTemplateParameterKey key, CppSymbolLocation loc);
    public virtual ICppTemplateArgument GetDefault();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeTemplateParameterPackWithSubstitution : CppTypeTemplateParameterWithSubstitutionBase`1<ICppTypeTemplateParameterPack> {
    public CppTypeTemplateParameterPackWithSubstitution(ICppTypeTemplateParameterPack inner, CppViewPos& pointOfInstantiation, ICppSubstitutionContext subst);
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public sealed virtual ICppTemplateArgumentPack CreateEmptyMatchingArgumentPack();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeTemplateParameterSymbol : CppTypeTemplateParameterSymbolBase {
    internal CppTypeTemplateParameterSymbol(string name, CppTypeTemplateParameterKey key, CppSymbolLocation loc);
    public static CppTypeTemplateParameterSymbol Create(string name, CppTypeTemplateParameterKey key, CppSymbolLocation loc, ICppTypeTemplateArgument def);
    public virtual ICppTemplateArgument GetDefault();
    public virtual ICppTypeTemplateArgument GetDefaultType();
    public virtual string ToString();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeTemplateParameterSymbolBase : CppParameterSymbolBase {
    private string myName;
    [CompilerGeneratedAttribute]
private CppTypeTemplateParameterKey <Key>k__BackingField;
    public string NamePartRaw { get; }
    public CppQualifiedNamePart NamePart { get; }
    public CppTypeTemplateParameterKey Key { get; }
    protected CppTypeTemplateParameterSymbolBase(string name, CppTypeTemplateParameterKey key, CppSymbolLocation loc);
    public virtual string get_NamePartRaw();
    public virtual bool NameEquals(CppQualifiedNamePart name);
    public virtual CppQualifiedNamePart get_NamePart();
    [CompilerGeneratedAttribute]
public virtual CppTypeTemplateParameterKey get_Key();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeTemplateParameterWithArgumentSymbol : CppTypeTemplateParameterSymbol {
    private ICppTypeTemplateArgument myDefault;
    public CppTypeTemplateParameterWithArgumentSymbol(string name, CppTypeTemplateParameterKey key, CppSymbolLocation loc, ICppTypeTemplateArgument def);
    public virtual ICppTemplateArgument GetDefault();
    public virtual ICppTypeTemplateArgument GetDefaultType();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeTemplateParameterWithSubstitution : CppTypeTemplateParameterWithSubstitutionBase`1<ICppTypeTemplateParameter> {
    public CppTypeTemplateParameterWithSubstitution(ICppTypeTemplateParameter inner, CppViewPos& pointOfInstantiation, ICppSubstitutionContext subst);
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeTemplateParameterWithSubstitutionBase`1 : CppTemplateParameterWithSubstitutionBase`1<Inner> {
    public CppDependentInfo DependentInfo { get; }
    public CppTypeTemplateParameterKey Key { get; }
    protected CppTypeTemplateParameterWithSubstitutionBase`1(Inner inner, CppViewPos& pointOfInstantiation, ICppSubstitutionContext subst);
    public virtual CppDependentInfo get_DependentInfo();
    public virtual CppTypeTemplateParameterKey get_Key();
    public abstract virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public abstract virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public virtual FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
internal enum JetBrains.ReSharper.Psi.Cpp.Symbols.CppUDLKind : Enum {
    public byte value__;
    public static CppUDLKind Int;
    public static CppUDLKind Float;
    public static CppUDLKind Char;
    public static CppUDLKind String;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUEGeneratedFunctionModuleEntity : CppRegularFunctionModuleEntityWithTypeWithOptionalData {
    public CppRegularNormalFunctionModuleEntity PrototypeFunction;
    private static int InvalidIndex;
    public CppUEGeneratedFunctionModuleEntity(ICppScopeModuleEntity parent, CppQualifiedNamePart name, CppDeclarationSpecifiers declarationSpecifiers, CppPureVirtualSpecifiers pureVirtualSpecifiers, CppAccessibility accessibility, IEnumerable`1<ICppSymbol> symbols, CppSmallArray`1<ICppAttribute> attributes);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUndeterminedClassSpecializationLinkageEntity : CppUndeterminedSpecializationLinkageEntity {
    public CppUndeterminedClassSpecializationLinkageEntity(CppQualifiedNamePart name, ICppLinkageEntity parent, ICppLinkageEntity primaryTemplate);
    public virtual Result Accept(ICppDependentLinkageEntityVisitor`1<Result> visitor);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUndeterminedSpecializationLinkageEntity : CppLinkageEntity {
    private ICppLinkageEntity myPrimaryTemplate;
    public ICppLinkageTemplateArgument[] TemplateArguments { get; }
    public CppQualifiedName DebugQualifiedName { get; }
    protected CppUndeterminedSpecializationLinkageEntity(CppQualifiedNamePart name, ICppLinkageEntity parent, ICppLinkageEntity primaryTemplate);
    public ICppLinkageTemplateArgument[] get_TemplateArguments();
    public virtual CppQualifiedName get_DebugQualifiedName();
    public abstract virtual Result Accept(ICppDependentLinkageEntityVisitor`1<Result> visitor);
    public virtual Result Accept(ICppLinkageEntityVisitor`1<Result> visitor);
    public virtual ICppLinkageEntity GetPrimaryTemplate();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUndeterminedSpecializationModuleEntity : object {
    public ICppClassOrRefClassModuleEntity Pack;
    public CppSmallArray`1<ICppModuleTemplateArgument> Arguments;
    public CppDependentInfo DependentInfo;
    public CppUndeterminedSpecializationModuleEntity(ICppClassOrRefClassModuleEntity pack, CppSmallArray`1<ICppModuleTemplateArgument> arguments, CppDependentInfo dependentInfo);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUndeterminedSpecializationResolveEntity : CppTemplateWithAppliedArgumentsResolveEntityBase {
    private Nullable`1<int> myArgumentsHashCode;
    private TriBool myHasSubstitutionFailure;
    [CompilerGeneratedAttribute]
private ICppResolveEntity <StructuralParent>k__BackingField;
    [CompilerGeneratedAttribute]
private CppDependentInfo <DependentInfo>k__BackingField;
    public ICppResolveEntity StructuralParent { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppDependentInfo DependentInfo { get; }
    public int ArgumentsHashCode { get; }
    public CppUndeterminedSpecializationResolveEntity(CppClassTemplateResolveEntityPack pack, ICppTemplateArgument[] args, CppDependentInfo depInfo);
    public CppUndeterminedSpecializationResolveEntity(CppClassTemplateResolveEntityPack pack, CppClassInstantiationKey instantiationKey, CppDependentInfo depInfo);
    [CompilerGeneratedAttribute]
public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppLocationAnchor get_LocationAnchor();
    [CompilerGeneratedAttribute]
public virtual CppDependentInfo get_DependentInfo();
    public int get_ArgumentsHashCode();
    public virtual bool HasSubstitutionFailure();
    public virtual FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
    public virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
    public sealed virtual CppClassKey GetKey();
    public ICppClassOrUndeterminedSpecializationResolveEntity DoSubstitutionGetResolveEntity(CppSubstitutionDriver substDriver);
    public CppClassTemplateResolveEntityPack GetPack();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUndeterminedTemplateVariableSpecializationResolveEntity : CppTemplateWithAppliedArgumentsResolveEntityBase {
    public ICppResolveEntity StructuralParent { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppUndeterminedTemplateVariableSpecializationResolveEntity(ICppVariableTemplateDeclaratorResolveEntity templateVar, ICppTemplateArgument[] arguments);
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual TResult Accept(ICppResolveEntityVisitor`1<TResult> visitor);
    public ICppVariableTemplateDeclaratorResolveEntity GetTemplateDeclarator();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUndeterminedTypeSpecializationLinkageEntity : CppUndeterminedSpecializationLinkageEntity {
    public CppUndeterminedTypeSpecializationLinkageEntity(CppQualifiedNamePart name, ICppLinkageEntity parent, ICppLinkageEntity primaryTemplate);
    public virtual Result Accept(ICppDependentLinkageEntityVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUndeterminedVariableSpecializationLinkageEntity : CppUndeterminedSpecializationLinkageEntity {
    public CppUndeterminedVariableSpecializationLinkageEntity(CppQualifiedNamePart name, ICppLinkageEntity parent, ICppLinkageEntity primaryTemplate);
    public virtual Result Accept(ICppDependentLinkageEntityVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUndeterminedVariableSpecializationModuleEntity : CppSubstitutedVariableOrUndeterminedSpecializationModuleEntity {
    public CppUndeterminedVariableSpecializationModuleEntity(CppSmallArray`1<ICppVariableModuleEntity> specializations, CppSmallArray`1<ICppModuleTemplateArgument> arguments);
    public CppImportResult`1<CppUndeterminedTemplateVariableSpecializationResolveEntity> Import(CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUngroupedLambdaInitCaptureResolveEntity : object {
    private ICppResolveEntityParentScope myParent;
    private CppLambdaInitCaptureSymbol mySymbol;
    private CppLocationAnchor myAnchor;
    private CppDeclaratorInitializer myReplacedInitializer;
    private CppCachedReference`1<object> myCachedResolvedInitializerArguments;
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public bool IsParameterPack { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    protected CppUngroupedLambdaInitCaptureResolveEntity(ICppResolveEntityParentScope parent, CppLambdaInitCaptureSymbol sym, CppLocationAnchor anchor);
    protected CppUngroupedLambdaInitCaptureResolveEntity(CppLambdaScopeResolveEntity parent, CppLambdaInitCaptureSymbol sym, CppLocationAnchor anchor, CppDeclaratorInitializer resolvedInitializer);
    public virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
    public virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public virtual CppAttributeList get_Attributes();
    public virtual bool get_IsParameterPack();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public sealed virtual bool HasInitializer();
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public virtual ICppResolveEntityParent get_RealParent();
    public virtual ICppResolveEntity get_StructuralParent();
    public virtual CppQualifiedNamePart get_Name();
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public virtual CppLocationAnchor get_LocationAnchor();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public void SetInitializer(CppDeclaratorInitializer initializer);
    public CppViewPos GetInitializerViewPos();
    public CppLambdaInitCaptureSymbol GetSymbol();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUnmergedActions : ValueType {
    private CppSmallList`1<ICppPendingMergingAction> myActions;
    private int myNextUnmergedAction;
    public bool IsCurrentlyMerging;
    public void AddAction(ICppFileResolveEntitiesCache resolveCache, ICppPendingMergingAction action);
    public void MergeActionsUpTo(ICppFileResolveEntitiesCache cache, CppLocationAnchor anchor);
    public bool HasPendingActions(CppLocationAnchor anchor);
    public bool HasPendingActions();
    public bool HasPendingNonTemplateClassWithTag(CppLocationAnchor anchor, CppClassTag tag);
    public CppSmallList`1<ICppPendingMergingAction> GetActions();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUnpackedQualTypeAndInitializer : ValueType {
    public CppUnpackedQualTypeAndInitializerKind TypeAndInitializerKind;
    public CppSmallArray`1<ICppExpression> InitializerArguments;
    public void SetInitializer(CppDeclaratorInitializer initializer);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUnpackedQualTypeAndInitializerKind : ValueType {
    private CppType myUnqualifiedType;
    private ushort myTypePackedQuals;
    private ushort myTypeDeclSpecPlacement;
    public KIND InitializerKind;
    public CppType UnqualifiedType { get; }
    public CppUnpackedQualTypeAndInitializerKind(CppType unqualifiedType, ushort typePackedQuals, ushort typeDeclSpecPlacement, KIND initializerKind);
    public CppUnpackedQualTypeAndInitializerKind(CppQualType qualType, KIND initializerKind);
    public CppType get_UnqualifiedType();
    [IsReadOnlyAttribute]
public CppQualType GetQualType();
    [IsReadOnlyAttribute]
public CppQualType GetTypeWithInputQualifiers(InputQualifiers inputQualifiers);
    [IsReadOnlyAttribute]
public void Marshal(CppMarshallingContext context);
    public static CppUnpackedQualTypeAndInitializerKind Unmarshal(CppUnmarshallingContext context);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUnresolvedStructuredBindingId : object {
    [CompilerGeneratedAttribute]
private CppStructuredBindingSymbol[] <ElementSymbols>k__BackingField;
    public CppStructuredBindingSymbol[] ElementSymbols { get; }
    public CppUnresolvedStructuredBindingId(CppStructuredBindingSymbol[] symbols);
    [CompilerGeneratedAttribute]
public CppStructuredBindingSymbol[] get_ElementSymbols();
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUpdateLazyMergingInfoUtil : object {
    [ExtensionAttribute]
public static void UpdateLazyMergingInfo(ICppTemplateParameterSymbol param, ICppLazyMergingDataConsumer resultConsumer);
    [ExtensionAttribute]
public static void UpdateLazyMergingInfo(CppSymbolTemplateParameters params, ICppLazyMergingDataConsumer resultConsumer);
    [ExtensionAttribute]
public static void UpdateLazyMergingInfo(CppSymbolTemplateParametersList params, ICppLazyMergingDataConsumer resultConsumer);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUserDefinedLiteralId : object {
    [CompilerGeneratedAttribute]
private string <Suffix>k__BackingField;
    public string Suffix { get; }
    public CppUserDefinedLiteralId(string suffix);
    [CompilerGeneratedAttribute]
public string get_Suffix();
    public sealed virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUserProvidedDeductionGuide : CppDeclaratorResolveEntityBase {
    public CppFunctionTraits Traits { get; }
    public ICppFunctionBodyResolveEntity Body { get; }
    public int BodyChameleonVersion { get; }
    public CppUserProvidedDeductionGuide(ICppClassResolveEntity parent, CppQualifiedNamePart name, ICppDeclaratorSymbol sym, CppLocationAnchor anchor, CppQualType replacedType, CppAttributeList attrs);
    public sealed virtual CppFunctionTraits get_Traits();
    public sealed virtual IEnumerable`1<ICppResolveEntity> GetResolvedCxxCliOverrideSpecifierTargets();
    public sealed virtual ICppResolvedExpression GetResolvedRequiresClause();
    public sealed virtual ICppFunctionBodyResolveEntity get_Body();
    public sealed virtual int get_BodyChameleonVersion();
    public sealed virtual ICppParameterListResolveEntity GetMainParameterList();
    public sealed virtual int GetFirstDefaultArgIndex();
    public sealed virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public bool InstantiateFunctionBody(CppViewPos& vp, bool forceChameleonInstantiation);
    public sealed virtual bool Contains(ICppDeclaratorResolveEntity decl);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual CppList`1<ICppFunctionOrVariableDeclaratorResolveEntity> GetUngroupedDeclarators();
    public sealed virtual ICppFunctionTemplateDeclaratorResolveEntity GetTemplateDeclaration();
    public sealed virtual ICppFunctionDeclaratorResolveEntity GetUngroupedThatProvidingBody();
    public sealed virtual ICppFunctionOrVariableDeclaratorResolveEntity GetFirstUngrouped();
    public virtual bool HasDefinition();
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual bool CanBeCalledWithZeroArguments();
    public sealed virtual bool CanAcceptInitializerList();
    public sealed virtual SourceKind GetSourceKind();
    public virtual ICppScopeResolveEntity LexicalParentScope();
    private static bool HasDefault(ICppDeclaratorSymbol symbol, int paramIndex);
    protected virtual CppQualType GetNonNormalizedType(ICppResolvedTypeFactory typeIntern, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPosForDeclSpecs, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPosForDeclarator);
    private CppParameterListResolveEntity GetParameterListImpl();
    private sealed virtual override bool JetBrains.ReSharper.Psi.Cpp.Resolve.ICppGroupedFunctionDeclaratorResolveEntity.InstantiateFunctionBody(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp, bool forceChameleonInstantiation);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUserProvidedDeductionGuideTemplate : object {
    private ICppUserProvidedDeductionGuide myDeclarator;
    private ICppTemplateArgument[] myDefaults;
    public ICppResolveEntityParent RealParent { get; }
    public ICppGroupedFunctionDeclaratorResolveEntity Function { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppUserProvidedDeductionGuideTemplate(ICppUserProvidedDeductionGuide declarator, ICppTemplateArgument[] defaultTemplateArguments);
    public ICppResolveEntityParent get_RealParent();
    public sealed virtual CppTemplateParametersBase GetParameters();
    public ICppTemplateArgument[] GetDefaults(CppViewPos& vp);
    public sealed virtual CppQualType GetTemplateType(ICppResolvedTypeFactory typeIntern);
    public CppPickFunctionSpecializationResult PickSpecializationInSFINAEContext(CppTypeContext& tc, CppSubstitutionContext subst, ICppTemplateFunctionCallDeductionErrorConsumer errorConsumer, ICppResolvedExpression& constraint);
    public sealed virtual bool CanBeCalledWithZeroArguments();
    public sealed virtual int GetFirstDefaultArgIndex();
    public sealed virtual bool CanAcceptInitializerList();
    public sealed virtual SourceKind GetSourceKind();
    public sealed virtual bool IsFunctionTemplateParameter(ICppTemplateParameter p);
    public sealed virtual ICppGroupedFunctionDeclaratorResolveEntity get_Function();
    public sealed virtual ICppParameterListResolveEntity GetMainParameterList();
    public sealed virtual void Dump(CppIndentationStringBuilder tw);
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual CppAttributeList GetAttributes();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual ICppResolvedExpression GetResolvedRequiresClause();
    public ICppUserProvidedDeductionGuide GetDeclarator();
    public static CppPickFunctionSpecializationResult CreateSubstitutedTemplateDeductionGuide(CppQualType originalType, CppAttributeList originalAttributes, CppSubstitutionContext subst, CppTypeContext& tc, CppQualifiedNamePart name, ICppTemplateDeductionGuide guide, ICppTemplateFunctionCallDeductionErrorConsumer errorConsumer);
    private CppTemplateId GetName();
    private sealed virtual override CppPickFunctionSpecializationResult JetBrains.ReSharper.Psi.Cpp.Resolve.ICppFunctionTemplateLikeDeducibleResolveEntity.PickSpecializationInSFINAEContext(CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc, CppSubstitutionContext subst, ICppTemplateFunctionCallDeductionErrorConsumer consumer, ICppResolvedExpression& constraint);
    private sealed virtual override ICppTemplateArgument[] JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateResolveEntityBase.GetDefaults(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUsingDeclarationLinkageEntity : CppLinkageEntity {
    private List`1<ICppLinkageEntity> myTargets;
    public IEnumerable`1<ICppLinkageEntity> Targets { get; }
    public CppUsingDeclarationLinkageEntity(CppQualifiedNamePart name, ICppLinkageEntity parent, IEnumerable`1<ICppLinkageEntity> targets);
    public IEnumerable`1<ICppLinkageEntity> get_Targets();
    public virtual bool Equals(object rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual Result Accept(ICppLinkageEntityVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUsingDeclarationModuleEntity : object {
    public CppQualifiedName Name;
    public ICppScopeModuleEntity Parent;
    public CppSmallArray`1<ICppModuleEntity> Targets;
    private CppSymbolLocation mySymbolLocation;
    private int myFlags;
    private static int HasTypenameOffset;
    private static int IsExplicitlyExportedOffset;
    private static int AreConstructorsOffset;
    private static int IsPackExpansionOffset;
    private static int AccessibilityOffset;
    public CppUsingDeclarationModuleEntity(CppQualifiedName name, ICppScopeModuleEntity parent, CppUsingDeclarationResolveEntity source, bool areConstructors, bool isPackExpansion, CppSmallArray`1<ICppModuleEntity> targets);
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual ICppScopeModuleEntity GetParent();
    public sealed virtual bool IsExplicitlyExported();
    private bool GetBit(int offset);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    private static CppQualifiedName SymbolName();
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public CppUsingDeclarationResolveEntity Import(ICppScopeResolveEntity targetParent, CppModuleImportingContext ctx);
    public sealed virtual CppUsingDeclarationSymbol GetSymbol();
    public sealed virtual CppSymbolLocation GetSymbolLocation();
    public sealed virtual bool HadTypename();
    public sealed virtual bool IsPackExpansion();
    public sealed virtual bool Export();
    public sealed virtual CppAccessibility GetAccessibility();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUsingDeclarationResolveEntity : object {
    private ICppScopeResolveEntity myParentScope;
    private CppQualifiedName myName;
    private ICppUsingDeclarationSymbolOrModuleEntity mySource;
    private CppCachedReference`1<UsingDeclarationTargets> myTargets;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <LocationAnchor>k__BackingField;
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public ICppScopeResolveEntity ParentScope { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppUsingDeclarationResolveEntity(ICppScopeResolveEntity parentScope, CppQualifiedName name, CppUsingDeclarationSymbol symbol, CppLocationAnchor anchor);
    public CppUsingDeclarationResolveEntity(ICppScopeResolveEntity parentScope, CppQualifiedName name, CppUsingDeclarationModuleEntity source, CppLocationAnchor anchor, UsingDeclarationTargets targets);
    public sealed virtual UsingDeclarationTargets GetTargets();
    private UsingDeclarationTargets CalculateTargets();
    public sealed virtual ICppResolveEntityParent get_RealParent();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public ICppScopeResolveEntity get_ParentScope();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    [CompilerGeneratedAttribute]
public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual UsingDeclarationTargets Journaling_GetTargets();
    public sealed virtual CppAccessibility GetAccessibility();
    public CppViewPos GetViewPos();
    public bool HadTypename();
    public bool Export();
    public ICppClassResolveEntity GetParentClass();
    public virtual string ToString();
    public CppQualifiedName GetName();
    public CppSymbolLocation GetSymbolLocation();
    internal bool IsImported();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUsingDeclarationResolveEntityWithSubstitution : object {
    private ICppResolveEntity myStructuralParent;
    private ICppUsingDeclarationResolveEntity myInner;
    private UsingDeclarationTargets myCachedTargets;
    private bool myTargetsCalculationInProcess;
    private CppSubstitutionDriver mySubstitutionDriver;
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppUsingDeclarationResolveEntityWithSubstitution(ICppScopeResolveEntity structuralParent, ICppUsingDeclarationResolveEntity inner, CppSubstitutionDriver driver);
    public sealed virtual UsingDeclarationTargets GetTargets();
    public sealed virtual ICppResolveEntityParent get_RealParent();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual UsingDeclarationTargets Journaling_GetTargets();
    public sealed virtual CppAccessibility GetAccessibility();
    private UsingDeclarationTargets CalculateTargets(UsingDeclarationTargets innerTargets);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUsingDeclarationSymbol : CppParserSymbol {
    private CppAccessibility myAccessibility;
    private bool myHadTypename;
    private bool myIsPackExpansion;
    private bool myExport;
    [CompilerGeneratedAttribute]
private CppFileLocation <ContainingFile>k__BackingField;
    public CppFileLocation ContainingFile { get; }
    public CppUsingDeclarationSymbol(CppQualifiedName name, CppAccessibility acc, CppSymbolLocation loc, bool hadTypename, bool isPackExpansion, bool export);
    public sealed virtual CppUsingDeclarationSymbol GetSymbol();
    [CompilerGeneratedAttribute]
public sealed virtual CppFileLocation get_ContainingFile();
    public sealed virtual CppSymbolLocation GetSymbolLocation();
    public sealed virtual bool HadTypename();
    public sealed virtual bool IsPackExpansion();
    public sealed virtual bool Export();
    public sealed virtual CppAccessibility GetAccessibility();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUsingDirectiveObject : object {
    private CppLocationAnchor myLocationAnchor;
    private ICppScopeResolveEntity myParent;
    private ICppSymbol mySymbol;
    private CppQualifiedName myTargetName;
    private CppCachedReference`1<CppNamespaceResolveEntity> myTarget;
    public CppLocationAnchor LocationAnchor { get; }
    public CppUsingDirectiveObject(ICppScopeResolveEntity parentScope, ICppSymbol sym, CppQualifiedName targetName, CppLocationAnchor anchor);
    public sealed virtual CppNamespaceResolveEntity GetTarget();
    private CppNamespaceResolveEntity CalculateTarget();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public ICppSymbol GetSymbol();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUsingDirectiveSymbol : CppParserSymbol {
    private static CppQualifiedId ourUsingDirectiveName;
    private CppQualifiedName myTarget;
    public CppUsingDirectiveSymbol(CppComplexOffset loc, CppQualifiedName target);
    private static CppUsingDirectiveSymbol();
    public CppQualifiedName GetTarget();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUsingEnumDeclarationData : object {
    private CppLocationAnchor myAnchor;
    private ICppScopeResolveEntity myScope;
    private CppUsingEnumDeclarationSymbol mySymbol;
    private ICppClassResolveEntity myTargetEnum;
    public CppUsingEnumDeclarationData(ICppClassResolveEntity targetEnum, ICppScopeResolveEntity scope, CppLocationAnchor anchor, CppUsingEnumDeclarationSymbol symbol);
    public ICppClassResolveEntity GetTargetEnum();
    public CppViewPos GetViewPos();
    public CppUsingEnumDeclarationSymbol GetSymbol();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUsingEnumDeclarationSymbol : CppParserSymbol {
    private static CppQualifiedId ourUsingEnumDeclarationName;
    private CppQualifiedName myTarget;
    public bool Export;
    public CppUsingEnumDeclarationSymbol(CppComplexOffset loc, CppQualifiedName target, bool export);
    private static CppUsingEnumDeclarationSymbol();
    public CppQualifiedName GetTarget();
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUsingEnumEnumeratorResolveEntity : object {
    private ICppScopeResolveEntity myParentScope;
    public bool Export;
    [CompilerGeneratedAttribute]
private ICppEnumeratorResolveEntity <Enumerator>k__BackingField;
    [CompilerGeneratedAttribute]
private CppLocationAnchor <LocationAnchor>k__BackingField;
    public ICppEnumeratorResolveEntity Enumerator { get; }
    public ICppResolveEntity StructuralParent { get; }
    public ICppResolveEntityParent RealParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public CppUsingEnumEnumeratorResolveEntity(ICppScopeResolveEntity parentScope, ICppEnumeratorResolveEntity enumerator, CppLocationAnchor anchor, bool export);
    [CompilerGeneratedAttribute]
public ICppEnumeratorResolveEntity get_Enumerator();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual ICppResolveEntityParent get_RealParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    [CompilerGeneratedAttribute]
public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual UsingDeclarationTargets GetTargets();
    public sealed virtual UsingDeclarationTargets Journaling_GetTargets();
    public sealed virtual CppAccessibility GetAccessibility();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUsingEnumeratorModuleEntity : object {
    public ICppEnumeratorModuleEntity Target;
    private bool myExplicitlyExported;
    public CppUsingEnumeratorModuleEntity(ICppEnumeratorModuleEntity target, bool explicitlyExported);
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual ICppScopeModuleEntity GetParent();
    public sealed virtual bool IsExplicitlyExported();
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUsingsBuilder : object {
    private ICppDeclarationBuilder myParent;
    private CppSymbolLocation myLocation;
    private ICppSymbol mySymbol;
    public ICppSymbol Symbol { get; }
    public CppUsingsBuilder(ICppDeclarationBuilder parent);
    public void LearnLocation(CppSymbolLocation location);
    public void LearnDirectiveTarget(CppTwinQualifiedNameBuilder& nameBuilder);
    public void LearnUsingDeclarationName(CppTwinQualifiedNameBuilder& nameBuilder, bool hadTypename, bool isPackExpansion);
    private CppUsingDeclarationResolveEntity FindImportedUsingDeclaration(ICppClassResolveEntity parentClass, CppLocationAnchor anchor, CppQualifiedNamePart replacedName);
    public void LearnAliasDeclaration(CppQualifiedName name, ICppDeclarationBuilder typeId, CppComplexOffset pointOfDeclaration, CppLocationAnchor anchorForViewPos);
    public CppUsingEnumDeclarationData LearnEnumDeclarationTarget(CppTwinQualifiedNameBuilder& nameBuilder);
    public ICppSymbol get_Symbol();
    public ICppDeclarationBuilder ParentDeclaration();
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUsingsBuilderUtil : object {
    public static void CreateUsingDirective(ICppScopeResolveEntity parentScope, CppUsingDirectiveSymbol sym, CppQualifiedName name, CppLocationAnchor anchor);
    public static CppUsingDeclarationResolveEntity CreateUsingDeclaration(ICppScopeResolveEntity parentScope, CppQualifiedName name, CppUsingDeclarationSymbol sym, CppLocationAnchor anchor, string moduleId);
    public static ICppTypeDeclaratorResolveEntity CreateAliasDeclaration(ICppScopeResolveEntity parentScope, List`1<CppTemplateParametersBase> templParams, CppAliasDeclarationSymbol sym, CppLocationAnchor anchor, CppLocationAnchor anchorForViewPos, CppQualType replacedType, CppAttributeList attributes, string moduleId);
    public static ICppClassResolveEntity CreateUsingEnumDeclaration(ICppScopeResolveEntity scope, CppQualifiedName name, CppLocationAnchor anchor, bool export);
    private static bool IsValidNameForUsing(CppQualifiedNamePart name);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUuidDeclaratorModuleEntity : object {
    private ICppClassOrRefClassModuleEntity myClass;
    public CppUuidDeclaratorModuleEntity(ICppClassOrRefClassModuleEntity class);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
    public sealed virtual CppImportResult`1<ICppGroupedVariableDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppUuidDeclaratorResolveEntity : object {
    private ICppClassResolveEntity myParent;
    private CppQualType myType;
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public ICppResolveEntityParent RealParent { get; }
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public bool IsParameterPack { get; }
    public CppUuidDeclaratorResolveEntity(ICppClassResolveEntity parent, CppQualType type);
    public sealed virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public sealed virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public sealed virtual CppAttributeList get_Attributes();
    public sealed virtual CppQualType GetCppType(ICppResolvedTypeFactory tf);
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual CppAccessibility GetAccessibility();
    public sealed virtual bool HasDefinition();
    public sealed virtual ICppResolveEntityParent get_RealParent();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual bool HasInitializer();
    public sealed virtual ICppEvaluationResult GetValue(CppEvaluationParams evalParams, ICppEvaluationErrorTracker errorTracker);
    public sealed virtual bool Contains(ICppDeclaratorResolveEntity decl);
    public sealed virtual ICppVariableTemplateDeclaratorResolveEntity GetTemplateDeclaration();
    public sealed virtual CppSmallList`1<ICppVariableDeclaratorResolveEntity> GetUngroupedDeclarators();
    public sealed virtual ICppVariableDeclaratorResolveEntity GetAnyUngrouped();
    public sealed virtual bool get_IsParameterPack();
    public virtual string ToString();
    public ICppClassResolveEntity GetClass();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppValueConstraint : object {
    public static CppValueConstraint INSTANCE;
    private static CppValueConstraint();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppVariableDeclaratorResolveEntity : CppDeclaratorResolveEntityBase {
    private CppLocationAnchor myInitializerAnchor;
    private CppDeclaratorInitializer myReplacedInitializer;
    private CppSmallArray`1<ICppExpression> myCachedResolvedInitializerArguments;
    private CppCachedInitializerState modreq(System.Runtime.CompilerServices.IsVolatile) myCachedResolvedInitializerState;
    public bool IsParameterPack { get; }
    public CppVariableDeclaratorResolveEntity(ICppResolveEntityParentScope parent, CppQualifiedNamePart name, ICppDeclaratorSymbol sym, CppLocationAnchor anchor, CppQualType replacedType, CppAttributeList attrs);
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    private CppDeclaratorInitializer ComposeResolvedInitializer();
    public sealed virtual CppViewPos GetViewPosForEvaluation();
    public virtual bool get_IsParameterPack();
    public virtual CppQualType GetCppType(ICppResolvedTypeFactory typeFactory);
    public void SetInitializer(CppDeclaratorInitializer replacedInitializer, CppLocationAnchor initializerAnchor);
    public CppQualType GetCppType(ICppResolvedTypeFactory typeFactory, bool adjustFunctionParameter);
    public virtual CppAccessibility GetAccessibility();
    private ICppClassResolveEntity GetEnclosingAnonymousClass();
    public virtual bool HasDefinition();
    public CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public CppViewPos GetViewPosForInitializer();
    public virtual string ToString();
    protected virtual void DumpInternal(CppIndentationStringBuilder tw);
    protected virtual CppQualType GetNonNormalizedType(ICppResolvedTypeFactory typeIntern, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPosForDeclSpecs, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPosForDeclarator);
    internal static void PatchUpZeroLengthArrayTypeForStructField(ICppVariableDeclaratorResolveEntity var, CppQualType& type, ICppResolvedTypeFactory typeIntern);
    public sealed virtual bool HasInitializer();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppVariableDeclaratorResolveEntityWithSubstitution : CppDeclaratorResolveEntityWithSubstitutionBase`1<ICppGroupedVariableDeclaratorResolveEntity> {
    private CppDeclaratorInitializer myCachedInitializer;
    private CppCachedInitializerState modreq(System.Runtime.CompilerServices.IsVolatile) myInitializerState;
    public bool InitializerSubstitutionInProgress { get; }
    public bool IsParameterPack { get; }
    public CppVariableDeclaratorResolveEntityWithSubstitution(ICppResolveEntityParent structuralParent, CppViewPos& vp, CppQualifiedNamePart name, ICppGroupedVariableDeclaratorResolveEntity inner, ICppSubstitutionContext subst);
    public virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual CppDeclaratorInitializer GetInitializer();
    public sealed virtual bool HasInitializer();
    private ValueTuple`2<CppDeclaratorInitializer, ICppSubstitutionContext> GetInnerInitializerWithSubstitution();
    public bool get_InitializerSubstitutionInProgress();
    public sealed virtual CppViewPos GetViewPosForEvaluation();
    public sealed virtual bool get_IsParameterPack();
    public virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
    public static void SubstituteIfNeeded(CppDeclaratorInitializer& initializer, CppVariableDeclaratorResolveEntityWithSubstitution var, ICppFunctionDeclaratorResolveEntity initializerProvidingFunction, ICppFunctionDeclaratorResolveEntity variableProvidingFunction, ICppGroupedFunctionDeclaratorResolveEntity grouped);
    private static CppDeclaratorInitializer TryFindInnerInitializerInOtherParameterList(CppVariableDeclaratorResolveEntityWithSubstitution var);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppVariableModuleEntity : object {
    public ICppScopeModuleEntity Parent;
    public CppQualifiedNamePart Name;
    public CppDeclarationSpecifiers DeclarationSpecifiers;
    public IEnumerable`1<ICppSymbol> Symbols;
    public CppSmallArray`1<ICppAttribute> Attributes;
    public CppQualType Type;
    public CppDeclaratorInitializer Initializer;
    public bool HasDefinition;
    public CppAccessibility Accessibility;
    private bool myExplicitlyExported;
    public int Index;
    public CppVariableModuleEntity(int index, ICppScopeModuleEntity parent, CppDeclarationSpecifiers declarationSpecifiers, IEnumerable`1<ICppSymbol> symbols, bool hasDefinition, CppAccessibility accessibility, bool explicitlyExported);
    internal CppVariableModuleEntity(int index);
    public sealed virtual CppQualifiedNamePart GetName();
    public sealed virtual ICppScopeModuleEntity GetParent();
    public sealed virtual bool IsExplicitlyExported();
    public sealed virtual CppImportResult`1<ICppGroupedVariableDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
    public virtual int SerializedSize();
    public virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppVariableTemplateModuleEntity : object {
    public ICppVariableModuleEntity PrimaryTemplate;
    public CppVariableTemplateModuleEntity(ICppVariableModuleEntity primaryTemplate);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppViewPos : ValueType {
    private ICppScopeResolveEntity myResolveScope;
    private CppLocationAnchor myAnchor;
    private CppTemplateHeaders myTemplateHeaders;
    private Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> myMapping;
    private ICppScopeResolveEntity myResolveScopeForDependencies;
    public CppViewPos(ICppScopeResolveEntity resolveScope, CppLocationAnchor anchor, CppTemplateParametersBase templParams);
    public CppViewPos(ICppScopeResolveEntity resolveScope, CppLocationAnchor anchor, CppTemplateParametersBase templParams, Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> mapping);
    public CppViewPos(ICppScopeResolveEntity resolveScope, CppLocationAnchor anchor, List`1<CppTemplateParametersBase> templParams, Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> mapping);
    public CppViewPos(ICppScopeResolveEntity resolveScope, CppLocationAnchor anchor, CppTemplateHeaders& templateHeaders, Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> mapping);
    public CppViewPos(ICppScopeResolveEntity resolveScope, CppLocationAnchor anchor, CppTemplateHeaders& templateHeaders, Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> mapping, ICppScopeResolveEntity resolveScopeForDependencies);
    public ICppScopeResolveEntity ResolveScope();
    public CppLocationAnchor Anchor();
    public CppTemplateHeaders TemplateHeaders();
    public Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> Mapping();
    public ICppScopeResolveEntity ResolveScopeForDependencies();
    public static CppLocationAnchor AnchorForViewPos(ICppScopeResolveEntity scope, CppViewPos& viewPos);
    private static CppLocationAnchor TranslateAnchorToInner(ICppScopeResolveEntity inner, ICppScopeResolveEntity outer, CppLocationAnchor anchor);
    public bool IsVisible(ICppResolveEntity ent);
    public bool IsVisible(ICppScopeResolveEntity scope, CppLocationAnchor anchorInScope);
    public bool IsVisible(CppViewPos& where);
    public static CppViewPos Full(ICppScopeResolveEntity resolveScope);
    [ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertScopeIsValid(ICppScopeResolveEntity ent);
    public virtual string ToString();
    public bool IsValid();
    public void CheckInvariant();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppVTableEntryInfo : object {
    public CppMethodInheritanceInfo Slot;
    public CppClassInheritanceInfo Class { get; }
    public CppMethodInheritanceInfo Method { get; }
    [CanBeNullAttribute]
public CppVTableEntryInfo Overrides { get; }
    public bool IsPure { get; }
    public bool IsSealed { get; }
    public bool IsAmbiguous { get; }
    public CppVTableEntryInfo ClassSlot { get; }
    protected CppVTableEntryInfo(CppMethodInheritanceInfo slot);
    public abstract virtual CppClassInheritanceInfo get_Class();
    public abstract virtual CppMethodInheritanceInfo get_Method();
    public abstract virtual CppVTableEntryInfo get_Overrides();
    public abstract virtual bool get_IsPure();
    public abstract virtual bool get_IsSealed();
    public virtual bool get_IsAmbiguous();
    public CppVTableEntryInfo get_ClassSlot();
    public bool IsAmbiguousWithoutDependent();
    public bool IsPrivateCliMethod();
    public bool IsLiveInClass(CppClassInheritanceInfo cls);
    public virtual bool Contains(CppVTableEntryInfo other);
    public abstract virtual Result Accept(ICppVTableEntryInfoVisitor`1<Result> visitor);
    public virtual bool IsVirtualBaseSlot();
    public virtual bool IsDominatedBy(CppVTableEntryInfo other);
    public virtual bool IsDominantOver(CppVTableEntryInfo other);
    protected virtual bool IsDominantOverInner(CppVTableEntryInfo other);
    public virtual CppVTableEntryInfo AddAmbiguous(CppVTableEntryInfo other);
    public virtual CppVTableEntryInfo AddMultipleInheritance(CppClassInheritanceInfo cls, CppVTableEntryInfo other);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppVTableEntryInfoAlias : CppVTableEntryInfoSpecific {
    public bool IsPure { get; }
    public bool IsSealed { get; }
    public CppVTableEntryInfoAlias(CppMethodInheritanceInfo slot, CppMethodInheritanceInfo method, CppVTableEntryInfo overrides);
    public virtual bool get_IsPure();
    public virtual bool get_IsSealed();
    public virtual Result Accept(ICppVTableEntryInfoVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppVTableEntryInfoAmbiguous : CppVTableEntryInfoSet {
    public CppVTableEntryInfoAmbiguous(CppMethodInheritanceInfo slot, CppVTableEntryInfo first, CppVTableEntryInfo second);
    public virtual Result Accept(ICppVTableEntryInfoVisitor`1<Result> visitor);
    public virtual CppVTableEntryInfo AddAmbiguous(CppVTableEntryInfo other);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppVTableEntryInfoDeferredImplement : CppVTableEntryInfoAlias {
    [CompilerGeneratedAttribute]
private CppClassInheritanceInfo <Class>k__BackingField;
    public CppClassInheritanceInfo Class { get; }
    public CppVTableEntryInfoDeferredImplement(CppClassInheritanceInfo cls, CppMethodInheritanceInfo slot, CppMethodInheritanceInfo method, CppVTableEntryInfo overrides);
    [CompilerGeneratedAttribute]
public virtual CppClassInheritanceInfo get_Class();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppVTableEntryInfoMultipleInheritance : CppVTableEntryInfoSet {
    [CompilerGeneratedAttribute]
private CppClassInheritanceInfo <Class>k__BackingField;
    public CppClassInheritanceInfo Class { get; }
    public CppVTableEntryInfoMultipleInheritance(CppClassInheritanceInfo cls, CppMethodInheritanceInfo slot, CppVTableEntryInfo first, CppVTableEntryInfo second);
    [CompilerGeneratedAttribute]
public virtual CppClassInheritanceInfo get_Class();
    public virtual Result Accept(ICppVTableEntryInfoVisitor`1<Result> visitor);
    public virtual CppVTableEntryInfo AddMultipleInheritance(CppClassInheritanceInfo cls, CppVTableEntryInfo other);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppVTableEntryInfoPrimary : CppVTableEntryInfoSpecific {
    [CompilerGeneratedAttribute]
private bool <IsSealed>k__BackingField;
    public bool IsPure { get; }
    public bool IsSealed { get; }
    public CppVTableEntryInfoPrimary(CppMethodInheritanceInfo slot, CppMethodInheritanceInfo method, CppVTableEntryInfo overrides, bool isSealed);
    public virtual bool get_IsPure();
    [CompilerGeneratedAttribute]
public virtual bool get_IsSealed();
    public virtual Result Accept(ICppVTableEntryInfoVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppVTableEntryInfoPrimaryWithInterfaceDefault : CppVTableEntryInfoPrimary {
    public bool IsPure { get; }
    public CppVTableEntryInfoPrimaryWithInterfaceDefault(CppMethodInheritanceInfo slot, CppMethodInheritanceInfo method, CppVTableEntryInfo overrides, bool isSealed);
    public virtual bool get_IsPure();
    public virtual bool IsDominantOver(CppVTableEntryInfo other);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppVTableEntryInfoSet : CppVTableEntryInfo {
    protected List`1<CppVTableEntryInfo> myItems;
    public CppClassInheritanceInfo Class { get; }
    public CppMethodInheritanceInfo Method { get; }
    public CppVTableEntryInfo Overrides { get; }
    public IReadOnlyList`1<CppVTableEntryInfo> Items { get; }
    public bool IsPure { get; }
    public bool IsSealed { get; }
    public bool IsAmbiguous { get; }
    protected CppVTableEntryInfoSet(CppMethodInheritanceInfo slot, CppVTableEntryInfo first, CppVTableEntryInfo second);
    public virtual CppClassInheritanceInfo get_Class();
    public virtual CppMethodInheritanceInfo get_Method();
    public virtual CppVTableEntryInfo get_Overrides();
    public IReadOnlyList`1<CppVTableEntryInfo> get_Items();
    public virtual bool get_IsPure();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAmbiguous();
    public virtual bool Contains(CppVTableEntryInfo other);
    public virtual bool IsVirtualBaseSlot();
    public virtual bool IsDominatedBy(CppVTableEntryInfo other);
    protected virtual bool IsDominantOverInner(CppVTableEntryInfo other);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppVTableEntryInfoSpecific : CppVTableEntryInfo {
    private CppMethodInheritanceInfo myMethod;
    [CompilerGeneratedAttribute]
private CppVTableEntryInfo <Overrides>k__BackingField;
    public CppClassInheritanceInfo Class { get; }
    public CppMethodInheritanceInfo Method { get; }
    public CppVTableEntryInfo Overrides { get; }
    protected CppVTableEntryInfoSpecific(CppMethodInheritanceInfo slot, CppMethodInheritanceInfo method, CppVTableEntryInfo overrides);
    public virtual CppClassInheritanceInfo get_Class();
    public virtual CppMethodInheritanceInfo get_Method();
    [CompilerGeneratedAttribute]
public virtual CppVTableEntryInfo get_Overrides();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppVTableEntryInfoVirtualBase : CppVTableEntryInfo {
    private CppVTableEntryInfo myOverrides;
    [CompilerGeneratedAttribute]
private CppClassInheritanceInfo <Class>k__BackingField;
    public CppClassInheritanceInfo Class { get; }
    public CppMethodInheritanceInfo Method { get; }
    public CppVTableEntryInfo Overrides { get; }
    public bool IsPure { get; }
    public bool IsSealed { get; }
    public bool IsAmbiguous { get; }
    public CppVTableEntryInfoVirtualBase(CppVTableEntryInfo overrides, CppClassInheritanceInfo base);
    [CompilerGeneratedAttribute]
public virtual CppClassInheritanceInfo get_Class();
    public virtual CppMethodInheritanceInfo get_Method();
    public virtual CppVTableEntryInfo get_Overrides();
    public virtual bool get_IsPure();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAmbiguous();
    public virtual Result Accept(ICppVTableEntryInfoVisitor`1<Result> visitor);
    public virtual bool Contains(CppVTableEntryInfo other);
    public virtual bool IsVirtualBaseSlot();
    public virtual bool IsDominatedBy(CppVTableEntryInfo other);
    public virtual bool IsDominantOver(CppVTableEntryInfo other);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppVTableEntryInfoVisitor`1 : object {
    public virtual Result Visit(CppVTableEntryInfoPrimary entry);
    public virtual Result Visit(CppVTableEntryInfoAlias entry);
    public virtual Result Visit(CppVTableEntryInfoAmbiguous entry);
    public virtual Result Visit(CppVTableEntryInfoMultipleInheritance entry);
    public virtual Result Visit(CppVTableEntryInfoVirtualBase entry);
    public abstract virtual Result Visit(CppVTableEntryInfoSpecific entry);
    public abstract virtual Result Visit(CppVTableEntryInfoSet entry);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppWhileStatementBuilder : CppLoopStatementBuilder`2<CppWhileStatementSymbol, CppWhileStatementResolveEntity> {
    public CppWhileStatementBuilder(ICppBuilder parent, CppSymbolLocation loc);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppWhileStatementModuleEntity : CppLoopStatementModuleEntity {
    public CppWhileStatementModuleEntity(CppLocationAnchor anchor, CppRegularFunctionModuleEntity function);
    public virtual ICppStatementResolveEntity Import(CppScopeResolveEntityBase targetParent, CppModuleImportingContext ctx);
    public virtual CppModuleEntityKind Kind();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppWhileStatementResolveEntity : CppWhileStatementResolveEntityBase {
    private CppResolveEntityCondition myCondition;
    public CppWhileStatementResolveEntity(ICppResolveEntity parentScope, CppLocationAnchor location);
    public virtual void SetReplacedCondition(ICppExpression e, CppLocationAnchor location);
    public virtual void SetResolvedCondition(ICppResolvedExpression e);
    public virtual ICppResolvedExpression GetCondition();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Symbols.CppWhileStatementResolveEntityBase : CppLoopStatementResolveEntityBase {
    public static CppQualifiedId NAME;
    public CppQualifiedNamePart Name { get; }
    protected CppWhileStatementResolveEntityBase(ICppResolveEntity parentScope, CppLocationAnchor location);
    private static CppWhileStatementResolveEntityBase();
    public virtual CppQualifiedNamePart get_Name();
    public virtual string ToString();
    internal virtual CppFuncEvaluationResult Evaluate(CppExpressionEvaluator evaluator, CppFunctionEvaluationContext functionCtx, CppQualType retType);
    internal virtual CppLoopStatementResolveEntityBase Substitute(ICppScopeResolveEntity parent, CppSubstitutionDriver driver);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.CppWhileStatementResolveEntityWithSubstitution : CppWhileStatementResolveEntityBase {
    private CppWhileStatementResolveEntityBase myInner;
    private CppSubstitutedCondition myCondition;
    public CppWhileStatementResolveEntityWithSubstitution(ICppScopeResolveEntity parent, CppWhileStatementResolveEntityBase inner, CppSubstitutionDriver driver);
    public virtual ICppResolvedExpression GetCondition();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.CppWhileStatementSymbol : CppLoopStatementSymbol {
    public CppWhileStatementSymbol(CppSymbolLocation loc);
    public virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.FunctionSignature : object {
    private CppQualifiedNamePart myName;
    private CppQualType myType;
    public FunctionSignature(CppQualifiedNamePart name, CppQualType type);
    public virtual int GetHashCode();
    public virtual bool Equals(object rhs);
    public CppQualifiedNamePart GetName();
    public CppQualType GetCppType();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.GenericSymbolLocationComparator`1 : object {
    public static GenericSymbolLocationComparator`1<T> INSTANCE;
    private static GenericSymbolLocationComparator`1();
    public sealed virtual bool Equals(T lhs, T rhs);
    public sealed virtual int GetHashCode(T obj);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.GenericSymbolLocationWithParentComparator`1 : object {
    public static GenericSymbolLocationWithParentComparator`1<T> INSTANCE;
    private static GenericSymbolLocationWithParentComparator`1();
    public sealed virtual bool Equals(T lhs, T rhs);
    public sealed virtual int GetHashCode(T obj);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.GetFileResolveCacheUtil : object {
    [ExtensionAttribute]
public static ICppFileResolveEntitiesCache GetFileResolveCache(ICppResolveEntity e);
    [ExtensionAttribute]
public static ICppRootFileResolveEntitiesCache GetRootFileResolveCache(ICppResolveEntity e);
    [ExtensionAttribute]
public static ICppFileResolveEntitiesCache GetFileResolveCache(CppViewPos& vp);
    [ExtensionAttribute]
public static ICppRootFileResolveEntitiesCache GetRootFileResolveCache(CppViewPos& vp);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.GetFileResolveCacheVisitor : object {
    public static GetFileResolveCacheVisitor INSTANCE;
    private static GetFileResolveCacheVisitor();
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppClassResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppStatementResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppRequiresExpressionScopeResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppRequiresExpressionItemResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppParameterListResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppDeclaratorResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppConceptDefinitionResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppEnumeratorResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppNamespaceResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppNamespaceAliasResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppUsingDeclarationResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppClassTemplateResolveEntityPack e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppTypeTemplateParameter e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppTypeTemplateParameterPack e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppExpressionTemplateParameter e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppExpressionTemplateParameterPack e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppTemplateTemplateParameter e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppTemplateTemplateParameterPack e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppGenericParameter e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppDependentResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppDependentDecltypeResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppDependentAutoTypeResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppDependentFunctionReturnAutoTypeResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppDependentDeducedClassTypePlaceholder e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppUsingDeclarationResolveEntityWithSubstitution e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppUndeterminedSpecializationResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppTemplateTemplateParameterWithAppliedArgumentsResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppDecltypeResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppTypeOfTypeResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppDeclaratorResolveEntityPack e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppUndeterminedTemplateVariableSpecializationResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppSuperResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(AbstractBuiltinResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppFunctionTemplateDeclaratorResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppTypeTemplateDeclaratorResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppVariableTemplateDeclaratorResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppDependencyKillerResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppCxxCliPropertySetResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(ICppDeductionGuide guide);
    public sealed virtual ICppFileResolveEntitiesCache Visit(CppUsingEnumEnumeratorResolveEntity e);
    public sealed virtual ICppFileResolveEntitiesCache Visit(HlslBuiltinFunctionResolveEntity ent);
    public sealed virtual ICppFileResolveEntitiesCache Visit(BlockShadersResolveEntity e);
    private static ICppFileResolveEntitiesCache GetFileResolveCacheThroughGlobalNamespace(ICppResolveEntity scope);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslAppendStructuredBufferMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslAppendStructuredBufferMethodsAppendParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslAppendStructuredBufferMethodsAppendParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslAppendStructuredBufferMethodsGetDimensionsParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslAppendStructuredBufferMethodsGetDimensionsParameterPatterns_1();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.HlslBasicKind : Enum {
    public int value__;
    public static HlslBasicKind BOOL;
    public static HlslBasicKind FLOAT16;
    public static HlslBasicKind FLOAT32_PARTIAL_PRECISION;
    public static HlslBasicKind FLOAT32;
    public static HlslBasicKind FLOAT64;
    public static HlslBasicKind INT8;
    public static HlslBasicKind UINT8;
    public static HlslBasicKind INT16;
    public static HlslBasicKind UINT16;
    public static HlslBasicKind INT32;
    public static HlslBasicKind UINT32;
    public static HlslBasicKind INT64;
    public static HlslBasicKind UINT64;
    public static HlslBasicKind MIN10FLOAT;
    public static HlslBasicKind MIN16FLOAT;
    public static HlslBasicKind MIN12INT;
    public static HlslBasicKind MIN16INT;
    public static HlslBasicKind MIN16UINT;
    public static HlslBasicKind ENUM;
    public static HlslBasicKind COUNT;
    public static HlslBasicKind NONE;
    public static HlslBasicKind UNKNOWN;
    public static HlslBasicKind NOCAST;
    public static HlslBasicKind POINTER;
    public static HlslBasicKind ENUM_CLASS;
    public static HlslBasicKind NULL;
    public static HlslBasicKind STRING_LITERAL;
    public static HlslBasicKind STRING;
    public static HlslBasicKind TEXTURE1D;
    public static HlslBasicKind TEXTURE1D_ARRAY;
    public static HlslBasicKind TEXTURE2D;
    public static HlslBasicKind TEXTURE2D_ARRAY;
    public static HlslBasicKind TEXTURE3D;
    public static HlslBasicKind TEXTURECUBE;
    public static HlslBasicKind TEXTURECUBE_ARRAY;
    public static HlslBasicKind TEXTURE2DMS;
    public static HlslBasicKind TEXTURE2DMS_ARRAY;
    public static HlslBasicKind SAMPLER;
    public static HlslBasicKind SAMPLER1D;
    public static HlslBasicKind SAMPLER2D;
    public static HlslBasicKind SAMPLER3D;
    public static HlslBasicKind SAMPLERCUBE;
    public static HlslBasicKind SAMPLERCOMPARISON;
    public static HlslBasicKind STATEBLOCK;
    public static HlslBasicKind INPUTPATCH;
    public static HlslBasicKind OUTPUTPATCH;
    public static HlslBasicKind INNER;
    public static HlslBasicKind LEGACY_EFFECT;
    public static HlslBasicKind WAVE;
    public static HlslBasicKind RAY_DESC;
    public static HlslBasicKind ACCELERATION_STRUCT;
    public static HlslBasicKind USER_DEFINED_TYPE;
    public static HlslBasicKind TRIANGLE_INTERSECTION_ATTRIBUTES;
    public static HlslBasicKind STATE_OBJECT_CONFIG;
    public static HlslBasicKind GLOBAL_ROOT_SIGNATURE;
    public static HlslBasicKind LOCAL_ROOT_SIGNATURE;
    public static HlslBasicKind SUBOBJECT_TO_EXPORTS_ASSOC;
    public static HlslBasicKind RAYTRACING_SHADER_CONFIG;
    public static HlslBasicKind RAYTRACING_PIPELINE_CONFIG;
    public static HlslBasicKind TRIANGLE_HIT_GROUP;
    public static HlslBasicKind PROCEDURAL_PRIMITIVE_HIT_GROUP;
    public static HlslBasicKind RAYTRACING_PIPELINE_CONFIG1;
    public static HlslBasicKind RAY_QUERY;
    public static HlslBasicKind MAXIMUM_COUNT;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslBufferMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslBufferMethodsGetDimensionsParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslBufferMethodsGetDimensionsParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslBufferMethodsLoadParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslBufferMethodsLoadParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslBufferMethodsLoadParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslBufferMethodsLoadParameterPatterns_2();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslBufferSpecifierBuilder : ValueType {
    private ICppDeclarationBuilder myOwner;
    public HlslBufferSpecifierBuilder(ICppDeclarationBuilder owner);
    public void LearnComponentType(ICppDeclarationBuilder declBuilder);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslBuiltinFunctionMatchResult : ValueType {
    public static byte IA_SPECIAL_SLOTS;
    public static int MaxIntrinsicArgs;
    public HlslBuiltinFunctionMatchStatus status;
    public CppQualType returnType;
    public HlslBuiltinFunctionMatchResult(HlslBuiltinFunctionMatchStatus status, CppQualType returnType);
    public static HlslBuiltinFunctionMatchResult Fail();
    private static HlslObjectKind ClassifyClassResolveEntity(ICppClassResolveEntity ent);
    private static HlslObjectKind GetTypeObjectKind(CppQualType type);
    public static HlslBuiltinFunctionMatchResult Match(HlslBuiltinFunctionPattern pattern, List`1<CppQualType> argsT, CppQualType objectTemplateType);
    private static HlslBasicKind CombineBasicTypes(HlslBasicKind left, HlslBasicKind right);
    private static CppQualType CreateFinalTypeByPattern(HlslBuiltinFunctionParameterPattern paramPattern, HlslObjectKind[] Template, HlslBasicKind[] ComponentType, Byte[] uSpecialSize, CppQualType objectType);
    private static CppQualType BasicKindToPredefinedType(HlslBasicKind kind);
    private static CppQualType CreateAggregateType(HlslObjectKind hlslObjectKind, HlslBasicKind basicKind, byte rows, byte columns, CppQualType objectType);
    private static HlslBasicKind ClassifyClassResolveEntityKind(ICppClassResolveEntity ent);
    private static HlslBasicKind ToBasicKind(CppNumericTypeKind kind);
    public static HlslBasicKind GetTypeElementKind(CppQualType type);
    private static bool IsFloating(HlslBasicKind kind);
    private static bool isUnsigned(HlslBasicKind kind);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.HlslBuiltinFunctionMatchStatus : Enum {
    public int value__;
    public static HlslBuiltinFunctionMatchStatus OK;
    public static HlslBuiltinFunctionMatchStatus FAIL;
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslBuiltinFunctionParameterPattern : ValueType {
    public HlslQuals quals;
    public HlslTemplateId templateId;
    public HlslLegalIntrinsicTemplates legalIntrinsicTemplates;
    public HlslCompTypeId componentTypeId;
    public HlslLegalIntrinsicCompTypes legalIntrinsicCompTypes;
    public HlslDimensionSize rows;
    public HlslDimensionSize columns;
    public HlslBuiltinFunctionParameterPattern(HlslQuals quals, HlslTemplateId templateId, HlslLegalIntrinsicTemplates legalIntrinsicTemplates, HlslCompTypeId componentTypeId, HlslLegalIntrinsicCompTypes legalIntrinsicCompTypes, HlslDimensionSize rows, HlslDimensionSize columns);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslBuiltinFunctionPattern : ValueType {
    public string name;
    public sbyte overloadParamIndex;
    public HlslBuiltinFunctionParameterPattern[] parameters;
    internal HlslBuiltinFunctionPattern(string name, sbyte overloadParamIndex, HlslBuiltinFunctionParameterPattern[] parameters);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslBuiltinFunctionResolveEntity : object {
    [CompilerGeneratedAttribute]
private ICppResolveEntity <parent>P;
    private CppQualifiedNamePart myName;
    private HlslKnownBuiltinFunction myBuiltinFunction;
    [IsReadOnlyAttribute]
public HlslBuiltinFunctionPattern& modreq(System.Runtime.InteropServices.InAttribute) Pattern { get; }
    public HlslKnownBuiltinFunction BuiltinFunction { get; }
    public ICppResolveEntity StructuralParent { get; }
    public ICppResolveEntityParent RealParent { get; }
    public CppQualifiedNamePart Name { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public HlslBuiltinFunctionResolveEntity(ICppResolveEntity parent, CppQualifiedNamePart name, HlslKnownBuiltinFunction builtinFunction);
    public HlslBuiltinFunctionPattern& modreq(System.Runtime.InteropServices.InAttribute) get_Pattern();
    public HlslKnownBuiltinFunction get_BuiltinFunction();
    public sealed virtual ICppResolveEntity get_StructuralParent();
    public sealed virtual ICppResolveEntityParent get_RealParent();
    public sealed virtual CppQualifiedNamePart get_Name();
    public sealed virtual CppLocationAnchor get_LocationAnchor();
    public sealed virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
    public sealed virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public HlslBuiltinFunctionMatchResult MatchPattern(List`1<CppQualType> argT);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslBuiltinNames : object {
    public static int VectorsMin16Float;
    public static int VectorsMin10Float;
    public static int VectorsMin16Int;
    public static int VectorsMin12Int;
    public static int VectorsMin16Uint;
    public static int MatricesMin16Float;
    public static int MatricesMin10Float;
    public static int MatricesMin16Int;
    public static int MatricesMin12Int;
    public static int MatricesMin16Uint;
    public static string PositiveInf;
    public static string NegativeInf;
    public static CppQualifiedId Uint;
    public static CppQualifiedId Dword;
    public static CppQualifiedId DWORD;
    public static CppQualifiedId FLOAT;
    public static CppQualifiedId VECTOR;
    public static CppQualifiedId MATRIX;
    public static CppQualifiedId Sampler;
    public static CppQualifiedId SamplerState;
    public static CppQualifiedId Min16Float;
    public static CppQualifiedId Min10Float;
    public static CppQualifiedId Min16Int;
    public static CppQualifiedId Min12Int;
    public static CppQualifiedId Min16Uint;
    public static CppQualifiedId PointStream;
    public static CppQualifiedId LineStream;
    public static CppQualifiedId TriangleStream;
    public static CppQualifiedId Buffer;
    public static CppQualifiedId Texture1D;
    public static CppQualifiedId Texture1DArray;
    public static CppQualifiedId Texture2D;
    public static CppQualifiedId Texture2DArray;
    public static CppQualifiedId Texture3D;
    public static CppQualifiedId TextureCube;
    public static CppQualifiedId TextureCubeArray;
    public static CppQualifiedId Texture2DMS;
    public static CppQualifiedId Texture2DMSArray;
    public static CppQualifiedId StructuredBuffer;
    public static CppQualifiedId ByteAddressBuffer;
    public static CppQualifiedId AppendStructuredBuffer;
    public static CppQualifiedId ConsumeStructuredBuffer;
    public static CppQualifiedId RWBuffer;
    public static CppQualifiedId RWStructuredBuffer;
    public static CppQualifiedId RWByteAddressBuffer;
    public static CppQualifiedId RWTexture1D;
    public static CppQualifiedId RWTexture1DArray;
    public static CppQualifiedId RWTexture2D;
    public static CppQualifiedId RWTexture2DArray;
    public static CppQualifiedId RWTexture3D;
    public static CppQualifiedId InputPatch;
    public static CppQualifiedId OutputPatch;
    public static CppQualifiedId Length;
    public static CppQualifiedId RayDesc;
    public static CppQualifiedId RayDescOrigin;
    public static CppQualifiedId RayDescTMin;
    public static CppQualifiedId RayDescDirection;
    public static CppQualifiedId RayDescTMax;
    public static CppQualifiedId RaytracingAccelerationStructure;
    public static CppQualifiedId RayFlag;
    public static CppQualifiedId RayFlagNone;
    public static CppQualifiedId RayFlagForceOpaque;
    public static CppQualifiedId RayFlagForceNonOpaque;
    public static CppQualifiedId RayFlagAcceptFirstHitAndEndSearch;
    public static CppQualifiedId RayFlagSkipClosestHitShader;
    public static CppQualifiedId RayFlagCullBackFacingTriangles;
    public static CppQualifiedId RayFlagCullFrontFacingTriangles;
    public static CppQualifiedId RayFlagCullOpaque;
    public static CppQualifiedId RayFlagCullNonOpaque;
    public static CppQualifiedId RayFlagSkipTriangles;
    public static CppQualifiedId RayFlagSkipProceduralPrimitives;
    public static CppQualifiedId RaytracingPipelineFlagNone;
    public static CppQualifiedId RaytracingPipelineFlagSkipTriangles;
    public static CppQualifiedId RaytracingPipelineFlagSkipProceduralPrimitives;
    public static CppQualifiedId CommittedStatus;
    public static CppQualifiedId CommittedNothing;
    public static CppQualifiedId CommittedTriangleHit;
    public static CppQualifiedId CommittedProceduralPrimitiveHit;
    public static CppQualifiedId CandidateType;
    public static CppQualifiedId CandidateNonOpaqueTriangle;
    public static CppQualifiedId CandidateProceduralPrimitive;
    public static CppType RayFlagUnresolvedType;
    public static CppQualifiedId RayQuery;
    public static CppQualifiedId SampleSliceType;
    public static CppQualifiedId SampleType;
    public static CppQualifiedId Sample;
    public static CppQualifiedId MipsSliceType;
    public static CppQualifiedId MipsType;
    public static CppQualifiedId Mips;
    private static String[] Scalars;
    public static CppQualifiedId[] VECTORS;
    public static CppQualifiedId[] MATRICES;
    private static HlslBuiltinNames();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Symbols.HlslBuiltinNames/<CreateVectors>d__92")]
private static IEnumerable`1<CppQualifiedId> CreateVectors();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Symbols.HlslBuiltinNames/<CreateMatrices>d__93")]
private static IEnumerable`1<CppQualifiedId> CreateMatrices();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslByteAddressBufferMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslByteAddressBufferMethodsGetDimensionsParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslByteAddressBufferMethodsGetDimensionsParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslByteAddressBufferMethodsLoad2ParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslByteAddressBufferMethodsLoad2ParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslByteAddressBufferMethodsLoad2ParameterPatterns_4 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslByteAddressBufferMethodsLoad2ParameterPatterns_4();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslByteAddressBufferMethodsLoad3ParameterPatterns_5 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslByteAddressBufferMethodsLoad3ParameterPatterns_5();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslByteAddressBufferMethodsLoad3ParameterPatterns_6 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslByteAddressBufferMethodsLoad3ParameterPatterns_6();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslByteAddressBufferMethodsLoad4ParameterPatterns_7 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslByteAddressBufferMethodsLoad4ParameterPatterns_7();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslByteAddressBufferMethodsLoad4ParameterPatterns_8 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslByteAddressBufferMethodsLoad4ParameterPatterns_8();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslByteAddressBufferMethodsLoadParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslByteAddressBufferMethodsLoadParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslByteAddressBufferMethodsLoadParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslByteAddressBufferMethodsLoadParameterPatterns_2();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.HlslCompTypeId : Enum {
    public byte value__;
    public static HlslCompTypeId COPM_TYPE_RETURN_TYPE;
    public static HlslCompTypeId COPM_TYPE_FIRST_PARAM;
    public static HlslCompTypeId COPM_TYPE_SECOND_PARAM;
    public static HlslCompTypeId COPM_TYPE_THIRD_PARAM;
    public static HlslCompTypeId COPM_TYPE_FOURTH_PARAM;
    public static HlslCompTypeId COPM_TYPE_FIFTH_PARAM;
    public static HlslCompTypeId COPM_TYPE_SIXTH_PARAM;
    public static HlslCompTypeId COPM_TYPE_SEVENTH_PARAM;
    public static HlslCompTypeId COPM_TYPE_EIGHTH_PARAM;
    public static HlslCompTypeId COMP_TYPE_FROM_TYPE_ELT0;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslConsumeStructuredBufferMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslConsumeStructuredBufferMethodsConsumeParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslConsumeStructuredBufferMethodsConsumeParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslConsumeStructuredBufferMethodsGetDimensionsParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslConsumeStructuredBufferMethodsGetDimensionsParameterPatterns_1();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.HlslDimensionSize : Enum {
    public byte value__;
    public static HlslDimensionSize ZERO;
    public static HlslDimensionSize ONE;
    public static HlslDimensionSize TWO;
    public static HlslDimensionSize THREE;
    public static HlslDimensionSize FOUR;
    public static HlslDimensionSize IA_SPECIAL_BASE;
    public static HlslDimensionSize IA_R;
    public static HlslDimensionSize IA_C;
    public static HlslDimensionSize IA_R2;
    public static HlslDimensionSize IA_C2;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslFeedbackTexture2DArrayMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslFeedbackTexture2DArrayMethodsWriteSamplerFeedbackBiasParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslFeedbackTexture2DArrayMethodsWriteSamplerFeedbackBiasParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslFeedbackTexture2DArrayMethodsWriteSamplerFeedbackBiasParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslFeedbackTexture2DArrayMethodsWriteSamplerFeedbackBiasParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslFeedbackTexture2DArrayMethodsWriteSamplerFeedbackGradParameterPatterns_4 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslFeedbackTexture2DArrayMethodsWriteSamplerFeedbackGradParameterPatterns_4();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslFeedbackTexture2DArrayMethodsWriteSamplerFeedbackGradParameterPatterns_5 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslFeedbackTexture2DArrayMethodsWriteSamplerFeedbackGradParameterPatterns_5();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslFeedbackTexture2DArrayMethodsWriteSamplerFeedbackLevelParameterPatterns_6 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslFeedbackTexture2DArrayMethodsWriteSamplerFeedbackLevelParameterPatterns_6();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslFeedbackTexture2DArrayMethodsWriteSamplerFeedbackParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslFeedbackTexture2DArrayMethodsWriteSamplerFeedbackParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslFeedbackTexture2DArrayMethodsWriteSamplerFeedbackParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslFeedbackTexture2DArrayMethodsWriteSamplerFeedbackParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslFeedbackTexture2DMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslFeedbackTexture2DMethodsWriteSamplerFeedbackBiasParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslFeedbackTexture2DMethodsWriteSamplerFeedbackBiasParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslFeedbackTexture2DMethodsWriteSamplerFeedbackBiasParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslFeedbackTexture2DMethodsWriteSamplerFeedbackBiasParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslFeedbackTexture2DMethodsWriteSamplerFeedbackGradParameterPatterns_4 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslFeedbackTexture2DMethodsWriteSamplerFeedbackGradParameterPatterns_4();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslFeedbackTexture2DMethodsWriteSamplerFeedbackGradParameterPatterns_5 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslFeedbackTexture2DMethodsWriteSamplerFeedbackGradParameterPatterns_5();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslFeedbackTexture2DMethodsWriteSamplerFeedbackLevelParameterPatterns_6 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslFeedbackTexture2DMethodsWriteSamplerFeedbackLevelParameterPatterns_6();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslFeedbackTexture2DMethodsWriteSamplerFeedbackParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslFeedbackTexture2DMethodsWriteSamplerFeedbackParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslFeedbackTexture2DMethodsWriteSamplerFeedbackParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslFeedbackTexture2DMethodsWriteSamplerFeedbackParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsics : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsabortParameterPatterns_100 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsabortParameterPatterns_100();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsabsParameterPatterns_101 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsabsParameterPatterns_101();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsAcceptHitAndEndSearchParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsAcceptHitAndEndSearchParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsacosParameterPatterns_102 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsacosParameterPatterns_102();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsAddUint64ParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsAddUint64ParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsAllMemoryBarrierParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsAllMemoryBarrierParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsAllMemoryBarrierWithGroupSyncParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsAllMemoryBarrierWithGroupSyncParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsAllocateRayQueryParameterPatterns_4 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsAllocateRayQueryParameterPatterns_4();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsallParameterPatterns_103 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsallParameterPatterns_103();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsanyParameterPatterns_104 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsanyParameterPatterns_104();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsasdoubleParameterPatterns_105 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsasdoubleParameterPatterns_105();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsasfloat16ParameterPatterns_107 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsasfloat16ParameterPatterns_107();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsasfloatParameterPatterns_106 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsasfloatParameterPatterns_106();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsasinParameterPatterns_108 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsasinParameterPatterns_108();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsasint16ParameterPatterns_110 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsasint16ParameterPatterns_110();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsasintParameterPatterns_109 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsasintParameterPatterns_109();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsasuint16ParameterPatterns_113 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsasuint16ParameterPatterns_113();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsasuintParameterPatterns_111 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsasuintParameterPatterns_111();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsasuintParameterPatterns_112 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsasuintParameterPatterns_112();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsatan2ParameterPatterns_115 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsatan2ParameterPatterns_115();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsatanParameterPatterns_114 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsatanParameterPatterns_114();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsCallShaderParameterPatterns_5 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsCallShaderParameterPatterns_5();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsceilParameterPatterns_116 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsceilParameterPatterns_116();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsCheckAccessFullyMappedParameterPatterns_6 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsCheckAccessFullyMappedParameterPatterns_6();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsclampParameterPatterns_117 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsclampParameterPatterns_117();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsclipParameterPatterns_118 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsclipParameterPatterns_118();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicscoshParameterPatterns_120 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicscoshParameterPatterns_120();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicscosParameterPatterns_119 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicscosParameterPatterns_119();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicscountbitsParameterPatterns_121 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicscountbitsParameterPatterns_121();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicscrossParameterPatterns_122 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicscrossParameterPatterns_122();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsD3DCOLORtoUBYTE4ParameterPatterns_7 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsD3DCOLORtoUBYTE4ParameterPatterns_7();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsddx_coarseParameterPatterns_124 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsddx_coarseParameterPatterns_124();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsddx_fineParameterPatterns_125 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsddx_fineParameterPatterns_125();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsddxParameterPatterns_123 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsddxParameterPatterns_123();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsddy_coarseParameterPatterns_127 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsddy_coarseParameterPatterns_127();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsddy_fineParameterPatterns_128 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsddy_fineParameterPatterns_128();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsddyParameterPatterns_126 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsddyParameterPatterns_126();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsdegreesParameterPatterns_129 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsdegreesParameterPatterns_129();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsdeterminantParameterPatterns_130 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsdeterminantParameterPatterns_130();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsDeviceMemoryBarrierParameterPatterns_8 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsDeviceMemoryBarrierParameterPatterns_8();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsDeviceMemoryBarrierWithGroupSyncParameterPatterns_9 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsDeviceMemoryBarrierWithGroupSyncParameterPatterns_9();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsDispatchMeshParameterPatterns_10 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsDispatchMeshParameterPatterns_10();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsDispatchRaysDimensionsParameterPatterns_11 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsDispatchRaysDimensionsParameterPatterns_11();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsDispatchRaysIndexParameterPatterns_12 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsDispatchRaysIndexParameterPatterns_12();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsdistanceParameterPatterns_131 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsdistanceParameterPatterns_131();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsdot2addParameterPatterns_133 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsdot2addParameterPatterns_133();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsdot4add_i8packedParameterPatterns_134 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsdot4add_i8packedParameterPatterns_134();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsdot4add_u8packedParameterPatterns_135 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsdot4add_u8packedParameterPatterns_135();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsdotParameterPatterns_132 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsdotParameterPatterns_132();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsdstParameterPatterns_136 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsdstParameterPatterns_136();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsEvaluateAttributeAtSampleParameterPatterns_13 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsEvaluateAttributeAtSampleParameterPatterns_13();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsEvaluateAttributeCentroidParameterPatterns_14 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsEvaluateAttributeCentroidParameterPatterns_14();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsEvaluateAttributeSnappedParameterPatterns_15 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsEvaluateAttributeSnappedParameterPatterns_15();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsexp2ParameterPatterns_138 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsexp2ParameterPatterns_138();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsexpParameterPatterns_137 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsexpParameterPatterns_137();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsf16tof32ParameterPatterns_139 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsf16tof32ParameterPatterns_139();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsf32tof16ParameterPatterns_140 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsf32tof16ParameterPatterns_140();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsfaceforwardParameterPatterns_141 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsfaceforwardParameterPatterns_141();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsfirstbithighParameterPatterns_142 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsfirstbithighParameterPatterns_142();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsfirstbitlowParameterPatterns_143 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsfirstbitlowParameterPatterns_143();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsfloorParameterPatterns_144 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsfloorParameterPatterns_144();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsfmaParameterPatterns_145 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsfmaParameterPatterns_145();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsfmodParameterPatterns_146 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsfmodParameterPatterns_146();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsfracParameterPatterns_147 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsfracParameterPatterns_147();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsfrexpParameterPatterns_148 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsfrexpParameterPatterns_148();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsfwidthParameterPatterns_149 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsfwidthParameterPatterns_149();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsGeometryIndexParameterPatterns_16 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsGeometryIndexParameterPatterns_16();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsGetAttributeAtVertexParameterPatterns_17 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsGetAttributeAtVertexParameterPatterns_17();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsGetRenderTargetSampleCountParameterPatterns_18 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsGetRenderTargetSampleCountParameterPatterns_18();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsGetRenderTargetSamplePositionParameterPatterns_19 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsGetRenderTargetSamplePositionParameterPatterns_19();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsGroupMemoryBarrierParameterPatterns_20 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsGroupMemoryBarrierParameterPatterns_20();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsGroupMemoryBarrierWithGroupSyncParameterPatterns_21 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsGroupMemoryBarrierWithGroupSyncParameterPatterns_21();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsHitKindParameterPatterns_22 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsHitKindParameterPatterns_22();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsIgnoreHitParameterPatterns_23 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsIgnoreHitParameterPatterns_23();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsInstanceIDParameterPatterns_24 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsInstanceIDParameterPatterns_24();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsInstanceIndexParameterPatterns_25 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsInstanceIndexParameterPatterns_25();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsInterlockedAddParameterPatterns_26 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsInterlockedAddParameterPatterns_26();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsInterlockedAddParameterPatterns_27 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsInterlockedAddParameterPatterns_27();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsInterlockedAndParameterPatterns_28 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsInterlockedAndParameterPatterns_28();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsInterlockedAndParameterPatterns_29 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsInterlockedAndParameterPatterns_29();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsInterlockedCompareExchangeParameterPatterns_30 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsInterlockedCompareExchangeParameterPatterns_30();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsInterlockedCompareStoreParameterPatterns_31 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsInterlockedCompareStoreParameterPatterns_31();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsInterlockedExchangeParameterPatterns_32 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsInterlockedExchangeParameterPatterns_32();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsInterlockedMaxParameterPatterns_33 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsInterlockedMaxParameterPatterns_33();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsInterlockedMaxParameterPatterns_34 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsInterlockedMaxParameterPatterns_34();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsInterlockedMinParameterPatterns_35 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsInterlockedMinParameterPatterns_35();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsInterlockedMinParameterPatterns_36 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsInterlockedMinParameterPatterns_36();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsInterlockedOrParameterPatterns_37 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsInterlockedOrParameterPatterns_37();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsInterlockedOrParameterPatterns_38 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsInterlockedOrParameterPatterns_38();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsInterlockedXorParameterPatterns_39 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsInterlockedXorParameterPatterns_39();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsInterlockedXorParameterPatterns_40 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsInterlockedXorParameterPatterns_40();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsisfiniteParameterPatterns_150 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsisfiniteParameterPatterns_150();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsisinfParameterPatterns_151 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsisinfParameterPatterns_151();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsisnanParameterPatterns_152 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsisnanParameterPatterns_152();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsldexpParameterPatterns_153 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsldexpParameterPatterns_153();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicslengthParameterPatterns_154 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicslengthParameterPatterns_154();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicslerpParameterPatterns_155 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicslerpParameterPatterns_155();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicslitParameterPatterns_156 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicslitParameterPatterns_156();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicslog10ParameterPatterns_158 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicslog10ParameterPatterns_158();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicslog2ParameterPatterns_159 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicslog2ParameterPatterns_159();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicslogParameterPatterns_157 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicslogParameterPatterns_157();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsmadParameterPatterns_160 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsmadParameterPatterns_160();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsmaxParameterPatterns_161 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsmaxParameterPatterns_161();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsminParameterPatterns_162 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsminParameterPatterns_162();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsmodfParameterPatterns_163 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsmodfParameterPatterns_163();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsmsad4ParameterPatterns_164 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsmsad4ParameterPatterns_164();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsmulParameterPatterns_165 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsmulParameterPatterns_165();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsmulParameterPatterns_166 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsmulParameterPatterns_166();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsmulParameterPatterns_167 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsmulParameterPatterns_167();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsmulParameterPatterns_168 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsmulParameterPatterns_168();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsmulParameterPatterns_169 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsmulParameterPatterns_169();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsmulParameterPatterns_170 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsmulParameterPatterns_170();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsmulParameterPatterns_171 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsmulParameterPatterns_171();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsmulParameterPatterns_172 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsmulParameterPatterns_172();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsmulParameterPatterns_173 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsmulParameterPatterns_173();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsNonUniformResourceIndexParameterPatterns_41 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsNonUniformResourceIndexParameterPatterns_41();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsnormalizeParameterPatterns_174 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsnormalizeParameterPatterns_174();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsObjectRayDirectionParameterPatterns_42 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsObjectRayDirectionParameterPatterns_42();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsObjectRayOriginParameterPatterns_43 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsObjectRayOriginParameterPatterns_43();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsObjectToWorld3x4ParameterPatterns_45 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsObjectToWorld3x4ParameterPatterns_45();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsObjectToWorld4x3ParameterPatterns_46 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsObjectToWorld4x3ParameterPatterns_46();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsObjectToWorldParameterPatterns_44 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsObjectToWorldParameterPatterns_44();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicspowParameterPatterns_175 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicspowParameterPatterns_175();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsPrimitiveIndexParameterPatterns_47 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsPrimitiveIndexParameterPatterns_47();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsProcess2DQuadTessFactorsAvgParameterPatterns_48 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsProcess2DQuadTessFactorsAvgParameterPatterns_48();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsProcess2DQuadTessFactorsMaxParameterPatterns_49 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsProcess2DQuadTessFactorsMaxParameterPatterns_49();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsProcess2DQuadTessFactorsMinParameterPatterns_50 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsProcess2DQuadTessFactorsMinParameterPatterns_50();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsProcessIsolineTessFactorsParameterPatterns_51 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsProcessIsolineTessFactorsParameterPatterns_51();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsProcessQuadTessFactorsAvgParameterPatterns_52 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsProcessQuadTessFactorsAvgParameterPatterns_52();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsProcessQuadTessFactorsMaxParameterPatterns_53 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsProcessQuadTessFactorsMaxParameterPatterns_53();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsProcessQuadTessFactorsMinParameterPatterns_54 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsProcessQuadTessFactorsMinParameterPatterns_54();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsProcessTriTessFactorsAvgParameterPatterns_55 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsProcessTriTessFactorsAvgParameterPatterns_55();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsProcessTriTessFactorsMaxParameterPatterns_56 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsProcessTriTessFactorsMaxParameterPatterns_56();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsProcessTriTessFactorsMinParameterPatterns_57 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsProcessTriTessFactorsMinParameterPatterns_57();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsQuadReadAcrossDiagonalParameterPatterns_58 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsQuadReadAcrossDiagonalParameterPatterns_58();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsQuadReadAcrossXParameterPatterns_59 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsQuadReadAcrossXParameterPatterns_59();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsQuadReadAcrossYParameterPatterns_60 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsQuadReadAcrossYParameterPatterns_60();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsQuadReadLaneAtParameterPatterns_61 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsQuadReadLaneAtParameterPatterns_61();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsradiansParameterPatterns_176 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsradiansParameterPatterns_176();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsRayFlagsParameterPatterns_62 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsRayFlagsParameterPatterns_62();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsRayTCurrentParameterPatterns_63 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsRayTCurrentParameterPatterns_63();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsRayTMinParameterPatterns_64 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsRayTMinParameterPatterns_64();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsrcpParameterPatterns_177 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsrcpParameterPatterns_177();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsreflectParameterPatterns_178 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsreflectParameterPatterns_178();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsrefractParameterPatterns_179 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsrefractParameterPatterns_179();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsReportHitParameterPatterns_65 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsReportHitParameterPatterns_65();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsreversebitsParameterPatterns_180 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsreversebitsParameterPatterns_180();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsroundParameterPatterns_181 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsroundParameterPatterns_181();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsrsqrtParameterPatterns_182 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsrsqrtParameterPatterns_182();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicssaturateParameterPatterns_183 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicssaturateParameterPatterns_183();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsSetMeshOutputCountsParameterPatterns_66 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsSetMeshOutputCountsParameterPatterns_66();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicssignParameterPatterns_184 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicssignParameterPatterns_184();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicssincosParameterPatterns_186 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicssincosParameterPatterns_186();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicssinhParameterPatterns_187 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicssinhParameterPatterns_187();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicssinParameterPatterns_185 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicssinParameterPatterns_185();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicssmoothstepParameterPatterns_188 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicssmoothstepParameterPatterns_188();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicssource_markParameterPatterns_189 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicssource_markParameterPatterns_189();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicssqrtParameterPatterns_190 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicssqrtParameterPatterns_190();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsstepParameterPatterns_191 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsstepParameterPatterns_191();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstanhParameterPatterns_193 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstanhParameterPatterns_193();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstanParameterPatterns_192 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstanParameterPatterns_192();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstex1DbiasParameterPatterns_196 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstex1DbiasParameterPatterns_196();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstex1DgradParameterPatterns_197 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstex1DgradParameterPatterns_197();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstex1DlodParameterPatterns_198 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstex1DlodParameterPatterns_198();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstex1DParameterPatterns_194 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstex1DParameterPatterns_194();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstex1DParameterPatterns_195 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstex1DParameterPatterns_195();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstex1DprojParameterPatterns_199 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstex1DprojParameterPatterns_199();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstex2DbiasParameterPatterns_202 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstex2DbiasParameterPatterns_202();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstex2DgradParameterPatterns_203 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstex2DgradParameterPatterns_203();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstex2DlodParameterPatterns_204 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstex2DlodParameterPatterns_204();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstex2DParameterPatterns_200 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstex2DParameterPatterns_200();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstex2DParameterPatterns_201 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstex2DParameterPatterns_201();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstex2DprojParameterPatterns_205 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstex2DprojParameterPatterns_205();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstex3DbiasParameterPatterns_208 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstex3DbiasParameterPatterns_208();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstex3DgradParameterPatterns_209 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstex3DgradParameterPatterns_209();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstex3DlodParameterPatterns_210 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstex3DlodParameterPatterns_210();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstex3DParameterPatterns_206 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstex3DParameterPatterns_206();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstex3DParameterPatterns_207 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstex3DParameterPatterns_207();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstex3DprojParameterPatterns_211 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstex3DprojParameterPatterns_211();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstexCUBEbiasParameterPatterns_214 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstexCUBEbiasParameterPatterns_214();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstexCUBEgradParameterPatterns_215 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstexCUBEgradParameterPatterns_215();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstexCUBElodParameterPatterns_216 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstexCUBElodParameterPatterns_216();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstexCUBEParameterPatterns_212 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstexCUBEParameterPatterns_212();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstexCUBEParameterPatterns_213 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstexCUBEParameterPatterns_213();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstexCUBEprojParameterPatterns_217 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstexCUBEprojParameterPatterns_217();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsTraceRayParameterPatterns_67 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsTraceRayParameterPatterns_67();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstransposeParameterPatterns_218 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstransposeParameterPatterns_218();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicstruncParameterPatterns_219 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicstruncParameterPatterns_219();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveActiveAllEqualParameterPatterns_68 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveActiveAllEqualParameterPatterns_68();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveActiveAllTrueParameterPatterns_69 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveActiveAllTrueParameterPatterns_69();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveActiveAnyTrueParameterPatterns_70 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveActiveAnyTrueParameterPatterns_70();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveActiveBallotParameterPatterns_71 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveActiveBallotParameterPatterns_71();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveActiveBitAndParameterPatterns_72 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveActiveBitAndParameterPatterns_72();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveActiveBitOrParameterPatterns_73 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveActiveBitOrParameterPatterns_73();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveActiveBitXorParameterPatterns_74 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveActiveBitXorParameterPatterns_74();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveActiveCountBitsParameterPatterns_75 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveActiveCountBitsParameterPatterns_75();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveActiveMaxParameterPatterns_76 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveActiveMaxParameterPatterns_76();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveActiveMinParameterPatterns_77 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveActiveMinParameterPatterns_77();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveActiveProductParameterPatterns_78 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveActiveProductParameterPatterns_78();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveActiveSumParameterPatterns_79 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveActiveSumParameterPatterns_79();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveGetLaneCountParameterPatterns_80 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveGetLaneCountParameterPatterns_80();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveGetLaneIndexParameterPatterns_81 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveGetLaneIndexParameterPatterns_81();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveIsFirstLaneParameterPatterns_82 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveIsFirstLaneParameterPatterns_82();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveMatchParameterPatterns_83 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveMatchParameterPatterns_83();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveMultiPrefixBitAndParameterPatterns_84 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveMultiPrefixBitAndParameterPatterns_84();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveMultiPrefixBitOrParameterPatterns_85 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveMultiPrefixBitOrParameterPatterns_85();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveMultiPrefixBitXorParameterPatterns_86 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveMultiPrefixBitXorParameterPatterns_86();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveMultiPrefixCountBitsParameterPatterns_87 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveMultiPrefixCountBitsParameterPatterns_87();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveMultiPrefixProductParameterPatterns_88 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveMultiPrefixProductParameterPatterns_88();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveMultiPrefixSumParameterPatterns_89 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveMultiPrefixSumParameterPatterns_89();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWavePrefixCountBitsParameterPatterns_90 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWavePrefixCountBitsParameterPatterns_90();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWavePrefixProductParameterPatterns_91 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWavePrefixProductParameterPatterns_91();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWavePrefixSumParameterPatterns_92 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWavePrefixSumParameterPatterns_92();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveReadLaneAtParameterPatterns_93 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveReadLaneAtParameterPatterns_93();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWaveReadLaneFirstParameterPatterns_94 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWaveReadLaneFirstParameterPatterns_94();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWorldRayDirectionParameterPatterns_95 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWorldRayDirectionParameterPatterns_95();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWorldRayOriginParameterPatterns_96 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWorldRayOriginParameterPatterns_96();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWorldToObject3x4ParameterPatterns_98 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWorldToObject3x4ParameterPatterns_98();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWorldToObject4x3ParameterPatterns_99 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWorldToObject4x3ParameterPatterns_99();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslIntrinsicsWorldToObjectParameterPatterns_97 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslIntrinsicsWorldToObjectParameterPatterns_97();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslKnownBuiltinFunction : ValueType {
    private static CppList`1<HlslBuiltinFunctionPattern> ourIndex;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourGlobalFunctionsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourStreamMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourTexture1DMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourTexture1DArrayMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourTexture2DMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourTexture2DMSMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourTexture2DArrayMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourTexture2DMSArrayMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourTexture3DMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourTextureCUBEMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourTextureCUBEArrayMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourRayQueryMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourFeedbackTexture2DArrayMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourFeedbackTexture2DMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourConsumeStructuredBufferMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourAppendStructuredBufferMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourRWStructuredBufferMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourStructuredBufferMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourRWByteAddressBufferMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourByteAddressBufferMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourRWBufferMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourRWTexture3DMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourRWTexture2DArrayMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourRWTexture2DMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourRWTexture1DArrayMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourRWTexture1DMethodsRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<int, int> ourBufferMethodsRange;
    private int myIndex;
    public static HlslKnownBuiltinFunction Invalid { get; }
    public static int MarshalSize { get; }
    [IsReadOnlyAttribute]
public HlslBuiltinFunctionPattern& modreq(System.Runtime.InteropServices.InAttribute) Pattern { get; }
    private static HlslKnownBuiltinFunction();
    private HlslKnownBuiltinFunction(int index);
    [MustUseReturnValueAttribute]
private static ValueTuple`2<int, int> AddPatterns(HlslBuiltinFunctionPattern[] patterns);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Symbols.HlslKnownBuiltinFunction/<GetFunctions>d__31")]
private static IEnumerable`1<HlslKnownBuiltinFunction> GetFunctions(ValueTuple`2<int, int> range);
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetGlobalFunctions();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetStreamMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetTexture1DMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetTexture1DArrayMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetTexture2DMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetTexture3DMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetTexture2DMSMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetTexture2DArrayMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetTexture2DMSArrayMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetTextureCUBEMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetTextureCUBEArrayMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetRayQueryMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetFeedbackTexture2DArrayMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetFeedbackTexture2DMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetConsumeStructuredBufferMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetAppendStructuredBufferMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetRWStructuredBufferMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetStructuredBufferMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetRWByteAddressBufferMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetByteAddressBufferMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetRWBufferMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetRWTexture3DMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetRWTexture2DArrayMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetRWTexture2DMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetRWTexture1DArrayMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetRWTexture1DMethods();
    public static IEnumerable`1<HlslKnownBuiltinFunction> GetBufferMethods();
    public static HlslKnownBuiltinFunction get_Invalid();
    public static int get_MarshalSize();
    public HlslBuiltinFunctionPattern& modreq(System.Runtime.InteropServices.InAttribute) get_Pattern();
    public void Marshal(CppBinaryStreamWriter& output);
    public static HlslKnownBuiltinFunction Unmarshal(CppBinaryStreamReader& input);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.HlslLegalIntrinsicCompTypes : Enum {
    public byte value__;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_VOID;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_BOOL;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_INT;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_UINT;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_ANY_INT;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_ANY_INT32;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_UINT_ONLY;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_FLOAT;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_ANY_FLOAT;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_FLOAT_LIKE;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_FLOAT_DOUBLE;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_DOUBLE;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_DOUBLE_ONLY;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_NUMERIC;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_NUMERIC32;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_NUMERIC32_ONLY;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_ANY;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_SAMPLER1D;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_SAMPLER2D;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_SAMPLER3D;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_SAMPLERCUBE;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_SAMPLERCMP;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_SAMPLER;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_STRING;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_WAVE;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_UINT64;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_FLOAT16;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_INT16;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_UINT16;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_NUMERIC16_ONLY;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_RAYDESC;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_ACCELERATION_STRUCT;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_USER_DEFINED_TYPE;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_TEXTURE2D;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_TEXTURE2DARRAY;
    public static HlslLegalIntrinsicCompTypes COMP_TYPE_COUNT;
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.HlslLegalIntrinsicTemplates : Enum {
    public byte value__;
    public static HlslLegalIntrinsicTemplates TEMPLATE_VOID;
    public static HlslLegalIntrinsicTemplates TEMPLATE_SCALAR;
    public static HlslLegalIntrinsicTemplates TEMPLATE_VECTOR;
    public static HlslLegalIntrinsicTemplates TEMPLATE_MATRIX;
    public static HlslLegalIntrinsicTemplates TEMPLATE_ANY;
    public static HlslLegalIntrinsicTemplates TEMPLATE_OBJECT;
    public static HlslLegalIntrinsicTemplates TEMPLATE_COUNT;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslMatrixSpecifierBuilder : ValueType {
    private ICppResolvedTypeFactory myTypeFactory;
    private ICppFileResolveEntitiesCache myResolveCache;
    private CppViewPos myViewPos;
    private CppQualType myType;
    private MatrixKind myKind;
    private CppQualType myComponentType;
    private ICppExpression myFirstDimension;
    private ICppExpression mySecondDimension;
    public HlslMatrixSpecifierBuilder(ICppBuilder parent);
    public void LearnKeyword(TokenNodeType tt);
    public void LearnComponentType(CppQualType componentType);
    public void LearnFirstDimension(ICppExpression e);
    public void LearnSecondDimension(ICppExpression e);
    public void Build();
    public void BuildEmptySpecifier();
    public CppQualType GetBuiltType();
    public static CppQualType ComputeType(MatrixKind kind, CppQualType resolvedComponentType, ICppResolvedExpression firstDimensionExpr, ICppResolvedExpression secondDimensionExpr, CppTypeContext& tc);
    public static CppQualType ComputeEmptyType(MatrixKind kind);
    private static byte EvaluateDimensionValue(ICppResolvedExpression e, CppExpressionEvaluator evaluator);
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.HlslObjectKind : Enum {
    public int value__;
    public static HlslObjectKind INVALID;
    public static HlslObjectKind VOID;
    public static HlslObjectKind BASIC;
    public static HlslObjectKind COMPOUND;
    public static HlslObjectKind INTERFACE;
    public static HlslObjectKind POINTER;
    public static HlslObjectKind OBJECT;
    public static HlslObjectKind ARRAY;
    public static HlslObjectKind MATRIX;
    public static HlslObjectKind VECTOR;
    public static HlslObjectKind QUALIFIER;
    public static HlslObjectKind INNER_OBJ;
    public static HlslObjectKind STRING;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsAbortParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsAbortParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCandidateGeometryIndexParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCandidateGeometryIndexParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCandidateInstanceContributionToHitGroupIndexParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCandidateInstanceContributionToHitGroupIndexParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCandidateInstanceIDParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCandidateInstanceIDParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCandidateInstanceIndexParameterPatterns_4 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCandidateInstanceIndexParameterPatterns_4();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCandidateObjectRayDirectionParameterPatterns_5 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCandidateObjectRayDirectionParameterPatterns_5();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCandidateObjectRayOriginParameterPatterns_6 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCandidateObjectRayOriginParameterPatterns_6();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCandidateObjectToWorld3x4ParameterPatterns_7 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCandidateObjectToWorld3x4ParameterPatterns_7();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCandidateObjectToWorld4x3ParameterPatterns_8 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCandidateObjectToWorld4x3ParameterPatterns_8();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCandidatePrimitiveIndexParameterPatterns_9 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCandidatePrimitiveIndexParameterPatterns_9();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCandidateProceduralPrimitiveNonOpaqueParameterPatterns_10 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCandidateProceduralPrimitiveNonOpaqueParameterPatterns_10();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCandidateTriangleBarycentricsParameterPatterns_11 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCandidateTriangleBarycentricsParameterPatterns_11();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCandidateTriangleFrontFaceParameterPatterns_12 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCandidateTriangleFrontFaceParameterPatterns_12();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCandidateTriangleRayTParameterPatterns_13 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCandidateTriangleRayTParameterPatterns_13();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCandidateTypeParameterPatterns_14 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCandidateTypeParameterPatterns_14();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCandidateWorldToObject3x4ParameterPatterns_15 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCandidateWorldToObject3x4ParameterPatterns_15();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCandidateWorldToObject4x3ParameterPatterns_16 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCandidateWorldToObject4x3ParameterPatterns_16();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCommitNonOpaqueTriangleHitParameterPatterns_17 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCommitNonOpaqueTriangleHitParameterPatterns_17();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCommitProceduralPrimitiveHitParameterPatterns_18 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCommitProceduralPrimitiveHitParameterPatterns_18();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCommittedGeometryIndexParameterPatterns_19 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCommittedGeometryIndexParameterPatterns_19();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCommittedInstanceContributionToHitGroupIndexParameterPatterns_20 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCommittedInstanceContributionToHitGroupIndexParameterPatterns_20();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCommittedInstanceIDParameterPatterns_21 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCommittedInstanceIDParameterPatterns_21();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCommittedInstanceIndexParameterPatterns_22 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCommittedInstanceIndexParameterPatterns_22();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCommittedObjectRayDirectionParameterPatterns_23 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCommittedObjectRayDirectionParameterPatterns_23();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCommittedObjectRayOriginParameterPatterns_24 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCommittedObjectRayOriginParameterPatterns_24();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCommittedObjectToWorld3x4ParameterPatterns_25 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCommittedObjectToWorld3x4ParameterPatterns_25();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCommittedObjectToWorld4x3ParameterPatterns_26 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCommittedObjectToWorld4x3ParameterPatterns_26();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCommittedPrimitiveIndexParameterPatterns_27 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCommittedPrimitiveIndexParameterPatterns_27();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCommittedRayTParameterPatterns_28 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCommittedRayTParameterPatterns_28();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCommittedStatusParameterPatterns_29 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCommittedStatusParameterPatterns_29();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCommittedTriangleBarycentricsParameterPatterns_30 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCommittedTriangleBarycentricsParameterPatterns_30();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCommittedTriangleFrontFaceParameterPatterns_31 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCommittedTriangleFrontFaceParameterPatterns_31();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCommittedWorldToObject3x4ParameterPatterns_32 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCommittedWorldToObject3x4ParameterPatterns_32();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsCommittedWorldToObject4x3ParameterPatterns_33 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsCommittedWorldToObject4x3ParameterPatterns_33();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsProceedParameterPatterns_34 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsProceedParameterPatterns_34();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsRayFlagsParameterPatterns_35 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsRayFlagsParameterPatterns_35();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsRayTMinParameterPatterns_36 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsRayTMinParameterPatterns_36();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsTraceRayInlineParameterPatterns_37 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsTraceRayInlineParameterPatterns_37();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsWorldRayDirectionParameterPatterns_38 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsWorldRayDirectionParameterPatterns_38();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRayQueryMethodsWorldRayOriginParameterPatterns_39 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRayQueryMethodsWorldRayOriginParameterPatterns_39();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWBufferMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWBufferMethodsGetDimensionsParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWBufferMethodsGetDimensionsParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWBufferMethodsLoadParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWBufferMethodsLoadParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWBufferMethodsLoadParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWBufferMethodsLoadParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsGetDimensionsParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsGetDimensionsParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsInterlockedAddParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsInterlockedAddParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsInterlockedAddParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsInterlockedAddParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsInterlockedAndParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsInterlockedAndParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsInterlockedAndParameterPatterns_4 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsInterlockedAndParameterPatterns_4();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsInterlockedCompareExchangeParameterPatterns_5 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsInterlockedCompareExchangeParameterPatterns_5();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsInterlockedCompareStoreParameterPatterns_6 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsInterlockedCompareStoreParameterPatterns_6();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsInterlockedExchangeParameterPatterns_7 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsInterlockedExchangeParameterPatterns_7();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsInterlockedMaxParameterPatterns_8 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsInterlockedMaxParameterPatterns_8();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsInterlockedMaxParameterPatterns_9 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsInterlockedMaxParameterPatterns_9();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsInterlockedMinParameterPatterns_10 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsInterlockedMinParameterPatterns_10();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsInterlockedMinParameterPatterns_11 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsInterlockedMinParameterPatterns_11();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsInterlockedOrParameterPatterns_12 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsInterlockedOrParameterPatterns_12();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsInterlockedOrParameterPatterns_13 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsInterlockedOrParameterPatterns_13();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsInterlockedXorParameterPatterns_14 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsInterlockedXorParameterPatterns_14();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsInterlockedXorParameterPatterns_15 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsInterlockedXorParameterPatterns_15();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsLoad2ParameterPatterns_18 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsLoad2ParameterPatterns_18();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsLoad2ParameterPatterns_19 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsLoad2ParameterPatterns_19();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsLoad3ParameterPatterns_20 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsLoad3ParameterPatterns_20();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsLoad3ParameterPatterns_21 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsLoad3ParameterPatterns_21();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsLoad4ParameterPatterns_22 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsLoad4ParameterPatterns_22();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsLoad4ParameterPatterns_23 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsLoad4ParameterPatterns_23();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsLoadParameterPatterns_16 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsLoadParameterPatterns_16();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsLoadParameterPatterns_17 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsLoadParameterPatterns_17();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsStore2ParameterPatterns_25 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsStore2ParameterPatterns_25();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsStore3ParameterPatterns_26 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsStore3ParameterPatterns_26();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsStore4ParameterPatterns_27 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsStore4ParameterPatterns_27();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWByteAddressBufferMethodsStoreParameterPatterns_24 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWByteAddressBufferMethodsStoreParameterPatterns_24();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWStructuredBufferMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWStructuredBufferMethodsDecrementCounterParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWStructuredBufferMethodsDecrementCounterParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWStructuredBufferMethodsGetDimensionsParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWStructuredBufferMethodsGetDimensionsParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWStructuredBufferMethodsIncrementCounterParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWStructuredBufferMethodsIncrementCounterParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWStructuredBufferMethodsLoadParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWStructuredBufferMethodsLoadParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWStructuredBufferMethodsLoadParameterPatterns_4 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWStructuredBufferMethodsLoadParameterPatterns_4();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture1DArrayMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture1DArrayMethodsGetDimensionsParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture1DArrayMethodsGetDimensionsParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture1DArrayMethodsGetDimensionsParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture1DArrayMethodsGetDimensionsParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture1DArrayMethodsLoadParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture1DArrayMethodsLoadParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture1DArrayMethodsLoadParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture1DArrayMethodsLoadParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture1DMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture1DMethodsGetDimensionsParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture1DMethodsGetDimensionsParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture1DMethodsGetDimensionsParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture1DMethodsGetDimensionsParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture1DMethodsLoadParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture1DMethodsLoadParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture1DMethodsLoadParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture1DMethodsLoadParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture2DArrayMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture2DArrayMethodsGetDimensionsParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture2DArrayMethodsGetDimensionsParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture2DArrayMethodsGetDimensionsParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture2DArrayMethodsGetDimensionsParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture2DArrayMethodsLoadParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture2DArrayMethodsLoadParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture2DArrayMethodsLoadParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture2DArrayMethodsLoadParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture2DMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture2DMethodsGetDimensionsParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture2DMethodsGetDimensionsParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture2DMethodsGetDimensionsParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture2DMethodsGetDimensionsParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture2DMethodsLoadParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture2DMethodsLoadParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture2DMethodsLoadParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture2DMethodsLoadParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture3DMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture3DMethodsGetDimensionsParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture3DMethodsGetDimensionsParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture3DMethodsGetDimensionsParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture3DMethodsGetDimensionsParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture3DMethodsLoadParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture3DMethodsLoadParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslRWTexture3DMethodsLoadParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslRWTexture3DMethodsLoadParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslStreamMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslStreamMethodsAppendParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslStreamMethodsAppendParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslStreamMethodsRestartStripParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslStreamMethodsRestartStripParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslStructuredBufferMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslStructuredBufferMethodsGetDimensionsParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslStructuredBufferMethodsGetDimensionsParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslStructuredBufferMethodsLoadParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslStructuredBufferMethodsLoadParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslStructuredBufferMethodsLoadParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslStructuredBufferMethodsLoadParameterPatterns_2();
}
public enum JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTemplateId : Enum {
    public byte value__;
    public static HlslTemplateId TEMPLATE_RETURN_TYPE;
    public static HlslTemplateId TEMPLATE_FIRST_PARAM;
    public static HlslTemplateId TEMPLATE_SECOND_PARAM;
    public static HlslTemplateId TEMPLATE_THIRD_PARAM;
    public static HlslTemplateId TEMPLATE_FOURTH_PARAM;
    public static HlslTemplateId TEMPLATE_FIFTH_PARAM;
    public static HlslTemplateId TEMPLATE_SIXTH_PARAM;
    public static HlslTemplateId TEMPLATE_SEVENTH_PARAM;
    public static HlslTemplateId TEMPLATE_EIGHTH_PARAM;
    public static HlslTemplateId TEMPLATE_FROM_TYPE;
    public static HlslTemplateId TEMPLATE_FROM_FUNCTION;
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsCalculateLevelOfDetailParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsCalculateLevelOfDetailParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsCalculateLevelOfDetailUnclampedParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsCalculateLevelOfDetailUnclampedParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsGetDimensionsParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsGetDimensionsParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsGetDimensionsParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsGetDimensionsParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsGetDimensionsParameterPatterns_4 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsGetDimensionsParameterPatterns_4();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsGetDimensionsParameterPatterns_5 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsGetDimensionsParameterPatterns_5();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsLoadParameterPatterns_6 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsLoadParameterPatterns_6();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsLoadParameterPatterns_7 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsLoadParameterPatterns_7();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsLoadParameterPatterns_8 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsLoadParameterPatterns_8();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleBiasParameterPatterns_13 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleBiasParameterPatterns_13();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleBiasParameterPatterns_14 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleBiasParameterPatterns_14();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleBiasParameterPatterns_15 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleBiasParameterPatterns_15();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleBiasParameterPatterns_16 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleBiasParameterPatterns_16();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleCmpLevelZeroParameterPatterns_21 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleCmpLevelZeroParameterPatterns_21();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleCmpLevelZeroParameterPatterns_22 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleCmpLevelZeroParameterPatterns_22();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleCmpLevelZeroParameterPatterns_23 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleCmpLevelZeroParameterPatterns_23();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleCmpParameterPatterns_17 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleCmpParameterPatterns_17();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleCmpParameterPatterns_18 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleCmpParameterPatterns_18();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleCmpParameterPatterns_19 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleCmpParameterPatterns_19();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleCmpParameterPatterns_20 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleCmpParameterPatterns_20();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleGradParameterPatterns_24 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleGradParameterPatterns_24();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleGradParameterPatterns_25 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleGradParameterPatterns_25();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleGradParameterPatterns_26 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleGradParameterPatterns_26();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleGradParameterPatterns_27 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleGradParameterPatterns_27();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleLevelParameterPatterns_28 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleLevelParameterPatterns_28();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleLevelParameterPatterns_29 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleLevelParameterPatterns_29();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleLevelParameterPatterns_30 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleLevelParameterPatterns_30();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleParameterPatterns_10 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleParameterPatterns_10();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleParameterPatterns_11 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleParameterPatterns_11();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleParameterPatterns_12 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleParameterPatterns_12();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DArrayMethodsSampleParameterPatterns_9 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DArrayMethodsSampleParameterPatterns_9();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsCalculateLevelOfDetailParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsCalculateLevelOfDetailParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsCalculateLevelOfDetailUnclampedParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsCalculateLevelOfDetailUnclampedParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsGetDimensionsParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsGetDimensionsParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsGetDimensionsParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsGetDimensionsParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsGetDimensionsParameterPatterns_4 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsGetDimensionsParameterPatterns_4();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsGetDimensionsParameterPatterns_5 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsGetDimensionsParameterPatterns_5();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsLoadParameterPatterns_6 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsLoadParameterPatterns_6();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsLoadParameterPatterns_7 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsLoadParameterPatterns_7();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsLoadParameterPatterns_8 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsLoadParameterPatterns_8();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleBiasParameterPatterns_13 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleBiasParameterPatterns_13();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleBiasParameterPatterns_14 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleBiasParameterPatterns_14();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleBiasParameterPatterns_15 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleBiasParameterPatterns_15();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleBiasParameterPatterns_16 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleBiasParameterPatterns_16();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleCmpLevelZeroParameterPatterns_21 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleCmpLevelZeroParameterPatterns_21();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleCmpLevelZeroParameterPatterns_22 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleCmpLevelZeroParameterPatterns_22();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleCmpLevelZeroParameterPatterns_23 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleCmpLevelZeroParameterPatterns_23();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleCmpParameterPatterns_17 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleCmpParameterPatterns_17();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleCmpParameterPatterns_18 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleCmpParameterPatterns_18();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleCmpParameterPatterns_19 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleCmpParameterPatterns_19();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleCmpParameterPatterns_20 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleCmpParameterPatterns_20();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleGradParameterPatterns_24 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleGradParameterPatterns_24();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleGradParameterPatterns_25 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleGradParameterPatterns_25();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleGradParameterPatterns_26 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleGradParameterPatterns_26();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleGradParameterPatterns_27 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleGradParameterPatterns_27();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleLevelParameterPatterns_28 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleLevelParameterPatterns_28();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleLevelParameterPatterns_29 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleLevelParameterPatterns_29();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleLevelParameterPatterns_30 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleLevelParameterPatterns_30();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleParameterPatterns_10 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleParameterPatterns_10();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleParameterPatterns_11 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleParameterPatterns_11();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleParameterPatterns_12 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleParameterPatterns_12();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture1DMethodsSampleParameterPatterns_9 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture1DMethodsSampleParameterPatterns_9();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsCalculateLevelOfDetailParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsCalculateLevelOfDetailParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsCalculateLevelOfDetailUnclampedParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsCalculateLevelOfDetailUnclampedParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherAlphaParameterPatterns_5 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherAlphaParameterPatterns_5();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherAlphaParameterPatterns_6 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherAlphaParameterPatterns_6();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherAlphaParameterPatterns_7 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherAlphaParameterPatterns_7();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherAlphaParameterPatterns_8 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherAlphaParameterPatterns_8();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherAlphaParameterPatterns_9 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherAlphaParameterPatterns_9();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherBlueParameterPatterns_10 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherBlueParameterPatterns_10();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherBlueParameterPatterns_11 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherBlueParameterPatterns_11();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherBlueParameterPatterns_12 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherBlueParameterPatterns_12();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherBlueParameterPatterns_13 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherBlueParameterPatterns_13();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherBlueParameterPatterns_14 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherBlueParameterPatterns_14();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpAlphaParameterPatterns_18 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpAlphaParameterPatterns_18();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpAlphaParameterPatterns_19 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpAlphaParameterPatterns_19();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpAlphaParameterPatterns_20 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpAlphaParameterPatterns_20();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpAlphaParameterPatterns_21 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpAlphaParameterPatterns_21();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpAlphaParameterPatterns_22 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpAlphaParameterPatterns_22();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpBlueParameterPatterns_23 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpBlueParameterPatterns_23();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpBlueParameterPatterns_24 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpBlueParameterPatterns_24();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpBlueParameterPatterns_25 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpBlueParameterPatterns_25();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpBlueParameterPatterns_26 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpBlueParameterPatterns_26();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpBlueParameterPatterns_27 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpBlueParameterPatterns_27();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpGreenParameterPatterns_28 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpGreenParameterPatterns_28();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpGreenParameterPatterns_29 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpGreenParameterPatterns_29();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpGreenParameterPatterns_30 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpGreenParameterPatterns_30();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpGreenParameterPatterns_31 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpGreenParameterPatterns_31();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpGreenParameterPatterns_32 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpGreenParameterPatterns_32();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpParameterPatterns_15 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpParameterPatterns_15();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpParameterPatterns_16 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpParameterPatterns_16();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpParameterPatterns_17 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpParameterPatterns_17();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpRedParameterPatterns_33 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpRedParameterPatterns_33();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpRedParameterPatterns_34 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpRedParameterPatterns_34();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpRedParameterPatterns_35 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpRedParameterPatterns_35();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpRedParameterPatterns_36 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpRedParameterPatterns_36();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherCmpRedParameterPatterns_37 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherCmpRedParameterPatterns_37();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherGreenParameterPatterns_38 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherGreenParameterPatterns_38();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherGreenParameterPatterns_39 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherGreenParameterPatterns_39();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherGreenParameterPatterns_40 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherGreenParameterPatterns_40();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherGreenParameterPatterns_41 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherGreenParameterPatterns_41();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherGreenParameterPatterns_42 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherGreenParameterPatterns_42();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherParameterPatterns_4 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherParameterPatterns_4();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherRedParameterPatterns_43 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherRedParameterPatterns_43();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherRedParameterPatterns_44 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherRedParameterPatterns_44();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherRedParameterPatterns_45 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherRedParameterPatterns_45();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherRedParameterPatterns_46 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherRedParameterPatterns_46();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGatherRedParameterPatterns_47 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGatherRedParameterPatterns_47();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGetDimensionsParameterPatterns_48 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGetDimensionsParameterPatterns_48();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGetDimensionsParameterPatterns_49 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGetDimensionsParameterPatterns_49();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGetDimensionsParameterPatterns_50 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGetDimensionsParameterPatterns_50();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsGetDimensionsParameterPatterns_51 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsGetDimensionsParameterPatterns_51();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsLoadParameterPatterns_52 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsLoadParameterPatterns_52();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsLoadParameterPatterns_53 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsLoadParameterPatterns_53();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsLoadParameterPatterns_54 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsLoadParameterPatterns_54();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleBiasParameterPatterns_59 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleBiasParameterPatterns_59();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleBiasParameterPatterns_60 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleBiasParameterPatterns_60();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleBiasParameterPatterns_61 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleBiasParameterPatterns_61();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleBiasParameterPatterns_62 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleBiasParameterPatterns_62();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleCmpLevelZeroParameterPatterns_67 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleCmpLevelZeroParameterPatterns_67();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleCmpLevelZeroParameterPatterns_68 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleCmpLevelZeroParameterPatterns_68();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleCmpLevelZeroParameterPatterns_69 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleCmpLevelZeroParameterPatterns_69();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleCmpParameterPatterns_63 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleCmpParameterPatterns_63();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleCmpParameterPatterns_64 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleCmpParameterPatterns_64();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleCmpParameterPatterns_65 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleCmpParameterPatterns_65();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleCmpParameterPatterns_66 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleCmpParameterPatterns_66();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleGradParameterPatterns_70 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleGradParameterPatterns_70();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleGradParameterPatterns_71 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleGradParameterPatterns_71();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleGradParameterPatterns_72 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleGradParameterPatterns_72();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleGradParameterPatterns_73 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleGradParameterPatterns_73();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleLevelParameterPatterns_74 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleLevelParameterPatterns_74();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleLevelParameterPatterns_75 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleLevelParameterPatterns_75();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleLevelParameterPatterns_76 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleLevelParameterPatterns_76();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleParameterPatterns_55 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleParameterPatterns_55();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleParameterPatterns_56 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleParameterPatterns_56();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleParameterPatterns_57 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleParameterPatterns_57();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMethodsSampleParameterPatterns_58 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMethodsSampleParameterPatterns_58();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMSMethodsGetDimensionsParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMSMethodsGetDimensionsParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMSMethodsGetDimensionsParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMSMethodsGetDimensionsParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMSMethodsGetSamplePositionParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMSMethodsGetSamplePositionParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMSMethodsLoadParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMSMethodsLoadParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMSMethodsLoadParameterPatterns_4 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMSMethodsLoadParameterPatterns_4();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DArrayMSMethodsLoadParameterPatterns_5 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DArrayMSMethodsLoadParameterPatterns_5();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsCalculateLevelOfDetailParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsCalculateLevelOfDetailParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsCalculateLevelOfDetailUnclampedParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsCalculateLevelOfDetailUnclampedParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherAlphaParameterPatterns_5 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherAlphaParameterPatterns_5();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherAlphaParameterPatterns_6 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherAlphaParameterPatterns_6();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherAlphaParameterPatterns_7 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherAlphaParameterPatterns_7();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherAlphaParameterPatterns_8 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherAlphaParameterPatterns_8();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherAlphaParameterPatterns_9 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherAlphaParameterPatterns_9();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherBlueParameterPatterns_10 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherBlueParameterPatterns_10();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherBlueParameterPatterns_11 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherBlueParameterPatterns_11();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherBlueParameterPatterns_12 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherBlueParameterPatterns_12();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherBlueParameterPatterns_13 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherBlueParameterPatterns_13();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherBlueParameterPatterns_14 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherBlueParameterPatterns_14();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpAlphaParameterPatterns_18 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpAlphaParameterPatterns_18();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpAlphaParameterPatterns_19 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpAlphaParameterPatterns_19();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpAlphaParameterPatterns_20 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpAlphaParameterPatterns_20();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpAlphaParameterPatterns_21 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpAlphaParameterPatterns_21();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpAlphaParameterPatterns_22 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpAlphaParameterPatterns_22();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpBlueParameterPatterns_23 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpBlueParameterPatterns_23();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpBlueParameterPatterns_24 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpBlueParameterPatterns_24();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpBlueParameterPatterns_25 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpBlueParameterPatterns_25();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpBlueParameterPatterns_26 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpBlueParameterPatterns_26();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpBlueParameterPatterns_27 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpBlueParameterPatterns_27();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpGreenParameterPatterns_28 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpGreenParameterPatterns_28();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpGreenParameterPatterns_29 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpGreenParameterPatterns_29();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpGreenParameterPatterns_30 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpGreenParameterPatterns_30();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpGreenParameterPatterns_31 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpGreenParameterPatterns_31();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpGreenParameterPatterns_32 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpGreenParameterPatterns_32();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpParameterPatterns_15 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpParameterPatterns_15();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpParameterPatterns_16 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpParameterPatterns_16();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpParameterPatterns_17 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpParameterPatterns_17();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpRedParameterPatterns_33 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpRedParameterPatterns_33();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpRedParameterPatterns_34 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpRedParameterPatterns_34();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpRedParameterPatterns_35 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpRedParameterPatterns_35();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpRedParameterPatterns_36 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpRedParameterPatterns_36();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherCmpRedParameterPatterns_37 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherCmpRedParameterPatterns_37();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherGreenParameterPatterns_38 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherGreenParameterPatterns_38();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherGreenParameterPatterns_39 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherGreenParameterPatterns_39();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherGreenParameterPatterns_40 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherGreenParameterPatterns_40();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherGreenParameterPatterns_41 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherGreenParameterPatterns_41();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherGreenParameterPatterns_42 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherGreenParameterPatterns_42();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherParameterPatterns_4 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherParameterPatterns_4();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherRedParameterPatterns_43 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherRedParameterPatterns_43();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherRedParameterPatterns_44 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherRedParameterPatterns_44();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherRedParameterPatterns_45 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherRedParameterPatterns_45();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherRedParameterPatterns_46 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherRedParameterPatterns_46();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGatherRedParameterPatterns_47 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGatherRedParameterPatterns_47();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGetDimensionsParameterPatterns_48 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGetDimensionsParameterPatterns_48();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGetDimensionsParameterPatterns_49 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGetDimensionsParameterPatterns_49();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGetDimensionsParameterPatterns_50 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGetDimensionsParameterPatterns_50();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsGetDimensionsParameterPatterns_51 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsGetDimensionsParameterPatterns_51();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsLoadParameterPatterns_52 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsLoadParameterPatterns_52();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsLoadParameterPatterns_53 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsLoadParameterPatterns_53();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsLoadParameterPatterns_54 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsLoadParameterPatterns_54();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleBiasParameterPatterns_59 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleBiasParameterPatterns_59();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleBiasParameterPatterns_60 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleBiasParameterPatterns_60();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleBiasParameterPatterns_61 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleBiasParameterPatterns_61();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleBiasParameterPatterns_62 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleBiasParameterPatterns_62();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleCmpLevelZeroParameterPatterns_67 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleCmpLevelZeroParameterPatterns_67();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleCmpLevelZeroParameterPatterns_68 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleCmpLevelZeroParameterPatterns_68();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleCmpLevelZeroParameterPatterns_69 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleCmpLevelZeroParameterPatterns_69();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleCmpParameterPatterns_63 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleCmpParameterPatterns_63();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleCmpParameterPatterns_64 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleCmpParameterPatterns_64();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleCmpParameterPatterns_65 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleCmpParameterPatterns_65();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleCmpParameterPatterns_66 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleCmpParameterPatterns_66();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleGradParameterPatterns_70 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleGradParameterPatterns_70();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleGradParameterPatterns_71 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleGradParameterPatterns_71();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleGradParameterPatterns_72 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleGradParameterPatterns_72();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleGradParameterPatterns_73 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleGradParameterPatterns_73();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleLevelParameterPatterns_74 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleLevelParameterPatterns_74();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleLevelParameterPatterns_75 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleLevelParameterPatterns_75();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleLevelParameterPatterns_76 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleLevelParameterPatterns_76();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleParameterPatterns_55 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleParameterPatterns_55();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleParameterPatterns_56 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleParameterPatterns_56();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleParameterPatterns_57 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleParameterPatterns_57();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMethodsSampleParameterPatterns_58 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMethodsSampleParameterPatterns_58();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMSArrayMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMSMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMSMethodsGetDimensionsParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMSMethodsGetDimensionsParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMSMethodsGetDimensionsParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMSMethodsGetDimensionsParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMSMethodsGetSamplePositionParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMSMethodsGetSamplePositionParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMSMethodsLoadParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMSMethodsLoadParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMSMethodsLoadParameterPatterns_4 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMSMethodsLoadParameterPatterns_4();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture2DMSMethodsLoadParameterPatterns_5 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture2DMSMethodsLoadParameterPatterns_5();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsCalculateLevelOfDetailParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsCalculateLevelOfDetailParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsCalculateLevelOfDetailUnclampedParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsCalculateLevelOfDetailUnclampedParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsGetDimensionsParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsGetDimensionsParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsGetDimensionsParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsGetDimensionsParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsGetDimensionsParameterPatterns_4 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsGetDimensionsParameterPatterns_4();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsGetDimensionsParameterPatterns_5 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsGetDimensionsParameterPatterns_5();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsLoadParameterPatterns_6 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsLoadParameterPatterns_6();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsLoadParameterPatterns_7 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsLoadParameterPatterns_7();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsLoadParameterPatterns_8 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsLoadParameterPatterns_8();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsSampleBiasParameterPatterns_13 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsSampleBiasParameterPatterns_13();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsSampleBiasParameterPatterns_14 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsSampleBiasParameterPatterns_14();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsSampleBiasParameterPatterns_15 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsSampleBiasParameterPatterns_15();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsSampleBiasParameterPatterns_16 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsSampleBiasParameterPatterns_16();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsSampleGradParameterPatterns_17 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsSampleGradParameterPatterns_17();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsSampleGradParameterPatterns_18 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsSampleGradParameterPatterns_18();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsSampleGradParameterPatterns_19 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsSampleGradParameterPatterns_19();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsSampleGradParameterPatterns_20 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsSampleGradParameterPatterns_20();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsSampleLevelParameterPatterns_21 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsSampleLevelParameterPatterns_21();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsSampleLevelParameterPatterns_22 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsSampleLevelParameterPatterns_22();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsSampleLevelParameterPatterns_23 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsSampleLevelParameterPatterns_23();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsSampleParameterPatterns_10 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsSampleParameterPatterns_10();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsSampleParameterPatterns_11 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsSampleParameterPatterns_11();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsSampleParameterPatterns_12 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsSampleParameterPatterns_12();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTexture3DMethodsSampleParameterPatterns_9 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTexture3DMethodsSampleParameterPatterns_9();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsCalculateLevelOfDetailParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsCalculateLevelOfDetailParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsCalculateLevelOfDetailUnclampedParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsCalculateLevelOfDetailUnclampedParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherAlphaParameterPatterns_4 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherAlphaParameterPatterns_4();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherAlphaParameterPatterns_5 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherAlphaParameterPatterns_5();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherBlueParameterPatterns_6 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherBlueParameterPatterns_6();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherBlueParameterPatterns_7 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherBlueParameterPatterns_7();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherCmpAlphaParameterPatterns_10 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherCmpAlphaParameterPatterns_10();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherCmpAlphaParameterPatterns_11 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherCmpAlphaParameterPatterns_11();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherCmpBlueParameterPatterns_12 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherCmpBlueParameterPatterns_12();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherCmpBlueParameterPatterns_13 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherCmpBlueParameterPatterns_13();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherCmpGreenParameterPatterns_14 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherCmpGreenParameterPatterns_14();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherCmpGreenParameterPatterns_15 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherCmpGreenParameterPatterns_15();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherCmpParameterPatterns_8 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherCmpParameterPatterns_8();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherCmpParameterPatterns_9 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherCmpParameterPatterns_9();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherCmpRedParameterPatterns_16 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherCmpRedParameterPatterns_16();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherCmpRedParameterPatterns_17 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherCmpRedParameterPatterns_17();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherGreenParameterPatterns_18 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherGreenParameterPatterns_18();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherGreenParameterPatterns_19 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherGreenParameterPatterns_19();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherRedParameterPatterns_20 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherRedParameterPatterns_20();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGatherRedParameterPatterns_21 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGatherRedParameterPatterns_21();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGetDimensionsParameterPatterns_22 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGetDimensionsParameterPatterns_22();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGetDimensionsParameterPatterns_23 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGetDimensionsParameterPatterns_23();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGetDimensionsParameterPatterns_24 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGetDimensionsParameterPatterns_24();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsGetDimensionsParameterPatterns_25 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsGetDimensionsParameterPatterns_25();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsSampleBiasParameterPatterns_29 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsSampleBiasParameterPatterns_29();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsSampleBiasParameterPatterns_30 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsSampleBiasParameterPatterns_30();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsSampleBiasParameterPatterns_31 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsSampleBiasParameterPatterns_31();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsSampleCmpLevelZeroParameterPatterns_35 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsSampleCmpLevelZeroParameterPatterns_35();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsSampleCmpLevelZeroParameterPatterns_36 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsSampleCmpLevelZeroParameterPatterns_36();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsSampleCmpParameterPatterns_32 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsSampleCmpParameterPatterns_32();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsSampleCmpParameterPatterns_33 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsSampleCmpParameterPatterns_33();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsSampleCmpParameterPatterns_34 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsSampleCmpParameterPatterns_34();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsSampleGradParameterPatterns_37 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsSampleGradParameterPatterns_37();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsSampleGradParameterPatterns_38 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsSampleGradParameterPatterns_38();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsSampleGradParameterPatterns_39 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsSampleGradParameterPatterns_39();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsSampleLevelParameterPatterns_40 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsSampleLevelParameterPatterns_40();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsSampleLevelParameterPatterns_41 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsSampleLevelParameterPatterns_41();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsSampleParameterPatterns_26 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsSampleParameterPatterns_26();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsSampleParameterPatterns_27 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsSampleParameterPatterns_27();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEArrayMethodsSampleParameterPatterns_28 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEArrayMethodsSampleParameterPatterns_28();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethods : object {
    public static HlslBuiltinFunctionPattern[] GetIntrinsics();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsCalculateLevelOfDetailParameterPatterns_0 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsCalculateLevelOfDetailParameterPatterns_0();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsCalculateLevelOfDetailUnclampedParameterPatterns_1 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsCalculateLevelOfDetailUnclampedParameterPatterns_1();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherAlphaParameterPatterns_4 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherAlphaParameterPatterns_4();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherAlphaParameterPatterns_5 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherAlphaParameterPatterns_5();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherBlueParameterPatterns_6 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherBlueParameterPatterns_6();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherBlueParameterPatterns_7 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherBlueParameterPatterns_7();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherCmpAlphaParameterPatterns_10 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherCmpAlphaParameterPatterns_10();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherCmpAlphaParameterPatterns_11 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherCmpAlphaParameterPatterns_11();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherCmpBlueParameterPatterns_12 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherCmpBlueParameterPatterns_12();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherCmpBlueParameterPatterns_13 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherCmpBlueParameterPatterns_13();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherCmpGreenParameterPatterns_14 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherCmpGreenParameterPatterns_14();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherCmpGreenParameterPatterns_15 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherCmpGreenParameterPatterns_15();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherCmpParameterPatterns_8 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherCmpParameterPatterns_8();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherCmpParameterPatterns_9 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherCmpParameterPatterns_9();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherCmpRedParameterPatterns_16 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherCmpRedParameterPatterns_16();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherCmpRedParameterPatterns_17 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherCmpRedParameterPatterns_17();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherGreenParameterPatterns_18 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherGreenParameterPatterns_18();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherGreenParameterPatterns_19 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherGreenParameterPatterns_19();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherParameterPatterns_2 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherParameterPatterns_2();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherParameterPatterns_3 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherParameterPatterns_3();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherRedParameterPatterns_20 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherRedParameterPatterns_20();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGatherRedParameterPatterns_21 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGatherRedParameterPatterns_21();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGetDimensionsParameterPatterns_22 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGetDimensionsParameterPatterns_22();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGetDimensionsParameterPatterns_23 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGetDimensionsParameterPatterns_23();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGetDimensionsParameterPatterns_24 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGetDimensionsParameterPatterns_24();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsGetDimensionsParameterPatterns_25 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsGetDimensionsParameterPatterns_25();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsSampleBiasParameterPatterns_29 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsSampleBiasParameterPatterns_29();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsSampleBiasParameterPatterns_30 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsSampleBiasParameterPatterns_30();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsSampleBiasParameterPatterns_31 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsSampleBiasParameterPatterns_31();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsSampleCmpLevelZeroParameterPatterns_35 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsSampleCmpLevelZeroParameterPatterns_35();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsSampleCmpLevelZeroParameterPatterns_36 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsSampleCmpLevelZeroParameterPatterns_36();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsSampleCmpParameterPatterns_32 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsSampleCmpParameterPatterns_32();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsSampleCmpParameterPatterns_33 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsSampleCmpParameterPatterns_33();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsSampleCmpParameterPatterns_34 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsSampleCmpParameterPatterns_34();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsSampleGradParameterPatterns_37 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsSampleGradParameterPatterns_37();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsSampleGradParameterPatterns_38 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsSampleGradParameterPatterns_38();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsSampleGradParameterPatterns_39 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsSampleGradParameterPatterns_39();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsSampleLevelParameterPatterns_40 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsSampleLevelParameterPatterns_40();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsSampleLevelParameterPatterns_41 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsSampleLevelParameterPatterns_41();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsSampleParameterPatterns_26 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsSampleParameterPatterns_26();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsSampleParameterPatterns_27 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsSampleParameterPatterns_27();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.HlslTextureCUBEMethodsSampleParameterPatterns_28 : object {
    public static HlslBuiltinFunctionParameterPattern[] GENERATED;
    private static HlslTextureCUBEMethodsSampleParameterPatterns_28();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppAccessibilityProvider {
    public abstract virtual CppAccessibility GetAccessibility();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppAnchor`1 {
    public int AnchorLocation { get; }
    public TAnchor Next { get; }
    public abstract virtual int get_AnchorLocation();
    public abstract virtual TAnchor get_Next();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppAnyDependentResolveEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppAnyExpressionTemplateParameterSymbol {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppAnyLinkageEntityOrTemplateParameter {
    public abstract virtual string Present(ICppPresenter presenter);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppAnyTemplateTemplateParameterSymbol {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppAttribute {
    public abstract virtual CppAttributeName GetName();
    public abstract virtual bool Equals(ICppAttribute obj, CppEqualityComparer comparer);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppAttributeArgumentsBuilder {
    public abstract virtual bool LearnNoArgs(ICppAttributeArgumentsParser parser);
    public abstract virtual bool LearnArgs(ICppAttributeArgumentsParser parser);
    public abstract virtual ICppAttribute GetUnresolvedAttribute(CppAttributeName name);
    public abstract virtual ICppAttribute GetReplacedAttribute(CppAttributeName name);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppAttributeArgumentsParser {
    public abstract virtual bool HasMoreArgs();
    public abstract virtual bool ParseStringLiteral(CppStringLiteralValue& value);
    public abstract virtual bool ParseExpression(ICppExpression& unresolved, ICppExpression& replaced);
    public abstract virtual bool ParseIdentifier(String& identifier);
    public abstract virtual bool Error(string s);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppAttributeListBuilder {
    public abstract virtual void LearnAttribute(CppAttributeName name, ICppAttributeArgumentsBuilder builder);
    public abstract virtual void LearnAttribute(ICppAttribute unresolved, ICppAttribute replaced);
    public abstract virtual void LearnAttributeConstant(ICppAttribute _);
    public abstract virtual void Merge(ICppAttributeListBuilder _);
    public abstract virtual void Merge(CppAttributeList unresolved, CppAttributeList replaced);
    public abstract virtual CppAttributeList GetUnresolvedList();
    public abstract virtual CppAttributeList GetReplacedList();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppBaseQualifiedReferenceBuilder {
    public abstract virtual BaseQualifiedReference CreateReferenceFromText(string text, ICppCompositeNode context, CppElementFactory factory);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppBuilder {
    public ICppScopeResolveEntity ResolveEntity { get; }
    public ICppBuilder Parent { get; }
    public abstract virtual ICppScopeResolveEntity get_ResolveEntity();
    public abstract virtual ICppBuilder get_Parent();
    public abstract virtual void AddChild(CppParserSymbol s);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppBuilderWithAccessibility {
    public abstract virtual void LearnAccessibility(CppAccessibility accessibility);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppBuilderWithOwner {
    public abstract virtual CppFileSymbolsCache GetOwner();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppBuilderWithViewPosByResolveEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppBuiltinOffsetOfBuilder`1 {
    public abstract virtual void LearnTypeArgument(ICppDeclarationBuilder declBuilder);
    public abstract virtual void LearnMemberDesignator(TQualifiedNameBuilder& nameBuilder);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppC11GenericExpressionBuilder`1 {
    public abstract virtual TExpressionBuilder CreateExpressionBuilder();
    public abstract virtual ICppDeclarationBuilder CreateInnerDeclarationBuilder(ICppBuilder parent);
    public abstract virtual void LearnControllingExpression(TExpressionBuilder& builder);
    public abstract virtual void LearnDefault();
    public abstract virtual void LearnType(ICppDeclarationBuilder builder);
    public abstract virtual void LearnExpression(TExpressionBuilder& builder);
    public abstract virtual void ApplyClause();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppCallingConventionBuilder {
    public abstract virtual void LearnCallingConvention(CppCallingConvention cc);
    public abstract virtual CppCallingConvention GetCallingConvention();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassBaseClauseBuilder {
    public abstract virtual void LearnSpecifier(TokenNodeType tt);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassBaseClauseBuilder`1 {
    public abstract virtual void BaseType(TQualifiedNameBuilder& name, bool expansion);
    public abstract virtual TQualifiedNameBuilder CreateQualifiedNameBuilder();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassLandingPad {
    public abstract virtual ICppParserSymbol GetClassParentSymbol();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassModuleEntityChild {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassModuleEntityParent {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassOrDelegateSymbol {
    public CppClassTag Tag { get; }
    public CppClassKey Key { get; }
    public CppClassVirtualSpecifiers ClassVirtualSpecifiers { get; }
    public abstract virtual CppClassTag get_Tag();
    public abstract virtual CppClassKey get_Key();
    public abstract virtual CppClassVirtualSpecifiers get_ClassVirtualSpecifiers();
    public abstract virtual bool Exported();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassOrDelegateSymbolOrModuleEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassOrGenericParameterResolveEntity {
    public abstract virtual CppBasicBaseDescription`1[] GetBases();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassOrNamespaceModuleEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassOrRefClassModuleEntity {
    public abstract virtual CppClassModuleEntityKind GetKind();
    public abstract virtual CppImportResult`1<ICppClassResolveEntity> Import(CppModuleImportingContext ctx, ICppScopeResolveEntity targetParent, bool onlyFindExisting, bool addToParentScope);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassOrUndeterminedSpecializationResolveEntity {
    public abstract virtual CppClassKey GetKey();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity {
    [CanBeNullAttribute]
public abstract virtual ICppDefinitionClassSymbol GetDefinitionSymbol();
    public abstract virtual bool HasDefinition();
    public abstract virtual bool Exported();
    public abstract virtual CppClassTag GetTag();
    public abstract virtual CppClassVirtualSpecifiers GetClassVirtualSpecifiers();
    public abstract virtual bool HasAbstractSpecifier();
    public abstract virtual bool IsFinal();
    public abstract virtual bool IsSealed();
    public abstract virtual bool IsFinalOrSealed();
    public abstract virtual bool IsAnonymousClass();
    public abstract virtual bool IsAbstract();
    public abstract virtual bool IsPolymorphic();
    public abstract virtual bool HasVirtualDestructor();
    public abstract virtual bool IsTriviallyCopyable(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public abstract virtual bool HasTrivialDestructor(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public abstract virtual bool HasNothrowDestructor(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public abstract virtual bool IsTrivial(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public abstract virtual bool IsStandardLayout(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public abstract virtual bool IsPOD(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public abstract virtual bool HasUniqueObjectRepresentations(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public abstract virtual bool HasTrivialConstructor();
    public abstract virtual IEnumerable`1<ICppResolveEntity> GetClassConstructors();
    public abstract virtual CppQualType GetEnumUnderlyingType();
    public abstract virtual CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> GetNonDependentBases();
    public abstract virtual ICppDeclaratorResolveEntityPack GetConversions();
    public abstract virtual ICppDeclaratorResolveEntityPack GetConstructors();
    public abstract virtual ICppDeclaratorResolveEntityPack GetStaticConstructors();
    public abstract virtual ICppDeclaratorResolveEntityPack GetDestructors();
    public abstract virtual ICppDeclaratorResolveEntityPack GetCliFinalizers();
    public abstract virtual IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity> GetClassConversions(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    public abstract virtual ICppTemplateArgument[] GetDefaultTemplateArguments(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    public abstract virtual CppSmallList`1<ICppFunctionDeclaratorResolveEntity> GetFriendFunctions(CppQualifiedNamePart name);
    public abstract virtual CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity> GetFriendClasses(CppQualifiedNamePart name);
    public abstract virtual ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppFunctionDeclaratorResolveEntity>> GetFriendFunctions();
    public abstract virtual ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity>> GetFriendClasses();
    public abstract virtual CppSmallList`1<ICppDependentTypeResolveEntity> GetFriendDependentTypes();
    public abstract virtual CppViewPos GetScopeForBaseClasses(ICppClassSymbol s);
    public abstract virtual CppLocationAnchor GetAnchorBySymbol(ICppClassOrDelegateSymbol s);
    public abstract virtual CppLocationAnchor GetDefinitionLocationAnchor();
    public abstract virtual bool IsEndLocationAnchorSet();
    public abstract virtual CppLocationAnchor GetEndLocationAnchor();
    public abstract virtual ICppGroupedTypeDeclaratorResolveEntity GetAssociatedTypedefForClass(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    public abstract virtual CppSmallList`1<ICppDeclaratorResolveEntityPack> GetAnonymousSubclassMembers(CppQualifiedNamePart name);
    public abstract virtual CppAttributeList GetAttributes();
    public abstract virtual CppList`1<ICppResolveEntity> GetAggregateMembers();
    public abstract virtual List`1<ICppResolveEntity> GetAllMembersSorted();
    public abstract virtual bool HasImmediateVirtualFunctions();
    public abstract virtual CppAccessibility GetAccessibility();
    public abstract virtual bool HasFixedEnumUnderlyingType();
    public abstract virtual bool HasInheritingConstructors();
    public abstract virtual bool ContainsSymbol(ICppClassOrDelegateSymbolOrModuleEntity symbol);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntityWithSubstitution {
    public abstract virtual void AssertInstantiated();
    public abstract virtual bool IsInstantiated();
    public abstract virtual CppInstantiationStatus Instantiate(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) pointOfInstantiation);
    public abstract virtual ICppClassResolveEntity GetInner();
    [CanBeNullAttribute]
public abstract virtual CppDefaultedSpecialMembers GetTemplateDefaultedSpecialMembers();
    public abstract virtual ICppSubstitutionContext GetSubstitution();
    public abstract virtual void Dump(CppIndentationStringBuilder sb);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntityWithSubstitutionState {
    public abstract virtual CppInstantiationStatus StateInstantiate();
    public abstract virtual bool InstantiationInProgress();
    public abstract virtual Nullable`1<CppViewPos> PointOfInstantiation();
    public abstract virtual ICppClassResolveEntity GetRawDefinition();
    public abstract virtual void Dump(CppIndentationStringBuilder sb);
    public abstract virtual CppLocationAnchor GetLocationAnchor();
    public abstract virtual CppClassVirtualSpecifiers GetClassVirtualSpecifiers();
    public abstract virtual void AddChild(ICppResolveEntity ent);
    public abstract virtual CppSmallList`1<ICppResolveEntity> ChildByName(CppQualifiedNamePart name, CppLocationAnchor anchor);
    public abstract virtual CppList`1<ICppResolveEntity> GetChildren();
    public abstract virtual void AddAnonymousClass(ICppClassResolveEntity ent);
    public abstract virtual CppList`1<ICppClassResolveEntity> AnonymousClasses();
    public abstract virtual CppSmallList`1<ICppDeclaratorResolveEntityPack> GetAnonymousSubclassMembers(CppQualifiedNamePart name);
    public abstract virtual void RegisterAnonymousSubclassMembers(CppList`1<ICppDeclaratorResolveEntityPack> members);
    public abstract virtual void GenerateImplicitDisposableIfNeeded();
    public abstract virtual CppViewPos GetScopeForBaseClasses(ICppClassSymbol sym);
    public abstract virtual CppLocationAnchor GetAnchorBySymbol(ICppClassOrDelegateSymbol sym);
    public abstract virtual bool HasDefinition();
    public abstract virtual ICppDefinitionClassSymbol GetDefinitionSymbol();
    public abstract virtual bool HasAbstractSpecifier();
    public abstract virtual bool IsFinal();
    public abstract virtual bool IsSealed();
    public abstract virtual bool IsFinalOrSealed();
    public abstract virtual bool IsAnonymousClass();
    public abstract virtual bool IsAbstract();
    public abstract virtual bool IsPolymorphic();
    public abstract virtual bool HasVirtualDestructor();
    public abstract virtual bool IsTriviallyCopyable(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public abstract virtual bool HasTrivialDestructor(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public abstract virtual bool HasNothrowDestructor(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public abstract virtual bool IsTrivial(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public abstract virtual bool IsStandardLayout(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public abstract virtual bool IsPOD(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public abstract virtual bool HasUniqueObjectRepresentations(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public abstract virtual bool HasTrivialConstructor();
    public abstract virtual IEnumerable`1<ICppResolveEntity> GetClassConstructors();
    public abstract virtual CppQualType GetEnumUnderlyingType();
    public abstract virtual CppList`1<CppBasicBaseDescription`1<ICppClassResolveEntity>> GetNonDependentBases();
    public abstract virtual CppBasicBaseDescription`1[] GetBases();
    public abstract virtual ICppDeclaratorResolveEntityPack GetConversions();
    public abstract virtual ICppDeclaratorResolveEntityPack GetConstructors();
    public abstract virtual ICppDeclaratorResolveEntityPack GetStaticConstructors();
    public abstract virtual ICppDeclaratorResolveEntityPack GetDestructors();
    public abstract virtual ICppDeclaratorResolveEntityPack GetCliFinalizers();
    public abstract virtual CppAttributeList GetAttributes();
    public abstract virtual bool Exported();
    public abstract virtual IEnumerable`1<ICppFunctionOrTemplateDeclaratorResolveEntity> GetClassConversions(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public abstract virtual CppLocationAnchor GetDefinitionLocationAnchor();
    public abstract virtual bool IsEndLocationAnchorSet();
    public abstract virtual CppLocationAnchor GetEndLocationAnchor();
    public abstract virtual CppSmallList`1<ICppFunctionDeclaratorResolveEntity> GetFriendFunctions(CppQualifiedNamePart name);
    public abstract virtual ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppFunctionDeclaratorResolveEntity>> GetFriendFunctions();
    public abstract virtual CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity> GetFriendClasses(CppQualifiedNamePart name);
    public abstract virtual ValueCollection<CppQualifiedNamePart, CppSmallList`1<ICppTypeTemplateInstantiationResolveEntity>> GetFriendClasses();
    public abstract virtual CppSmallList`1<ICppDependentTypeResolveEntity> GetFriendDependentTypes();
    public abstract virtual CppList`1<ICppResolveEntity> GetAggregateMembers();
    public abstract virtual List`1<ICppResolveEntity> GetAllMembersSorted();
    public abstract virtual bool HasImmediateVirtualFunctions();
    public abstract virtual bool HasInheritingConstructors();
    public abstract virtual bool HasFixedEnumUnderlyingType();
    public abstract virtual CppDeclaratorResolveEntityPack GetOrCreateConversions(CppLocationAnchor anchor);
    public abstract virtual CppDeclaratorResolveEntityPack GetOrCreateConstructors(CppLocationAnchor anchor);
    public abstract virtual CppDeclaratorResolveEntityPack GetOrCreateStaticConstructors(CppLocationAnchor anchor);
    public abstract virtual CppDeclaratorResolveEntityPack GetOrCreateDestructors(CppLocationAnchor anchor);
    public abstract virtual CppDeclaratorResolveEntityPack GetOrCreateCliFinalizers(CppLocationAnchor anchor);
    public abstract virtual void AddFriend(ICppFunctionDeclaratorResolveEntity dent);
    public abstract virtual void AddFriend(ICppTypeTemplateInstantiationResolveEntity cent);
    public abstract virtual void AddFriend(ICppDependentTypeResolveEntity ent);
    public abstract virtual void SetBases(CppList`1<CppBasicBaseDescription`1<CppQualifiedName>> bases);
    public abstract virtual void ResolveBases();
    public abstract virtual void SetEnumUnderlyingType(CppQualType replacedType, CppLocationAnchor anchor);
    public abstract virtual void SetResolvedEnumUnderlyingType(CppQualType resolvedType);
    public abstract virtual void SetDefinitionLocationAnchor(CppLocationAnchor anchor);
    public abstract virtual void SetEndLocationAnchor(CppLocationAnchor anchor);
    public abstract virtual void AddSymbolsForLateMerging(CppList`1<ICppSymbol> symbols, CppLocationAnchor anchor);
    public abstract virtual void ForceImporting();
    public abstract virtual CppConstructorDeclaratorResolveEntityPack EnsureConstructorExists(CppLocationAnchor anchor);
    [CanBeNullAttribute]
public abstract virtual CppDefaultedSpecialMembers GetTemplateDefaultedSpecialMembers();
    public abstract virtual ICppGroupedFunctionDeclaratorResolveEntity FindSubstitutionForCurrentlySubstituted(ICppGroupedFunctionDeclaratorResolveEntity orig);
    public abstract virtual void Journaling_RollbackSymbolPart(bool isDefinition, int attributesCount, CppClassVirtualSpecifiers specs);
    public abstract virtual void Journaling_RollbackChild(ICppResolveEntity ent);
    public abstract virtual void Journaling_RollbackCachedClassConstructors();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassSymbol {
    public abstract virtual CppSymbolTemplateParametersList ParamList();
    public abstract virtual CppAttributeList Attributes();
    public abstract virtual void SetLazyMergingInfo(CppClassLazyMergingInfo flags);
    public abstract virtual CppClassLazyMergingInfo GetLazyMergingInfo();
    public abstract virtual CppAccessibility GetAccessibility();
    public abstract virtual CppModuleAttachment ModuleAttachment();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassWithBasesSymbol {
    public abstract virtual CppList`1<CppBasicBaseDescription`1<CppQualifiedName>> GetBases();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClrClassResolveEntity {
    public abstract virtual BuiltinClass GetBuiltinClass();
    public abstract virtual CppPredefinedType GetPredefinedType();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClrElementResolveEntity {
    public IClrDeclaredElement ClrDeclaredElement { get; }
    public abstract virtual IClrDeclaredElement get_ClrDeclaredElement();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClrScopeResolveEntity {
    public abstract virtual CppSmallList`1<ICppResolveEntity> ClrChildByName(CppQualifiedNamePart name);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppCodeFragmentResolveEntity {
    public abstract virtual ICppFileResolveEntitiesCache GetCodeFragmentResolveCache();
    public abstract virtual CppLocationAnchor GetOuterAnchor();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppCompilerIntrinsicModuleEntity {
    public abstract virtual bool IsDefined(CppLanguageDialect dialect);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppConceptDefinitionBuilder {
    public CppConceptDefinitionSymbol Symbol { get; }
    public bool HasSymbol { get; }
    public abstract virtual ICppDeclarationBuilder GetDeclarationBuilder();
    public abstract virtual void LearnLocation(CppSymbolLocation _);
    public abstract virtual void LearnQualifiedName(CppTwinQualifiedNameBuilder& modreq(System.Runtime.InteropServices.InAttribute) _);
    public abstract virtual void ComposeSymbol(CppSymbolLocation _);
    public abstract virtual void LearnExpression(CppTwinExpressionBuilder& _);
    public abstract virtual CppConceptDefinitionSymbol get_Symbol();
    public abstract virtual bool get_HasSymbol();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppConceptDefinitionModuleEntity {
    public abstract virtual CppConceptDefinitionResolveEntity Import(CppModuleImportingContext ctx);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppConceptDefinitionResolveEntity {
    public CppQualifiedNamePart FullName { get; }
    public abstract virtual CppQualifiedNamePart get_FullName();
    public abstract virtual ICppResolvedExpression GetDefinition();
    public abstract virtual CppDependentInfo GetDependentInfo();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppConceptDefinitionSymbolOrModuleEntity {
    public abstract virtual CppConceptDefinitionSymbol GetSymbol();
    public abstract virtual CppSymbolLocation GetSymbolLocation();
    public abstract virtual bool Export();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppConceptDefinitionTemplateResolveEntity {
    public abstract virtual ICppConceptDefinitionResolveEntity InstantiateTemplate(ReadOnlySpan`1<ICppTemplateArgument> args, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppConceptParameterBuilder {
    public abstract virtual void LearnLocation(CppSymbolLocation _);
    public abstract virtual void LearnConceptName(CppTwinQualifiedNameBuilder nameBuilder);
    public abstract virtual void LearnEllipsis();
    public abstract virtual void LearnName(string _);
    public abstract virtual bool LearnConcept(CppConceptDefinitionResolveEntity reference);
    public abstract virtual void LearnDefaultTypeArgument(ICppDeclarationBuilder _);
    public abstract virtual ICppTemplateParameterSymbol GetSymbol();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppConceptParameterHeaderBuilder`1 {
    public abstract virtual TConceptParameterBuilder CreateConceptParameterBuilder();
    public abstract virtual void LearnConceptParameter(TConceptParameterBuilder _);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppConceptTemplateParameter {
    public abstract virtual CppQualifiedName GetReplacedConceptName();
    public abstract virtual CppQualifiedName CalculateResolvedConceptNameHint();
    public abstract virtual CppConceptDefinitionResolveEntity GetResolvedConcept();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppConceptTemplateParameterSymbol {
    public abstract virtual CppQualifiedName GetConceptName();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppConceptTemplateParameterWithResolveCache {
    public abstract virtual void Journaling_RollbackCachedConcept();
    public abstract virtual void Journaling_RollbackCachedConceptExpression();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.ICppConceptTemplateParameterWithResolveCacheUtil : object {
    [ExtensionAttribute]
public static CppConceptDefinitionResolveEntity ResolveConcept(ICppConceptTemplateParameterWithResolveCache param, CppCachedReference`1& cache);
    [ExtensionAttribute]
public static ICppTemplateParameter GetFirstParameter(ICppConceptDefinitionTemplateResolveEntity concept);
    [ExtensionAttribute]
public static ICppResolvedExpression ResolveConceptExpression(ICppConceptTemplateParameterWithResolveCache param, CppCachedReference`1& cache);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppCustomLexicalParentDeclaratorResolveEntity {
    public abstract virtual ICppClassResolveEntity LexicalParentClass();
    public abstract virtual ICppScopeResolveEntity LexicalParentScope();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaration0Builder {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclarationBuilder {
    public ICppDeclaratorBuilder LastDeclaratorBuilder { get; }
    public CppClassBuilder ClassBuilder { get; }
    public ICppAttributeListBuilder AttributeListBuilder { get; }
    public abstract virtual CppTemplateDeclarationBuilder TemplateDeclarationBuilder();
    public abstract virtual ICppDeclaratorBuilder get_LastDeclaratorBuilder();
    public abstract virtual ICppUnresolvedDeclarationSpecifierTypeBuilder GetUnresolvedSpecifierTypeBuilder();
    public abstract virtual ICppResolvedDeclarationSpecifierTypeBuilder GetReplacedSpecifierTypeBuilder();
    public abstract virtual void LearnDecltypeAuto();
    public abstract virtual void ApplyImplicitIntType();
    public abstract virtual ICppAttributeListBuilder CreateAttributesBuilder();
    public abstract virtual ICppCallingConventionBuilder CreateCallingConventionBuilder();
    public abstract virtual ICppStructuredBindingDeclarationBuilder CreateStructuredBindingBuilder();
    public abstract virtual CppClassBuilder get_ClassBuilder();
    public abstract virtual ICppAttributeListBuilder get_AttributeListBuilder();
    public abstract virtual void FinishDeclaration();
    public abstract virtual bool IsStandalone();
    public abstract virtual bool HasImplicitIntType();
    public abstract virtual CppDeclarationSpecifiers GetSpecifiers();
    public abstract virtual void LearnSpecifier(TokenNodeType tt);
    public abstract virtual void LearnDeclspecProperty();
    public abstract virtual void LearnAttributes(ICppAttributeListBuilder _);
    public abstract virtual void LearnCallingConvention(ICppCallingConventionBuilder ccBuilder);
    public abstract virtual void LearnClassSpecifier(CppClassBuilder _);
    public abstract virtual ICppDeclaratorBuilder NewDeclaratorBuilder();
    public abstract virtual ICppConceptDefinitionBuilder NewConceptDefinitionBuilder();
    public abstract virtual bool NeedTypename();
    public abstract virtual void LearnExplicitSpecifier();
    public abstract virtual void LearnExplicitSpecifier(CppTwinExpressionBuilder& exprBuilder);
    public abstract virtual void LearnExport();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorBuilder {
    public ICppDeclaratorSymbol Symbol { get; }
    public bool HasSymbol { get; }
    public bool IsParameterPackDeclarator { get; }
    public abstract virtual ICppDeclarationBuilder GetDeclarationBuilder();
    public abstract virtual ICppAttributeListBuilder CreateAttributesBuilder();
    public abstract virtual ICppCallingConventionBuilder CreateCallingConventionBuilder();
    public abstract virtual void ComposeSymbolType(CppSymbolLocation _);
    public abstract virtual void LearnLocation(CppSymbolLocation _);
    public abstract virtual void LearnQualifiedName(CppTwinQualifiedNameBuilder& modreq(System.Runtime.InteropServices.InAttribute) _);
    public abstract virtual void LearnQualifiedName(ICppStructuredBindingDeclarationBuilder _);
    public abstract virtual void LearnInitializer(KIND kind, CppSmallArray`1<ICppExpression> unresolvedArguments, CppSmallArray`1<ICppExpression> replacedArguments);
    public abstract virtual void LearnMainParameterList(ICppFunctionParameterListBuilder _);
    public abstract virtual void LearnFunctionBody(CppDeclarationTrailingKind _);
    public abstract virtual void LearnPureVirtualSpecifier(CppPureVirtualSpecifiers _);
    public abstract virtual void LearnEllipsis();
    public abstract virtual void LearnAttributes(ICppAttributeListBuilder _);
    public abstract virtual void LearnNoAttributes();
    public abstract virtual void LearnBitfieldSize(ICppExpression unresolvedSize, ICppExpression replacedSize);
    public abstract virtual void LearnCxxCliOverrideSpecifier(CppTwinQualifiedNameBuilder& modreq(System.Runtime.InteropServices.InAttribute) _);
    public abstract virtual void LearnRequiresClause(ICppExpression unresolved, ICppExpression replaced);
    public abstract virtual ICppFunctionParameterListBuilder GetMainParameterListBuilder();
    public abstract virtual ICppDeclaratorSymbol get_Symbol();
    public abstract virtual bool get_HasSymbol();
    public abstract virtual bool get_IsParameterPackDeclarator();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorOrTemplateDeclaratorPack {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorResolveEntity {
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public CppAttributeList Attributes { get; }
    public abstract virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public abstract virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public abstract virtual CppAttributeList get_Attributes();
    public abstract virtual CppQualType GetCppType(ICppResolvedTypeFactory typeIntern);
    public abstract virtual CppAccessibility GetAccessibility();
    public abstract virtual bool HasDefinition();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorResolveEntityPack {
    public abstract virtual void Dump(CppIndentationStringBuilder builder);
    public abstract virtual void ForceMerge(CppLocationAnchor anchor);
    public abstract virtual IEnumerable`1<ICppResolveEntity> GetGroupedEntities();
    public abstract virtual IEnumerable`1<ICppResolveEntity> GetGroupedEntities(CppLocationAnchor anchor);
    public abstract virtual void AppendGroupedEntities(CppLocationAnchor anchor, FrugalLocalList`1& result);
    public abstract virtual void AppendGroupedEntities(CppLocationAnchor anchor, List`1<ICppResolveEntity> result);
    public abstract virtual ICppGroupedDeclaratorResolveEntity FindGroupedDeclarator(ICppDeclaratorResolveEntity ent);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorResolveEntityWithSubstitution {
    public abstract virtual ICppDeclaratorResolveEntity GetInner();
    public abstract virtual CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) PointOfInstantiation();
    public abstract virtual ICppSubstitutionContext GetSubstitution();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorSymbol {
    public CppQualType RawType { get; }
    public CppDeclarationSpecifiers DeclarationSpecifiers { get; }
    public CppPureVirtualSpecifiers PureVirtualSpecifiers { get; }
    public bool IsExplicitInstantiation { get; }
    public abstract virtual CppQualType get_RawType();
    public abstract virtual CppDeclarationSpecifiers get_DeclarationSpecifiers();
    public abstract virtual CppPureVirtualSpecifiers get_PureVirtualSpecifiers();
    public abstract virtual bool get_IsExplicitInstantiation();
    public abstract virtual CppSymbolTemplateParametersList ParamList();
    public abstract virtual CppAttributeList Attributes();
    public abstract virtual CppDeclarationTrailingKind GetDeclarationTrailingKind();
    public abstract virtual CppAccessibility GetAccessibility();
    public abstract virtual ICppExpression GetRequiresClause();
    public abstract virtual bool IsFunction();
    public abstract virtual bool IsParameterPack();
    public abstract virtual CppDeclaratorInitializer GetInitializer();
    [CanBeNullAttribute]
public abstract virtual CppCompoundStatementSymbol GetFunctionBody();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDecltypeResolveEntity {
    public abstract virtual ICppResolvedExpression GetExpression();
    public abstract virtual CppDecltypeKind GetKind();
    public abstract virtual ICppFileResolveEntitiesCache GetResolveCache();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeducibleTypeTemplateResolveEntity {
    public abstract virtual bool IsDeducibleTemplate();
    public abstract virtual CppList`1<ICppDeductionGuide> GetDeductionGuides(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
    public abstract virtual CppClassTemplateResolveEntityPack GetClassPack();
    [CanBeNullAttribute]
public abstract virtual ICppDeductionGuide GetAggregateDeductionGuide(ICppExpression[] args, CppArgumentListKind argListKind, CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc);
    public abstract virtual CppQualType FinalizeDeduction(CppQualType type, CppTypeContext& modreq(System.Runtime.InteropServices.InAttribute) tc);
    public abstract virtual bool IsDeducibleTemplateChildEntity(ICppResolveEntity entity);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDefinitionClassSymbol {
    public abstract virtual bool IsAnonymousClass();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDependentLinkageEntity {
    public CppQualifiedName DebugQualifiedName { get; }
    public abstract virtual CppQualifiedName get_DebugQualifiedName();
    public abstract virtual Result Accept(ICppDependentLinkageEntityVisitor`1<Result> visitor);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDependentLinkageEntityVisitor`1 {
    public abstract virtual Result Visit(CppClassLinkageEntity ent);
    public abstract virtual Result Visit(CppDependentAutoTypeLinkageEntity ent);
    public abstract virtual Result Visit(CppDependentDecltypeLinkageEntity ent);
    public abstract virtual Result Visit(CppDependentSuperLinkageEntity ent);
    public abstract virtual Result Visit(CppDependentLinkageEntity ent);
    public abstract virtual Result Visit(CppTemplateTemplateParameterWithAppliedArgumentsLinkageEntity ent);
    public abstract virtual Result Visit(CppUndeterminedClassSpecializationLinkageEntity ent);
    public abstract virtual Result Visit(CppUndeterminedVariableSpecializationLinkageEntity ent);
    public abstract virtual Result Visit(CppUndeterminedTypeSpecializationLinkageEntity ent);
    public abstract virtual Result Visit(CppConceptSpecializationLinkageEntity ent);
    public abstract virtual Result Visit(CppTemplateParameterDependentLinkageEntity ent);
    public abstract virtual Result Visit(CppDependentDeducedClassTypePlaceholderLinkageEntity ent);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDependentModuleEntityHead {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDependentResolveEntity {
    public abstract virtual CppLookupResult DoSubstitutionGetLookupResult(CppSubstitutionDriver driver);
    public abstract virtual ICppTemplateArgument DoSubstitutionGetTemplateArgument(CppSubstitutionDriver driver);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDependentScopeLikeResolveEntity {
    public CppDependentInfo DependentInfo { get; }
    public abstract virtual CppDependentInfo get_DependentInfo();
    public abstract virtual ICppScopeLikeResolveEntity DoSubstitutionGetScopeLike(CppSubstitutionDriver substDriver);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDependentTemplateArgument {
    public CppQualifiedName LookedUpName { get; }
    public abstract virtual CppQualifiedName get_LookedUpName();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDependentTypeResolveEntity {
    public abstract virtual CppQualType DoSubstitutionGetType(CppSubstitutionDriver substDriver);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDesignatorBuilder`1 {
    public abstract virtual TExpressionBuilder CreateExpressionBuilder();
    public abstract virtual void LearnSubscriptDesignator(TExpressionBuilder& index);
    public abstract virtual void LearnMemAccessDesignator(string name);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDetachedStatementResolveEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDoubleArgumentTypeTraitExpressionBuilder {
    public abstract virtual void LearnFirstArgument(ICppDeclarationBuilder declBuilder);
    public abstract virtual void LearnSecondArgument(ICppDeclarationBuilder declBuilder);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDumpableChildrenResolveEntity {
    public abstract virtual IEnumerable`1<ICppResolveEntity> GetExtraChildrenForDump();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppEnumeratorModuleEntity {
    public abstract virtual ICppClassOrRefClassModuleEntity GetParent();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppEnumeratorResolveEntity {
    public abstract virtual ICppClassResolveEntity GetEnumeration();
    public abstract virtual ICppEnumeratorResolveEntity GetPreviousEnumerator();
    public abstract virtual bool HasValueCached();
    [CanBeNullAttribute]
public abstract virtual ICppEvaluationResult GetValue(ICppEvaluationErrorTracker errorTracker);
    public abstract virtual CppDependentInfo GetDependentInfo();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppEnumeratorSymbolOrModuleEntity {
    public abstract virtual CppQualifiedNamePart GetName();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppExceptionSpecificationBuilder {
    public abstract virtual void LearnThrowAnySpecification();
    public abstract virtual void LearnNoExceptSpecification();
    public abstract virtual void LearnNoExceptSpecification(CppTwinExpressionBuilder& exprBuilder);
    public abstract virtual ICppDeclarationBuilder CreateDeclarationBuilderForDynamicExceptionSpecification(ICppBuilder parent, bool isDetectionMode);
    public abstract virtual void LearnDynamicExceptionSpecification();
    public abstract virtual void LearnDynamicExceptionSpecificationElement(ICppDeclarationBuilder _, bool isPackExpansion);
    public abstract virtual ICppExceptionSpecification GetUnresolvedExceptionSpecification();
    public abstract virtual ICppExceptionSpecification GetReplacedExceptionSpecification();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppExcessiveTemplateArgument {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppExpressionBuilder {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppExpressionBuilder`9 {
    public abstract virtual TExpressionBuilder CreateInnerExpressionBuilder();
    public abstract virtual ICppDeclarationBuilder CreateInnerDeclarationBuilder(ICppBuilder parent);
    public abstract virtual TQualifiedNameBuilder CreateInnerQualifiedNameBuilder();
    public abstract virtual TFunctionArgumentListBuilder CreateInnerFunctionArgumentListBuilder();
    public abstract virtual TDesignatorBuilder CreateDesignatorBuilder();
    public abstract virtual TC11GenericExpressionBuilder CreateC11GenericExpressionBuilder();
    public abstract virtual void LearnEmptyExpression();
    public abstract virtual void ApplyThrowOperator();
    public abstract virtual void ApplyCStyleCast(ICppDeclarationBuilder declBuilder);
    public abstract virtual void ApplyUnaryOperator(TokenNodeType tok);
    public abstract virtual void ApplyMSAssume();
    public abstract virtual void LearnSizeOfExpression(ICppDeclarationBuilder builder);
    public abstract virtual void LearnSizeOfEllipsisExpression(TQualifiedNameBuilder& nameBuilder);
    public abstract virtual void ApplySizeOf();
    public abstract virtual void LearnAlignOfExpression(ICppDeclarationBuilder builder);
    public abstract virtual void ApplyAlignOf();
    public abstract virtual void LearnMSUuidOfExpression(ICppDeclarationBuilder builder);
    public abstract virtual void ApplyMSUuidOf();
    public abstract virtual void LearnMSEventHookExpression(bool unhook, TFunctionArgumentListBuilder& builder);
    public abstract virtual void ApplyNoExcept();
    public abstract virtual void ApplyBuiltinAddressOf();
    public abstract virtual void ApplyGnuBuiltinConstantP();
    public abstract virtual void LearnBuiltinOffsetOf(TBuiltinOffsetOfBuilder offsetofBuilder);
    public abstract virtual void LearnNewExpression(TNewExpressionBuilder builder);
    public abstract virtual void ApplyDeleteOperator(bool isArrayKind);
    public abstract virtual void LearnSingleArgumentTypeTraitExpression(ICppDeclarationBuilder argumentTypeId, TokenNodeType kwToken);
    public abstract virtual void LearnDoubleArgumentTypeTraitExpression(TDoubleArgumentTypeTraitExpressionBuilder builder, TokenNodeType kwToken);
    public abstract virtual void LearnMultiArgumentTypeTraitExpression(TMultiArgumentTypeTraitExpressionBuilder builder, TokenNodeType kwToken);
    public abstract virtual void ApplyCast(TokenNodeType tt, ICppDeclarationBuilder declBuilder);
    public abstract virtual void LearnTypeIdExpression(ICppDeclarationBuilder builder);
    public abstract virtual void ApplyTypeId();
    public abstract virtual void ApplyParen();
    public abstract virtual void LearnQualifiedReferenceExpression(TQualifiedNameBuilder& qualNameBuilder);
    public abstract virtual void LearnQualifiedReferenceExpression(CppTwinQualifiedNameBuilder& qualNameBuilder);
    public abstract virtual void ApplyPostfixOperator(TokenNodeType tt);
    public abstract virtual void ApplyDotOperator(TokenNodeType tt, TQualifiedNameBuilder& name);
    public abstract virtual void ApplySubscriptionOperator(TExpressionBuilder exprBuilder, bool isPackExpansion);
    public abstract virtual void ApplyMultiArgumentSubscriptionOperator(TFunctionArgumentListBuilder& argListBuilder, bool cli);
    public abstract virtual void LearnCliTypeId(TQualifiedNameBuilder& nameBuilder);
    public abstract virtual void ApplyBinaryOperator(CppOperatorKind kind, TExpressionBuilder& exprBuilder);
    public abstract virtual void ApplyConditionalOperator(TExpressionBuilder& secondArgumentBuilder, TExpressionBuilder& thirdArgumentBuilder, CppConditionalExprKind kind);
    public abstract virtual void ApplyGnuBuiltinChooseExpr(CppFunctionArgumentListBuilder& argBuilder);
    public abstract virtual void ApplyUnaryLeftFoldExpression(CppOperatorKind kind);
    public abstract virtual void ApplyUnaryRightFoldExpression(CppOperatorKind kind);
    public abstract virtual void ApplyBinaryFoldExpression(CppOperatorKind kind, TExpressionBuilder& exprBuilder);
    public abstract virtual void LearnLambdaExpression(CppLambdaBuilder builder);
    public abstract virtual void LearnRequiresExpression(CppRequiresExpressionBuilder builder);
    public abstract virtual void LearnC11GenericExpression(TC11GenericExpressionBuilder& builder);
    public abstract virtual void LearnGnuStatementExpression(CppCompoundStatementInExpressionBuilder builder);
    public abstract virtual bool LearnLiteral(TokenNodeType tt, string text, CppLanguageDialect dialect);
    public abstract virtual bool LearnStringLiteral(CppStringLiteralBuilder& builder);
    public abstract virtual void LearnThis();
    public abstract virtual void LearnMSNoopExpression();
    public abstract virtual void LearnGNUAddressOfLabelExpression(string labelName);
    public abstract virtual void ApplyCallOperator(TFunctionArgumentListBuilder& builder);
    public abstract virtual void LearnCallToTypeId(CppUnresolvedDeclarationSpecifierTypeBuilder typeBuilder, TFunctionArgumentListBuilder& argBuilder);
    public abstract virtual void LearnBracedInitializedTypeId(CppUnresolvedDeclarationSpecifierTypeBuilder typeBuilder, TFunctionArgumentListBuilder& argBuilder);
    public abstract virtual void LearnBracedInitializedTypeIdDecl(ICppDeclarationBuilder declBuilder, TFunctionArgumentListBuilder& argBuilder);
    public abstract virtual void ApplyBracedInitializer(TFunctionArgumentListBuilder& argBuilder);
    public abstract virtual void LearnBracedInitList(TFunctionArgumentListBuilder& builder);
    public abstract virtual void ApplyCoAwaitExpression();
    public abstract virtual void ApplyCoYieldExpression();
    public abstract virtual void LearnDesignation(TDesignatorBuilder& designator, TExpressionBuilder& initializer, InitializerKind kind);
    public abstract virtual TQualifiedNameBuilder CreateQualifiedNameBuilder();
    public abstract virtual CppStringLiteralBuilder CreateStringLiteralBuilder();
    public abstract virtual TFunctionArgumentListBuilder CreateFunctionArgumentListBuilder(bool createSymbols);
    public abstract virtual TNewExpressionBuilder CreateNewExpressionBuilder();
    public abstract virtual TDoubleArgumentTypeTraitExpressionBuilder CreateDoubleArgumentTypeTraitExpressionBuilder();
    public abstract virtual TMultiArgumentTypeTraitExpressionBuilder CreateMultiArgumentTypeTraitExpressionBuilder();
    public abstract virtual TBuiltinOffsetOfBuilder CreateBuiltinOffsetOfBuilder();
    public abstract virtual ICppExpression GetExpressionForLookup();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppExpressionTemplateArgument {
    public abstract virtual IEnumerable`1<CppExpressionTemplateArgument> UnpackExprArgs();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppExpressionTemplateParameter {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppExpressionTemplateParameterOrPack {
    public abstract virtual ICppResolvedExpression DoExpressionTemplateParameterSubstitution(CppSubstitutionDriver substDriver);
    public abstract virtual CppDependentInfo GetDependentInfo();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppExpressionTemplateParameterOrPackForPsi {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppExpressionTemplateParameterPack {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppExpressionTemplateParameterSymbol {
    public CppQualType Type { get; }
    public abstract virtual CppQualType get_Type();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFailedTemplateInstantiationResolveEntity {
    public abstract virtual ICppResolvedExpression GetFailedConstraint();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFileResolveEntitiesCache {
    public CppLocationAnchor CurrentAnchor { get; }
    public CppPPLocationAnchor CurrentPPAnchor { get; }
    public ICppResolvedTypeFactory TypeFactory { get; }
    public ICppResolvedTypeFactory VerboseTypeFactory { get; }
    public ICppResolvedTypeFactory VerboseNormalizingTypeFactory { get; }
    public CppGlobalNamespaceResolveEntity GlobalNamespace { get; }
    public CppResolveMutex ResolveMutex { get; }
    public bool AllowPendingActions { get; }
    public ICppRootFileResolveEntitiesCache RootCache { get; }
    public CppRootInclusionContext InclusionContext { get; }
    public CppModuleId CurrentModule { get; }
    public abstract virtual CppLocationAnchor get_CurrentAnchor();
    public abstract virtual CppPPLocationAnchor get_CurrentPPAnchor();
    public abstract virtual ICppResolvedTypeFactory get_TypeFactory();
    public abstract virtual ICppResolvedTypeFactory get_VerboseTypeFactory();
    public abstract virtual ICppResolvedTypeFactory get_VerboseNormalizingTypeFactory();
    public abstract virtual CppGlobalNamespaceResolveEntity get_GlobalNamespace();
    public abstract virtual CppResolveMutex get_ResolveMutex();
    public abstract virtual bool get_AllowPendingActions();
    public abstract virtual ICppRootFileResolveEntitiesCache get_RootCache();
    public abstract virtual CppRootInclusionContext get_InclusionContext();
    public abstract virtual void AddTemplateParametersMapping(ICppResolveEntity ent, Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> mapping);
    public abstract virtual Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> GetTemplateParametersMapping(ICppResolveEntity ent);
    public abstract virtual CppLocationAnchor IncrementCurrentAnchor(int delta);
    public abstract virtual CppLocationAnchor IncrementCurrentAnchor();
    public abstract virtual CppPPLocationAnchor IncrementCurrentPPAnchor();
    public abstract virtual CppLanguageDialect GetDialect();
    public abstract virtual CppModuleId get_CurrentModule();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFileSymbolsCache {
    public ICppBuilder RootBuilder { get; }
    public ICppFileResolveEntitiesCache ResolveCache { get; }
    public CppFileLocation BaseFile { get; }
    public List`1<ICppSymbol> PreprocessorSymbols { get; public set; }
    public Nullable`1<UInt32> PragmaPackForChameleon { get; }
    public abstract virtual ICppBuilder get_RootBuilder();
    public abstract virtual ICppFileResolveEntitiesCache get_ResolveCache();
    public abstract virtual CppFileLocation get_BaseFile();
    public abstract virtual List`1<ICppSymbol> get_PreprocessorSymbols();
    public abstract virtual void set_PreprocessorSymbols(List`1<ICppSymbol> value);
    public abstract virtual void SetDetectionMode(bool enabled);
    public abstract virtual CppSymbolTypeIntern GetTypeIntern();
    public abstract virtual void DisablePsiMode();
    public abstract virtual ICppSymbol IgnorePPSymbol(CppComplexOffset offset);
    public abstract virtual void RegisterAndIncrementAnchorForIncludeDirective(CppComplexOffset offset, bool localInclude);
    public abstract virtual void RegisterCacheSnapshot(CppComplexOffset o);
    public abstract virtual void RegisterPreprocessorSnapshot(CppComplexOffset offset, CppInclusionContextSnapshot snapshot);
    public abstract virtual bool HasCacheSnapshot();
    public abstract virtual Nullable`1<UInt32> get_PragmaPackForChameleon();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFriendDeclTargetResolveEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFriendFunctionModuleEntity {
    public abstract virtual CppImportResult`1<ICppFunctionDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFunctionArgumentListBuilder`1 {
    public abstract virtual TExpressionBuilder CreateExpressionBuilder();
    public abstract virtual void LearnArgument(TExpressionBuilder& exprBuilder, bool isPackExpansion);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFunctionBodyResolveEntity {
    public ICppFunctionDeclaratorResolveEntity Function { get; }
    public abstract virtual ICppFunctionDeclaratorResolveEntity get_Function();
    public abstract virtual CppQualType GetResolvedFunctionReturnType(ICppResolvedTypeFactory tf);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFunctionDeclaratorBuilder {
    public abstract virtual bool ShouldParseFunctionBody();
    public abstract virtual void LearnFunctionBody(CppFunctionBodyBuilder _);
    public abstract virtual void LearnClosedBodyChameleon();
    public abstract virtual void LearnCtorBlockWithoutBody();
    public abstract virtual void LearnAutoParameter(ICppTypeTemplateParameterOrPack _);
    public abstract virtual void SetUsedInDeferredParsing();
    [CanBeNullAttribute]
public abstract virtual CppTemplateParametersBase GetTemplateParameters();
    public abstract virtual ICppBuilder CreateInitDeclaratorBuilder();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFunctionDeclaratorResolveEntity {
    public CppFunctionTraits Traits { get; }
    [CanBeNullAttribute]
public ICppFunctionBodyResolveEntity Body { get; }
    public int BodyChameleonVersion { get; }
    public abstract virtual CppFunctionTraits get_Traits();
    public abstract virtual ICppFunctionBodyResolveEntity get_Body();
    public abstract virtual int get_BodyChameleonVersion();
    [CanBeNullAttribute]
public abstract virtual ICppParameterListResolveEntity GetMainParameterList();
    [CanBeNullAttribute]
public abstract virtual IEnumerable`1<ICppResolveEntity> GetResolvedCxxCliOverrideSpecifierTargets();
    public abstract virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public abstract virtual int GetFirstDefaultArgIndex();
    [CanBeNullAttribute]
public abstract virtual ICppResolvedExpression GetResolvedRequiresClause();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFunctionModuleEntity {
    public abstract virtual CppImportResult`1<ICppGroupedFunctionDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFunctionOrVariableDeclaratorResolveEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFunctionParameterListBuilder {
    public abstract virtual void LearnCVQualifier(TokenNodeType tt);
    public abstract virtual CVQualifiers GetFunctionCVQualifiers();
    public abstract virtual void LearnRefQualifier(TokenNodeType tt);
    public abstract virtual void LearnIsMainParameterList(bool declaratorIsStatic);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppGeneratedDeclaratorResolveEntity {
    public abstract virtual CppGeneratedResolveEntityType GetEntityType();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppGeneratedFunctionDeclaratorResolveEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppGeneratedTypeTemplateDeclaratorBuilder {
    public abstract virtual CppQualifiedNamePart GetName();
    public abstract virtual CppTemplateParametersBase CreateTemplateParameters(ICppFileResolveEntitiesCache cache, ICppResolvedTypeFactory tf);
    public abstract virtual CppGeneratedTypeTemplateDeclaratorResolveEntityBase CreateDeclarator(CppGeneratedTypeDeclaratorResolveEntity primaryTemplate);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppGenericConstraint {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppGenericParameter {
    public abstract virtual CppList`1<CppBasicBaseDescription`1<ICppClassOrGenericParameterResolveEntity>> GetNonDependentBases();
    public abstract virtual CppGenericParameterFlags GetFlags();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppIfStatementResolveEntity {
    public abstract virtual CppCompoundStatementResolveEntity GetThenResolveEntity();
    public abstract virtual CppCompoundStatementResolveEntity GetElseResolveEntity();
    public abstract virtual bool IsConstExpr();
    public abstract virtual bool IsConstEval();
    public abstract virtual bool GetConstEvalCondition();
    public abstract virtual CppViewPos ViewPosForCondition();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppImportedDeclaratorResolveEntity {
    public abstract virtual ICppTopLevelDeclaratorModuleEntity GetSource();
    public abstract virtual CppModuleImportingContext GetImportingContext();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppInnerDeclaratorBuilder {
    public abstract virtual ICppDeclaratorBuilder GetDeclaratorBuilder();
    public abstract virtual ICppUnresolvedTypeBuilder GetUnresolvedTypeBuilder();
    public abstract virtual ICppResolvedTypeBuilder GetReplacedTypeBuilder();
    public abstract virtual ICppFunctionParameterListBuilder CreateParameterListBuilder();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppInventedTypeTemplateParameterOrPack {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppJournalEntry {
    public abstract virtual void Rollback();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppLambdaCapture {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppLambdaParameterListBuilder {
    public abstract virtual void LearnMutable();
    public abstract virtual void LearnConstexpr();
    public abstract virtual void LearnConsteval();
    public abstract virtual void LearnStatic();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppLazyMergingDataConsumer {
    public abstract virtual void LearnTrailingReturnType();
    public abstract virtual void LearnDeclarator(CppDeclaratorSymbol declSym);
    public abstract virtual void LearnClassSymbol(ICppClassSymbol sym);
    public abstract virtual void IncrementAnchor(int diff);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppLinkageConceptTemplateParameter {
    public CppQualifiedName ConceptName { get; }
    public abstract virtual CppQualifiedName get_ConceptName();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppLinkageEntity {
    public CppQualifiedNamePart Name { get; }
    public ICppLinkageEntity Parent { get; }
    public abstract virtual CppQualifiedNamePart get_Name();
    public abstract virtual ICppLinkageEntity get_Parent();
    public abstract virtual Result Accept(ICppLinkageEntityVisitor`1<Result> visitor);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppLinkageEntityVisitor`1 {
    public abstract virtual Result Visit(CppNamespaceLinkageEntity ent);
    public abstract virtual Result Visit(CppNamespaceAliasLinkageEntity ent);
    public abstract virtual Result Visit(CppClassLinkageEntity ent);
    public abstract virtual Result Visit(CppDeclaratorLinkageEntity ent);
    public abstract virtual Result Visit(CppUndeterminedSpecializationLinkageEntity ent);
    public abstract virtual Result Visit(CppUsingDeclarationLinkageEntity ent);
    public abstract virtual Result Visit(CppParameterLinkageEntity ent);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppLinkageExpressionTemplateArgument {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppLinkageExpressionTemplateParameter {
    public CppQualType Type { get; }
    public abstract virtual CppQualType get_Type();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppLinkageGenericParameter {
    public CppTypeTemplateParameterKey Key { get; }
    public abstract virtual CppTypeTemplateParameterKey get_Key();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppLinkageTemplateArgument {
    public abstract virtual string Present(ICppPresenter presenter);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppLinkageTemplateArgumentPack {
    public abstract virtual IEnumerable`1<ICppLinkageTemplateArgument> Unpack();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppLinkageTemplateParameter {
    public CppQualifiedNamePart Name { get; }
    public CppLinkageTemplateParameterList OwnerParameterList { get; }
    public abstract virtual CppQualifiedNamePart get_Name();
    public abstract virtual CppLinkageTemplateParameterList get_OwnerParameterList();
    public abstract virtual int GetParameterIndex();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppLinkageTemplateParameterPack {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppLinkageTemplateTemplateArgument {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppLinkageTemplateTemplateParameter {
    public ICppLinkageTemplateParameter[] Parameters { get; }
    public abstract virtual ICppLinkageTemplateParameter[] get_Parameters();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppLinkageTypeTemplateArgument {
    public IEnumerable`1<CppQualType> ArgTypes { get; }
    public abstract virtual IEnumerable`1<CppQualType> get_ArgTypes();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppLinkageTypeTemplateParameter {
    public CppTypeTemplateParameterKey Key { get; }
    public abstract virtual CppTypeTemplateParameterKey get_Key();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppMainFunctionParameterListBuilder {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppMainParameterListBuilder {
    public abstract virtual void LearnAutoParameter(ICppTypeTemplateParameterOrPack param);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppMergeClassSymbolAction {
    public abstract virtual bool IsPendingActionForFwdClassWithTag(CppClassTag tag);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppModuleEntity {
    public abstract virtual CppModuleEntityKind Kind();
    public abstract virtual int SerializedSize();
    public abstract virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public abstract virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppModuleOperatorCallExpression {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppModuleTemplateArgument {
    public abstract virtual ICppTemplateArgument Import(CppModuleImportingContext ctx);
    public abstract virtual CppModuleTemplateArgumentKind Kind();
    public abstract virtual int SerializedSize();
    public abstract virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppModuleTemplateParameter {
    public abstract virtual ICppTemplateParameter Import(CppModuleImportingContext ctx);
    public abstract virtual bool IsOrphaned();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppMultiArgumentTypeTraitExpressionBuilder {
    public abstract virtual void LearnArgument(ICppDeclarationBuilder declBuilder, bool isPackExpansion);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppMutableClassResolveEntity {
    public abstract virtual CppDeclaratorResolveEntityPack GetOrCreateConversions(CppLocationAnchor anchor);
    public abstract virtual CppDeclaratorResolveEntityPack GetOrCreateConstructors(CppLocationAnchor anchor);
    public abstract virtual CppDeclaratorResolveEntityPack GetOrCreateStaticConstructors(CppLocationAnchor anchor);
    public abstract virtual CppDeclaratorResolveEntityPack GetOrCreateDestructors(CppLocationAnchor anchor);
    public abstract virtual CppDeclaratorResolveEntityPack GetOrCreateCliFinalizers(CppLocationAnchor anchor);
    public abstract virtual void AddFriend(ICppFunctionDeclaratorResolveEntity ent);
    public abstract virtual void AddFriend(ICppTypeTemplateInstantiationResolveEntity ent);
    public abstract virtual void AddFriend(ICppDependentTypeResolveEntity ent);
    public abstract virtual void SetBases(CppList`1<CppBasicBaseDescription`1<CppQualifiedName>> bases);
    public abstract virtual void ResolveBases();
    public abstract virtual void AddSymbolPart(ICppClassOrDelegateSymbol sym, CppLocationAnchor anchor, CppQualifiedNamePart name, CppAttributeList attrs);
    public abstract virtual void AddModulePart(CppClassOrEnumModuleEntity ent, CppModuleImportingContext ctx);
    public abstract virtual void SetEnumUnderlyingType(CppQualType replacedType, CppLocationAnchor anchor);
    public abstract virtual void SetResolvedEnumUnderlyingType(CppQualType resolvedType);
    public abstract virtual void SetDefinitionLocationAnchor(CppLocationAnchor anchor);
    public abstract virtual void SetEndLocationAnchor(CppLocationAnchor anchor);
    public abstract virtual void AddSymbolsForLateMerging(CppList`1<ICppSymbol> syms, CppLocationAnchor anchor);
    public abstract virtual void ForceImporting();
    public abstract virtual CppConstructorDeclaratorResolveEntityPack EnsureConstructorExists(CppLocationAnchor anchor);
    public abstract virtual void SetAssociatedTypedef(CppDeclaratorResolveEntityPack assocTypedef);
    public abstract virtual void SetAssociatedTypedef(ICppTypeDeclaratorResolveEntity assocTypedef);
    public abstract virtual void RegisterAnonymousSubclassMembers(CppList`1<ICppDeclaratorResolveEntityPack> members);
    public abstract virtual void GenerateImplicitDisposableIfNeeded();
    public abstract virtual void Journaling_RollbackSymbolPart(bool isDefinition, int attributesCount, CppClassVirtualSpecifiers spec);
    public abstract virtual void Journaling_RollbackChild(ICppResolveEntity ent);
    public abstract virtual void Journaling_RollbackCachedClassConstructors();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppMutableStatementWithConditionResolveEntity {
    public abstract virtual void SetReplacedCondition(ICppExpression c, CppLocationAnchor a);
    public abstract virtual void SetResolvedCondition(ICppResolvedExpression e);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppNamespaceModuleEntityChild {
    public abstract virtual CppQualifiedNamePart GetName();
    public abstract virtual ICppScopeModuleEntity GetParent();
    public abstract virtual bool IsExplicitlyExported();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppNamespaceSymbol {
    public abstract virtual bool IsExported();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppNamespaceSymbolOrModuleEntity {
    public abstract virtual bool IsInline();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppNewExpressionBuilder`2 {
    public abstract virtual void LearnIsCliGCNew(bool gcn);
    public abstract virtual void LearnIsFromGlobalNamespace(bool isFromGlobalNamespace);
    public abstract virtual void LearnType(ICppDeclarationBuilder declBuilder);
    public abstract virtual void LearnOperatorArguments(TFunctionArgumentListBuilder& funcArgList);
    public abstract virtual void LearnConstructorArguments(TFunctionArgumentListBuilder& funcArgListBuilder);
    public abstract virtual void LearnBracedArguments(TFunctionArgumentListBuilder& funcArgListBuilder);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppNonTypeTemplateParameterHeaderBuilder`1 {
    public abstract virtual TNonTypeParameterBuilder CreateNonTypeParameterBuilder();
    public abstract virtual void LearnNonTypeParameter(TNonTypeParameterBuilder _);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppParameterLinkageEntity {
    public abstract virtual int GetDepth();
    public abstract virtual int GetIndex();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppParameterListBuilder {
    public abstract virtual void LearnExplicitThis();
    public abstract virtual void LearnEllipsis(CppEllipsisKind kind);
    public abstract virtual void LearnRestrictionSpecifier(CppRestrictionSpecifiers _);
    public abstract virtual ICppDeclarationBuilder CreateDeclarationBuilderForParameter(CppBuilderPool _);
    public abstract virtual void LearnParameter(ICppDeclarationBuilder _);
    public abstract virtual void LearnEndAnchor();
    public abstract virtual void LearnKnRStyleParamsStart();
    public abstract virtual CppEllipsisKind GetEllipsisKind();
    public abstract virtual CppRestrictionSpecifiers GetRestrictionSpecifiers();
    public abstract virtual FuncRefQualifier GetFunctionRefQualifier();
    public abstract virtual CppParameterListResolveEntity GetResolveEntity();
    public abstract virtual CppList`1<CppParameterDeclaratorSymbol> GetParameterSymbols();
    public abstract virtual ICppDeclarationBuilder CreateDeclarationBuilderForTrailingReturnType();
    public abstract virtual void LearnTrailingReturnStartAnchor();
    public abstract virtual void LearnTrailingReturnType(ICppDeclarationBuilder _);
    public abstract virtual CppQualType GetUnresolvedTrailingReturnType();
    public abstract virtual CppQualType GetReplacedTrailingReturnType();
    public abstract virtual bool HasOnlyParamsWithImplicitInt();
    public abstract virtual bool IsKnRParamListStarted();
    public abstract virtual ICppExceptionSpecificationBuilder CreateExceptionSpecificationBuilder(CppComplexOffset _);
    public abstract virtual void LearnExceptionSpecification(CppComplexOffset offset, ICppExceptionSpecificationBuilder builder);
    public abstract virtual ICppExceptionSpecification GetUnresolvedExceptionSpecification();
    public abstract virtual ICppExceptionSpecification GetReplacedExceptionSpecification();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppParameterListResolveEntity {
    public CppEllipsisKind EllipsisKind { get; }
    public abstract virtual CppEllipsisKind get_EllipsisKind();
    public abstract virtual CppList`1<ICppVariableDeclaratorResolveEntity> GetParameters();
    public abstract virtual bool IsMainParameterListOfStaticFunction();
    public abstract virtual bool IsMainParameterList();
    public abstract virtual bool IsRequiresExpressionParameterList();
    public abstract virtual ICppFunctionDeclaratorResolveEntity GetOwningDeclarator();
    public abstract virtual CVQualifiers GetCVQualifiers();
    public abstract virtual CppLocationAnchor GetEndAnchor();
    public abstract virtual Nullable`1<CppLocationAnchor> GetExceptionSpecAnchor();
    public abstract virtual CppLocationAnchor GetTrailingReturnTypeAnchor();
    public abstract virtual bool ContainsLambdas();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.ICppParameterListUtil : object {
    [ExtensionAttribute]
public static bool ParameterListNeedsEagerSubstitution(ICppParameterListResolveEntity paramList, ICppGroupedFunctionDeclaratorResolveEntity function, ICppFileResolveEntitiesCache resolveCache);
    [ExtensionAttribute]
public static bool ParameterListNeedsEagerSubstitution(ICppParameterListResolveEntity paramList, CppQualType functionType);
    private static bool DependsOn(CppQualType type, ICppParameterListResolveEntity paramList);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppParameterPack {
    public abstract virtual UInt32 GetCardinality();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppParserSymbol {
    public CppQualifiedName Name { get; }
    public ICppParserSymbol Parent { get; }
    public abstract virtual CppQualifiedName get_Name();
    public abstract virtual ICppParserSymbol get_Parent();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppPendingActionWithResult`1 {
    public abstract virtual TResult GetResult();
    public abstract virtual bool ResultWasSet();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppPendingMergingAction {
    public abstract virtual CppLocationAnchor GetAnchor();
    public abstract virtual void DoMerge(ICppFileResolveEntitiesCache c);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppPPSymbol {
    public string Name { get; }
    public abstract virtual string get_Name();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppQualifiedNameBuilder {
    public abstract virtual void LearnId(string id);
    public abstract virtual void LearnAnonymousId();
    public abstract virtual void LearnDestructorTag(string tag);
    public abstract virtual void LearnOperatorId(CppOperatorKind kind);
    public abstract virtual void LearnConversionId(ICppDeclarationBuilder declBuilder);
    public abstract virtual void LearnUserDefinedLiteralId(string id);
    public abstract virtual ICppDeclarationBuilder CreateDeclarationBuilderForConversion(ICppBuilder parent);
    public abstract virtual void LearnDecltypeDestructorTag();
    public abstract virtual void LearnTypeOfType(ICppDeclarationBuilder declBuilder, CppDecltypeKind kind);
    public abstract virtual void LearnGlobalNamespaceId();
    public abstract virtual void LearnMSSuperId();
    public abstract virtual void LearnCliSimpleTypeId(CppQualType type);
    public abstract virtual void LearnCliFinalizerTag(string tag);
    public abstract virtual CppQualifiedName GetRawNameForLookup();
    public abstract virtual ICppTemplateArgumentsBuilder CreateTemplateArgumentsBuilderBoxed();
    public abstract virtual void LearnTemplateArgumentsBoxed(ICppTemplateArgumentsBuilder builder);
    public abstract virtual ICppExpressionBuilder CreateExpressionBuilderBoxed(bool createSymbols);
    public abstract virtual void LearnDecltypeBoxed(ICppExpressionBuilder exprBuilder, CppDecltypeKind kind);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppQualifiedNameBuilderWithExpressionBuilder`1 {
    public abstract virtual TExpressionBuilder CreateExpressionBuilder(bool createSymbols);
    public abstract virtual void LearnDecltype(TExpressionBuilder exprBuilder, CppDecltypeKind kind);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppQualifiedNameBuilderWithTemplateArguments`1 {
    public abstract virtual TTemplateArgumentsBuilder CreateTemplateArgumentsBuilder();
    public abstract virtual void LearnTemplateArguments(TTemplateArgumentsBuilder builder);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppQualifiedNamePartDynamic {
    public abstract virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppQualifiedNamePartVisitor`2 {
    public abstract virtual Result Visit(Data data, CppQualifiedId name);
    public abstract virtual Result Visit(Data data, CppAnonymousId name);
    public abstract virtual Result Visit(Data data, CppDestructorTag name);
    public abstract virtual Result Visit(Data data, CppOperatorId name);
    public abstract virtual Result Visit(Data data, CppUserDefinedLiteralId name);
    public abstract virtual Result Visit(Data data, CppDecltypeDestructorTag name);
    public abstract virtual Result Visit(Data data, CppGlobalNamespaceId name);
    public abstract virtual Result Visit(Data data, CppMSSuperId name);
    public abstract virtual Result Visit(Data data, CppLambdaId name);
    public abstract virtual Result Visit(Data data, CppConversionsPackId name);
    public abstract virtual Result Visit(Data data, CppCliFinalizerTag name);
    public abstract virtual Result Visit(Data data, CppConversionId name);
    public abstract virtual Result Visit(Data data, CppDecltypeId name);
    public abstract virtual Result Visit(Data data, CppTypeOfTypeId name);
    public abstract virtual Result Visit(Data data, CppResolvedStructuredBindingId name);
    public abstract virtual Result Visit(Data data, CppUnresolvedStructuredBindingId name);
    public abstract virtual Result Visit(Data data, CppCliSimpleTypeId name);
    public abstract virtual Result Visit(Data data, CppTemplateId name);
    public abstract virtual Result Visit(Data data, CppSubstitutionId name);
    public abstract virtual Result Visit(Data data, CppAnonymousLinkageId name);
    public abstract virtual Result Visit(Data data, CppLinkageTemplateId name);
    public abstract virtual Result Visit(Data data, CppModuleTemplateId name);
    public abstract virtual Result Visit(Data data, CppModuleSubstitutionId name);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppRawDeclaratorResolveEntity {
    public abstract virtual CppQualType ResolveType(ICppResolvedTypeFactory tf);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppReferentialClassOrEnumModuleEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppRequiresExpressionItemSymbolVisitor`1 {
    public abstract virtual TResult Visit(CppRequiresExpressionItemTypenameSymbol sym);
    public abstract virtual TResult Visit(CppRequiresExpressionItemSimpleSymbol sym);
    public abstract virtual TResult Visit(CppRequiresExpressionItemNestedSymbol sym);
    public abstract virtual TResult Visit(CppRequiresExpressionItemCompoundSymbol sym);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppRequiresExpressionScopeResolveEntity {
    public abstract virtual CppRequiresExpressionSymbol GetRequiresSymbol();
    public abstract virtual List`1<ICppTemplateParameter> GetTemplateDependencies();
    public abstract virtual ICppParameterListResolveEntity GetParameterList();
    public abstract virtual int GetItemsCount();
    public abstract virtual CppList`1<ICppRequiresExpressionItem> GetResolvedItems();
    public abstract virtual CppViewPos GetViewPos();
    public abstract virtual TriBool Evaluate(CppExpressionEvaluator evaluator);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppResolveEntity {
    public ICppResolveEntity StructuralParent { get; }
    public CppQualifiedNamePart Name { get; }
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public CppLocationAnchor LocationAnchor { get; }
    public abstract virtual ICppResolveEntity get_StructuralParent();
    public abstract virtual CppQualifiedNamePart get_Name();
    public abstract virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public abstract virtual CppLocationAnchor get_LocationAnchor();
    public abstract virtual Result Accept(ICppResolveEntityVisitor`1<Result> visitor);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppResolveEntityParent {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppResolveEntityParentScope {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppResolveEntityVisitor`1 {
    public abstract virtual Result Visit(ICppClassResolveEntity ent);
    public abstract virtual Result Visit(ICppStatementResolveEntity ent);
    public abstract virtual Result Visit(ICppParameterListResolveEntity ent);
    public abstract virtual Result Visit(ICppDeclaratorResolveEntity ent);
    public abstract virtual Result Visit(ICppDeclaratorResolveEntityPack ent);
    public abstract virtual Result Visit(ICppConceptDefinitionResolveEntity ent);
    public abstract virtual Result Visit(ICppTypeTemplateParameter ent);
    public abstract virtual Result Visit(ICppTypeTemplateParameterPack ent);
    public abstract virtual Result Visit(ICppExpressionTemplateParameter ent);
    public abstract virtual Result Visit(ICppExpressionTemplateParameterPack ent);
    public abstract virtual Result Visit(ICppTemplateTemplateParameter ent);
    public abstract virtual Result Visit(ICppTemplateTemplateParameterPack ent);
    public abstract virtual Result Visit(ICppVariableTemplateDeclaratorResolveEntity ent);
    public abstract virtual Result Visit(ICppEnumeratorResolveEntity ent);
    public abstract virtual Result Visit(ICppGenericParameter ent);
    public abstract virtual Result Visit(ICppRequiresExpressionScopeResolveEntity ent);
    public abstract virtual Result Visit(AbstractBuiltinResolveEntity ent);
    public abstract virtual Result Visit(ICppFunctionTemplateDeclaratorResolveEntity ent);
    public abstract virtual Result Visit(ICppTypeTemplateDeclaratorResolveEntity ent);
    public abstract virtual Result Visit(CppClassTemplateResolveEntityPack ent);
    public abstract virtual Result Visit(CppUndeterminedSpecializationResolveEntity ent);
    public abstract virtual Result Visit(CppNamespaceResolveEntity ent);
    public abstract virtual Result Visit(CppNamespaceAliasResolveEntity ent);
    public abstract virtual Result Visit(CppTemplateTemplateParameterWithAppliedArgumentsResolveEntity ent);
    public abstract virtual Result Visit(CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity ent);
    public abstract virtual Result Visit(CppUndeterminedTemplateVariableSpecializationResolveEntity ent);
    public abstract virtual Result Visit(CppDecltypeResolveEntity ent);
    public abstract virtual Result Visit(ICppDeductionGuide ent);
    public abstract virtual Result Visit(CppTypeOfTypeResolveEntity ent);
    public abstract virtual Result Visit(CppUsingEnumEnumeratorResolveEntity ent);
    public abstract virtual Result Visit(CppDependentResolveEntity ent);
    public abstract virtual Result Visit(CppDependentAutoTypeResolveEntity ent);
    public abstract virtual Result Visit(CppDependentFunctionReturnAutoTypeResolveEntity ent);
    public abstract virtual Result Visit(CppDependentDecltypeResolveEntity ent);
    public abstract virtual Result Visit(CppDependentDeducedClassTypePlaceholder ent);
    public abstract virtual Result Visit(CppRequiresExpressionItemResolveEntity ent);
    public abstract virtual Result Visit(CppSuperResolveEntity ent);
    public abstract virtual Result Visit(CppUsingDeclarationResolveEntity ent);
    public abstract virtual Result Visit(CppUsingDeclarationResolveEntityWithSubstitution ent);
    public abstract virtual Result Visit(CppDependencyKillerResolveEntity ent);
    public abstract virtual Result Visit(ICppCxxCliPropertySetResolveEntity ent);
    public abstract virtual Result Visit(HlslBuiltinFunctionResolveEntity ent);
    public abstract virtual Result Visit(BlockShadersResolveEntity e);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppResolveEntityWithParent {
    public ICppResolveEntityParent RealParent { get; }
    public abstract virtual ICppResolveEntityParent get_RealParent();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppReturnStatementResolveEntity {
    public abstract virtual CppViewPos GetViewPos();
    [CanBeNullAttribute]
public abstract virtual ICppResolvedExpression GetExpression();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppRootFileResolveEntitiesCache {
    public CppFileLocation SourceFile { get; }
    public CppGlobalSymbolCache GlobalCache { get; }
    public ISymbolScope ClrScope { get; }
    public CppPPUsagesCollection PPUsageEngine { get; }
    public CppSymbolLocator SymbolLocator { get; }
    public int ClassInstantiationsCount { get; public set; }
    public CppComparisonCategories ComparisonCategories { get; }
    public bool IsUESolution { get; }
    public CppUE4Version UEVersion { get; }
    public abstract virtual CppFileLocation get_SourceFile();
    public abstract virtual CppGlobalSymbolCache get_GlobalCache();
    public abstract virtual ISymbolScope get_ClrScope();
    public abstract virtual CppPPUsagesCollection get_PPUsageEngine();
    public abstract virtual CppSymbolLocator get_SymbolLocator();
    public abstract virtual int get_ClassInstantiationsCount();
    public abstract virtual void set_ClassInstantiationsCount(int value);
    public abstract virtual CppComparisonCategories get_ComparisonCategories();
    public abstract virtual IEnumerable`1<KeyValuePair`2<ICppResolveEntity, Dictionary`2<ICppResolveEntity, CppTemplateParametersBase>>> Journaling_QueryTemplateParameterMapping();
    public abstract virtual Dictionary`2<ICppResolveEntity, ICppLinkageEntity> Journaling_QueryResolveToLinkageEntityMap();
    public abstract virtual void SetStartAnchor(CppLocationAnchor anchor);
    public abstract virtual void SetStartPPAnchor(CppPPLocationAnchor anchor);
    public abstract virtual ICppLinkageEntity TryGetCachedLinkageEntity(ICppResolveEntity e);
    public abstract virtual void CacheLinkageEntity(ICppResolveEntity e, ICppLinkageEntity l);
    public abstract virtual void RecacheLinkageEntitySymbols();
    public abstract virtual void ClearLinkageEntitiesCache();
    public abstract virtual CppResolveEntitiesDetachedData GetDetachedData();
    [CanBeNullAttribute]
public abstract virtual CppJournal GetCurrentJournal();
    public abstract virtual CppJournal Snapshot();
    public abstract virtual void Rollback(CppJournal journal);
    public abstract virtual long GetVersion();
    public abstract virtual ICppPerfEventAccumulator GetPerfEvents();
    public abstract virtual CppMergeSymbolActions GetMergeSymbolActions();
    public abstract virtual void SetCurrentModule(CppModuleId module);
    public abstract virtual void RegisterImportedModule(CppModuleImportingContext ctx);
    public abstract virtual void UnregisterImportedModule(CppModuleImportingContext ctx);
    public abstract virtual bool TryGetContextOfAlreadyImportedModule(CppModuleDescriptor descriptor, CppModuleImportingContext& ctx);
    public abstract virtual bool ImportsModulesOtherThanBuiltins();
    public abstract virtual bool get_IsUESolution();
    public abstract virtual CppUE4Version get_UEVersion();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppRsInternalResolveEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeLikeResolveEntity {
    public abstract virtual FrugalLocalList`1<ICppResolveEntity> Lookup(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos, CppQualifiedNamePart name, CppLookupFilter filter, bool ignoreDependencies, bool forceHideByName);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeModuleEntity {
    public abstract virtual CppImportResult`1<ICppScopeResolveEntity> ImportScopeAutoParent(CppModuleImportingContext ctx);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeResolveEntity {
    public abstract virtual void AddChild(ICppResolveEntity e);
    public abstract virtual void RemoveChild(ICppResolveEntity e);
    public abstract virtual CppSmallList`1<ICppResolveEntity> ChildByName(CppQualifiedNamePart name, CppLocationAnchor anchor);
    public abstract virtual CppList`1<ICppResolveEntity> GetChildren();
    public abstract virtual void AddAnonymousClass(ICppClassResolveEntity c);
    public abstract virtual CppList`1<ICppClassResolveEntity> AnonymousClasses();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeResolveEntityUtil : object {
    [ExtensionAttribute]
public static CppSmallList`1<ICppResolveEntity> AllChildrenByName(ICppScopeResolveEntity scope, CppQualifiedNamePart name);
    [ExtensionAttribute]
public static FrugalLocalList`1<ICppUsingDirectiveObject> QueryUsingDirectives(ICppScopeResolveEntity scope);
    private static void BuildUsingDirectives(ICppScopeResolveEntity scope, FrugalLocalList`1& output);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeStatementBuilder {
    [CanBeNullAttribute]
public abstract virtual CppScopeSymbol GetSymbol();
    public abstract virtual CppScopeStatementResolveEntity GetResolveEntity();
    public abstract virtual void AddGotoStatement(CppComplexOffset loc, CppGotoStatementKind kind);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeStatementResolveEntity {
    public abstract virtual List`1<ICppResolveEntity> GetSortedChildren();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppScopeStatementResolveEntityWithSubstitution {
    public abstract virtual List`1<ICppResolveEntity> GetCachedSortedChildren();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppSpecializationLinkageEntity {
    public abstract virtual ICppLinkageEntity GetPrimaryTemplate();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppStatementResolveEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppStatementWithConditionResolveEntity {
    [CanBeNullAttribute]
public abstract virtual ICppResolvedExpression GetCondition();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppStringLiteralBuilder {
    public abstract virtual void StartMsLPrefix();
    public abstract virtual void LearnStringLiteral(ITokenNode token);
    public abstract virtual void LearnFuncKeyword(CppFuncKeywordKind kind, CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) vp);
    public abstract virtual FrugalLocalList`1<string> GetStringParts();
    public abstract virtual string GetUserDefinedSuffix();
    public abstract virtual void LearnStringLiteralFromText(string text);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppStructuredBindingDeclarationBuilder {
    public abstract virtual CppStructuredBindingSymbol LearnId(string id, CppSymbolLocation location);
    public abstract virtual CppQualifiedNamePart CreateUnresolvedNamePart();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppSubstitutedScopeStatementModuleEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppSubstitutionContext {
    public abstract virtual bool TryGetSubstitution(CppTemplateParameterTag tag, ICppTemplateArgument& a);
    public abstract virtual bool ContainsSubstitutionFor(CppTemplateParameterTag p);
    public abstract virtual bool TryGetExpansion(CppTemplateParameterTag tag, ICppTemplateArgument& a);
    public abstract virtual bool ContainsExpansionFor(CppTemplateParameterTag p);
    public abstract virtual ICppSubstitutionContext ReplaceTags(CppTemplateParametersBase old, CppTemplateParametersBase new_);
    public abstract virtual CppSubstitutionContext Reinstate();
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppSubstitutionMapping {
    public int Count { get; }
    public ICppTemplateArgument Item { get; public set; }
    public abstract virtual int get_Count();
    public abstract virtual ICppTemplateArgument get_Item(CppTemplateParameterTag tag);
    public abstract virtual void set_Item(CppTemplateParameterTag tag, ICppTemplateArgument value);
    public abstract virtual void Add(CppTemplateParameterTag tag, ICppTemplateArgument arg);
    public abstract virtual bool ContainsKey(CppTemplateParameterTag tag);
    public abstract virtual bool TryGetValue(CppTemplateParameterTag tag, ICppTemplateArgument& value);
    public abstract virtual IEnumerable`1<CppTemplateParameterTag> Keys();
    public abstract virtual ICppSubstitutionMapping Clone();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppSymbol {
    public CppSymbolLocation Location { get; }
    public CppFileLocation ContainingFile { get; }
    public CppComplexOffset ComplexOffset { get; }
    public string DbgDescription { get; }
    public abstract virtual CppSymbolLocation get_Location();
    public abstract virtual CppFileLocation get_ContainingFile();
    public abstract virtual CppComplexOffset get_ComplexOffset();
    public abstract virtual string get_DbgDescription();
    public abstract virtual void ShiftLocation(int textOffsetDelta);
    public abstract virtual TextRange LocateTextRange();
    public abstract virtual DocumentRange LocateDocumentRange(ISolution solution);
    public abstract virtual Result Accept(ICppSymbolVisitor`1<Result> visitor);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppSymbolDataInternStrategy {
    public abstract virtual string Intern(string name);
    public abstract virtual CppQualifiedNamePart Intern(CppQualifiedNamePart name);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppSymbolOrModuleEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppSymbolVisitor`1 {
    public abstract virtual Result Visit(ICppDeclaratorSymbol s);
    public abstract virtual Result Visit(CppDeclarationSymbol s);
    public abstract virtual Result Visit(CppParameterDeclaratorSymbol s);
    public abstract virtual Result Visit(CppClassSymbol s);
    public abstract virtual Result Visit(CppFwdClassSymbol s);
    public abstract virtual Result Visit(CppDeserializedFromModuleClassSymbol s);
    public abstract virtual Result Visit(CppEnumWithBaseSymbol s);
    public abstract virtual Result Visit(CppFwdEnumWithBaseSymbol s);
    public abstract virtual Result Visit(CppEnumeratorSymbol s);
    public abstract virtual Result Visit(CppAliasDeclarationSymbol s);
    public abstract virtual Result Visit(CppTypeTemplateParameterSymbol s);
    public abstract virtual Result Visit(CppTypeTemplateParameterPackSymbol s);
    public abstract virtual Result Visit(CppExpressionTemplateParameterSymbol s);
    public abstract virtual Result Visit(CppExpressionTemplateParameterPackSymbol s);
    public abstract virtual Result Visit(CppTemplateTemplateParameterSymbol s);
    public abstract virtual Result Visit(CppTemplateTemplateParameterPackSymbol s);
    public abstract virtual Result Visit(CppGenericParameterSymbol s);
    public abstract virtual Result Visit(CppConceptTypeTemplateParameterSymbol s);
    public abstract virtual Result Visit(CppConceptTypeTemplateParameterPackSymbol s);
    public abstract virtual Result Visit(CppLambdaSymbol s);
    public abstract virtual Result Visit(CppLambdaInitCaptureSymbol s);
    public abstract virtual Result Visit(CppNamespaceSymbol s);
    public abstract virtual Result Visit(CppNamespaceAliasSymbol s);
    public abstract virtual Result Visit(CppNamespaceQualifierSymbol s);
    public abstract virtual Result Visit(CppExportBlockSymbol _);
    public abstract virtual Result Visit(CppLinkageSpecSymbol _);
    public abstract virtual Result Visit(CppUsingDeclarationSymbol s);
    public abstract virtual Result Visit(CppUsingDirectiveSymbol s);
    public abstract virtual Result Visit(CppUsingEnumDeclarationSymbol s);
    public abstract virtual Result Visit(CppStructuredBindingSymbol s);
    public abstract virtual Result Visit(CppConceptDefinitionSymbol s);
    public abstract virtual Result Visit(CppAnonymousCStructDeclarationSymbol s);
    public abstract virtual Result Visit(CppGotoStatementSymbol s);
    public abstract virtual Result Visit(CppHLSLBufferSymbol s);
    public abstract virtual Result Visit(CppCatchBlockSymbol s);
    public abstract virtual Result Visit(CppCompoundStatementSymbol s);
    public abstract virtual Result Visit(CppSwitchStatementSymbol s);
    public abstract virtual Result Visit(CppWhileStatementSymbol s);
    public abstract virtual Result Visit(CppDoStatementSymbol s);
    public abstract virtual Result Visit(CppForStatementSymbol s);
    public abstract virtual Result Visit(CppIfStatementSymbol s);
    public abstract virtual Result Visit(CppReturnStatementSymbol s);
    public abstract virtual Result Visit(CppExpressionStatementSymbol s);
    public abstract virtual Result Visit(CppCtorInitializerStatementSymbol s);
    public abstract virtual Result Visit(CppPPDefineSymbol s);
    public abstract virtual Result Visit(CppPPIncludeSymbol s);
    public abstract virtual Result Visit(CppPPMacroParameterSymbol s);
    public abstract virtual Result Visit(CppPPUndefSymbol s);
    public abstract virtual Result Visit(CppPPPragmaSymbol s);
    public abstract virtual Result Visit(CppCxxCliDelegateSymbol s);
    public abstract virtual Result Visit(CppCxxCliPropertySymbol s);
    public abstract virtual Result Visit(CppModuleDirectiveSymbol s);
    public abstract virtual Result Visit(CppImportHeaderUnitDirectiveSymbol s);
    public abstract virtual Result Visit(CppImportModuleDirectiveSymbol s);
    public abstract virtual Result Visit(CppRequiresExpressionSymbol s);
    public abstract virtual Result Visit(CppRequiresExpressionItemTypenameSymbol s);
    public abstract virtual Result Visit(CppRequiresExpressionItemSimpleSymbol s);
    public abstract virtual Result Visit(CppRequiresExpressionItemNestedSymbol s);
    public abstract virtual Result Visit(CppRequiresExpressionItemCompoundSymbol s);
    public abstract virtual Result Visit(BSBlockSymbol s);
    public abstract virtual Result Visit(BSBlockShaderSymbol s);
    public abstract virtual Result Visit(BSBlockShaderInterfaceSymbol s);
    public abstract virtual Result Visit(BSCustomizationPointSymbol s);
    public abstract virtual Result Visit(BSCustomizationPointImplementationSymbol s);
    public abstract virtual Result Visit(BSTemplateSymbol s);
    public abstract virtual Result Visit(CppGGDeclareHungarianSymbol s);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppSymbolWithBracedBody {
    public abstract virtual void SetBodyStartOffset(CppComplexOffset offset);
    public abstract virtual CppComplexOffset GetBodyStartOffset();
    public abstract virtual void SetBodyEndOffset(CppComplexOffset offset);
    public abstract virtual CppComplexOffset GetBodyEndOffset();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateArgument {
    public abstract virtual Result Accept(Data data, ICppTemplateArgumentVisitor`2<Result, Data> visitor);
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateArgumentPack {
    public int Cardinality { get; }
    public ICppTemplateArgument Item { get; }
    public abstract virtual int get_Cardinality();
    public abstract virtual ICppTemplateArgument get_Item(int i);
    public abstract virtual IEnumerable`1<ICppTemplateArgument> Unpack();
    public abstract virtual void IncreaseCardinality(int val);
    public abstract virtual void SetElement(int index, ICppTemplateArgument value);
    public abstract virtual void Push(ICppTemplateArgument arg);
    public abstract virtual ICppTemplateArgument MakeInvalidElement();
    public abstract virtual ICppTemplateArgumentPack New(int cardinality);
    public abstract virtual ICppTemplateArgumentPack Clone();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateArgumentsBuilder {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateArgumentsBuilder`2 {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateArgumentVisitor`2 {
    public abstract virtual Result Visit(Data data, CppQualType type);
    public abstract virtual Result Visit(Data data, CppTypeTemplateArgument arg);
    public abstract virtual Result Visit(Data data, CppTypeTemplateArgumentPack arg);
    public abstract virtual Result Visit(Data data, CppExpressionTemplateArgument arg);
    public abstract virtual Result Visit(Data data, CppExpressionTemplateArgumentPack arg);
    public abstract virtual Result Visit(Data data, CppTemplateTemplateArgument arg);
    public abstract virtual Result Visit(Data data, CppTemplateTemplateArgumentPack arg);
    public abstract virtual Result Visit(Data data, CppLookupFailureTemplateArgument arg);
    public abstract virtual Result Visit(Data data, CppQualifiedReferenceTemplateArgument arg);
    public abstract virtual Result Visit(Data data, CppInjectedClassNameTemplateArgument arg);
    public abstract virtual Result Visit(Data data, CppDependentTemplateArgument arg);
    public abstract virtual Result Visit(Data data, CppExcessiveTemplateArgument arg);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateHeaderBuilder {
    public abstract virtual void LearnGenericParameter(CppGenericParameterBuilder _);
    public abstract virtual void LearnRequiresClause(ICppExpression unresolved, ICppExpression replaced);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateHeaderBuilder`4 {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateInstantiationResolveEntity {
    public abstract virtual bool IsTemplateInstantiation();
    public abstract virtual ICppTemplateResolveEntity GetTemplate();
    public abstract virtual ICppTemplateArgument[] GetArguments();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateParameter {
    public abstract virtual bool NameEquals(CppQualifiedNamePart name);
    public abstract virtual ICppFileResolveEntitiesCache GetResolveCache();
    public abstract virtual ICppTemplateArgument GetDefault(ICppResolvedTypeFactory tf);
    public abstract virtual CppTemplateParameterTag GetTag();
    public abstract virtual void ReplaceTag(CppTemplateParameterTag tag);
    public abstract virtual bool IsConcept();
    public abstract virtual bool IsInvented();
    public abstract virtual ICppResolvedExpression GetResolvedConceptExpression();
    [CanBeNullAttribute]
public abstract virtual ICppSymbol GetSymbol();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateParameterForPsi {
    public abstract virtual CppViewPos GetViewPos();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateParameterPack {
    public abstract virtual ICppTemplateArgumentPack CreateEmptyMatchingArgumentPack();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateParameterPackSymbol {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateParameterSymbol {
    public CppQualifiedNamePart NamePart { get; }
    public abstract virtual CppQualifiedNamePart get_NamePart();
    public abstract virtual bool NameEquals(CppQualifiedNamePart name);
    public abstract virtual ICppTemplateArgument GetDefault();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateParameterWithSubstitution {
    public abstract virtual ICppTemplateParameter GetInner();
    public abstract virtual CppViewPos PointOfInstantiation();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateResolveEntity {
    public abstract virtual IEnumerable`1<ICppResolveEntity> GetAllSpecializations();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateResolveEntityBase {
    public abstract virtual CppTemplateParametersBase GetParameters();
    public abstract virtual ICppTemplateArgument[] GetDefaults(CppViewPos& modreq(System.Runtime.InteropServices.InAttribute) viewPos);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateTemplateArgument {
    public abstract virtual IEnumerable`1<CppTemplateTemplateArgument> UnpackTemplateArgs();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateTemplateParameter {
    public abstract virtual ICppTypeTemplateResolveEntity DoSubstitutionGetTypeTemplate(CppSubstitutionDriver substDriver);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateTemplateParameterBuilder`1 {
    public abstract virtual TTemplateHeaderBuilder CreateTemplateHeaderBuilder();
    public abstract virtual void LearnTemplateHeader(TTemplateHeaderBuilder headerBuilder);
    public abstract virtual void LearnName(CppPsiBuilder _);
    public abstract virtual void LearnName(string _);
    public abstract virtual void LearnLocation(CppSymbolLocation _);
    public abstract virtual void LearnDefaultArgument(CppTwinQualifiedNameBuilder nameBuilder);
    public abstract virtual void LearnEllipsis();
    public abstract virtual ICppTemplateTemplateParameterSymbol GetSymbol();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateTemplateParameterHeaderBuilder`1 {
    public abstract virtual TTemplateTemplateParameterBuilder CreateTemplateTemplateParameterBuilder();
    public abstract virtual void LearnTemplateTemplateParameter(TTemplateTemplateParameterBuilder _);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateTemplateParameterOrPack {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateTemplateParameterPack {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateTemplateParameterSymbol {
    public abstract virtual CppSymbolTemplateParameters GetParameters();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTopLevelDeclaratorModuleEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTypeAliasModuleEntity {
    public abstract virtual CppImportResult`1<ICppGroupedTypeDeclaratorResolveEntity> Import(CppModuleImportingContext _);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTypeDeclaratorResolveEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTypeIdOrExpressionBuilder`2 {
    public abstract virtual ICppDeclarationBuilder CreateDeclarationBuilder(ICppBuilder parent, bool createParameters);
    public abstract virtual TExpressionBuilder CreateExpressionBuilder(bool createSymbols);
    public abstract virtual void LearnTypeId(ICppDeclarationBuilder builder, bool isPackExpansion);
    public abstract virtual void LearnExpression(TExpressionBuilder& exprBuilder, bool isPackExpansion);
    public abstract virtual void LearnQualifiedReference(TQualifiedNameBuilder& nameBuilder, bool isPackExpansion, bool hadTypename);
    public abstract virtual void LearnQualifiedReference(CppTwinQualifiedNameBuilder& nameBuilder, bool isPackExpansion, bool hadTypename);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTypeModuleEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTypeParameterBuilder {
    public abstract virtual void LearnName(CppPsiBuilder _);
    public abstract virtual void LearnName(string _);
    public abstract virtual void LearnLocation(CppSymbolLocation _);
    public abstract virtual void LearnDefaultArgument(ICppDeclarationBuilder _);
    public abstract virtual void LearnKey(CppTypeTemplateParameterKey _);
    public abstract virtual void LearnEllipsis();
    public abstract virtual ICppTemplateParameterSymbol GetSymbol();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTypeParameterHeaderBuilder`1 {
    public abstract virtual TTypeParameterBuilder CreateTypeParameterBuilder();
    public abstract virtual void LearnTypeParameter(TTypeParameterBuilder _);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTypeTemplateArgument {
    public abstract virtual CppQualType GetQualType();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTypeTemplateArgumentOrPack {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTypeTemplateInstantiationResolveEntity {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTypeTemplateInstantiationResolveEntityUtil : object {
    [ExtensionAttribute]
public static ICppTypeTemplateResolveEntity GetTypeTemplate(ICppTypeTemplateInstantiationResolveEntity ent);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTypeTemplateParameter {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTypeTemplateParameterOrPack {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTypeTemplateParameterOrPackOrGenericParameter {
    public CppTypeTemplateParameterKey Key { get; }
    public abstract virtual CppTypeTemplateParameterKey get_Key();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTypeTemplateParameterPack {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTypeTemplateParameterSymbol {
    public CppTypeTemplateParameterKey Key { get; }
    public abstract virtual CppTypeTemplateParameterKey get_Key();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTypeTemplateResolveEntity {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppUserProvidedDeductionGuide {
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppUsingDeclarationResolveEntity {
    public abstract virtual UsingDeclarationTargets GetTargets();
    public abstract virtual UsingDeclarationTargets Journaling_GetTargets();
    public abstract virtual CppAccessibility GetAccessibility();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppUsingDeclarationSymbolOrModuleEntity {
    public abstract virtual CppUsingDeclarationSymbol GetSymbol();
    public abstract virtual CppSymbolLocation GetSymbolLocation();
    public abstract virtual bool HadTypename();
    public abstract virtual bool IsPackExpansion();
    public abstract virtual bool Export();
    public abstract virtual CppAccessibility GetAccessibility();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppUsingDirectiveContainer {
    public abstract virtual void AddUsingDirective(ICppUsingDirectiveObject o);
    public abstract virtual CppList`1<ICppUsingDirectiveObject> GetUsingDirectives();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppUsingDirectiveObject {
    public CppLocationAnchor LocationAnchor { get; }
    public abstract virtual CppLocationAnchor get_LocationAnchor();
    public abstract virtual CppNamespaceResolveEntity GetTarget();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppVariableDeclaratorProvidingViewposForEvaluation {
    public abstract virtual CppViewPos GetViewPosForEvaluation();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppVariableDeclaratorResolveEntity {
    public bool IsParameterPack { get; }
    public abstract virtual bool get_IsParameterPack();
    public abstract virtual CppDeclaratorInitializer GetInitializer();
    public abstract virtual bool HasInitializer();
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppVariableModuleEntity {
    public abstract virtual CppImportResult`1<ICppGroupedVariableDeclaratorResolveEntity> Import(CppModuleImportingContext ctx);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ICppVTableEntryInfoVisitor`1 {
    public abstract virtual Result Visit(CppVTableEntryInfoPrimary entry);
    public abstract virtual Result Visit(CppVTableEntryInfoAlias entry);
    public abstract virtual Result Visit(CppVTableEntryInfoAmbiguous entry);
    public abstract virtual Result Visit(CppVTableEntryInfoMultipleInheritance entry);
    public abstract virtual Result Visit(CppVTableEntryInfoVirtualBase entry);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.IsSubobjectAgnosticVisitor : object {
    public sealed virtual bool Visit(ICppClassResolveEntity e);
    public sealed virtual bool Visit(ICppStatementResolveEntity e);
    public sealed virtual bool Visit(ICppRequiresExpressionScopeResolveEntity e);
    public sealed virtual bool Visit(CppRequiresExpressionItemResolveEntity e);
    public sealed virtual bool Visit(ICppParameterListResolveEntity e);
    public sealed virtual bool Visit(ICppDeclaratorResolveEntity e);
    public sealed virtual bool Visit(ICppConceptDefinitionResolveEntity e);
    public sealed virtual bool Visit(ICppEnumeratorResolveEntity e);
    public sealed virtual bool Visit(CppNamespaceResolveEntity e);
    public sealed virtual bool Visit(CppNamespaceAliasResolveEntity e);
    public sealed virtual bool Visit(CppUsingDeclarationResolveEntity e);
    public sealed virtual bool Visit(CppClassTemplateResolveEntityPack e);
    public sealed virtual bool Visit(ICppTypeTemplateParameter e);
    public sealed virtual bool Visit(ICppTypeTemplateParameterPack e);
    public sealed virtual bool Visit(ICppExpressionTemplateParameter e);
    public sealed virtual bool Visit(ICppExpressionTemplateParameterPack e);
    public sealed virtual bool Visit(ICppTemplateTemplateParameter e);
    public sealed virtual bool Visit(ICppTemplateTemplateParameterPack e);
    public sealed virtual bool Visit(ICppGenericParameter e);
    public sealed virtual bool Visit(CppDependentResolveEntity e);
    public sealed virtual bool Visit(CppDependentDecltypeResolveEntity e);
    public sealed virtual bool Visit(CppDependentAutoTypeResolveEntity e);
    public sealed virtual bool Visit(CppDependentFunctionReturnAutoTypeResolveEntity e);
    public sealed virtual bool Visit(CppDependentDeducedClassTypePlaceholder e);
    public sealed virtual bool Visit(CppUsingDeclarationResolveEntityWithSubstitution e);
    public sealed virtual bool Visit(ICppFunctionTemplateDeclaratorResolveEntity ent);
    public sealed virtual bool Visit(ICppTypeTemplateDeclaratorResolveEntity ent);
    public sealed virtual bool Visit(ICppVariableTemplateDeclaratorResolveEntity ent);
    public sealed virtual bool Visit(CppUndeterminedSpecializationResolveEntity e);
    public sealed virtual bool Visit(CppTemplateTemplateParameterWithAppliedArgumentsResolveEntity e);
    public sealed virtual bool Visit(CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity e);
    public sealed virtual bool Visit(CppUndeterminedTemplateVariableSpecializationResolveEntity e);
    public sealed virtual bool Visit(CppSuperResolveEntity e);
    public sealed virtual bool Visit(AbstractBuiltinResolveEntity e);
    public sealed virtual bool Visit(CppDecltypeResolveEntity e);
    public sealed virtual bool Visit(CppTypeOfTypeResolveEntity e);
    public sealed virtual bool Visit(ICppDeclaratorResolveEntityPack e);
    public sealed virtual bool Visit(CppDependencyKillerResolveEntity e);
    public sealed virtual bool Visit(ICppCxxCliPropertySetResolveEntity e);
    public sealed virtual bool Visit(ICppDeductionGuide e);
    public sealed virtual bool Visit(CppUsingEnumEnumeratorResolveEntity e);
    public sealed virtual bool Visit(HlslBuiltinFunctionResolveEntity e);
    public sealed virtual bool Visit(BlockShadersResolveEntity e);
}
public interface JetBrains.ReSharper.Psi.Cpp.Symbols.ITextRangesBuilder {
    public abstract virtual void Reserve(int count);
    public abstract virtual void Add(int begin, int end);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.LogEx : object {
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void TraceWithThread(ILog this, string message);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void TraceWithThread(ILog this, string message, T1 t1);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.Modules.HlslBuiltinFunctionModuleEntity : object {
    [CompilerGeneratedAttribute]
private HlslKnownBuiltinFunction <ref>P;
    [CompilerGeneratedAttribute]
private ICppModuleEntity <parent>P;
    public HlslBuiltinFunctionModuleEntity(HlslKnownBuiltinFunction ref, ICppModuleEntity parent);
    public sealed virtual CppModuleEntityKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
    public sealed virtual void Unmarshal(CppModuleUnmarshallingContext context, CppBinaryStreamReader& input);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.NameAndStructuralParent : ValueType {
    public ICppResolveEntityParentScope structuralParent;
    public Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> mapping;
    private ICppScopeResolveEntity lexicalParent;
    private CppLocationAnchor anchor;
    private List`1<CppTemplateParametersBase> templParams;
    private bool templateParamsOrphaned;
    private CppQualifiedNamePart replacedName;
    public NameAndStructuralParent(ICppResolveEntityParentScope structuralParent, Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> mapping, ICppScopeResolveEntity lexicalParent, CppLocationAnchor anchor, List`1<CppTemplateParametersBase> templParams, CppQualifiedNamePart replacedName, bool templateParamsOrphaned);
    public void InjectTemplateParameter(ICppTemplateParameter newParam);
    [CanBeNullAttribute]
public CppTemplateParametersBase GetTemplateParameters();
    public CppQualifiedNamePart ResolveAndCalculateName();
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.NavigateIntoNamespaceVisitor : CppAbstractResolveEntityVisitor`1<CppNamespaceResolveEntity> {
    public static NavigateIntoNamespaceVisitor INSTANCE;
    private static NavigateIntoNamespaceVisitor();
    public virtual CppNamespaceResolveEntity Visit(ICppResolveEntity e);
    public virtual CppNamespaceResolveEntity Visit(CppNamespaceResolveEntity e);
    public virtual CppNamespaceResolveEntity Visit(CppNamespaceAliasResolveEntity e);
    public virtual CppNamespaceResolveEntity Visit(CppDependentResolveEntity e);
}
internal class JetBrains.ReSharper.Psi.Cpp.Symbols.NavigateIntoVisitor : object {
    public static NavigateIntoVisitor INSTANCE;
    private static NavigateIntoVisitor();
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppClassResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppStatementResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppRequiresExpressionScopeResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppRequiresExpressionItemResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppParameterListResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppDeclaratorResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppConceptDefinitionResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppEnumeratorResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppNamespaceResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppNamespaceAliasResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppUsingDeclarationResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppClassTemplateResolveEntityPack e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppTypeTemplateParameter e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppTypeTemplateParameterPack e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppExpressionTemplateParameter e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppExpressionTemplateParameterPack e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppTemplateTemplateParameter e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppTemplateTemplateParameterPack e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppGenericParameter e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppDependentResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppDependentDecltypeResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppDependentAutoTypeResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppDependentFunctionReturnAutoTypeResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppDependentDeducedClassTypePlaceholder e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppUsingDeclarationResolveEntityWithSubstitution e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppUndeterminedSpecializationResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppTemplateTemplateParameterWithAppliedArgumentsResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppDecltypeResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppTypeOfTypeResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppDeclaratorResolveEntityPack e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppUndeterminedTemplateVariableSpecializationResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppSuperResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(AbstractBuiltinResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppFunctionTemplateDeclaratorResolveEntity ent);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppTypeTemplateDeclaratorResolveEntity ent);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppVariableTemplateDeclaratorResolveEntity ent);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppDependencyKillerResolveEntity ent);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppCxxCliPropertySetResolveEntity ent);
    public sealed virtual ICppScopeLikeResolveEntity Visit(ICppDeductionGuide ent);
    public sealed virtual ICppScopeLikeResolveEntity Visit(CppUsingEnumEnumeratorResolveEntity e);
    public sealed virtual ICppScopeLikeResolveEntity Visit(HlslBuiltinFunctionResolveEntity ent);
    public sealed virtual ICppScopeLikeResolveEntity Visit(BlockShadersResolveEntity e);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.ResolveEntityPredicates : object {
    [ExtensionAttribute]
public static bool TagIsNoTag(ICppResolveEntity ent, CppViewPos& vp);
    [ExtensionAttribute]
public static bool IsHiddenFriend(ICppFunctionDeclaratorResolveEntity dent, CppViewPos& vp);
    private static bool IsHiddenFriend(ICppGroupedFunctionDeclaratorResolveEntity groupedDecl, CppLocationAnchor anchor);
    [ExtensionAttribute]
public static bool IsType(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsTypeOrTemplate(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsValue(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool CanBeQualifier(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsTypeTemplate(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsTemplate(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool SuitsForSubstitution(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsNamespace(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsGlobalNamespace(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsClassMemberDeclaratorOrTemplateDeclarator(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsConstructorDeclarator(ICppResolveEntity ent);
    private static bool IsNameOfConstructor(ICppResolveEntity decl, ICppClassResolveEntity clsT);
    [ExtensionAttribute]
public static bool IsNonStaticConstructorDeclarator(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsDefaultConstructorDeclarator(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsCopyConstructorDeclarator(ICppFunctionDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool IsMoveConstructorDeclarator(ICppFunctionDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool IsCopyOrMoveConstructorDeclarator(ICppFunctionDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool IsCopyOrMoveConstructorDeclarator(ICppFunctionDeclaratorResolveEntity ent, CppQualType& argType);
    [ExtensionAttribute]
public static bool IsInitListConstructorDeclarator(ICppFunctionOrTemplateDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool IsAssignmentOperatorDeclarator(ICppFunctionDeclaratorResolveEntity func);
    [ExtensionAttribute]
public static bool IsAssignmentOperatorDeclarator(ICppGroupedFunctionDeclaratorResolveEntity func);
    [ExtensionAttribute]
public static bool IsAssignmentOperatorDeclarator(ICppGroupedFunctionDeclaratorResolveEntity func, CppQualType& argType);
    private static CppQualType GetFunctionType(ICppFunctionDeclaratorResolveEntity func, ICppResolvedTypeFactory tf);
    private static CppQualType GetGroupedFunctionType(ICppGroupedFunctionDeclaratorResolveEntity func, ICppResolvedTypeFactory tf);
    private static bool IsAssignmentOperatorDeclarator(TFunc func, Func`3<TFunc, ICppResolvedTypeFactory, CppQualType> functionTypeFunc, CppQualType& argType);
    [ExtensionAttribute]
public static bool IsMoveAssignmentOperatorDeclarator(ICppFunctionDeclaratorResolveEntity func);
    [ExtensionAttribute]
public static bool IsConversionOperatorDeclarator(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsNonConversionOperatorDeclarator(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsNonConversionOperatorDeclarator(ICppResolveEntity ent, CppOperatorId& operatorId);
    [ExtensionAttribute]
public static bool IsDestructorDeclarator(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsCliFinalizerDeclarator(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsFunctionDeclaratorOrTemplateFunctionPack(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsFunctionTemplateDeclaratorPack(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsFunctionTemplate(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsFunctionOrFunctionTemplate(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsFunction(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsHlslBuiltinFunction(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsClass(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsClassDataMember(ICppDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool IsClassNonStaticDataMember(ICppDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool IsStaticClassMemberDeclarator(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsNonStaticClassMemberDeclarator(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsClassDataOrFunctionMember(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsBuiltinOperatorEntity(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsFunctionParameterDeclarator(ICppDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool IsTypeDependentValue(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsTypeDependentType(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsCurrentInstantiation(ICppClassResolveEntity cls, CppViewPos& viewPos);
    [ExtensionAttribute]
public static bool IsDependentAndNotCurrentInstantiationClass(ICppClassResolveEntity cls, CppViewPos& viewPos);
    [ExtensionAttribute]
public static bool IsTypeDependentResolveEntity(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsUserProvidedMember(ICppGroupedFunctionDeclaratorResolveEntity member);
    [ExtensionAttribute]
public static bool HasUserProvidedDefaultConstructor(ICppClassResolveEntity classEnt);
    [ExtensionAttribute]
public static bool IsDefaultedMember(ICppFunctionDeclaratorResolveEntity declEnt);
    [ExtensionAttribute]
public static bool IsDeletedFunction(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsImplicitlyDeletedDefaultedMoveSpecialFunction(ICppGroupedFunctionDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool IsImplicitlyGeneratedMember(CppGroupedFunctionDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool IsImplicitlyGeneratedMember(ICppFunctionDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool IsImplicitlyGeneratedEqualityOperator(ICppFunctionDeclaratorResolveEntity func);
    [ExtensionAttribute]
public static bool IsInheritedCtor(ICppFunctionDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool IsUE4Generated(ICppFunctionDeclaratorResolveEntity func);
    [ExtensionAttribute]
public static bool IsCompilerIntrinsic(ICppDeclaratorResolveEntity decl);
    [ExtensionAttribute]
public static bool IsEnumerator(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsAnonymousClass(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsGlobal(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsGlobalVariable(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsInterface(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsEnum(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsTypedef(ICppResolveEntity declarator);
    [ExtensionAttribute]
public static bool IsTypedef(ICppDeclaratorResolveEntity declarator);
    [ExtensionAttribute]
public static bool IsLocalVariableScope(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsLocalVariable(ICppDeclaratorResolveEntity entity);
    [ExtensionAttribute]
public static bool IsAnonymousNamespaceMember(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool HasAnonymousNamePartInQualifiedName(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsGlobalStaticDeclarator(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsGlobalStaticDeclarator(ICppDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool IsGlobalOrStaticDeclarator(ICppDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool WantsReturnType(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsNonQualifiedDeclarator(ICppDeclaratorResolveEntity entity);
    private static bool HasNonQualifiedSymbol(ICppDeclaratorResolveEntity entity);
    [ExtensionAttribute]
public static bool IsDeclaratorInClassScope(ICppDeclaratorResolveEntity entity);
    [ExtensionAttribute]
public static bool IsNonFriendDeclaratorInClassScope(ICppDeclaratorResolveEntity entity);
    [ExtensionAttribute]
public static bool IsDeclaratorInNamespaceScope(ICppDeclaratorResolveEntity entity);
    [ExtensionAttribute]
public static bool IsPureFunction(ICppDeclaratorResolveEntity entity);
    [ExtensionAttribute]
public static bool IsTemplateParameter(ICppResolveEntity entity);
    [ExtensionAttribute]
public static bool IsExpressionTemplateParameter(ICppDeclaratorResolveEntity entity);
    [ExtensionAttribute]
public static bool IsSpecialMemberFunction(ICppFunctionDeclaratorResolveEntity entity);
    [ExtensionAttribute]
public static bool IsFirstFunctionDeclaration(ICppFunctionDeclaratorResolveEntity entity);
    [ExtensionAttribute]
public static bool IsCliPropertyOrEvent(ICppResolveEntity entity);
    [ExtensionAttribute]
public static bool IsCliPropertyAccessor(ICppDeclaratorResolveEntity entity);
    [ExtensionAttribute]
public static bool IsCliInterfaceMember(ICppResolveEntity entity);
    [ExtensionAttribute]
public static bool IsCliNonInterfaceClassMember(ICppResolveEntity entity);
    [ExtensionAttribute]
public static bool IsCliClassOrInterfaceMember(ICppResolveEntity entity);
    [ExtensionAttribute]
public static bool IsCliClassOrInterface(ICppResolveEntity entity);
    [ExtensionAttribute]
public static bool IsMSNativeEvent(ICppResolveEntity entity);
    [ExtensionAttribute]
public static bool IsLiteralOperator(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsStaticClassMember(ICppResolveEntity e);
    [ExtensionAttribute]
public static bool IsTypeConceptDefinition(ICppConceptDefinitionTemplateResolveEntity definition);
    [ExtensionAttribute]
public static bool IsNewOrDeleteOperator(ICppDeclaratorResolveEntity decl);
    [ExtensionAttribute]
public static bool IsCpp23StaticOperator(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsHlslBuiltinSwizzlingEntity(ICppResolveEntity entity);
    [ExtensionAttribute]
public static bool IsExplicitInstantiation(ICppResolveEntity entity);
    [ExtensionAttribute]
public static bool IsTypeAlias(ICppDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool IsStructuredBinding(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsStructuredBindingDeclaration(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsLValueRefStructuredBinding(ICppResolveEntity resolveEntity);
    [ExtensionAttribute]
public static bool IsAggregateClass(ICppClassResolveEntity classEnt, CppLanguageDialect dialect, bool allowDependent);
    private static bool HasInheritedConstructors(ICppClassResolveEntity cent);
    [ExtensionAttribute]
public static bool IsAggregateClassOrCStruct(ICppClassResolveEntity entity, CppLanguageDialect dialect, bool allowDependent);
    [ExtensionAttribute]
public static bool IsAggregateClassOrCStruct(ICppClassResolveEntity entity, CppLanguageDialect dialect);
    [ExtensionAttribute]
public static TriBool IsLiteralClass(ICppClassResolveEntity classEnt, CppLanguageDialect dialect);
    [ExtensionAttribute]
public static bool CanHaveDefaultSpecifier(ICppFunctionDeclaratorResolveEntity entity);
    [ExtensionAttribute]
public static bool HasUserConstructor(ICppClassResolveEntity ent, CppViewPos& viewPos);
    [ExtensionAttribute]
public static bool HasUserDeclaredDestructor(ICppClassResolveEntity ent);
    [ExtensionAttribute]
public static bool IsDeductionGuide(ICppResolveEntity ent);
    [ExtensionAttribute]
public static bool IsBitfield(ICppDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool IsUngroupedTypedefComeOnlyFromGGDeclareHungarianDirective(ICppTypeDeclaratorResolveEntity ungrouped);
    [ExtensionAttribute]
public static bool IsTypedefComeOnlyFromGGDeclareHungarianDirective(ICppGroupedTypeDeclaratorResolveEntity ent);
    [ExtensionAttribute]
public static bool IsDeclaratorPackComeOnlyFromGGDeclareHungarianDirective(ICppDeclaratorResolveEntityPack pack);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.ResolveEntityPrettyPrinter : object {
    public static string GetFullName(ICppResolveEntity ent);
    public static string GetFullName(ICppScopeResolveEntity sc);
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.RsCppBuiltinNames : object {
    public static CppQualifiedId type_name;
    public static CppQualifiedId enumerator_name;
    public static CppQualifiedId array_rank;
    public static CppQualifiedId array_extent;
    private static RsCppBuiltinNames();
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.RsCppNoDeduceUtil : object {
    public static CppQualifiedId TemplateName;
    public static CppQualifiedId InnerTypedefName;
    private static RsCppNoDeduceUtil();
    public static CppQualType WrapTypeResolved(CppQualType arg, CppViewPos& viewPos);
    public static CppQualType WrapTypeResolved(CppQualType arg, ICppResolveEntity scope);
    public static CppQualType UnwrapIfNoDeduce(CppQualType type);
    public static CppQualType Unwrap(CppTypedefType typedefType);
    public static CppQualType Unwrap(CppDependentType depType);
    public static CppQualType Unwrap(ICppResolveEntity entity);
    private static CppQualType Unwrap(CppDependentResolveEntity depEntity);
    private static CppQualType Unwrap(ICppGroupedTypeDeclaratorResolveEntity typeEntity);
    private static CppQualType ExtractSingleType(ICppTemplateArgument[] arguments);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.SubstitutedTemplateDeductionGuide : CppGroupedFunctionDeclaratorResolveEntity {
    private ICppTemplateDeductionGuide myTemplateDeductionGuide;
    public IEnumerable`1<ICppSymbol> SymbolParts { get; }
    public SubstitutedTemplateDeductionGuide(CppQualType funcType, CppAttributeList attributes, ICppResolveEntity structuralParent, CppQualifiedNamePart name, ICppTemplateDeductionGuide templateDeductionGuide, ICppResolvedExpression requiresClause, CppViewPos& pointOfInstantiation);
    public virtual IEnumerable`1<ICppSymbol> get_SymbolParts();
    public sealed virtual ICppTemplateDeductionGuide GetTemplateDeductionGuide();
    public virtual int GetFirstDefaultArgIndex();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.SymbolLocationComparator : object {
    public static GenericSymbolLocationComparator`1<ICppSymbol> INSTANCE;
    private static SymbolLocationComparator();
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.UsingDeclarationTargets : object {
    public bool AreConstructors;
    public FrugalLocalList`1<ICppResolveEntity> Entities;
    public CppSubstitutionContext ExpansionClosure;
    public bool IsPackExpansion;
    public UsingDeclarationTargets Pattern { get; }
    public UsingDeclarationTargets(bool constructors, FrugalLocalList`1<ICppResolveEntity> entities);
    public UsingDeclarationTargets(bool constructors, FrugalLocalList`1<ICppResolveEntity> entities, bool isPackExpansion, CppSubstitutionContext expansionClosure);
    public UsingDeclarationTargets get_Pattern();
}
public static class JetBrains.ReSharper.Psi.Cpp.Symbols.Util.CppFunctionDefinitionUtil : object {
    public static FunctionImplementations GetMissingImplementations(CppGroupedFunctionDeclaratorResolveEntity function);
    public static FunctionImplementations GetMissingImplementations(ICppDeclaratorResolveEntity declEnt, ICppLinkageEntity linkageEntity, CppGlobalSymbolCache cache);
    public static CppGroupedFunctionDeclaratorResolveEntity GetDeclaratorForImplementationType(CppGroupedFunctionDeclaratorResolveEntity originalDeclarator, FunctionImplementations targetType);
    public static FrugalLocalList`1<CppGroupedFunctionDeclaratorResolveEntity> GetDeclaratorsForImplementationTypes(CppGroupedFunctionDeclaratorResolveEntity originalDeclarator, FunctionImplementations targetTypes);
}
public class JetBrains.ReSharper.Psi.Cpp.Symbols.WhereClauseBuilder : object {
    private CppTemplateDeclarationBuilder myTemplDecl;
    private CppList`1<CppSymbolConstraintClause> myClauses;
    private CppViewPos myViewPosForConstraints;
    public WhereClauseBuilder(CppTemplateDeclarationBuilder templDecl);
    public CppTemplateDeclarationBuilder GetTemplateDeclarationBuilder();
    public void LearnConstaintClause(CppGenericConstraintClauseBuilder clause);
    public CppList`1<CppSymbolConstraintClause> GetClauses();
    public CppViewPos GetViewPosForConstraints();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.AbstractDeclarator : NonNestedDeclaratorBase {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    protected virtual CppViewPos GetViewPosByResolveEntity(ICppDeclaratorResolveEntity ent);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.AbstractDeclaratorName : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.AccessSpecifier : CppCompositeNode {
    public NodeType NodeType { get; }
    [CanBeNullAttribute]
public ITokenNode AccessSpecifierToken { get; }
    public CppAccessibility Accessibility { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_AccessSpecifierToken();
    public CppAccessibility get_Accessibility();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.AliasDeclaration : BaseNamedSymbolNode`1<CppAliasDeclarationSymbol> {
    public NodeType NodeType { get; }
    public TypeId TypeIdNode { get; }
    public AliasDeclarationName AliasDeclarationNameNode { get; }
    [CanBeNullAttribute]
public ITokenNode SemicolonNode { get; }
    public ITokenNode UsingNode { get; }
    public AliasDeclaration(ICppSymbol symbol);
    public virtual NodeType get_NodeType();
    public TypeId get_TypeIdNode();
    public AliasDeclarationName get_AliasDeclarationNameNode();
    public ITokenNode get_SemicolonNode();
    public ITokenNode get_UsingNode();
    public virtual CppTreeElementRange GetNameTokenRange();
    public CppAliasDeclarationResolveEntity GetResolveEntity();
    public sealed virtual CppViewPos GetViewPos();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.AliasDeclarationName : BaseQualifiedName {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.AliasDeclarationNameNavigator : object {
    public static AliasDeclarationName GetByNamePart(ITreeNode namePart);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.AliasDeclarationNavigator : object {
    public static AliasDeclaration GetByName(AliasDeclarationName name);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.AlignmentSpecifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.AlignOfExpression : CppExpressionNodeWithCachedDepInfo {
    public ICppTypeIdOrExpressionNode Operand { get; }
    public NodeType NodeType { get; }
    public ICppTypeIdOrExpressionNode get_Operand();
    public virtual NodeType get_NodeType();
    public sealed virtual ICppTypeIdOrExpression GetArgument();
    public sealed virtual CppViewPos GetViewPos();
    public virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public virtual TResult Accept(ICppExpressionNodeVisitor`1<TResult> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.AmpRestrictionSpecifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public void ParseRestrictionSpecifiers(CppRestrictionSpecifiersBuilder& builder);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ArraySizeSpecifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public ICppExpressionNode ConstantExpression { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public virtual NodeType get_NodeType();
    public ICppExpressionNode get_ConstantExpression();
    public ITokenNode get_LBracket();
    public ITokenNode get_RBracket();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.ArraySizeSpecifierNavigator : object {
    public static ArraySizeSpecifier GetByConstantExpression(ICppExpressionNode expr);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.AsmDefinition : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.Attribute : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public CppAttributeName GetAttributeName();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.AttributeList : CppCompositeNode {
    public NodeType NodeType { get; }
    public CppList`1<Attribute> Attributes { get; }
    public virtual NodeType get_NodeType();
    public CppList`1<Attribute> get_Attributes();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.AttributeListNavigator : object {
    public static AttributeList GetByAttribute(Attribute attr);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.AwaitReadyReference`1 : CoroutineReferenceBase`1<TNode> {
    public AwaitReadyReference`1(TNode expr);
    public virtual ResolveResultWithInfo ResolveWithoutCache();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.AwaitResumeReference`1 : CoroutineReferenceBase`1<TNode> {
    public AwaitResumeReference`1(TNode expr);
    public virtual ResolveResultWithInfo ResolveWithoutCache();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.AwaitSuspendReference`1 : CoroutineReferenceBase`1<TNode> {
    public AwaitSuspendReference`1(TNode expr);
    public virtual ResolveResultWithInfo ResolveWithoutCache();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.AwaitTransformReference`1 : CoroutineReferenceBase`1<TNode> {
    public AwaitTransformReference`1(TNode expr);
    public virtual ResolveResultWithInfo ResolveWithoutCache();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.BaseClause : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode Colon { get; }
    public CppList`1<BaseSpecifier> BaseSpecifierNodes { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_Colon();
    public CppList`1<BaseSpecifier> get_BaseSpecifierNodes();
    public sealed virtual CppViewPos GetViewPos();
    public EnumBase GetEnumBase();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.BaseClauseNavigator : object {
    public static BaseClause GetByBaseSpecifier(BaseSpecifier baseSpecifier);
    public static BaseClause GetByBaseQualifiedReference(QualifiedBaseTypeReference baseTypeReference);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.BaseDeclaration : CppCompositeNode {
    private static NodeTypeSet NODE_TYPES;
    public DeclarationSpecifiers DeclarationSpecifiersNode { get; }
    public ICppNonNestedDeclaratorNode FirstDeclarator { get; }
    public ICppNonNestedDeclaratorNode LastDeclarator { get; }
    private static BaseDeclaration();
    public DeclarationSpecifiers get_DeclarationSpecifiersNode();
    public CppList`1<ICppNonNestedDeclaratorNode> GetDeclaratorNodes();
    public int GetDeclaratorsCount();
    public ICppNonNestedDeclaratorNode get_FirstDeclarator();
    public ICppNonNestedDeclaratorNode get_LastDeclarator();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.BaseDeclarationNavigator : object {
    public static BaseDeclaration GetByDeclarator(ICppNonNestedDeclaratorNode declarator);
    public static BaseDeclaration GetBySingleDeclarator(ICppNonNestedDeclaratorNode declarator);
    public static BaseDeclaration GetByLastDeclarator(ICppNonNestedDeclaratorNode declarator);
    public static BaseDeclaration GetByClassSpecifier(IClassOrEnumSpecifier specifiers);
    public static BaseDeclaration GetByDeclarationSpecifiers(DeclarationSpecifiers declSpecs);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.BaseDeclaratorNode : CppCompositeNode {
    public NestedDeclarator NestedDeclaratorNode { get; }
    public virtual CppViewPos GetViewPos();
    public virtual NestedDeclarator get_NestedDeclaratorNode();
    public static ITreeNode GetFirstCVQualifierByPointer(ITreeNode ptrNode);
    public static ITreeNode GetNextCVQualifier(ITreeNode node);
    protected abstract virtual CppViewPos GetViewPosByResolveEntity(ICppDeclaratorResolveEntity ent);
    protected void CalculateTypePartInner(ICppResolvedTypeBuilder builder, CppTypeSelection selection);
    private static CVQualifiers GetCVQualifiersAfterPtr(ITreeNode node);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.BaseDesignatorNode : CppCompositeNode {
    private CppQualType myInferredScopeType;
    public ICppDesignatorNode Qualifier { get; }
    public sealed virtual ICppDesignatorNode get_Qualifier();
    public sealed virtual ICppDesignator GetQualifier();
    public virtual CppQualType GetInferredScopeType();
    public sealed virtual void SetInferredScopeType(CppQualType type);
    public abstract virtual TResult Accept(ICppDesignatorVisitor`1<TResult> visitor);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.BaseNamedMacroSymbolNode`1 : BaseNamedSymbolNode`1<T> {
    public IDeclaredElement DeclaredElement { get; }
    protected BaseNamedMacroSymbolNode`1(ICppSymbol symbol);
    public virtual IDeclaredElement get_DeclaredElement();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.BaseNamedSymbolNode`1 : BaseSymbolNode`1<T> {
    public IDeclaredElement DeclaredElement { get; }
    public string DeclaredName { get; }
    protected BaseNamedSymbolNode`1(ICppSymbol symbol);
    public abstract virtual CppTreeElementRange GetNameTokenRange();
    public virtual XmlNode GetXMLDoc(bool inherit);
    public virtual bool IsSynthetic();
    public virtual IDeclaredElement get_DeclaredElement();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.BaseNavigator`1 : object {
    public static TreeNode GetByChild(ITreeNode node);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.BaseQualifiedName : CppCompositeNode {
    [CanBeNullAttribute]
public NameQualifier Qualifier { get; }
    [CanBeNullAttribute]
public ITreeNode NamePart { get; }
    [CanBeNullAttribute]
public ITokenNode NamePartTilde { get; }
    [CanBeNullAttribute]
public ITokenNode NamePartExcl { get; }
    [CanBeNullAttribute]
public DecltypeSpecifier DecltypeSpec { get; }
    [CanBeNullAttribute]
public ITokenNode SuperSpec { get; }
    [CanBeNullAttribute]
public TypeId CliSimpleTypeId { get; }
    [CanBeNullAttribute]
public TemplateArgumentList TemplateArgumentListNode { get; }
    public virtual CppQualifiedName GetQualifiedName();
    public CppQualifiedNamePart GetNamePart();
    public NameQualifier get_Qualifier();
    public ITreeNode get_NamePart();
    public ITokenNode get_NamePartTilde();
    public ITokenNode get_NamePartExcl();
    public DecltypeSpecifier get_DecltypeSpec();
    public ITokenNode get_SuperSpec();
    public TypeId get_CliSimpleTypeId();
    public TemplateArgumentList get_TemplateArgumentListNode();
    public virtual CppTreeElementRange GetNameTokenRange();
    public bool CanAddQualifier(NameQualifier newQualifier);
    public NameQualifier AddQualifier(NameQualifier newQualifier);
    public bool CanAddTemplateArgumentList(TemplateArgumentList newArgumentList);
    public bool AddTemplateArgumentList(TemplateArgumentList newArgumentList);
    protected void BuildQualifiedName(CppQualifiedNameBuilder& builder, bool withQualifier);
    private static void LearnTemplateArgumentList(ITreeNode templArgumentList, CppTemplateArgumentsBuilder templArgsBuilder);
    protected virtual CppQualifiedName GetNameAfterBuildCompletes(CppQualifiedNameBuilder& nb);
    private CppQualifiedName GetQualifiedNameImpl(bool withQualifier);
    private bool CanBePartOfName(ITreeNode node);
    private static ITreeNode AnchorForQualifier(BaseQualifiedName name);
    private static ITreeNode AnchorForArgumentList(BaseQualifiedName name);
    [CompilerGeneratedAttribute]
internal static bool <LearnTemplateArgumentList>g__NextTokenIsEllipsis|24_0(ITreeNode node);
    [CompilerGeneratedAttribute]
internal static void <LearnTemplateArgumentList>g__LearnQualifiedReference|24_1(QualifiedReference qualRef, CppTemplateArgumentsBuilder templArgsBuilder, CppQualifiedName qualName, bool isPackExpansion, bool hadTypename);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.BaseQualifiedNameNavigator : object {
    public static BaseQualifiedName GetByTemplateArgumentList(TemplateArgumentList argList);
    public static BaseQualifiedName GetByOperatorFunctionId(OperatorFunctionId id);
    public static BaseQualifiedName GetByQualifier(NameQualifier qual);
    public static BaseQualifiedName GetByNamePart(ITreeNode namePart);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.BaseQualifiedReference : BaseQualifiedName {
    private ICppReference myReference;
    [CanBeNullAttribute]
public ITokenNode TypenameKeyword { get; }
    [CanBeNullAttribute]
public ITokenNode TemplateKeyword { get; }
    [CanBeNullAttribute]
public ITokenNode Identifier { get; }
    [CanBeNullAttribute]
public OperatorFunctionId OperatorFunctionId { get; }
    protected virtual void PreInit();
    public CppResolveResult GetCppResolveResult();
    public sealed virtual ReferenceCollection GetFirstClassReferences();
    public ICppReference GetReference();
    public abstract virtual CppLookupResult LookupReferenceWithCustomName(CppQualifiedName name);
    public virtual CppResolveResult ResolveReferenceWithCustomName(CppQualifiedName name);
    public ITokenNode get_TypenameKeyword();
    public ITokenNode get_TemplateKeyword();
    public ITokenNode get_Identifier();
    public OperatorFunctionId get_OperatorFunctionId();
    public virtual void DropReferences();
    public virtual string GetNameOfReference();
    protected virtual ICppReference CreateReference();
    protected virtual CppQualifiedName GetNameAfterBuildCompletes(CppQualifiedNameBuilder& nb);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.BaseQualifiedReferenceNavigator : object {
    public static BaseQualifiedReference GetOutermostReference(BaseQualifiedReference ref);
    public static BaseQualifiedReference GetByTemplateArgumentList(TemplateArgumentList list);
    public static BaseQualifiedReference GetByIdentifier(ITokenNode identifier);
    public static BaseQualifiedReference GetByOperatorFunctionId(OperatorFunctionId operatorFunctionId);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.BaseSpecifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode PublicAccessSpecifierNode { get; }
    public ITokenNode ProtectedAccessSpecifierNode { get; }
    public ITokenNode PrivateAccessSpecifierNode { get; }
    public QualifiedBaseTypeReference QualifiedBaseTypeReferenceNode { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_PublicAccessSpecifierNode();
    public ITokenNode get_ProtectedAccessSpecifierNode();
    public ITokenNode get_PrivateAccessSpecifierNode();
    public QualifiedBaseTypeReference get_QualifiedBaseTypeReferenceNode();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.BaseSpecifierNavigator : object {
    [CanBeNullAttribute]
public static BaseSpecifier GetByTypeReference(QualifiedBaseTypeReference baseTypeReference);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.BaseSymbolNode`1 : CppCompositeNode {
    private ICppSymbol mySymbol;
    protected BaseSymbolNode`1(ICppSymbol symbol);
    public virtual T GetSymbol();
    public virtual ICppSymbol GetGenericSymbol();
    protected void SetSymbol(ICppSymbol symbol);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.BaseTypeGenericConstraintItem : DeclarationSpecifiersBase {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public GenericConstraint GetGenericConstraint();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.BinaryExpression : CppExpressionNodeWithCachedDepInfo {
    private BinaryOperatorReference myReference;
    public NodeType NodeType { get; }
    public ICppExpressionNode LeftOperand { get; }
    public ICppExpressionNode RightOperand { get; }
    public ITokenNode Operator { get; }
    public ICppReference FirstClassRef { get; }
    public virtual NodeType get_NodeType();
    public ICppExpressionNode get_LeftOperand();
    public ICppExpressionNode get_RightOperand();
    public ITokenNode get_Operator();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual ICppExpression GetLeftArgument();
    public sealed virtual ICppExpression GetRightArgument();
    public sealed virtual ICppResolvedExpression GetResolvedLeftArgument();
    public sealed virtual ICppResolvedExpression GetResolvedRightArgument();
    public sealed virtual CppOperatorKind GetOperatorKind();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppResolveResult GetResolvedOperator();
    public virtual TriBool IsNoexcept();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    public virtual void DropReferences();
    public ICppReference get_FirstClassRef();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.BinaryExpressionNavigator : object {
    public static BinaryExpression GetByLeftOperand(ICppExpressionNode expr);
    public static BinaryExpression GetByLeftOperandThroughParens(ICppExpressionNode expr);
    public static BinaryExpression GetByRightOperand(ICppExpressionNode expr);
    public static BinaryExpression GetByRightOperandThroughParens(ICppExpressionNode expr);
    public static BinaryExpression GetByOperand(ICppExpressionNode expr);
    public static BinaryExpression GetByOperandThroughParens(ICppExpressionNode expr);
    public static BinaryExpression GetByOperator(ITokenNode tokNode);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.BitfieldDeclarator : NonAbstractDeclaratorBase {
    public NodeType NodeType { get; }
    public BitfieldDeclarator(ICppDeclaratorSymbol symbol);
    public virtual NodeType get_NodeType();
    protected virtual CppViewPos GetViewPosByResolveEntity(ICppDeclaratorResolveEntity ent);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.BooleanExpressionNode : CppExpressionNodeWithCachedDepInfo {
    public virtual CppQualType GetVerboseType();
    public virtual CppTypeAndCategory GetTypeAndCategory();
    public virtual CppTypeAndCategory GetVerboseTypeAndCategory();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.BracedInitList : CppExpressionNodeWithCachedDepInfo {
    public static string ReferenceName;
    private BracedInitListReference myReference;
    private CppQualType myInferredType;
    public NodeType NodeType { get; }
    public CppList`1<ICppExpressionNode> Arguments { get; }
    public CppList`1<ITokenNode> Commas { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public CppList`1<Designation> Designations { get; }
    public virtual NodeType get_NodeType();
    public virtual ReferenceCollection GetFirstClassReferences();
    public ICppSubordinateReference GetReference();
    public sealed virtual ICppExpression[] GetArguments();
    public sealed virtual CppArgumentListKind GetArgListKind();
    public sealed virtual bool HasBeenShrinked();
    public sealed virtual CppList`1<ICppExpressionNode> get_Arguments();
    public sealed virtual CppList`1<ITokenNode> get_Commas();
    public sealed virtual int GetArgumentsCount();
    public sealed virtual ICppExpressionNode GetFirstArgument();
    public sealed virtual ICppExpressionNode GetLastArgument();
    public ITokenNode get_LBrace();
    public ITokenNode get_RBrace();
    public sealed virtual ITokenNode get_LBracket();
    public sealed virtual ITokenNode get_RBracket();
    public CppList`1<Designation> get_Designations();
    public CppQualType GetCppType();
    public virtual CppQualType GetVerboseType();
    public virtual CppTypeAndCategory GetTypeAndCategory();
    public virtual CppTypeAndCategory GetVerboseTypeAndCategory();
    public CppQualType GetInferredType();
    public void SetInferredType(CppQualType type);
    public CppResolveResult GetCppResolveResult();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    public virtual void DropReferences();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
    private CppQualType DeduceRangeType(ICppResolvedTypeFactory tf);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.BracedInitListNavigator : object {
    public static BracedInitList GetByDesignation(Designation designation);
    public static BracedInitList GetByArgument(ICppExpressionNode expr);
    public static BracedInitList GetByArgumentThoughParens(ICppExpressionNode expr);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.BraceInitializedTemporary : CppExpressionNodeWithCachedDepInfo {
    public NodeType NodeType { get; }
    public ICppTypeIdOrQualifiedReference InitializerTypeNode { get; }
    public BracedInitList InitList { get; }
    public virtual NodeType get_NodeType();
    public ICppTypeIdOrQualifiedReference get_InitializerTypeNode();
    public BracedInitList get_InitList();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public sealed virtual ICppTypeIdOrExpression GetInitializerTypeNode();
    public sealed virtual ICppBracedInitListExpression GetArgumentList();
    public sealed virtual ICppResolvedBracedInitListExpression GetResolvedArgumentList();
    public sealed virtual CppResolveResult GetResolvedOperator();
    public sealed virtual CppViewPos GetViewPos();
    public virtual TriBool IsNoexcept();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.BraceInitializedTemporaryNavigator : object {
    public static BraceInitializedTemporary GetByInitializerTypeNode(ICppTypeIdOrQualifiedReference typeNode);
    public static BraceInitializedTemporary GetByInitList(BracedInitList initList);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.BreakStatement : CppCompositeNode {
    public ITokenNode BreakKeyword { get; }
    public NodeType NodeType { get; }
    public ITokenNode get_BreakKeyword();
    public virtual NodeType get_NodeType();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.BreakStatementNavigator : object {
    public static BreakStatement GetByBreakKeyword(ITokenNode child);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.BuiltinAddressOfExpression : CppExpressionNode {
    public NodeType NodeType { get; }
    public ICppExpressionNode Argument { get; }
    public virtual NodeType get_NodeType();
    public ICppExpressionNode get_Argument();
    public sealed virtual ICppExpression GetArgument();
    public sealed virtual ICppResolvedExpression GetResolvedArgument();
    public virtual CppDependentInfo GetDependentInfo();
    public virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public virtual TResult Accept(ICppExpressionNodeVisitor`1<TResult> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.BuiltinOffsetOfExpression : CppExpressionNodeWithCachedDepInfo {
    private Nullable`1<CppResolveResult> myResolvedMember;
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public sealed virtual CppQualType GetTypeArgument();
    public sealed virtual CppQualifiedName GetMemberDesignator();
    public TypeId GetTypeId();
    public OffsetofMemberReferenceDesignator GetOffsetofMemberReferenceDesignator();
    public ICppClassResolveEntity GetResolvedType();
    public sealed virtual CppResolveResult GetResolvedMemberDesignator();
    public CppViewPos GetViewPos();
    protected virtual CppDependentInfo CalculateDependentInfo();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.BuiltinOffsetOfExpressionNavigator : object {
    public static BuiltinOffsetOfExpression GetByMemberDesignator(OffsetofMemberReferenceDesignator memberDesignator);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.BuiltinTypeTrait : CppCompositeNode {
    public NodeType NodeType { get; }
    public CppBuiltinTypeTraitKind Kind { get; }
    public virtual NodeType get_NodeType();
    public CppBuiltinTypeTraitKind get_Kind();
    public TypeId GetTypeId();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.C11GenericExpression : CppExpressionNodeWithCachedDepInfo {
    public NodeType NodeType { get; }
    public ITokenNode GenericKeyword { get; }
    public ICppExpressionNode ControllingExpression { get; }
    public CppList`1<C11GenericExpressionClauseNode> Clauses { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_GenericKeyword();
    public ICppExpressionNode get_ControllingExpression();
    public CppList`1<C11GenericExpressionClauseNode> get_Clauses();
    public sealed virtual ICppExpression GetControllingExpression();
    public sealed virtual CppC11GenericExpressionClause[] GetClauses();
    public sealed virtual ICppResolvedExpression GetResolvedControllingExpression();
    public sealed virtual ICppResolvedExpression GetResolvedResultExpression();
    public sealed virtual CppViewPos GetViewPos();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.C11GenericExpressionClauseNode : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode DefaultKeyword { get; }
    public TypeId Type { get; }
    public ICppExpressionNode Expression { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_DefaultKeyword();
    public TypeId get_Type();
    public ICppExpressionNode get_Expression();
    public CppC11GenericExpressionClause GetClause();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.C11GenericExpressionNavigator : object {
    public static C11GenericExpression GetByControllingExpression(ICppExpressionNode arg);
    public static C11GenericExpression GetByClause(C11GenericExpressionClauseNode arg);
    public static C11GenericExpressionClauseNode GetClauseByType(TypeId arg);
    public static C11GenericExpressionClauseNode GetClauseByExpression(ICppExpressionNode arg);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CallExpression : CppExpressionNodeWithCachedDepInfo {
    private CallOperatorReference myReference;
    private CastReference myCastReference;
    private CppCachedValue`1<CppResolveResult> myResolvedOperator;
    public NodeType NodeType { get; }
    public ITokenNode RaiseKeyword { get; }
    public ICppTypeIdOrExpressionNode InvokedExpression { get; }
    public FunctionArgumentList ArgumentList { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_RaiseKeyword();
    public ICppTypeIdOrExpressionNode get_InvokedExpression();
    public FunctionArgumentList get_ArgumentList();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual ICppTypeIdOrExpression GetCallee();
    public sealed virtual ICppExpression[] GetArguments();
    public sealed virtual CppCallExpressionKind GetExpressionKind();
    public sealed virtual CppResolveResult GetResolvedOperator();
    public sealed virtual CppViewPos GetViewPos();
    public virtual TriBool IsNoexcept();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    public virtual void DropReferences();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CallExpressionNavigator : object {
    public static CallExpression GetByInvokedExpression(ICppTypeIdOrExpressionNode invoked);
    public static CallExpression GetByInvokedExpressionThroughParens(ICppTypeIdOrExpressionNode invoked);
    public static CallExpression GetByArgumentList(FunctionArgumentList argList);
    public static CallExpression GetByArgumentExpression(ICppExpressionNode argument);
    public static CallExpression GetByArgumentExpressionThroughParens(ICppExpressionNode argument);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CaseStatement : CppCompositeNode {
    public ICppExpressionNode ConstantExpression { get; }
    public ITokenNode CaseKeyword { get; }
    public ITokenNode Colon { get; }
    public NodeType NodeType { get; }
    public ICppStatement Statement { get; }
    public ICppExpressionNode get_ConstantExpression();
    public ITokenNode get_CaseKeyword();
    public ITokenNode get_Colon();
    public virtual NodeType get_NodeType();
    public sealed virtual ICppStatement get_Statement();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CaseStatementNavigator : object {
    public static CaseStatement GetByCaseKeyword(ITokenNode child);
    public static CaseStatement GetByStatement(ICppStatement stmt);
    public static CaseStatement GetByConstantExpression(ICppExpressionNode expr);
    public static CaseStatement GetByInnerPartConstantExpression(ICppExpressionNode expr);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CastExpression : CppExpressionNodeWithCachedDepInfo {
    private CastOperatorReference myReference;
    private CppCachedValue`1<CppResolveResult> myResolvedOperator;
    public NodeType NodeType { get; }
    public ITokenNode CastKeyword { get; }
    public TypeId CastTypeId { get; }
    public ICppExpressionNode Expression { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_CastKeyword();
    public TypeId get_CastTypeId();
    public ICppExpressionNode get_Expression();
    public ITokenNode get_LBracket();
    public ITokenNode get_RBracket();
    public ITokenNode get_LPar();
    public ITokenNode get_RPar();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual ICppExpression GetArgument();
    public sealed virtual ICppResolvedExpression GetResolvedArgument();
    public sealed virtual CppCastType GetCastType();
    public sealed virtual CppQualType GetQualType();
    public sealed virtual CppResolveResult GetResolvedOperator();
    public sealed virtual CppViewPos GetViewPos();
    public virtual TriBool IsNoexcept();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    public virtual void DropReferences();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CastExpressionNavigator : object {
    public static CastExpression GetByInnerExpr(ICppExpressionNode node);
    public static CastExpression GetByInnerExprThoughParens(ICppExpressionNode node);
    public static CastExpression GetByTypeId(TypeId node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CatchSection : CppCompositeNode {
    public NodeType NodeType { get; }
    public CompoundStatement CompoundStatementNode { get; }
    public Declaration CatchDeclarationNode { get; }
    public ITokenNode Ellipsis { get; }
    public ITokenNode CatchKeyword { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public bool IsFinally { get; }
    public virtual NodeType get_NodeType();
    public CompoundStatement get_CompoundStatementNode();
    public Declaration get_CatchDeclarationNode();
    public ITokenNode get_Ellipsis();
    public ITokenNode get_CatchKeyword();
    public ITokenNode get_LPar();
    public ITokenNode get_RPar();
    public bool get_IsFinally();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CatchSectionNavigator : object {
    public static CatchSection GetByCatchDeclaration(Declaration declaration);
    public static CatchSection GetByCatchDeclarationDeclarator(ICppNonNestedDeclaratorNode declarator);
    public static CatchSection GetByCompoundStatement(CompoundStatement compoundStatement);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.ClassOrEnumSpecifierBase`1 : BaseNamedSymbolNode`1<T> {
    private CppLocationAnchor mySymbolAnchor;
    public ClassOrEnumSpecifierBase`1(CppClassSymbolAndAnchor symbolAndAnchor);
    public virtual CppList`1<ITokenNode> GetKeyTokens();
    public virtual CppTreeElementRange GetNameTokenRange();
    public IEnumerable`1<MSDeclSpec> GetDeclSpecs();
    public virtual ClassQualifiedName GetClassQualifiedName();
    public virtual ICppClassSymbol GetClassSymbol();
    public virtual CppLocationAnchor GetClassSymbolAnchor();
    public virtual ICppClassResolveEntity GetClassResolveEntity();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.ClassOrEnumSpecifierNavigator : object {
    public static IClassOrEnumWithBodySpecifier GetByMemberDeclaration(ICppTopLevelDeclarationNode declaration);
    public static IClassOrEnumWithBodySpecifier GetByLBrace(ITokenNode node);
    public static IClassOrEnumWithBodySpecifier GetByRBrace(ITokenNode node);
    public static IClassOrEnumSpecifier GetByDeclarationSpecifiers(DeclarationSpecifiers specifiers);
    public static IClassOrEnumSpecifier GetByClassQualifiedName(ClassQualifiedName classQualifiedName);
    public static IClassOrEnumSpecifier GetByBaseClause(BaseClause baseClause);
    public static IClassOrEnumSpecifier GetByBaseClause(EnumUnderlyingTypeClause baseClause);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.ClassOrEnumSpecifierWithBodyBase`1 : ClassOrEnumSpecifierBase`1<T> {
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public ClassOrEnumSpecifierWithBodyBase`1(CppClassSymbolAndAnchor symbolAndAnchor);
    public virtual ITokenNode get_LBrace();
    public virtual ITokenNode get_RBrace();
    public virtual ICppScopeResolveEntity GetResolveScope();
    public virtual CppDeclarationOwnerKind GetDeclarationOwnerKind();
    public virtual ICppScopeResolveEntity GetScopeForDeclarations();
    public virtual CppList`1<ICppTopLevelDeclarationNode> GetTopLevelDeclarations();
    public virtual IEnumerable`1<ICppCompositeNode> GetMembers();
    public virtual ICppTopLevelDeclarationNode GetNextDeclaration(ICppTopLevelDeclarationNode decl);
    public virtual ICppTopLevelDeclarationNode GetPrevDeclaration(ICppTopLevelDeclarationNode decl);
    public virtual TDecl AddDeclarationBefore(TDecl decl, ITreeNode anchor, bool withComments);
    public virtual bool CanAddDeclarationBefore(ITreeNode anchor);
    public virtual TDecl AddDeclarationAfter(TDecl decl, ITreeNode anchor, bool withComments);
    public virtual bool CanAddDeclarationAfter(ITreeNode anchor);
    public virtual void RemoveDeclaration(TDecl decl, CppCommentsDeleteMode commentsDeleteMode);
    public virtual CppComplexOffset GetTopComplexOffset();
    public virtual CppComplexOffset GetBottomComplexOffset();
    public virtual ITreeNode GetBodyStartAnchor();
    public virtual ITreeNode GetBodyEndAnchor();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ClassQualifiedName : BaseQualifiedName {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public sealed virtual CppViewPos GetViewPosForName();
    public static CppViewPos GetViewPosForName(IClassOrEnumSpecifier classSpecifier);
    public sealed virtual List`1<CppTemplateParametersBase> GetTemplateParameters();
    public sealed virtual CppViewPos GetViewPos();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.ClassQualifiedNameNavigator : object {
    public static ClassQualifiedName GetByQualifier(NameQualifier qual);
    public static ClassQualifiedName GetByNamePart(ITreeNode namePart);
    public static ClassQualifiedName GetByTemplateArgumentList(TemplateArgumentList list);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ClassSpecifier : ClassOrEnumSpecifierWithBodyBase`1<CppClassSymbol> {
    public NodeType NodeType { get; }
    public ITokenNode FinalNode { get; }
    public ITokenNode SealedNode { get; }
    public ITokenNode AbstractNode { get; }
    public ClassSpecifier(CppClassSymbolAndAnchor symAndAnchor);
    public virtual NodeType get_NodeType();
    public BaseClause GetBaseClause();
    public IEnumerable`1<AccessSpecifier> GetAccessSpecifiers();
    public CppAccessibility FindAccessibilityBeforeChild(ITreeNode child);
    public CppAccessibility FindAccessibilityAfterChild(ITreeNode child);
    public ITreeNode EnsureAccessiblityBefore(ITreeNode anchor, CppAccessibility accessibility);
    public ITreeNode EnsureAccessiblityAfter(ITreeNode anchor, CppAccessibility accessibility);
    public ITokenNode get_FinalNode();
    public ITokenNode get_SealedNode();
    public ITokenNode get_AbstractNode();
    public ICppNonAbstractDeclaratorNode FindUserDestructor();
    public ICppClassResolveEntity TryGetClassResolveEntityWithKilledDependencies();
    private static bool IsConstructor(SimpleDeclaration simpleDecl);
    private static ITreeNode EnsureAccessibilityBeforeAfter(ClassSpecifier that, ITreeNode anchor, CppAccessibility accessibility, bool before);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.ClassSpecifierNavigator : object {
    public static ClassSpecifier GetByChild(ITreeNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CliMultiArgumentSubscriptExpression : CppExpressionNodeWithCachedDepInfo {
    private SubscriptOperatorReference myReference;
    public NodeType NodeType { get; }
    public ICppExpressionNode LeftSideExpr { get; }
    public CppList`1<ICppExpressionNode> IndexExprs { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    private ICppReference FirstClassRef { get; }
    public virtual NodeType get_NodeType();
    public sealed virtual ICppExpressionNode get_LeftSideExpr();
    public CppList`1<ICppExpressionNode> get_IndexExprs();
    public sealed virtual ITokenNode get_LBracket();
    public sealed virtual ITokenNode get_RBracket();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual ICppExpression GetLeftArgument();
    public sealed virtual ICppResolvedExpression GetResolvedLeftArgument();
    public sealed virtual ICppExpression[] GetIndexArguments();
    public sealed virtual int GetIndexArgumentCount();
    public sealed virtual CppResolveResult GetResolvedOperator();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    private ICppReference get_FirstClassRef();
    protected virtual CppDependentInfo CalculateDependentInfo();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CliMultiArgumentSubscriptExpressionNavigator : object {
    public static CliMultiArgumentSubscriptExpression GetByIndexExpression(ICppExpressionNode index);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CliTypeIdExpression : CppExpressionNode {
    public NodeType NodeType { get; }
    public NameQualifier Argument { get; }
    public virtual NodeType get_NodeType();
    public NameQualifier get_Argument();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppLookupResult GetLookupResult();
    public sealed virtual CppQualifiedName GetArgument();
    public virtual CppDependentInfo GetDependentInfo();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CliTypeIdExpressionNavigator : object {
    public static CliTypeIdExpression GetByArgument(NameQualifier arg);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CoAwaitExpression : CppExpressionNodeWithCachedDepInfo {
    private ICppReference myAwaitTransformReference;
    private ICppReference myOperatorCoAwaitReference;
    private ICppReference myAwaitReadyReference;
    private ICppReference myAwaitSuspendReference;
    private ICppReference myAwaitResumeReference;
    private CppCachedValue`1<CppCoAwaitResolveResult> myResolveResult;
    public NodeType NodeType { get; }
    public ITokenNode CoAwaitKeyword { get; }
    public ICppExpressionNode Argument { get; }
    public virtual NodeType get_NodeType();
    public sealed virtual ITokenNode GetCoKeyword();
    public sealed virtual CppResolveResult ResolveOperatorCoAwait();
    public sealed virtual CppResolveResult ResolveAwaitReady();
    public sealed virtual CppResolveResult ResolveAwaitResume();
    public sealed virtual CppResolveResult ResolveAwaitSuspend();
    public sealed virtual CppResolveResult ResolveAwaitTransform();
    public ITokenNode get_CoAwaitKeyword();
    public ICppExpressionNode get_Argument();
    public sealed virtual ICppExpression GetArgument();
    public sealed virtual ICppResolvedExpression GetResolvedArgument();
    public sealed virtual CppCoAwaitResolveResult GetResolveResult();
    public sealed virtual CppViewPos GetViewPos();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CompoundStatement : CppCompositeNode {
    public CppCompoundStatementResolveEntity ResolveEntity;
    public NodeType NodeType { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public CppList`1<ICppStatement> Statements { get; }
    public CompoundStatement(CppCompoundStatementResolveEntity resolveEntity);
    public virtual NodeType get_NodeType();
    public virtual ITokenNode get_LBrace();
    public virtual ITokenNode get_RBrace();
    public CppList`1<ICppStatement> get_Statements();
    [CanBeNullAttribute]
public ICppStatement GetFirstStatement();
    [CanBeNullAttribute]
public ICppStatement GetLastStatement();
    public virtual T AddStatementBefore(T statement, ICppStatement anchor);
    public virtual T AddStatementBefore(T statement, ICppStatement anchor, bool withComments);
    public virtual bool CanAddStatementBefore(ICppStatement anchor);
    public virtual ITreeRange AddStatementsBefore(ITreeRange statements, ICppStatement anchor);
    public virtual ITreeRange AddStatementsBefore(ITreeRange statements, ICppStatement anchor, bool withComments);
    public virtual T AddStatementAfter(T statement, ICppStatement anchor);
    public virtual T AddStatementAfter(T statement, ICppStatement anchor, bool withComments);
    public virtual bool CanAddStatementAfter(ICppStatement anchor);
    public virtual ITreeRange AddStatementsAfter(ITreeRange statements, ICppStatement anchor);
    public virtual ITreeRange AddStatementsAfter(ITreeRange statements, ICppStatement anchor, bool withComments);
    public virtual void RemoveStatement(ICppStatement statement);
    public virtual void RemoveStatement(ICppStatement statement, CppCommentsDeleteMode commentsDeleteMode);
    public virtual void RemoveStatements(ITreeRange statements);
    public virtual void RemoveStatements(ITreeRange statements, CppCommentsDeleteMode commentsDeleteMode);
    public virtual ICppScopeResolveEntity GetResolveScope();
    public virtual ICppScopeResolveEntity GetScopeForDeclarations();
    public virtual CppDeclarationOwnerKind GetDeclarationOwnerKind();
    public virtual IEnumerable`1<ICppCompositeNode> GetMembers();
    public virtual ICppTopLevelDeclarationNode GetNextDeclaration(ICppTopLevelDeclarationNode decl);
    public virtual ICppTopLevelDeclarationNode GetPrevDeclaration(ICppTopLevelDeclarationNode decl);
    public sealed virtual T AddDeclarationBefore(T decl, ITreeNode anchor, bool withComments);
    public virtual bool CanAddDeclarationBefore(ITreeNode anchor);
    public sealed virtual T AddDeclarationAfter(T decl, ITreeNode anchor, bool withComments);
    public virtual bool CanAddDeclarationAfter(ITreeNode anchor);
    public virtual void RemoveDeclaration(T decl, CppCommentsDeleteMode commentsDeleteMode);
    public virtual CppComplexOffset GetTopComplexOffset();
    public virtual CppComplexOffset GetBottomComplexOffset();
    public virtual ITreeNode GetBodyStartAnchor();
    public virtual ITreeNode GetBodyEndAnchor();
    private static T AddDeclarationBeforeAfterImpl(CompoundStatement that, bool before, T decl, ITreeNode anchor, bool withComments);
    private static void EnsureBraces(CompoundStatement statement);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CompoundStatementExpression : CppExpressionNode {
    public CompoundStatement Statement { get; }
    public ITokenNode LParen { get; }
    public ITokenNode RParen { get; }
    public NodeType NodeType { get; }
    public CompoundStatement get_Statement();
    public ITokenNode get_LParen();
    public ITokenNode get_RParen();
    public virtual NodeType get_NodeType();
    public virtual CppDependentInfo GetDependentInfo();
    public sealed virtual CppCompoundStatementResolveEntity GetStatementResolveEntity();
    public sealed virtual ICppResolvedExpression GetResultExpression();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CompoundStatementExpressionNavigator : object {
    public static CompoundStatementExpression GetByCompoundStatement(CompoundStatement compoundStatement);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CompoundStatementNavigator : BaseNavigator`1<CompoundStatement> {
    public static CompoundStatement GetByStatement(ICppStatement statement);
    public static CompoundStatement GetByLBrace(ITokenNode tok);
    public static CompoundStatement GetByRBrace(ITokenNode tok);
    public static CompoundStatement GetByAnyBrace(ITokenNode tok);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ConceptAutoSpecifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public QualifiedConceptReference ConceptReference { get; }
    public ITokenNode DecltypeKeyword { get; }
    public virtual NodeType get_NodeType();
    public QualifiedConceptReference get_ConceptReference();
    public ITokenNode get_DecltypeKeyword();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ConceptDefinition : BaseNamedSymbolNode`1<CppConceptDefinitionSymbol> {
    public NodeType NodeType { get; }
    public ConceptQualifiedName Name { get; }
    public ICppExpressionNode Expression { get; }
    public ConceptDefinition(CppConceptDefinitionSymbol declSymbol);
    public sealed virtual CppViewPos GetViewPos();
    public ICppConceptDefinitionResolveEntity GetResolveEntity();
    public virtual NodeType get_NodeType();
    public ConceptQualifiedName get_Name();
    public ICppExpressionNode get_Expression();
    public virtual CppTreeElementRange GetNameTokenRange();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ConceptDefinitionNavigator : object {
    public static ConceptDefinition GetByName(ConceptQualifiedName name);
    public static ConceptDefinition GetByExpression(ICppExpressionNode expr);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ConceptParameter : BaseNamedSymbolNode`1<ICppTemplateParameterSymbol> {
    public NodeType NodeType { get; }
    public QualifiedConceptReference Concept { get; }
    public ITreeNode Identifier { get; }
    public TypeId DefaultType { get; }
    public ICppExpressionNode DefaultExpression { get; }
    public QualifiedTemplateReference DefaultTemplate { get; }
    public ConceptParameter(ICppSymbol sym);
    public virtual NodeType get_NodeType();
    public QualifiedConceptReference get_Concept();
    public ITreeNode get_Identifier();
    public TypeId get_DefaultType();
    public ICppExpressionNode get_DefaultExpression();
    public QualifiedTemplateReference get_DefaultTemplate();
    public sealed virtual ICppTemplateParameter GetResolveEntity();
    public ICppTemplateParameterForPsi GetResolveEntityForPsi();
    public sealed virtual ITreeNode GetNameNode();
    public virtual CppTreeElementRange GetNameTokenRange();
    public sealed virtual CppViewPos GetViewPos();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ConceptQualifiedName : BaseQualifiedName {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public sealed virtual CppViewPos GetViewPosForName();
    public sealed virtual List`1<CppTemplateParametersBase> GetTemplateParameters();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.ConceptQualifiedNameNavigator : object {
    public static ConceptQualifiedName GetByQualifier(NameQualifier qual);
    public static ConceptQualifiedName GetByNamePart(ITreeNode namePart);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ConditionalExpression : CppExpressionNodeWithCachedDepInfo {
    public NodeType NodeType { get; }
    public ITokenNode QuestionMarkNode { get; }
    public ITokenNode ColonNode { get; }
    public ICppExpressionNode Condition { get; }
    public ICppExpressionNode SecondArg { get; }
    public ICppExpressionNode ThirdArg { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_QuestionMarkNode();
    public ITokenNode get_ColonNode();
    public ICppExpressionNode get_Condition();
    public ICppExpressionNode get_SecondArg();
    public ICppExpressionNode get_ThirdArg();
    public sealed virtual ICppExpression GetFirstArgument();
    public sealed virtual ICppExpression GetSecondArgument();
    public sealed virtual ICppExpression GetThirdArgument();
    public sealed virtual CppConditionalExprKind GetKind();
    public sealed virtual ICppResolvedExpression GetResolvedFirstArgument();
    public sealed virtual ICppResolvedExpression GetResolvedSecondArgument();
    public sealed virtual ICppResolvedExpression GetResolvedThirdArgument();
    public sealed virtual CppViewPos GetViewPosForOverloading();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.ConditionalExpressionNavigator : object {
    public static ConditionalExpression GetByCondition(ICppExpressionNode condition);
    public static ConditionalExpression GetBySecondArg(ICppExpressionNode condition);
    public static ConditionalExpression GetByThirdArg(ICppExpressionNode condition);
    public static ConditionalExpression GetByQuestionMark(ITokenNode questionMark);
    public static ConditionalExpression GetByColon(ITokenNode colon);
    public static ConditionalExpression GetByColonOrQuestionMark(ITokenNode token);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ContinueStatement : CppCompositeNode {
    public ITokenNode ContinueKeyword { get; }
    public NodeType NodeType { get; }
    public ITokenNode get_ContinueKeyword();
    public virtual NodeType get_NodeType();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.ContinueStatementNavigator : object {
    public static ContinueStatement GetByContinueKeyword(ITokenNode child);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ContractAttribute : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ConversionProviderUtil : object {
    public static CppQualType GetClassTypeByConversion(ICppConversionProvidingNode conversionProvidingNode);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CoReturnStatement : CppCompositeNode {
    private Reference myReference;
    private CppCachedValue`1<CppCoReturnResolveResult> myResolveResult;
    public NodeType NodeType { get; }
    public ITokenNode CoReturnKeyword { get; }
    public ICppExpressionNode ReturnedValue { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_CoReturnKeyword();
    public ICppExpressionNode get_ReturnedValue();
    public CppCoReturnResolveResult GetResolveResult();
    public CppDependentInfo GetDependentInfo();
    public virtual ReferenceCollection GetFirstClassReferences();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CoReturnStatementNavigator : object {
    public static CoReturnStatement GetByReturnedValue(ICppExpressionNode node);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.CoroutineReferenceBase`1 : CppReferenceBase`1<TNode> {
    protected CoroutineReferenceBase`1(TNode expr);
    public virtual CppTreeElementRange GetTokenRange();
    public virtual string GetName();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CoYieldExpression : CppExpressionNodeWithCachedDepInfo {
    private ICppReference myYieldValueReference;
    private ICppReference myOperatorCoAwaitReference;
    private ICppReference myAwaitReadyReference;
    private ICppReference myAwaitSuspendReference;
    private ICppReference myAwaitResumeReference;
    private CppCachedValue`1<CppCoYieldResolveResult> myResolveResult;
    public NodeType NodeType { get; }
    public ITokenNode CoYieldKeyword { get; }
    public ICppExpressionNode Argument { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_CoYieldKeyword();
    public ICppExpressionNode get_Argument();
    public sealed virtual ICppExpression GetArgument();
    public sealed virtual ICppResolvedExpression GetResolvedArgument();
    public sealed virtual CppCoYieldResolveResult GetResolveResult();
    public sealed virtual CppViewPos GetViewPos();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual ITokenNode GetCoKeyword();
    public sealed virtual CppResolveResult ResolveOperatorCoAwait();
    public sealed virtual CppResolveResult ResolveAwaitReady();
    public sealed virtual CppResolveResult ResolveAwaitResume();
    public sealed virtual CppResolveResult ResolveAwaitSuspend();
    public sealed virtual CppResolveResult ResolveYieldValue();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CoYieldExpressionNavigator : object {
    public static CoYieldExpression GetByYieldedExpression(ICppExpressionNode yielded);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.Cpp20ImportHeaderUnitDirective : BaseSymbolNode`1<CppImportHeaderUnitDirectiveSymbol> {
    private IReadOnlyList`1<IReference> myReferences;
    public NodeType NodeType { get; }
    public ITokenNode ImportKeyword { get; }
    public string UnquotedImportPath { get; }
    public ITokenNode QuotedImportPath { get; }
    public bool IsAngleBracket { get; }
    public bool IsIncludeNext { get; }
    public Cpp20ImportHeaderUnitDirective(ICppSymbol symbol);
    public virtual NodeType get_NodeType();
    public ITokenNode get_ImportKeyword();
    public sealed virtual string get_UnquotedImportPath();
    public sealed virtual ITokenNode get_QuotedImportPath();
    public sealed virtual bool get_IsAngleBracket();
    public sealed virtual bool get_IsIncludeNext();
    public virtual ReferenceCollection GetFirstClassReferences();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.Cpp20ImportHeaderUnitDirectiveNavigator : object {
    [CanBeNullAttribute]
public static Cpp20ImportHeaderUnitDirective GetByImportPath(ITokenNode path);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.Cpp20ImportModuleDirective : BaseSymbolNode`1<CppImportModuleDirectiveSymbol> {
    private ImportModuleReference myReference;
    public NodeType NodeType { get; }
    public ITokenNode Colon { get; }
    public ModuleName ModuleName { get; }
    public ModuleName PartitionName { get; }
    public Cpp20ImportModuleDirective(ICppSymbol symbol);
    public virtual NodeType get_NodeType();
    public ITokenNode get_Colon();
    public ModuleName get_ModuleName();
    public ModuleName get_PartitionName();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual CppTreeElementRange GetNameTokenRange();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.CppAbstractExpressionNodeVisitor`1 : object {
    public abstract virtual Result VisitExpression(ICppExpressionNode e);
    public virtual Result Visit(BinaryExpression e);
    public virtual Result Visit(UnaryExpression e);
    public virtual Result Visit(EmptyExpression e);
    public virtual Result Visit(CallExpression e);
    public virtual Result Visit(CastExpression e);
    public virtual Result Visit(ConditionalExpression e);
    public virtual Result Visit(DeleteExpression e);
    public virtual Result Visit(LiteralExpression e);
    public virtual Result Visit(UserDefinedLiteralExpression e);
    public virtual Result Visit(GnuBuiltinChooseExprExpression e);
    public virtual Result Visit(ThisExpression e);
    public virtual Result Visit(MemberAccessExpression e);
    public virtual Result Visit(SingleArgumentTypeTraitExpression e);
    public virtual Result Visit(DoubleArgumentTypeTraitExpression e);
    public virtual Result Visit(MultiArgumentTypeTraitExpression e);
    public virtual Result Visit(MSUuidOfExpression e);
    public virtual Result Visit(MSEventHookExpression e);
    public virtual Result Visit(MSNoopExpression e);
    public virtual Result Visit(MSAssumeExpression e);
    public virtual Result Visit(BuiltinAddressOfExpression e);
    public virtual Result Visit(BuiltinOffsetOfExpression e);
    public virtual Result Visit(GnuBuiltinConstantPExpression e);
    public virtual Result Visit(GnuAddressOfLabelExpression e);
    public virtual Result Visit(NewExpression e);
    public virtual Result Visit(ParenExpression e);
    public virtual Result Visit(PostfixExpression e);
    public virtual Result Visit(QualifiedReference e);
    public virtual Result Visit(SizeOfExpression e);
    public virtual Result Visit(SizeOfEllipsisExpression e);
    public virtual Result Visit(AlignOfExpression e);
    public virtual Result Visit(SubscriptExpression e);
    public virtual Result Visit(ThrowExpression e);
    public virtual Result Visit(TypeIdExpression e);
    public virtual Result Visit(BracedInitList e);
    public virtual Result Visit(BraceInitializedTemporary e);
    public virtual Result Visit(Designation e);
    public virtual Result Visit(LambdaExpression e);
    public virtual Result Visit(RequiresExpression e);
    public virtual Result Visit(CliMultiArgumentSubscriptExpression e);
    public virtual Result Visit(CliTypeIdExpression e);
    public virtual Result Visit(NoExceptExpression e);
    public virtual Result Visit(CompoundStatementExpression e);
    public virtual Result Visit(PackExpansionExpression e);
    public virtual Result Visit(FoldExpression e);
    public virtual Result Visit(CoAwaitExpression e);
    public virtual Result Visit(CoYieldExpression e);
    public virtual Result Visit(C11GenericExpression e);
}
public enum JetBrains.ReSharper.Psi.Cpp.Tree.CppAddChildMode : Enum {
    public int value__;
    public static CppAddChildMode ADD_AFTER_ANCHOR;
    public static CppAddChildMode ADD_BEFORE_ANCHOR;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppAddChildModeUtils : object {
    [ExtensionAttribute]
public static CppAddChildMode Invert(CppAddChildMode m);
    [ExtensionAttribute]
public static ITreeRange AddChildRange(CppAddChildMode mode, ITreeNode parent, ITreeNode anchor, ITreeRange range);
    [ExtensionAttribute]
public static ITreeNode AddChildRange(CppAddChildMode mode, ITreeNode parent, ITreeNode anchor, IList`1<ITokenNode> range);
    [ExtensionAttribute]
public static ITokenNode GetNextToken(CppAddChildMode mode, ITreeNode node);
    [ExtensionAttribute]
public static ITreeNode GetFirstChild(CppAddChildMode mode, ITreeNode node);
    [ExtensionAttribute]
public static ITreeNode FindLastToken(CppAddChildMode mode, ITreeNode node);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.CppBaseFileReference`1 : TreeReferenceBase`1<TOwnerElement> {
    private TextRange myElementRange;
    private string myPathPart;
    [CompilerGeneratedAttribute]
private ICppFileReference <ParentReference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFolderReference>k__BackingField;
    public ICppFileReference ParentReference { get; }
    public bool IsFolderReference { get; }
    protected ITokenNode PathToken { get; }
    public CppBaseFileReference`1(TOwnerElement owner, ICppFileReference parentReference, string pathPart, TextRange range, bool isFolderReference);
    [CompilerGeneratedAttribute]
public sealed virtual ICppFileReference get_ParentReference();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsFolderReference();
    protected abstract virtual ITokenNode get_PathToken();
    public abstract virtual IEnumerable`1<VirtualFileSystemPath> GetSearchPaths();
    public virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public virtual IAccessContext GetAccessContext();
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual ResolveResultWithInfo Resolve();
    public virtual TreeTextRange GetTreeTextRange();
    public virtual string GetName();
    public virtual string GetFullPath();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppBulkReplacePsiModification : object {
    private IList`1<CppReplacePsiModification> myReplaces;
    private IList`1<CppReplacePsiModification> mySingleReplaces;
    private IList`1<GroupReplaceWithSameProtoTokens> myReplaceGroups;
    private IDictionary`2<CppReplacePsiModification, bool> myCanBeReplaced;
    private IDictionary`2<GroupReplaceWithSameProtoTokens, bool> myCanBeReplacedGroups;
    public IReadOnlyList`1<CppReplacePsiModification> Tasks { get; }
    public CppBulkReplacePsiModification(IEnumerable`1<CppReplacePsiModification> replaces);
    public IReadOnlyList`1<CppReplacePsiModification> get_Tasks();
    public bool CanBeReplaced();
    public bool CanBeReplaced(CppReplacePsiModification replace);
    public IDictionary`2<CppReplacePsiModification, ITreeRange> DoReplace();
    private void AddItem(CppReplacePsiModification replace);
    private void AddItemComingFromSingleMacroArgument(CppReplacePsiModification replace, IList`1<ITokenNode> protoTokens);
    private void SetCanBeReplaced(CppReplacePsiModification replace, bool value);
    private void SetCanBeReplaced(GroupReplaceWithSameProtoTokens group, bool value);
    private bool CalculateCanBeReplaced(CppReplacePsiModification replace);
    private bool CalculateCanBeReplaced(GroupReplaceWithSameProtoTokens groupReplace);
    private ITreeRange DoReplaceSingle(CppReplacePsiModification replace);
    private IList`1<ITreeRange> DoReplaceGroup(GroupReplaceWithSameProtoTokens groupReplace);
    private static bool AreRangesIntersecting(ITreeRange x, ITreeRange y);
    private static void ProcessCommentsOnReplace(ITreeRange oldNodes, ITreeRange newNodes, CppCommentsReplaceMode commentsMode);
    private static void AddMacroArgumentProtoTokensAfter(ITreeNode anchor, IList`1<ITokenNode> macroArgProtoToksForNewChild, int startIndex);
    private static void ReplaceMacroArgumentTokens(IList`1<ITokenNode> macroArgProtoToksForOldChild, IList`1<ITokenNode> macroArgProtoToksForNewChild);
    private static ITreeRange ReplaceMacroArgumentTokens(IList`1<ITokenNode> macroArgProtoToksForOldChild, ITreeRange newNodes);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppCaseOrDefaultStatementNavigator : object {
    public static ICppCaseOrDefaultStatement GetByStatement(ICppStatement statement);
    public static ICppCaseOrDefaultStatement GetTopmostStatementByStatement(ICppStatement statement);
}
internal class JetBrains.ReSharper.Psi.Cpp.Tree.CppCastConversionCache : CppImplicitConversionPsiCache {
    private CppCastConversion myConversion;
    public CppCastConversionCache(CppCastConversion conv, CppImplicitConversionPsiCache next);
    protected virtual void TraverseImpl(ICppConversionVisitor visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppChameleonCompoundStatement : CompoundStatement {
    public bool WasHighlighted;
    private CppChameleonData myChameleonData;
    private int myModificationStamp;
    public Nullable`1<int> ModificationStamp { get; public set; }
    public int InitialTextLength { get; }
    public bool IsOpened { get; }
    public ITreeNode FirstChild { get; }
    public ITreeNode LastChild { get; }
    public CppChameleonData& ChameleonData { get; }
    public CppFileSymbolsCache FileSymbolsCache { get; }
    public NodeUserDataHolder NodeUserDataHolder { get; }
    public bool HoldOwnUserData { get; }
    public CppChameleonCompoundStatement(CppChameleonStatementInfo info);
    public virtual string ToString();
    public void ReplaceFunctionBody(CppChameleonCompoundStatement newNode);
    public sealed virtual Nullable`1<int> get_ModificationStamp();
    public sealed virtual void set_ModificationStamp(Nullable`1<int> value);
    public int get_InitialTextLength();
    [CanBeNullAttribute]
private CppFunctionBodyResolveEntity TryGetFunctionBody();
    public sealed virtual bool get_IsOpened();
    public virtual ITreeNode get_FirstChild();
    public virtual ITreeNode get_LastChild();
    public virtual int GetTextLength();
    public virtual StringBuilder GetText(StringBuilder to);
    public virtual IBuffer GetTextAsBuffer();
    public virtual IChameleonNode FindChameleonWhichCoversRange(TreeTextRange textRange);
    public virtual ITreeNode FindNodeAt(TreeTextRange textRange);
    public sealed virtual IChameleonNode ReSync(CachingLexer lexer, TreeTextRange changedRange, int insertedTextLen);
    protected virtual TreeElement DeepClone(TreeNodeCopyContext context);
    public sealed virtual CppChameleonData& get_ChameleonData();
    public sealed virtual CppFileSymbolsCache get_FileSymbolsCache();
    public virtual ICppScopeResolveEntity GetResolveScope();
    public virtual CppComplexOffset GetComplexOffset();
    public sealed virtual StringBuilder TryGetWordsFromClosedChameleon();
    public sealed virtual void GetWordsFromClosedChameleon(IntSet words);
    public sealed virtual IEnumerable`1<CppNonSortedRangeIndex> GetPPUsages();
    public sealed virtual NodeUserDataHolder get_NodeUserDataHolder();
    public sealed virtual bool get_HoldOwnUserData();
    public sealed virtual void CloseChameleon();
    private static bool HasUnsupportedDirectives(CppDocumentBuffer docBuffer);
    private static bool IsKeywordPragmaPack(CppInnerLexer& lexer);
    private static bool IsIdentifier(CppInnerLexer& lexer, string id);
    private static void SkipWhitespaces(CppInnerLexer& lexer);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppChameleonCtorBlock : CtorBlock {
    private CppChameleonData myChameleonData;
    public bool IsOpened { get; }
    public ITreeNode FirstChild { get; }
    public ITreeNode LastChild { get; }
    public CppFileSymbolsCache FileSymbolsCache { get; }
    public NodeUserDataHolder NodeUserDataHolder { get; }
    public bool HoldOwnUserData { get; }
    public CppChameleonData& ChameleonData { get; }
    public CppChameleonCtorBlock(CppChameleonStatementInfo info);
    public virtual string ToString();
    public sealed virtual bool get_IsOpened();
    public virtual ITreeNode get_FirstChild();
    public virtual ITreeNode get_LastChild();
    public virtual int GetTextLength();
    public virtual StringBuilder GetText(StringBuilder to);
    public virtual IBuffer GetTextAsBuffer();
    public virtual IChameleonNode FindChameleonWhichCoversRange(TreeTextRange textRange);
    public virtual ITreeNode FindNodeAt(TreeTextRange textRange);
    public sealed virtual IChameleonNode ReSync(CachingLexer cachingLexer, TreeTextRange changedRange, int insertedTextLen);
    protected virtual TreeElement DeepClone(TreeNodeCopyContext context);
    public sealed virtual CppFileSymbolsCache get_FileSymbolsCache();
    public virtual ICppScopeResolveEntity GetResolveScope();
    public virtual CppComplexOffset GetComplexOffset();
    public sealed virtual StringBuilder TryGetWordsFromClosedChameleon();
    public sealed virtual void GetWordsFromClosedChameleon(IntSet words);
    public sealed virtual IEnumerable`1<CppNonSortedRangeIndex> GetPPUsages();
    public sealed virtual NodeUserDataHolder get_NodeUserDataHolder();
    public sealed virtual bool get_HoldOwnUserData();
    public sealed virtual void CloseChameleon();
    public sealed virtual CppChameleonData& get_ChameleonData();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppChameleonData : ValueType {
    private ICppScopeResolveEntity myResolveScope;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myClosedTextLength;
    private object mySyncObject;
    private CppFileSymbolsCache mySymbolCache;
    private NodeUserDataHolder myUserDataHolder;
    [CompilerGeneratedAttribute]
private int <InitialTextLength>k__BackingField;
    [CompilerGeneratedAttribute]
private CppClosedChameleonToken <ClosedToken>k__BackingField;
    public bool IsOpened { get; }
    public int InitialTextLength { get; }
    public NodeUserDataHolder NodeUserDataHolder { get; public set; }
    public bool HoldOwnUserData { get; }
    public CppClosedChameleonToken ClosedToken { get; }
    public CppChameleonData(CompositeElement self, CppClosedChameleonToken token);
    public bool get_IsOpened();
    public ITreeNode GetFirstChild(T self);
    public ITreeNode GetLastChild(T self);
    public int GetTextLength(Func`1<int> baseImpl);
    public StringBuilder GetText(StringBuilder to, Func`2<StringBuilder, StringBuilder> baseImpl);
    public IBuffer GetTextAsBuffer(Func`1<IBuffer> baseImpl);
    public IChameleonNode FindChameleonWhichCoversRange(T self, TreeTextRange textRange, Func`2<TreeTextRange, IChameleonNode> baseImpl);
    public ITreeNode FindNodeAt(T self, TreeTextRange textRange, Func`2<TreeTextRange, ITreeNode> baseImpl);
    public TreeElement DeepClone(T self, TreeNodeCopyContext context, Func`2<TreeNodeCopyContext, TreeElement> baseImpl);
    private static void DeepClonePersistentUserDataForCppChameleons(INodeUserDataHolderOwner original, INodeUserDataHolderOwner clone);
    public CppFileSymbolsCache GetFileSymbolsCache(T self);
    public ICppScopeResolveEntity GetResolveScope();
    public CppComplexOffset GetComplexOffset(T self, Func`1<CppComplexOffset> baseImpl);
    public StringBuilder TryGetWordsFromClosedChameleon(T self);
    public void GetWordsFromClosedChameleon(T self, IntSet words);
    public IEnumerable`1<CppNonSortedRangeIndex> GetPPUsages();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_InitialTextLength();
    public NodeUserDataHolder get_NodeUserDataHolder();
    public void set_NodeUserDataHolder(NodeUserDataHolder value);
    public bool get_HoldOwnUserData();
    private void OpenChameleonIfClosed(T self);
    public bool OpenChameleon(T self, bool isReSync);
    public void CloseChameleon(T self);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CppClosedChameleonToken get_ClosedToken();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppChameleonFunctionTryBlock : FunctionTryBlock {
    private CppChameleonData myChameleonData;
    public bool IsOpened { get; }
    public ITreeNode FirstChild { get; }
    public ITreeNode LastChild { get; }
    public CppFileSymbolsCache FileSymbolsCache { get; }
    public NodeUserDataHolder NodeUserDataHolder { get; }
    public bool HoldOwnUserData { get; }
    public CppChameleonData& ChameleonData { get; }
    public CppChameleonFunctionTryBlock(CppChameleonStatementInfo info);
    public virtual string ToString();
    public sealed virtual bool get_IsOpened();
    public virtual ITreeNode get_FirstChild();
    public virtual ITreeNode get_LastChild();
    public virtual int GetTextLength();
    public virtual StringBuilder GetText(StringBuilder to);
    public virtual IBuffer GetTextAsBuffer();
    public virtual IChameleonNode FindChameleonWhichCoversRange(TreeTextRange textRange);
    public virtual ITreeNode FindNodeAt(TreeTextRange textRange);
    public sealed virtual IChameleonNode ReSync(CachingLexer cachingLexer, TreeTextRange changedRange, int insertedTextLen);
    protected virtual TreeElement DeepClone(TreeNodeCopyContext context);
    public sealed virtual CppFileSymbolsCache get_FileSymbolsCache();
    public virtual ICppScopeResolveEntity GetResolveScope();
    public virtual CppComplexOffset GetComplexOffset();
    public sealed virtual StringBuilder TryGetWordsFromClosedChameleon();
    public sealed virtual void GetWordsFromClosedChameleon(IntSet words);
    public sealed virtual IEnumerable`1<CppNonSortedRangeIndex> GetPPUsages();
    public sealed virtual NodeUserDataHolder get_NodeUserDataHolder();
    public sealed virtual bool get_HoldOwnUserData();
    public sealed virtual void CloseChameleon();
    public sealed virtual CppChameleonData& get_ChameleonData();
}
internal static class JetBrains.ReSharper.Psi.Cpp.Tree.CppChameleonNodeUtil : object {
    public static TextRange GetNewTextRange(IChameleonNode node, TreeTextRange changedRange, int insertedTextLen);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppChameleonStatementInfo : object {
    [CanBeNullAttribute]
public ICollection`1<CppNonSortedRangeIndex> PPUsages;
    public List`1<ICppSymbol> PreprocessorSymbols;
    public Range PsiBuilderRange;
    public CppViewPos ViewPos;
    public CompositeNodeType NodeType;
    public Nullable`1<UInt32> PragmaPack;
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppChildrenResolvedHelper : object {
    public static void EnsureExpressionChildrenResolved(ICppExpressionNode node);
    private static void MarkChildrenResolved(ICppExpressionNode node);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppClassTaggedNodeExtensions : object {
    public static CppClassKey GetKeyByNode(ICppClassTaggedNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppClonedSelectedType : ValueType {
    [CompilerGeneratedAttribute]
private NestedDeclarator <OuterDeclarator>k__BackingField;
    [CompilerGeneratedAttribute]
private NestedDeclarator <NestedDeclaratorNode>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <PrefixEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <SuffixBegin>k__BackingField;
    public NestedDeclarator OuterDeclarator { get; public set; }
    public NestedDeclarator NestedDeclaratorNode { get; public set; }
    public ITreeNode PrefixEnd { get; public set; }
    public ITreeNode SuffixBegin { get; public set; }
    public CppClonedSelectedType(NestedDeclarator OuterDeclarator, NestedDeclarator NestedDeclaratorNode, ITreeNode PrefixEnd, ITreeNode SuffixBegin);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public NestedDeclarator get_OuterDeclarator();
    [CompilerGeneratedAttribute]
public void set_OuterDeclarator(NestedDeclarator value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public NestedDeclarator get_NestedDeclaratorNode();
    [CompilerGeneratedAttribute]
public void set_NestedDeclaratorNode(NestedDeclarator value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ITreeNode get_PrefixEnd();
    [CompilerGeneratedAttribute]
public void set_PrefixEnd(ITreeNode value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ITreeNode get_SuffixBegin();
    [CompilerGeneratedAttribute]
public void set_SuffixBegin(ITreeNode value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CppClonedSelectedType left, CppClonedSelectedType right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CppClonedSelectedType left, CppClonedSelectedType right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CppClonedSelectedType other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(NestedDeclarator& OuterDeclarator, NestedDeclarator& NestedDeclaratorNode, ITreeNode& PrefixEnd, ITreeNode& SuffixBegin);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.CppClosedChameleonToken : CppTokenNodeBase {
    protected List`1<ICppSymbol> PreprocessorSymbols;
    [CompilerGeneratedAttribute]
private Range <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<CppNonSortedRangeIndex> <PPUsages>k__BackingField;
    [CompilerGeneratedAttribute]
private CppViewPos <OriginalViewPos>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <PragmaPack>k__BackingField;
    public NodeType NodeType { get; }
    public Range Range { get; }
    public IEnumerable`1<CppNonSortedRangeIndex> PPUsages { get; }
    public CppViewPos OriginalViewPos { get; }
    public Nullable`1<UInt32> PragmaPack { get; }
    public CppClosedChameleonToken(CppChameleonStatementInfo info);
    public virtual NodeType get_NodeType();
    public virtual string GetText();
    public virtual int GetTextLength();
    public abstract virtual ITreeNode Expand(ICppCompositeNode consumer, CppPsiBuilder builder);
    [CompilerGeneratedAttribute]
public Range get_Range();
    [CompilerGeneratedAttribute]
public IEnumerable`1<CppNonSortedRangeIndex> get_PPUsages();
    [CompilerGeneratedAttribute]
public CppViewPos get_OriginalViewPos();
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_PragmaPack();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppClosedCtorBlockChameleonToken : CppClosedChameleonToken {
    public CppClosedCtorBlockChameleonToken(CppChameleonStatementInfo info);
    public virtual ITreeNode Expand(ICppCompositeNode consumer, CppPsiBuilder builder);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppClosedFunctionTryBlockChameleonToken : CppClosedChameleonToken {
    public CppClosedFunctionTryBlockChameleonToken(CppChameleonStatementInfo info);
    public virtual ITreeNode Expand(ICppCompositeNode consumer, CppPsiBuilder builder);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppClosedStatementChameleonToken : CppClosedChameleonToken {
    public CppClosedStatementChameleonToken(CppChameleonStatementInfo info);
    public virtual ITreeNode Expand(ICppCompositeNode consumer, CppPsiBuilder builder);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppCodeFragment : CppCompositeNode {
    private int myModificationStamp;
    private ICppScopeResolveEntity myFragmentScope;
    private CppFileSymbolsCache mySymbolCache;
    private ITreeNode myContext;
    private IPsiModule myPsiModule;
    [CompilerGeneratedAttribute]
private NodeUserDataHolder <NodeUserDataHolder>k__BackingField;
    public int LevelDelta { get; }
    public CppFileSymbolsCache FileSymbolsCache { get; }
    public NodeType NodeType { get; }
    public NodeUserDataHolder NodeUserDataHolder { get; }
    public bool HoldOwnUserData { get; }
    public ITreeNode ContextNode { get; }
    public SandBoxContextType ContextType { get; }
    public Nullable`1<int> ModificationStamp { get; public set; }
    public int get_LevelDelta();
    public sealed virtual CppFileSymbolsCache get_FileSymbolsCache();
    public virtual NodeType get_NodeType();
    public virtual IPsiServices GetPsiServices();
    public sealed virtual IPsiModule GetPsiModule();
    public sealed virtual ICppScopeResolveEntity GetResolveScope();
    public virtual bool IsValid();
    [CompilerGeneratedAttribute]
public sealed virtual NodeUserDataHolder get_NodeUserDataHolder();
    public sealed virtual bool get_HoldOwnUserData();
    public sealed virtual ITreeNode get_ContextNode();
    public sealed virtual SandBoxContextType get_ContextType();
    public sealed virtual Nullable`1<int> get_ModificationStamp();
    public sealed virtual void set_ModificationStamp(Nullable`1<int> value);
    public void SetContext(ITreeNode context, ICppScopeResolveEntity fragmentScope, CppFileSymbolsCache cache, IPsiModule psiModule);
    public ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Tree.CppCommentsDeleteMode : Enum {
    public int value__;
    public static CppCommentsDeleteMode IGNORE;
    public static CppCommentsDeleteMode DELETE_BEFORE;
    public static CppCommentsDeleteMode DELETE_AFTER;
    public static CppCommentsDeleteMode DELETE;
}
public enum JetBrains.ReSharper.Psi.Cpp.Tree.CppCommentsReplaceMode : Enum {
    public int value__;
    public static CppCommentsReplaceMode IGNORE;
    public static CppCommentsReplaceMode REPLACE_WHEN_NEW_COMMENTS_ARE_PRESENT;
    public static CppCommentsReplaceMode REPLACE_ALWAYS;
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.CppCompositeNode : CompositeElement {
    public PsiLanguageType Language { get; }
    public virtual CppComplexOffset GetComplexOffset();
    public virtual CppFile GetContainingFile();
    public virtual CppFileSymbolsCache GetFileCache();
    public virtual PsiLanguageType get_Language();
    public virtual bool IsFiltered();
    public virtual void DropReferences();
    public TreeElement FindChildByType(NodeType childType);
    public CppList`1<T> FindChildrenByType(NodeType childType);
    public CppList`1<T> FindChildrenByType(NodeTypeSet childTypeSet);
    public T FindChildByType(NodeType childType, int childIndex);
    public T FindChildByType(NodeType childType, int childIndex, bool lookInErrorElements);
    public T FindChildByType(NodeTypeSet childTypeSet, int childIndex);
    public T FindChildByType(NodeTypeSet childTypeSet, int childIndex, bool lookInErrorElements);
    public T FindChildByType(int childIndex, NodeType[] childTypes);
    [CanBeNullAttribute]
public T FindLastChildByType(NodeType childType);
    [CanBeNullAttribute]
public T FindLastChildByType(NodeTypeSet childTypeSet);
    public int ChildrenCountByType(NodeType childType);
    public int ChildrenCountByType(NodeTypeSet childTypeSet);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppCompositeNodeExtensions : object {
    private static NodeTypeSet ourTagTypes;
    private static CppCompositeNodeExtensions();
    [ExtensionAttribute]
public static CppList`1<ITokenNode> NodeGetKey(CppCompositeNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppConvertToReplacedExpressionVisitor : object {
    public static CppConvertToReplacedExpressionVisitor Instance;
    private static CppConvertToReplacedExpressionVisitor();
    public sealed virtual ICppExpression Visit(BinaryExpression e);
    public sealed virtual ICppExpression Visit(UnaryExpression e);
    public sealed virtual ICppExpression Visit(EmptyExpression e);
    public sealed virtual ICppExpression Visit(CallExpression e);
    public sealed virtual ICppExpression Visit(CastExpression e);
    public sealed virtual ICppExpression Visit(ConditionalExpression e);
    public sealed virtual ICppExpression Visit(DeleteExpression e);
    public sealed virtual ICppExpression Visit(LiteralExpression e);
    public sealed virtual ICppExpression Visit(UserDefinedLiteralExpression e);
    public sealed virtual ICppExpression Visit(GnuBuiltinChooseExprExpression e);
    public sealed virtual ICppExpression Visit(ThisExpression e);
    public sealed virtual ICppExpression Visit(MemberAccessExpression e);
    public sealed virtual ICppExpression Visit(SingleArgumentTypeTraitExpression e);
    public sealed virtual ICppExpression Visit(DoubleArgumentTypeTraitExpression e);
    public sealed virtual ICppExpression Visit(MultiArgumentTypeTraitExpression e);
    public sealed virtual ICppExpression Visit(MSUuidOfExpression e);
    public sealed virtual ICppExpression Visit(MSEventHookExpression e);
    public sealed virtual ICppExpression Visit(MSNoopExpression e);
    public sealed virtual ICppExpression Visit(MSAssumeExpression e);
    public sealed virtual ICppExpression Visit(BuiltinAddressOfExpression e);
    public sealed virtual ICppExpression Visit(BuiltinOffsetOfExpression e);
    public sealed virtual ICppExpression Visit(GnuBuiltinConstantPExpression e);
    public sealed virtual ICppExpression Visit(GnuAddressOfLabelExpression e);
    public sealed virtual ICppExpression Visit(NewExpression e);
    public sealed virtual ICppExpression Visit(ParenExpression e);
    public sealed virtual ICppExpression Visit(PostfixExpression e);
    public sealed virtual ICppExpression Visit(QualifiedReference e);
    public sealed virtual ICppExpression Visit(SizeOfExpression e);
    public sealed virtual ICppExpression Visit(SizeOfEllipsisExpression e);
    public sealed virtual ICppExpression Visit(AlignOfExpression e);
    public sealed virtual ICppExpression Visit(SubscriptExpression e);
    public sealed virtual ICppExpression Visit(ThrowExpression e);
    public sealed virtual ICppExpression Visit(TypeIdExpression e);
    public sealed virtual ICppExpression Visit(BracedInitList e);
    private CppBracedInitListExpression VisitBracedInitList(BracedInitList e);
    public sealed virtual ICppExpression Visit(Designation e);
    private ICppDesignator ReApply(ICppDesignatorNode designator);
    public sealed virtual ICppExpression Visit(BraceInitializedTemporary e);
    public sealed virtual ICppExpression Visit(LambdaExpression e);
    public sealed virtual ICppExpression Visit(RequiresExpression e);
    public sealed virtual ICppExpression Visit(CliMultiArgumentSubscriptExpression e);
    public sealed virtual ICppExpression Visit(CliTypeIdExpression e);
    public sealed virtual ICppExpression Visit(NoExceptExpression e);
    public sealed virtual ICppExpression Visit(CompoundStatementExpression e);
    public sealed virtual ICppExpression Visit(PackExpansionExpression e);
    public sealed virtual ICppExpression Visit(FoldExpression e);
    public sealed virtual ICppExpression Visit(CoAwaitExpression e);
    public sealed virtual ICppExpression Visit(CoYieldExpression e);
    public sealed virtual ICppExpression Visit(C11GenericExpression node);
    [CanBeNullAttribute]
private ICppExpression ReApplySafe(ICppExpressionNode arg);
    public ICppExpression ReApply(ICppExpressionNode arg);
    private ICppTypeIdOrExpression VisitTypeIdOrExpression(ICppTypeIdOrExpressionNode node);
    private ICppArgumentList VisitArgumentList(ICppExpressionsArgumentListNode arglist);
    private ICppExpression[] VisitExprList(CppList`1<ICppExpressionNode> argsNode);
    private CppSmallArray`1<ICppExpression> VisitExprList(CppSmallList`1<ICppExpressionNode> argsNode);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Tree.CppDeclarationOwnerKind : Enum {
    public int value__;
    public static CppDeclarationOwnerKind OrdinaryNamespace;
    public static CppDeclarationOwnerKind GlobalNamespace;
    public static CppDeclarationOwnerKind Class;
    public static CppDeclarationOwnerKind CompoundStatement;
    public static CppDeclarationOwnerKind CxxCli_PropertyOrEvent;
    public static CppDeclarationOwnerKind None;
    public static CppDeclarationOwnerKind All;
    public static CppDeclarationOwnerKind Namespace;
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDeclarationSpecifiersSelection : object {
    private List`1<ITreeNode> mySelectedDeclSpecs;
    [CompilerGeneratedAttribute]
private DeclarationSpecifiersBase <DeclSpecs>k__BackingField;
    public DeclarationSpecifiersBase DeclSpecs { get; }
    public CppDeclarationSpecifiersSelection(DeclarationSpecifiersBase declSpecs);
    private CppDeclarationSpecifiersSelection(DeclarationSpecifiersBase declSpecs, List`1<ITreeNode> selectedDeclSpecs);
    [CompilerGeneratedAttribute]
public DeclarationSpecifiersBase get_DeclSpecs();
    public bool AreAllTypeNodesSelected();
    public IEnumerable`1<ITreeNode> GetSelectedNodes();
    public void AddChild(ITreeNode child);
    public bool CanBeDeleted();
    public bool CanBeReplacedBy(CppDeclarationSpecifiersSelection other);
    public CppDeclarationSpecifiersSelection ReplaceBy(CppDeclarationSpecifiersSelection other);
    public CppDeclarationSpecifiersSelection ReplaceBy(CppDeclarationSpecifiersSelection other, CppPsiModificationStrategy modStrategy);
    public List`1<ITreeRange> BuildTreeRanges();
    private bool CanBeDeleted(List`1<ITreeRange> ranges);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppDeclarationTrailingNodeNavigator : object {
    public static ICppDeclarationTrailingNode GetByCtorInitializer(CtorInitializer ctorInit);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppDeclaratorNodeNavigator : object {
    public static ICppDeclaratorNode GetByChildNestedDeclarator(NestedDeclarator declarator);
    public static ICppNonNestedDeclaratorNode GetByDeclaratorQualifiedName(DeclaratorQualifiedName declarator);
    public static NestedDeclarator GetOutermostNestedDeclarator(NestedDeclarator declarator);
    public static ICppNonNestedDeclaratorNode GetByNestedDeclarator(ICppDeclaratorNode nestedDeclarator);
    public static ICppNonNestedDeclaratorNode GetByParametersAndQualifiers(ParametersAndQualifiers parametersAndQualifiers);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.CppDeclaratorReference`1 : CppReferenceBase`1<TOwnerElement> {
    public CppDeclaratorReference`1(TOwnerElement owner);
    public virtual ResolveResultWithInfo ResolveWithoutCache();
    public virtual string GetName();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDeclaratorSelection : object {
    [CompilerGeneratedAttribute]
private NestedDeclarator <Declarator>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <PrefixEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <SuffixBegin>k__BackingField;
    [NotNullAttribute]
public NestedDeclarator Declarator { get; }
    [CanBeNullAttribute]
public ITreeNode PrefixEnd { get; }
    [CanBeNullAttribute]
public ITreeNode SuffixBegin { get; }
    public bool IsEmpty { get; }
    public CppDeclaratorSelection(NestedDeclarator declarator, ITreeNode prefixEnd, ITreeNode suffixBegin);
    [CompilerGeneratedAttribute]
public NestedDeclarator get_Declarator();
    [CompilerGeneratedAttribute]
public ITreeNode get_PrefixEnd();
    [CompilerGeneratedAttribute]
public ITreeNode get_SuffixBegin();
    public bool get_IsEmpty();
    public ITreeNode GetFirstPrefixNode();
    public ITreeNode GetLastPrefixNode();
    public ITreeNode GetFirstSuffixNode();
    public ITreeNode GetLastSuffixNode();
    public DocumentRange GetPrefixDocumentRange();
    public DocumentRange GetSuffixDocumentRange();
    private static DocumentRange GetDocRangeOfNode(ITreeNode node);
    public bool HasSuffixNodes();
    public bool CanBeReplacedBy(CppDeclaratorSelection other);
    public CppDeclaratorSelection ReplaceBy(CppDeclaratorSelection other);
    public CppDeclaratorSelection ReplaceBy(CppDeclaratorSelection other, CppPsiModificationStrategy modStrat);
    public CppClonedSelectedType CloneSelectedType();
    public ITreeRange GetUnselectedRange();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenBracketedList : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenCommandNameNode : CppDoxygenNode {
    public NodeType NodeType { get; }
    public string Name { get; }
    public virtual NodeType get_NodeType();
    public string get_Name();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenCommandNode : CppDoxygenNode {
    public NodeType NodeType { get; }
    public CppDoxygenCommandNameNode Name { get; }
    public CppList`1<CppDoxygenParamRef> ParamRefNodes { get; }
    public bool HasParamRefNodes { get; }
    public virtual NodeType get_NodeType();
    public virtual CppDoxygenCommandNameNode get_Name();
    public CppList`1<CppDoxygenParamRef> get_ParamRefNodes();
    public bool get_HasParamRefNodes();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenCommentBodyNode : CppDoxygenNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenCommentNode : FileElementBase {
    public PsiLanguageType Language { get; }
    public NodeType NodeType { get; }
    public bool IsPostComment { get; }
    public bool IsEolComment { get; }
    public CppList`1<CppDoxygenCommandNode> CommandNodes { get; }
    public List`1<CppDoxygenHtmlPairedCommand> HtmlPairedCommandNodes { get; }
    public List`1<CppDoxygenHtmlTag> HtmlTagNodes { get; }
    public virtual PsiLanguageType get_Language();
    public virtual NodeType get_NodeType();
    public bool get_IsPostComment();
    public bool get_IsEolComment();
    public CppList`1<CppDoxygenCommandNode> get_CommandNodes();
    public List`1<CppDoxygenHtmlPairedCommand> get_HtmlPairedCommandNodes();
    public List`1<CppDoxygenHtmlTag> get_HtmlTagNodes();
    [CanBeNullAttribute]
public ICppCompositeNode FindAdjacentCompositeNode(bool skipDoxygen, bool checkPost);
    [CanBeNullAttribute]
public ICppCompositeNode FindAdjacentCompositeNode(bool skipDoxygen);
    [CanBeNullAttribute]
public ICppCompositeNode FindAdjacentCompositeNodeOrParent(bool skipDoxygen);
    [CanBeNullAttribute]
public SimpleDeclaration FindSimpleDeclaration(bool checkPost);
    [CanBeNullAttribute]
public SimpleDeclaration FindSimpleDeclaration();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenCommentNodeNavigator : object {
    public static CppDoxygenCommentNode GetByDoxygenNode(CppDoxygenNode param);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenDeclaration : CppDoxygenNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenDeclarationSpecifiers : CppDoxygenNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenDeclarationSpecifierTypename : CppDoxygenNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenDeclarator : CppDoxygenNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenDeclaratorQualifiedName : CppDoxygenNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenFileRef : CppDoxygenNode {
    private IReadOnlyList`1<IReference> myReferences;
    public NodeType NodeType { get; }
    public ITreeNode WordNode { get; }
    public string UnquotedPath { get; }
    public ITreeNode QuotedPath { get; }
    public IReadOnlyList`1<IReference> References { get; }
    public bool ShouldResolve();
    public virtual NodeType get_NodeType();
    public ITreeNode get_WordNode();
    public string get_UnquotedPath();
    public ITreeNode get_QuotedPath();
    public IReadOnlyList`1<IReference> get_References();
    public virtual ReferenceCollection GetFirstClassReferences();
    public ICppFileReference GetCppReference();
    private IReadOnlyList`1<IReference> CalculateReferences();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenFunctionParamReference : TreeReferenceBase`1<CppDoxygenNode> {
    private TreeTextRange myTreeTextRange;
    private string myParamName;
    public CppDoxygenFunctionParamReference(CppDoxygenNode owner, TreeTextRange treeTextRange, string paramName);
    public virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual IAccessContext GetAccessContext();
    public virtual TreeTextRange GetTreeTextRange();
    public virtual string GetName();
    public virtual ResolveResultWithInfo ResolveWithoutCache();
    public sealed virtual CppTreeElementRange GetTokenRange();
    public sealed virtual ICppCompositeNode GetCppTreeNode();
    public sealed virtual void DropCache();
    private ResolveResultWithInfo ResolveByFunction(CppFunctionDeclaratorResolveEntity ent);
    private bool ParamIsEllipsis();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenHtmlAttribute : CppDoxygenNode {
    private Nullable`1<ValueTuple`2<ITokenNode, ITokenNode>> myNameValue;
    private IReference myFunctionParameterReference;
    private bool myFunctionParameterReferenceInitialized;
    public NodeType NodeType { get; }
    public ITokenNode NameNode { get; }
    public ITokenNode ValueNode { get; }
    public string Name { get; }
    public string Value { get; }
    public IReference FunctionParameterReference { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_NameNode();
    public ITokenNode get_ValueNode();
    public string get_Name();
    public string get_Value();
    public IReference get_FunctionParameterReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    private static bool MoveToNext(ITokenNode& token);
    private static bool SkipWhitespaces(ITokenNode& token);
    private static ValueTuple`2<ITokenNode, ITokenNode> GetNameValue(ITreeNode first);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenHtmlPairedCommand : CppDoxygenNode {
    public NodeType NodeType { get; }
    public CppDoxygenHtmlTag OpenTag { get; }
    public CppList`1<CppDoxygenHtmlAttribute> Attributes { get; }
    [CanBeNullAttribute]
public CppDoxygenHtmlPairedCommandBody Body { get; }
    public virtual NodeType get_NodeType();
    public CppDoxygenHtmlTag get_OpenTag();
    public CppList`1<CppDoxygenHtmlAttribute> get_Attributes();
    public CppDoxygenHtmlPairedCommandBody get_Body();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenHtmlPairedCommandBody : CppDoxygenNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenHtmlTag : CppDoxygenNode {
    public NodeType NodeType { get; }
    public string Name { get; }
    public CppList`1<CppDoxygenHtmlAttribute> Attributes { get; }
    public virtual NodeType get_NodeType();
    public string get_Name();
    public CppList`1<CppDoxygenHtmlAttribute> get_Attributes();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenHtmlTagNavigator : object {
    public static CppDoxygenHtmlTag GetByAttribute(CppDoxygenHtmlAttribute attr);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenLineNode : CppDoxygenNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenList : CppDoxygenNode {
    public NodeType NodeType { get; }
    public CppList`1<CppDoxygenListItem> Items { get; }
    public virtual NodeType get_NodeType();
    public CppList`1<CppDoxygenListItem> get_Items();
    public Kind GetKind();
    private static Kind TokenKind(ITreeNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenListItem : CppDoxygenNode {
    public NodeType NodeType { get; }
    public CppDoxygenListItemMarker Marker { get; }
    public CppDoxygenListItemBody Body { get; }
    public virtual NodeType get_NodeType();
    public CppDoxygenListItemMarker get_Marker();
    public CppDoxygenListItemBody get_Body();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenListItemBody : CppDoxygenNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenListItemMarker : CppDoxygenNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenNameQualifier : CppDoxygenReferenceNode {
    public NodeType NodeType { get; }
    public IReference Reference { get; }
    public virtual NodeType get_NodeType();
    public IReference get_Reference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual ICppReference GetCppReference();
    public virtual CppResolveResult GetCppResolveResult();
    public virtual CppTreeElementRange GetNameTokenRange();
    public CppQualifiedName GetQualifiedName();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenNode : CppCompositeNode {
    public PsiLanguageType Language { get; }
    public CppDoxygenCommentNode GetDoxygenRootNode();
    public virtual PsiLanguageType get_Language();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenPairedCommand : CppDoxygenCommandNode {
    public NodeType NodeType { get; }
    public CppDoxygenCommandNameNode Name { get; }
    public CppDoxygenCommandNameNode EndName { get; }
    public virtual NodeType get_NodeType();
    public virtual CppDoxygenCommandNameNode get_Name();
    public CppDoxygenCommandNameNode get_EndName();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenPairedCommandBodyNode : CppDoxygenNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenParagraphNode : CppDoxygenNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenParametersAndQualifiers : CppDoxygenNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenParamRef : CppDoxygenReferenceNode {
    private IReference myReference;
    public NodeType NodeType { get; }
    public IReference Reference { get; }
    public bool IsEllipsis { get; }
    public virtual NodeType get_NodeType();
    public IReference get_Reference();
    public bool get_IsEllipsis();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual ICppReference GetCppReference();
    public virtual CppResolveResult GetCppResolveResult();
    public virtual CppTreeElementRange GetNameTokenRange();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenQualifiedReference : CppDoxygenReferenceNode {
    private ICppReference myReference;
    public NodeType NodeType { get; }
    public IReference Reference { get; }
    public virtual NodeType get_NodeType();
    public IReference get_Reference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual ICppReference GetCppReference();
    public virtual CppResolveResult GetCppResolveResult();
    public virtual CppTreeElementRange GetNameTokenRange();
    public CppQualifiedName GetQualifiedName();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenQuotedStringNode : CppDoxygenNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenReferenceNode : CppDoxygenNode {
    public abstract virtual ICppReference GetCppReference();
    public abstract virtual CppResolveResult GetCppResolveResult();
    public abstract virtual CppTreeElementRange GetNameTokenRange();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenReferenceNodeNavigator : object {
    public static CppDoxygenReferenceNode GetByIdentifier(ITokenNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenTemplateParamRef : CppDoxygenReferenceNode {
    private IReference myReference;
    public NodeType NodeType { get; }
    public IReference Reference { get; }
    public virtual NodeType get_NodeType();
    public IReference get_Reference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual ICppReference GetCppReference();
    public virtual CppResolveResult GetCppResolveResult();
    public virtual CppTreeElementRange GetNameTokenRange();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppDoxygenWordNode : CppDoxygenNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
internal class JetBrains.ReSharper.Psi.Cpp.Tree.CppEnsureExpressionResolvedVisitor : CppAbstractResolvedExpressionVisitor`1<CppMonostate> {
    public static CppEnsureExpressionResolvedVisitor Instance;
    private static CppEnsureExpressionResolvedVisitor();
    public virtual CppMonostate VisitExpression(ICppResolvedExpression expr);
    public virtual CppMonostate Visit(ICppEmptyExpression _);
    public virtual CppMonostate Visit(ICppResolvedLiteralExpression _);
    public virtual CppMonostate Visit(ICppResolvedUserDefinedLiteralExpression _);
    public virtual CppMonostate Visit(ICppResolvedThisExpression expr);
    public virtual CppMonostate Visit(ICppParenExpression expr);
    public virtual CppMonostate Visit(ICppResolvedBinaryExpression expr);
    public virtual CppMonostate Visit(ICppResolvedUnaryExpression expr);
    public virtual CppMonostate Visit(ICppResolvedPostfixExpression expr);
    public virtual CppMonostate Visit(ICppResolvedConditionalExpression _);
    public virtual CppMonostate Visit(ICppResolvedQualifiedReferenceExpression expr);
    public virtual CppMonostate Visit(ICppResolvedMemberAccessExpression expr);
    public virtual CppMonostate Visit(ICppResolvedNewExpression expr);
    public virtual CppMonostate Visit(ICppDeleteExpression _);
    public virtual CppMonostate Visit(ICppResolvedSubscriptExpression expr);
    public virtual CppMonostate Visit(ICppResolvedCliMultiArgumentSubscriptExpression expr);
    public virtual CppMonostate Visit(ICppResolvedCallExpression expr);
    public virtual CppMonostate Visit(ICppResolvedCastExpression expr);
    public virtual CppMonostate Visit(ICppResolvedSizeOfExpression _);
    public virtual CppMonostate Visit(ICppResolvedSizeOfEllipsisExpression expr);
    public virtual CppMonostate Visit(ICppResolvedAlignOfExpression expr);
    public virtual CppMonostate Visit(ICppResolvedTypeIdExpression _);
    public virtual CppMonostate Visit(ICppResolvedNoExceptExpression _);
    public virtual CppMonostate Visit(ICppResolvedSingleArgumentTypeTraitExpression _);
    public virtual CppMonostate Visit(ICppResolvedDoubleArgumentTypeTraitExpression _);
    public virtual CppMonostate Visit(ICppResolvedMultiArgumentTypeTraitExpression _);
    public virtual CppMonostate Visit(ICppResolvedMSUuidOfExpression _);
    public virtual CppMonostate Visit(ICppMSNoopExpression _);
    public virtual CppMonostate Visit(ICppMSAssumeExpression _);
    public virtual CppMonostate Visit(ICppResolvedBuiltinAddressOfExpression _);
    public virtual CppMonostate Visit(ICppResolvedBuiltinOffsetOfExpression _);
    public virtual CppMonostate Visit(ICppResolvedGnuBuiltinConstantPExpression _);
    public virtual CppMonostate Visit(ICppResolvedGNUAddressOfLabelExpression _);
    public virtual CppMonostate Visit(ICppThrowExpression _);
    public virtual CppMonostate Visit(ICppResolvedBracedInitListExpression _);
    public virtual CppMonostate Visit(ICppResolvedBraceInitializedTemporaryExpression expr);
    public virtual CppMonostate Visit(ICppLambdaExpression _);
    public virtual CppMonostate Visit(ICppReplacedLambdaExpression _);
    public virtual CppMonostate Visit(ICppGnuStatementExpression _);
    public virtual CppMonostate Visit(ICppReplacedGnuStatementExpression _);
    public virtual CppMonostate Visit(ICppRequiresExpression _);
    public virtual CppMonostate Visit(ICppReplacedRequiresExpression _);
    public virtual CppMonostate Visit(ICppLinkageRequiresExpression _);
    public virtual CppMonostate Visit(ICppCliTypeIdExpression _);
    public virtual CppMonostate Visit(ICppResolvedPackExpansionExpression _);
    public virtual CppMonostate Visit(ICppResolvedCliTypeIdExpression expr);
    public virtual CppMonostate Visit(ICppResolvedFoldExpression expr);
    public virtual CppMonostate Visit(ICppResolvedCoAwaitExpression expr);
    public virtual CppMonostate Visit(ICppResolvedCoYieldExpression expr);
    public virtual CppMonostate Visit(ICppResolvedC11GenericExpression expr);
    public virtual CppMonostate Visit(ICppResolvedDesignation _);
}
public enum JetBrains.ReSharper.Psi.Cpp.Tree.CppEvaluationContext : Enum {
    public int value__;
    public static CppEvaluationContext BOTH;
    public static CppEvaluationContext COMPILE_TIME_ONLY;
    public static CppEvaluationContext RUNTIME_ONLY;
    public static CppEvaluationContext UNEVALUATED;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppEvaluationContextUtil : object {
    [ExtensionAttribute]
public static CppEvaluationParams InConstantContextOf(CppEvaluationParams evalParams, ITreeNode node);
    [ExtensionAttribute]
private static CppIsConstantEvaluatedAssumedValue ToIsConstantEvaluatedAssumedValue(CppEvaluationContext context);
    public static CppEvaluationContext GetEvaluationContext(ITreeNode node);
    private static CppEvaluationContext GetEvaluationContextByGlobalVariable(CppVariableDeclaratorResolveEntity ent);
    private static CppEvaluationContext GetEvaluationContextByDeclarationOfFunction(SimpleDeclaration simpleDeclaration);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.CppExpressionNode : CppCompositeNode {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myChildrenAreResolved;
    public virtual CppTypeAndCategory GetTypeAndCategory();
    public virtual CppTypeAndCategory GetVerboseTypeAndCategory();
    public virtual CppQualType GetVerboseType();
    public sealed virtual void MarkChildrenAsResolved();
    public sealed virtual bool ChildrenAreResolved();
    public abstract virtual CppDependentInfo GetDependentInfo();
    public virtual TriBool IsNoexcept();
    public virtual CppTypeContext TryGetTypeContext();
    public abstract virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public abstract virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppExpressionNodeUtil : object {
    public static Key`1<Ref`1<CppTypeAndCategory>> ExpressionTypeKey;
    public static Key`1<Ref`1<CppTypeAndCategory>> ExpressionVerboseTypeKey;
    private static CppExpressionNodeUtil();
    [ExtensionAttribute]
public static ICppExpressionNode GetOutermostExpression(ICppExpressionNode expr);
    [ExtensionAttribute]
public static ICppExpressionNode GetExpressionThroughParens(ICppExpressionNode expr);
    [ExtensionAttribute]
public static ITreeNode GetParentThroughParens(ICppExpressionNode expr);
    [ExtensionAttribute]
public static ICppExpressionNode GetOutermostParenExpression(ICppExpressionNode expr);
    public static IEnumerable`1<CppQualType> CollectAllSubtypes(ICppExpressionNode expression);
    public static IEnumerable`1<CppQualType> CollectAllSubtypesFromOuterExpressions(IEnumerable`1<ICppExpressionNode> expressions);
    public static CppTypeAndCategory GetTypeAndCategory(ICppExpressionNode node);
    public static CppTypeAndCategory GetVerboseTypeAndCategory(ICppExpressionNode node);
    [ExtensionAttribute]
public static ICppExpression ConvertToReplacedExpression(ICppExpressionNode node);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.CppExpressionNodeWithCachedDepInfo : CppExpressionNode {
    private CppDependentInfo myDependentInfo;
    public virtual CppDependentInfo GetDependentInfo();
    protected abstract virtual CppDependentInfo CalculateDependentInfo();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppExpressionsArgumentListNodeNavigator : object {
    public static ICppExpressionsArgumentListNode GetBySingleArgument(ICppExpressionNode node);
    public static ICppExpressionsArgumentListNode GetByArgument(ICppExpressionNode node);
    public static ICppExpressionsArgumentListNode GetByLBracket(ITokenNode node);
    public static ICppExpressionsArgumentListNode GetByRBracket(ITokenNode node);
    public static ICppExpression[] GetArguments(ICppExpressionsArgumentListNode argList);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppExpressionTreeUtil : object {
    public static CppQualType GetTypeForExpressionOrDeclaration(ICppExpressionOrDeclarationNode node);
    [ExtensionAttribute]
public static ICppResolvedExpression ConvertExpressionNodeToExpression(ICppExpressionNode node);
    [ExtensionAttribute]
public static ICppTypeIdOrExpression ConvertExpressionOrTypeIdNodeToExpression(ICppTypeIdOrExpressionNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppFile : FileElementBase {
    private CppFileSymbolsCache myFileSymbolsCache;
    private int myModificationStamp;
    private CppNoConcurrencyChecker myCc;
    [CompilerGeneratedAttribute]
private CppFileSymbolTable <FileSymbolTable>k__BackingField;
    [CompilerGeneratedAttribute]
private CppFileContextSignature <FileContextSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private CppInclusionContext <InclusionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IntSet <WordSetAfterReSync>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDestroyed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ModificationAfterReparse>k__BackingField;
    [CompilerGeneratedAttribute]
private CppParserProfilingInfo <ProfilingInfo>k__BackingField;
    public CppFileLocation File { get; }
    public CppFileSymbolTable FileSymbolTable { get; public set; }
    public CppFileContextSignature FileContextSignature { get; public set; }
    public CppInclusionContext InclusionContext { get; public set; }
    public IntSet WordSetAfterReSync { get; public set; }
    public ILogger Logger { get; }
    public bool IsDestroyed { get; public set; }
    public int ModificationAfterReparse { get; public set; }
    public bool IsDummy { get; }
    public CppParserProfilingInfo ProfilingInfo { get; public set; }
    public IModuleReferenceResolveContext ResolveContext { get; public set; }
    public bool IsOpened { get; }
    public CppFileSymbolsCache FileSymbolsCache { get; public set; }
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public Nullable`1<int> ModificationStamp { get; public set; }
    public bool HasSpecialCommitReparse { get; }
    public CppFileLocation get_File();
    [CompilerGeneratedAttribute]
public CppFileSymbolTable get_FileSymbolTable();
    [CompilerGeneratedAttribute]
public void set_FileSymbolTable(CppFileSymbolTable value);
    [CompilerGeneratedAttribute]
public CppFileContextSignature get_FileContextSignature();
    [CompilerGeneratedAttribute]
public void set_FileContextSignature(CppFileContextSignature value);
    [CompilerGeneratedAttribute]
public CppInclusionContext get_InclusionContext();
    [CompilerGeneratedAttribute]
public void set_InclusionContext(CppInclusionContext value);
    [CompilerGeneratedAttribute]
public IntSet get_WordSetAfterReSync();
    [CompilerGeneratedAttribute]
public void set_WordSetAfterReSync(IntSet value);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public bool get_IsDestroyed();
    [CompilerGeneratedAttribute]
public void set_IsDestroyed(bool value);
    [CompilerGeneratedAttribute]
public int get_ModificationAfterReparse();
    [CompilerGeneratedAttribute]
public void set_ModificationAfterReparse(int value);
    public bool get_IsDummy();
    [CompilerGeneratedAttribute]
public CppParserProfilingInfo get_ProfilingInfo();
    [CompilerGeneratedAttribute]
public void set_ProfilingInfo(CppParserProfilingInfo value);
    public IModuleReferenceResolveContext get_ResolveContext();
    public void set_ResolveContext(IModuleReferenceResolveContext value);
    public sealed virtual bool get_IsOpened();
    public sealed virtual IChameleonNode ReSync(CachingLexer cachingLexer, TreeTextRange changedRange, int insertedTextLen);
    public sealed virtual ICppScopeResolveEntity GetScopeForDeclarations();
    public sealed virtual CppDeclarationOwnerKind GetDeclarationOwnerKind();
    public sealed virtual IEnumerable`1<ICppCompositeNode> GetMembers();
    public sealed virtual ICppTopLevelDeclarationNode GetNextDeclaration(ICppTopLevelDeclarationNode decl);
    public sealed virtual ICppTopLevelDeclarationNode GetPrevDeclaration(ICppTopLevelDeclarationNode decl);
    public sealed virtual bool CanAddDeclarationBefore(ITreeNode anchor);
    public sealed virtual bool CanAddDeclarationAfter(ITreeNode anchor);
    public sealed virtual CppComplexOffset GetTopComplexOffset();
    public sealed virtual CppComplexOffset GetBottomComplexOffset();
    public sealed virtual ITreeNode GetBodyStartAnchor();
    public sealed virtual ITreeNode GetBodyEndAnchor();
    public sealed virtual T AddDeclarationBefore(T decl, ITreeNode anchor, bool withComments);
    public sealed virtual T AddDeclarationAfter(T decl, ITreeNode anchor, bool withComments);
    public sealed virtual void RemoveDeclaration(T decl, CppCommentsDeleteMode commentsDeleteMode);
    public sealed virtual CppFileSymbolsCache get_FileSymbolsCache();
    public void set_FileSymbolsCache(CppFileSymbolsCache value);
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public sealed virtual ICppScopeResolveEntity GetResolveScope();
    public sealed virtual CppComplexOffset GetComplexOffset();
    public sealed virtual CppFile GetContainingFile();
    public sealed virtual CppFileSymbolsCache GetFileCache();
    public sealed virtual void DropReferences();
    public sealed virtual Nullable`1<int> get_ModificationStamp();
    public sealed virtual void set_ModificationStamp(Nullable`1<int> value);
    public virtual void CommitReparse(ITreeNode oldElement, ITreeNode newElement);
    public virtual bool get_HasSpecialCommitReparse();
    public virtual IChameleonNode FindChameleonWhichCoversRange(TreeTextRange textRange);
    public static CppFile GetPsiFileForSourceFile(ISolution solution, IPsiSourceFile sourceFile, CppFileLocation file);
    public static CppFile GetRandomPsiFile(ISolution solution, CppFileLocation file);
    public static CppSmallList`1<CppFile> GetAllPsiFiles(ISolution solution, CppFileLocation file);
    public static CppSmallList`1<CppFile> GetCachedCppFiles(IPsiServices psiServices, CppExternalModule externalModule, CppFileLocation file);
    private static void ShiftOffsets(ITreeNode node, ITreeNode skipNode, int offset, int delta);
    private static void ShiftOffsets(CppChameleonCompoundStatement chameleon, int delta);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppFileUtil : object {
    [ExtensionAttribute]
public static CppGlobalSymbolCache GetGlobalSymbolCache(CppFile cppFile);
    [ExtensionAttribute]
public static bool IncludesUEGeneratedHeader(CppFile file);
    [ExtensionAttribute]
public static bool NeedsIncludeGuard(CppFile file);
    [ExtensionAttribute]
public static bool ContainsExportModuleDeclaration(CppFile file);
    [ExtensionAttribute]
public static bool IsInUnrealSolution(CppFile file);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.CppFunctionDeclaration : object {
    public ICppDeclarationTrailingNode TrailingNode { get; }
    public FunctionParameters Parameters { get; }
    public ITreeNode FunctionDeclarationNode { get; }
    [CanBeNullAttribute]
public static CppFunctionDeclaration TryCreateFromFunctionDeclaration(SimpleDeclaration simpleDecl);
    public static CppFunctionDeclaration CreateFromLambda(LambdaExpression lambda);
    [CanBeNullAttribute]
public static CppFunctionDeclaration TryCreateFromTrailingNode(ICppDeclarationTrailingNode node);
    [CanBeNullAttribute]
public SimpleDeclaration GetUnderlyingNodeIfSimpleDeclaration();
    [CanBeNullAttribute]
public abstract virtual ICppFunctionDeclaratorResolveEntity GetFunctionResolveEntity();
    [CanBeNullAttribute]
public abstract virtual CppTypeSelection GetReturnTypeSelection();
    public abstract virtual ICppDeclarationTrailingNode get_TrailingNode();
    public abstract virtual FunctionParameters get_Parameters();
    public abstract virtual ITreeNode get_FunctionDeclarationNode();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppHasFailedConversionsVisitor : object {
    [CompilerGeneratedAttribute]
private bool <Result>k__BackingField;
    public bool Result { get; private set; }
    public sealed virtual bool Visit(CppOverloadingRunInfo info);
    public sealed virtual bool Visit(CppImplicitConversionSequence conv);
    public sealed virtual bool Visit(CppCastConversion conv);
    [CompilerGeneratedAttribute]
public bool get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(bool value);
    private bool SetResultYes();
}
internal class JetBrains.ReSharper.Psi.Cpp.Tree.CppImplicitConversionCache : CppImplicitConversionPsiCache {
    private CppImplicitConversionSequence myConvSeq;
    public CppImplicitConversionCache(CppImplicitConversionSequence seq, CppImplicitConversionPsiCache next);
    protected virtual void TraverseImpl(ICppConversionVisitor visitor);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.CppImplicitConversionPsiCache : object {
    public static CppImplicitConversionPsiCache Invalid;
    public static Key`1<CppImplicitConversionPsiCache> CachedConversionKey;
    private CppImplicitConversionPsiCache myNext;
    private static CppImplicitConversionPsiCache();
    protected CppImplicitConversionPsiCache(CppImplicitConversionPsiCache next);
    public static CppImplicitConversionPsiCache Create(CppImplicitConversionSequence seq, CppImplicitConversionPsiCache next);
    public static CppImplicitConversionPsiCache Create(CppOverloadingRunInfo info, CppImplicitConversionPsiCache next);
    public static CppImplicitConversionPsiCache Create(CppCastConversion conv, CppImplicitConversionPsiCache next);
    protected abstract virtual void TraverseImpl(ICppConversionVisitor visitor);
    public void Traverse(ICppConversionVisitor visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppImportFileReference : CppBaseFileReference`1<ICppImportDirective> {
    protected ITokenNode PathToken { get; }
    public CppImportFileReference(ICppImportDirective owner, ICppFileReference parentReference, string pathPart, TextRange range, bool isFolderReference);
    protected virtual ITokenNode get_PathToken();
    public virtual IEnumerable`1<VirtualFileSystemPath> GetSearchPaths();
    public virtual ResolveResultWithInfo ResolveWithoutCache();
    public virtual IReference BindTo(IDeclaredElement element);
    public IReference BindTo(IDeclaredElement element, CppImportFileReference contextRef);
    [CanBeNullAttribute]
public static RelativePath FindBindPath(CppInclusionContext context, CppInclusionContext srcContext, VirtualFileSystemPath newPath, VirtualFileSystemPath localPath, string lookupPath, bool isAngleBracket, bool isIncludeNext, bool isFolder);
    private static bool VerifyIncludeTarget(RelativePath path, VirtualFileSystemPath fullPath, VirtualFileSystemPath localSearchPath, List`1<VirtualFileSystemPath> searchPaths, bool isFolder);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Tree.CppImportFileReference/<ListBindPaths>d__9")]
private static IEnumerable`1<RelativePath> ListBindPaths(VirtualFileSystemPath newPath, VirtualFileSystemPath localSearchPath, List`1<VirtualFileSystemPath> searchPaths, CppInclusionContext srcContext, string lookupPath, bool isAngleBracket, bool isIncludeNext, bool isFolder);
    private static bool IsValidPath(RelativePath path);
    private static bool IsValidSubPath(RelativePath path);
    private IReference ReplacePath(IPath newPath, bool onlyName);
}
internal class JetBrains.ReSharper.Psi.Cpp.Tree.CppInvalidConversionPsiCache : CppImplicitConversionPsiCache {
    protected virtual void TraverseImpl(ICppConversionVisitor v);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppLinkedFileReference : CppImportFileReference {
    private CppFileLocation myLinkedFile;
    public CppLinkedFileReference(ICppImportDirective owner, string pathPart, TextRange range, CppFileLocation linkedFile);
    public virtual ResolveResultWithInfo ResolveWithoutCache();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppLocateSymbolUtil : object {
    [ExtensionAttribute]
public static IGenericSymbolNode LocateDeclarator(ICppSymbol symbol, ISolution solution);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Tree.CppLocateSymbolUtil/<LocateDeclaratorInAllFiles>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<IGenericSymbolNode> LocateDeclaratorInAllFiles(ICppSymbol symbol, ISolution solution);
    [ExtensionAttribute]
public static IGenericSymbolNode LocateDeclarator(ICppSymbol symbol, CppFile root);
    private static CppComplexOffset GetNavigationOffsetByName(BaseQualifiedName name);
    private static CppComplexOffset GetNavigationOffset(IGenericSymbolNode symbolNode);
    public static IGenericSymbolNode LocateDeclaratorDontCheckRoot(ICppSymbol symbol, CppFile root, Boolean& unqualifiedIdTypenameExists);
    [CompilerGeneratedAttribute]
internal static void <LocateDeclaratorDontCheckRoot>g__CheckIfUnqualifiedTypename|5_0(BaseQualifiedName typename, Boolean& existedUnqualifiedIdTypename, CppComplexOffset symbolOffset);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.CppLoopStatementBase : CppCompositeNode {
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ICppStatement Body { get; }
    public ITokenNode get_LPar();
    public ITokenNode get_RPar();
    public virtual ICppStatement get_Body();
    public abstract virtual ICppScopeResolveEntity GetResolveScope();
}
public enum JetBrains.ReSharper.Psi.Cpp.Tree.CppMemInitNameTargetKind : Enum {
    public int value__;
    public static CppMemInitNameTargetKind DataMember;
    public static CppMemInitNameTargetKind BaseClass;
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppModificationUtil : object {
    public static ITreeRange AddChildRange(ITreeNode parent, ITreeNode anchor, ITreeRange range, CppAddChildMode mode, bool withComments);
    public static ITreeRange AddChildRangeSafe(ITreeNode parent, ITreeNode anchor, ITreeRange range, CppAddChildMode mode, bool withComments);
    public static T AddChild(ITreeNode anchor, T child, CppAddChildMode mode, bool withComments);
    public static T AddChildSafe(ITreeNode anchor, T child, CppAddChildMode mode, bool withComments);
    public static T AddChild(ITreeNode parent, ITreeNode anchor, T child, CppAddChildMode mode, bool withComments);
    public static void DeleteChild(ITreeNode child, CppCommentsDeleteMode commentsDeleteMode);
    public static void DeleteChildSafe(ITreeNode child, CppCommentsDeleteMode commentsDeleteMode);
    public static void DeleteChildRange(ITreeRange range, CppCommentsDeleteMode commentsDeleteMode);
    public static void DeleteChildRangeSafe(ITreeRange range, CppCommentsDeleteMode commentsDeleteMode);
    public static T ReplaceChild(ITreeNode oldChild, T newChild, CppCommentsReplaceMode commentsMode);
    public static ITreeRange ReplaceChildRangeNotFormatting(ITreeRange oldNodes, ITreeRange newNodes, CppCommentsReplaceMode commentsMode);
    public static ITreeRange ReplaceChildRangeNotFormattingSafe(ITreeRange oldNodes, ITreeRange newNodes, CppCommentsReplaceMode commentsMode);
    public static T ReplaceChildSafe(ITreeNode oldChild, T newChild, CppCommentsReplaceMode commentsMode);
    public static ITreeRange ReplaceChildRange(ITreeRange oldNodes, ITreeRange newNodes, CppCommentsReplaceMode commentsMode);
    public static ITreeRange ReplaceChildRangeSafe(ITreeRange oldNodes, ITreeRange newNodes, CppCommentsReplaceMode commentsMode);
    public static ITreeRange Replace(CppReplacePsiModification task);
    public static IDictionary`2<CppReplacePsiModification, ITreeRange> BulkReplace(CppBulkReplacePsiModification task);
    public static T CloneNode(T node);
    public static bool CanBeAdded(ITreeNode parent, ITreeNode anchor, ITreeNode child, CppAddChildMode mode);
    public static bool CanBeAdded(ITreeNode parent, ITreeNode anchor, ITreeRange range, CppAddChildMode mode);
    public static bool CanBeAdded(ITreeNode anchor, ITreeNode child, CppAddChildMode mode);
    public static bool CanBeAddedTo(ITreeNode anchor, CppAddChildMode mode);
    public static bool ChildCanBeAdded(ITreeNode subtree);
    public static bool ChildCanBeAdded(ITreeRange range);
    public static bool CanBeDeleted(ITreeNode node);
    public static bool CanBeDeleted(ITreeRange range);
    public static bool CanBeReplaced(ITreeNode oldChild, ITreeNode newChild);
    public static bool CanBeReplaced(ITreeRange oldNodes, ITreeRange newNodes);
    public static bool CanBeReplacedToSomethingTrivial(ITreeNode node);
}
internal static class JetBrains.ReSharper.Psi.Cpp.Tree.CppModificationUtilImpl : object {
    public static bool IsPureWhitespace(ITreeNode subtree);
    public static ITreeRange AddChildRangeNotFormatting(ITreeNode parent, ITreeNode anchor, ITreeRange range, bool withComments, bool afterAnchorComments, CppAddChildMode mode);
    private static ITreeRange AddChildRangeNotFormattingImpl(ITreeNode parent, ITreeNode anchor, ITreeNode clearedAnchorParent, ITreeNode clearedAnchor, ITreeRange range, bool withComments, bool anchorComments, CppAddChildMode mode);
    private static ICodeFormatter GetCodeFormatter();
    public static ICodeFormatterImpl GetCodeFormatterImpl();
    public static ITreeRange FormatInserted(ITreeRange inserted, ITreeRange original);
    private static T FormatReplaced(ITreeNode oldNode, T newNode);
    public static ITreeRange FormatReplaced(ITreeRange replaced, ITreeRange original);
    private static CppTreeElementRange DeviseMacroArgumentProtoTokensRangeFor(ITreeNode node);
    private static List`1<ITokenNode> DeviseAndFixateMacroArgumentProtoTokensFor(ITreeRange range);
    private static bool DbgCheckMAProtoTokensPertainToSameMA(IEnumerable`1<ITokenNode> toks);
    public static void ClearPrototypeMacroCache(ITreeNode node);
    private static void ClearPrototypeMacroCache(ITreeRange range);
    private static void UpdateNextTokenIndices(ITokenNode firstToken, int offsetDelta, int index, int tokenIndexDelta);
    private static OffsetAndMacroArgumentInfoRange FindOffsetAndMacroArgumentInfoRange(LazyTokenView tokens);
    public static void DeleteSubstitutionTokens(ITreeRange range);
    private static ITreeNode ClearAnchorThrough(IEnumerable`1<ITokenNode> tokens, bool leftish);
    private static ITreeNode ClearLeftAnchor(ITreeNode anchor, bool withComments);
    private static ITreeNode ClearRightAnchor(ITreeNode anchor, bool withComments);
    public static ITreeNode ClearAnchor(CppAddChildMode mode, ITreeNode anchor, bool withComments);
    public static void AddCommentsOnInsert(ITreeRange inserted, ITreeRange originalRange, ITreeRange& commentsInsertedBefore, ITreeRange& commentsInsertedAfter);
    public static void ProcessCommentsOnDelete(ITreeRange range, CppCommentsDeleteMode commentsDeleteMode);
    public static void DeletePrototypeTokensFor(ITreeRange range);
    public static void DeleteRangeIfMacroSpawnsOnlySubtreesOf(ITreeRange range);
    public static bool CanBeDeletedImpl(ITreeNode node, bool andReplacedToSomethingTrivial);
    private static ITokenNode FindNonWhitespaceToken(IEnumerable`1<ITokenNode> tokens);
    public static T RawCloneNode(T node);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertChildNodeType();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppNestedDeclarationNavigator : object {
    [ExtensionAttribute]
public static ICppTopLevelDeclarationNode GetOutermostInterestingTopLevelDeclaration(ICppTopLevelDeclarationNode declaration);
    [ExtensionAttribute]
public static ICppNestedDeclarationNode GetInnerDeclaration(ICppTopLevelDeclarationNode node);
    [ExtensionAttribute]
public static ICppNestedDeclarationNode GetOuterDeclaration(ICppNestedDeclarationNode node);
    [ExtensionAttribute]
public static ICppTopLevelDeclarationNode GetInnerMostDeclaration(ICppTopLevelDeclarationNode node);
    [ExtensionAttribute]
public static ICppNestedDeclarationNode GetOuterMostDeclaration(ICppNestedDeclarationNode node);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppNonAbstractDeclaratorBaseNavigator : object {
    public static NonAbstractDeclaratorBase GetByDeclaratorQualifiedName(DeclaratorQualifiedName dqn);
    public static NonAbstractDeclaratorBase GetByRequiresClause(RequiresClause clause);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppNonAbstractDeclaratorNodeUtil : object {
    public static bool IsDefaultInitInDeclarator(Declarator declarator);
    private static bool IsDefaultInitInNonInitDeclarator(ICppDeclaratorResolveEntity ent);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppOccurrencesComparer`1 : OccurrencesComparer`1<TreeNode> {
    private bool myIgnoreMacroOrigin;
    private List`1<Pair`2<ITreeNode, ITreeNode>> myDifferingSubtrees;
    private HashSet`1<ITreeNode> myBlackSet;
    public IEnumerable`1<Pair`2<TreeNode, TreeNode>> DifferingSubtrees { get; }
    public Pair`2<TreeNode, TreeNode> DifferingSubtreesLCA { get; }
    public CppOccurrencesComparer`1(TreeNode tree, bool ignoreMacroOrigin);
    public IEnumerable`1<Pair`2<TreeNode, TreeNode>> get_DifferingSubtrees();
    public Pair`2<TreeNode, TreeNode> get_DifferingSubtreesLCA();
    public virtual bool CompareWith(ITreeNode element);
    protected virtual bool AreNodesEquivalent(ITreeNode one, ITreeNode other, ElementsIndex index);
    protected virtual bool AreNodesEquivalent(ITreeNode one, ITreeNode other);
    private void BlackParents(ITreeNode n);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppOccurrencesComparerUtil : object {
    public static bool AreNodesEquivalent(ITreeNode node1, ITreeNode node2);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.CppOperatorReferenceBase`1 : CppReferenceBase`1<TOwnerExpr> {
    protected CppOperatorReferenceBase`1(TOwnerExpr owner);
    public abstract virtual bool IsDependentReference();
    public virtual ResolveResultWithInfo ResolveWithoutCache();
    public virtual string GetName();
    protected abstract virtual CppResolveResult DoOverloadResolution();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppOperatorReferenceName : object {
    public static string ReferenceName;
    private static CppOperatorReferenceName();
}
internal class JetBrains.ReSharper.Psi.Cpp.Tree.CppOverloadingRunCache : CppImplicitConversionPsiCache {
    private CppOverloadingRunInfo myInfo;
    public CppOverloadingRunCache(CppOverloadingRunInfo info, CppImplicitConversionPsiCache next);
    protected virtual void TraverseImpl(ICppConversionVisitor visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppPattern : object {
    private static IEnumerable`1<NodeTypeSet> ourKeywordsFactorization;
    [CompilerGeneratedAttribute]
private NodeType <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeType <LeftSibling>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeType <LeftSiblingLastChild>k__BackingField;
    public NodeType Parent { get; }
    public NodeType LeftSibling { get; }
    public NodeType LeftSiblingLastChild { get; }
    public CppPattern(NodeType parent, NodeType leftSibling, NodeType leftSiblingLastChild);
    private static CppPattern();
    [CompilerGeneratedAttribute]
public NodeType get_Parent();
    [CompilerGeneratedAttribute]
public NodeType get_LeftSibling();
    [CompilerGeneratedAttribute]
public NodeType get_LeftSiblingLastChild();
    public bool Equals(CppPattern other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static CppPattern GetPatternOfNode(ITreeNode& current, ITreeNode& leftSibling, bool ignoreAttributes);
    public static NodeType GetRepresentativeKeyword(NodeType type);
    public static NodeTypeSet GetGroupByRepresentativeKeyword(NodeType type);
    private static NodeType GetSiblingType(NodeType type);
    private static bool IsFunctionArgumentListButNotParameterList(ITreeNode argList);
    [CompilerGeneratedAttribute]
internal static ITreeNode <GetPatternOfNode>g__GetContext|14_0(ITreeNode node);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppPsiDumper : object {
    public static string DumpPsi(ITreeNode node, bool dumpPreprocessed, ICppPresenter presenter);
    public static string DumpPsi(ITreeNode node, bool dumpPreprocessed, bool dumpComments, ICppPresenter presenter);
    public static string DumpPsi(CppTreeElementRange range, bool dumpPreprocessed, ICppPresenter presenter);
    public static string DumpPsi(CppTreeElementRange range, bool dumpPreprocessed, bool dumpComments, ICppPresenter presenter);
}
public enum JetBrains.ReSharper.Psi.Cpp.Tree.CppPsiModificationStrategy : Enum {
    public int value__;
    public static CppPsiModificationStrategy Normal;
    public static CppPsiModificationStrategy ThrowExceptionOnInvalidReplace;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppPsiModificationStrategyUtil : object {
    [ExtensionAttribute]
public static ITreeRange AddChildRangeBefore(CppPsiModificationStrategy strategy, ITreeNode parent, ITreeNode anchor, ITreeRange range, bool withComments);
    [ExtensionAttribute]
public static void DeleteChildRange(CppPsiModificationStrategy strategy, ITreeRange range, CppCommentsDeleteMode commentsDeleteMode);
    [ExtensionAttribute]
public static ITreeRange ReplaceChildRange(CppPsiModificationStrategy strategy, ITreeRange oldNodes, ITreeRange newNodes, CppCommentsReplaceMode commentsMode);
    [ExtensionAttribute]
public static T ReplaceChild(CppPsiModificationStrategy strategy, ITreeNode oldChild, T newChild, CppCommentsReplaceMode commentsMode);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppPsiNodeModificationException : Exception {
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppQualifiedReferenceSimpleReference`1 : CppReferenceBase`1<TOwnerElement> {
    public CppQualifiedReferenceSimpleReference`1(TOwnerElement owner);
    public virtual ResolveResultWithInfo ResolveWithoutCache();
    public virtual string GetName();
    public virtual CppTreeElementRange GetTokenRange();
    private TOwnerElement GetElementInternal();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.CppReferenceBase`1 : CppReferenceWithoutCacheBase`1<TOwnerElement> {
    protected ResolveResultWithInfo myResolveResult;
    public ResolveResultWithInfo CurrentResolveResult { get; public set; }
    protected CppReferenceBase`1(TOwnerElement owner);
    public virtual ResolveResultWithInfo Resolve();
    public virtual void DropCache();
    public virtual ResolveResultWithInfo get_CurrentResolveResult();
    public virtual void set_CurrentResolveResult(ResolveResultWithInfo value);
    public abstract virtual ResolveResultWithInfo ResolveWithoutCache();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppReferenceNodeUtil : object {
    public static CppLookupResult LookupReference(ICppReferenceNode node);
    public static CppResolveResult ResolveReference(ICppReferenceNode node);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.CppReferenceWithoutCacheBase`1 : UserDataHolder {
    [CompilerGeneratedAttribute]
private TOwnerElement <owner>P;
    public bool HasMultipleNames { get; }
    public ResolveResultWithInfo CurrentResolveResult { get; public set; }
    protected CppReferenceWithoutCacheBase`1(TOwnerElement owner);
    public abstract virtual string GetName();
    public abstract virtual CppTreeElementRange GetTokenRange();
    public virtual bool IsValid();
    public abstract virtual ResolveResultWithInfo Resolve();
    public virtual ITreeNode GetTreeNode();
    public virtual ICppCompositeNode GetCppTreeNode();
    public virtual TreeTextRange GetTreeTextRange();
    public virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public virtual IReference BindTo(IDeclaredElement e);
    public virtual IReference BindTo(IDeclaredElement e, ISubstitution s);
    public virtual IAccessContext GetAccessContext();
    public virtual bool get_HasMultipleNames();
    public virtual HybridCollection`1<string> GetAllNames();
    public virtual void DropCache();
    protected TOwnerElement GetElement();
    public virtual ResolveResultWithInfo get_CurrentResolveResult();
    public virtual void set_CurrentResolveResult(ResolveResultWithInfo value);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppReplacePsiModification : object {
    public ITreeRange OldNodes;
    public ITreeRange NewNodes;
    public bool DoFormat;
    public CppCommentsReplaceMode CommentsReplaceMode;
    public CppReplacePsiModification(ITreeRange oldNodes, ITreeRange newNodes, bool doFormat, CppCommentsReplaceMode commentsReplaceMode);
    public CppReplacePsiModification(ITreeRange oldNodes, ITreeRange newNodes);
    public CppReplacePsiModification(ITreeNode oldChild, ITreeNode newChild, CppCommentsReplaceMode commentsReplaceMode);
    public CppReplacePsiModification(ITreeNode oldChild, ITreeNode newChild);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppResolveScopeNodeStructure : object {
    [ExtensionAttribute]
public static ICppResolveEntity GetResolveEntity(IGenericSymbolNode decl);
    [ExtensionAttribute]
public static ICppResolveEntity TryGetResolveEntity(IGenericSymbolNode decl);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppStatementNavigator : BaseNavigator`1<ICppStatement> {
    public static ICppStatement GetPrevStatement(ICppStatement statement);
    public static ICppStatement GetNextStatement(ICppStatement statement);
    public static ICppStatement GetParentStatementByBody(ICppStatement statement);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.CppSubordinateReferenceBase`1 : CppReferenceBase`1<TOwnerElement> {
    public CppSubordinateReferenceBase`1(TOwnerElement owner);
    public abstract virtual bool IsSubordinateReference();
    public virtual void SetResolveResult(CppResolveResult& modreq(System.Runtime.InteropServices.InAttribute) rr);
    public virtual ResolveResultWithInfo Resolve();
    private static bool ResolveSubordinateReferenceBase(ResolveResultWithInfo& resolveResult, ICppCompositeNode element);
    public ResolveResultWithInfo ResolveBase();
    public virtual ResolveResultWithInfo ResolveWithoutCache();
    protected virtual CppResolveResult GetFallbackResolveResult();
    private static ICppSubordinateReference GetSubordinateReferenceForOverloadedFunc(ICppExpressionNode node);
    private static ICppCompositeNode GetSourceForOverloadedFunctions(ICppCompositeNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppTemplateParametersHelper : object {
    public static List`1<CppTemplateParametersBase> GetTemplateParameters(ICppResolveEntity ent, ICppFileResolveEntitiesCache rc);
    public static Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> GetTemplateParametersMapping(ICppResolveEntity ent, ICppFileResolveEntitiesCache rc);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppTreeElementRange : ValueType {
    public static CppTreeElementRange INVALID;
    [CompilerGeneratedAttribute]
private ITreeNode <First>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <Last>k__BackingField;
    public ITreeNode First { get; }
    public ITreeNode Last { get; }
    public bool IsEmpty { get; }
    public CppTreeElementRange(ITreeNode start, ITreeNode end);
    public CppTreeElementRange(ITreeNode start);
    private static CppTreeElementRange();
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_First();
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_Last();
    public T GetStart();
    public T GetEnd();
    public sealed virtual bool get_IsEmpty();
    public bool IsValid();
    public CppTreeElementRangeEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<ITreeNode> System.Collections.Generic.IEnumerable<JetBrains.ReSharper.Psi.Tree.ITreeNode>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    public CppTreeElementRange Join(CppTreeElementRange range);
    public CppTreeElementRange GetTreeElementRangeWithMacroCalls();
    public DocumentRange GetDocumentRange();
    public DocumentRange GetDocumentRangeWithMacroCalls();
    public DocumentRange GetDocumentRangeWithoutRemapping();
    public TreeTextRange GetTreeTextRange();
    public TreeTextRange GetTreeTextRangeWithMacroCalls();
    public TreeTextRange GetTreeTextRangeWithoutRemapping();
    public static CppTreeElementRange Create(ITreeNode start, ITreeNode end);
    public static CppTreeElementRange CreateFromElement(ITreeNode node);
    public CppTreeElementRange TryRemapOntoMacroArguments();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppTreeInitializersUtil : object {
    [ExtensionAttribute]
public static CppQualType CalculateUnresolvedType(ICppNonNestedDeclaratorNode declarator);
    [ExtensionAttribute]
public static CppQualType CalculateTypeWithTypeFactory(ICppNonNestedDeclaratorNode declarator, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType CalculateResolvedType(ICppNonNestedDeclaratorNode declarator);
    [ExtensionAttribute]
public static CppQualType CalculateVerboseResolvedType(ICppNonNestedDeclaratorNode declarator);
    [ExtensionAttribute]
public static CppQualType CalculateTypeWithoutAutoSubstitution(ICppNonNestedDeclaratorNode declarator, ICppResolvedTypeFactory tf, CppTypePlaceholders& placeholders);
    [ExtensionAttribute]
public static CppQualType CalculateTypeWithTypeFactory(TypeId typeId, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType CalculateResolvedType(TypeId typeId);
    [ExtensionAttribute]
public static CppQualType CalculateVerboseResolvedType(TypeId typeId);
    [ExtensionAttribute]
public static ICppResolvedExpression GetAutoInitializerWithTypeFactory(ICppNonAbstractDeclaratorNode declarator, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static ICppResolvedExpression GetAutoInitializer(TypeId typeId);
    [ExtensionAttribute]
public static CppQualType GetAutoOrDecltypeAutoSubstitution(ICppNonNestedDeclaratorNode declarator, ICppResolvedTypeFactory tf, CppTypePlaceholders expected);
    public static ICppResolvedExpression GetAutoInitializerWithTypeFactory(ICppNonNestedDeclaratorNode declarator, ICppResolvedTypeFactory tf);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
internal static ICppExpressionNode <GetAutoInitializer>g__GetSingleArgument|9_0(ICppExpressionsArgumentListNode argumentList);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppTreeModificationUtil : object {
    public static ITreeNode GetAnchorForNewImportDirective(CppFile file);
    public static ITreeNode GetAnchorAfterImportDirectives(CppFile file);
    public static ITreeNode SkipIncludeGuard(CppFile file, Boolean& includeGuardFound);
    public static ImportDirective FindImportDirective(CppFile file, string directivePath);
    public static bool CanRemoveDeclaration(ICppTopLevelDeclarationNode decl);
    public static void RemoveDeclaration(ICppTopLevelDeclarationNode decl);
    public static bool CanRemoveDeclaration(BaseDeclaration decl);
    public static void RemoveDeclaration(BaseDeclaration decl);
    public static bool CanRemoveDeclarator(ICppNonNestedDeclaratorNode declarator);
    public static void RemoveDeclarator(ICppNonNestedDeclaratorNode declarator);
    private static bool HasNamedClassSpecifier(BaseDeclaration baseDeclaration);
    public static bool CanRemoveClassSpecifier(IClassOrEnumSpecifier clazz);
    public static void RemoveClassSpecifier(IClassOrEnumSpecifier clazz);
    public static bool CanRemoveCommaListElement(ITreeNode element);
    public static void RemoveCommaListElement(ITreeNode element);
    public static bool CanRemoveListElement(ITreeNode element, NodeType separatorNodeType);
    public static void RemoveListElement(ITreeNode element, NodeType separatorNodeType);
    private static ITreeNode SkipStartingComments(CppFile file);
    private static bool IsIfNdefDirective(Directive dir);
    private static ITreeNode GetSeparatorForRemove(ITreeNode element, NodeType separator);
    public static bool CanAddVirtualSpecifier(Declaration declaration);
    public static void AddVirtualSpecifier(Declaration declaration);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppTreeTextRange : ValueType {
    public static CppTreeTextRange INVALID_RANGE;
    private CppComplexOffset myStartOffset;
    private CppComplexOffset myEndOffset;
    public CppComplexOffset Start { get; }
    public CppComplexOffset End { get; }
    public CppTreeTextRange(CppComplexOffset start, CppComplexOffset end);
    private static CppTreeTextRange();
    public CppComplexOffset get_Start();
    public CppComplexOffset get_End();
    public bool Contains(CppTreeTextRange other);
    public bool ContainedIn(CppTreeTextRange other);
    public CppTreeTextRange Join(CppTreeTextRange other);
    public sealed virtual bool Equals(CppTreeTextRange other);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppTypeSelection : object {
    [CompilerGeneratedAttribute]
private CppDeclarationSpecifiersSelection <DeclSpecsSelection>k__BackingField;
    [CompilerGeneratedAttribute]
private CppDeclaratorSelection <DeclaratorSelection>k__BackingField;
    public CppDeclarationSpecifiersSelection DeclSpecsSelection { get; }
    public CppDeclaratorSelection DeclaratorSelection { get; }
    public CppTypeSelection(CppDeclarationSpecifiersSelection declSpecs, CppDeclaratorSelection declaratorSelection);
    [CompilerGeneratedAttribute]
public CppDeclarationSpecifiersSelection get_DeclSpecsSelection();
    [CompilerGeneratedAttribute]
public CppDeclaratorSelection get_DeclaratorSelection();
    public CppQualType CalculateSelectedType(ICppResolvedTypeFactory tf);
    public bool CanBeReplacedBy(CppTypeSelection other);
    public CppTypeSelection ReplacedBy(CppTypeSelection other);
    public CppTypeSelection ReplacedBy(CppTypeSelection other, CppPsiModificationStrategy modStrat);
    private static CppTypeSelection SelectTypeForReplace(CppTypeSelection selection, CppTypeSelection replaceTarget);
    public SimpleDeclaration CreateNewTypeDeclarationForSelection(CppElementFactory ef);
    private CppTypeSelection ReplacedByImpl(CppTypeSelection other, CppPsiModificationStrategy modStrat);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppTypeSelectionExtensions : object {
    [ExtensionAttribute]
public static void FormatReplaced(CppTypeSelection selection);
    private static ICodeFormatter GetCodeFormatterOfNode(ITreeNode node);
    [ExtensionAttribute]
public static DocumentRange GetTypePrefixDocumentRange(CppTypeSelection selection);
    [ExtensionAttribute]
public static DocumentRange GetTypeSuffixDocumentRange(CppTypeSelection selection);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppTypeSelectionFactory : object {
    public static CppDeclarationSpecifiersSelection CreateTypeDeclSpecsSelection(DeclarationSpecifiersBase declSpecs);
    public static CppDeclarationSpecifiersSelection CreateTypeDeclSpecsSelectionWithoutCVQuals(DeclarationSpecifiersBase declSpecs);
    public static CppDeclarationSpecifiersSelection CreateNonTypeDeclSpecsSelection(DeclarationSpecifiersBase declSpecs);
    public static CppDeclaratorSelection CreateSelectionOfNestedDecl(NestedDeclarator decl);
    public static CppDeclaratorSelection CreateFullDeclaratorSelection(ICppDeclaratorNode node);
    public static CppDeclaratorSelection CreateEmptyDeclaratorSelection(ICppDeclaratorNode node);
    public static CppTypeSelection CreateEquivalentSelection(BaseDeclaration declaration, CppTypeSelection selection);
    private static CppDeclaratorSelection CreateEquivalentDeclaratorSelection(CppDeclaratorSelection selection, ICppNonNestedDeclaratorNode declarator);
    private static ITreeNode FindEquivalentDeclaratorNode(NestedDeclarator oldDeclarator, ITreeNode oldTarget, NestedDeclarator newDeclarator, bool prefix);
    public static CppTypeSelection CreateEquivalentSelection(EnumBase enumBase, CppTypeSelection selection);
    private static CppDeclarationSpecifiersSelection CreateEquivalentDeclarationSpecifiersSelection(CppDeclarationSpecifiersSelection selection, DeclarationSpecifiersBase declarationSpecifiers);
    public static CppTypeSelection CreateSelectionForDeclaratorAndSpecifiers(ICppNonNestedDeclaratorNode declarator);
    public static CppTypeSelection CreateFunctionReturnTypeSelection(ICppNonNestedDeclaratorNode declarator);
    private static ITreeNode GetPrefixEndNode(NestedDeclarator nestedDecl);
    public static CppTypeSelection CreateTrailingReturnTypeSelection(TrailingReturnType trailingReturnType);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppUE4GeneratedBody : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppUE4Metadata : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public UE4ReflectionMacroType GetMacroType();
    public IEnumerable`1<CppUE4MetadataSpecifier> GetSpecifiers();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppUE4MetadataNavigator : object {
    public static CppUE4Metadata GetBySpecifier(CppUE4MetadataSpecifier specifier);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppUE4MetadataSpecifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public CppUE4MetadataSpecifierKey GetKey();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppUE4MetadataSpecifierKey : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public string GetName();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppUE4MetadataSpecifierNavigator : object {
    public static CppUE4MetadataSpecifier GetBySpecifierKey(CppUE4MetadataSpecifierKey key);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppUE4MetadataSpecifierValue : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CppUnparsedTextNode : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CppViewPosHelper : object {
    [ExtensionAttribute]
public static CppViewPos GetViewPos(ITreeNode node);
    [ExtensionAttribute]
public static CppViewPos GetViewPos(ICppResolveScopeNode resolveScopeNode, CppComplexOffset complexOffset);
    [ExtensionAttribute]
public static CppViewPos GetViewPosForDeclarationSpecifiers(ICppDeclaratorResolveEntity entity);
    [ExtensionAttribute]
public static CppViewPos GetViewPosForDeclarator(ICppDeclaratorResolveEntity entity);
    [ExtensionAttribute]
public static CppViewPos GetViewPosForDeclaratorRequiresClause(ICppFunctionDeclaratorResolveEntity entity);
    [ExtensionAttribute]
public static CppViewPos GetViewPosForClassName(ICppScopeResolveEntity lexicalParent, ICppClassResolveEntity entity, CppLocationAnchor anchor);
    [ExtensionAttribute]
public static CppViewPos GetViewPosForDeclaratorName(ICppScopeResolveEntity lexicalParent, ICppDeclaratorResolveEntity entity, ICppSymbol symbol);
    [ExtensionAttribute]
public static CppViewPos GetViewPosForNameForConversionTypeId(ICppDeclaratorResolveEntity entity, ICppSymbol symbol);
    [ExtensionAttribute]
public static CppViewPos GetViewPosForConceptDefinition(ICppConceptDefinitionResolveEntity entity);
    internal static CppViewPos GetViewPos(RangeBasedForStatement rangeForNode, ITreeNode pp, ITreeNode originalNode);
    [ExtensionAttribute]
public static ICppScopeResolveEntity GetResolveScope(ITreeNode node);
    public static Nullable`1<CppViewPos> TryGetViewPos(DeclarationSpecifiers declSpecs, ITreeNode node);
    private static CppLocationAnchor GetLocationAnchor(ICppCompositeNode composite, ITreeNode node);
    private static CppViewPos GetViewPos(TNode outerNode, ICppResolveEntity outerResolveEntity, ITreeNode originalNode, ICppScopeResolveEntity resolveScope);
    private static CppViewPos GetViewPosForLoop(TLoopNode loopNode, TLoopResolveEntity loopResolveEntity, ITreeNode originalNode, ITreeNode pp);
    private static CppViewPos GetViewPosForTemplateDecl(TemplateDeclaration templateDecl, Declaration decl, ICppCompositeNode ctx, ITreeNode node);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.CtorBlock : CppCompositeNode {
    public NodeType NodeType { get; }
    [CanBeNullAttribute]
public CtorInitializer ConstructorInitializerNode { get; }
    [CanBeNullAttribute]
public CompoundStatement CompoundStatementNode { get; }
    public virtual NodeType get_NodeType();
    public CtorInitializer get_ConstructorInitializerNode();
    public CompoundStatement get_CompoundStatementNode();
    public abstract virtual ICppScopeResolveEntity GetResolveScope();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CtorBlockChameleon : CtorBlock {
    public virtual ICppScopeResolveEntity GetResolveScope();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CtorBlockNavigator : object {
    public static CtorBlock GetByCompoundStatement(CompoundStatement stmt);
    public static CtorBlock GetByCtorInitializer(CtorInitializer ctorInitializer);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CtorBlockNonChameleon : CtorBlock {
    [CompilerGeneratedAttribute]
private CppFileSymbolsCache <FileSymbolsCache>k__BackingField;
    public CppFileSymbolsCache FileSymbolsCache { get; }
    public CtorBlockNonChameleon(CppCodeFragmentSymbolsCache symbolCache);
    public virtual ICppScopeResolveEntity GetResolveScope();
    [CompilerGeneratedAttribute]
public sealed virtual CppFileSymbolsCache get_FileSymbolsCache();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CtorInitializer : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode ColonNode { get; }
    public CppList`1<MemInitializer> MemberInitializerNodes { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_ColonNode();
    public CppList`1<MemInitializer> get_MemberInitializerNodes();
    public bool CanAddMemInitializerAfter(MemInitializer anchor, MemInitializer memInit);
    public MemInitializer AddMemInitializerAfter(MemInitializer anchor, MemInitializer memInit);
    public bool CanAddMemInitializerBefore(MemInitializer anchor, MemInitializer memInit);
    public MemInitializer AddMemInitializerBefore(MemInitializer anchor, MemInitializer memInit);
    private static void EnsureCommaBeforeNextMemInit(MemInitializer memInit);
    private static ITreeNode GetAnchorForAddMemInitAfter(CtorInitializer that, MemInitializer anchor);
    private static ITreeNode GetAnchorForAddMemInitBefore(CtorInitializer that, MemInitializer anchor);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CtorInitializerNavigator : object {
    public static CtorInitializer GetByMemInitialier(MemInitializer memInit);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CudaArgumentList : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CxxCliDelegateDeclarator : NonNestedDeclaratorBase {
    private ICppDeclaratorSymbol mySymbol;
    public IDeclaredElement DeclaredElement { get; }
    public string DeclaredName { get; }
    public NodeType NodeType { get; }
    public CxxCliDelegateDeclarator(ICppDeclaratorSymbol symbol);
    public sealed virtual ICppSymbol GetGenericSymbol();
    public sealed virtual ICppDeclaratorSymbol GetSymbol();
    public ICppClassResolveEntity GetResolveEntity();
    public DeclaratorQualifiedName GetDeclaratorQualifiedName();
    public sealed virtual CppTreeElementRange GetNameTokenRange();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual bool IsSynthetic();
    public sealed virtual IDeclaredElement get_DeclaredElement();
    public sealed virtual string get_DeclaredName();
    public sealed virtual void SetName(string name);
    public sealed virtual TreeTextRange GetNameRange();
    public virtual NodeType get_NodeType();
    protected sealed virtual CppViewPos GetViewPosByResolveEntity(ICppDeclaratorResolveEntity ent);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CxxCliEventDeclaration : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CxxCliOverrideSpecifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public CppList`1<QualifiedCxxCliOverrideTargetReference> Targets { get; }
    public virtual NodeType get_NodeType();
    public CppList`1<QualifiedCxxCliOverrideTargetReference> get_Targets();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CxxCliPropertyDeclaration : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public Declaration DeclarationNode { get; }
    public CppList`1<SimpleDeclaration> MemberDeclarations { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_LBrace();
    public ITokenNode get_RBrace();
    public Declaration get_DeclarationNode();
    public CppList`1<SimpleDeclaration> get_MemberDeclarations();
    public sealed virtual ICppScopeResolveEntity GetResolveScope();
    public sealed virtual ICppScopeResolveEntity GetScopeForDeclarations();
    public sealed virtual CppDeclarationOwnerKind GetDeclarationOwnerKind();
    public sealed virtual IEnumerable`1<ICppCompositeNode> GetMembers();
    public sealed virtual ICppTopLevelDeclarationNode GetNextDeclaration(ICppTopLevelDeclarationNode decl);
    public sealed virtual ICppTopLevelDeclarationNode GetPrevDeclaration(ICppTopLevelDeclarationNode decl);
    public sealed virtual T AddDeclarationBefore(T decl, ITreeNode anchor, bool withComments);
    public sealed virtual bool CanAddDeclarationBefore(ITreeNode anchor);
    public sealed virtual T AddDeclarationAfter(T decl, ITreeNode anchor, bool withComments);
    public sealed virtual bool CanAddDeclarationAfter(ITreeNode anchor);
    public sealed virtual void RemoveDeclaration(T decl, CppCommentsDeleteMode commentsDeleteMode);
    public sealed virtual CppComplexOffset GetTopComplexOffset();
    public sealed virtual CppComplexOffset GetBottomComplexOffset();
    public sealed virtual ITreeNode GetBodyStartAnchor();
    public sealed virtual ITreeNode GetBodyEndAnchor();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CxxCliPropertyIndexes : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public CppList`1<TypeId> IndexTypes { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_LBracket();
    public ITokenNode get_RBracket();
    public CppList`1<TypeId> get_IndexTypes();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CxxCliPropertyIndexesNavigator : object {
    public static CxxCliPropertyIndexes GetByIndexType(TypeId type);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.CxxCliPropertyOrEventDeclarationNavigator : object {
    public static IEnumerable`1<SimpleDeclaration> GetAccessorDeclarations(ICxxCliPropertyOrEventDeclaration n);
    public static ICxxCliPropertyOrEventDeclaration GetByAccessorDeclaration(ICppTopLevelDeclarationNode n);
    public static ICxxCliPropertyOrEventDeclaration GetByDeclaration(Declaration declaration);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.CxxCliPropertyOrEventDeclarator : NonAbstractDeclaratorBase {
    public NodeType NodeType { get; }
    public CxxCliPropertyOrEventDeclarator(ICppDeclaratorSymbol symbol);
    public virtual NodeType get_NodeType();
    protected virtual CppViewPos GetViewPosByResolveEntity(ICppDeclaratorResolveEntity ent);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.Declaration : BaseDeclaration {
    private CppDeclarationSymbol mySymbol;
    public NodeType NodeType { get; }
    public AttributeList AttributeListNode { get; }
    public CppList`1<AttributeList> AttributeListNodes { get; }
    public Declaration(CppDeclarationSymbol declSymbol);
    public virtual NodeType get_NodeType();
    public AttributeList get_AttributeListNode();
    public CppList`1<AttributeList> get_AttributeListNodes();
    public sealed virtual CppDeclarationSymbol GetSymbol();
    public sealed virtual ICppSymbol GetGenericSymbol();
    public ICppNonNestedDeclaratorNode InsertDeclarator(ICppNonNestedDeclaratorNode declarator);
    public bool CanRemoveDeclarator(ICppNonNestedDeclaratorNode declarator);
    public void RemoveDeclarator(ICppNonNestedDeclaratorNode declarator);
    private static bool IsCommaNode(ITreeNode node);
    private static ITreeNode GetThisOrMeaningfulLeftSib(ITreeNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.DeclarationNavigator : object {
    public static Declaration GetByDeclarator(ICppNonNestedDeclaratorNode declarator);
    public static Declaration GetBySingleDeclarator(ICppNonNestedDeclaratorNode declarator);
    public static Declaration GetByLastDeclarator(ICppNonNestedDeclaratorNode declarator);
    public static Declaration GetByClassSpecifier(IClassOrEnumSpecifier specifiers);
    public static Declaration GetByDeclarationSpecifiers(DeclarationSpecifiers specifiers);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.DeclarationSpecifiers : DeclarationSpecifiersBase {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public BaseDeclaration GetDeclaration();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.DeclarationSpecifiersBase : CppCompositeNode {
    [CanBeNullAttribute]
public IClassOrEnumSpecifier ClassSpecifierNode { get; }
    [CanBeNullAttribute]
public DeclarationSpecifierTypename DeclarationSpecifierTypenameNode { get; }
    [CanBeNullAttribute]
public ElaboratedTypeSpecifier ElaboratedTypeSpecifierNode { get; }
    [CanBeNullAttribute]
public ConceptAutoSpecifier ConceptAutoSpecifierNode { get; }
    [CanBeNullAttribute]
public BuiltinTypeTrait BuiltinTypeTraitNode { get; }
    [CanBeNullAttribute]
public HlslVectorTypeSpecifier HlslVectorTypeSpecifierNode { get; }
    [CanBeNullAttribute]
public HlslMatrixTypeSpecifier HlslMatrixTypeSpecifierNode { get; }
    [CanBeNullAttribute]
public ITreeNode FirstDeclarationTypeNode { get; }
    public CppList`1<ITreeNode> DeclarationTypeNodes { get; }
    public CppList`1<ITreeNode> DeclarationTypeAndCvNodes { get; }
    public int DeclarationTypeNodesCount { get; }
    [CanBeNullAttribute]
public ITokenNode StaticSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode VirtualSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode FriendSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode MutableSpecifierNode { get; }
    [CanBeNullAttribute]
public ExplicitSpecifier ExplicitSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode InlineSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode ExternSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode ConstSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode VolatileSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode TypedefSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode AutoSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode GCCAutoTypeSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode ConstExprSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode ConstEvalSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode ConstInitSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode RegisterSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode EventSpecifierNode { get; }
    [CanBeNullAttribute]
public MSDeclSpec MsDeclSpec { get; }
    [CanBeNullAttribute]
public DecltypeAutoSpecifier DecltypeAutoSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode CliDelegateSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode CliPropertySpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode CliEventSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode CliLiteralSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode CliInitonlySpecifierNode { get; }
    public CppList`1<ITreeNode> DeclarationSpecifierNodes { get; }
    public IClassOrEnumSpecifier get_ClassSpecifierNode();
    public DeclarationSpecifierTypename get_DeclarationSpecifierTypenameNode();
    public ElaboratedTypeSpecifier get_ElaboratedTypeSpecifierNode();
    public ConceptAutoSpecifier get_ConceptAutoSpecifierNode();
    public BuiltinTypeTrait get_BuiltinTypeTraitNode();
    public HlslVectorTypeSpecifier get_HlslVectorTypeSpecifierNode();
    public HlslMatrixTypeSpecifier get_HlslMatrixTypeSpecifierNode();
    public ITreeNode get_FirstDeclarationTypeNode();
    public CppList`1<ITreeNode> get_DeclarationTypeNodes();
    public CppList`1<ITreeNode> get_DeclarationTypeAndCvNodes();
    public int get_DeclarationTypeNodesCount();
    public ITokenNode get_StaticSpecifierNode();
    public ITokenNode get_VirtualSpecifierNode();
    public ITokenNode get_FriendSpecifierNode();
    public ITokenNode get_MutableSpecifierNode();
    public ExplicitSpecifier get_ExplicitSpecifierNode();
    public ITokenNode get_InlineSpecifierNode();
    public ITokenNode get_ExternSpecifierNode();
    public ITokenNode get_ConstSpecifierNode();
    public ITokenNode get_VolatileSpecifierNode();
    public ITokenNode get_TypedefSpecifierNode();
    public ITokenNode get_AutoSpecifierNode();
    public ITokenNode get_GCCAutoTypeSpecifierNode();
    public ITokenNode get_ConstExprSpecifierNode();
    public ITokenNode get_ConstEvalSpecifierNode();
    public ITokenNode get_ConstInitSpecifierNode();
    public ITokenNode get_RegisterSpecifierNode();
    public ITokenNode get_EventSpecifierNode();
    public MSDeclSpec get_MsDeclSpec();
    public DecltypeAutoSpecifier get_DecltypeAutoSpecifierNode();
    public ITokenNode get_CliDelegateSpecifierNode();
    public ITokenNode get_CliPropertySpecifierNode();
    public ITokenNode get_CliEventSpecifierNode();
    public ITokenNode get_CliLiteralSpecifierNode();
    public ITokenNode get_CliInitonlySpecifierNode();
    public CppList`1<ITreeNode> get_DeclarationSpecifierNodes();
    public CppQualType CalculateBaseType();
    public CppQualType CalculateBaseType(CppTypeSelection selection);
    private void CalculateBaseTypeInner(ICppResolvedDeclarationSpecifierTypeBuilder builder, CppTypeSelection selection);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.DeclarationSpecifiersBaseNavigator : object {
    public static DeclarationSpecifiersBase GetByClassSpecifier(IClassOrEnumSpecifier node);
    public static DeclarationSpecifiersBase GetBySpecifier(ITreeNode node);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.DeclarationSpecifiersNavigator : object {
    public static DeclarationSpecifiers GetByClassSpecifier(IClassOrEnumSpecifier node);
    public static DeclarationSpecifiers GetByElaboratedTypeSpecifier(ElaboratedTypeSpecifier node);
    public static DeclarationSpecifiers GetByDeclarationSpecifierTypename(DeclarationSpecifierTypename node);
    public static DeclarationSpecifiers GetByAutoSpecifier(ITokenNode node);
    public static DeclarationSpecifiers GetByDecltypeAutoSpecifier(DecltypeAutoSpecifier node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.DeclarationSpecifierTypename : BaseQualifiedReference {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public CppClassTag GetClassTag();
    public virtual CppLookupResult LookupReferenceWithCustomName(CppQualifiedName name);
    public DeclarationSpecifiersBase GetDeclarationSpecifiers();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.DeclarationStatement : CppCompositeNode {
    public NodeType NodeType { get; }
    public ICppTopLevelDeclarationNode DeclarationNode { get; }
    public virtual NodeType get_NodeType();
    public ICppTopLevelDeclarationNode get_DeclarationNode();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.DeclarationStatementNavigator : object {
    public static DeclarationStatement GetByDeclaration(ICppTopLevelDeclarationNode simpleDecl);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.Declarator : NonAbstractDeclaratorBase {
    private IReference modreq(System.Runtime.CompilerServices.IsVolatile) myReference;
    public NodeType NodeType { get; }
    public PureSpecifier PureSpecifierNode { get; }
    public ITokenNode OverrideSpecifierNode { get; }
    public ITokenNode FinalSpecifierNode { get; }
    public ITokenNode SealedSpecifierNode { get; }
    public ITokenNode AbstractSpecifierNode { get; }
    public CxxCliOverrideSpecifier CxxCliOverrideSpecifierNode { get; }
    public Declarator(ICppDeclaratorSymbol symbol);
    public virtual NodeType get_NodeType();
    public PureSpecifier get_PureSpecifierNode();
    public ITokenNode get_OverrideSpecifierNode();
    public ITokenNode get_FinalSpecifierNode();
    public ITokenNode get_SealedSpecifierNode();
    public ITokenNode get_AbstractSpecifierNode();
    public CxxCliOverrideSpecifier get_CxxCliOverrideSpecifierNode();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual void DropReferences();
    protected sealed virtual CppViewPos GetViewPosByResolveEntity(ICppDeclaratorResolveEntity ent);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.DeclaratorNavigator : object {
    public static Declarator GetByOverrideSpecifier(ITokenNode specifier);
    public static Declarator GetByFinalSpecifier(ITokenNode specifier);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.DeclaratorQualifiedName : BaseQualifiedName {
    public NodeType NodeType { get; }
    public StructuredBindingIdentifierList StructuredBindingIdentifierListNode { get; }
    public virtual NodeType get_NodeType();
    public StructuredBindingIdentifierList get_StructuredBindingIdentifierListNode();
    public sealed virtual CppViewPos GetViewPosForName();
    public sealed virtual List`1<CppTemplateParametersBase> GetTemplateParameters();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.DeclaratorQualifiedNameNavigator : object {
    public static DeclaratorQualifiedName GetByQualifier(NameQualifier qual);
    public static DeclaratorQualifiedName GetByNamePart(ITreeNode namePart);
    public static DeclaratorQualifiedName GetByTemplateArgumentList(TemplateArgumentList list);
    public static DeclaratorQualifiedName GetByStructuredBindingIdentifierList(StructuredBindingIdentifierList list);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.DecltypeAutoSpecifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.DecltypeSpecifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode Keyword { get; }
    public ICppExpressionNode Expression { get; }
    public TypeId TypeIdNode { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_Keyword();
    public ICppExpressionNode get_Expression();
    public TypeId get_TypeIdNode();
    public CppDecltypeKind GetKind();
    public void BuildDecltypeName(CppQualifiedNameBuilder& builder);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.DecltypeSpecifierNavigator : object {
    [CanBeNullAttribute]
public static DecltypeSpecifier GetByExpression(ICppExpressionNode node);
    [CanBeNullAttribute]
public static DecltypeSpecifier GetByKeyword(ITokenNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.DefaultSpecifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.DefaultStatement : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode DefaultKeyword { get; }
    public ITokenNode Colon { get; }
    public ICppStatement Statement { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_DefaultKeyword();
    public ITokenNode get_Colon();
    public sealed virtual ICppStatement get_Statement();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.DefaultStatementNavigator : object {
    public static DefaultStatement GetByDefaultKeyword(ITokenNode child);
    public static DefaultStatement GetByStatement(ICppStatement stmt);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.DeleteExpression : CppExpressionNode {
    public NodeType NodeType { get; }
    public ICppExpressionNode Expression { get; }
    public DeleteExpressionKind Kind { get; }
    public virtual NodeType get_NodeType();
    public ICppExpressionNode get_Expression();
    public sealed virtual ICppExpression GetArgument();
    public virtual CppDependentInfo GetDependentInfo();
    public sealed virtual DeleteExpressionKind get_Kind();
    public virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public bool IsArrayKind();
    public virtual TResult Accept(ICppExpressionNodeVisitor`1<TResult> visitor);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.DeleteExpressionNavigator : object {
    public static DeleteExpression GetByExpression(ICppExpressionNode expr);
    public static DeleteExpression GetByExpressionThroughParens(ICppExpressionNode expr);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.DeleteSpecifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.Designation : CppExpressionNode {
    public NodeType NodeType { get; }
    public ICppDesignatorNode Designator { get; }
    public ICppExpressionNode Initializer { get; }
    public ITokenNode EqOperator { get; }
    public virtual NodeType get_NodeType();
    public ICppDesignatorNode get_Designator();
    public ICppExpressionNode get_Initializer();
    public ITokenNode get_EqOperator();
    public virtual CppDependentInfo GetDependentInfo();
    public virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public sealed virtual ICppDesignator GetDesignator();
    public sealed virtual ICppResolvedExpression GetResolvedInitializer();
    public sealed virtual ICppExpression GetInitializer();
    public sealed virtual InitializerKind GetInitializerKind();
    public CppUnknownEntityInfo GetInfo();
    public virtual CppTypeAndCategory GetTypeAndCategory();
    public virtual CppTypeAndCategory GetVerboseTypeAndCategory();
    public virtual TResult Accept(ICppExpressionNodeVisitor`1<TResult> visitor);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.DesignationNavigator : object {
    public static Designation GetByDesignator(ICppDesignatorNode node);
    public static Designation GetByInitializer(ICppExpressionNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.Directive : CppCompositeNode {
    public ITokenNode Head { get; }
    public bool IsIfDef { get; }
    public bool IsIfNdef { get; }
    public bool IsIf { get; }
    public bool IsElIf { get; }
    public bool IsElIfDef { get; }
    public bool IsElIfNdef { get; }
    public bool IsElse { get; }
    public bool IsEndIf { get; }
    public bool IsElseVariant { get; }
    public bool IsError { get; }
    public bool IsWarning { get; }
    public bool IsUnknown { get; }
    public NodeType NodeType { get; }
    public ITokenNode get_Head();
    public bool get_IsIfDef();
    public bool get_IsIfNdef();
    public bool get_IsIf();
    public bool get_IsElIf();
    public bool get_IsElIfDef();
    public bool get_IsElIfNdef();
    public bool get_IsElse();
    public bool get_IsEndIf();
    public bool get_IsElseVariant();
    public bool get_IsError();
    public bool get_IsWarning();
    public bool get_IsUnknown();
    public virtual NodeType get_NodeType();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.DirectiveNavigator : object {
    public static ICppDirective GetByTokenNode(ITokenNode tokenNode);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.DiscardStatement : CppCompositeNode {
    public ITokenNode DiscardKeyword { get; }
    public NodeType NodeType { get; }
    public ITokenNode get_DiscardKeyword();
    public virtual NodeType get_NodeType();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.DiscardStatementNavigator : object {
    public static DiscardStatement GetByDiscardKeyword(ITokenNode child);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.DoStatement : CppCompositeNode {
    public NodeType NodeType { get; }
    public DoStatementBody RealBodyNode { get; }
    public ICppExpressionOrDeclarationNode Condition { get; }
    public ICppStatement Body { get; }
    public ITokenNode WhileKeyword { get; }
    public virtual NodeType get_NodeType();
    public DoStatementBody get_RealBodyNode();
    public ICppExpressionOrDeclarationNode get_Condition();
    public ICppStatement get_Body();
    public ITokenNode get_WhileKeyword();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams params);
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.DoStatementBody : CppLoopStatementBase {
    private CppCompoundStatementResolveEntity myResolveEntity;
    public NodeType NodeType { get; }
    public ITokenNode DoKeyword { get; }
    public DoStatementBody(CppCompoundStatementResolveEntity resolveEntity);
    public virtual NodeType get_NodeType();
    public ITokenNode get_DoKeyword();
    public virtual ICppScopeResolveEntity GetResolveScope();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.DoStatementBodyNavigator : object {
    public static DoStatementBody GetByDoKeyword(ITokenNode child);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.DoStatementNavigator : object {
    public static DoStatement GetByCondition(ICppExpressionOrDeclarationNode condition);
    public static DoStatement GetByBody(ICppStatement body);
    public static DoStatement GetByRealBody(DoStatementBody realBodyNode);
    public static DoStatement GetByWhileKeyword(ITokenNode child);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.DoubleArgumentTypeTraitExpression : CppExpressionNodeWithCachedDepInfo {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public TypeId GetFirstTypeId();
    public TypeId GetSecondTypeId();
    public ITokenNode GetKeyword();
    public sealed virtual CppQualType GetFirstArgument();
    public sealed virtual CppQualType GetSecondArgument();
    public sealed virtual CppDoubleArgumentTypeTraitKind GetKind();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.DoubleArgumentTypeTraitExpressionNavigator : object {
    public static DoubleArgumentTypeTraitExpression GetByArgument(TypeId arg);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.DynamicExceptionSpecification : CppCompositeNode {
    public NodeType NodeType { get; }
    public CppList`1<TypeId> TypeIdNodes { get; }
    public ITokenNode EllipsisNode { get; }
    public virtual NodeType get_NodeType();
    public CppList`1<TypeId> get_TypeIdNodes();
    public ITokenNode get_EllipsisNode();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.DynamicExceptionSpecificationNavigator : object {
    public static DynamicExceptionSpecification GetByTypeId(TypeId typeId);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ElaboratedTypeSpecifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public DeclarationSpecifierTypename DeclarationSpecifierTypenameNode { get; }
    public virtual NodeType get_NodeType();
    public DeclarationSpecifierTypename get_DeclarationSpecifierTypenameNode();
    public sealed virtual CppList`1<ITokenNode> GetKeyTokens();
    public CppQualifiedName GetQualifiedName();
    public DeclarationSpecifiersBase GetDeclarationSpecifiers();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.ElaboratedTypeSpecifierNavigator : object {
    public static ElaboratedTypeSpecifier GetByDeclarationSpecifierTypename(DeclarationSpecifierTypename node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.EmptyDeclaration : CppCompositeNode {
    [CanBeNullAttribute]
public ITreeNode SemicolonNode { get; }
    public NodeType NodeType { get; }
    public ITreeNode get_SemicolonNode();
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.EmptyExpression : CppExpressionNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public sealed virtual CppUnknownEntityInfo GetInfo();
    public virtual CppDependentInfo GetDependentInfo();
    public virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public virtual CppTypeAndCategory GetTypeAndCategory();
    public virtual CppTypeAndCategory GetVerboseTypeAndCategory();
    public virtual TResult Accept(ICppExpressionNodeVisitor`1<TResult> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.EmptyStatement : CppCompositeNode {
    [CanBeNullAttribute]
public ITokenNode SemicolonNode { get; }
    public CppList`1<AttributeList> Attributes { get; }
    public NodeType NodeType { get; }
    public ITokenNode get_SemicolonNode();
    public CppList`1<AttributeList> get_Attributes();
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.EnumBase : DeclarationSpecifiersBase {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public EnumUnderlyingTypeClause GetBaseClause();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.EnumBaseNavigator : object {
    public static EnumBase GetByClassSpecifier(IClassOrEnumSpecifier node);
    public static EnumBase GetByElaboratedTypeSpecifier(ElaboratedTypeSpecifier node);
    public static EnumBase GetByDeclarationSpecifierTypename(DeclarationSpecifierTypename node);
    public static EnumBase GetByAutoSpecifier(ITokenNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.Enumerator : BaseNamedSymbolNode`1<CppEnumeratorSymbol> {
    [NotNullAttribute]
private CppEnumeratorResolveEntity myEnumerator;
    public NodeType NodeType { get; }
    public ITokenNode Name { get; }
    public ICppExpressionNode Initializer { get; }
    public Enumerator(CppEnumeratorSymbol symbol, CppEnumeratorResolveEntity enumerator);
    public virtual NodeType get_NodeType();
    public ITokenNode get_Name();
    public ICppExpressionNode get_Initializer();
    public virtual CppTreeElementRange GetNameTokenRange();
    public sealed virtual CppViewPos GetViewPos();
    [NotNullAttribute]
public CppEnumeratorResolveEntity GetResolveEntity();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.EnumeratorNavigator : object {
    public static Enumerator GetByInitializer(ICppExpressionNode initializer);
    public static Enumerator GetByInitializerThroughParens(ICppExpressionNode initializer);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.EnumSpecifier : ClassOrEnumSpecifierWithBodyBase`1<ICppClassSymbol> {
    public NodeType NodeType { get; }
    public CppList`1<Enumerator> Enumerators { get; }
    public EnumSpecifier(CppClassSymbolAndAnchor symbolAndAnchor);
    public virtual NodeType get_NodeType();
    public EnumUnderlyingTypeClause GetBaseClause();
    public CppList`1<Enumerator> get_Enumerators();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.EnumSpecifierNavigator : object {
    public static EnumSpecifier GetByChild(ITreeNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.EnumUnderlyingTypeClause : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode Colon { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_Colon();
    public sealed virtual CppViewPos GetViewPos();
    public EnumBase GetEnumBase();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.EnumUnderlyingTypeClauseNavigator : object {
    public static EnumUnderlyingTypeClause GetByEnumBase(EnumBase declSpecs);
    public static EnumUnderlyingTypeClause GetByBaseQualifiedReference(BaseQualifiedReference baseQualifiedReference);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ExplicitInstantiation : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode TemplateKeyword { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_TemplateKeyword();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.ExplicitInstantiationNavigator : object {
    public static ExplicitInstantiation GetBySimpleDeclaration(SimpleDeclaration simpleDeclaration);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ExplicitSpecifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public ICppExpressionNode ExplicitExpression { get; }
    public virtual NodeType get_NodeType();
    public ICppExpressionNode get_ExplicitExpression();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.ExplicitSpecifierNavigator : object {
    public static ExplicitSpecifier GetByExplicitExpression(ICppExpressionNode expr);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ExportDeclaration : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode ExportKeyword { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_ExportKeyword();
    public sealed virtual ITokenNode get_LBrace();
    public sealed virtual ITokenNode get_RBrace();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.ExportDeclarationNavigator : object {
    public static ExportDeclaration GetByDeclaration(ICppTopLevelDeclarationNode decl);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ExpressionStatement : CppCompositeNode {
    public NodeType NodeType { get; }
    public ICppExpressionNode Expression { get; }
    [CanBeNullAttribute]
public ITokenNode Semicolon { get; }
    public virtual NodeType get_NodeType();
    public ICppExpressionNode get_Expression();
    public ITokenNode get_Semicolon();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.ExpressionStatementNavigator : object {
    public static ExpressionStatement GetByExpression(ICppExpressionNode expression);
    public static ExpressionStatement GetByExpressionThroughParens(ICppExpressionNode expression);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.FoldExpression : CppExpressionNode {
    public NodeType NodeType { get; }
    public ICppExpressionNode LeftOperand { get; }
    public ICppExpressionNode RightOperand { get; }
    public ITokenNode Operator { get; }
    public ITokenNode Ellipsis { get; }
    public ITokenNode LParen { get; }
    public ITokenNode RParen { get; }
    public ICppResolvedExpression Pattern { get; }
    public CppSubstitutionContext ExpansionClosure { get; }
    public virtual NodeType get_NodeType();
    public ICppExpressionNode get_LeftOperand();
    public ICppExpressionNode get_RightOperand();
    public ITokenNode get_Operator();
    public ITokenNode get_Ellipsis();
    public ITokenNode get_LParen();
    public ITokenNode get_RParen();
    public sealed virtual ICppResolvedExpression get_Pattern();
    public sealed virtual CppSubstitutionContext get_ExpansionClosure();
    public sealed virtual ICppResolvedExpression GetPackArgument();
    public sealed virtual ICppResolvedExpression GetInitArgument();
    public sealed virtual bool IsLeftFold();
    public sealed virtual CppOperatorKind GetOperatorKind();
    public virtual CppDependentInfo GetDependentInfo();
    public virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public virtual TResult Accept(ICppExpressionNodeVisitor`1<TResult> visitor);
    private void FindOperands(ICppExpressionNode& leftOperand, ICppExpressionNode& rightOperand);
    private bool FindArguments(ICppResolvedExpression& packArgument, ICppResolvedExpression& initArgument);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.FoldExpressionNavigator : object {
    public static FoldExpression GetByOperand(ICppExpressionNode expr);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ForStatement : CppLoopStatementBase {
    private CppForStatementResolveEntity myResolveEntity;
    public NodeType NodeType { get; }
    public ITokenNode ForKeyword { get; }
    public ICppExpressionOrDeclarationOrAliasDeclarationNode InitStatement { get; }
    public ICppExpressionOrDeclarationNode Condition { get; }
    public ICppExpressionNode UpdateExpression { get; }
    public ForStatement(CppForStatementResolveEntity resolveEntity);
    public virtual NodeType get_NodeType();
    public sealed virtual ITokenNode get_ForKeyword();
    public ICppExpressionOrDeclarationOrAliasDeclarationNode get_InitStatement();
    public ICppExpressionOrDeclarationNode get_Condition();
    public ICppExpressionNode get_UpdateExpression();
    private static ITreeNode SkipSemicolons(ITreeNode node, int semicolonCount);
    public virtual ICppScopeResolveEntity GetResolveScope();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams params);
    public CppForStatementResolveEntity GetResolveEntity();
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.ForStatementNavigator : object {
    public static ForStatement GetByForKeyword(ITokenNode child);
    public static ForStatement GetByCondition(ICppExpressionOrDeclarationNode condition);
    public static ForStatement GetByInitStatement(ICppExpressionOrDeclarationNode statement);
    public static ForStatement GetByUpdateExpression(ICppExpressionNode statement);
    public static ForStatement GetByBody(ICppStatement body);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.FunctionArgumentList : CppCompositeNode {
    public ITokenNode LParen { get; }
    public ITokenNode RParen { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public NodeType NodeType { get; }
    public CppList`1<ICppExpressionNode> Arguments { get; }
    public CppList`1<ITokenNode> Commas { get; }
    public ITokenNode get_LParen();
    public ITokenNode get_RParen();
    public sealed virtual ITokenNode get_LBracket();
    public sealed virtual ITokenNode get_RBracket();
    public virtual NodeType get_NodeType();
    public sealed virtual ICppExpression[] GetArguments();
    public sealed virtual CppArgumentListKind GetArgListKind();
    public sealed virtual int GetArgumentsCount();
    public sealed virtual CppList`1<ICppExpressionNode> get_Arguments();
    public sealed virtual CppList`1<ITokenNode> get_Commas();
    public sealed virtual ICppExpressionNode GetFirstArgument();
    public sealed virtual ICppExpressionNode GetLastArgument();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.FunctionArgumentListNavigator : object {
    public static FunctionArgumentList GetByArgument(ICppExpressionNode expr);
    public static FunctionArgumentList GetByArgumentThoughParens(ICppExpressionNode expr);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.FunctionBody : CompoundStatement {
    [CompilerGeneratedAttribute]
private CppFileSymbolsCache <FileSymbolsCache>k__BackingField;
    public NodeType NodeType { get; }
    public CppFileSymbolsCache FileSymbolsCache { get; }
    public FunctionBody(CppCodeFragmentSymbolsCache symbolCache);
    public virtual NodeType get_NodeType();
    [CompilerGeneratedAttribute]
public sealed virtual CppFileSymbolsCache get_FileSymbolsCache();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.FunctionParameters : CppCompositeNode {
    private CppParameterListResolveEntity myResolveEntity;
    public ITokenNode LParen { get; }
    public ITokenNode RParen { get; }
    public ITokenNode EllipsisNode { get; }
    public ITokenNode CliEllipsisNode { get; }
    public CppList`1<Declaration> ParameterDeclarations { get; }
    public TrailingReturnType TrailingReturnTypeNode { get; }
    public DynamicExceptionSpecification DynamicExceptionSpecificationNode { get; }
    public NoExceptSpecification NoExceptSpecificationNode { get; }
    public CppList`1<AmpRestrictionSpecifier> AmpRestrictionSpecifierNodes { get; }
    public CppRestrictionSpecifiers RestrictionSpecifiers { get; }
    public FunctionParameters(CppParameterListResolveEntity resolveEntity);
    public CppParameterListResolveEntity GetResolveEntity();
    public virtual ICppScopeResolveEntity GetResolveScope();
    public virtual CppParameterListResolveEntity GetParameterListResolveEntity();
    public CppEllipsisKind GetEllipsisKind();
    public bool HasParameters();
    public ITokenNode get_LParen();
    public ITokenNode get_RParen();
    public ITokenNode get_EllipsisNode();
    public ITokenNode get_CliEllipsisNode();
    public CppList`1<Declaration> get_ParameterDeclarations();
    [CanBeNullAttribute]
public Declaration GetFirstParameter();
    [CanBeNullAttribute]
public Declaration GetLastParameter();
    public TrailingReturnType get_TrailingReturnTypeNode();
    public DynamicExceptionSpecification get_DynamicExceptionSpecificationNode();
    public NoExceptSpecification get_NoExceptSpecificationNode();
    public CppList`1<AmpRestrictionSpecifier> get_AmpRestrictionSpecifierNodes();
    public CppRestrictionSpecifiers get_RestrictionSpecifiers();
    public Declaration AddParameterAfter(Declaration param, ITreeNode anchor);
    public bool CanAddParameterAfter(ITreeNode anchor);
    public void AddEllipsis(CppEllipsisKind kind);
    public void AddTrailingReturnType(TrailingReturnType trailingReturnType);
    public ITreeNode AddExceptionSpecification(ITreeNode spec);
    public void AddRestrictionSpecifier(AmpRestrictionSpecifier spec);
    public ITreeNode GetRestrictionSpecifierAnchor();
    public ITreeNode GetExceptionSpecificationAnchor();
    protected virtual ITreeNode GetLastNodeBeforeRestrictionSpecifiers();
    private static bool CanPreceedCliArrayEllipsis(NodeType type);
    private static ITreeNode EnsureCommaAfter(ITreeNode node);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.FunctionParametersNavigator`1 : object {
    public static int GetIndexByDeclaration(Declaration declaration);
    public static TParamsAndQuals GetByDeclaration(Declaration declaration);
    public static TParamsAndQuals GetByTrailingReturnType(TrailingReturnType returnType);
    public static TParamsAndQuals GetByDynamicExceptionSpecification(DynamicExceptionSpecification spec);
    public static TParamsAndQuals GetByNoExceptSpecification(NoExceptSpecification spec);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.FunctionTryBlock : CppCompositeNode {
    private CppScopeStatementResolveEntity myResolveEntity;
    public NodeType NodeType { get; }
    public ITokenNode TryKeywordNode { get; }
    public CtorInitializer ConstructorInitializerNode { get; }
    public CompoundStatement CompoundStatementNode { get; }
    public CppList`1<CatchSection> CatchSections { get; }
    public FunctionTryBlock(CppScopeStatementResolveEntity resolveEntity);
    public virtual NodeType get_NodeType();
    public ITokenNode get_TryKeywordNode();
    public CtorInitializer get_ConstructorInitializerNode();
    public CompoundStatement get_CompoundStatementNode();
    public CppList`1<CatchSection> get_CatchSections();
    public virtual ICppScopeResolveEntity GetResolveScope();
    public bool CanAddCtorInitializer(CtorInitializer init);
    public CtorInitializer AddCtorInitializer(CtorInitializer init);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.FunctionTryBlockNavigator : object {
    public static FunctionTryBlock GetByCtorInitializer(CtorInitializer init);
    public static FunctionTryBlock GetByTryStatement(ICppStatement statement);
    public static FunctionTryBlock GetByCatchSection(CatchSection catchSection);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.FwdClassOrEnumSpecifierBase`1 : ClassOrEnumSpecifierBase`1<TSymbol> {
    private IReference myReference;
    public IDeclaredElement DeclaredElement { get; }
    public FwdClassOrEnumSpecifierBase`1(CppClassSymbolAndAnchor symbolAndAnchor);
    public virtual IDeclaredElement get_DeclaredElement();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual CppViewPos GetViewPos();
    private bool ShouldBeTreatedAsDeclaration();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.FwdClassSpecifier : FwdClassOrEnumSpecifierBase`1<CppFwdClassSymbol> {
    public NodeType NodeType { get; }
    public FwdClassSpecifier(CppClassSymbolAndAnchor symbolAndAnchor);
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.FwdEnumSpecifier : FwdClassOrEnumSpecifierBase`1<ICppClassSymbol> {
    public NodeType NodeType { get; }
    public FwdEnumSpecifier(CppClassSymbolAndAnchor symbolAndAnchor);
    public virtual NodeType get_NodeType();
    public EnumUnderlyingTypeClause GetBaseClause();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.GenericConstraint : CppCompositeNode {
    public NodeType NodeType { get; }
    public CppList`1<ICppGenericConstraintItem> GenericConstraintItems { get; }
    public virtual NodeType get_NodeType();
    public CppList`1<ICppGenericConstraintItem> get_GenericConstraintItems();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.GenericConstraintNavigator : object {
    public static GenericConstraint GetByGenericConstraintItem(ICppGenericConstraintItem item);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.GnuAsmClobbersList : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.GnuAsmDefinition : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.GnuAsmGotoLabelsList : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.GnuAsmOperandList : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.GnuBuiltinChooseExprExpression : CppExpressionNodeWithCachedDepInfo {
    private FunctionArgumentList ArgList { get; }
    public ICppExpressionNode Condition { get; }
    public ICppExpressionNode SecondArg { get; }
    public ICppExpressionNode ThirdArg { get; }
    public NodeType NodeType { get; }
    private FunctionArgumentList get_ArgList();
    public ICppExpressionNode get_Condition();
    public ICppExpressionNode get_SecondArg();
    public ICppExpressionNode get_ThirdArg();
    public virtual NodeType get_NodeType();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
    public sealed virtual ICppExpression GetFirstArgument();
    public sealed virtual ICppExpression GetSecondArgument();
    public sealed virtual ICppExpression GetThirdArgument();
    public sealed virtual CppConditionalExprKind GetKind();
    public sealed virtual CppViewPos GetViewPosForOverloading();
    public sealed virtual ICppResolvedExpression GetResolvedFirstArgument();
    public sealed virtual ICppResolvedExpression GetResolvedSecondArgument();
    public sealed virtual ICppResolvedExpression GetResolvedThirdArgument();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.GnuBuiltinConstantPExpression : CppExpressionNode {
    public NodeType NodeType { get; }
    public ICppExpressionNode Argument { get; }
    public virtual NodeType get_NodeType();
    public ICppExpressionNode get_Argument();
    public sealed virtual ICppExpression GetArgument();
    public sealed virtual ICppResolvedExpression GetResolvedArgument();
    public virtual CppDependentInfo GetDependentInfo();
    public virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public virtual TResult Accept(ICppExpressionNodeVisitor`1<TResult> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.GnuCaseRange : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.GnuComputedGotoStatement : CppCompositeNode {
    public ITokenNode GotoKeyword { get; }
    public ICppExpressionNode TargetExpr { get; }
    public NodeType NodeType { get; }
    public ITokenNode get_GotoKeyword();
    public ICppExpressionNode get_TargetExpr();
    public virtual NodeType get_NodeType();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.GnuComputedGotoStatementNavigator : object {
    public static GnuComputedGotoStatement GetByGotoKeyword(ITokenNode child);
    public static GnuComputedGotoStatement GetByTargetExpr(ICppExpressionNode child);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.GnuStyleAttributeList : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.GotoStatement : CppCompositeNode {
    public ITokenNode GotoKeyword { get; }
    public ITokenNode TargetIdent { get; }
    public NodeType NodeType { get; }
    public ITokenNode get_GotoKeyword();
    public ITokenNode get_TargetIdent();
    public virtual NodeType get_NodeType();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.GotoStatementNavigator : object {
    public static GotoStatement GetByGotoKeyword(ITokenNode child);
    public static GotoStatement GetByTargetIdent(ITokenNode child);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.HlslAttributes : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.HlslBufferTypeSpecifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.HlslMatrixTypeSpecifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public ITreeNode GetKeyword();
    public TypeId GetScalarTypeId();
    public ICppExpressionNode GetFirstDimention();
    public ICppExpressionNode GetSecondDimention();
    public CppQualType GetQualType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.HlslShaderConstantsBuffer : BaseSymbolNode`1<CppHLSLBufferSymbol> {
    public ITreeNode BufferKeyword { get; }
    public ITreeNode NameNode { get; }
    public ITokenNode LBrace { get; }
    public NodeType NodeType { get; }
    public HlslShaderConstantsBuffer(CppHLSLBufferSymbol sym);
    public ITreeNode get_BufferKeyword();
    public ITreeNode get_NameNode();
    public ITokenNode get_LBrace();
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.HlslTrailingPackOffset : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.HlslTrailingRegister : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.HlslTrailingSemantic : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.HlslVectorTypeSpecifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public ITreeNode GetKeyword();
    public TypeId GetScalarTypeId();
    public ICppExpressionNode GetFirstDimention();
    public CppQualType GetQualType();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.IClassOrEnumSpecifier {
    [CanBeNullAttribute]
public abstract virtual ClassQualifiedName GetClassQualifiedName();
    public abstract virtual ICppClassResolveEntity GetClassResolveEntity();
    public abstract virtual ICppClassSymbol GetClassSymbol();
    public abstract virtual CppLocationAnchor GetClassSymbolAnchor();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.IClassOrEnumWithBodySpecifier {
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual ITokenNode get_RBrace();
    public abstract virtual CppList`1<ICppTopLevelDeclarationNode> GetTopLevelDeclarations();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppAnySubscriptExpressionNode {
    public ICppExpressionNode LeftSideExpr { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public abstract virtual ICppExpressionNode get_LeftSideExpr();
    public abstract virtual ITokenNode get_LBracket();
    public abstract virtual ITokenNode get_RBracket();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppCaseOrDefaultStatement {
    public ICppStatement Statement { get; }
    public abstract virtual ICppStatement get_Statement();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppChameleonNode {
    public CppChameleonData& ChameleonData { get; }
    public abstract virtual IEnumerable`1<CppNonSortedRangeIndex> GetPPUsages();
    [CanBeNullAttribute]
public abstract virtual StringBuilder TryGetWordsFromClosedChameleon();
    public abstract virtual void GetWordsFromClosedChameleon(IntSet words);
    public abstract virtual void CloseChameleon();
    public abstract virtual CppChameleonData& get_ChameleonData();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppClassTaggedNode {
    public abstract virtual CppList`1<ITokenNode> GetKeyTokens();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppCoAwaitNode {
    public abstract virtual CppResolveResult ResolveAwaitTransform();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppCoAwaitOrCoYieldNode {
    public abstract virtual ITokenNode GetCoKeyword();
    public abstract virtual CppResolveResult ResolveOperatorCoAwait();
    public abstract virtual CppResolveResult ResolveAwaitReady();
    public abstract virtual CppResolveResult ResolveAwaitResume();
    public abstract virtual CppResolveResult ResolveAwaitSuspend();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppCompositeNode {
    public abstract virtual CppComplexOffset GetComplexOffset();
    public abstract virtual CppFile GetContainingFile();
    public abstract virtual CppFileSymbolsCache GetFileCache();
    public abstract virtual void DropReferences();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppConstructorDeclaration {
    public CtorInitializer ConstructorInitializerNode { get; }
    public abstract virtual CtorInitializer get_ConstructorInitializerNode();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppConversionProvidingNode {
    public abstract virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams _);
    public abstract virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppConversionProvidingNodeVisitor`1 {
    public abstract virtual TResult Visit(BinaryExpression node);
    public abstract virtual TResult Visit(BracedInitList node);
    public abstract virtual TResult Visit(BraceInitializedTemporary node);
    public abstract virtual TResult Visit(CallExpression node);
    public abstract virtual TResult Visit(CastExpression node);
    public abstract virtual TResult Visit(CliMultiArgumentSubscriptExpression node);
    public abstract virtual TResult Visit(ConditionalExpression node);
    public abstract virtual TResult Visit(DoStatement node);
    public abstract virtual TResult Visit(ForStatement node);
    public abstract virtual TResult Visit(IfStatement node);
    public abstract virtual TResult Visit(InitDeclarator node);
    public abstract virtual TResult Visit(LambdaCapture node);
    public abstract virtual TResult Visit(MemInitializer node);
    public abstract virtual TResult Visit(NewExpression node);
    public abstract virtual TResult Visit(PostfixExpression node);
    public abstract virtual TResult Visit(RangeBasedForStatement node);
    public abstract virtual TResult Visit(ReturnStatement node);
    public abstract virtual TResult Visit(SubscriptExpression node);
    public abstract virtual TResult Visit(UnaryExpression node);
    public abstract virtual TResult Visit(WhileStatement node);
    public abstract virtual TResult Visit(TemplateArgumentList node);
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppConversionVisitor {
    public abstract virtual bool Visit(CppOverloadingRunInfo info);
    public abstract virtual bool Visit(CppImplicitConversionSequence conv);
    public abstract virtual bool Visit(CppCastConversion castConv);
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppCoYieldNode {
    public abstract virtual CppResolveResult ResolveYieldValue();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppDeclarationOwner {
    public abstract virtual ICppScopeResolveEntity GetScopeForDeclarations();
    public abstract virtual CppDeclarationOwnerKind GetDeclarationOwnerKind();
    public abstract virtual IEnumerable`1<ICppCompositeNode> GetMembers();
    public abstract virtual ICppTopLevelDeclarationNode GetNextDeclaration(ICppTopLevelDeclarationNode decl);
    public abstract virtual ICppTopLevelDeclarationNode GetPrevDeclaration(ICppTopLevelDeclarationNode decl);
    public abstract virtual T AddDeclarationBefore(T decl, ITreeNode anchor, bool withComments);
    public abstract virtual bool CanAddDeclarationBefore(ITreeNode anchor);
    public abstract virtual T AddDeclarationAfter(T decl, ITreeNode anchor, bool withComments);
    public abstract virtual bool CanAddDeclarationAfter(ITreeNode anchor);
    public abstract virtual void RemoveDeclaration(T decl, CppCommentsDeleteMode commentsDeleteMode);
    public abstract virtual CppComplexOffset GetTopComplexOffset();
    public abstract virtual CppComplexOffset GetBottomComplexOffset();
    public abstract virtual ITreeNode GetBodyStartAnchor();
    public abstract virtual ITreeNode GetBodyEndAnchor();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppDeclarationTrailingNode {
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppDeclaratorNode {
    public NestedDeclarator NestedDeclaratorNode { get; }
    public abstract virtual NestedDeclarator get_NestedDeclaratorNode();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppDesignatorNode {
    public ICppDesignatorNode Qualifier { get; }
    public abstract virtual ICppDesignatorNode get_Qualifier();
    public abstract virtual CppQualType GetInferredScopeType();
    public abstract virtual void SetInferredScopeType(CppQualType type);
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppDirective {
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppExpressionNode {
    public abstract virtual CppTypeAndCategory GetTypeAndCategory();
    public abstract virtual CppTypeAndCategory GetVerboseTypeAndCategory();
    public abstract virtual CppQualType GetVerboseType();
    public abstract virtual void MarkChildrenAsResolved();
    public abstract virtual bool ChildrenAreResolved();
    public abstract virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppExpressionNodeVisitor`1 {
    public abstract virtual Result Visit(AlignOfExpression node);
    public abstract virtual Result Visit(BinaryExpression node);
    public abstract virtual Result Visit(BracedInitList node);
    public abstract virtual Result Visit(BraceInitializedTemporary node);
    public abstract virtual Result Visit(C11GenericExpression node);
    public abstract virtual Result Visit(CallExpression node);
    public abstract virtual Result Visit(CastExpression node);
    public abstract virtual Result Visit(CliMultiArgumentSubscriptExpression node);
    public abstract virtual Result Visit(CliTypeIdExpression node);
    public abstract virtual Result Visit(CoAwaitExpression node);
    public abstract virtual Result Visit(CoYieldExpression node);
    public abstract virtual Result Visit(CompoundStatementExpression node);
    public abstract virtual Result Visit(ConditionalExpression node);
    public abstract virtual Result Visit(DeleteExpression node);
    public abstract virtual Result Visit(Designation node);
    public abstract virtual Result Visit(EmptyExpression node);
    public abstract virtual Result Visit(FoldExpression node);
    public abstract virtual Result Visit(GnuBuiltinConstantPExpression node);
    public abstract virtual Result Visit(GnuAddressOfLabelExpression node);
    public abstract virtual Result Visit(LambdaExpression node);
    public abstract virtual Result Visit(LiteralExpression node);
    public abstract virtual Result Visit(MemberAccessExpression node);
    public abstract virtual Result Visit(MSAssumeExpression node);
    public abstract virtual Result Visit(BuiltinAddressOfExpression node);
    public abstract virtual Result Visit(BuiltinOffsetOfExpression node);
    public abstract virtual Result Visit(DoubleArgumentTypeTraitExpression node);
    public abstract virtual Result Visit(MSEventHookExpression node);
    public abstract virtual Result Visit(MultiArgumentTypeTraitExpression node);
    public abstract virtual Result Visit(MSNoopExpression node);
    public abstract virtual Result Visit(SingleArgumentTypeTraitExpression node);
    public abstract virtual Result Visit(MSUuidOfExpression node);
    public abstract virtual Result Visit(NewExpression node);
    public abstract virtual Result Visit(NoExceptExpression node);
    public abstract virtual Result Visit(PackExpansionExpression node);
    public abstract virtual Result Visit(ParenExpression node);
    public abstract virtual Result Visit(PostfixExpression node);
    public abstract virtual Result Visit(QualifiedReference node);
    public abstract virtual Result Visit(RequiresExpression node);
    public abstract virtual Result Visit(SizeOfEllipsisExpression node);
    public abstract virtual Result Visit(SizeOfExpression node);
    public abstract virtual Result Visit(SubscriptExpression node);
    public abstract virtual Result Visit(ThisExpression node);
    public abstract virtual Result Visit(ThrowExpression node);
    public abstract virtual Result Visit(TypeIdExpression node);
    public abstract virtual Result Visit(UnaryExpression node);
    public abstract virtual Result Visit(UserDefinedLiteralExpression node);
    public abstract virtual Result Visit(GnuBuiltinChooseExprExpression node);
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppExpressionOrDeclarationNode {
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppExpressionOrDeclarationOrAliasDeclarationNode {
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppExpressionsArgumentListNode {
    public CppList`1<ITokenNode> Commas { get; }
    public CppList`1<ICppExpressionNode> Arguments { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public abstract virtual CppList`1<ITokenNode> get_Commas();
    public abstract virtual CppList`1<ICppExpressionNode> get_Arguments();
    public abstract virtual ITokenNode get_LBracket();
    public abstract virtual ITokenNode get_RBracket();
    public abstract virtual int GetArgumentsCount();
    [CanBeNullAttribute]
public abstract virtual ICppExpressionNode GetFirstArgument();
    [CanBeNullAttribute]
public abstract virtual ICppExpressionNode GetLastArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppFileReference {
    public bool IsFolderReference { get; }
    public ICppFileReference ParentReference { get; }
    public abstract virtual bool get_IsFolderReference();
    public abstract virtual ICppFileReference get_ParentReference();
    public abstract virtual IEnumerable`1<VirtualFileSystemPath> GetSearchPaths();
    public abstract virtual string GetFullPath();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppFileSymbolCacheNode {
    public CppFileSymbolsCache FileSymbolsCache { get; }
    public abstract virtual CppFileSymbolsCache get_FileSymbolsCache();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppForStatement {
    public ITokenNode ForKeyword { get; }
    public abstract virtual ITokenNode get_ForKeyword();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppGenericConstraintItem {
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppImportDirective {
    public string UnquotedImportPath { get; }
    public ITokenNode QuotedImportPath { get; }
    public bool IsAngleBracket { get; }
    public bool IsIncludeNext { get; }
    public abstract virtual string get_UnquotedImportPath();
    public abstract virtual ITokenNode get_QuotedImportPath();
    public abstract virtual bool get_IsAngleBracket();
    public abstract virtual bool get_IsIncludeNext();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppLoopStatement {
    public ICppStatement Body { get; }
    public abstract virtual ICppStatement get_Body();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppNamedNode {
    public abstract virtual CppTreeElementRange GetNameTokenRange();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppNestedDeclarationNode {
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppNodeWithInvariant {
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppNonAbstractDeclaratorNode {
    public RequiresClause RequiresClauseNode { get; }
    public abstract virtual ICppDeclaratorResolveEntity GetResolveEntity();
    public abstract virtual DeclaratorQualifiedName GetDeclaratorQualifiedName();
    public abstract virtual RequiresClause get_RequiresClauseNode();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppNonNestedDeclaratorNode {
    public abstract virtual CppQualType CalculateUnresolvedType(CppTypeSelection selection);
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppReference {
    public abstract virtual CppTreeElementRange GetTokenRange();
    public abstract virtual ICppCompositeNode GetCppTreeNode();
    public abstract virtual void DropCache();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppReferenceNode {
    public abstract virtual CppQualifiedName GetQualifiedName();
    public abstract virtual CppLookupResult LookupReferenceWithCustomName(CppQualifiedName name);
    public abstract virtual CppResolveResult ResolveReferenceWithCustomName(CppQualifiedName name);
    public abstract virtual string GetNameOfReference();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppResolveScopeNode {
    public abstract virtual ICppScopeResolveEntity GetResolveScope();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppStatement {
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppSubordinateReference {
    public abstract virtual bool IsSubordinateReference();
    public abstract virtual void SetResolveResult(CppResolveResult& modreq(System.Runtime.InteropServices.InAttribute) rr);
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppTemplateParameterNode {
    public abstract virtual ICppTemplateParameter GetResolveEntity();
    public abstract virtual ITreeNode GetNameNode();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppTopLevelDeclarationNode {
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppTypeIdOrExpressionNode {
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppTypeIdOrQualifiedReference {
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICppViewPosNode {
    public abstract virtual CppViewPos GetViewPos();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ICxxCliPropertyOrEventDeclaration {
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.IDeclarationName {
    public abstract virtual CppViewPos GetViewPosForName();
    public abstract virtual List`1<CppTemplateParametersBase> GetTemplateParameters();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.IfStatement : CppCompositeNode {
    private CppIfStatementResolveEntity myResolveEntity;
    public NodeType NodeType { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ICppExpressionOrDeclarationOrAliasDeclarationNode InitStatement { get; }
    public ICppExpressionOrDeclarationNode Condition { get; }
    public ICppStatement ThenStatement { get; }
    public ICppStatement ElseStatement { get; }
    public ITokenNode ElseKeyword { get; }
    public ITokenNode IfKeyword { get; }
    public ITokenNode ConstexprKeyword { get; }
    public ITokenNode ConstevalKeyword { get; }
    public ITokenNode ConstevalExcl { get; }
    public IfStatement(CppIfStatementResolveEntity resolveEntity);
    public virtual NodeType get_NodeType();
    public ITokenNode get_LPar();
    public ITokenNode get_RPar();
    public ICppExpressionOrDeclarationOrAliasDeclarationNode get_InitStatement();
    public ICppExpressionOrDeclarationNode get_Condition();
    public ICppStatement get_ThenStatement();
    public ICppStatement get_ElseStatement();
    public ITokenNode get_ElseKeyword();
    public ITokenNode get_IfKeyword();
    public ITokenNode get_ConstexprKeyword();
    public ITokenNode get_ConstevalKeyword();
    public ITokenNode get_ConstevalExcl();
    public sealed virtual ICppScopeResolveEntity GetResolveScope();
    public CppIfStatementResolveEntity GetIfStatementResolveEntity();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams params);
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
    private void ParseHeader(ICppExpressionOrDeclarationOrAliasDeclarationNode& init, ICppExpressionOrDeclarationNode& cond);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.IfStatementNavigator : BaseNavigator`1<IfStatement> {
    public static IfStatement GetByInitStatement(ICppExpressionOrDeclarationNode init);
    public static IfStatement GetByCondition(ICppExpressionOrDeclarationNode condition);
    public static IfStatement GetByThenStatement(ICppStatement statement);
    public static IfStatement GetByElseStatement(ICppStatement statement);
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.IFunctionTemplateParamReference {
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.IGenericSymbolNode {
    public abstract virtual ICppSymbol GetGenericSymbol();
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ILinkageSpecificationOrExportDeclaration {
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual ITokenNode get_RBrace();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ImportDirective : BaseSymbolNode`1<CppPPIncludeSymbol> {
    private IReadOnlyList`1<IReference> myReferences;
    public NodeType NodeType { get; }
    public string UnquotedImportPath { get; }
    public ITokenNode QuotedImportPath { get; }
    public bool IsAngleBracket { get; }
    public bool IsPchInclude { get; }
    public bool IsIncludeNext { get; }
    public bool IsOpened { get; }
    public ImportDirective(ICppSymbol symbol);
    protected virtual void PreInit();
    public virtual NodeType get_NodeType();
    public sealed virtual string get_UnquotedImportPath();
    public sealed virtual ITokenNode get_QuotedImportPath();
    public sealed virtual bool get_IsAngleBracket();
    public bool get_IsPchInclude();
    public sealed virtual bool get_IsIncludeNext();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual IChameleonNode ReSync(CachingLexer lexer, TreeTextRange changedRange, int insertedTextLen);
    public sealed virtual bool get_IsOpened();
    public virtual IChameleonNode FindChameleonWhichCoversRange(TreeTextRange textRange);
    private IReadOnlyList`1<IReference> CalculateReferences();
}
internal static class JetBrains.ReSharper.Psi.Cpp.Tree.ImportDirectiveImpl : object {
    private static ICppFileReference CreateReference(ICppImportDirective importDirective, int offsetInNodeText, string text, TextRange rangeInPath, ICppFileReference parent, bool isFolder);
    internal static string ParseIncludeDirectiveContent(IBuffer buffer, int start, int end);
    internal static IReadOnlyList`1<IReference> CalculateReferences(ICppImportDirective importDirective, Nullable`1<CppFileLocation> pchIncludeTarget);
    internal static IReadOnlyList`1<IReference> CalculateReferences(Func`5<string, TextRange, ICppFileReference, bool, ICppFileReference> createReference, string stringValue, CppInclusionContext context, ISolution solution);
    private static string CalculateBasePath(string transformedPath, IReadOnlyList`1<string> originalParts, Int32& commonPartsSuffixLength);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.InitBitfieldDeclarator : NonAbstractDeclaratorBase {
    public NodeType NodeType { get; }
    public InitBitfieldDeclarator(ICppDeclaratorSymbol symbol);
    public virtual NodeType get_NodeType();
    protected virtual CppViewPos GetViewPosByResolveEntity(ICppDeclaratorResolveEntity ent);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.InitDeclarator : NonAbstractDeclaratorBase {
    private CppReferenceBase`1<InitDeclarator> myReference;
    public NodeType NodeType { get; }
    public ITokenNode EqOperator { get; }
    public ICppExpressionNode Initializer { get; }
    public ICppExpressionsArgumentListNode ArgumentList { get; }
    public bool IsDirectInitialization { get; }
    public InitDeclarator(ICppDeclaratorSymbol symbol);
    public virtual NodeType get_NodeType();
    public ITokenNode get_EqOperator();
    public ICppExpressionNode get_Initializer();
    public ICppExpressionsArgumentListNode get_ArgumentList();
    public CppResolveResult GetResolveResult();
    public bool get_IsDirectInitialization();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    public virtual void DropReferences();
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
    private CppImplicitConversionSequence BuildInitializationConversionSequence(ICppDeclaratorResolveEntity decl, CppTypeContext& tc, CppOverloadSetBuilderParams builderParams);
    protected virtual CppViewPos GetViewPosByResolveEntity(ICppDeclaratorResolveEntity ent);
    private ICppExpressionNode FindInitializerExpressionNode();
    private ICppExpressionsArgumentListNode FindArgListNode();
    [CompilerGeneratedAttribute]
internal static bool <BuildConversion>g__CanBeAggregateParenInit|14_0(ICppExpressionsArgumentListNode argList, ICppDeclaratorResolveEntity decl, ICppFileResolveEntitiesCache resolveCache, CppViewPos& vp);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.InitDeclaratorNavigator : object {
    public static InitDeclarator GetByInitializerOrArgument(ICppExpressionNode node);
    public static InitDeclarator GetByInitializer(ICppExpressionNode node);
    public static InitDeclarator GetByArgumentList(ICppExpressionsArgumentListNode node);
    public static InitDeclarator GetByDeclaration(Declaration node);
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.ISymbolNode`1 {
    public abstract virtual T GetSymbol();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.KnRStyleParameterDeclarations : CppCompositeNode {
    private CppParameterListResolveEntity myParameterListResolveEntity;
    public NodeType NodeType { get; }
    public CppList`1<Declaration> ParameterDeclarations { get; }
    public KnRStyleParameterDeclarations(CppParameterListResolveEntity parameterListResolveEntity);
    public virtual NodeType get_NodeType();
    public CppList`1<Declaration> get_ParameterDeclarations();
    public CppParameterListResolveEntity getParameterListResolveEntity();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.LabeledStatement : CppCompositeNode {
    public ITokenNode LabelIdent { get; }
    public ICppStatement Statement { get; }
    public NodeType NodeType { get; }
    public ITokenNode get_LabelIdent();
    public sealed virtual ICppStatement get_Statement();
    public virtual NodeType get_NodeType();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.LabeledStatementNavigator : object {
    public static LabeledStatement GetByLabelIdent(ITokenNode child);
    public static LabeledStatement GetByStatement(ICppStatement statement);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.LambdaCapture : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode EqToken { get; }
    public ITokenNode RefToken { get; }
    public ITokenNode MulToken { get; }
    public ITokenNode ThisToken { get; }
    public ICppAnyResolvedReferenceExpression CapturedReferenceNode { get; }
    public LambdaCaptureName LambdaCaptureNameNode { get; }
    public ICppExpressionNode Initializer { get; }
    public ICppExpressionsArgumentListNode ArgumentList { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_EqToken();
    public ITokenNode get_RefToken();
    public ITokenNode get_MulToken();
    public ITokenNode get_ThisToken();
    public ICppAnyResolvedReferenceExpression get_CapturedReferenceNode();
    public LambdaCaptureName get_LambdaCaptureNameNode();
    public ICppExpressionNode get_Initializer();
    public ICppExpressionsArgumentListNode get_ArgumentList();
    public CppLambdaCaptureDescription GetCaptureDescription();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.LambdaCaptureName : BaseNamedSymbolNode`1<CppLambdaInitCaptureSymbol> {
    public NodeType NodeType { get; }
    public ITokenNode Name { get; }
    public LambdaCaptureName(ICppSymbol symbol);
    public virtual NodeType get_NodeType();
    public ITokenNode get_Name();
    public virtual CppTreeElementRange GetNameTokenRange();
    public ICppVariableDeclaratorResolveEntity GetResolveEntity();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.LambdaCaptureNavigator : object {
    public static LambdaCapture GetByInitializer(ICppExpressionNode initializer);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.LambdaDeclarator : FunctionParameters {
    public NodeType NodeType { get; }
    [CanBeNullAttribute]
public ITokenNode StaticSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode MutableSpecifierNode { get; }
    public LambdaDeclarator(CppParameterListResolveEntity resolveEntity);
    public virtual NodeType get_NodeType();
    public ITokenNode get_StaticSpecifierNode();
    public ITokenNode get_MutableSpecifierNode();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.LambdaDeclaratorNavigator : FunctionParametersNavigator`1<LambdaDeclarator> {
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.LambdaExpression : BaseSymbolNode`1<CppLambdaSymbol> {
    private CppLambdaClassResolveEntity myClassResolveEntity;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myChildrenAreResolved;
    public NodeType NodeType { get; }
    public LambdaIntroducer LambdaIntroducerNode { get; }
    [CanBeNullAttribute]
public LambdaDeclarator LambdaDeclaratorNode { get; }
    public CompoundStatement LambdaBodyNode { get; }
    public RequiresClause HeaderRequiresClauseNode { get; }
    public RequiresClause TrailingRequiresClauseNode { get; }
    public LambdaExpression(ICppSymbol symbol, CppLambdaClassResolveEntity clazz);
    public CppLambdaSymbol GetLambdaSymbol();
    public sealed virtual ICppClassResolveEntity GetClassResolveEntity();
    public virtual NodeType get_NodeType();
    public LambdaIntroducer get_LambdaIntroducerNode();
    public LambdaDeclarator get_LambdaDeclaratorNode();
    public CompoundStatement get_LambdaBodyNode();
    public RequiresClause get_HeaderRequiresClauseNode();
    public RequiresClause get_TrailingRequiresClauseNode();
    public sealed virtual CppTypeAndCategory GetTypeAndCategory();
    public sealed virtual CppTypeAndCategory GetVerboseTypeAndCategory();
    public sealed virtual CppQualType GetVerboseType();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public sealed virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public sealed virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public CppLambdaClassResolveEntity GetLambdaClassResolveEntity();
    public sealed virtual void MarkChildrenAsResolved();
    public sealed virtual bool ChildrenAreResolved();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.LambdaExpressionNavigator : object {
    public static LambdaExpression GetByCompoundStatement(CompoundStatement statement);
    public static LambdaExpression GetByLambdaDeclarator(LambdaDeclarator declarator);
    public static LambdaExpression GetByRequiresClause(RequiresClause declarator);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.LambdaIntroducer : CppCompositeNode {
    public NodeType NodeType { get; }
    public CppList`1<LambdaCapture> LambdaCaptureNodes { get; }
    public LambdaCapture LastCapture { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public virtual NodeType get_NodeType();
    public CppList`1<LambdaCapture> get_LambdaCaptureNodes();
    public LambdaCapture get_LastCapture();
    public ITokenNode get_LBracket();
    public ITokenNode get_RBracket();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.LambdaIntroducerNavigator : object {
    public static LambdaIntroducer GetByLambdaCapture(LambdaCapture capture);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.LinkageSpecification : CppCompositeNode {
    private string mySpecification;
    public NodeType NodeType { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public string Specification { get; }
    public IEnumerable`1<SimpleDeclaration> Declarations { get; }
    public virtual NodeType get_NodeType();
    public sealed virtual ITokenNode get_LBrace();
    public sealed virtual ITokenNode get_RBrace();
    public string get_Specification();
    public IEnumerable`1<SimpleDeclaration> get_Declarations();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.LinkageSpecificationNavigator : object {
    public static LinkageSpecification GetByLBrace(ITokenNode node);
    public static LinkageSpecification GetByRBrace(ITokenNode node);
    public static LinkageSpecification GetByDeclaration(SimpleDeclaration decl);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.LiteralExpression : CppExpressionNode {
    public NodeType NodeType { get; }
    public ITreeNode Literal { get; }
    public virtual NodeType get_NodeType();
    public ITreeNode get_Literal();
    public sealed virtual ICppLiteralValue GetValue();
    public virtual CppDependentInfo GetDependentInfo();
    public virtual TriBool IsNoexcept();
    public virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public virtual TResult Accept(ICppExpressionNodeVisitor`1<TResult> visitor);
    public CppList`1<ITokenNode> GetLiterals();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.LiteralExpressionNavigator : object {
    public static LiteralExpression GetByStringLiteralToken(ITokenNode node);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.LoopStatementNavigator : object {
    public static ICppLoopStatement GetByBody(ICppStatement body);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MacroArgument : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual void FindNodesAtInternal(TreeTextRange relativeRange, List`1<ITreeNode> result, bool includeContainingNodes);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MacroArgumentList : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode LParen { get; }
    public ITokenNode RParen { get; }
    public CppList`1<ITokenNode> Commas { get; }
    public CppList`1<MacroArgument> Arguments { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_LParen();
    public ITokenNode get_RParen();
    public CppList`1<ITokenNode> get_Commas();
    public CppList`1<MacroArgument> get_Arguments();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.MacroArgumentListNavigator : object {
    public static MacroArgumentList GetByMacroArgument(MacroArgument arg);
    public static MacroArgumentList GetByToken(ITokenNode token);
    public static MacroArgumentList GetByLPar(ITokenNode token);
    public static MacroArgumentList GetByRPar(ITokenNode token);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.MacroArgumentNavigator : object {
    public static MacroArgument GetByToken(ITokenNode token);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MacroBody : CppCompositeNode {
    public NodeType NodeType { get; }
    public CppList`1<ITokenNode> Identifiers { get; }
    public virtual NodeType get_NodeType();
    public CppList`1<ITokenNode> get_Identifiers();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MacroBodyNavigator : BaseNavigator`1<MacroBody> {
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MacroCall : CppCompositeNode {
    [CompilerGeneratedAttribute]
private int <MacroLevel>k__BackingField;
    public NodeType NodeType { get; }
    [CanBeNullAttribute]
public MacroReference MacroReferenceNode { get; }
    public MacroArgumentList ArgumentListNode { get; }
    public int MacroLevel { get; }
    public MacroCall(int macroLevel);
    public virtual NodeType get_NodeType();
    public MacroReference get_MacroReferenceNode();
    public MacroArgumentList get_ArgumentListNode();
    [CompilerGeneratedAttribute]
public int get_MacroLevel();
    public bool IsTopLevel();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MacroCallNavigator : BaseNavigator`1<MacroCall> {
    public static MacroCall GetByMacroReference(MacroReference reference);
    public static MacroCall GetByMacroArgument(MacroArgument argument);
    public static MacroCall GetByMacroArgumentList(MacroArgumentList argument);
    public static MacroCall GetByToken(ITokenNode token);
    public static bool ContainsMacroCalls(CppCompositeNode node);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Tree.MacroClosure : ValueType {
    private static OrderedHashSet`1<MacroCall> EmptyMacroSet;
    private OrderedHashSet`1<MacroCall> myMacros;
    public OrderedHashSet`1<MacroCall> Macros { get; }
    public IEnumerable`1<MacroCall> MacrosInOrder { get; }
    private MacroClosure(CppTreeElementRange range);
    private MacroClosure(ITokenNode node);
    private static MacroClosure();
    public OrderedHashSet`1<MacroCall> get_Macros();
    public IEnumerable`1<MacroCall> get_MacrosInOrder();
    public static MacroClosure BuildFull(ITreeNode node);
    public static MacroClosure BuildFull(ITreeRange range);
    public static MacroClosure BuildSticked(ITreeNode node);
    public static MacroClosure BuildSticked(ITreeRange range);
    private static MacroCall ProcessTokenForMacroClosure(ITokenNode token, Int32& macroLevel, HashSet`1& prototyped, OrderedHashSet`1& macros, bool isLeftMost);
    private static bool Contains(CppTreeElementRange range, ITreeNode node);
    private static void BuildMacroClosure(CppTreeElementRange range, HashSet`1& prototyped, OrderedHashSet`1& macros, bool isLeftMostMacroCall);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MacroDefinition : BaseNamedMacroSymbolNode`1<CppPPDefineSymbol> {
    public ITokenNode Head { get; }
    public ITokenNode Name { get; }
    public MacroBody Body { get; }
    [CanBeNullAttribute]
public MacroParameterList ParameterList { get; }
    public NodeType NodeType { get; }
    public MacroDefinition(ICppSymbol symbol);
    public ITokenNode get_Head();
    public ITokenNode get_Name();
    public MacroBody get_Body();
    public MacroParameterList get_ParameterList();
    public virtual NodeType get_NodeType();
    public virtual CppTreeElementRange GetNameTokenRange();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MacroDefinitionNavigator : BaseNavigator`1<MacroDefinition> {
    public static MacroDefinition GetByMacroParameter(MacroParameter parameter);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MacroMigration : object {
    private ITreeRange mySource;
    private ITreeRange myTarget;
    private ITreeNode myParent;
    private ITreeNode myAnchor;
    private MacroClosure mySourceClosure;
    private MacroClosure myTargetClosure;
    private IPsiModule myPsiModule;
    private Func`2<MacroCall, MacroCall> mySelector;
    private MacroMigration(ITreeRange source, ITreeRange target, Func`2<MacroCall, MacroCall> selector);
    public sealed virtual void Dispose();
    public static MacroMigration CreateSwiping(ITreeNode source, ITreeNode target);
    public static MacroMigration CreateSwiping(ITreeRange source, ITreeRange target);
    public static MacroMigration CreateCloning(ITreeNode source, ITreeNode target);
    public static MacroMigration CreateCloning(ITreeRange source, ITreeRange target);
    public void Anchor(ITreeNode n);
    private void Migrate();
    private void Swipe(MacroClosure c);
    private void Sandbox();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MacroMigrationUtil : object {
    public static Func`2<MacroCall, MacroCall> IdentitySelector;
    public static Func`2<MacroCall, MacroCall> CloningSelector;
    private static MacroMigrationUtil();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MacroParameter : BaseNamedMacroSymbolNode`1<CppPPMacroParameterSymbol> {
    private CppPPMacroParameterSymbol mySymbol;
    public string Name { get; }
    public NodeType NodeType { get; }
    public string get_Name();
    public virtual NodeType get_NodeType();
    public virtual CppTreeElementRange GetNameTokenRange();
    public virtual CppPPMacroParameterSymbol GetSymbol();
    public CppPPMacroParameterSymbol GetSymbolRaw();
    public virtual ICppSymbol GetGenericSymbol();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MacroParameterList : CppCompositeNode {
    public NodeType NodeType { get; }
    public CppList`1<MacroParameter> MacroParameters { get; }
    public virtual NodeType get_NodeType();
    public CppList`1<MacroParameter> get_MacroParameters();
    public bool HasVarargs();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.MacroParameterListNavigator : object {
    public static MacroParameterList GetByMacroParameter(MacroParameter param);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MacroReference : CppCompositeNode {
    private MacroReferenceReference myReference;
    [CanBeNullAttribute]
private CppPPDefineSymbol mySymbol;
    public int MacroLevel { get; }
    private MacroReferenceReference FirstClassRef { get; }
    public NodeType NodeType { get; }
    public MacroReference(CppPPDefineSymbol symbol);
    public int get_MacroLevel();
    private MacroReferenceReference get_FirstClassRef();
    public virtual NodeType get_NodeType();
    public sealed virtual CppTreeElementRange GetNameTokenRange();
    public virtual ReferenceCollection GetFirstClassReferences();
    [CanBeNullAttribute]
public CppPPDefineSymbol GetReferencedSymbol();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.MacroReferenceNavigator : object {
    public static MacroReference GetByIdentifier(ITokenNode identifier);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MacroUndefinition : BaseNamedMacroSymbolNode`1<CppPPUndefSymbol> {
    public NodeType NodeType { get; }
    public ITokenNode Head { get; }
    public MacroReference MacroReferenceNode { get; }
    public MacroUndefinition(ICppSymbol symbol);
    public virtual NodeType get_NodeType();
    public ITokenNode get_Head();
    public MacroReference get_MacroReferenceNode();
    public virtual CppTreeElementRange GetNameTokenRange();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MemberAccessDesignator : BaseDesignatorNode {
    private MemberAccessDesignatorReference myReference;
    public NodeType NodeType { get; }
    public ITokenNode Identifier { get; }
    public virtual NodeType get_NodeType();
    public CppResolveResult GetCppResolveResult();
    public virtual CppQualType GetInferredScopeType();
    public ITokenNode get_Identifier();
    public sealed virtual string GetName();
    public sealed virtual CppTreeElementRange GetNameTokenRange();
    public virtual ReferenceCollection GetFirstClassReferences();
    public ICppSubordinateReference GetReference();
    public virtual TResult Accept(ICppDesignatorVisitor`1<TResult> visitor);
    public virtual void DropReferences();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MemberAccessExpression : CppExpressionNodeWithCachedDepInfo {
    public static NodeTypeSet SIGN_TYPES;
    private ArrowOperatorReference myReference;
    private CppCachedValue`1<CppResolveResult> myResolvedMember;
    public NodeType NodeType { get; }
    public QualifiedReference Member { get; }
    public ITokenNode Sign { get; }
    public ICppExpressionNode Qualifier { get; }
    private ArrowOperatorReference FirstClassRef { get; }
    private static MemberAccessExpression();
    public virtual NodeType get_NodeType();
    public QualifiedReference get_Member();
    public ITokenNode get_Sign();
    public ICppExpressionNode get_Qualifier();
    public sealed virtual ICppExpression GetLeftArgument();
    public sealed virtual ICppResolvedExpression GetResolvedLeftArgument();
    public sealed virtual CppQualifiedName GetRightArgument();
    public sealed virtual CppMemberAccessType GetAccessType();
    public sealed virtual CppResolveResult GetLookupScopeResolveResult();
    public ICppResolveEntity GetResolvedScope();
    public sealed virtual CppResolveResult GetResolvedReference();
    public sealed virtual CppViewPos GetViewPos();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual void DropReferences();
    private ArrowOperatorReference get_FirstClassRef();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.MemberAccessExpressionNavigator : object {
    public static MemberAccessExpression GetByQualifier(ICppExpressionNode qualifier);
    public static MemberAccessExpression GetByQualifierThroughParens(ICppExpressionNode qualifier);
    public static MemberAccessExpression GetByMember(QualifiedReference member);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MemInitializer : CppCompositeNode {
    private CppDeclaratorReference`1<MemInitializer> myReference;
    public NodeType NodeType { get; }
    public MemInitializerName MemberInitializerNameNode { get; }
    [CanBeNullAttribute]
public ICppExpressionsArgumentListNode ArgumentList { get; }
    public virtual NodeType get_NodeType();
    public MemInitializerName get_MemberInitializerNameNode();
    public ICppExpressionsArgumentListNode get_ArgumentList();
    public virtual ReferenceCollection GetFirstClassReferences();
    public CppResolveResult GetResolveResult();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    public virtual void DropReferences();
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MemInitializerName : BaseQualifiedReference {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual CppLookupResult LookupReferenceWithCustomName(CppQualifiedName name);
    public Nullable`1<CppMemInitNameTargetKind> GetInitTargetKind();
    public MemInitializer GetMemInitializer();
    public CppQualType CalculateType();
    public CppQualType CalculateVerboseType();
    private Declaration GetDeclaration();
    private ICppClassResolveEntity GetClassResolveEntity();
    private static CppQualType CalculateTypeImpl(MemInitializerName that, ICppResolvedTypeFactory tf);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.MemInitializerNavigator : object {
    public static MemInitializer GetByMemInitializerName(MemInitializerName name);
    public static MemInitializer GetByArgumentList(ICppExpressionsArgumentListNode argList);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ModuleDirective : BaseSymbolNode`1<CppModuleDirectiveSymbol> {
    public NodeType NodeType { get; }
    public ITokenNode ExportKeyword { get; }
    public ITokenNode Colon { get; }
    public ModuleName ModuleName { get; }
    public ModuleName PartitionName { get; }
    public IDeclaredElement DeclaredElement { get; }
    public CppModuleId ModuleId { get; }
    public string DeclaredName { get; }
    public ModuleDirective(CppModuleDirectiveSymbol symbol);
    public virtual NodeType get_NodeType();
    public ITokenNode get_ExportKeyword();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual CppTreeElementRange GetNameTokenRange();
    public ITokenNode get_Colon();
    public ModuleName get_ModuleName();
    public ModuleName get_PartitionName();
    public sealed virtual IDeclaredElement get_DeclaredElement();
    public CppModuleId get_ModuleId();
    public sealed virtual string get_DeclaredName();
    public sealed virtual void SetName(string name);
    public sealed virtual TreeTextRange GetNameRange();
    public sealed virtual bool IsSynthetic();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ModuleName : CppCompositeNode {
    public NodeType NodeType { get; }
    public ModuleNameQualifier Qualifier { get; }
    public virtual NodeType get_NodeType();
    public ModuleNameQualifier get_Qualifier();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ModuleNameQualifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSAsmComment : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSAsmDefinition : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode LBrace { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_LBrace();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSAssumeExpression : CppExpressionNode {
    public NodeType NodeType { get; }
    public ICppExpressionNode Argument { get; }
    public virtual NodeType get_NodeType();
    public ICppExpressionNode get_Argument();
    public sealed virtual ICppExpression GetArgument();
    public virtual CppDependentInfo GetDependentInfo();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSAttributes : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSDeclSpec : CppCompositeNode {
    public NodeType NodeType { get; }
    private IEnumerable`1<ITokenNode> Specifiers { get; }
    public virtual NodeType get_NodeType();
    private IEnumerable`1<ITokenNode> get_Specifiers();
    public bool HasNoVTable();
    public bool IsDllExport();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSEventHookExpression : CppExpressionNodeWithCachedDepInfo {
    public ITokenNode HookKeyword { get; }
    public ITokenNode UnhookKeyword { get; }
    public FunctionArgumentList ArgumentList { get; }
    public NodeType NodeType { get; }
    public ITokenNode get_HookKeyword();
    public ITokenNode get_UnhookKeyword();
    public FunctionArgumentList get_ArgumentList();
    public virtual NodeType get_NodeType();
    public sealed virtual bool IsUnhook();
    public sealed virtual ICppArgumentList GetArgumentList();
    public sealed virtual CppViewPos GetViewPos();
    public virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
    public virtual TResult Accept(ICppExpressionNodeVisitor`1<TResult> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSForeachStatement : RangedForBase {
    private CppForStatementResolveEntity myResolveEntity;
    public NodeType NodeType { get; }
    public ITokenNode ForKeyword { get; }
    public ITokenNode EachKeyword { get; }
    public ITokenNode Colon { get; }
    public Declaration ForRangeDeclaration { get; }
    public ICppExpressionOrDeclarationNode InitStatement { get; }
    public MSForeachStatement(CppForStatementResolveEntity resolveEntity);
    public virtual NodeType get_NodeType();
    public virtual ITokenNode get_ForKeyword();
    public ITokenNode get_EachKeyword();
    public virtual ITokenNode get_Colon();
    public virtual Declaration get_ForRangeDeclaration();
    public virtual ICppExpressionOrDeclarationNode get_InitStatement();
    public virtual ICppScopeResolveEntity GetResolveScope();
    public virtual ICppExpressionNode GetRangeInitializer();
    public virtual CppForStatementKind GetForType();
    public CppForStatementResolveEntity GetResolveEntity();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.MSForeachStatementNavigator : object {
    public static MSForeachStatement GetByDeclaration(Declaration declaration);
    public static MSForeachStatement GetByForKeyword(ITokenNode child);
    public static MSForeachStatement GetByEachKeyword(ITokenNode child);
    public static MSForeachStatement GetByInKeyword(ITokenNode child);
    public static MSForeachStatement GetByBody(ICppStatement body);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSIdentifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode GetNameToken();
    public string GetUnscreenedText();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSIfExistsArgumentClause : CppCompositeNode {
    public MSIfExistsReference Reference { get; }
    public ITokenNode IfExistsNode { get; }
    public ITokenNode IfNotExistsNode { get; }
    public NodeType NodeType { get; }
    public MSIfExistsReference get_Reference();
    public ITokenNode get_IfExistsNode();
    public ITokenNode get_IfNotExistsNode();
    public virtual NodeType get_NodeType();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.MSIfExistsBaseNode : CppCompositeNode {
    public MSIfExistsArgumentClause ArgumentClause { get; }
    public MSIfExistsArgumentClause get_ArgumentClause();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.MSIfExistsBaseNodeNavigator : object {
    public static MSIfExistsBaseNode GetByBraces(MSIfExistsBlockBraces braces);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSIfExistsBlockBraces : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public virtual NodeType get_NodeType();
    public virtual ITokenNode get_LBrace();
    public virtual ITokenNode get_RBrace();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSIfExistsClassMember : MSIfExistsBaseNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSIfExistsExpression : MSIfExistsBaseNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSIfExistsReference : BaseQualifiedReference {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual CppLookupResult LookupReferenceWithCustomName(CppQualifiedName name);
    private static CppLookupResult DoResolve(CppQualifiedName name, CppViewPos& viewPos);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSIfExistsStatement : MSIfExistsBaseNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSIfExistsTopLevel : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSImportDirective : BaseSymbolNode`1<CppPPIncludeSymbol> {
    private IReadOnlyList`1<IReference> myReferences;
    public NodeType NodeType { get; }
    public string UnquotedImportPath { get; }
    public ITokenNode QuotedImportPath { get; }
    public bool IsAngleBracket { get; }
    public bool IsIncludeNext { get; }
    public MSImportDirective(ICppSymbol symbol);
    public virtual NodeType get_NodeType();
    public sealed virtual string get_UnquotedImportPath();
    public sealed virtual ITokenNode get_QuotedImportPath();
    public sealed virtual bool get_IsAngleBracket();
    public sealed virtual bool get_IsIncludeNext();
    public virtual ReferenceCollection GetFirstClassReferences();
    private IReadOnlyList`1<IReference> CalculateReferences();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSLeaveStatement : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSLPrefixedLiteral : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSNoopExpression : CppExpressionNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual CppDependentInfo GetDependentInfo();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MSUuidOfExpression : CppExpressionNodeWithCachedDepInfo {
    public NodeType NodeType { get; }
    public ICppTypeIdOrExpressionNode Argument { get; }
    public virtual NodeType get_NodeType();
    public ICppTypeIdOrExpressionNode get_Argument();
    public sealed virtual ICppTypeIdOrExpression GetArgument();
    public sealed virtual CppViewPos GetViewPos();
    public virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public virtual TResult Accept(ICppExpressionNodeVisitor`1<TResult> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.MSUuidOfExpressionNavigator : object {
    public static MSUuidOfExpression GetByArgument(ICppTypeIdOrExpressionNode arg);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.MultiArgumentTypeTraitExpression : BooleanExpressionNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public CppList`1<TypeId> GetArgumentsTypeId();
    public ITokenNode GetKeyword();
    public sealed virtual CppList`1<Element> GetArguments();
    public static bool ArgumentIsExpansion(TypeId e);
    public sealed virtual CppMultiArgumentTypeTraitKind GetKind();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.MultiArgumentTypeTraitExpressionNavigator : object {
    public static MultiArgumentTypeTraitExpression GetByArgument(TypeId arg);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.NameQualifier : BaseQualifiedReference {
    public NodeType NodeType { get; }
    public ITokenNode Colon2xNode { get; }
    public virtual NodeType get_NodeType();
    public virtual CppLookupResult LookupReferenceWithCustomName(CppQualifiedName resolvedName);
    public QualifiedReference GetQualifiedReference();
    public BaseQualifiedReference GetBaseQualifiedReference();
    public IDeclarationName GetDeclarationName();
    public ITokenNode get_Colon2xNode();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.NamespaceAliasDefinition : BaseNamedSymbolNode`1<CppNamespaceAliasSymbol> {
    public NodeType NodeType { get; }
    public NamespaceAliasDefinition(ICppSymbol symbol);
    public ITreeNode GetNameNode();
    public virtual NodeType get_NodeType();
    public virtual CppTreeElementRange GetNameTokenRange();
    public sealed virtual CppViewPos GetViewPos();
    public CppNamespaceAliasResolveEntity GetResolveEntity();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.NamespaceAliasDefinitionNavigator : object {
    public static NamespaceAliasDefinition GetByValue(QualifiedNamespaceReference value);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.NamespaceDefinition : BaseNamedSymbolNode`1<CppNamespaceSymbol> {
    public NodeType NodeType { get; }
    [CanBeNullAttribute]
public ITokenNode InlineSpecifierNode { get; }
    public ITokenNode NamespaceKeyword { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public AttributeList AttributeListNode { get; }
    public NamespaceDefinition(ICppSymbol symbol);
    public virtual NodeType get_NodeType();
    public ITokenNode get_InlineSpecifierNode();
    public ITokenNode get_NamespaceKeyword();
    public ITokenNode get_LBrace();
    public ITokenNode get_RBrace();
    public AttributeList get_AttributeListNode();
    public NamespaceDefinitionName GetNameNode();
    public virtual CppTreeElementRange GetNameTokenRange();
    public sealed virtual ICppScopeResolveEntity GetResolveScope();
    public CppNamespaceResolveEntity GetResolveEntity();
    public sealed virtual ICppScopeResolveEntity GetScopeForDeclarations();
    public sealed virtual CppDeclarationOwnerKind GetDeclarationOwnerKind();
    public CppList`1<ICppTopLevelDeclarationNode> GetTopLevelDeclarations();
    public sealed virtual IEnumerable`1<ICppCompositeNode> GetMembers();
    public sealed virtual ICppTopLevelDeclarationNode GetNextDeclaration(ICppTopLevelDeclarationNode decl);
    public sealed virtual ICppTopLevelDeclarationNode GetPrevDeclaration(ICppTopLevelDeclarationNode decl);
    public sealed virtual T AddDeclarationBefore(T decl, ITreeNode anchor, bool withComments);
    public sealed virtual bool CanAddDeclarationBefore(ITreeNode anchor);
    public sealed virtual T AddDeclarationAfter(T decl, ITreeNode anchor, bool withComments);
    public sealed virtual bool CanAddDeclarationAfter(ITreeNode anchor);
    public sealed virtual void RemoveDeclaration(T decl, CppCommentsDeleteMode commentsDeleteMode);
    public sealed virtual CppComplexOffset GetTopComplexOffset();
    public sealed virtual CppComplexOffset GetBottomComplexOffset();
    public sealed virtual ITreeNode GetBodyStartAnchor();
    public sealed virtual ITreeNode GetBodyEndAnchor();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.NamespaceDefinitionName : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode GetIdentifier();
    public MSIdentifier GetMSIdentifier();
    [CanBeNullAttribute]
public NamespaceDefinitionNameQualifier GetQualifier();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.NamespaceDefinitionNameNavigator : object {
    public static NamespaceDefinitionName GetByQualifier(NamespaceDefinitionNameQualifier node);
    public static NamespaceDefinitionName GetByNamePart(ITreeNode namePart);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.NamespaceDefinitionNameQualifier : BaseNamedSymbolNode`1<CppNamespaceQualifierSymbol> {
    public NodeType NodeType { get; }
    public NamespaceDefinitionNameQualifier NameQualifier { get; }
    [CanBeNullAttribute]
public ITokenNode InlineSpecifierNode { get; }
    public NamespaceDefinitionNameQualifier(ICppSymbol symbol);
    public virtual NodeType get_NodeType();
    public NamespaceDefinitionNameQualifier get_NameQualifier();
    public ITokenNode get_InlineSpecifierNode();
    public ITokenNode GetIdentifier();
    public MSIdentifier GetMSIdentifier();
    public CppNamespaceResolveEntity GetResolveEntity();
    public virtual CppTreeElementRange GetNameTokenRange();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.NamespaceDefinitionNameQualifierNavigator : object {
    public static NamespaceDefinitionNameQualifier GetByNestedQualifier(NamespaceDefinitionNameQualifier node);
    public static NamespaceDefinitionNameQualifier GetByNamePart(ITreeNode namePart);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.NamespaceDefinitionNavigator : object {
    public static NamespaceDefinition GetByLBrace(ITokenNode node);
    public static NamespaceDefinition GetByRBrace(ITokenNode node);
    public static NamespaceDefinition GetByChild(ITreeNode node);
    public static NamespaceDefinition GetByName(NamespaceDefinitionName node);
    public static NamespaceDefinition GetByQualifier(NamespaceDefinitionNameQualifier node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.NestedDeclarator : BaseDeclaratorNode {
    public NodeType NodeType { get; }
    [CanBeNullAttribute]
public ITokenNode ConstSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode VolatileSpecifierNode { get; }
    [CanBeNullAttribute]
public AbstractDeclaratorName AbstractDeclaratorNameNode { get; }
    [CanBeNullAttribute]
public ArraySizeSpecifier FirstArraySizeSpecifierNode { get; }
    public CppList`1<ArraySizeSpecifier> ArraySizeSpecifierNodes { get; }
    public CppList`1<ParametersAndQualifiers> ParametersAndQualifiersNodes { get; }
    public ParametersAndQualifiers ParametersAndQualifiersNode { get; }
    public DeclaratorQualifiedName DeclaratorQualifiedNameNode { get; }
    public ITreeNode FirstPrefixNode { get; }
    public ITreeNode LastPrefixNode { get; }
    public ITreeNode FirstSuffixNode { get; }
    public ITreeNode LastSuffixNode { get; }
    public CppList`1<ITreeNode> TypePrefixNodes { get; }
    public CppList`1<ITreeNode> TypeSuffixNodes { get; }
    public ITokenNode MsCallingConventionNode { get; }
    [CanBeNullAttribute]
public ITokenNode LParen { get; }
    [CanBeNullAttribute]
public ITokenNode RParen { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_ConstSpecifierNode();
    public ITokenNode get_VolatileSpecifierNode();
    public AbstractDeclaratorName get_AbstractDeclaratorNameNode();
    public ArraySizeSpecifier get_FirstArraySizeSpecifierNode();
    public CppList`1<ArraySizeSpecifier> get_ArraySizeSpecifierNodes();
    public CppList`1<ParametersAndQualifiers> get_ParametersAndQualifiersNodes();
    public ParametersAndQualifiers get_ParametersAndQualifiersNode();
    public DeclaratorQualifiedName get_DeclaratorQualifiedNameNode();
    public ITreeNode get_FirstPrefixNode();
    public ITreeNode get_LastPrefixNode();
    public ITreeNode get_FirstSuffixNode();
    public ITreeNode get_LastSuffixNode();
    public CppList`1<ITreeNode> get_TypePrefixNodes();
    public CppList`1<ITreeNode> get_TypeSuffixNodes();
    public ITokenNode get_MsCallingConventionNode();
    public ITokenNode get_LParen();
    public ITokenNode get_RParen();
    protected sealed virtual CppViewPos GetViewPosByResolveEntity(ICppDeclaratorResolveEntity ent);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.NestedDeclaratorNavigator : object {
    public static NestedDeclarator GetByParametersAndQualifiers(ParametersAndQualifiers quals);
    public static NestedDeclarator GetByDeclaratorQualifiedName(DeclaratorQualifiedName dqn);
    public static NestedDeclarator GetByFirstArraySizeSpecifierNode(ArraySizeSpecifier arraySize);
    public static NestedDeclarator GetByArraySizeSpecifierNode(ArraySizeSpecifier arraySize);
    public static NestedDeclarator GetByNestedDeclarator(NestedDeclarator decl);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.NewExpression : CppExpressionNodeWithCachedDepInfo {
    private CppReferenceBase`1<NewExpression> myConstructorReference;
    private CppReferenceBase`1<NewExpression> myOperatorReference;
    public NodeType NodeType { get; }
    public TypeId NewTypeId { get; }
    public FunctionArgumentList OperatorArgumentList { get; }
    public ICppExpressionsArgumentListNode ConstructorArgumentList { get; }
    public ITokenNode NewKeyword { get; }
    public CppOperatorKind OperatorKind { get; }
    public virtual NodeType get_NodeType();
    public TypeId get_NewTypeId();
    public FunctionArgumentList get_OperatorArgumentList();
    public ICppExpressionsArgumentListNode get_ConstructorArgumentList();
    public ITokenNode get_NewKeyword();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppNewExpressionResolveResult GetResolvedOperator();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual bool IsCliGCNew();
    public sealed virtual bool IsFromGlobalNamespace();
    public sealed virtual CppQualType GetQualType();
    public sealed virtual ICppArgumentList GetOperatorArgumentList();
    public sealed virtual ICppArgumentList GetConstructorArgumentList();
    public bool IsArrayKind();
    public CppOperatorKind get_OperatorKind();
    public CppResolveResult GetConstructorResolveResult();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    public void BuildOperatorConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
    public virtual void DropReferences();
    protected virtual CppDependentInfo CalculateDependentInfo();
    private static bool ShouldResolveDefaultConstructor(NewExpression newExpr);
    private static bool ShouldResolveConstructor(NewExpression newExpr);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.NewExpressionNavigator : object {
    public static NewExpression GetByNewTypeId(TypeId typeId);
    public static NewExpression GetByNewKeyword(ITokenNode newKeyword);
    public static NewExpression GetByArgumentList(ICppExpressionsArgumentListNode argListNode);
    public static NewExpression GetByPlacementArgumentList(ICppExpressionsArgumentListNode argListNode);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.NoExceptExpression : CppExpressionNode {
    public NodeType NodeType { get; }
    public ICppExpressionNode Argument { get; }
    public virtual NodeType get_NodeType();
    public ICppExpressionNode get_Argument();
    public sealed virtual ICppExpression GetArgument();
    public sealed virtual ICppResolvedExpression GetResolvedArgument();
    public virtual CppDependentInfo GetDependentInfo();
    public virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public virtual TResult Accept(ICppExpressionNodeVisitor`1<TResult> visitor);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.NoExceptExpressionNavigator : object {
    public static NoExceptExpression GetByArgument(ICppExpressionNode arg);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.NoExceptSpecification : CppCompositeNode {
    public NodeType NodeType { get; }
    public ICppExpressionNode NoExceptExpression { get; }
    public virtual NodeType get_NodeType();
    public ICppExpressionNode get_NoExceptExpression();
    public sealed virtual CppViewPos GetViewPos();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.NoExceptSpecificationNavigator : object {
    public static NoExceptSpecification GetByNoExceptExpression(ICppExpressionNode expr);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.NonAbstractDeclaratorBase : NonNestedDeclaratorBase {
    private ICppDeclaratorSymbol mySymbol;
    public IDeclaredElement DeclaredElement { get; }
    public string DeclaredName { get; }
    public RequiresClause RequiresClauseNode { get; }
    protected NonAbstractDeclaratorBase(ICppDeclaratorSymbol symbol);
    public virtual ICppSymbol GetGenericSymbol();
    public virtual ICppDeclaratorSymbol GetSymbol();
    public virtual ICppDeclaratorResolveEntity GetResolveEntity();
    public virtual DeclaratorQualifiedName GetDeclaratorQualifiedName();
    public virtual CppTreeElementRange GetNameTokenRange();
    public virtual XmlNode GetXMLDoc(bool inherit);
    public virtual bool IsSynthetic();
    public virtual IDeclaredElement get_DeclaredElement();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public virtual RequiresClause get_RequiresClauseNode();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.NonNestedDeclaratorBase : BaseDeclaratorNode {
    public virtual CppQualType CalculateUnresolvedType(CppTypeSelection selection);
    private void CalculateTypeInner(ICppResolvedTypeBuilder builder, CppTypeSelection selection);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.NonTypeParameter : BaseDeclaration {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public sealed virtual ICppTemplateParameter GetResolveEntity();
    public ICppTemplateParameterForPsi GetResolveEntityForPsi();
    public sealed virtual ITreeNode GetNameNode();
    public sealed virtual CppViewPos GetViewPos();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.NonTypeParameterNavigator : object {
    public static NonTypeParameter GetByDeclarationSpecifiers(DeclarationSpecifiers declarationSpecifiers);
    public static NonTypeParameter GetByDeclarator(ICppNonAbstractDeclaratorNode declarator);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.OffsetofMemberReferenceDesignator : BaseQualifiedReference {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual CppLookupResult LookupReferenceWithCustomName(CppQualifiedName name);
    private CppLookupResult DoResolve(CppQualifiedName resolvedName, CppViewPos& viewPos);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.OffsetofMemberReferenceDesignatorNavigator : object {
    public static OffsetofMemberReferenceDesignator GetByNameQualifier(NameQualifier nameQualifier);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.OperatorCoAwaitReference`1 : CoroutineReferenceBase`1<TNode> {
    public OperatorCoAwaitReference`1(TNode expr);
    public virtual ResolveResultWithInfo ResolveWithoutCache();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.OperatorFunctionId : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode SuffixNode { get; }
    public virtual NodeType get_NodeType();
    public sealed virtual CppViewPos GetViewPos();
    public ITokenNode get_SuffixNode();
    public DocumentRange GetSuffixDocumentRange();
    public string GetSuffixText();
    public void BuildOperatorName(CppQualifiedNameBuilder& builder);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.OperatorFunctionIdNavigator : object {
    public static OperatorFunctionId GetByOperatorKeyword(ITokenNode operatorKeyword);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.PackExpansionExpression : CppExpressionNode {
    public NodeType NodeType { get; }
    public ICppExpressionNode PatternNode { get; }
    public ICppExpression Pattern { get; }
    public virtual NodeType get_NodeType();
    public ICppExpressionNode get_PatternNode();
    public sealed virtual ICppExpression get_Pattern();
    public sealed virtual ICppResolvedExpression GetResolvedPattern();
    public virtual CppDependentInfo GetDependentInfo();
    public virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public virtual TResult Accept(ICppExpressionNodeVisitor`1<TResult> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ParametersAndQualifiers : FunctionParameters {
    public NodeType NodeType { get; }
    [CanBeNullAttribute]
public ITokenNode ConstSpecifierNode { get; }
    [CanBeNullAttribute]
public ITokenNode VolatileSpecifierNode { get; }
    public CppList`1<ITokenNode> CVQualifierNodes { get; }
    public CppList`1<ITokenNode> RefQualifierNodes { get; }
    public CppList`1<ITokenNode> CVRefQualifierNodes { get; }
    public ParametersAndQualifiers(CppParameterListResolveEntity resolveEntity);
    public virtual NodeType get_NodeType();
    public ITokenNode get_ConstSpecifierNode();
    public ITokenNode get_VolatileSpecifierNode();
    public CppList`1<ITokenNode> get_CVQualifierNodes();
    public CppList`1<ITokenNode> get_RefQualifierNodes();
    public CppList`1<ITokenNode> get_CVRefQualifierNodes();
    public CVQualifiers GetCVQualifiers();
    public FuncRefQualifier GetRefQualifier();
    public void AddConst();
    public void AddVolatile();
    public void AddFuncRefQualifier(FuncRefQualifier qualifier);
    protected virtual ITreeNode GetLastNodeBeforeRestrictionSpecifiers();
    private static void AddQualifierToParams(ParametersAndQualifiers params, TokenNodeType qualTt);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ParametersAndQualifiersNavigator : FunctionParametersNavigator`1<ParametersAndQualifiers> {
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ParenExpression : CppExpressionNode {
    public NodeType NodeType { get; }
    public ITokenNode LParen { get; }
    public ITokenNode RParen { get; }
    public ICppExpressionNode ParenthesizedExpression { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_LParen();
    public ITokenNode get_RParen();
    public sealed virtual ICppExpression GetInnerExpression();
    public ICppExpressionNode get_ParenthesizedExpression();
    public virtual CppDependentInfo GetDependentInfo();
    public virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public virtual TResult Accept(ICppExpressionNodeVisitor`1<TResult> visitor);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.ParenExpressionNavigator : object {
    public static ParenExpression GetByParenthesizedExpression(ICppExpressionNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.PostfixExpression : CppExpressionNodeWithCachedDepInfo {
    private PostfixOperatorReference myReference;
    public NodeType NodeType { get; }
    public ITokenNode Operator { get; }
    public ICppExpressionNode Operand { get; }
    public ICppReference FirstClassRef { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_Operator();
    public ICppExpressionNode get_Operand();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual ICppExpression GetArgument();
    public sealed virtual ICppResolvedExpression GetResolvedArgument();
    public sealed virtual CppOperatorKind GetOperatorKind();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppResolveResult GetResolvedOperator();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    public virtual void DropReferences();
    public ICppReference get_FirstClassRef();
    protected virtual CppDependentInfo CalculateDependentInfo();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.PostfixExpressionNavigator : object {
    public static PostfixExpression GetByOperator(ITokenNode op);
    public static PostfixExpression GetByOperand(ICppExpressionNode node);
    public static PostfixExpression GetByOperandThroughParens(ICppExpressionNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.PPPragmaDirective : CppCompositeNode {
    [CanBeNullAttribute]
public string PragmaName { get; }
    public ITokenNode Head { get; }
    [CanBeNullAttribute]
public ITokenNode PragmaNameNode { get; }
    public bool IsPragmaOnce { get; }
    public bool IsPragmaRegion { get; }
    public bool IsPragmaEndRegion { get; }
    public NodeType NodeType { get; }
    public string get_PragmaName();
    public ITokenNode get_Head();
    public ITokenNode get_PragmaNameNode();
    public bool get_IsPragmaOnce();
    public bool get_IsPragmaRegion();
    public bool get_IsPragmaEndRegion();
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.PragmaDirective : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.PragmaParameterReference : CppCompositeNode {
    private ICppReference myReference;
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public sealed virtual CppTreeElementRange GetNameTokenRange();
    public virtual ReferenceCollection GetFirstClassReferences();
    public CppResolveResult GetCppResolveResult();
    public ICppReference GetReference();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.PureSpecifier : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.QualifiedBaseTypeReference : BaseQualifiedReference {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual CppLookupResult LookupReferenceWithCustomName(CppQualifiedName name);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.QualifiedConceptReference : BaseQualifiedReference {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual CppQualifiedName GetQualifiedName();
    public ICppTemplateArgument[] GetExtraTemplateArguments();
    public virtual CppLookupResult LookupReferenceWithCustomName(CppQualifiedName name);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.QualifiedCxxCliOverrideTargetReference : BaseQualifiedReference {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual CppLookupResult LookupReferenceWithCustomName(CppQualifiedName name);
    public virtual CppResolveResult ResolveReferenceWithCustomName(CppQualifiedName name);
    public ICppDeclaratorResolveEntity GetParentDeclaratorEntity();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.QualifiedNamespaceReference : BaseQualifiedReference {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual CppLookupResult LookupReferenceWithCustomName(CppQualifiedName name);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.QualifiedReference : BaseQualifiedReference {
    private CppCachedValue`1<CppResolveResult> myResolvedReference;
    private CppCachedValue`1<CppQualifiedName> myResolvedName;
    private CppDependentInfo myDependentInfo;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myChildrenAreResolved;
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public sealed virtual CppTypeAndCategory GetTypeAndCategory();
    public sealed virtual CppTypeAndCategory GetVerboseTypeAndCategory();
    public sealed virtual CppQualType GetVerboseType();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public virtual CppLookupResult LookupReferenceWithCustomName(CppQualifiedName name);
    public virtual CppResolveResult ResolveReferenceWithCustomName(CppQualifiedName name);
    public virtual void DropReferences();
    public sealed virtual void MarkChildrenAsResolved();
    public sealed virtual bool ChildrenAreResolved();
    public bool IsDestructorTag();
    protected virtual ICppReference CreateReference();
    public sealed virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public sealed virtual CppResolveResult GetResolvedReference();
    public ICppResolveEntity GetResolvedScope();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppQualifiedName GetResolvedNameHint();
    public sealed virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public bool IsSubordinateReference();
    public static bool IsSubordinateReferenceNode(QualifiedReference ref);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.QualifiedTemplateReference : BaseQualifiedReference {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual CppLookupResult LookupReferenceWithCustomName(CppQualifiedName name);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.QualifiedTypenameReference : BaseQualifiedReference {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual CppLookupResult LookupReferenceWithCustomName(CppQualifiedName name);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.QualifiedUsingDeclarationTargetReference : BaseQualifiedReference {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual CppLookupResult LookupReferenceWithCustomName(CppQualifiedName name);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.QualifiedUsingEnumDeclarationTargetReference : BaseQualifiedReference {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual CppLookupResult LookupReferenceWithCustomName(CppQualifiedName name);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.RangeBasedCoAwaitForStatement : RangeBasedForStatement {
    private ICppReference myAwaitTransformReference;
    private ICppReference myOperatorCoAwaitReference;
    private ICppReference myAwaitReadyReference;
    private ICppReference myAwaitSuspendReference;
    private ICppReference myAwaitResumeReference;
    private CppCachedValue`1<ResolveResult> myResolveResult;
    public NodeType NodeType { get; }
    public ITokenNode CoAwaitKeyword { get; }
    public RangeBasedCoAwaitForStatement(CppForStatementResolveEntity resolveEntity);
    public virtual NodeType get_NodeType();
    public ITokenNode get_CoAwaitKeyword();
    public virtual ReferenceCollection GetFirstClassReferences();
    public CppCoAwaitResolveResult GetResolveResult();
    public CppDependentInfo GetDependentInfo();
    public virtual CppForStatementKind GetForType();
    private ResolveResult GetCachedResolveResult();
    private ResolveResult Resolve();
    public sealed virtual ITokenNode GetCoKeyword();
    public sealed virtual CppResolveResult ResolveOperatorCoAwait();
    public sealed virtual CppResolveResult ResolveAwaitReady();
    public sealed virtual CppResolveResult ResolveAwaitResume();
    public sealed virtual CppResolveResult ResolveAwaitSuspend();
    public sealed virtual CppResolveResult ResolveAwaitTransform();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.RangeBasedForStatement : RangedForBase {
    private CppForStatementResolveEntity myResolveEntity;
    public NodeType NodeType { get; }
    public ITokenNode ForKeyword { get; }
    public ITokenNode Colon { get; }
    public Declaration ForRangeDeclaration { get; }
    public ICppExpressionOrDeclarationNode InitStatement { get; }
    public RangeBasedForStatement(CppForStatementResolveEntity resolveEntity);
    public virtual NodeType get_NodeType();
    public virtual ITokenNode get_ForKeyword();
    public virtual ITokenNode get_Colon();
    public virtual Declaration get_ForRangeDeclaration();
    public virtual ICppExpressionNode GetRangeInitializer();
    public virtual ICppExpressionOrDeclarationNode get_InitStatement();
    public virtual CppForStatementKind GetForType();
    public virtual ICppScopeResolveEntity GetResolveScope();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
    public CppForStatementResolveEntity GetResolveEntity();
    private void Parse(ICppExpressionOrDeclarationNode& initStatement, Declaration& rangeDeclaration, ICppExpressionNode& rangeInitializer);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.RangeBasedForStatementNavigator : object {
    public static RangeBasedForStatement GetByDeclaration(Declaration declaration);
    public static RangeBasedForStatement GetByForKeyword(ITokenNode child);
    public static RangeBasedForStatement GetByInitializer(ICppExpressionNode child);
    public static RangeBasedForStatement GetByInitStatement(ICppExpressionOrDeclarationNode statement);
    public static RangeBasedForStatement GetByBody(ICppStatement body);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.RangedForBase : CppLoopStatementBase {
    private ICppReference myBeginReference;
    private ICppReference myEndReference;
    private ICppReference myGetEnumeratorReference;
    private ICppReference myCurrentReference;
    private ICppReference myMoveNextReference;
    private ResolveResult myResolveResult;
    public ITokenNode ForKeyword { get; }
    public ITokenNode Colon { get; }
    public Declaration ForRangeDeclaration { get; }
    public ICppExpressionOrDeclarationNode InitStatement { get; }
    public abstract virtual ITokenNode get_ForKeyword();
    public abstract virtual ITokenNode get_Colon();
    public abstract virtual Declaration get_ForRangeDeclaration();
    public abstract virtual ICppExpressionOrDeclarationNode get_InitStatement();
    public abstract virtual ICppExpressionNode GetRangeInitializer();
    public virtual ReferenceCollection GetFirstClassReferences();
    public ResolveResult GetResolveResult();
    public abstract virtual CppForStatementKind GetForType();
    private CppRangeBasedForResolveEngine GetResolveEngine();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.RangedForBaseNavigator : object {
    public static RangedForBase GetByDeclaration(Declaration declaration);
    public static RangedForBase GetByBody(ICppStatement body);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.RangedForBaseUtil : object {
    public static ICppResolvedExpression GetElementInitializer(ICppResolvedExpression rangeInitializer, CppForStatementKind forType, CppTypeContext& tc, ICppFileResolveEntitiesCache fileCache);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.RecoveryJunk : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.RequiresClause : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode RequiresKeyword { get; }
    public ICppExpressionNode Expression { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_RequiresKeyword();
    public ICppExpressionNode get_Expression();
    public sealed virtual CppViewPos GetViewPos();
    private static Nullable`1<CppViewPos> TryGetViewPosOfLambdaRequiresClause(RequiresClause requiresClause);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.RequiresClauseNavigator : object {
    public static RequiresClause GetByExpression(ICppExpressionNode node);
    public static RequiresClause GetByExpressionThoughParens(ICppExpressionNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.RequiresExpression : BaseSymbolNode`1<CppRequiresExpressionSymbol> {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myChildrenAreResolved;
    private CppDependentInfo myDependentInfo;
    public NodeType NodeType { get; }
    public LambdaDeclarator LambdaDeclaratorNode { get; }
    public RequiresExpressionBody BodyNode { get; }
    public RequiresExpression(ICppSymbol symbol);
    public CppRequiresExpressionSymbol GetRequiresSymbol();
    public sealed virtual ICppRequiresExpressionScopeResolveEntity GetScopeResolveEntity();
    public sealed virtual CppList`1<ICppRequiresExpressionItem> GetResolvedItems();
    public virtual NodeType get_NodeType();
    public LambdaDeclarator get_LambdaDeclaratorNode();
    public RequiresExpressionBody get_BodyNode();
    public sealed virtual CppTypeAndCategory GetTypeAndCategory();
    public sealed virtual CppTypeAndCategory GetVerboseTypeAndCategory();
    public sealed virtual CppQualType GetVerboseType();
    public sealed virtual CppDependentInfo GetDependentInfo();
    public sealed virtual TriBool IsNoexcept();
    public sealed virtual CppTypeContext TryGetTypeContext();
    public sealed virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public sealed virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual void MarkChildrenAsResolved();
    public sealed virtual bool ChildrenAreResolved();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.RequiresExpressionBody : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public CppList`1<RequiresExpressionItem> ItemNodes { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_LBrace();
    public ITokenNode get_RBrace();
    public CppList`1<RequiresExpressionItem> get_ItemNodes();
    public sealed virtual ICppScopeResolveEntity GetResolveScope();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.RequiresExpressionBodyNavigator : object {
    public static RequiresExpressionBody GetByItem(RequiresExpressionItem clause);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.RequiresExpressionItem : BaseSymbolNode`1<CppRequiresExpressionItemSymbol> {
    public NodeType NodeType { get; }
    public ITokenNode Typename { get; }
    public ITokenNode Requires { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public ICppExpressionNode ExpressionNode { get; }
    [CanBeNullAttribute]
public ITokenNode DerefNode { get; }
    [CanBeNullAttribute]
public QualifiedConceptReference TypeConstraintNode { get; }
    public RequiresExpressionItem(ICppSymbol symbol);
    public virtual NodeType get_NodeType();
    public CppRequiresExpressionItemResolveEntity GetResolveEntity();
    public ITokenNode get_Typename();
    public ITokenNode get_Requires();
    public ITokenNode get_LBrace();
    public ITokenNode get_RBrace();
    public ICppExpressionNode get_ExpressionNode();
    public ITokenNode get_DerefNode();
    public QualifiedConceptReference get_TypeConstraintNode();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.RequiresExpressionItemNavigator : object {
    public static RequiresExpressionItem GetByExpression(ICppExpressionNode expr);
    public static RequiresExpressionItem GetByReturnTypeConstraint(TypeId type);
    public static RequiresExpressionItem GetByTypeRequirement(QualifiedTypenameReference typeRequirement);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.RequiresExpressionNavigator : object {
    public static RequiresExpression GetByLambdaDeclarator(LambdaDeclarator declarator);
    public static RequiresExpression GetByBody(RequiresExpressionBody body);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ReturnStatement : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode ReturnKeyword { get; }
    public ICppExpressionNode ReturnedValue { get; }
    [CanBeNullAttribute]
public ITokenNode Semicolon { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_ReturnKeyword();
    public ICppExpressionNode get_ReturnedValue();
    public ITokenNode get_Semicolon();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.ReturnStatementNavigator : object {
    public static ReturnStatement GetByReturnedValue(ICppExpressionNode node);
    public static ReturnStatement GetByReturnedValueThoughParens(ICppExpressionNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.SimpleDeclaration : CppCompositeNode {
    private static NodeTypeSet NODE_TYPES;
    public NodeType NodeType { get; }
    public Declaration DeclarationNode { get; }
    [CanBeNullAttribute]
public CtorInitializer ConstructorInitializerNode { get; }
    [CanBeNullAttribute]
public CompoundStatement CompoundStatementNode { get; }
    [CanBeNullAttribute]
public FunctionTryBlock FunctionTryBlockNode { get; }
    [CanBeNullAttribute]
public CtorBlock ConstructorBlock { get; }
    [CanBeNullAttribute]
public ICppDeclarationTrailingNode TrailingNode { get; }
    [CanBeNullAttribute]
public DeleteSpecifier DeleteSpecifierNode { get; }
    [CanBeNullAttribute]
public DefaultSpecifier DefaultSpecifierNode { get; }
    [CanBeNullAttribute]
public ITreeNode SemicolonNode { get; }
    private static SimpleDeclaration();
    public virtual NodeType get_NodeType();
    public Declaration get_DeclarationNode();
    public sealed virtual CtorInitializer get_ConstructorInitializerNode();
    public CompoundStatement get_CompoundStatementNode();
    public FunctionTryBlock get_FunctionTryBlockNode();
    public CtorBlock get_ConstructorBlock();
    public ICppDeclarationTrailingNode get_TrailingNode();
    public DeleteSpecifier get_DeleteSpecifierNode();
    public DefaultSpecifier get_DefaultSpecifierNode();
    public ITreeNode get_SemicolonNode();
    public bool CanAddMemInitializerAfter(MemInitializer anchor, MemInitializer memInit);
    public MemInitializer AddMemInitializerAfter(MemInitializer anchor, MemInitializer memInit);
    public bool CanAddMemInitializerBefore(MemInitializer anchor, MemInitializer memInit);
    public MemInitializer AddMemInitializerBefore(MemInitializer anchor, MemInitializer memInit);
    public bool CanAddCtorInitializer(CtorInitializer ctorInit);
    public CtorInitializer AddCtorInitializer(CtorInitializer ctorInit);
    public bool CanAddCtorBlock(CtorBlock ctorBlock);
    public CtorBlock AddCtorBlock(CtorBlock ctorBlock);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.SimpleDeclarationNavigator : object {
    public static SimpleDeclaration GetByCtorInitializer(CtorInitializer initializer);
    public static SimpleDeclaration GetByCompoundStatement(CompoundStatement statement);
    public static SimpleDeclaration GetByCompoundStatementThroughTrailingNodes(CompoundStatement statement);
    public static SimpleDeclaration GetByFunctionTryBlock(FunctionTryBlock tryBlock);
    public static SimpleDeclaration GetByDeclaration(Declaration declaration);
    public static SimpleDeclaration GetByDeclarator(ICppNonNestedDeclaratorNode declarator);
    public static SimpleDeclaration GetByTrailingNode(ICppDeclarationTrailingNode node);
    public static SimpleDeclaration GetByConstructorBlock(CtorBlock node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.SimpleGenericConstraintItem : CppCompositeNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.SingleArgumentTypeTraitExpression : BooleanExpressionNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public TypeId GetTypeId();
    public ITokenNode GetKeyword();
    public sealed virtual CppQualType GetArgument();
    public sealed virtual CppSingleArgumentTypeTraitKind GetKind();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.SizeOfEllipsisExpression : CppExpressionNodeWithCachedDepInfo {
    private ICppReference myReference;
    public NodeType NodeType { get; }
    public CppQualifiedName Operand { get; }
    public ITreeNode Identifier { get; }
    public virtual NodeType get_NodeType();
    public CppQualifiedName get_Operand();
    public ITreeNode get_Identifier();
    public sealed virtual CppQualifiedName GetArgument();
    public sealed virtual CppResolveResult GetResolvedArgument();
    public sealed virtual CppViewPos GetViewPos();
    public virtual ReferenceCollection GetFirstClassReferences();
    public ICppReference GetReference();
    public sealed virtual CppTreeElementRange GetNameTokenRange();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.SizeOfExpression : CppExpressionNodeWithCachedDepInfo {
    public NodeType NodeType { get; }
    public ICppTypeIdOrExpressionNode Operand { get; }
    public virtual NodeType get_NodeType();
    public ICppTypeIdOrExpressionNode get_Operand();
    public sealed virtual ICppTypeIdOrExpression GetArgument();
    public sealed virtual CppViewPos GetViewPos();
    public virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public virtual TResult Accept(ICppExpressionNodeVisitor`1<TResult> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.SizeOfExpressionNavigator : object {
    public static SizeOfExpression GetByOperand(ICppTypeIdOrExpressionNode op);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.StaticAssertDeclaration : CppCompositeNode {
    public ICppExpressionNode ConstantExpression { get; }
    public CppList`1<ITokenNode> StringLiteral { get; }
    [CanBeNullAttribute]
public ITokenNode Semicolon { get; }
    public NodeType NodeType { get; }
    public ICppExpressionNode get_ConstantExpression();
    public CppList`1<ITokenNode> get_StringLiteral();
    public ITokenNode get_Semicolon();
    public virtual NodeType get_NodeType();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.StaticAssertDeclarationNavigator : object {
    [CanBeNullAttribute]
public static StaticAssertDeclaration GetByConstantExpression(ICppExpressionNode node);
    [CanBeNullAttribute]
public static StaticAssertDeclaration GetByConstantExpressionThroughParens(ICppExpressionNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.StructuredBindingIdentifier : BaseNamedSymbolNode`1<CppStructuredBindingSymbol> {
    public ITokenNode Name { get; }
    public NodeType NodeType { get; }
    public StructuredBindingIdentifier(CppStructuredBindingSymbol symbol);
    public ITokenNode get_Name();
    public virtual NodeType get_NodeType();
    public sealed virtual CppViewPos GetViewPos();
    public virtual CppTreeElementRange GetNameTokenRange();
    public CppStructuredBindingResolveEntity GetResolveEntity();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.StructuredBindingIdentifierList : CppCompositeNode {
    public NodeType NodeType { get; }
    public CppList`1<StructuredBindingIdentifier> IdentifierNodes { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public virtual NodeType get_NodeType();
    public CppList`1<StructuredBindingIdentifier> get_IdentifierNodes();
    public ITokenNode get_LBracket();
    public ITokenNode get_RBracket();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.StructuredBindingIdentifierListNavigator : object {
    public static StructuredBindingIdentifierList GetByIdentifier(StructuredBindingIdentifier identifier);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.SubscriptDesignator : BaseDesignatorNode {
    public NodeType NodeType { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public ICppExpressionNode Index { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_LBracket();
    public ITokenNode get_RBracket();
    public ICppExpressionNode get_Index();
    public sealed virtual ICppExpression GetIndex();
    public sealed virtual ICppResolvedExpression GetResolvedIndex();
    public virtual TResult Accept(ICppDesignatorVisitor`1<TResult> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.SubscriptExpression : CppExpressionNodeWithCachedDepInfo {
    private SubscriptOperatorReference myReference;
    public NodeType NodeType { get; }
    public ICppExpressionNode LeftSideExpr { get; }
    public ICppExpressionNode RightSideExpression { get; }
    public CppSmallList`1<ICppExpressionNode> RightSideExpressions { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public ICppReference FirstClassRef { get; }
    public virtual NodeType get_NodeType();
    public sealed virtual ICppExpressionNode get_LeftSideExpr();
    public ICppExpressionNode get_RightSideExpression();
    public CppSmallList`1<ICppExpressionNode> get_RightSideExpressions();
    public sealed virtual int GetIndexArgumentCount();
    public sealed virtual ITokenNode get_LBracket();
    public sealed virtual ITokenNode get_RBracket();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual ICppExpression GetLeftArgument();
    public sealed virtual CppSmallArray`1<ICppExpression> GetIndexArguments();
    public sealed virtual ICppResolvedExpression GetResolvedLeftArgument();
    public sealed virtual CppResolveResult GetResolvedOperator();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    public ICppReference get_FirstClassRef();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.SubscriptExpressionNavigator : object {
    public static SubscriptExpression GetByLBracket(ITokenNode node);
    public static SubscriptExpression GetByRBracket(ITokenNode node);
    public static SubscriptExpression GetByLeftArgument(ICppExpressionNode node);
    public static SubscriptExpression GetByLeftArgumentThroughParens(ICppExpressionNode node);
    public static SubscriptExpression GetByRightArgument(ICppExpressionNode node);
    public static SubscriptExpression GetByArgument(ICppExpressionNode node);
    public static ICppAnySubscriptExpressionNode GetAnyByLeftArgument(ICppExpressionNode node);
    public static ICppAnySubscriptExpressionNode GetAnyByLeftArgumentThroughParens(ICppExpressionNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.SwitchStatement : CppCompositeNode {
    private CppSwitchStatementResolveEntity myResolveEntity;
    public NodeType NodeType { get; }
    public ITokenNode SwitchKeyword { get; }
    public ICppExpressionOrDeclarationOrAliasDeclarationNode InitStatementNode { get; }
    [CanBeNullAttribute]
public ICppExpressionOrDeclarationNode SwitchExpressionNode { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ICppStatement StatementNode { get; }
    public SwitchStatement(CppSwitchStatementResolveEntity resolveEntity);
    public virtual NodeType get_NodeType();
    public ITokenNode get_SwitchKeyword();
    public ICppExpressionOrDeclarationOrAliasDeclarationNode get_InitStatementNode();
    public ICppExpressionOrDeclarationNode get_SwitchExpressionNode();
    public ITokenNode get_LPar();
    public ITokenNode get_RPar();
    public ICppStatement get_StatementNode();
    public IList`1<CaseStatement> GetCaseStatementNodes();
    public IList`1<DefaultStatement> GetDefaultStatementNodes();
    public IList`1<ICppCaseOrDefaultStatement> GetCaseAndDefaultStatements();
    private IList`1<T> CollectCaseAndDefaultStatements();
    public sealed virtual ICppScopeResolveEntity GetResolveScope();
    private void ParseHeader(ICppExpressionOrDeclarationOrAliasDeclarationNode& init, ICppExpressionOrDeclarationNode& cond);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.SwitchStatementNavigator : object {
    public static SwitchStatement GetBySwitchKeyword(ITokenNode child);
    public static SwitchStatement GetByInitStatement(ICppExpressionOrDeclarationNode init);
    public static SwitchStatement GetBySwitchExpression(ICppExpressionOrDeclarationNode expr);
    public static SwitchStatement GetByCaseStatement(CaseStatement stmt);
    public static SwitchStatement GetByStatement(ICppStatement stmt);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.TemplateArgumentList : CppCompositeNode {
    private static NodeTypeSet ArgumentNodeTypeSet;
    public NodeType NodeType { get; }
    public CppList`1<ICppTypeIdOrExpressionNode> Arguments { get; }
    public CppList`1<ITokenNode> Commas { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public ICppTypeIdOrExpressionNode LastArgument { get; }
    private static TemplateArgumentList();
    public virtual NodeType get_NodeType();
    public CppList`1<ICppTypeIdOrExpressionNode> get_Arguments();
    public CppList`1<ITokenNode> get_Commas();
    public ITokenNode get_LBracket();
    public ITokenNode get_RBracket();
    public int GetArgumentsCount();
    public ICppTypeIdOrExpressionNode GetArgument(int index);
    public ICppTypeIdOrExpressionNode get_LastArgument();
    public int IndexOf(ICppTypeIdOrExpressionNode arg);
    public IDeclarationName GetDeclarationName();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    public sealed virtual TResult Accept(ICppConversionProvidingNodeVisitor`1<TResult> visitor);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.TemplateArgumentListNavigator : object {
    public static TemplateArgumentList GetByArgument(ICppTypeIdOrExpressionNode arg);
    public static TemplateArgumentList GetByArgumentThoughParens(ICppTypeIdOrExpressionNode arg);
    public static TemplateArgumentList GetByLBracket(ITokenNode token);
    public static TemplateArgumentList GetByRBracket(ITokenNode token);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.TemplateDeclaration : CppCompositeNode {
    private List`1<CppTemplateParametersBase> myTemplateParameters;
    public NodeType NodeType { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    [CanBeNullAttribute]
public ITokenNode TemplateKeyword { get; }
    [CanBeNullAttribute]
public ITokenNode GenericKeyword { get; }
    [CanBeNullAttribute]
public RequiresClause RequiresClauseNode { get; }
    public ICppTopLevelDeclarationNode InnerDeclaration { get; }
    public ICppTopLevelDeclarationNode InnermostDeclaration { get; }
    public CppList`1<ICppTemplateParameterNode> TemplateParameters { get; }
    public CppList`1<GenericConstraint> GenericConstraints { get; }
    public TemplateDeclaration(List`1<CppTemplateParametersBase> params);
    public virtual NodeType get_NodeType();
    public ITokenNode get_LBracket();
    public ITokenNode get_RBracket();
    public ITokenNode get_TemplateKeyword();
    public ITokenNode get_GenericKeyword();
    public RequiresClause get_RequiresClauseNode();
    public ICppTopLevelDeclarationNode get_InnerDeclaration();
    public ICppTopLevelDeclarationNode get_InnermostDeclaration();
    public CppList`1<ICppTemplateParameterNode> get_TemplateParameters();
    public CppList`1<GenericConstraint> get_GenericConstraints();
    public ICppTopLevelDeclarationNode GetInnermostDeclaration(Int32& depth);
    public List`1<CppTemplateParametersBase> GetTemplateParameters();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.TemplateDeclarationNavigator : object {
    public static TemplateDeclaration GetByTemplateParameter(ICppTemplateParameterNode param);
    public static TemplateDeclaration GetByInnerDeclaration(ICppTopLevelDeclarationNode decl);
    public static TemplateDeclaration GetByInnerDeclarationThoughTemplateDeclarations(ICppTopLevelDeclarationNode decl);
    public static TemplateDeclaration GetByGenericConstraint(GenericConstraint constraint);
    public static TemplateDeclaration GetByRequiresClause(RequiresClause clause);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.TemplateTemplateParameter : BaseNamedSymbolNode`1<ICppTemplateParameterSymbol> {
    public ITreeNode Identifier { get; }
    public ITreeNode TemplateKeyword { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public ITreeNode ClassKeyword { get; }
    public CppList`1<ICppTemplateParameterNode> TemplateParameters { get; }
    public NodeType NodeType { get; }
    public TemplateTemplateParameter(ICppSymbol sym);
    public ITreeNode get_Identifier();
    public ITreeNode get_TemplateKeyword();
    public ITokenNode get_LBracket();
    public ITokenNode get_RBracket();
    public ITreeNode get_ClassKeyword();
    public CppList`1<ICppTemplateParameterNode> get_TemplateParameters();
    public sealed virtual ICppTemplateParameter GetResolveEntity();
    public sealed virtual ITreeNode GetNameNode();
    public virtual NodeType get_NodeType();
    public sealed virtual CppViewPos GetViewPos();
    public ICppTemplateParameterForPsi GetResolveEntityForPsi();
    public virtual CppTreeElementRange GetNameTokenRange();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ThisExpression : CppExpressionNodeWithCachedDepInfo {
    public NodeType NodeType { get; }
    public ITokenNode Token { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_Token();
    public sealed virtual CppQualType GetThisObjectType();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.ThrowExpression : CppExpressionNode {
    public NodeType NodeType { get; }
    public ITokenNode ThrowKeyword { get; }
    public ICppExpressionNode Argument { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_ThrowKeyword();
    public ICppExpressionNode get_Argument();
    public sealed virtual ICppExpression GetArgument();
    public virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public virtual CppDependentInfo GetDependentInfo();
    public virtual TResult Accept(ICppExpressionNodeVisitor`1<TResult> visitor);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.ThrowExpressionNavigator : object {
    public static ThrowExpression GetByThrowKeyword(ITokenNode child);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.TrailingReturnType : CppCompositeNode {
    public NodeType NodeType { get; }
    public ITokenNode DerefNode { get; }
    public TypeId TypeIdNode { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_DerefNode();
    public TypeId get_TypeIdNode();
    public sealed virtual CppViewPos GetViewPos();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.TryStatement : CppCompositeNode {
    private static NodeTypeSet ourTypeKeywords;
    public NodeType NodeType { get; }
    public ITokenNode TryKeyword { get; }
    public CppList`1<CatchSection> CatchSections { get; }
    public CompoundStatement Body { get; }
    private static TryStatement();
    public virtual NodeType get_NodeType();
    public ITokenNode get_TryKeyword();
    public CppList`1<CatchSection> get_CatchSections();
    public CompoundStatement get_Body();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.TryStatementNavigator : object {
    public static TryStatement GetByTryStatement(CompoundStatement statement);
    public static TryStatement GetByCatchSection(CatchSection catchSection);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.TypeId : BaseDeclaration {
    public NodeType NodeType { get; }
    public AbstractDeclarator TypeIdDeclarator { get; }
    public virtual NodeType get_NodeType();
    public AbstractDeclarator get_TypeIdDeclarator();
    public CppQualType CalculateUnresolvedType();
    public CppQualType CalculateUnresolvedType(CppTypeSelection selection);
    public sealed virtual CppQualType GetQualType();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.TypeIdExpression : CppExpressionNodeWithCachedDepInfo {
    public NodeType NodeType { get; }
    public ICppTypeIdOrExpressionNode Argument { get; }
    public virtual NodeType get_NodeType();
    public ICppTypeIdOrExpressionNode get_Argument();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual ICppTypeIdOrExpression GetArgument();
    public virtual TResult Accept(ICppExpressionVisitor`1<TResult> visitor);
    public virtual TResult Accept(ICppExpressionNodeVisitor`1<TResult> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.TypeIdExpressionNavigator : object {
    public static TypeIdExpression GetByArgument(ICppTypeIdOrExpressionNode arg);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.TypeIdNavigator : object {
    public static TypeId GetByDeclarator(ICppNonNestedDeclaratorNode declarator);
    public static TypeId GetByDeclarationSpecifiers(DeclarationSpecifiers specifiers);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.TypeParameter : BaseNamedSymbolNode`1<ICppTemplateParameterSymbol> {
    public ITreeNode TypenameSpecifier { get; }
    public ITreeNode Identifier { get; }
    public NodeType NodeType { get; }
    public TypeParameter(ICppSymbol sym);
    public ITreeNode get_TypenameSpecifier();
    public ITreeNode get_Identifier();
    public sealed virtual ICppTemplateParameter GetResolveEntity();
    public sealed virtual ITreeNode GetNameNode();
    public virtual NodeType get_NodeType();
    public sealed virtual CppViewPos GetViewPos();
    public ICppTemplateParameterForPsi GetResolveEntityForPsi();
    public virtual CppTreeElementRange GetNameTokenRange();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.UnaryExpression : CppExpressionNodeWithCachedDepInfo {
    private UnaryOperatorReference myReference;
    public NodeType NodeType { get; }
    public ITokenNode Operator { get; }
    public ICppExpressionNode Operand { get; }
    public ICppReference FirstClassRef { get; }
    public virtual NodeType get_NodeType();
    public ITokenNode get_Operator();
    public ICppExpressionNode get_Operand();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual ICppExpression GetArgument();
    public sealed virtual ICppResolvedExpression GetResolvedArgument();
    public sealed virtual CppOperatorKind GetOperatorKind();
    public sealed virtual CppViewPos GetViewPos();
    public sealed virtual CppResolveResult GetResolvedOperator();
    public virtual TriBool IsNoexcept();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    public virtual void DropReferences();
    public ICppReference get_FirstClassRef();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
    protected virtual CppDependentInfo CalculateDependentInfo();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.UnaryExpressionNavigator : object {
    public static UnaryExpression GetByOperator(ITokenNode op);
    public static UnaryExpression GetByOperand(ICppExpressionNode expr);
    public static UnaryExpression GetByOperandThroughParens(ICppExpressionNode expr);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.UserDefinedLiteralExpression : CppExpressionNode {
    private Reference myReference;
    private CppCachedValue`1<CppResolveResult> myResolvedOperator;
    private ICppUserDefinedLiteralExpression myDecodedExpression;
    public NodeType NodeType { get; }
    public ITreeNode Literal { get; }
    public DocumentRange GetSuffixDocumentRange();
    public DocumentRange GetSuffixDocumentRangeWithMacroCalls();
    public virtual NodeType get_NodeType();
    public ITreeNode get_Literal();
    public sealed virtual ICppUserDefinedLiteralValue GetLiteralValue();
    public sealed virtual string GetSuffix();
    public sealed virtual CppResolveResult GetResolvedOperator();
    public sealed virtual CppViewPos GetViewPos();
    public virtual CppDependentInfo GetDependentInfo();
    public ICppReference GetReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    private ICppUserDefinedLiteralExpression GetDecodedExpression();
    public virtual Result Accept(ICppExpressionNodeVisitor`1<Result> visitor);
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    private static ICppUserDefinedLiteralExpression CalculateDecodedExpression(UserDefinedLiteralExpression ref);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.UserDefinedLiteralExpressionNavigator : object {
    [CanBeNullAttribute]
public static UserDefinedLiteralExpression GetByLiteral(ITreeNode literal);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.UsingDeclaration : CppCompositeNode {
    public NodeType NodeType { get; }
    public CppList`1<UsingDeclarator> UsingDeclarators { get; }
    [CanBeNullAttribute]
public ITokenNode SemicolonNode { get; }
    public virtual NodeType get_NodeType();
    public CppList`1<UsingDeclarator> get_UsingDeclarators();
    public ITokenNode get_SemicolonNode();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.UsingDeclarationNavigator : object {
    [CanBeNullAttribute]
public static UsingDeclaration GetByDeclarator(UsingDeclarator decl);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.UsingDeclarator : BaseSymbolNode`1<CppUsingDeclarationSymbol> {
    public NodeType NodeType { get; }
    public QualifiedUsingDeclarationTargetReference TargetReference { get; }
    public IDeclaredElement DeclaredElement { get; }
    public string DeclaredName { get; }
    public UsingDeclarator(ICppSymbol symbol);
    public virtual NodeType get_NodeType();
    public sealed virtual CppViewPos GetViewPos();
    public CppUsingDeclarationResolveEntity GetResolveEntity();
    public QualifiedUsingDeclarationTargetReference get_TargetReference();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual bool IsSynthetic();
    public sealed virtual IDeclaredElement get_DeclaredElement();
    public sealed virtual string get_DeclaredName();
    public sealed virtual void SetName(string name);
    public sealed virtual TreeTextRange GetNameRange();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.UsingDeclaratorNavigator : object {
    public static UsingDeclarator GetByTargetReference(BaseQualifiedReference ref);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.UsingDirective : BaseSymbolNode`1<CppUsingDirectiveSymbol> {
    public NodeType NodeType { get; }
    public QualifiedNamespaceReference NamespaceReference { get; }
    public UsingDirective(ICppSymbol sym);
    public virtual NodeType get_NodeType();
    public QualifiedNamespaceReference get_NamespaceReference();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.UsingDirectiveNavigator : object {
    public static UsingDirective GetByNamespaceReference(QualifiedNamespaceReference ref);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.UsingEnumDeclaration : BaseSymbolNode`1<CppUsingEnumDeclarationSymbol> {
    private ICppClassResolveEntity myTargetEnum;
    private CppViewPos myViewPos;
    public NodeType NodeType { get; }
    public QualifiedUsingEnumDeclarationTargetReference TargetReference { get; }
    public ICppClassResolveEntity TargetEnum { get; }
    public UsingEnumDeclaration(CppUsingEnumDeclarationData data);
    public virtual NodeType get_NodeType();
    public QualifiedUsingEnumDeclarationTargetReference get_TargetReference();
    public ICppClassResolveEntity get_TargetEnum();
    public sealed virtual CppViewPos GetViewPos();
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.Util.CppPathUtil : object {
    public static string ExtractPathText(ITreeNode node);
    public static string ExtractPathText(string text);
    public static int ExtractPathOffset(ITreeNode node);
    public static int ExtractPathOffset(string text);
    public static IEnumerable`1<VirtualFileSystemPath> ResolvePath(CppInclusionContext context, bool angleBracket, string pathSpec, bool folder);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Tree.Util.CppPathUtil/<ResolvePath>d__5")]
public static IEnumerable`1<VirtualFileSystemPath> ResolvePath(CppInclusionContext context, bool angleBracket, bool isIncludeNext, string pathSpec, bool folder);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Tree.Util.CppPathUtil/<ResolvePathEx>d__6")]
public static IEnumerable`1<CppIncludePathWithSearchPath> ResolvePathEx(CppInclusionContext context, bool angleBracket, bool isIncludeNext, string pathSpec, bool folder);
    private static FrugalLocalList`1<CppIncludePathWithSearchPath> ResolvePathCandidates(CppInclusionContext context, bool angleBracket, bool isIncludeNext, string pathSpec, bool folder);
    public static IEnumerable`1<VirtualFileSystemPath> TryResolveSearchPaths(CppInclusionContext context, bool angleBracket, string pathSpec, bool folder);
    public static IEnumerable`1<VirtualFileSystemPath> TryResolveSearchPaths(CppInclusionContext context, bool angleBracket, bool isIncludeNext, string pathSpec, bool folder);
    public static IEnumerable`1<VirtualFileSystemPath> CombineSearchPaths(IEnumerable`1<VirtualFileSystemPath> fileSearchPaths, IEnumerable`1<VirtualFileSystemPath> projectSearchPaths);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Tree.Util.CppPsiVisitorUtil : object {
    [ExtensionAttribute]
public static void Visit(ICppPsiVisitor visitor, ITreeNode node, bool dumpPreprocessed);
    [ExtensionAttribute]
public static void Visit(ICppPsiVisitor visitor, CppTreeElementRange range, bool dumpPreprocessed);
    private static IRecursiveElementProcessor CreateElementProcessor(bool dumpPreprocessed, ICppPsiVisitor visitor);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Tree.Util.CppQualRefEntities : Enum {
    public int value__;
    public static CppQualRefEntities None;
    public static CppQualRefEntities Value;
    public static CppQualRefEntities Type;
    public static CppQualRefEntities Namespace;
    public static CppQualRefEntities ClassTemplate;
    public static CppQualRefEntities All;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Tree.Util.CppSandBox : object {
    [ExtensionAttribute]
public static void SandBox(ITreeNode node, IPsiModule module);
    public static void RawSandBoxFor(ITreeNode node, IPsiModule module);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.Util.CppStringLiteralNodesBuilder : CppStringPartsBuilderBase {
    public CppList`1<ITokenNode> Nodes;
    protected virtual void StartLPrefix();
    protected virtual void AddNode(ITokenNode element);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.Util.CppStringPartsBuilder : CppStringPartsBuilderBase {
    private CppStringLiteralBuilder myBuilder;
    private CppViewPos myViewPos;
    public CppStringPartsBuilder(CppViewPos& vp);
    public FrugalLocalList`1<string> GetParts();
    public string GetUserDefinedSuffix();
    protected virtual void StartLPrefix();
    protected virtual void AddNode(ITokenNode token);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Tree.Util.CppStringPartsBuilderBase : object {
    public bool ProcessingIsFinished { get; }
    public virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public virtual bool get_ProcessingIsFinished();
    public virtual void ProcessBeforeInterior(ITreeNode element);
    public virtual void ProcessAfterInterior(ITreeNode element);
    protected abstract virtual void StartLPrefix();
    protected abstract virtual void AddNode(ITokenNode element);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Tree.Util.CppTreeNodeExtensions : object {
    private static Predicate`1<ITreeNode> PHANTOM_COMPOSITE_CHECKER;
    private static CppTreeNodeExtensions();
    private static bool IsPhantom(ITreeNode node);
    [ExtensionAttribute]
public static string GetNodeText(ITreeNode node);
    [ExtensionAttribute]
public static string GetTokenNodeText(ITokenNode node);
    [ExtensionAttribute]
public static void GetTokenNodeText(ITokenNode node, StringBuilder out);
    [ExtensionAttribute]
public static int GetTokenNodeTextLength(ITokenNode node);
    [ExtensionAttribute]
public static TreeTextRange GetTreeTextRangeWithMapping(ITreeNode node);
    [ExtensionAttribute]
public static TreeTextRange GetTreeTextRangeWithMacroCalls(ITreeNode node);
    [ExtensionAttribute]
public static ITreeNode SafeParent(ITreeNode node);
    [ExtensionAttribute]
public static T FindNextSiblingByType(ITreeNode node, int siblingIndex);
    [ExtensionAttribute]
public static T FindNextSiblingByType(ITreeNode node, NodeTypeSet typeSet, int siblingIndex);
    [ExtensionAttribute]
public static T FindPrevSiblingByType(ITreeNode node, int siblingIndex);
    [ExtensionAttribute]
public static T FindPrevSiblingByType(ITreeNode node, NodeTypeSet typeSet, int siblingIndex);
    [ExtensionAttribute]
public static T FindLastSiblingByType(ITreeNode node, NodeTypeSet typeSet);
    [ExtensionAttribute]
public static T FindPrevSiblingOfAnyTypeExcept(ITreeNode node, NodeTypeSet typeSet, int siblingIndex);
    [ExtensionAttribute]
public static LazyTokenView Tokens(ITreeNode node);
    [ExtensionAttribute]
public static LazyTokenView Tokens(CppTreeElementRange treeRange);
    [ExtensionAttribute]
public static ITreeNode FindNonRootEmbracingParentWithSameTokenRange(ITreeNode node);
    [ExtensionAttribute]
public static ITreeNode FindNonRootEmbracingParentWithSameTokenRange(ITreeNode node, NodeType parentNodeType);
    public static ITreeNode FindCommonParent(ITreeNode one, ITreeNode other);
    public static ITreeNode FindCommonParent(ITreeNode one, ITreeNode other);
    [ExtensionAttribute]
public static ITreeNode FindCommonParent(CppTreeElementRange treeRange);
    [ExtensionAttribute]
public static bool IsWhitespace(CppTreeElementRange range);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<ITreeNode> FindNodesAt(ITreeNode node, CppComplexOffset offset);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<ITreeNode> FindNodesAt(ITreeNode node, TreeOffset offset);
    [ExtensionAttribute]
public static ITreeNode FindNodeAt(ITreeNode node, CppTreeTextRange range);
    [ExtensionAttribute]
public static CppComplexOffset GetComplexOffset(ITreeNode node);
    [ExtensionAttribute]
public static CppTreeTextRange GetTreeTextRange(ITreeNode node);
    [ExtensionAttribute]
public static CppTreeElementRange GetEmbracingPPRegion(CppTreeElementRange treeRange);
    [ExtensionAttribute]
public static ITreeNode GetNextSiblingThroughMacros(ITreeNode parent, ITreeNode treeNode);
    [ExtensionAttribute]
public static ITreeNode GetNextSiblingThroughMacros(ITreeNode treeNode);
    [ExtensionAttribute]
public static ITreeNode GetNextSiblingThroughMacrosDontSkipComments(ITreeNode parent, ITreeNode treeNode);
    [ExtensionAttribute]
public static ITreeNode GetNextSiblingThroughMacrosDontSkipComments(ITreeNode treeNode);
    [ExtensionAttribute]
public static ITreeNode GetNextSiblingThroughMacrosDontSkipCommentsAndNewLines(ITreeNode treeNode);
    [ExtensionAttribute]
public static ITokenNode GetNextTokenThroughMacros(ITreeNode treeNode, bool includeThis);
    [ExtensionAttribute]
public static ITokenNode GetNextTokenThroughWhitespaces(ITreeNode treeNode, bool includeThis);
    [ExtensionAttribute]
public static ITokenNode GetNextTokenThroughWhitespacesAndComments(ITreeNode treeNode, bool includeThis);
    [ExtensionAttribute]
public static ITreeNode GetPreviousSiblingThroughMacros(ITreeNode parent, ITreeNode treeNode);
    [ExtensionAttribute]
public static ITreeNode GetPreviousSiblingThroughMacros(ITreeNode treeNode);
    [ExtensionAttribute]
public static ITokenNode GetPreviousTokenThroughMacros(ITreeNode treeNode, bool includeThis);
    [ExtensionAttribute]
public static ITreeNode GetPreviousSiblingThroughMacrosDontSkipComments(ITreeNode treeNode);
    [ExtensionAttribute]
public static ITreeNode GetPreviousSiblingThroughMacrosDontSkipCommentsAndNewLines(ITreeNode treeNode);
    [ExtensionAttribute]
public static ITokenNode GetPreviousTokenThroughWhitespaces(ITreeNode treeNode, bool includeThis);
    [ExtensionAttribute]
public static ITokenNode GetPreviousTokenThroughWhitespacesAndComments(ITreeNode treeNode, bool includeThis);
    public static ITokenNode GetNextToken(ITreeNode treeNode);
    public static ITokenNode GetPreviousToken(ITreeNode treeNode);
    [ExtensionAttribute]
public static ITreeNode GetContextNode(ITreeNode treeNode);
    private static ITreeNode GetPreviousSiblingThroughMacrosImpl(ITreeNode parent, ITreeNode treeNode, bool skipComments, bool skipNewLines);
    private static ITreeNode GetNextSiblingThroughMacrosImpl(ITreeNode parent, ITreeNode treeNode, bool skipComments, bool skipNewLines);
    private static int FindNodesAtImpl(ITreeNode node, int relativeOffset, List`1<ITreeNode> result);
    private static int FindNodesAtImpl(ITreeNode node, int relativeTextOffset, int offsetInSubstitution, List`1<ITreeNode> result);
    private static T FindNextSiblingByTypeImpl(ITreeNode node, NodeTypeSet typeSet, int siblingIndex);
    public static T FindPrevSiblingByTypeImpl(ITreeNode node, NodeTypeSet typeSet, int siblingIndex);
    public static CppTreeElementRange FindEmbracingPPRegion(CppTreeElementRange treeRange);
    public static ITokenNode GetNextTokenThroughInternal(NodeTypeSet nodeTypeSet, ITreeNode node, bool includeThis);
    public static ITokenNode GetPreviousTokenThroughInternal(NodeTypeSet nodeTypeSet, ITreeNode node, bool includeThis);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Tree.Util.CppTreeUtil : object {
    [ExtensionAttribute]
public static ITreeNode FindContainingChildOf(ITreeNode source, ITreeNode parent);
    [ExtensionAttribute]
public static ITreeRange FindCommentRangeBefore(ITreeRange range);
    [ExtensionAttribute]
public static ITreeRange FindCommentRangeAfter(ITreeRange range);
    [ExtensionAttribute]
public static ITreeRange FindCommentRangeBefore(ITreeNode anchor);
    [ExtensionAttribute]
public static ITreeRange FindCommentRangeAfter(ITreeNode anchor);
    [ExtensionAttribute]
public static TriBool IsPreComment(ITreeNode comment);
    [ExtensionAttribute]
public static bool CanBindCommentTo(ITreeNode node);
    [ExtensionAttribute]
public static bool IsCommentRange(CppTreeElementRange range, bool allowWhitespaces);
    [ExtensionAttribute]
public static CppQualRefEntities FindExpectedEntities(BaseQualifiedReference ref, Boolean& templateAllowedIfLanguageHadCTAD);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller TryGetOverloadContextByPsiNode(ICppConversionProvidingNode node);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller TryGetOverloadContextByArgList(ICppExpressionsArgumentListNode argList);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller TryGetOverloadContext(CallExpression call);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller TryGetOverloadContext(BraceInitializedTemporary bracedCall);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller TryGetOverloadContext(InitDeclarator initDecl);
    private static CppOverloadContextWithCaller GetOverloadContext(InitDeclarator initDecl, ICppExpressionsArgumentListNode argList);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller TryGetOverloadContext(NewExpression newExpr);
    private static CppOverloadContextWithCaller GetOverloadContext(NewExpression newExpr, ICppExpressionsArgumentListNode argList);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller TryGetOverloadContext(MemInitializer memInitializer);
    private static CppOverloadContextWithCaller GetOverloadContext(MemInitializer memInitializer, ICppExpressionsArgumentListNode argList);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller TryGetOverloadContext(BinaryExpression binExpr);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller TryGetOverloadContext(UnaryExpression unExpr);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller TryGetOverloadContext(PostfixExpression postfixExpr);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller TryGetOverloadContext(SubscriptExpression subscriptExpr);
    [ExtensionAttribute]
public static CppOverloadContextWithCaller TryGetOverloadContext(CliMultiArgumentSubscriptExpression expr);
    [ExtensionAttribute]
public static ICppExpressionNode GetInitializerByArgumentList(ICppExpressionsArgumentListNode argList);
    [ExtensionAttribute]
public static ICppFunctionDeclaratorResolveEntity GetEnclosingFunction(ITreeNode node);
    public static CppQualType GetVerboseReturnTypeOfEnclosingFunction(CppViewPos& viewPos);
    [ExtensionAttribute]
public static CppQualType GetVerboseReturnTypeOfEnclosingFunction(ICppCompositeNode node);
    [ExtensionAttribute]
public static CppQualType GetReturnTypeOfEnclosingFunction(CppViewPos& viewPos);
    [ExtensionAttribute]
public static CppQualType GetReturnTypeOfEnclosingFunction(CppViewPos& viewPos, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType GetReturnTypeOfEnclosingFunction(ICppCompositeNode node);
    private static CppQualType GetReturnTypeOfEnclosingFunctionImpl(CppViewPos& viewPos, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static ITreeNode FindNextAnchorSkippingComment(ITreeNode anchor);
    [ExtensionAttribute]
public static ITreeNode FindPrevAnchorSkippingComment(ITreeNode anchor);
    [ExtensionAttribute]
public static ICppStatement GetParentStatement(ICppStatement statement);
    [ExtensionAttribute]
public static ICppStatement FindContainingStatement(ITreeNode node, NodeTypeSet nt);
    [ExtensionAttribute]
public static ICppStatement GetBreakLoopOrSwitch(BreakStatement stmt);
    [ExtensionAttribute]
public static ICppStatement GetContinueLoop(ContinueStatement stmt);
    [ExtensionAttribute]
public static SwitchStatement GetDefaultSwitch(DefaultStatement stmt);
    [ExtensionAttribute]
public static SwitchStatement GetCaseSwitch(CaseStatement stmt);
    [ExtensionAttribute]
public static ICppDeclarationOwner FindContainingDeclarationOwner(ITreeNode node, CppDeclarationOwnerKind includeOnly, bool returnCurrent);
    [ExtensionAttribute]
public static ICppCompositeNode FindContainingDeclarationOwnerChild(ICppCompositeNode node, CppDeclarationOwnerKind ownerKind);
    [ExtensionAttribute]
public static ICppFunctionDeclaratorResolveEntity GetFunctionDeclarationResolveEntity(ICppTopLevelDeclarationNode funcDecl);
    [ExtensionAttribute]
public static bool IsFunctionDeclarationWithTrailingNode(SimpleDeclaration decl);
    [ExtensionAttribute]
public static CompoundStatement GetStatementInsideTrailingNode(ICppDeclarationTrailingNode trailingNode);
    [ExtensionAttribute]
public static SimpleDeclaration FindNamedOwningCallable(ITreeNode node);
    [ExtensionAttribute]
public static CppFunctionDeclaration FindContainingFunctionDeclaration(ITreeNode node);
    [ExtensionAttribute]
public static CatchSection FindContainingCatchSection(ITreeNode node);
    [ExtensionAttribute]
public static bool IsOwnerOf(ICppDeclarationOwner owner, ICppTopLevelDeclarationNode decl);
    [ExtensionAttribute]
public static TNode FindNextChildByType(ITreeNode parent, NodeTypeSet nt, ITreeNode child);
    [ExtensionAttribute]
public static TNode FindPrevChildByType(ITreeNode parent, NodeTypeSet nt, ITreeNode child);
    [ExtensionAttribute]
public static CppList`1<TNode> FindChildrenByType(ITreeNode parent, NodeTypeSet childTypeSet);
    [ExtensionAttribute]
public static ICppNonAbstractDeclaratorNode TryGetSingleDeclaratorNode(Declaration declaration);
    [ExtensionAttribute]
public static ICppDeclaratorResolveEntity TryGetSingleDeclaratorEntity(SimpleDeclaration simpleDecl);
    [ExtensionAttribute]
public static IClassOrEnumSpecifier TryGetSingleClassSpecifierNode(Declaration declaration);
    [ExtensionAttribute]
public static ICppClassResolveEntity TryGetSingleClassSpecifierEntity(SimpleDeclaration simpleDecl);
    [ExtensionAttribute]
public static ICppResolveEntity TryGetSingleResolveEntity(SimpleDeclaration simpleDecl);
    [ExtensionAttribute]
public static ICppResolveEntity TryGetFirstReferencedResolveEntity(ITreeNode node);
    [ExtensionAttribute]
public static TriBool IsLazyBinaryOperator(BinaryExpression binExpr);
    [ExtensionAttribute]
public static TriBool IsLazyBinaryOperator(FoldExpression foldExpr);
    [ExtensionAttribute]
public static TriBool IsBuiltinNot(UnaryExpression unaryExpr);
    [ExtensionAttribute]
public static bool IsInitializationNotOverloading(InitDeclarator initDecl, CppTypeContext& tc);
    [ExtensionAttribute]
public static bool IsInitializationNotOverloading(MemInitializer memInit, CppTypeContext& tc);
    [ExtensionAttribute]
public static bool TraverseConversionsOfPsiNode(ICppConversionProvidingNode node, ICppConversionVisitor visitor);
    [ExtensionAttribute]
public static ICppConversionProvidingNode FindContainingConversionProvidingNode(ICppCompositeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITreeNode FindContainingNonForeignNode(ITreeNode node);
    [ExtensionAttribute]
public static bool IsInsideTemplateCode(ITreeNode node);
    [ExtensionAttribute]
public static bool WithControlFlowBody(SimpleDeclaration decl);
    [ExtensionAttribute]
public static bool IsFunctionBodyTrailingNode(ICppDeclarationTrailingNode trailingNode);
    [ExtensionAttribute]
public static NestedDeclarator GetInnermostDeclarator(ICppDeclaratorNode declaratorNode);
    [ExtensionAttribute]
public static ParametersAndQualifiers GetTopLevelFunctionParametersAndQualifiers(ICppNonNestedDeclaratorNode declaratorNode);
    [ExtensionAttribute]
public static KnRStyleParameterDeclarations GetKnRStyleParameterDeclarations(ICppNonNestedDeclaratorNode declaratorNode);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static SimpleDeclaration GetFunctionDeclarationByParameter(ICppNonNestedDeclaratorNode declaratorNode);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static LambdaExpression GetLambdaExpressionByParameter(ICppNonNestedDeclaratorNode declaratorNode);
    [ExtensionAttribute]
public static bool IsMemberInDependentMemberAccessExpression(BaseQualifiedReference reference);
    [ExtensionAttribute]
public static ICppTemplateParameter GetTemplateParameterByArgument(ICppTypeIdOrExpressionNode argument);
    [ExtensionAttribute]
public static IEnumerable`1<ICppTemplateParameter> GetPossibleTemplateParameterByArgument(ICppTypeIdOrExpressionNode argument);
    [ExtensionAttribute]
public static ICppTemplateParameter GetTemplateParameterByArgument(ICppResolveEntity templateEntity, int argumentIndex);
    [ExtensionAttribute]
public static ICppExpressionNode WalkUpThroughArrayAccesses(ICppExpressionNode expr);
    [ExtensionAttribute]
public static bool IsCallOfPropertySetter(BinaryExpression assignment);
    [ExtensionAttribute]
public static CppUsageKind GetUsageKind(ICppExpressionNode expr);
    [ExtensionAttribute]
public static CppUsageKind GetUsageKindForControlFlow(ICppExpressionNode expr);
    [ExtensionAttribute]
public static ICppExpressionNode TryGetMemberAccessThoughQualifiers(ICppExpressionNode node);
    private static ICppExpressionNode GetParentIfMemberAccess(ICppExpressionNode node);
    [ExtensionAttribute]
public static ICppExpressionNode GetNewArraySize(NewExpression expr);
    [ExtensionAttribute]
public static bool IsDependentAndCanBeFoundWithAdl(BaseQualifiedReference ref);
    [ExtensionAttribute]
public static CppQualType CalculateTypeOfDeclarationSpecifiersAfterAutoSubstitution(DeclarationSpecifiers specs);
    [ExtensionAttribute]
public static bool IsTakingPointerToMemberExpression(QualifiedReference qualRef);
    [ExtensionAttribute]
public static TriBool IsMemberAccessExpression(QualifiedReference qualRef, ICppResolveEntity accessScope, CppViewPos& viewPos);
    [ExtensionAttribute]
public static bool IsMemberAccessExpression(MemberAccessExpression memAcc);
    [ExtensionAttribute]
public static ITreeRange ExpandRangeToLeftIfFromSubstitution(ITreeRange range);
    [ExtensionAttribute]
public static bool IsCondition(ICppExpressionOrDeclarationNode node);
    [ExtensionAttribute]
public static bool DeconstructCtorInitializer(CtorInitializer ctorInitializer, ICollection`1<ICppResolveEntity> baseInitializers, ICollection`1<ICppResolveEntity> memberInitializers, ICppResolveEntity& delegatingConstructorTarget, Boolean& isDelegatingConstructor);
    [ExtensionAttribute]
public static bool IsDynamicTypeIdExpression(TypeIdExpression typeId);
    [ExtensionAttribute]
public static TriBool IsBuiltinAddressOf(UnaryExpression addressOf);
    [ExtensionAttribute]
public static TriBool IsBuiltinDereference(UnaryExpression addressOf);
    [ExtensionAttribute]
public static TriBool IsBuiltinSubscript(SubscriptExpression subscript);
    [ExtensionAttribute]
public static TriBool IsBuiltinBinaryOperator(BinaryExpression binary);
    [ExtensionAttribute]
public static bool IsExplicitConversionArgument(ICppExpressionNode node);
    [ExtensionAttribute]
public static bool IsAfxMsgHandler(SimpleDeclaration simpleDeclaration);
    [ExtensionAttribute]
public static bool IsDefinedOperator(ITreeNode node);
    private static bool IsAfxMsgMacroCall(ITreeNode node);
    [ExtensionAttribute]
public static bool IsDeclarationWithImplicitInt(BaseDeclaration baseDeclaration);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string GetLabel(GotoStatement stmt);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string GetLabel(LabeledStatement stmt);
    private static string GetLabelByIdent(ITokenNode tok);
    [ExtensionAttribute]
public static bool ContainsBindingToNonConstRef(ICppExpressionNode node);
    private static bool ContainsBindingToNonConstRefConversion(ICppConversionProvidingNode node, ICppExpressionNode ref);
    [ExtensionAttribute]
public static bool StdUtilityIncluded(ICppCompositeNode node);
    public static ITokenNode GetConstSpecifierFromDeclarator(ICppNonNestedDeclaratorNode node);
    public static ITokenNode GetVolatileSpecifierFromDeclarator(ICppNonNestedDeclaratorNode node);
    public static bool IsInsideStaticAssert(ICppExpressionNode expr);
    [CanBeNullAttribute]
public static IErrorElement TryFindError(ITreeNode node);
    [ExtensionAttribute]
public static bool CanResolveInPsiNode(ITreeNode node);
    public static GetFunctionOutermostCompoundStatementResult GetFunctionOutermostCompoundStatement(ITreeNode node);
    public static ReturnStatement[] CollectAllNestedReturnStatements(CompoundStatement compoundStatement, Dictionary`2<ITreeNode, ITreeNode> replacements);
    [ExtensionAttribute]
public static void BuildConditionalNodeConversion(ICppExpressionOrDeclarationNode node, ICppConversionVisitor visitor, CppOverloadSetBuilderParams builderParams);
    [ExtensionAttribute]
public static void OpenChameleons(ITreeNode node);
    [ExtensionAttribute]
public static void CloseChameleonsAndDropReferences(ITreeNode node);
    [ExtensionAttribute]
public static bool IsInPreprocessorDirective(ITreeNode node);
    public static bool StartsFromErrorAtThisLevel(ICppCompositeNode node);
    [ExtensionAttribute]
public static Nullable`1<CppQualifiedName> GetCalleeQualifiedName(ICppCallExpression call);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static QualifiedReference GetCalleeQualifiedReference(CallExpression call);
    [ExtensionAttribute]
public static CppCodeFragment GetContainingCodeFragment(ITreeNode node);
    [ExtensionAttribute]
public static bool IsParameterListWithVoidParameter(ParametersAndQualifiers params);
    [CompilerGeneratedAttribute]
internal static SimpleDeclaration <FindNamedOwningCallable>g__GetFromParametersList|45_0(ParametersAndQualifiers parameterList);
    [CompilerGeneratedAttribute]
internal static bool <FindNamedOwningCallable>g__IsFunctionDecl|45_1(SimpleDeclaration maybeFuncDecl);
    [CompilerGeneratedAttribute]
internal static ParametersAndQualifiers <GetTopLevelFunctionParametersAndQualifiers>g__Impl|71_0(ICppDeclaratorNode declaratorNode);
    [CompilerGeneratedAttribute]
internal static bool <IsMemberAccessExpression>g__IsClassDataMember|89_0(ICppResolveEntity e);
    [CompilerGeneratedAttribute]
internal static ICppExpressionNode <IsMemberAccessExpression>g__TryDropDeref|90_0(ICppExpressionNode expr);
    [CompilerGeneratedAttribute]
internal static bool <ContainsBindingToNonConstRef>g__CallOfNonConstFunction|107_0(CppResolveResult& rr, bool considerOnlyMemberFunctions);
}
public interface JetBrains.ReSharper.Psi.Cpp.Tree.Util.ICppPsiVisitor {
    public bool ProcessingFinished { get; }
    public abstract virtual bool get_ProcessingFinished();
    public abstract virtual void VisitToken(ITokenNode token, NodeType tt);
    public abstract virtual bool TryVisitNonToken(ITreeNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.Util.LazyTokenEnumerator : ValueType {
    private ITokenNode myFirst;
    private ITokenNode myLast;
    [CompilerGeneratedAttribute]
private ITokenNode <Current>k__BackingField;
    public ITokenNode Current { get; private set; }
    public LazyTokenEnumerator(ITokenNode first, ITokenNode last);
    public bool MoveNext();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ITokenNode get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(ITokenNode value);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Tree.Util.LazyTokenView : ValueType {
    private ITokenNode myFirst;
    private ITokenNode myLast;
    public LazyTokenView(ITreeNode node);
    public LazyTokenView(CppTreeElementRange treeRange);
    public LazyTokenEnumerator GetEnumerator();
    public bool IsEmpty();
    public ITokenNode First();
    public ITokenNode Last();
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.WhileStatement : CppLoopStatementBase {
    private CppWhileStatementResolveEntity myResolveEntity;
    public NodeType NodeType { get; }
    public ITokenNode WhileKeyword { get; }
    public ICppExpressionOrDeclarationNode Condition { get; }
    public WhileStatement(CppWhileStatementResolveEntity resolveEntity);
    public virtual NodeType get_NodeType();
    public ITokenNode get_WhileKeyword();
    public ICppExpressionOrDeclarationNode get_Condition();
    public virtual ICppScopeResolveEntity GetResolveScope();
    public CppWhileStatementResolveEntity GetResolveEntity();
    public sealed virtual void BuildConversion(ICppConversionVisitor visitor, CppOverloadSetBuilderParams params);
    public sealed virtual Result Accept(ICppConversionProvidingNodeVisitor`1<Result> visitor);
}
public static class JetBrains.ReSharper.Psi.Cpp.Tree.WhileStatementNavigator : object {
    public static WhileStatement GetByWhileKeyword(ITokenNode tok);
    public static WhileStatement GetByCondition(ICppExpressionOrDeclarationNode condition);
    public static WhileStatement GetByBody(ICppStatement body);
}
public class JetBrains.ReSharper.Psi.Cpp.Tree.YieldValueReference`1 : CoroutineReferenceBase`1<TNode> {
    public YieldValueReference`1(TNode expr);
    public virtual ResolveResultWithInfo ResolveWithoutCache();
}
public enum JetBrains.ReSharper.Psi.Cpp.TriBool : Enum {
    public byte value__;
    public static TriBool False;
    public static TriBool Indeterminate;
    public static TriBool True;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.TriBoolUtil : object {
    [ExtensionAttribute]
public static TriBool Not(TriBool val);
    [ExtensionAttribute]
public static TriBool And(TriBool val1, TriBool val2);
    [ExtensionAttribute]
public static TriBool Or(TriBool val1, TriBool val2);
    [ExtensionAttribute]
public static TriBool ToTriBool(bool val);
    [ExtensionAttribute]
public static bool CanBeTrue(TriBool val);
    [ExtensionAttribute]
public static bool CanBeFalse(TriBool val);
}
internal class JetBrains.ReSharper.Psi.Cpp.Types.AssertTypeClassVisitor : CppAbstractVerboseTypeVisitor`1<bool> {
    private CppTypeClasses myTypec;
    public AssertTypeClassVisitor(CppTypeClasses typec);
    public virtual bool Visit(CppFunctionType e, Qualifiers quals);
    public void VisitExceptionSpecification(ICppExceptionSpecification spec);
    public virtual bool Visit(CppTemplateParameterType t, Qualifiers q);
    public virtual bool Visit(CppGenericParameterType t, Qualifiers q);
    public virtual bool VisitUnresolvedFunctionType(CppUnresolvedFunctionType e, Qualifiers quals);
    public virtual bool Visit(CppUnresolvedFunctionMultipleArgumentsType e, Qualifiers quals);
    public virtual bool Visit(CppReplacedFunctionType e, Qualifiers quals);
    public virtual bool Visit(CppMemberPointerType e, Qualifiers q);
    public virtual bool Visit(CppTypeReference e, Qualifiers q);
    public virtual bool Visit(CppElaboratedTypeReference e, Qualifiers q);
    public virtual bool Visit(CppClassType t, Qualifiers q);
    public virtual bool Visit(CppPendingClassType t, Qualifiers q);
    public virtual bool Visit(CppEnumType t, Qualifiers q);
    public virtual bool Visit(CppResolvedClassType t, Qualifiers q);
    public virtual bool Visit(CppResolvedEnumType t, Qualifiers q);
    public virtual bool Visit(CppLinkageEntityType t, Qualifiers q);
    public virtual bool Visit(CppDependentLinkageEntityType t, Qualifiers q);
    public virtual bool Visit(CppLinkageTemplateParameterType t, Qualifiers q);
    public virtual bool Visit(CppLinkageArrayType e, Qualifiers quals);
    public virtual bool Visit(CppLinkageVectorType e, Qualifiers quals);
    public virtual bool Visit(CppArrayType e, Qualifiers quals);
    public virtual bool Visit(CppCliArrayType e, Qualifiers quals);
    public virtual bool VisitReference(CppQualType innerType, ReferenceFlag refFlag);
    public virtual bool VisitType(CppType t, Qualifiers q);
    public virtual bool VisitTypeWithInnerType(CppTypeWithInnerType t, Qualifiers q);
    public virtual bool Visit(CppNamedParameterType t, Qualifiers q);
    public virtual bool Visit(CppNameSuggestionType t, Qualifiers q);
    public virtual bool Visit(CppScopeSuggestionType t, Qualifiers q);
    public virtual bool Visit(CppDecoratedBuiltinTypeTraitType t, Qualifiers q);
    public virtual bool Visit(CppDependentInstantiatedTemplateAliasType t, Qualifiers q);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Types.AssertUnresolvedUtil : object {
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertUnresolved(CppQualType input);
}
internal class JetBrains.ReSharper.Psi.Cpp.Types.AssertUnresolvedVisitor : CppAbstractTypeVisitor`1<bool> {
    public static AssertUnresolvedVisitor Instance;
    private static AssertUnresolvedVisitor();
    public virtual bool Visit(CppFunctionType e, Qualifiers quals);
    public virtual bool Visit(CppResolvedClassType e, Qualifiers q);
    public virtual bool Visit(CppResolvedEnumType e, Qualifiers q);
    public virtual bool Visit(CppMemberPointerType e, Qualifiers q);
    public virtual bool Visit(CppTemplateParameterType e, Qualifiers q);
    public virtual bool Visit(CppGenericParameterType e, Qualifiers q);
    public virtual bool Visit(CppDependentType e, Qualifiers q);
    public virtual bool Visit(CppCliArrayType e, Qualifiers q);
    public virtual bool VisitReference(CppQualType innerType, ReferenceFlag refFlag);
    public virtual bool VisitType(CppType e, Qualifiers q);
    public virtual bool VisitTypeWithInnerType(CppTypeWithInnerType t, Qualifiers q);
}
internal class JetBrains.ReSharper.Psi.Cpp.Types.ContainsUnknownTypeVisitor : CppAbstractTypeVisitor`1<bool> {
    public static ContainsUnknownTypeVisitor Instance;
    private static ContainsUnknownTypeVisitor();
    public virtual bool VisitType(CppType t, Qualifiers q);
    public virtual bool VisitTypeWithInnerType(CppTypeWithInnerType t, Qualifiers q);
    public virtual bool Visit(CppFunctionType e, Qualifiers quals);
    public virtual bool VisitReference(CppQualType inner, ReferenceFlag refFlag);
    public virtual bool Visit(CppUnknownType t, Qualifiers quals);
    public virtual bool Visit(CppPackExpansionType t, Qualifiers quals);
    public virtual bool Visit(CppMemberPointerType t, Qualifiers quals);
    public virtual bool Visit(CppCliArrayType t, Qualifiers quals);
}
internal class JetBrains.ReSharper.Psi.Cpp.Types.ContainsUnpresentableTypesVisitor : CppAbstractVerboseTypeVisitor`1<bool> {
    private ICppScopeResolveEntity myScope;
    private bool myAllowLambdas;
    public ContainsUnpresentableTypesVisitor(ICppScopeResolveEntity scope, bool allowLambdas);
    public virtual bool Visit(CppNameSuggestionType t, Qualifiers q);
    public virtual bool VisitType(CppType t, Qualifiers q);
    public virtual bool VisitTypeWithInnerType(CppTypeWithInnerType t, Qualifiers q);
    public virtual bool Visit(CppFunctionType e, Qualifiers quals);
    public virtual bool VisitReference(CppQualType inner, ReferenceFlag refFlag);
    public virtual bool Visit(CppResolvedClassType t, Qualifiers quals);
    public virtual bool Visit(CppResolvedEnumType t, Qualifiers quals);
    public virtual bool Visit(CppPackExpansionType t, Qualifiers quals);
    public virtual bool Visit(CppMemberPointerType t, Qualifiers quals);
    public virtual bool Visit(CppDependentType t, Qualifiers q);
    public virtual bool Visit(CppUnknownType t, Qualifiers q);
    public virtual bool Visit(CppInstantiatedTemplateAliasType t, Qualifiers q);
    private bool ReApply(ICppClassResolveEntity clazz);
    private bool ReApply(ICppDependentTypeResolveEntity ent);
    private bool ReApply(CppQualType t);
    private bool ReApply(CppQualifiedName qualName);
    private bool ReApply(CppQualifiedNamePart name);
    private bool ReApply(ICppTemplateArgument[] args);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppAbstractTypeVisitor`1 : object {
    public abstract virtual Result VisitReference(CppQualType innerType, ReferenceFlag r);
    public virtual Result VisitTypeWithDeclSpecPlacement(CppQualType innerType, CppDeclSpecPlacement placement);
    public virtual Result Visit(CppTemplateParameterType t, Qualifiers q);
    public virtual Result Visit(CppGenericParameterType t, Qualifiers q);
    public virtual Result Visit(CppPackExpansionType t, Qualifiers q);
    public virtual Result Visit(CppDependentType t, Qualifiers q);
    public virtual Result Visit(CppTypeReference t, Qualifiers q);
    public virtual Result Visit(CppElaboratedTypeReference t, Qualifiers q);
    public virtual Result Visit(CppVoidType t, Qualifiers q);
    public virtual Result Visit(CppClassType t, Qualifiers q);
    public virtual Result Visit(CppPendingClassType t, Qualifiers q);
    public virtual Result Visit(CppUnknownType t, Qualifiers q);
    public virtual Result Visit(CppResolvedClassType t, Qualifiers q);
    public virtual Result Visit(CppNumericType t, Qualifiers q);
    public virtual Result Visit(CppNullptrType t, Qualifiers q);
    public virtual Result Visit(CppEnumType t, Qualifiers q);
    public virtual Result Visit(CppResolvedEnumType t, Qualifiers q);
    public virtual Result Visit(CppMemberPointerType t, Qualifiers q);
    public virtual Result Visit(CppLinkageEntityType t, Qualifiers q);
    public virtual Result Visit(CppDependentLinkageEntityType t, Qualifiers q);
    public virtual Result Visit(CppLinkageTemplateParameterType t, Qualifiers q);
    public virtual Result Visit(CppAutoType t, Qualifiers q);
    public virtual Result Visit(CppResolvedAutoType t, Qualifiers q);
    public virtual Result Visit(CppArrayType t, Qualifiers q);
    public virtual Result Visit(CppVectorType t, Qualifiers q);
    public virtual Result Visit(CppLinkageArrayType t, Qualifiers q);
    public virtual Result Visit(CppLinkageVectorType t, Qualifiers q);
    public virtual Result Visit(CppFunctionType t, Qualifiers q);
    public virtual Result Visit(CppUnresolvedFunctionWithoutArgumentsType t, Qualifiers q);
    public virtual Result Visit(CppUnresolvedFunctionSingleArgumentType t, Qualifiers q);
    public virtual Result Visit(CppUnresolvedFunctionMultipleArgumentsType t, Qualifiers q);
    public virtual Result Visit(CppReplacedFunctionType t, Qualifiers q);
    public virtual Result Visit(CppPointerType t, Qualifiers q);
    public virtual Result Visit(CppDeclarationSpecifierType t, Qualifiers q);
    public virtual Result Visit(CppDeducedClassTypePlaceholder t, Qualifiers q);
    public virtual Result Visit(CppBuiltinTypeTraitType t, Qualifiers q);
    public virtual Result Visit(CppDependentInstantiatedTemplateAliasType t, Qualifiers q);
    public virtual Result Visit(CppCliHandleType t, Qualifiers q);
    public virtual Result Visit(CppCliInteriorPointerType t, Qualifiers q);
    public virtual Result Visit(CppCliPinPointerType t, Qualifiers q);
    public virtual Result Visit(CppCliArrayType t, Qualifiers q);
    public virtual Result Visit(CppLinkageCliArrayType t, Qualifiers q);
    public virtual Result Visit(CppDeducedClassTypePlaceholderModuleType t, Qualifiers q);
    public virtual Result Visit(HlslVectorType t, Qualifiers q);
    public virtual Result Visit(HlslMatrixType t, Qualifiers q);
    public virtual Result Visit(HlslSamplerType t, Qualifiers q);
    public virtual Result Visit(CppModuleEntityType t, Qualifiers q);
    public virtual Result Visit(CppDecoratedType t, Qualifiers q);
    public virtual Result Visit(CppTypedefModuleType t, Qualifiers q);
    public virtual Result Visit(CppInstantiatedTemplateAliasModuleType t, Qualifiers q);
    public virtual Result Visit(CppDependentInstantiatedTemplateAliasModuleType t, Qualifiers q);
    public abstract virtual Result VisitType(CppType t, Qualifiers q);
    public virtual Result VisitTypeWithInnerType(CppTypeWithInnerType t, Qualifiers q);
    public virtual Result VisitUnresolvedFunctionType(CppUnresolvedFunctionType t, Qualifiers q);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppAbstractVerboseTypeVisitor`1 : CppAbstractTypeVisitor`1<Result> {
    public virtual Result Visit(CppTypedefType t, Qualifiers q);
    public virtual Result Visit(CppInstantiatedTemplateAliasType t, Qualifiers q);
    public virtual Result Visit(CppCEnumeratorType t, Qualifiers q);
    public virtual Result Visit(CppNamedType t, Qualifiers q);
    public virtual Result Visit(CppNamedParameterType t, Qualifiers q);
    public virtual Result Visit(CppNameSuggestionType t, Qualifiers q);
    public virtual Result Visit(CppScopeSuggestionType t, Qualifiers q);
    public virtual Result Visit(CppFunctionWithTrailingReturnType t, Qualifiers q);
    public virtual Result Visit(CppDecoratedBuiltinTypeTraitType t, Qualifiers q);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppArrayType : CppTypeWithInnerType {
    [CompilerGeneratedAttribute]
private ICppExpression <SizeExpression>k__BackingField;
    public ICppExpression SizeExpression { get; }
    public CppArrayType(CppQualType ref, ICppExpression sizeExpr);
    [CompilerGeneratedAttribute]
public ICppExpression get_SizeExpression();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppAutoType : CppType {
    public static CppAutoType AutoInstance;
    public static CppAutoType DecltypeAutoInstance;
    public static CppQualType Instance;
    private CppQualifiedName myConceptName;
    private bool myDecltypeAuto;
    public string DbgDescription { get; }
    public CppQualifiedName ConceptName { get; }
    private CppAutoType(bool decltypeAuto, CppQualifiedName concept);
    private static CppAutoType();
    public virtual string get_DbgDescription();
    public sealed virtual bool IsDecltypeAuto();
    public sealed virtual CppQualifiedName get_ConceptName();
    public static CppAutoType Create(bool decltypeAuto, CppQualifiedName concept);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer consumer);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppBasicDeclarationSpecifierTypeBuilder : object {
    private CppDeclSpecPlacement myDeclSpecsPlacement;
    private bool myShouldSkipAutoSpecifier;
    private Nullable`1<CppQualType> myType;
    private CVQualifiers myCVQuals;
    private CppAttributeList myAttributes;
    private CppBuilderTokenFlag myWasSignedFlag;
    private CppBuilderTokenFlag myWasUnsignedFlag;
    private CppBuilderTokenFlag myWasShortFlag;
    private CppBuilderTokenFlag myWasLongFlag;
    private ICppTypeFactory myTypeIntern;
    protected CppBasicDeclarationSpecifierTypeBuilder(ICppTypeFactory typeIntern, CppLanguageDialect dialect);
    public virtual CppQualType ComposeResultType();
    public virtual void LearnTokenType(TokenNodeType tt);
    public virtual void LearnDecltypeAuto();
    public sealed virtual void LearnBuiltinTypeTraitType(CppQualType argument, CppBuiltinTypeTraitKind kind);
    public virtual void LearnConceptName(CppQualifiedName name, bool decltypeAuto);
    public virtual void LearnQualifiedName(CppQualifiedName name);
    public virtual void LearnElaboratedReference(CppQualifiedName name, CppClassTag tag);
    public virtual void LearnMatrixSpecifier(HlslMatrixSpecifierBuilder& matrixSpecifierBuilder);
    public virtual void LearnHlslBufferComponentType(CppQualType componentType);
    public virtual void LearnClassTag();
    public void LearnAttributes(CppAttributeList attributes);
    private void CreateLeftSideTypeIfNeeded();
    private void PromoteToTypePlacement();
    private void LearnConst();
    private void LearnVolatile();
    private void LearnTypePlacement();
    private void LearnSignedUnsignedPlacement();
    private void LearnShortLongPlacement();
    private void UpdateSpecifiers();
    private CppQualType GetResultType();
    protected void Init(ICppTypeFactory typeIntern, CppLanguageDialect dialect);
    protected void Clear();
    protected void LearnType(CppQualType type);
    private CppQualType ComposeResultInternal(bool shouldInternate);
    protected abstract virtual CppQualType InternateType(CppQualType t);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppBasicIdentityTypeVisitor`1 : object {
    private TTypeIntern myTypeIntern;
    [CompilerGeneratedAttribute]
private bool <OptimizeForUnchangedTypes>k__BackingField;
    public TTypeIntern TypeIntern { get; }
    protected bool OptimizeForUnchangedTypes { get; }
    protected CppBasicIdentityTypeVisitor`1(TTypeIntern typeIntern, bool optimizeForUnchangedTypes);
    public TTypeIntern get_TypeIntern();
    [CompilerGeneratedAttribute]
protected bool get_OptimizeForUnchangedTypes();
    public virtual CppQualType Visit(CppClassType e, Qualifiers quals);
    public virtual CppQualType Visit(CppPendingClassType e, Qualifiers quals);
    public virtual CppQualType Visit(CppEnumType e, Qualifiers quals);
    public virtual CppQualType Visit(CppResolvedClassType e, Qualifiers quals);
    public virtual CppQualType Visit(CppResolvedEnumType e, Qualifiers quals);
    public virtual CppQualType Visit(CppTemplateParameterType e, Qualifiers quals);
    public virtual CppQualType Visit(CppGenericParameterType e, Qualifiers quals);
    public virtual CppQualType Visit(CppPackExpansionType e, Qualifiers quals);
    public virtual CppQualType Visit(CppDependentType e, Qualifiers quals);
    public virtual CppQualType Visit(CppMemberPointerType e, Qualifiers quals);
    public virtual CppQualType Visit(CppAutoType e, Qualifiers quals);
    public virtual CppQualType Visit(CppResolvedAutoType e, Qualifiers quals);
    public virtual CppQualType Visit(CppVoidType e, Qualifiers quals);
    public virtual CppQualType Visit(CppUnknownType e, Qualifiers quals);
    public virtual CppQualType Visit(CppNumericType e, Qualifiers quals);
    public virtual CppQualType Visit(CppNullptrType e, Qualifiers quals);
    public virtual CppQualType Visit(CppTypeReference e, Qualifiers quals);
    public virtual CppQualType Visit(CppElaboratedTypeReference e, Qualifiers quals);
    public virtual CppQualType Visit(CppArrayType e, Qualifiers quals);
    public virtual CppQualType Visit(CppVectorType e, Qualifiers quals);
    public virtual CppQualType Visit(CppFunctionType e, Qualifiers quals);
    public virtual CppQualType Visit(CppUnresolvedFunctionWithoutArgumentsType e, Qualifiers quals);
    public virtual CppQualType Visit(CppUnresolvedFunctionSingleArgumentType e, Qualifiers quals);
    public virtual CppQualType Visit(CppUnresolvedFunctionMultipleArgumentsType e, Qualifiers quals);
    public virtual CppQualType Visit(CppReplacedFunctionType e, Qualifiers quals);
    public virtual CppQualType Visit(CppPointerType e, Qualifiers quals);
    public virtual CppQualType Visit(CppDeclarationSpecifierType e, Qualifiers quals);
    public virtual CppQualType Visit(CppCliHandleType e, Qualifiers quals);
    public virtual CppQualType Visit(CppCliInteriorPointerType e, Qualifiers quals);
    public virtual CppQualType Visit(CppCliPinPointerType e, Qualifiers quals);
    public virtual CppQualType Visit(CppBuiltinTypeTraitType t, Qualifiers quals);
    public virtual CppQualType Visit(CppCliArrayType e, Qualifiers quals);
    public virtual CppQualType VisitReference(CppQualType innerType, ReferenceFlag refFlag);
    public virtual CppQualType VisitTypeWithDeclSpecPlacement(CppQualType innerType, CppDeclSpecPlacement placement);
    public virtual CppQualType Visit(CppDecoratedType e, Qualifiers quals);
    public virtual CppQualType Visit(CppNamedParameterType e, Qualifiers quals);
    public virtual CppQualType Visit(CppTypedefType e, Qualifiers quals);
    public virtual CppQualType Visit(CppInstantiatedTemplateAliasType e, Qualifiers quals);
    public virtual CppQualType Visit(CppCEnumeratorType e, Qualifiers quals);
    public virtual CppQualType Visit(CppNamedType e, Qualifiers quals);
    public virtual CppQualType Visit(CppNameSuggestionType e, Qualifiers quals);
    public virtual CppQualType Visit(CppScopeSuggestionType e, Qualifiers quals);
    public virtual CppQualType Visit(CppFunctionWithTrailingReturnType e, Qualifiers quals);
    public virtual CppQualType Visit(CppDecoratedBuiltinTypeTraitType t, Qualifiers quals);
    public virtual CppQualType Visit(CppDeducedClassTypePlaceholder e, Qualifiers quals);
    public virtual CppQualType Visit(CppDependentInstantiatedTemplateAliasType e, Qualifiers quals);
    public virtual CppQualType Visit(CppLinkageEntityType e, Qualifiers q);
    public virtual CppQualType Visit(CppDependentLinkageEntityType e, Qualifiers q);
    public virtual CppQualType Visit(CppLinkageTemplateParameterType e, Qualifiers q);
    public virtual CppQualType Visit(CppLinkageArrayType e, Qualifiers q);
    public virtual CppQualType Visit(CppLinkageVectorType e, Qualifiers q);
    public virtual CppQualType Visit(CppLinkageCliArrayType e, Qualifiers q);
    public virtual CppQualType Visit(HlslVectorType t, Qualifiers q);
    public virtual CppQualType Visit(HlslMatrixType t, Qualifiers q);
    public virtual CppQualType Visit(HlslSamplerType t, Qualifiers q);
    public virtual CppQualType Visit(CppModuleEntityType t, Qualifiers q);
    public virtual CppQualType Visit(CppTypedefModuleType e, Qualifiers q);
    public sealed virtual CppQualType Visit(CppInstantiatedTemplateAliasModuleType e, Qualifiers q);
    public virtual CppQualType Visit(CppDependentInstantiatedTemplateAliasModuleType e, Qualifiers q);
    public sealed virtual CppQualType Visit(CppDeducedClassTypePlaceholderModuleType t, Qualifiers q);
    protected virtual ICppNoExceptSpecification VisitNoExceptSpecification(ICppNoExceptSpecification e);
    protected virtual CppQualType ReApply(CppQualType t, Boolean& changed);
    protected virtual CppList`1<CppQualType> ReApplyToPackExpansion(CppQualType t, Boolean& changed);
    protected virtual CppUnknownEntityInfo ReApply(CppUnknownEntityInfo info, Boolean& changed);
    protected virtual CppQualType[] VisitFunctionParams(CppQualType[] types, Boolean& changed);
    protected virtual CppParameterDeclaratorData VisitFunctionParam(CppParameterDeclaratorData param, Boolean& changed);
    protected virtual CppParameterDeclaratorData[] VisitFunctionParams(CppParameterDeclaratorData[] oldParameters, Boolean& changed);
    protected virtual ICppExpression VisitArraySize(ICppExpression arraySize, Boolean& changed);
    protected virtual ICppExpression VisitVectorSize(ICppExpression size, Boolean& changed);
    protected virtual ICppExpression VisitCliArrayRank(ICppExpression arrayRank, Boolean& changed);
    protected virtual ICppExceptionSpecification VisitExceptionSpecification(ICppExceptionSpecification exceptionSpecification, Boolean& changed);
    protected virtual CppQualifiedName VisitAutoConceptName(CppQualifiedName name, Boolean& changed);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppBasicTypeBuilder : object {
    protected CppQualType myResultType;
    protected CppQualType myLeftSideType;
    protected CppQualType myInnerType;
    protected bool myInnerTypeSetByLeftSide;
    protected CppQualType myRightSideType;
    protected CppTypeWithInnerTypeInterface myRightSideParentType;
    protected bool myHadPointers;
    protected CppCallingConvention myLeftMostCallingConvention;
    protected CppCallingConvention myRightMostCallingConvention;
    protected void Init();
    public virtual CppQualType ComposeResultType();
    public virtual void LearnBaseType(CppQualType type);
    public virtual void LearnTokenType(TokenNodeType tt);
    public virtual void LearnTokenType(TokenNodeType tt, ITokenNode location);
    public virtual void LearnPtr(TokenNodeType tt, CVQualifiers quals);
    public virtual void LearnNameQualifierPtrName(CppQualifiedName name, CVQualifiers quals);
    public virtual bool InnerTypeIsEmpty();
    public virtual void LearnArraySize(ICppExpression sizeExpr);
    public virtual void LearnUnknownArraySize();
    public virtual void LearnFunctionParameters(CppSmallArray`1<CppParameterDeclaratorSymbol> syms, CppEllipsisKind ellipsisKind, CVQualifiers cvQuals, FuncRefQualifier refQual, CppQualType trailingReturnType, CppRestrictionSpecifiers restrictionSpecifiers, ICppExceptionSpecification exceptionSpecification);
    public virtual void LearnReplacedFunction(CppParameterListResolveEntity resolveEntity, CppEllipsisKind ellipsisKind, CVQualifiers cvQuals, FuncRefQualifier refQual, CppQualType trailingReturnType, CppRestrictionSpecifiers restrictionSpecifiers, ICppExceptionSpecification exceptionSpecification);
    public virtual void LearnCallingConvention(CppCallingConvention cc);
    public sealed virtual void LearnCallingConvention(ICppCallingConventionBuilder ccBuilder);
    private void UpdateRightSideType(CppTypeWithInnerTypeInterface type, Qualifiers quals);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
protected static void AssertTypeHasPlaceholderTypeBuilder(CppQualType type);
    protected virtual CppQualType ComposeResultInternal(bool shouldInternate);
    protected abstract virtual CppQualType InternateType(CppQualType t);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppBinaryTypingResult : ValueType {
    public CppTypeAndCategory ResultType;
    public CppTypeAndCategory LeftOperandType;
    public CppTypeAndCategory RightOperandType;
    public CppBinaryTypingResult(CppTypeAndCategory resultType, CppTypeAndCategory leftOperandType, CppTypeAndCategory rightOperandType);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppBoundOverloadedFunctionExpression : CppTemporaryExpression {
    private CppResolveResult myResolveResult;
    private CppBoundOverloadedFunctionExpression(CppTypeAndCategory type, ICppResolvedExpression innerExpr, CppResolveResult& rr);
    public static ICppResolvedExpression Create(ICppResolvedExpression innerExpr, CppResolveResult& rr, CppTypeAndCategory tc);
    public CppResolveResult GetResolveResult();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppBuilderTokenFlag : ValueType {
    [CompilerGeneratedAttribute]
private int <SetCount>k__BackingField;
    public int SetCount { get; private set; }
    public static bool op_Implicit(CppBuilderTokenFlag flag);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_SetCount();
    [CompilerGeneratedAttribute]
private void set_SetCount(int value);
    public void Set();
    public int Drop();
}
public enum JetBrains.ReSharper.Psi.Cpp.Types.CppBuiltinTypeTraitKind : Enum {
    public int value__;
    public static CppBuiltinTypeTraitKind UnderlyingType;
    public static CppBuiltinTypeTraitKind AddPointer;
    public static CppBuiltinTypeTraitKind AddLvalReference;
    public static CppBuiltinTypeTraitKind AddRvalReference;
    public static CppBuiltinTypeTraitKind Decay;
    public static CppBuiltinTypeTraitKind MakeSigned;
    public static CppBuiltinTypeTraitKind MakeUnsigned;
    public static CppBuiltinTypeTraitKind RemoveConst;
    public static CppBuiltinTypeTraitKind RemoveVolatile;
    public static CppBuiltinTypeTraitKind RemoveCV;
    public static CppBuiltinTypeTraitKind RemoveCVRef;
    public static CppBuiltinTypeTraitKind RemoveReference;
    public static CppBuiltinTypeTraitKind RemovePointer;
    public static CppBuiltinTypeTraitKind RemoveExtent;
    public static CppBuiltinTypeTraitKind RemoveAllExtents;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Types.CppBuiltinTypeTraitKindUtil : object {
    private static HashMap`2<TokenNodeType, CppBuiltinTypeTraitKind> ourTokenToKind;
    private static HashMap`2<CppBuiltinTypeTraitKind, TokenNodeType> ourKindToToken;
    private static CppBuiltinTypeTraitKindUtil();
    [ExtensionAttribute]
public static CppBuiltinTypeTraitKind TokenTypeToBuiltinTypeTraitKind(TokenNodeType tok);
    [ExtensionAttribute]
public static string GetRepresentation(CppBuiltinTypeTraitKind kind);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__Add|2_0(TokenNodeType token, CppBuiltinTypeTraitKind kind);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppBuiltinTypeTraitType : CppTypeWithInnerType {
    public CppBuiltinTypeTraitKind Kind;
    private static CppQualType ourInvalidTypeEvaluationResult;
    public CppBuiltinTypeTraitType(CppQualType argument, CppBuiltinTypeTraitKind kind);
    private static CppBuiltinTypeTraitType();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
    public static CppQualType EvaluateTypeTrait(CppQualType argument, CppBuiltinTypeTraitKind kind, ICppResolvedTypeFactory tf);
    private static CppQualType EvaluateNonDependentTypeTrait(CppQualType argument, CppBuiltinTypeTraitKind kind, ICppResolvedTypeFactory tf);
    private static CppQualType GetNonDependentEnumUnderlyingType(CppQualType enumType);
    private static CppQualType AddPointer(CppQualType argument, ICppResolvedTypeFactory tf);
    private static CppQualType AddReference(CppQualType argument, ReferenceFlag refToAdd);
    private static CppQualType Decay(CppQualType type, ICppResolvedTypeFactory tf);
    private static bool IsQualifiedMemberFunction(CppQualType type);
    private static CppQualType MakeSigned(CppQualType argument);
    private static CppQualType MakeUnsigned(CppQualType argument);
    private static CppQualType RemoveExtent(CppQualType type);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppCachingProxyTypeIntern : CppProxyTypeFactory {
    private ConcurrentDictionary`2<ICppRawDeclaratorResolveEntity, CppQualType> myDeclaratorTypeCache;
    private ConcurrentDictionary`2<CppGroupedFunctionDeclaratorResolveEntity, CppQualType> myFunctionReturnTypeCache;
    public CppCachingProxyTypeIntern(ICppResolvedTypeFactory inner);
    public virtual CppQualType GetCachedType(ICppRawDeclaratorResolveEntity key);
    public virtual CppQualType GetCachedType(CppGroupedFunctionDeclaratorResolveEntity key);
    public virtual CppQualType TryGetCachedType(ICppRawDeclaratorResolveEntity key);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppCEnumeratorType : CppDecoratedType {
    [CompilerGeneratedAttribute]
private ICppClassResolveEntity <Enumeration>k__BackingField;
    public ICppClassResolveEntity Enumeration { get; }
    public string DbgDescription { get; }
    public CppCEnumeratorType(ICppClassResolveEntity enumEnt, CppQualType innerType);
    [CompilerGeneratedAttribute]
public ICppClassResolveEntity get_Enumeration();
    public virtual string get_DbgDescription();
    public virtual Result Accept(ICppVerboseTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
}
internal class JetBrains.ReSharper.Psi.Cpp.Types.CppCheckSubstitutionFailureTypeVisitor : CppAbstractTypeVisitor`1<CppUnknownEntityInfo> {
    public static CppCheckSubstitutionFailureTypeVisitor Instance;
    private static CppCheckSubstitutionFailureTypeVisitor();
    public virtual CppUnknownEntityInfo VisitType(CppType t, Qualifiers q);
    public virtual CppUnknownEntityInfo VisitReference(CppQualType innerType, ReferenceFlag f);
    public virtual CppUnknownEntityInfo VisitTypeWithInnerType(CppTypeWithInnerType t, Qualifiers q);
    public virtual CppUnknownEntityInfo Visit(CppArrayType t, Qualifiers q);
    public virtual CppUnknownEntityInfo Visit(CppCliArrayType t, Qualifiers q);
    public virtual CppUnknownEntityInfo Visit(CppMemberPointerType t, Qualifiers q);
    public virtual CppUnknownEntityInfo Visit(CppResolvedClassType t, Qualifiers q);
    public virtual CppUnknownEntityInfo Visit(CppResolvedAutoType t, Qualifiers q);
    public virtual CppUnknownEntityInfo Visit(CppFunctionType t, Qualifiers q);
    public virtual CppUnknownEntityInfo Visit(CppUnknownType t, Qualifiers q);
    public virtual CppUnknownEntityInfo Visit(CppDependentType t, Qualifiers q);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppClassType : CppTypeWithClassSymbol {
    public CppClassType(ICppClassSymbol classSymbol);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppCliArrayType : CppType {
    private CppQualType myElementType;
    [CompilerGeneratedAttribute]
private ICppExpression <RankExpression>k__BackingField;
    public CppQualType ElementType { get; }
    public ICppExpression RankExpression { get; }
    public CppCliArrayType(CppQualType elementType, ICppExpression rankExpr);
    public CppQualType get_ElementType();
    [CompilerGeneratedAttribute]
public ICppExpression get_RankExpression();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Cpp.Types.CppCliHandleConversionKind : Enum {
    public int value__;
    public static CppCliHandleConversionKind No;
    public static CppCliHandleConversionKind Yes;
    public static CppCliHandleConversionKind SourceTypeIsIncomplete;
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppCliHandleType : CppTypeWithInnerType {
    public CppCliHandleType(CppQualType ref);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppCliInteriorPointerType : CppTypeWithInnerType {
    public CppCliInteriorPointerType(CppQualType ref);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppCliPinPointerType : CppTypeWithInnerType {
    public CppCliPinPointerType(CppQualType ref);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Cpp.Types.CppCollectDeducibleTemplateParametersVisitor : CppAbstractTypeVisitor`1<int> {
    private ICollection`1<CppTemplateParameterTag> myOutput;
    public CppCollectDeducibleTemplateParametersVisitor(ICollection`1<CppTemplateParameterTag> output);
    public sealed virtual int Visit(CppMonostate m, CppQualifiedReferenceTemplateArgument a);
    public sealed virtual int Visit(CppMonostate m, CppQualType a);
    public sealed virtual int Visit(CppMonostate m, CppTypeTemplateArgument a);
    public sealed virtual int Visit(CppMonostate m, CppTypeTemplateArgumentPack a);
    public sealed virtual int Visit(CppMonostate m, CppExpressionTemplateArgument a);
    public sealed virtual int Visit(CppMonostate m, CppExpressionTemplateArgumentPack a);
    public sealed virtual int Visit(CppMonostate m, CppTemplateTemplateArgument a);
    public sealed virtual int Visit(CppMonostate m, CppTemplateTemplateArgumentPack a);
    public sealed virtual int Visit(CppMonostate m, CppDependentTemplateArgument a);
    public sealed virtual int Visit(CppMonostate m, CppLookupFailureTemplateArgument a);
    public sealed virtual int Visit(CppMonostate m, CppInjectedClassNameTemplateArgument a);
    public sealed virtual int Visit(CppMonostate m, CppExcessiveTemplateArgument a);
    public virtual int VisitType(CppType t, Qualifiers q);
    public virtual int Visit(CppPackExpansionType t, Qualifiers q);
    public virtual int Visit(CppArrayType t, Qualifiers q);
    public virtual int Visit(CppCliArrayType t, Qualifiers q);
    public int VisitFunctionParameters(CppQualType[] params);
    public virtual int Visit(CppFunctionType t, Qualifiers q);
    public virtual int Visit(CppPointerType t, Qualifiers q);
    public virtual int Visit(CppTemplateParameterType t, Qualifiers q);
    public virtual int Visit(CppGenericParameterType t, Qualifiers q);
    public virtual int Visit(CppDependentType t, Qualifiers q);
    public virtual int Visit(CppResolvedClassType t, Qualifiers q);
    public virtual int Visit(CppMemberPointerType t, Qualifiers q);
    public virtual int VisitReference(CppQualType innerType, ReferenceFlag f);
    public virtual int Visit(CppCliHandleType t, Qualifiers q);
    public virtual int Visit(CppCliInteriorPointerType t, Qualifiers q);
    public virtual int Visit(CppCliPinPointerType t, Qualifiers q);
    public virtual int Visit(CppDependentInstantiatedTemplateAliasType t, Qualifiers q);
    private void HandleDeducibleExpr(ICppExpression expr);
    private void HandleClass(ICppTypeTemplateInstantiationResolveEntity ent);
}
internal class JetBrains.ReSharper.Psi.Cpp.Types.CppCollectTypedefsVisitor : CppAbstractVerboseTypeVisitor`1<object> {
    private JetHashSet`1<ICppDeclaratorResolveEntity> myTypedefs;
    public IEnumerable`1<ICppDeclaratorResolveEntity> GetResult();
    public virtual object VisitType(CppType t, Qualifiers q);
    public virtual object VisitReference(CppQualType innerType, ReferenceFlag refFlag);
    public virtual object Visit(CppTypedefType t, Qualifiers q);
    public virtual object VisitTypeWithInnerType(CppTypeWithInnerType t, Qualifiers q);
    public virtual object Visit(CppFunctionType t, Qualifiers q);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppCVQualifiersBuilder : ValueType {
    private CVQualifiers myCVQuals;
    public void LearnTokenType(TokenNodeType tt);
    public CVQualifiers GetCVQualifiers();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppDeclarationSpecifierType : CppType {
    public static CppDeclarationSpecifierType INSTANCE;
    private static CppDeclarationSpecifierType();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Types.CppDeclarationSpecifierTypeBuilderUtil : object {
    [ExtensionAttribute]
public static void LearnTypeBuilderWithClassBuilder(ICppUnresolvedDeclarationSpecifierTypeBuilder typeBuilder, CppClassBuilder classBuilder);
    [ExtensionAttribute]
public static void LearnTypeBuilderWithClassBuilder(ICppResolvedDeclarationSpecifierTypeBuilder typeBuilder, CppClassBuilder classBuilder);
}
public enum JetBrains.ReSharper.Psi.Cpp.Types.CppDeclSpecKind : Enum {
    public ushort value__;
    public static CppDeclSpecKind None;
    public static CppDeclSpecKind Typename;
    public static CppDeclSpecKind Const;
    public static CppDeclSpecKind Volatile;
    public static CppDeclSpecKind SignedUnsigned;
    public static CppDeclSpecKind ShortLong;
    public static CppDeclSpecKind ClassTag;
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppDeclSpecPlacement : ValueType {
    private ushort myPlacement;
    private static int BitStep;
    private static int BitLimit;
    private static int BitMask;
    public CppDeclSpecPlacement(ushort rawPlacement);
    public CppDeclSpecPlacement(CppList`1<CppDeclSpecKind> order);
    public CppList`1<CppDeclSpecKind> GetOrder();
    public bool IsTrivial();
    public bool HasDeclSpec(CppDeclSpecKind spec);
    public void LearnDeclSpec(CppDeclSpecKind spec);
    public bool ReplaceDeclSpec(CppDeclSpecKind from, CppDeclSpecKind to);
    public bool RemoveDeclSpec(CppDeclSpecKind spec);
    public sealed virtual bool Equals(CppDeclSpecPlacement other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public ushort GetPlacement();
    public static byte ToBytePacked(ushort placement);
    public static ushort FromBytePacked(byte placement);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppDecoratedBuiltinTypeTraitType : CppDecoratedType {
    public CppBuiltinTypeTraitKind Kind;
    public CppQualType Argument;
    public CppDecoratedBuiltinTypeTraitType(CppQualType innerType, CppQualType argument, CppBuiltinTypeTraitKind kind);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual Result Accept(ICppVerboseTypeVisitor`1<Result> visitor, Qualifiers quals);
}
public static class JetBrains.ReSharper.Psi.Cpp.Types.CppDecoratedFunctionParameterFactory : object {
    public static ICppDecoratedFunctionParameter CreateFromParameterData(CppParameterDeclaratorData data, bool isParameterPack);
    public static ICppDecoratedFunctionParameter CreateFromResolveEntity(ICppVariableDeclaratorResolveEntity ent);
    public static ICppDecoratedFunctionParameter CreateResolved(string name, ICppResolvedExpression initializer);
    public static ICppDecoratedFunctionParameter CreateWithSubstitution(string name, ICppResolvedExpression initializer, CppTypeContext& typeContext, CppSubstitutionContext subst);
    public static ICppVariableDeclaratorResolveEntity GetParameterResolveEntity(ICppDecoratedFunctionParameter param);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppDecoratedFunctionParameterFromParameterData : object {
    private CppParameterDeclaratorData myParameterData;
    [CompilerGeneratedAttribute]
private bool <IsParameterPack>k__BackingField;
    public string Name { get; }
    public ICppExpression Initializer { get; }
    public bool ShouldBeResolved { get; }
    public bool IsParameterPack { get; }
    public CppDecoratedFunctionParameterFromParameterData(CppParameterDeclaratorData parameterData, bool isParameterPack);
    public sealed virtual string get_Name();
    public sealed virtual ICppExpression get_Initializer();
    public sealed virtual bool get_ShouldBeResolved();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsParameterPack();
    public sealed virtual bool Equals(ICppDecoratedFunctionParameter other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppDecoratedType : CppType {
    [CompilerGeneratedAttribute]
private CppQualType <Type>k__BackingField;
    public CppQualType Type { get; }
    public string DbgDescription { get; }
    protected CppDecoratedType(CppQualType innerType);
    [CompilerGeneratedAttribute]
public CppQualType get_Type();
    public virtual string get_DbgDescription();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public abstract virtual Result Accept(ICppVerboseTypeVisitor`1<Result> visitor, Qualifiers quals);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppDeducedClassTypePlaceholder : CppType {
    public ICppDeducibleTypeTemplateResolveEntity ClassTemplate;
    public CppDeducedClassTypePlaceholder(ICppDeducibleTypeTemplateResolveEntity classTemplate);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppDeducedClassTypePlaceholderModuleType : CppType {
    public ICppModuleEntity ClassTemplate;
    public CppDeducedClassTypePlaceholderModuleType(ICppModuleEntity classTemplate);
    public virtual TResult Accept(ICppTypeVisitor`1<TResult> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public static CppImportResult`1<ICppDeducibleTypeTemplateResolveEntity> ImportClassTemplate(ICppModuleEntity classTemplate, CppModuleImportingContext ctx);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
}
public enum JetBrains.ReSharper.Psi.Cpp.Types.CppDefaultInitializationError : Enum {
    public int value__;
    public static CppDefaultInitializationError None;
    public static CppDefaultInitializationError InaccessibleConstructor;
    public static CppDefaultInitializationError InitOfAbstractClass;
    public static CppDefaultInitializationError InitOfConstType;
    public static CppDefaultInitializationError InitOfFunctionType;
    public static CppDefaultInitializationError InitOfReferenceType;
    public static CppDefaultInitializationError InitOfVoidType;
    public static CppDefaultInitializationError DeductionFail;
    public static CppDefaultInitializationError DeletedConstructor;
    public static CppDefaultInitializationError NoDefaultConstructor;
    public static CppDefaultInitializationError NoUserDefaultConstructorInConstClass;
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppDependentInstantiatedTemplateAliasModuleType : CppTypeWithInnerType {
    public CppSmallArray`1<ICppModuleTemplateArgument> Arguments;
    public ICppTypeAliasModuleEntity TemplateDeclarator;
    public string DbgDescription { get; }
    public CppDependentInstantiatedTemplateAliasModuleType(CppQualType underlyingType, ICppTypeAliasModuleEntity templateDeclarator, CppSmallArray`1<ICppModuleTemplateArgument> arguments);
    public virtual string get_DbgDescription();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppDependentInstantiatedTemplateAliasType : CppTypeWithInnerType {
    public ICppTemplateArgument[] Arguments;
    public ICppTypeTemplateDeclaratorResolveEntity TemplateDeclarator;
    public string DbgDescription { get; }
    public CppDependentInstantiatedTemplateAliasType(CppQualType underlyingType, ICppTypeTemplateDeclaratorResolveEntity templateDeclarator, ICppTemplateArgument[] arguments);
    public virtual string get_DbgDescription();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public static CppQualType GetUnderlyingType(CppQualType type);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppDependentLinkageEntityType : CppType {
    [CompilerGeneratedAttribute]
private ICppDependentLinkageEntity <LinkageEntity>k__BackingField;
    public ICppDependentLinkageEntity LinkageEntity { get; }
    public CppDependentLinkageEntityType(ICppDependentLinkageEntity linkageEntity);
    [CompilerGeneratedAttribute]
public ICppDependentLinkageEntity get_LinkageEntity();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppDependentType : CppType {
    [CompilerGeneratedAttribute]
private ICppDependentTypeResolveEntity <ResolveEntity>k__BackingField;
    public ICppDependentTypeResolveEntity ResolveEntity { get; }
    public string DbgDescription { get; }
    public CppDependentType(ICppDependentTypeResolveEntity e);
    [CompilerGeneratedAttribute]
public ICppDependentTypeResolveEntity get_ResolveEntity();
    public virtual string get_DbgDescription();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppDropDecorationProxy : CppProxyTypeFactory {
    public bool IgnoresScopeSuggestions { get; }
    public bool IgnoresNameSuggestions { get; }
    public CppDropDecorationProxy(ICppResolvedTypeFactory tf);
    public virtual bool get_IgnoresScopeSuggestions();
    public virtual bool get_IgnoresNameSuggestions();
    public virtual CppQualType GetTypedefType(CppQualType innerType, ICppGroupedTypeDeclaratorResolveEntity decl);
    public virtual CppQualType GetInstantiatedTemplateAliasType(CppQualType innerType, CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity e);
    public virtual CppQualType GetCEnumeratorType(CppQualType innerType, ICppClassResolveEntity decl);
    public virtual CppQualType GetNamedType(CppQualType innerType, CppQualifiedName name);
    public virtual CppQualType GetNameSuggestionType(CppQualType innerType, CppQualifiedName name);
    public virtual CppQualType GetScopeSuggestionType(CppQualType innerType, CppQualType scopeType);
    public virtual CppQualType GetNamedParameterType(ICppDecoratedFunctionParameter parameter, CppQualType innerType);
    public virtual CppQualType GetFunctionWithTrailingReturnType(CppQualType functionType);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppDynamicExceptionSpecification : object {
    private CppList`1<Element> myElements;
    public CppList`1<Element> Elements { get; }
    public CppDynamicExceptionSpecification(CppList`1<Element> exceptions);
    public CppList`1<Element> get_Elements();
    public virtual string ToString();
    public void AddElement(CppQualType type, bool isPackExpansion);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppElaboratedTypeReference : CppType {
    private CppQualifiedName myTypeQualifiedName;
    [CompilerGeneratedAttribute]
private CppClassTag <Tag>k__BackingField;
    public CppQualifiedName QualifiedName { get; }
    public CppClassTag Tag { get; }
    public CppElaboratedTypeReference(CppQualifiedName name, CppClassTag tag);
    public CppQualifiedName get_QualifiedName();
    [CompilerGeneratedAttribute]
public CppClassTag get_Tag();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppEnumType : CppTypeWithClassSymbol {
    public CppEnumType(ICppClassSymbol classSymbol);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
public static class JetBrains.ReSharper.Psi.Cpp.Types.CppEqualsTypeUtil : object {
    public static ReferenceFlag GetRefFlag(CppQualType t, ICppEqualityComparer engine);
    public static CppQualType ClearRefFlag(CppQualType t, ICppEqualityComparer engine);
    public static bool TypeIsReference(CppQualType t, ICppEqualityComparer engine);
    public static bool VisitReference(CppQualType innerT, ReferenceFlag refFlag, CppQualType rhs, ICppEqualityComparer engine);
    public static TType TypeInternalAs(CppQualType t, ICppEqualityComparer engine);
    public static bool CompareExceptionSpecifications(ICppExceptionSpecification lhs, ICppExceptionSpecification rhs, ICppEqualityComparer engine, bool noexceptEqualsToNoexceptTrue);
    private static bool DecayedFunctionParameterEqualsTo(CppFunctionType lhsFunction, CppQualType rhsPointee, ICppEqualityComparer engine);
    private static bool ComparePointerWithNonNormalizedParameterType(CppQualType lhsPointer, CppQualType rhs, ICppEqualityComparer engine);
    public static bool CompareNonNormalizedFunctionParameters(CppQualType lhs, CppQualType rhs, ICppEqualityComparer engine);
}
public static class JetBrains.ReSharper.Psi.Cpp.Types.CppExpectedTypeUtil : object {
    public static CppTypeAndCategory GuessUnaryOperandByResultType(CppTypeAndCategory resultT, CppOperatorKind opKind, ICppResolvedTypeFactory typeFactory);
    public static CppTypeAndCategory GuessBinaryLeftOperandByResultType(CppTypeAndCategory resulT, CppTypeAndCategory rhsT, CppOperatorKind opKind, ICppResolvedTypeFactory typeFactory);
    public static CppTypeAndCategory GuessBinaryRightOperandByResultType(CppTypeAndCategory resulT, CppTypeAndCategory lhsT, CppOperatorKind opKind, ICppResolvedTypeFactory typeFactory);
    public static CppTypeAndCategory GuessBinaryLeftOperandByRightOperand(CppTypeAndCategory rightT, CppOperatorKind opKind, ICppResolvedTypeFactory typeFactory);
    public static CppTypeAndCategory GuessBinaryRightOperandByLeftOperand(CppTypeAndCategory leftT, CppOperatorKind opKind, ICppResolvedTypeFactory typeFactory);
    public static CppTypeAndCategory GuessBinaryLeftOperandByResult(CppTypeAndCategory resultT, CppOperatorKind opKind, ICppResolvedTypeFactory typeFactory);
    public static CppTypeAndCategory GuessBinaryRightOperandByResult(CppTypeAndCategory resultT, CppOperatorKind opKind, ICppResolvedTypeFactory typeFactory);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppFloatTypeKind : CppNumericTypeKind {
    public static CppFloatTypeKind HALF;
    public static CppFloatTypeKind FLOAT;
    public static CppFloatTypeKind DOUBLE;
    public static CppFloatTypeKind LONGDOUBLE;
    [CompilerGeneratedAttribute]
private FloatPrecision <Precision>k__BackingField;
    private int mySize;
    private int myConversionRank;
    public FloatPrecision Precision { get; }
    private CppFloatTypeKind(string name, FloatPrecision p, int rank, int size);
    private static CppFloatTypeKind();
    [CompilerGeneratedAttribute]
public FloatPrecision get_Precision();
    public virtual int GetSize(CppLanguageDialect dialect);
    public virtual int GetConversionRank(CppLanguageDialect dialect);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppFuncRefQualifierBuilder : ValueType {
    private FuncRefQualifier myFuncRefQualifier;
    public void LearnTokenType(TokenNodeType tt);
    public void LearnExplicitThis();
    public FuncRefQualifier GetFuncRefQualifier();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppFunctionBasicData : ValueType {
    private CppType myUnqualifiedType;
    private FlagsAndTypeBits myFlagsAndTypeBits;
    internal CppType UnqualifiedType { get; }
    internal CppFunctionFlags Flags { get; }
    public CppFunctionBasicData(CppQualType type, CppFunctionFlags flags);
    internal CppType get_UnqualifiedType();
    internal CppFunctionFlags get_Flags();
    [IsReadOnlyAttribute]
internal CppQualType GetQualType();
    public void SetType(CppQualType t);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Types.CppFunctionFlags : ValueType {
    private static int CallingConventionOffset;
    private static int RestrictionSpecifiersOffset;
    private static UInt32 ByteMask;
    private UInt32 myStorage;
    public static CppFunctionFlags UnspecifiedCallingConvCpuOnly;
    public static CppFunctionFlags Cdecl;
    public static CppFunctionFlags ClrCall;
    public CppEllipsisKind EllipsisKind { get; }
    public CppCallingConvention CallingConvention { get; }
    public CppRestrictionSpecifiers RestrictionSpecifiers { get; }
    public CppFunctionFlags(CppEllipsisKind ellipsisKind, CppCallingConvention callingConvention, CppRestrictionSpecifiers restrictionSpecifiers);
    private static CppFunctionFlags();
    public CppEllipsisKind get_EllipsisKind();
    public CppCallingConvention get_CallingConvention();
    public CppRestrictionSpecifiers get_RestrictionSpecifiers();
    public sealed virtual bool Equals(CppFunctionFlags other);
    public CppFunctionFlags WithCallingConvention(CppCallingConvention conv);
    public CppFunctionFlags WithUnspecifiedCallingConvention();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppFunctionType : CppType {
    private CppFunctionBasicData myData;
    [CompilerGeneratedAttribute]
private CppQualType[] <ParameterTypes>k__BackingField;
    public CppQualType ReturnType { get; }
    public CppQualType[] ParameterTypes { get; }
    public CppFunctionFlags Flags { get; }
    public CppEllipsisKind EllipsisKind { get; }
    public CppCallingConvention CallingConvention { get; }
    public CppRestrictionSpecifiers RestrictionSpecifiers { get; }
    [CanBeNullAttribute]
public ICppExceptionSpecification ExceptionSpecification { get; }
    public CppFunctionType(CppQualType returnType, CppQualType[] types, CppFunctionFlags flags);
    public static CppFunctionType Create(CppQualType returnType, CppQualType[] types, CppFunctionFlags flags, ICppExceptionSpecification exceptionSpecification);
    public CppQualType get_ReturnType();
    [CompilerGeneratedAttribute]
public CppQualType[] get_ParameterTypes();
    public CppFunctionFlags get_Flags();
    public CppEllipsisKind get_EllipsisKind();
    public CppCallingConvention get_CallingConvention();
    public CppRestrictionSpecifiers get_RestrictionSpecifiers();
    public virtual ICppExceptionSpecification get_ExceptionSpecification();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public bool EqualsTypeIgnoringReturnType(Qualifiers lhsQuals, CppQualType rhs, ICppEqualityComparer engine);
    public bool EqualsTypeIgnoringReturnType(CppFunctionType c, ICppEqualityComparer engine, bool ignoreExceptionSpecification, bool ignoreCallingConvention);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppFunctionWithExceptionSpecificationType : CppFunctionType {
    [CompilerGeneratedAttribute]
private ICppExceptionSpecification <ExceptionSpecification>k__BackingField;
    public ICppExceptionSpecification ExceptionSpecification { get; }
    public CppFunctionWithExceptionSpecificationType(CppQualType returnType, CppQualType[] types, CppFunctionFlags flags, ICppExceptionSpecification exceptionSpecification);
    [CompilerGeneratedAttribute]
public virtual ICppExceptionSpecification get_ExceptionSpecification();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppFunctionWithTrailingReturnType : CppDecoratedType {
    public string DbgDescription { get; }
    public CppFunctionWithTrailingReturnType(CppQualType innerType);
    public virtual string get_DbgDescription();
    public virtual Result Accept(ICppVerboseTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppGenericParameterType : CppType {
    [CompilerGeneratedAttribute]
private ICppGenericParameter <ResolveEntity>k__BackingField;
    public ICppGenericParameter ResolveEntity { get; }
    public CppGenericParameterType(ICppGenericParameter ent);
    [CompilerGeneratedAttribute]
public ICppGenericParameter get_ResolveEntity();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Types.CppHasAutoTypeUtil : object {
    [ExtensionAttribute]
public static bool HasAutoType(CppQualType type);
    [ExtensionAttribute]
public static bool HasDecltypeAutoType(CppQualType type);
    [ExtensionAttribute]
public static bool HasAnyAutoType(CppQualType type);
    [ExtensionAttribute]
public static CppTypePlaceholders GetTypePlaceholders(CppQualType type);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppHasAutoTypeVisitor : CppAbstractTypeVisitor`1<CppTypePlaceholders> {
    public static CppHasAutoTypeVisitor INSTANCE;
    private static CppHasAutoTypeVisitor();
    public virtual CppTypePlaceholders VisitType(CppType t, Qualifiers q);
    public virtual CppTypePlaceholders VisitReference(CppQualType innerType, ReferenceFlag f);
    public virtual CppTypePlaceholders VisitTypeWithInnerType(CppTypeWithInnerType t, Qualifiers q);
    public virtual CppTypePlaceholders Visit(CppAutoType t, Qualifiers q);
    public virtual CppTypePlaceholders Visit(CppResolvedAutoType t, Qualifiers q);
    public virtual CppTypePlaceholders Visit(CppFunctionType ft, Qualifiers q);
    public virtual CppTypePlaceholders VisitUnresolvedFunctionType(CppUnresolvedFunctionType ft, Qualifiers q);
    public virtual CppTypePlaceholders Visit(CppUnresolvedFunctionSingleArgumentType ft, Qualifiers q);
    public virtual CppTypePlaceholders Visit(CppUnresolvedFunctionMultipleArgumentsType ft, Qualifiers q);
    public virtual CppTypePlaceholders Visit(CppReplacedFunctionType ft, Qualifiers q);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppIdentityTypeVisitorWithResolvedOutput : CppBasicIdentityTypeVisitor`1<ICppResolvedTypeFactory> {
    public CppIdentityTypeVisitorWithResolvedOutput(ICppResolvedTypeFactory typeFactory, bool optimizeForUnchangedTypes);
    public virtual CppQualType Visit(CppPendingClassType e, Qualifiers quals);
    public virtual CppQualType Visit(CppResolvedClassType e, Qualifiers quals);
    public virtual CppQualType Visit(CppResolvedEnumType e, Qualifiers quals);
    public virtual CppQualType Visit(CppTemplateParameterType e, Qualifiers quals);
    public virtual CppQualType Visit(CppGenericParameterType e, Qualifiers quals);
    public virtual CppQualType Visit(CppDependentType e, Qualifiers quals);
    public virtual CppQualType Visit(CppResolvedAutoType e, Qualifiers quals);
    public virtual CppQualType Visit(CppReplacedFunctionType e, Qualifiers quals);
    public virtual CppQualType Visit(CppTypedefType e, Qualifiers quals);
    public virtual CppQualType Visit(CppInstantiatedTemplateAliasType e, Qualifiers quals);
    public virtual CppQualType Visit(CppCEnumeratorType e, Qualifiers quals);
    public virtual CppQualType Visit(CppNamedType e, Qualifiers quals);
    public virtual CppQualType Visit(CppNameSuggestionType e, Qualifiers quals);
    public virtual CppQualType Visit(CppScopeSuggestionType e, Qualifiers quals);
    public virtual CppQualType Visit(CppFunctionWithTrailingReturnType e, Qualifiers quals);
    public virtual CppQualType Visit(CppDecoratedBuiltinTypeTraitType e, Qualifiers quals);
    public virtual CppQualType Visit(CppDeducedClassTypePlaceholder e, Qualifiers quals);
    public virtual CppQualType Visit(CppDependentInstantiatedTemplateAliasType e, Qualifiers quals);
    protected virtual ICppResolvedExpression VisitAutoConstraint(ICppResolvedExpression constraint, Boolean& changed);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppIdentityTypeVisitorWithUnresolvedOutput : CppBasicIdentityTypeVisitor`1<ICppSymbolTypeFactory> {
    public CppIdentityTypeVisitorWithUnresolvedOutput(ICppSymbolTypeFactory symbolTypeIntern, bool optimizeForUnchangedTypes);
    public virtual CppQualType Visit(CppClassType e, Qualifiers quals);
    public virtual CppQualType Visit(CppEnumType e, Qualifiers quals);
    public virtual CppQualType Visit(CppDeclarationSpecifierType e, Qualifiers quals);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppInstantiatedTemplateAliasModuleType : CppTypeWithInnerType {
    public CppSubstitutedTypeTemplateDeclaratorModuleEntity Declarator;
    public CppInstantiatedTemplateAliasModuleType(CppQualType underlyingType, CppSubstitutedTypeTemplateDeclaratorModuleEntity declarator);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppInstantiatedTemplateAliasType : CppDecoratedType {
    public CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity TemplateAlias;
    public string DbgDescription { get; }
    public CppInstantiatedTemplateAliasType(CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity templateAlias, CppQualType innerType);
    public virtual string get_DbgDescription();
    public virtual Result Accept(ICppVerboseTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppIntTypeKind : CppNumericTypeKind {
    public static CppIntTypeKind BOOL;
    public static CppIntTypeKind CHAR;
    public static CppIntTypeKind UCHAR;
    public static CppIntTypeKind SCHAR;
    public static CppIntTypeKind WCHAR_T;
    public static CppIntTypeKind CHAR8_T;
    public static CppIntTypeKind CHAR16_T;
    public static CppIntTypeKind CHAR32_T;
    public static CppIntTypeKind SHORT;
    public static CppIntTypeKind USHORT;
    public static CppIntTypeKind INT;
    public static CppIntTypeKind UINT;
    public static CppIntTypeKind LONG;
    public static CppIntTypeKind ULONG;
    public static CppIntTypeKind LONGLONG;
    public static CppIntTypeKind ULONGLONG;
    public static CppIntTypeKind __INT128;
    public static CppIntTypeKind __UINT128;
    private string myBaseName;
    private int myShortLong;
    [CompilerGeneratedAttribute]
private Signing <Signed>k__BackingField;
    public Signing Signed { get; }
    private CppIntTypeKind(string name, Signing s, string baseName, int shortLong);
    private static CppIntTypeKind();
    [CompilerGeneratedAttribute]
public Signing get_Signed();
    public bool IsRepresentable(ulong value, CppLanguageDialect dialect);
    public string GetNameParts(bool useSigned, bool useShortLong, Signing& signed, Int32& shortLong);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppInvalidTypeHandlingProxyTypeFactory : CppProxyTypeFactory {
    public CppInvalidTypeHandlingProxyTypeFactory(ICppResolvedTypeFactory inner);
    public virtual CppQualType GetPointerType(CppQualType t);
    public virtual CppQualType GetReferenceType(CppQualType t, ReferenceFlag isRval);
    public virtual CppQualType GetArrayType(CppQualType t, ICppExpression sizeExpr);
    public virtual CppQualType GetFunctionType(CppQualType returnType, CppQualType[] paramTypes, CppFunctionFlags flags, ICppExceptionSpecification exceptionSpecification);
    public virtual CppQualType GetDerefFunctionType(CppQualType returnType, CppQualType[] paramTypes, CppFunctionFlags flags, ICppExceptionSpecification exceptionSpecification);
    public virtual CppQualType GetMemberPointerType(CppQualType classType, CppQualType memberType);
    private CppQualType GetFunctionTypeImpl(CppQualType returnType, CppQualType[] paramTypes, CppFunctionFlags flags, ICppExceptionSpecification exceptionSpecification, bool allowFunctionReturnType);
}
public enum JetBrains.ReSharper.Psi.Cpp.Types.CppIsModifiableLValueResult : Enum {
    public int value__;
    public static CppIsModifiableLValueResult Yes;
    public static CppIsModifiableLValueResult ArrayType;
    public static CppIsModifiableLValueResult ReadOnlyType;
    public static CppIsModifiableLValueResult NonObjectType;
    public static CppIsModifiableLValueResult IncompleteType;
    public static CppIsModifiableLValueResult RValue;
}
internal class JetBrains.ReSharper.Psi.Cpp.Types.CppIsValidTypeForPresentationVisitor : CppAbstractTypeVisitor`1<bool> {
    public static CppIsValidTypeForPresentationVisitor Instance;
    private static CppIsValidTypeForPresentationVisitor();
    public virtual bool VisitType(CppType t, Qualifiers q);
    public virtual bool VisitTypeWithInnerType(CppTypeWithInnerType t, Qualifiers q);
    public virtual bool Visit(CppFunctionType e, Qualifiers quals);
    public virtual bool VisitReference(CppQualType inner, ReferenceFlag refFlag);
    public virtual bool Visit(CppUnknownType t, Qualifiers quals);
    public virtual bool Visit(CppResolvedClassType t, Qualifiers quals);
    public virtual bool Visit(CppPackExpansionType t, Qualifiers quals);
    public virtual bool Visit(CppMemberPointerType t, Qualifiers quals);
    private bool ReApply(CppQualType t);
    private bool ReApply(CppQualifiedNamePart name);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Types.CppKillDependenciesUtil : object {
    [ExtensionAttribute]
public static CppQualType KillDependencies(CppQualType type, CppTypeContext& tc);
    [ExtensionAttribute]
public static ICppClassResolveEntity TryKillDependenciesOfClass(ICppClassResolveEntity cls, CppTypeContext& tc);
    [ExtensionAttribute]
public static IEnumerable`1<ICppResolveEntity> TryKillDependenciesAndResolve(ICppScopeLikeResolveEntity depEnt, CppTypeContext& tc);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICppResolvedExpression TryKillDependencies(ICppResolvedExpression expr, CppTypeContext& tc);
    [CanBeNullAttribute]
public static ICppGroupedFunctionDeclaratorResolveEntity TryKillDependenciesOfFunctionWithAutoReturnType(CppGroupedFunctionDeclaratorResolveEntity func, CppTypeContext& tc);
    private static bool TryKillDependenciesOfClassParent(ICppClassResolveEntity& cls, CppKillDependenciesVisitor vis);
    private static ICppClassResolveEntity TryKillDependenciesOfClass(ICppClassResolveEntity cls, CppKillDependenciesVisitor vis);
    private static IEnumerable`1<ICppScopeLikeResolveEntity> TryKillDependenciesOfDependentResolveEntityHead(ICppDependentScopeLikeResolveEntity head, CppKillDependenciesVisitor vis);
    private static void TryKillDependenciesOfAllDependentResolveEntities(CppDependentResolveEntity dependent, CppKillDependenciesVisitor vis, ICollection`1<ICppResolveEntity> result);
    private static bool IsCorrectPrimaryTemplate(ICppClassResolveEntity cls);
    private static bool IsPrimaryTemplateClassOrHasPrimaryTemplateParents(ICppClassResolveEntity cls);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppLinkageArrayType : CppTypeWithInnerType {
    [CompilerGeneratedAttribute]
private int <SizeExpressionHashCode>k__BackingField;
    public int SizeExpressionHashCode { get; }
    public CppLinkageArrayType(CppQualType ref, int sizeExpressionHashCode);
    [CompilerGeneratedAttribute]
public int get_SizeExpressionHashCode();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppLinkageCliArrayType : CppType {
    [CompilerGeneratedAttribute]
private CppQualType <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RankExpressionHashCode>k__BackingField;
    public CppQualType ElementType { get; }
    public int RankExpressionHashCode { get; }
    public CppLinkageCliArrayType(CppQualType elementType, int rankExpressionHashCode);
    [CompilerGeneratedAttribute]
public CppQualType get_ElementType();
    [CompilerGeneratedAttribute]
public int get_RankExpressionHashCode();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppLinkageEntityType : CppType {
    [CompilerGeneratedAttribute]
private ICppLinkageEntity <LinkageEntity>k__BackingField;
    public ICppLinkageEntity LinkageEntity { get; }
    public CppLinkageEntityType(ICppLinkageEntity linkageEntity);
    [CompilerGeneratedAttribute]
public ICppLinkageEntity get_LinkageEntity();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppLinkageTemplateParameterType : CppType {
    [CompilerGeneratedAttribute]
private ICppLinkageTemplateParameter <TemplateParameter>k__BackingField;
    public ICppLinkageTemplateParameter TemplateParameter { get; }
    public CppLinkageTemplateParameterType(ICppLinkageTemplateParameter templateParameter);
    [CompilerGeneratedAttribute]
public ICppLinkageTemplateParameter get_TemplateParameter();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppLinkageVectorType : CppTypeWithInnerType {
    [CompilerGeneratedAttribute]
private int <SizeExpressionHashCode>k__BackingField;
    public int SizeExpressionHashCode { get; }
    public CppLinkageVectorType(CppQualType ref, int sizeExpressionHashCode);
    [CompilerGeneratedAttribute]
public int get_SizeExpressionHashCode();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppMarkFailureErrorConsumer : object {
    protected bool myLearnedError;
    protected CppTypeContext myTypeContext;
    public bool IsLearnedError { get; }
    public CppMarkFailureErrorConsumer(CppTypeContext& tc);
    public bool get_IsLearnedError();
    public virtual void CheckFirstOperandContextuallyConvertibleToBool(CppTypeAndCategory tc);
    public virtual void CheckSecondOperandContextuallyConvertibleToBool(CppTypeAndCategory tc);
    public virtual void CheckDerivedClassForDotMul(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT, CppQualType lhsClassT, CppQualType rhsClassT);
    public virtual void CheckArgumentIsNullPointerConstant(bool checkLeftArgument);
    public virtual void CheckAssignable(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public virtual void LearnCompoundAssignmentError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT, CppOperatorKind op);
    public virtual void LearnRemOrBitOpError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT, CppOperatorKind op);
    public virtual void LearnMulOrDivOpError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT, CppOperatorKind op);
    public virtual void LearnPlusPointerError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public virtual void LearnMinusPointerError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public virtual void LearnOtherInvalidBinaryArgumentsError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public virtual void LearnRelationalOpError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT, CppOperatorKind op);
    public virtual void LearnDotMulOpError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public virtual void LearnDerefMulOpError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public virtual void CheckForPointerAndQualificationConversions(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public virtual void CheckComparableCliHandles(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public virtual void LearnUsualArithmeticConversionsError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public virtual void CheckOperandContextuallyConvertibleToBool(CppTypeAndCategory tc);
    public virtual void LearnIndirectionError(CppTypeAndCategory lhsT);
    public virtual void LearnUnaryPlusError(CppTypeAndCategory lhsT);
    public virtual void LearnPrefixIncrementError(CppTypeAndCategory lhsT);
    public virtual void LearnPrefixDecrementError(CppTypeAndCategory lhsT);
    public virtual void LearnPrefixDecrementIsBoolError();
    public virtual void LearnUnaryMinusError(CppTypeAndCategory lhsT);
    public virtual void LearnBitComplementError(CppTypeAndCategory lhsT);
    private void CheckConvertibleToBool(CppTypeAndCategory tc);
}
public static class JetBrains.ReSharper.Psi.Cpp.Types.CppMemberLayoutUtil : object {
    public static Nullable`1<int> GetOffsetOfMember(ICppClassResolveEntity clazz, ICppDeclaratorResolveEntity member, CppTypeContext& tc);
    public static Nullable`1<MemberLayout> GetMemberLayout(ICppClassResolveEntity clazz, ICppDeclaratorResolveEntity member, CppTypeContext& tc);
    private static void Apply(ICppClassResolveEntity clazz, CppTypeContext& tc, TMemberProcessor& memberProcessor);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppMemberPointerType : CppTypeWithInnerType {
    [CompilerGeneratedAttribute]
private CppQualType <ClassType>k__BackingField;
    public CppQualType ClassType { get; }
    public CppQualType MemberType { get; }
    public CppMemberPointerType(CppQualType clsT, CppQualType memberType);
    [CompilerGeneratedAttribute]
public CppQualType get_ClassType();
    public CppQualType get_MemberType();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppModuleEntityType : CppType {
    public ICppTypeModuleEntity ModuleEntity;
    public CppModuleEntityType(ICppTypeModuleEntity moduleEntity);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppNamedParameterType : CppDecoratedType {
    [CompilerGeneratedAttribute]
private ICppDecoratedFunctionParameter <Parameter>k__BackingField;
    public ICppDecoratedFunctionParameter Parameter { get; }
    public string DbgDescription { get; }
    public CppNamedParameterType(CppQualType innerType, ICppDecoratedFunctionParameter parameter);
    [CompilerGeneratedAttribute]
public ICppDecoratedFunctionParameter get_Parameter();
    public virtual string get_DbgDescription();
    public virtual TResult Accept(ICppVerboseTypeVisitor`1<TResult> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppNamedType : CppDecoratedType {
    [CompilerGeneratedAttribute]
private CppQualifiedName <Name>k__BackingField;
    public CppQualifiedName Name { get; }
    public string DbgDescription { get; }
    public CppNamedType(CppQualifiedName name, CppQualType innerType);
    [CompilerGeneratedAttribute]
public CppQualifiedName get_Name();
    public virtual string get_DbgDescription();
    public virtual Result Accept(ICppVerboseTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppNameSuggestionType : CppDecoratedType {
    [CompilerGeneratedAttribute]
private CppQualifiedName <SuggestedName>k__BackingField;
    public CppQualifiedName SuggestedName { get; }
    public CppNameSuggestionType(CppQualType innerType, CppQualifiedName suggestedName);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
private void CheckRedundancy();
    [CompilerGeneratedAttribute]
public CppQualifiedName get_SuggestedName();
    public virtual Result Accept(ICppVerboseTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal static bool <CheckRedundancy>g__HasDefaults|1_0(ICppTemplateResolveEntityBase template);
    [CompilerGeneratedAttribute]
internal static bool <CheckRedundancy>g__AreStructurallyEqual|1_1(CppSubstitutionId substitutionId, ICppTemplateResolveEntityBase template, ICppTemplateArgument[] templateArguments);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppNoExceptSpecification : object {
    public static CppNoExceptSpecification InstanceFalse;
    private ICppExpression myArgument;
    public CppNoExceptSpecification(ICppExpression argument);
    private static CppNoExceptSpecification();
    public sealed virtual bool HasArgument();
    public sealed virtual ICppExpression GetArgument();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppNoExceptSpecificationWithoutArg : object {
    public static CppNoExceptSpecificationWithoutArg Instance;
    private static CppNoExceptSpecificationWithoutArg();
    public sealed virtual bool HasArgument();
    public sealed virtual ICppExpression GetArgument();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppNoopTypingErrorConsumer : object {
    public static CppNoopTypingErrorConsumer Instance;
    private static CppNoopTypingErrorConsumer();
    public sealed virtual void CheckFirstOperandContextuallyConvertibleToBool(CppTypeAndCategory tc);
    public sealed virtual void CheckSecondOperandContextuallyConvertibleToBool(CppTypeAndCategory tc);
    public sealed virtual void CheckDerivedClassForDotMul(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT, CppQualType lhsClassT, CppQualType rhsClassT);
    public sealed virtual void CheckArgumentIsNullPointerConstant(bool checkLeftArgument);
    public sealed virtual void CheckAssignable(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public sealed virtual void LearnCompoundAssignmentError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT, CppOperatorKind op);
    public sealed virtual void LearnRemOrBitOpError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT, CppOperatorKind op);
    public sealed virtual void LearnMulOrDivOpError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT, CppOperatorKind op);
    public sealed virtual void LearnPlusPointerError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public sealed virtual void LearnMinusPointerError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public sealed virtual void LearnOtherInvalidBinaryArgumentsError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public sealed virtual void LearnRelationalOpError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT, CppOperatorKind op);
    public sealed virtual void LearnDotMulOpError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public sealed virtual void LearnDerefMulOpError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public sealed virtual void CheckForPointerAndQualificationConversions(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public sealed virtual void CheckComparableCliHandles(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public sealed virtual void LearnUsualArithmeticConversionsError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public sealed virtual void LearnSubscriptError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public sealed virtual void CheckOperandContextuallyConvertibleToBool(CppTypeAndCategory tc);
    public sealed virtual void LearnIndirectionError(CppTypeAndCategory lhsT);
    public sealed virtual void LearnUnaryPlusError(CppTypeAndCategory lhsT);
    public sealed virtual void LearnPrefixIncrementError(CppTypeAndCategory lhsT);
    public sealed virtual void LearnPrefixDecrementError(CppTypeAndCategory lhsT);
    public sealed virtual void LearnPrefixDecrementIsBoolError();
    public sealed virtual void LearnUnaryMinusError(CppTypeAndCategory lhsT);
    public sealed virtual void LearnBitComplementError(CppTypeAndCategory lhsT);
    public void CheckArgumentIsQualifiedId(CppTypeAndCategory tc);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppNormalizeFunctionTypeInternProxy : CppProxyTypeFactory {
    public CppNormalizeFunctionTypeInternProxy(ICppResolvedTypeFactory inner);
    public virtual CppQualType GetFunctionType(CppQualType returnType, CppQualType[] paramTypes, CppFunctionFlags flags, ICppExceptionSpecification exceptionSpecification);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppNullDeclarationSpecifierTypeBuilder : object {
    public static CppNullDeclarationSpecifierTypeBuilder Instance;
    private static CppNullDeclarationSpecifierTypeBuilder();
    public sealed virtual void LearnClassTag();
    public sealed virtual void LearnResolvedClassType(ICppClassResolveEntity ent);
    public sealed virtual void LearnResolvedType(CppQualType t);
    public sealed virtual CppQualType ComposeResultType();
    public sealed virtual void LearnTokenType(TokenNodeType tt);
    public sealed virtual void LearnDecltypeAuto();
    public sealed virtual void LearnBuiltinTypeTraitType(CppQualType argument, CppBuiltinTypeTraitKind _);
    public sealed virtual void LearnConceptName(CppQualifiedName name, bool decltypeAuto);
    public sealed virtual void LearnQualifiedName(CppQualifiedName name);
    public sealed virtual void LearnElaboratedReference(CppQualifiedName name, CppClassTag tag);
    public sealed virtual void LearnClassType(ICppClassSymbol sym);
    public sealed virtual void LearnMatrixSpecifier(HlslMatrixSpecifierBuilder& matrixTypeSpecifier);
    public sealed virtual void LearnHlslBufferComponentType(CppQualType componentType);
    public void LearnTokenType(TokenNodeType tt, ITokenNode location);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppNullptrType : CppType {
    public static CppNullptrType INSTANCE;
    private static CppNullptrType();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppNullTypeBuilder : object {
    private bool myLeftSideWasSomething;
    private RightSideState myRightSideState;
    public CppNullTypeBuilder(IHighlightingConsumer consumer);
    public sealed virtual ICppResolvedTypeBuilder CreateResolvedTypeBuilderForPartInParens();
    public sealed virtual void LearnTypePartInParens(ICppResolvedTypeBuilder builder);
    public sealed virtual CppQualType ComposeResultType();
    public sealed virtual void LearnBaseType(CppQualType type);
    public sealed virtual void LearnTokenType(TokenNodeType tt);
    public sealed virtual void LearnTokenType(TokenNodeType tt, ITokenNode location);
    public sealed virtual void LearnPtr(TokenNodeType tt, CVQualifiers quals);
    public sealed virtual void LearnNameQualifierPtrName(CppQualifiedName name, CVQualifiers quals);
    public sealed virtual bool InnerTypeIsEmpty();
    public sealed virtual void LearnArraySize(ICppExpression expr);
    public sealed virtual void LearnUnknownArraySize();
    public sealed virtual void LearnFunctionParameters(CppSmallArray`1<CppParameterDeclaratorSymbol> symbols, CppEllipsisKind ellipsisKind, CVQualifiers cvQuals, FuncRefQualifier refQual, CppQualType trailingReturnType, CppRestrictionSpecifiers restrictionSpecifiers, ICppExceptionSpecification exceptionSpecification);
    public sealed virtual void LearnReplacedFunction(CppParameterListResolveEntity resolveEntity, CppEllipsisKind ellipsisKind, CVQualifiers cvQuals, FuncRefQualifier refQual, CppQualType trailingReturnType, CppRestrictionSpecifiers restrictionSpecifiers, ICppExceptionSpecification exceptionSpecification);
    public sealed virtual void LearnCallingConvention(CppCallingConvention cc);
    public sealed virtual void LearnCallingConvention(ICppCallingConventionBuilder ccBuilder);
    public sealed virtual ICppUnresolvedTypeBuilder CreateUnresolvedTypeBuilderForPartInParens();
    public sealed virtual void LearnTypePartInParens(ICppUnresolvedTypeBuilder builder);
    public sealed virtual void LearnDeclarationSpecifierType();
    public sealed virtual bool IsFunction();
    public void LearnElaboratedReference(CppQualifiedName name, CppClassTag tag);
    public void LearnClassType(ICppClassSymbol sym);
    public void LearnPackExpansion();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppNumericType : CppType {
    [CompilerGeneratedAttribute]
private CppNumericTypeKind <Kind>k__BackingField;
    public CppNumericTypeKind Kind { get; private set; }
    public CppNumericType(CppNumericTypeKind kind);
    [CompilerGeneratedAttribute]
public CppNumericTypeKind get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(CppNumericTypeKind value);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public void SetKind(CppNumericTypeKind kind);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppNumericTypeKind : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    protected CppNumericTypeKind(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    public abstract virtual int GetConversionRank(CppLanguageDialect dialect);
    public abstract virtual int GetSize(CppLanguageDialect dialect);
    public virtual string ToString();
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Types.CppNumericTypeKindUtil : object {
    public static CppPredefinedType GetPredefinedTypeForNumKind(CppNumericTypeKind nk);
    [ExtensionAttribute]
public static byte GetIdByCppNumericTypeKind(CppNumericTypeKind kind);
    public static CppNumericTypeKind GetCppNumericTypeKindById(byte id);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppPackExpansionType : CppTypeWithInnerType {
    [CompilerGeneratedAttribute]
private CppSubstitutionContext <ExpansionClosure>k__BackingField;
    public CppQualType Pattern { get; }
    public CppSubstitutionContext ExpansionClosure { get; }
    public string DbgDescription { get; }
    public CppPackExpansionType(CppQualType pattern);
    public CppPackExpansionType(CppQualType pattern, CppSubstitutionContext expansionClosure);
    public CppQualType get_Pattern();
    [CompilerGeneratedAttribute]
public CppSubstitutionContext get_ExpansionClosure();
    public virtual string get_DbgDescription();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppPendingClassType : CppType {
    private CppPendingActionWithResultActivator`1<ICppClassResolveEntity> myClassActivator;
    public CppPendingClassType(CppPendingActionWithResultActivator`1<ICppClassResolveEntity> activator);
    public void Init(CppPendingActionWithResultActivator`1<ICppClassResolveEntity> activator);
    public void Clear();
    public ICppClassResolveEntity MergeAndGetClass();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
}
public enum JetBrains.ReSharper.Psi.Cpp.Types.CppPointerConversionKind : Enum {
    public int value__;
    public static CppPointerConversionKind No;
    public static CppPointerConversionKind Yes;
    public static CppPointerConversionKind CIntegralPointer;
    public static CppPointerConversionKind SourceTypeIsIncomplete;
    public static CppPointerConversionKind TargetTypeIsIncomplete;
    public static CppPointerConversionKind AmbiguousOrInaccessibleBase;
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppPointerType : CppTypeWithInnerType {
    public CppPointerType(CppQualType ref);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Cpp.Types.CppPredefinedType : Enum {
    public int value__;
    public static CppPredefinedType Half;
    public static CppPredefinedType Float;
    public static CppPredefinedType Double;
    public static CppPredefinedType LongDouble;
    public static CppPredefinedType Int;
    public static CppPredefinedType UInt;
    public static CppPredefinedType Long;
    public static CppPredefinedType ULong;
    public static CppPredefinedType LongLong;
    public static CppPredefinedType ULongLong;
    public static CppPredefinedType Int128;
    public static CppPredefinedType UInt128;
    public static CppPredefinedType Bool;
    public static CppPredefinedType Char;
    public static CppPredefinedType UChar;
    public static CppPredefinedType SChar;
    public static CppPredefinedType WChar;
    public static CppPredefinedType Char8;
    public static CppPredefinedType Char16;
    public static CppPredefinedType Char32;
    public static CppPredefinedType Short;
    public static CppPredefinedType UShort;
    public static CppPredefinedType Void;
    public static CppPredefinedType Nullptr;
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppPredefinedTypes : object {
    public static int ArithmeticStart;
    public static int ArithmeticEnd;
    public static int PromotedStart;
    public static int PromotedEnd;
    public static int IntegralStart;
    public static int IntegralEnd;
    public static int PromotedIntegralStart;
    public static int PromotedIntegralEnd;
    public static int FloatingPointStart;
    public static int FloatingPointEnd;
    private static CppQualType[] ourAllPredefinedTypes;
    public static CppQualType Half { get; }
    public static CppQualType Float { get; }
    public static CppQualType Double { get; }
    public static CppQualType LongDouble { get; }
    public static CppQualType Int { get; }
    public static CppQualType UInt { get; }
    public static CppQualType Long { get; }
    public static CppQualType ULong { get; }
    public static CppQualType LongLong { get; }
    public static CppQualType ULongLong { get; }
    public static CppQualType Int128 { get; }
    public static CppQualType UInt128 { get; }
    public static CppQualType Bool { get; }
    public static CppQualType Char { get; }
    public static CppQualType UChar { get; }
    public static CppQualType SChar { get; }
    public static CppQualType WChar { get; }
    public static CppQualType Char8 { get; }
    public static CppQualType Char16 { get; }
    public static CppQualType Char32 { get; }
    public static CppQualType Short { get; }
    public static CppQualType UShort { get; }
    public static CppQualType Void { get; }
    public static CppQualType Nullptr { get; }
    private static CppPredefinedTypes();
    public static CppQualType get_Half();
    public static CppQualType get_Float();
    public static CppQualType get_Double();
    public static CppQualType get_LongDouble();
    public static CppQualType get_Int();
    public static CppQualType get_UInt();
    public static CppQualType get_Long();
    public static CppQualType get_ULong();
    public static CppQualType get_LongLong();
    public static CppQualType get_ULongLong();
    public static CppQualType get_Int128();
    public static CppQualType get_UInt128();
    public static CppQualType get_Bool();
    public static CppQualType get_Char();
    public static CppQualType get_UChar();
    public static CppQualType get_SChar();
    public static CppQualType get_WChar();
    public static CppQualType get_Char8();
    public static CppQualType get_Char16();
    public static CppQualType get_Char32();
    public static CppQualType get_Short();
    public static CppQualType get_UShort();
    public static CppQualType get_Void();
    public static CppQualType get_Nullptr();
    public static CppQualType GetPredefinedType(CppPredefinedType t);
    public static CppQualType[] GetAllPredefinedTypes();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppProxyTypeFactory : object {
    private ICppVerboseTypeVisitor`1<CppQualType> myIdentityTypeVisitor;
    [CompilerGeneratedAttribute]
private ICppResolvedTypeFactory <InnerIntern>k__BackingField;
    public ICppResolvedTypeFactory InnerIntern { get; }
    public bool IgnoresScopeSuggestions { get; }
    public bool IgnoresNameSuggestions { get; }
    public ICppRootFileResolveEntitiesCache ResolveCache { get; }
    protected CppProxyTypeFactory(ICppResolvedTypeFactory inner);
    [CompilerGeneratedAttribute]
public ICppResolvedTypeFactory get_InnerIntern();
    public virtual CppQualType GetPointerType(CppQualType t);
    public virtual CppQualType GetReferenceType(CppQualType t, ReferenceFlag isRval);
    public virtual CppQualType GetArrayType(CppQualType t, ICppExpression sizeExpr);
    public virtual CppQualType GetVectorType(CppQualType t, ICppExpression sizeExpr);
    public virtual CppPackExpansionType GetPackExpansionType(CppQualType t);
    public virtual CppQualType GetFunctionType(CppQualType returnType, CppQualType[] paramTypes, CppFunctionFlags flags, ICppExceptionSpecification exceptionSpecification);
    public virtual CppQualType GetDerefFunctionType(CppQualType returnType, CppQualType[] paramTypes, CppFunctionFlags flags, ICppExceptionSpecification exceptionSpecification);
    public virtual CppQualType GetTyperefType(CppQualifiedName qualName, CppClassTag tag);
    public virtual CppQualType GetMemberPointerType(CppQualType classType, CppQualType memberType);
    public virtual CppQualType GetUnknownType(CppUnknownEntityInfo info);
    public virtual CppQualType GetNamedParameterType(ICppDecoratedFunctionParameter parameter, CppQualType innerType);
    public virtual bool get_IgnoresScopeSuggestions();
    public virtual bool get_IgnoresNameSuggestions();
    public virtual ICppRootFileResolveEntitiesCache get_ResolveCache();
    public virtual CppLanguageDialect GetDialect();
    public virtual CppQualType GetReplacedFunctionType(CppQualType returnType, CppParameterListResolveEntity resolveEntity, CppFunctionFlags flags, CppQualType trailingReturnType, ICppExceptionSpecification exceptionSpecification);
    public virtual CppQualType GetResolvedTypeForEntity(ICppClassResolveEntity classEnt);
    public virtual CppQualType GetTemplateParameterType(ICppTypeTemplateParameterOrPack templParameterEnt);
    public virtual CppQualType GetGenericParameterType(ICppGenericParameter genericParameterEnt);
    public virtual CppQualType GetDependentType(ICppDependentTypeResolveEntity depEnt);
    public virtual CppQualType GetTypedefType(CppQualType innerType, ICppGroupedTypeDeclaratorResolveEntity decl);
    public virtual CppQualType GetInstantiatedTemplateAliasType(CppQualType innerType, CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity alias);
    public virtual CppQualType GetCEnumeratorType(CppQualType innerType, ICppClassResolveEntity decl);
    public virtual CppQualType GetNamedType(CppQualType innerType, CppQualifiedName name);
    public virtual CppQualType GetNameSuggestionType(CppQualType innerType, CppQualifiedName name);
    public virtual CppQualType GetScopeSuggestionType(CppQualType innerType, CppQualType scopeType);
    public virtual CppQualType GetFunctionWithTrailingReturnType(CppQualType functionType);
    public virtual CppQualType GetDeducedClassTypePlaceholder(ICppDeducibleTypeTemplateResolveEntity classTemplate);
    public virtual CppQualType GetAutoType(bool decltypeAuto, CppQualifiedName concept);
    public virtual CppQualType GetResolvedAutoType(bool decltypeAuto, CppQualifiedName concept, ICppResolvedExpression constraint);
    public virtual CppQualType GetCliHandleType(CppQualType t);
    public virtual CppQualType GetCliInteriorPointerType(CppQualType t);
    public virtual CppQualType GetCliPinPointerType(CppQualType t);
    public virtual CppQualType GetCliArrayType(CppQualType t, ICppExpression rankExpr);
    public virtual CppQualType GetCachedType(ICppRawDeclaratorResolveEntity key);
    public virtual CppQualType GetCachedType(CppGroupedFunctionDeclaratorResolveEntity key);
    public virtual CppQualType TryGetCachedType(ICppRawDeclaratorResolveEntity key);
    public virtual ICppVerboseTypeVisitor`1<CppQualType> GetIdentityTypeVisitor();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Types.CppQualType : ValueType {
    private CppType myInternalType;
    private ushort myPackedQuals;
    private ushort myDeclSpecPlacement;
    public Qualifiers TypeQualifiers { get; }
    public CppType InternalType { get; }
    public CVQualifiers CVQuals { get; }
    public bool IsConst { get; }
    public bool IsVolatile { get; }
    public ReferenceFlag RefFlag { get; }
    public bool IsRef { get; }
    public bool IsRefLval { get; }
    public bool IsRefRval { get; }
    public bool IsRefCliTracking { get; }
    public InputQualifiers InputQuals { get; }
    public bool IsIn { get; }
    public bool IsOut { get; }
    public string DbgDescription { get; }
    public CppQualType(CppType internalType);
    public CppQualType(CppType internalType, Qualifiers quals);
    public CppQualType(CppType internalType, Qualifiers quals, CppDeclSpecPlacement placement);
    public CppQualType(CppType internalType, Qualifiers quals, CppDeclSpecPlacement placement, InputQualifiers inputQuals);
    public CppQualType(CppType internalType, ushort packedQuals, ushort packedDeclSpecPlacement);
    public Qualifiers get_TypeQualifiers();
    public CppType get_InternalType();
    public TType InternalAs();
    public CppType InternalUntyped();
    public CppType InternalDecoratedUntyped();
    public TType InternalSafeAs();
    public bool InternalIs();
    public CppQualType WithoutQuals();
    public CppQualType WithChangedQuals(Qualifiers quals);
    public CppQualType WithAppendedQuals(Qualifiers quals);
    public CppQualType WithAppendedQuals(Qualifiers quals, InputQualifiers inputQuals);
    public CppQualType WithQualsOf(CppQualType typeForQuals);
    public CppQualType WithAppendedCVQuals(CVQualifiers quals);
    public CppQualType WithChangedCVQuals(CVQualifiers quals);
    public CppQualType ClearCVQuals();
    public CppQualType WithChangedRefFlag(ReferenceFlag flag);
    public CppQualType WithChangedFuncRefQual(FuncRefQualifier qual);
    public CVQualifiers get_CVQuals();
    public bool get_IsConst();
    public bool get_IsVolatile();
    public FuncRefQualifier GetFuncRefQual();
    public ReferenceFlag get_RefFlag();
    public bool get_IsRef();
    public bool get_IsRefLval();
    public bool get_IsRefRval();
    public bool get_IsRefCliTracking();
    public bool IsEmptyType();
    public static CppQualType EmptyType();
    public bool IsNullType();
    public static CppQualType NullType();
    public bool ReferentiallyEquals(CppQualType other);
    [DebuggerStepThroughAttribute]
public Qualifiers GetRawQualifiers();
    public InputQualifiers get_InputQuals();
    public bool get_IsIn();
    public bool get_IsOut();
    public CppQualType WithInputQualifiers(InputQualifiers qualifiers);
    public CppDeclSpecPlacement GetDeclSpecPlacement();
    public CppQualType WithDeclSpecPlacement(CppDeclSpecPlacement placement);
    public virtual string ToString();
    public Result Accept(ICppTypeVisitor`1<Result> visitor);
    public bool EqualsType(CppQualType rhs, ICppEqualityComparer engine);
    public void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public string get_DbgDescription();
    public ushort GetPackedQualifiers();
    public ushort GetPackedDeclSpecPlacement();
    private bool IsValid();
    private static bool IsCleanReference(CppQualType t);
    [CanBeNullAttribute]
public TType InternalDecoratedAs();
    private CppType GetTypeThroughTypedefs();
    private static ushort MakePackedQualifiers(Qualifiers rawQuals, Qualifiers cachedTypeQualifiers, InputQualifiers inputQualifiers);
    private static ushort MakePackedQualifiers(CppType internalType, Qualifiers rawQuals, InputQualifiers inputQualifiers);
    private static Qualifiers GetCachedTypeQualifiers(ushort packedQuals);
    [DebuggerStepThroughAttribute]
internal static Qualifiers GetRawQualifiers(ushort packedQuals);
    private static InputQualifiers GetInputQualifiers(ushort packedQuals);
    [CompilerGeneratedAttribute]
internal static Qualifiers <MakePackedQualifiers>g__ComputeTypeQualifiers|74_0(CppType internalType, Qualifiers rawQuals);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppQualTypeDeepNonSemanticallyComparer : object {
    public static CppQualTypeDeepNonSemanticallyComparer INSTANCE;
    private static CppQualTypeDeepNonSemanticallyComparer();
    public sealed virtual bool Equals(CppQualType lhs, CppQualType rhs);
    public sealed virtual int GetHashCode(CppQualType obj);
}
public static class JetBrains.ReSharper.Psi.Cpp.Types.CppQualTypeEq : object {
    public static bool ResolvedEquals(CppQualType lhs, CppQualType rhs);
    public static int ResolvedHashCode(CppQualType obj);
    public static bool UnresolvedEquals(CppQualType lhs, CppQualType rhs);
    public static int UnresolvedHashCode(CppQualType obj);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppQualTypeReferentiallyCompare : object {
    public static CppQualTypeReferentiallyCompare INSTANCE;
    private static CppQualTypeReferentiallyCompare();
    public sealed virtual bool Equals(CppQualType lhs, CppQualType rhs);
    public sealed virtual int GetHashCode(CppQualType lhs);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppQualTypeResolvedComparer : object {
    public static CppQualTypeResolvedComparer INSTANCE;
    private static CppQualTypeResolvedComparer();
    public sealed virtual bool Equals(CppQualType lhs, CppQualType rhs);
    public sealed virtual int GetHashCode(CppQualType obj);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppQualTypeUnresolvedComparer : object {
    public static CppQualTypeUnresolvedComparer INSTANCE;
    private static CppQualTypeUnresolvedComparer();
    public virtual bool Equals(CppQualType lhs, CppQualType rhs);
    public virtual int GetHashCode(CppQualType obj);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppRebindNamedTypeVisitor : CppIdentityTypeVisitorWithResolvedOutput {
    private CppViewPos myViewPos;
    private CppRebindNamedTypeVisitor myParamsVisitor;
    public CppRebindNamedTypeVisitor(CppViewPos& vp);
    public CppRebindNamedTypeVisitor(CppViewPos& vp, CppViewPos& paramsViewPos);
    public virtual CppQualType Visit(CppNamedType t, Qualifiers q);
    public virtual CppQualType Visit(CppTypedefType t, Qualifiers q);
    private CppQualifiedName RebindName(CppQualifiedName name);
    private static CppQualifiedName RebindResolveEntityName(FrugalLocalList`1<CppQualifiedName> hints, ICppResolveEntity ent, CppViewPos& vp);
    public virtual CppQualType Visit(CppFunctionWithTrailingReturnType e, Qualifiers quals);
    protected virtual CppQualType[] VisitFunctionParams(CppQualType[] types, Boolean& changed);
    protected virtual ICppExceptionSpecification VisitExceptionSpecification(ICppExceptionSpecification exceptionSpecification, Boolean& changed);
}
internal class JetBrains.ReSharper.Psi.Cpp.Types.CppRecreateTopLevelDecorationsVisitor : CppAbstractVerboseTypeVisitor`1<CppQualType> {
    private ICppResolvedTypeFactory myTypeFactory;
    private CppQualType myReplacement;
    public CppRecreateTopLevelDecorationsVisitor(ICppResolvedTypeFactory tf, CppQualType replacement);
    public virtual CppQualType VisitType(CppType t, Qualifiers quals);
    public virtual CppQualType VisitReference(CppQualType innerType, ReferenceFlag f);
    public virtual CppQualType VisitTypeWithDeclSpecPlacement(CppQualType innerType, CppDeclSpecPlacement placement);
    public virtual CppQualType Visit(CppTypedefType t, Qualifiers q);
    public virtual CppQualType Visit(CppCEnumeratorType t, Qualifiers q);
    public virtual CppQualType Visit(CppNamedType t, Qualifiers q);
    public virtual CppQualType Visit(CppNamedParameterType t, Qualifiers q);
    public virtual CppQualType Visit(CppNameSuggestionType t, Qualifiers q);
    public virtual CppQualType Visit(CppScopeSuggestionType t, Qualifiers q);
    public virtual CppQualType Visit(CppFunctionWithTrailingReturnType t, Qualifiers q);
    private CppQualType ReApply(CppQualType t);
}
public enum JetBrains.ReSharper.Psi.Cpp.Types.CppReferenceRelation : Enum {
    public int value__;
    public static CppReferenceRelation Incompatible;
    public static CppReferenceRelation Related;
    public static CppReferenceRelation CompatibleWithAddedQualification;
    public static CppReferenceRelation Compatible;
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppReferenceType : CppTypeWithInnerType {
    public CppReferenceType(CppQualType inner);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer consumer);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Cpp.Types.CppRemoveRedundantQualificationVisitor : CppIdentityTypeVisitorWithResolvedOutput {
    private CppViewPos myViewPos;
    private ICppResolveEntity myQualifier;
    public CppRemoveRedundantQualificationVisitor(ICppResolveEntity qualifier, CppTypeContext& tc);
    public virtual CppQualType Visit(CppFunctionWithTrailingReturnType e, Qualifiers quals);
    public virtual CppQualType Visit(CppNameSuggestionType e, Qualifiers quals);
    public virtual CppQualType Visit(CppNamedType e, Qualifiers quals);
    private CppQualifiedName VisitTypeName(CppQualifiedName name);
    private CppQualifiedName TryGetShorterQualifier(CppQualifiedName qualifier);
    private static ICppResolveEntity GetOneResolveEntityIfOk(CppLookupResult lr);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Types.CppReplaceDeclarationSpecifiersTypeUtil : object {
    [ExtensionAttribute]
public static CppReplaceDeclSpecsTypeReturn ReplaceDeclarationSpecifiers(CppQualType t, CppQualType replacement, ICppResolvedTypeFactory tf);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppReplaceDeclarationSpecifiersTypeVisitor : object {
    private ICppResolvedTypeFactory myTypeFactory;
    private CppQualType myReplacement;
    private int myStepsAfterReplacement;
    [CompilerGeneratedAttribute]
private bool <ShouldReplaceRValueRefWithLValue>k__BackingField;
    [CompilerGeneratedAttribute]
private CVQualifiers <QualifiersToRemoveFromDeclSpecs>k__BackingField;
    public bool ShouldReplaceRValueRefWithLValue { get; private set; }
    public CVQualifiers QualifiersToRemoveFromDeclSpecs { get; private set; }
    public CppReplaceDeclarationSpecifiersTypeVisitor(CppQualType replacement, ICppResolvedTypeFactory tf);
    [CompilerGeneratedAttribute]
public bool get_ShouldReplaceRValueRefWithLValue();
    [CompilerGeneratedAttribute]
private void set_ShouldReplaceRValueRefWithLValue(bool value);
    [CompilerGeneratedAttribute]
public CVQualifiers get_QualifiersToRemoveFromDeclSpecs();
    [CompilerGeneratedAttribute]
private void set_QualifiersToRemoveFromDeclSpecs(CVQualifiers value);
    public sealed virtual CppQualType Visit(CppAutoType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppResolvedAutoType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppArrayType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppVectorType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppFunctionType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppUnresolvedFunctionWithoutArgumentsType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppUnresolvedFunctionSingleArgumentType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppUnresolvedFunctionMultipleArgumentsType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppReplacedFunctionType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppNumericType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppPointerType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppTemplateParameterType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppGenericParameterType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppPackExpansionType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppDependentType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppTypeReference t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppElaboratedTypeReference t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppVoidType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppClassType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppPendingClassType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppUnknownType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppResolvedClassType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppNullptrType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppEnumType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppResolvedEnumType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppDecoratedType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppMemberPointerType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppDeclarationSpecifierType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppCliHandleType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppCliInteriorPointerType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppCliPinPointerType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppBuiltinTypeTraitType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppCliArrayType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppDeducedClassTypePlaceholder t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppDependentInstantiatedTemplateAliasType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppLinkageEntityType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppDependentLinkageEntityType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppLinkageTemplateParameterType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppLinkageArrayType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppLinkageVectorType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppLinkageCliArrayType t, Qualifiers q);
    public sealed virtual CppQualType VisitReference(CppQualType innerType, ReferenceFlag flag);
    public sealed virtual CppQualType VisitTypeWithDeclSpecPlacement(CppQualType innerType, CppDeclSpecPlacement placement);
    public sealed virtual CppQualType Visit(HlslVectorType t, Qualifiers q);
    public sealed virtual CppQualType Visit(HlslMatrixType t, Qualifiers q);
    public sealed virtual CppQualType Visit(HlslSamplerType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppModuleEntityType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppInstantiatedTemplateAliasModuleType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppDependentInstantiatedTemplateAliasModuleType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppTypedefModuleType t, Qualifiers q);
    public sealed virtual CppQualType Visit(CppDeducedClassTypePlaceholderModuleType t, Qualifiers q);
    public CppQualType Visit(CppTypedefType t, Qualifiers q);
    public CppQualType Visit(CppCEnumeratorType t, Qualifiers q);
    public CppQualType Visit(CppNamedType t, Qualifiers q);
    public CppQualType Visit(CppNameSuggestionType t, Qualifiers q);
    public CppQualType Visit(CppNamedParameterType t, Qualifiers q);
    private CppQualType ReApply(CppQualType t);
    private CppQualType DoReplacement(Qualifiers q);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppReplaceDeclSpecsTypeReturn : ValueType {
    public CppQualType ResultType;
    public CVQualifiers QualifiersToRemoveFromDeclSpecs;
    public bool ShouldReplaceRValueRefWithLValue;
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppReplacedFunctionType : CppTypeWithInnerType {
    private CppFunctionFlags myFlags;
    [CompilerGeneratedAttribute]
private CppParameterListResolveEntity <ResolveEntity>k__BackingField;
    [CompilerGeneratedAttribute]
private CppQualType <TrailingReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppExceptionSpecification <ExceptionSpecification>k__BackingField;
    public CppFunctionFlags Flags { get; }
    public CppParameterListResolveEntity ResolveEntity { get; }
    public CppQualType ReturnType { get; }
    public CppQualType TrailingReturnType { get; }
    [CanBeNullAttribute]
public ICppExceptionSpecification ExceptionSpecification { get; }
    public CppReplacedFunctionType(CppQualType returnType, CppParameterListResolveEntity resolveEntity, CppFunctionFlags flags, CppQualType trailingReturnType, ICppExceptionSpecification exceptionSpecification);
    public CppFunctionFlags get_Flags();
    [CompilerGeneratedAttribute]
public CppParameterListResolveEntity get_ResolveEntity();
    public CppQualType get_ReturnType();
    [CompilerGeneratedAttribute]
public CppQualType get_TrailingReturnType();
    [CompilerGeneratedAttribute]
public ICppExceptionSpecification get_ExceptionSpecification();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppResolvedAutoType : CppType {
    private static CppResolvedAutoType Instance;
    private static CppResolvedAutoType DecltypeInstance;
    private bool myDecltypeAuto;
    [CompilerGeneratedAttribute]
private ICppResolvedExpression <Constraint>k__BackingField;
    [CompilerGeneratedAttribute]
private CppQualifiedName <ConceptName>k__BackingField;
    public string DbgDescription { get; }
    public ICppResolvedExpression Constraint { get; }
    public CppQualifiedName ConceptName { get; }
    private CppResolvedAutoType(bool decltypeAuto, CppQualifiedName concept, ICppResolvedExpression constraint);
    private static CppResolvedAutoType();
    public virtual string get_DbgDescription();
    [CompilerGeneratedAttribute]
public ICppResolvedExpression get_Constraint();
    public sealed virtual bool IsDecltypeAuto();
    [CompilerGeneratedAttribute]
public sealed virtual CppQualifiedName get_ConceptName();
    public static CppResolvedAutoType Create(bool decltypeAuto);
    public static CppResolvedAutoType Create(bool decltypeAuto, CppQualifiedName concept, ICppResolvedExpression constraint);
    public static CppQualType GetType(bool decltypeAuto);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppResolvedClassType : CppTypeWithClassResolveEntity {
    public CppResolvedClassType(ICppClassResolveEntity resolveEntity);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppResolvedDeclarationSpecifierTypeBuilder : CppBasicDeclarationSpecifierTypeBuilder {
    private ICppResolvedTypeFactory myTypeIntern;
    public CppResolvedDeclarationSpecifierTypeBuilder(ICppResolvedTypeFactory typeIntern);
    public sealed virtual void LearnResolvedClassType(ICppClassResolveEntity ent);
    public sealed virtual void LearnResolvedType(CppQualType resolvedType);
    public void Init(ICppResolvedTypeFactory typeIntern);
    public void Clear();
    protected virtual CppQualType InternateType(CppQualType t);
    private ICppResolvedTypeFactory GetTypeIntern();
}
public static class JetBrains.ReSharper.Psi.Cpp.Types.CppResolveDeclaratorTypeUtil : object {
    public static CppQualType ResolveDeclaratorType(CppQualType unresolvedType, CppViewPos& specifiersViewPos, CppViewPos& declaratorViewPos, ICppResolvedTypeFactory typeFactory, ICppVariableDeclaratorResolveEntity initializerProvider);
    public static CppQualType ResolveDeclaratorType(CppQualType unresolvedType, CppViewPos& specifiersViewPos, CppViewPos& declaratorViewPos, ICppResolvedTypeFactory typeFactory);
    public static CppQualType ResolveDeclaratorTypeWithAuto(CppQualType unresolvedType, CppViewPos& specifiersViewPos, CppViewPos& declaratorViewPos, ICppResolvedTypeFactory typeFactory, CppTypePlaceholders& placeholders);
    public static CppQualType ResolveDeclaratorTypeWithAuto(CppQualType unresolvedType, CppViewPos& specifiersViewPos, CppViewPos& declaratorViewPos, ICppResolvedTypeFactory typeFactory);
    private static CppQualType ReplaceAutoAndDeducedClassTypeUsingDeclaratorInitializer(CppQualType resolvedWithAuto, CppTypeContext& tc, ICppVariableDeclaratorResolveEntity var, CppTypePlaceholders placeholders);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppResolvedEnumType : CppTypeWithClassResolveEntity {
    public CppResolvedEnumType(ICppClassResolveEntity resolveEntity);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppResolvedToLinkageTypeConverter : CppIdentityTypeVisitorWithUnresolvedOutput {
    [CompilerGeneratedAttribute]
private CppCreateLinkageEntityContext <Context>k__BackingField;
    public CppCreateLinkageEntityContext Context { get; }
    public CppResolvedToLinkageTypeConverter(ICppSymbolTypeFactory baseTypeIntern, CppCreateLinkageEntityContext context);
    [CompilerGeneratedAttribute]
public CppCreateLinkageEntityContext get_Context();
    private CppQualType CreateTypeFromResolveEntity(ICppResolveEntity resolveEntity, Qualifiers quals);
    public virtual CppQualType Visit(CppResolvedClassType t, Qualifiers quals);
    public virtual CppQualType Visit(CppResolvedEnumType t, Qualifiers quals);
    public virtual CppQualType Visit(CppDeducedClassTypePlaceholder t, Qualifiers quals);
    public virtual CppQualType Visit(CppResolvedAutoType t, Qualifiers quals);
    public virtual CppQualType Visit(CppTemplateParameterType t, Qualifiers quals);
    public virtual CppQualType Visit(CppGenericParameterType t, Qualifiers quals);
    public virtual CppQualType Visit(CppDependentType t, Qualifiers quals);
    public virtual CppQualType Visit(CppMemberPointerType t, Qualifiers quals);
    public virtual CppQualType Visit(CppArrayType t, Qualifiers quals);
    public virtual CppQualType Visit(CppVectorType t, Qualifiers quals);
    public virtual CppQualType Visit(CppCliArrayType t, Qualifiers quals);
    public virtual CppQualType Visit(CppNamedType t, Qualifiers quals);
    public virtual CppQualType Visit(CppNameSuggestionType t, Qualifiers quals);
    private static bool ConvertedNameIsValid(CppQualifiedName name);
    public virtual CppQualType Visit(CppScopeSuggestionType t, Qualifiers quals);
    public virtual CppQualType Visit(CppDecoratedBuiltinTypeTraitType t, Qualifiers quals);
    public virtual CppQualType Visit(CppNamedParameterType t, Qualifiers quals);
    public virtual CppQualType Visit(CppTypedefType t, Qualifiers quals);
    public virtual CppQualType Visit(CppInstantiatedTemplateAliasType t, Qualifiers quals);
    public virtual CppQualType Visit(CppDependentInstantiatedTemplateAliasType t, Qualifiers quals);
    public virtual CppQualType Visit(CppCEnumeratorType t, Qualifiers quals);
    public virtual CppQualType Visit(CppFunctionWithTrailingReturnType t, Qualifiers quals);
    protected virtual CppUnknownEntityInfo ReApply(CppUnknownEntityInfo info, Boolean& changed);
    protected virtual ICppExceptionSpecification VisitExceptionSpecification(ICppExceptionSpecification exceptionSpecification, Boolean& changed);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppResolvedTypeBuilder : CppBasicTypeBuilder {
    private ICppResolvedTypeFactory myTypeIntern;
    public CppResolvedTypeBuilder(ICppResolvedTypeFactory typeIntern);
    public void Init(ICppResolvedTypeFactory typeIntern);
    public sealed virtual ICppResolvedTypeBuilder CreateResolvedTypeBuilderForPartInParens();
    public sealed virtual void LearnTypePartInParens(ICppResolvedTypeBuilder b);
    protected virtual CppQualType InternateType(CppQualType t);
    private ICppResolvedTypeFactory GetTypeIntern();
}
public static class JetBrains.ReSharper.Psi.Cpp.Types.CppResolveTypeUtil : object {
    public static CppQualType GetAutoOrDecltypeAutoSubstitution(CppQualType resolvedWithAuto, CppTypeContext& tc, ICppResolvedExpression autoInitializer, CppTypePlaceholders placeholders);
    public static CppQualType ResolveTypeButNotReplaceAuto(CppQualType unresolvedType, CppTypeContext& tc, bool returnDeducedClassTypePlaceholder, CppTypePlaceholders& placeholders);
    public static CppQualType ResolveTypeButNotReplaceAuto(CppQualType unresolvedType, CppTypeContext& tc, bool returnDeducedClassTypePlaceholder);
    public static CppQualType ResolveTypeWithoutAutoInitializer(CppQualType unresolvedType, CppTypeContext& tc);
    public static CppQualType ResolveTypeUsingAutoInitializerExpression(CppQualType unresolvedType, CppTypeContext& tc, ICppResolvedExpression autoInitializer);
    public static CppQualType ReplaceAutoTypeUsingExpression(CppQualType resolvedWithAuto, CppTypeContext& tc, ICppResolvedExpression autoInitializer, CppTypePlaceholders placeholders);
    public static CppQualType DoReplaceAutoType(CppQualType resolvedWithAuto, CppTypeContext& tc, ICppResolvedExpression autoInitializer, bool isStructuredBindingDeclaration, bool isReturnType);
    private static CppSubstitutionContext CreateAutoToUnknownSubstitution(CppQualType resolvedWithAuto, ICppResolvedExpression autoInitializer);
    public static CppQualType ReplaceDeducedClassTypeUsingInitializer(ICppDeducibleTypeTemplateResolveEntity classTemplate, CppTypeContext& tc, CppDeclaratorInitializer initializer);
    public static CppQualType ReplaceDeducedClassTypeUsingArgumentList(ICppDeducibleTypeTemplateResolveEntity classTemplate, CppTypeContext& tc, ICppArgumentList argList);
    public static CppQualType ReplaceDeducedClassTypeUsingArgumentList(ICppDeducibleTypeTemplateResolveEntity classTemplate, CppTypeContext& tc, ICppExpression[] args);
    public static CppQualType ResolveNewExpressionTypeId(ICppNewExpression newExpr, CppQualType unresolvedType, CppTypeContext& tc);
    public static CppQualType DeduceTemplateArgumentsForCall(CppDeducedClassTypePlaceholder deducedClassTypePlaceholder, ICppArgumentList argList, CppTypeContext& tc);
    public static CppGetAutoSubstitutionResult GetAutoSubstitutionForResolve(CppQualType resolvedWithAuto, ICppResolvedExpression autoInitializer, CppTypeContext& tc, bool isStructuredBindingDeclaration, bool isReturnType);
    private static CppQualType DoDeduceTemplateArguments(ICppDeducibleTypeTemplateResolveEntity classTemplate, CppList`1<ICppDeductionGuide> guides, ICppBracedInitListExpression bracedInitList, CppTypeContext& tc, bool allowExplicit);
    private static CppQualType DoDeduceTemplateArguments(CppList`1<ICppDeductionGuide> guides, ICppExpression[] args, CppTypeContext& tc, bool allowExplicit);
    private static CppQualType DoDeduceTemplateArguments(ICppDeducibleTypeTemplateResolveEntity classTemplate, CppList`1<ICppDeductionGuide> guides, ICppExpression[] args, CppTypeContext& tc, bool allowExplicit);
    private static CppQualType DoDeduceTemplateArguments(CppList`1<ICppDeductionGuide> guides, CppTypeContext& tc, bool allowExplicit);
    private static bool ShouldTryInitializerList(ICppBracedInitListExpression bracedInitList, ICppDeducibleTypeTemplateResolveEntity deducibleTemplate, CppList`1<ICppDeductionGuide> guides, CppTypeContext& tc);
    private static bool ShouldTryInitializerList(ICppExpression[] elems, ICppDeducibleTypeTemplateResolveEntity deducibleTemplate, CppList`1<ICppDeductionGuide> guides, CppTypeContext& tc);
    private static CppQualType DoDeduceTemplateArguments(CppList`1<ICppDeductionGuide> guides, ICppArgumentList argList, CppTypeContext& tc, ICppDeducibleTypeTemplateResolveEntity classTemplate);
    private static bool ContainsTypeDependentArgs(ICppExpression[] arguments);
    private static bool ContainsTypeDependentArgs(CppSmallArray`1<ICppExpression> arguments);
    private static bool ContainsTypeDependentArgs(ICppArgumentList argList);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppScopeSuggestionType : CppDecoratedType {
    [CompilerGeneratedAttribute]
private CppQualType <ScopeType>k__BackingField;
    public CppQualType ScopeType { get; }
    public CppScopeSuggestionType(CppQualType scopeType, CppQualType innerType);
    [CompilerGeneratedAttribute]
public CppQualType get_ScopeType();
    public virtual Result Accept(ICppVerboseTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppSemanticsHandlingTypeFactory : object {
    public sealed virtual CppQualType GetArrayType(CppQualType t, ICppExpression sizeExpr);
    public sealed virtual CppQualType GetVectorType(CppQualType elementType, ICppExpression size);
    public sealed virtual CppQualType GetPointerType(CppQualType t);
    public sealed virtual CppQualType GetReferenceType(CppQualType t, ReferenceFlag isRval);
    public sealed virtual CppQualType GetMemberPointerType(CppQualType classType, CppQualType memberType);
    public sealed virtual CppQualType GetFunctionType(CppQualType returnType, CppQualType[] paramTypes, CppFunctionFlags flags, ICppExceptionSpecification exceptionSpecification);
    public sealed virtual CppQualType GetDerefFunctionType(CppQualType returnType, CppQualType[] paramTypes, CppFunctionFlags flags, ICppExceptionSpecification exceptionSpecification);
    public sealed virtual CppPackExpansionType GetPackExpansionType(CppQualType t);
    public sealed virtual CppQualType GetCliHandleType(CppQualType t);
    public sealed virtual CppQualType GetCliInteriorPointerType(CppQualType t);
    public sealed virtual CppQualType GetCliPinPointerType(CppQualType t);
    public sealed virtual CppQualType GetCliArrayType(CppQualType t, ICppExpression rankExpr);
    public virtual CppQualType GetAutoType(bool decltypeAuto, CppQualifiedName concept);
    public abstract virtual CppQualType GetTyperefType(CppQualifiedName qualName, CppClassTag tag);
    public abstract virtual CppQualType GetNamedParameterType(ICppDecoratedFunctionParameter parameter, CppQualType innerType);
    public abstract virtual CppQualType GetUnknownType(CppUnknownEntityInfo info);
    protected abstract virtual CppQualType GetArrayTypeImpl(CppQualType t, ICppExpression sizeExpr);
    protected abstract virtual CppQualType GetVectorTypeImpl(CppQualType elementType, ICppExpression size);
    protected abstract virtual CppQualType GetPointerTypeImpl(CppQualType t);
    protected abstract virtual CppQualType GetReferenceTypeImpl(CppQualType t, ReferenceFlag isRval);
    protected abstract virtual CppQualType GetMemberPointerTypeImpl(CppQualType classType, CppQualType memberType);
    protected abstract virtual CppQualType GetFunctionTypeImpl(CppQualType returnType, CppQualType[] paramTypes, CppFunctionFlags flags, ICppExceptionSpecification exceptionSpecification);
    protected abstract virtual CppPackExpansionType GetPackExpansionTypeImpl(CppQualType t);
    protected abstract virtual CppQualType GetCliHandleTypeImpl(CppQualType t);
    protected abstract virtual CppQualType GetCliInteriorPointerTypeImpl(CppQualType t);
    protected abstract virtual CppQualType GetCliPinPointerTypeImpl(CppQualType t);
    protected abstract virtual CppQualType GetCliArrayTypeImpl(CppQualType t, ICppExpression rankExpr);
}
internal class JetBrains.ReSharper.Psi.Cpp.Types.CppShouldInternateWithTypeFactoryVisitor : CppAbstractTypeVisitor`1<bool> {
    public static CppShouldInternateWithTypeFactoryVisitor Instance;
    private static CppShouldInternateWithTypeFactoryVisitor();
    public virtual bool VisitType(CppType t, Qualifiers q);
    public virtual bool VisitReference(CppQualType innerType, ReferenceFlag f);
    public virtual bool VisitTypeWithInnerType(CppTypeWithInnerType t, Qualifiers q);
    public virtual bool Visit(CppPendingClassType t, Qualifiers q);
    public virtual bool Visit(CppDependentType t, Qualifiers q);
    public virtual bool Visit(CppArrayType t, Qualifiers q);
    public virtual bool Visit(CppUnknownType t, Qualifiers q);
    public virtual bool Visit(CppFunctionType t, Qualifiers q);
    public virtual bool Visit(CppPackExpansionType t, Qualifiers q);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Types.CppSizeAndAlignmentUtil : object {
    public static CppDefineKey STDCPP_DEFAULT_NEW_ALIGNMENT;
    private static CppSizeAndAlignmentUtil();
    [ExtensionAttribute]
public static CppSizeAndAlignment GetSizeAndAlignment(CppQualType qualType, CppTypeContext& tc);
    public static CppSizeAndAlignment GetSizeAndAlignmentForCompleteClassAdjusted(ICppClassResolveEntity e, CppTypeContext& tc, CppResolveEntitiesDetachedData data);
    [ExtensionAttribute]
public static CppSizeAndAlignment BuildLayout(ICppClassResolveEntity cent, CppTypeContext& tc, ICppLayoutBuilder layoutBuilder, bool withVirtualBases);
    public static ICppValue GetTypeSize(CppQualType qualType, CppTypeContext& tc);
    [CanBeNullAttribute]
public static ICppValue GetTypeAlignment(CppQualType qualType, CppTypeContext& tc);
    public static TriBool IsTypeEmpty(CppQualType qualType, CppTypeContext& tc);
    public static TriBool IsClassEmpty(ICppClassResolveEntity clazz, CppTypeContext& tc, CppResolveEntitiesDetachedData data);
    private static bool HasVfptrInBases(ICppClassResolveEntity e, CppViewPos& viewPos);
    private static bool NeedVfptr(ICppClassResolveEntity e, CppViewPos& viewPos);
    private static bool HasImmediateVirtualBase(ICppClassResolveEntity e, CppViewPos& viewPos);
    private static bool HasVbptrInBases(ICppClassResolveEntity e, CppViewPos& viewPos);
    private static bool NeedVbptr(ICppClassResolveEntity e, CppViewPos& viewPos);
    private static Nullable`1<ulong> GetBitfieldSize(CppAttributeList attrs, CppTypeContext& tc);
    private static bool HasNonUniqueAddress(CppAttributeList attrs);
    private static bool IsEmptyClass(CppQualType type, CppTypeContext& tc, CppResolveEntitiesDetachedData data);
    [CanBeNullAttribute]
private static ICppResolveEntity ReferencedTypeResolveEntity(ICppExpression expr);
    private static Nullable`1<ulong> GetAlignAsValue(CppAttributeList attrs, CppTypeContext& tc);
    private static Nullable`1<ulong> DefaultAlignment(ICppFileResolveEntitiesCache resolveCache);
    private static Nullable`1<ulong> GetAlignAsValue(ICppClassResolveEntity ent, CppTypeContext& tc);
    private static CppSizeAndAlignment CalculateSizeAndAlignmentForClassWithoutVBases(ICppClassResolveEntity e, CppTypeContext& tc, CppResolveEntitiesDetachedData data, ICppLayoutBuilder layoutBuilder);
    private static CppSizeAndAlignment GetSizeAndAlignmentForClassWithoutVBases(ICppClassResolveEntity e, CppTypeContext& tc, CppResolveEntitiesDetachedData data, ICppLayoutBuilder layoutBuilder);
    private static CppSizeAndAlignment CalculateSizeAndAlignmentForCompleteClassWithVBases(ICppClassResolveEntity e, CppTypeContext& tc, CppResolveEntitiesDetachedData data, ICppLayoutBuilder layoutBuilder);
    private static CppSizeAndAlignment GetSizeAndAlignmentForCompleteClassWithVBases(ICppClassResolveEntity e, CppTypeContext& tc, CppResolveEntitiesDetachedData data);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppSymbolTypeIntern : CppTypeInternBase {
    private TypeVisitor myInternVisitor;
    public sealed virtual CppQualType GetTypeForClassSym(ICppClassSymbol sym);
    public virtual CppQualType GetNamedParameterType(ICppDecoratedFunctionParameter parameter, CppQualType innerType);
    public CppQualType GetClassType(ICppClassSymbol sym);
    public CppQualType GetEnumType(ICppClassSymbol sym);
    public virtual bool ShouldInternate(CppQualType type);
    public virtual bool ShouldInternate(CppQualifiedName name);
    public CppQualType InternateUnresolvedType(CppQualType type);
    public static bool ShouldNotInternateTemplateArgument(ICppTemplateArgument arg);
    public static bool ShouldNotInternateTemplateArguments(ICppTemplateArgument[] args);
    public static bool ShouldNotInternateQualifiedName(CppQualifiedName name);
    public static bool ShouldNotInternateType(CppQualType type);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppTemplateParameterType : CppType {
    [CompilerGeneratedAttribute]
private ICppTypeTemplateParameterOrPack <ResolveEntity>k__BackingField;
    public ICppTypeTemplateParameterOrPack ResolveEntity { get; }
    public CppTemplateParameterType(ICppTypeTemplateParameterOrPack ent);
    [CompilerGeneratedAttribute]
public ICppTypeTemplateParameterOrPack get_ResolveEntity();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppTemporaryExpression : object {
    private CppTypeAndCategory myType;
    [CanBeNullAttribute]
private ICppResolvedExpression myUnderlyingExpr;
    private CppDependentInfo myDependentInfo;
    protected CppTemporaryExpression(CppTypeAndCategory mockType, ICppResolvedExpression underlyingExpr);
    public virtual CppUnknownEntityInfo GetInfo();
    public virtual CppDependentInfo GetDependentInfo();
    public virtual TriBool IsNoexcept();
    public virtual CppTypeContext TryGetTypeContext();
    public virtual Result Accept(ICppExpressionVisitor`1<Result> visitor);
    public virtual CppTypeAndCategory GetTypeAndCategory();
    [CanBeNullAttribute]
public ICppResolvedExpression GetUnderlyingExpression();
    public static ICppResolvedExpression CreateFromType(CppTypeAndCategory type);
    public static ICppResolvedExpression CreateFromType(CppQualType mockType);
    public static ICppResolvedExpression CreateFromExpression(CppExpressionInfo info);
    public static ICppResolvedExpression CreateFromExpression(ICppResolvedExpression expr, CppTypeAndCategory newType);
    public static ICppResolvedExpression CreateFromExpression(ICppExpressionNode expr, CppTypeAndCategory newType);
    public static ICppResolvedExpression CreateFromExpression(CppTemporaryExpression expr, CppTypeAndCategory newType);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppThisObjectType : object {
    public static ICppClassResolveEntity GetThisClass(CppViewPos& viewPos);
    public static CppQualType IsObjectType(CppTypeContext& tc, bool skipLambda);
    private static ICppParameterListResolveEntity GetEnclosingNonStaticFunctionParameterList(CppViewPos& viewPos, bool skipLambda);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppThrowAnySpecification : object {
    public static CppThrowAnySpecification Instance;
    private static CppThrowAnySpecification();
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppType : object {
    public string DbgDescription { get; }
    public virtual string get_DbgDescription();
    public abstract virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public abstract virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public abstract virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public sealed virtual Result Accept(Data data, ICppTemplateArgumentVisitor`2<Result, Data> visitor);
    public sealed virtual CppQualType GetQualType();
    public sealed virtual ICppTemplateArgument Import(CppModuleImportingContext ctx);
    public sealed virtual CppModuleTemplateArgumentKind Kind();
    public sealed virtual int SerializedSize();
    public sealed virtual void Marshal(CppModuleMarshallingContext context, CppBinaryStreamWriter& output);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppTypeAndCategory : ValueType {
    private CppType myType;
    private ushort myPackedQualifiers;
    private ushort myPackedDeclSpecPlacement;
    private static ushort RefBits;
    public CppQualType Type { get; public set; }
    public CppValueCategory Category { get; public set; }
    public string DbgDescription { get; }
    public CppTypeAndCategory(CppQualType t, CppValueCategory c);
    public static CppTypeAndCategory MakeLValue(CppQualType t);
    public static CppTypeAndCategory MakeGCLValue(CppQualType t);
    public static CppTypeAndCategory MakeXValue(CppQualType t);
    public static CppTypeAndCategory MakePRValue(CppQualType t);
    private ushort GetQualifiers();
    private void SetQualifiers(ushort packedQualifiers, CppValueCategory c);
    public CppQualType get_Type();
    public void set_Type(CppQualType value);
    public CppValueCategory get_Category();
    public void set_Category(CppValueCategory value);
    public string get_DbgDescription();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Types.CppTypeAndCategoryUtil : object {
    [ExtensionAttribute]
public static bool ResolvedEquals(CppTypeAndCategory lhs, CppTypeAndCategory rhs);
    [ExtensionAttribute]
public static int ResolvedHashCode(CppTypeAndCategory tc);
    [ExtensionAttribute]
public static bool IsLValue(CppTypeAndCategory cat);
    [ExtensionAttribute]
public static bool IsGCLValue(CppTypeAndCategory cat);
    [ExtensionAttribute]
public static bool IsAnyLValue(CppTypeAndCategory cat);
    [ExtensionAttribute]
public static bool IsXValue(CppTypeAndCategory cat);
    [ExtensionAttribute]
public static bool IsPRValue(CppTypeAndCategory cat);
    [ExtensionAttribute]
public static bool IsRValue(CppTypeAndCategory cat);
    [ExtensionAttribute]
public static bool IsGLValue(CppTypeAndCategory cat);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Types.CppTypeClasses : Enum {
    public int value__;
    public static CppTypeClasses NONE;
    public static CppTypeClasses FACET_UNRESOLVED_REFERENCES;
    public static CppTypeClasses FACET_UNRESOLVED_CLASSES;
    public static CppTypeClasses FACET_UNRESOLVED_FUNCTIONS_WITH_TRAILING_RETURN_TYPE;
    public static CppTypeClasses FACET_UNRESOLVED_FUNCTIONS_WO_TRAILING_RETURN_TYPE;
    public static CppTypeClasses FACET_REPLACED_FUNCTIONS;
    public static CppTypeClasses FACET_RESOLVED_CLASSES;
    public static CppTypeClasses FACET_RESOLVED_FUNCTIONS;
    public static CppTypeClasses FACET_RESOLVED;
    public static CppTypeClasses FACET_LINKAGE;
    public static CppTypeClasses FACET_UNRESOLVED_EXPRESSIONS;
    public static CppTypeClasses FACET_RESOLVED_EXPRESSIONS;
    public static CppTypeClasses FACET_UNRESOLVED_LAMBDA_EXPRESSION;
    public static CppTypeClasses FACET_REPLACED_LAMBDA_EXPRESSION;
    public static CppTypeClasses FACET_REPLACED_CLASSES;
    public static CppTypeClasses FACET_INVENTED_TYPE_TEMPLATE_PARAMS;
    public static CppTypeClasses UNRESOLVED;
    public static CppTypeClasses REPLACED;
    public static CppTypeClasses RESOLVED;
    public static CppTypeClasses LINKAGE;
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppTypedefModuleType : CppType {
    public ICppTypeAliasModuleEntity TypeAlias;
    public CppTypedefModuleType(ICppTypeAliasModuleEntity typeAlias);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppTypedefType : CppDecoratedType {
    [CompilerGeneratedAttribute]
private ICppGroupedTypeDeclaratorResolveEntity <Declarator>k__BackingField;
    public ICppGroupedTypeDeclaratorResolveEntity Declarator { get; }
    public string DbgDescription { get; }
    public CppTypedefType(ICppGroupedTypeDeclaratorResolveEntity declEnt, CppQualType innerType);
    [CompilerGeneratedAttribute]
public ICppGroupedTypeDeclaratorResolveEntity get_Declarator();
    public virtual string get_DbgDescription();
    public virtual Result Accept(ICppVerboseTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppTypeFactory : CppTypeInternBase {
    private ConcurrentDictionary`2<ICppClassResolveEntity, CppType> myClassEntToType;
    private ConcurrentDictionary`2<ICppGenericParameter, CppType> myGenericParameterToType;
    private ConcurrentDictionary`2<InstantiatedTemplateAliasKey, CppInstantiatedTemplateAliasType> myInstantiatedTemplateAliasesCache;
    private ICppVerboseTypeVisitor`1<CppQualType> myIdentityTypeVisitor;
    private ICppRootFileResolveEntitiesCache myResolveCache;
    private ConcurrentDictionary`2<ICppTypeTemplateParameterOrPack, CppType> myTemplateParameterToType;
    public bool IgnoresScopeSuggestions { get; }
    public bool IgnoresNameSuggestions { get; }
    public ICppRootFileResolveEntitiesCache ResolveCache { get; }
    public CppTypeFactory(ICppRootFileResolveEntitiesCache resolveCache);
    public sealed virtual bool get_IgnoresScopeSuggestions();
    public sealed virtual bool get_IgnoresNameSuggestions();
    public sealed virtual ICppRootFileResolveEntitiesCache get_ResolveCache();
    public sealed virtual CppLanguageDialect GetDialect();
    public sealed virtual CppQualType GetReplacedFunctionType(CppQualType returnType, CppParameterListResolveEntity resolveEntity, CppFunctionFlags flags, CppQualType trailingReturnType, ICppExceptionSpecification exceptionSpecification);
    public sealed virtual CppQualType GetResolvedTypeForEntity(ICppClassResolveEntity classEnt);
    public sealed virtual CppQualType GetTemplateParameterType(ICppTypeTemplateParameterOrPack templParameterEnt);
    public sealed virtual CppQualType GetGenericParameterType(ICppGenericParameter genericParameterEnt);
    public sealed virtual CppQualType GetDependentType(ICppDependentTypeResolveEntity depEnt);
    public sealed virtual CppQualType GetResolvedAutoType(bool decltypeAuto, CppQualifiedName concept, ICppResolvedExpression constraint);
    public sealed virtual CppQualType GetTypedefType(CppQualType innerType, ICppGroupedTypeDeclaratorResolveEntity decl);
    public sealed virtual CppQualType GetInstantiatedTemplateAliasType(CppQualType innerType, CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity alias);
    public sealed virtual CppQualType GetCEnumeratorType(CppQualType innerType, ICppClassResolveEntity enumDecl);
    public sealed virtual CppQualType GetNamedType(CppQualType innerType, CppQualifiedName name);
    public sealed virtual CppQualType GetNameSuggestionType(CppQualType innerType, CppQualifiedName name);
    public sealed virtual CppQualType GetScopeSuggestionType(CppQualType innerType, CppQualType scopeType);
    public virtual CppQualType GetNamedParameterType(ICppDecoratedFunctionParameter parameter, CppQualType innerType);
    public sealed virtual CppQualType GetFunctionWithTrailingReturnType(CppQualType functionType);
    public sealed virtual CppQualType GetDeducedClassTypePlaceholder(ICppDeducibleTypeTemplateResolveEntity classTemplate);
    public sealed virtual CppQualType GetCachedType(ICppRawDeclaratorResolveEntity key);
    public sealed virtual CppQualType GetCachedType(CppGroupedFunctionDeclaratorResolveEntity key);
    public sealed virtual CppQualType TryGetCachedType(ICppRawDeclaratorResolveEntity key);
    public sealed virtual ICppVerboseTypeVisitor`1<CppQualType> GetIdentityTypeVisitor();
    public CppQualType GetResolvedObjectType(ICppClassResolveEntity classEnt);
    public CppQualType GetResolvedEnumType(ICppClassResolveEntity classEnt);
    public virtual bool ShouldInternate(CppQualType type);
    public virtual bool ShouldInternate(CppQualifiedName name);
    private CppQualType GetResolvedEntityTypeInternal(ICppClassResolveEntity classEnt);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Types.CppTypeFactoryUtil : object {
    [ExtensionAttribute]
public static ICppResolvedTypeFactory GetTypeFactory(ICppResolveEntity ent);
    [ExtensionAttribute]
public static ICppResolvedTypeFactory GetTypeFactory(ICppCompositeNode node);
    [ExtensionAttribute]
public static ICppResolvedTypeFactory GetTypeFactory(CppViewPos& vp);
    [ExtensionAttribute]
public static ICppResolvedTypeFactory GetVerboseTypeFactory(ICppResolveEntity ent);
    [ExtensionAttribute]
public static ICppResolvedTypeFactory GetVerboseTypeFactory(ICppCompositeNode node);
    [ExtensionAttribute]
public static ICppResolvedTypeFactory GetVerboseNormalizingTypeFactory(ICppResolveEntity ent);
    [ExtensionAttribute]
public static CppQualType GetCtorDtorFunctionType(ICppResolvedTypeFactory tf, CppQualType returnType, CppRestrictionSpecifiers restrictionSpecifiers, bool isCli);
    [ExtensionAttribute]
public static CppQualType GetCtorDtorFunctionType(ICppResolvedTypeFactory tf, CppQualType returnType, CppQualType param1, CppRestrictionSpecifiers restrictionSpecifiers);
    [ExtensionAttribute]
public static CppQualType GetFunctionType(ICppResolvedTypeFactory tf, CppQualType returnType, CppQualType[] paramTypes, CppRestrictionSpecifiers restrictionSpecifiers);
    [ExtensionAttribute]
public static CppQualType GetFunctionType(ICppResolvedTypeFactory tf, CppQualType returnType, CppRestrictionSpecifiers restrictionSpecifiers);
    [ExtensionAttribute]
public static CppQualType GetFunctionType(ICppResolvedTypeFactory tf, CppQualType returnType, CppQualType param1, CppRestrictionSpecifiers restrictionSpecifiers);
    [ExtensionAttribute]
public static CppQualType GetFunctionType(ICppResolvedTypeFactory tf, CppQualType returnType, CppQualType param1, CppQualType param2, CppRestrictionSpecifiers restrictionSpecifiers);
    [ExtensionAttribute]
public static CppQualType GetMemberFunctionType(ICppResolvedTypeFactory tf, CppQualType returnType, CppQualType[] paramTypes, CppRestrictionSpecifiers restrictionSpecifiers);
    [ExtensionAttribute]
public static CppQualType GetMemberFunctionType(ICppResolvedTypeFactory tf, CppQualType returnType, CppRestrictionSpecifiers restrictionSpecifiers);
    [ExtensionAttribute]
public static CppQualType GetMemberFunctionType(ICppResolvedTypeFactory tf, CppQualType returnType, CppQualType param1, CppRestrictionSpecifiers restrictionSpecifiers);
    [ExtensionAttribute]
public static CppQualType GetMemberFunctionType(ICppResolvedTypeFactory tf, CppQualType returnType, CppQualType param1, CppQualType param2, CppRestrictionSpecifiers restrictionSpecifiers);
    [ExtensionAttribute]
public static CppQualType GetTyperefTypeSafe(ICppTypeFactory tf, CppQualifiedName qualName, CppClassTag tag);
    [ExtensionAttribute]
public static ICppResolvedTypeFactory EnsureNonnormalizing(ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static ICppResolvedTypeFactory CreateErrorHandlingFactory(ICppResolvedTypeFactory tf);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppTypeInternBase : CppTypeInternOfBaseTypes {
    private ConcurrentDictionary`2<CppQualifiedName, CppType> myConceptNameToAuto;
    private ConcurrentDictionary`2<CppQualifiedName, CppType> myConceptNameToDecltypeAuto;
    private ConcurrentDictionary`2<CppQualType, CppPackExpansionType> myExpandeeToExpansion;
    private ConcurrentDictionary`2<FuncKey, CppType> myParamsToFunctionType;
    private ConcurrentDictionary`2<ArrayKey, CppType> myPointeeToArray;
    private ConcurrentDictionary`2<ArrayKey, CppType> myPointeeToCliArray;
    private ConcurrentDictionary`2<ArrayKey, CppType> myPointeeToVector;
    private ConcurrentDictionary`2<CppQualType, CppType> myPointeeToCliHandle;
    private ConcurrentDictionary`2<CppQualType, CppType> myPointeeToCliInteriorPointer;
    private ConcurrentDictionary`2<CppQualType, CppType> myPointeeToCliPinPointer;
    private ConcurrentDictionary`2<CppQualType, CppType> myPointeeToPointer;
    private ConcurrentDictionary`2<TyperefKey, CppType> myTyperefToType;
    private ConcurrentDictionary`2<MemberPointerKey, CppType> myTypeToMemberPointer;
    protected CppTypeInternBase(IEqualityComparer`1<CppQualType> comparer);
    public virtual CppQualType GetTyperefType(CppQualifiedName qualName, CppClassTag tag);
    public virtual CppQualType GetAutoType(bool decltypeAuto, CppQualifiedName concept);
    public virtual CppQualType GetUnknownType(CppUnknownEntityInfo info);
    protected virtual CppQualType GetPointerTypeImpl(CppQualType t);
    protected virtual CppQualType GetCliHandleTypeImpl(CppQualType t);
    protected virtual CppQualType GetCliInteriorPointerTypeImpl(CppQualType t);
    protected virtual CppQualType GetCliPinPointerTypeImpl(CppQualType t);
    protected virtual CppQualType GetCliArrayTypeImpl(CppQualType t, ICppExpression rankExpr);
    protected virtual CppQualType GetReferenceTypeImpl(CppQualType t, ReferenceFlag isRval);
    protected virtual CppQualType GetArrayTypeImpl(CppQualType t, ICppExpression sizeExpr);
    protected virtual CppQualType GetVectorTypeImpl(CppQualType elementType, ICppExpression size);
    protected virtual CppQualType GetFunctionTypeImpl(CppQualType returnType, CppQualType[] paramTypes, CppFunctionFlags flags, ICppExceptionSpecification exceptionSpecification);
    protected virtual CppPackExpansionType GetPackExpansionTypeImpl(CppQualType innerType);
    protected virtual CppQualType GetMemberPointerTypeImpl(CppQualType classType, CppQualType memberType);
    public abstract virtual bool ShouldInternate(CppQualType type);
    public abstract virtual bool ShouldInternate(CppQualifiedName name);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppTypeInternOfBaseTypes : CppSemanticsHandlingTypeFactory {
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Types.CppTypePlaceholders : Enum {
    public byte value__;
    public static CppTypePlaceholders NONE;
    public static CppTypePlaceholders AUTO;
    public static CppTypePlaceholders DECLTYPE_AUTO;
    public static CppTypePlaceholders DEDUCED_CLASS_TYPE;
    public static CppTypePlaceholders ANY_AUTO;
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppTypeReference : CppType {
    private CppQualifiedName myTypeQualifiedName;
    public CppQualifiedName QualifiedName { get; }
    public CppTypeReference(CppQualifiedName name);
    public CppQualifiedName get_QualifiedName();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Types.CppTypesUtil : object {
    public static Func`2<CppQualType, bool> IsNotUnknownTypeFunc;
    private static CppTypesUtil();
    public static CppUnaryTypingResult GetUnaryOperationResultType(CppTypeAndCategory operandT, CppOperatorKind opKind, ICppResolvedTypeFactory typeFactory);
    public static CppBinaryTypingResult GetSubscriptOperationResultType(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT, ICppResolvedTypeFactory typeFactory);
    public static CppQualType BinaryOpBuiltinType(CppExpressionInfo left, CppExpressionInfo right, CppOperatorKind opKind, CppTypeContext& tc);
    public static CppQualType BinaryOpBuiltinType(CppExpressionInfo left, CppExpressionInfo right, CppOperatorKind opKind, CppTypeContext& tc, ICppBinaryTypingErrorConsumer errorConsumer);
    public static CppQualType UnaryOpBuiltinType(CppTypeAndCategory leftT, CppOperatorKind opKind, ICppResolvedTypeFactory typeFactory);
    public static CppQualType PostfixOpBuiltinType(CppTypeAndCategory leftT, ICppResolvedTypeFactory typeFactory);
    public static CppTypeAndCategory GetTypeForDotMulOperatorApplication(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public static CppUnaryTypingResult GetUnaryOperationResultType(CppTypeAndCategory operandT, CppOperatorKind opKind, ICppResolvedTypeFactory typeFactory, ICppUnaryTypingErrorConsumer errorConsumer);
    public static CppBinaryTypingResult GetExpectedBinaryOperationResultType(CppTypeAndCategory left, CppTypeAndCategory right, CppOperatorKind opKind, CppTypeContext& tc, ICppBinaryTypingErrorConsumer errorConsumer);
    public static CppBinaryTypingResult GetBinaryOperationResultType(CppExpressionInfo left, CppExpressionInfo right, CppOperatorKind opKind, CppTypeContext& tc, ICppBinaryTypingErrorConsumer errorConsumer);
    public static CppBinaryTypingResult GetSubscriptOperationResultType(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT, ICppResolvedTypeFactory typeFactory, ICppSubscriptErrorConsumer errorConsumer);
    private static CppClassifyRelationalOperand ClassifyRelOp(CppQualType t);
    private static ICppBinaryTypingErrorConsumer ForwardToBinaryErrorConsumer(ICppUnaryTypingErrorConsumer unaryConsumer);
    private static CppTypeAndCategory GetDotMulOperationResultType(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT, ICppBinaryTypingErrorConsumer errorConsumer);
    private static CppTypeAndCategory GetBinaryOperationResultTypeImpl(CppTypeAndCategory& lhsT, CppTypeAndCategory& rhsT, CppOperatorKind opKind, ICppResolvedTypeFactory typeFactory, ICppBinaryTypingErrorConsumer errorConsumer);
    private static CppQualType VectorScalarComparisonResultType(CppQualType vectorType, CppQualType scalarType, ICppResolvedTypeFactory tf);
    private static CppTypeAndCategory GetThreeWayComparisonResultType(CppExpressionInfo lhs, CppExpressionInfo rhs, CppTypeContext& tc, ICppBinaryTypingErrorConsumer errorConsumer);
    private static CppTypeAndCategory GetUnaryOperationResultTypeImpl(CppTypeAndCategory& operandT, CppOperatorKind opKind, ICppResolvedTypeFactory typeFactory, ICppUnaryTypingErrorConsumer errorConsumer);
    [ExtensionAttribute]
public static int GetFunctionParametersCount(CppQualType funcT);
    [ExtensionAttribute]
public static bool IsReference(CppQualType t);
    [ExtensionAttribute]
public static bool IsRValueReference(CppQualType t);
    [ExtensionAttribute]
public static bool IsLValueReference(CppQualType t);
    [ExtensionAttribute]
public static bool IsCliTrackingReference(CppQualType t);
    [ExtensionAttribute]
public static bool IsNonRValueReference(CppQualType t);
    [ExtensionAttribute]
public static CppQualType ClearRefs(CppQualType t);
    [ExtensionAttribute]
public static CppQualType GetReferencedType(CppQualType t);
    [ExtensionAttribute]
public static CppQualType AppendCVQualifiers(CppQualType t, CVQualifiers quals);
    [ExtensionAttribute]
public static CppQualType RemoveConst(CppQualType t);
    [ExtensionAttribute]
public static CppQualType RemoveVolatile(CppQualType t);
    [ExtensionAttribute]
public static CppQualType AddConst(CppQualType t);
    [ExtensionAttribute]
public static CppQualType CVQualify(CppQualType t, CVQualifiers quals);
    [ExtensionAttribute]
public static CppQualType CVUnqualify(CppQualType t);
    [ExtensionAttribute]
public static CppQualType GetNonReferenceType(CppQualType t);
    [ExtensionAttribute]
public static bool IsFunctionType(CppQualType t);
    [ExtensionAttribute]
public static bool IsFunctionTypeNoAssert(CppQualType t);
    [ExtensionAttribute]
public static bool IsReplacedFunctionType(CppQualType t);
    [ExtensionAttribute]
public static bool IsReplacedFunctionTypeNoAssert(CppQualType t);
    [ExtensionAttribute]
public static bool IsUnresolvedFunctionTypeNoAssert(CppQualType t);
    [ExtensionAttribute]
public static bool IsUnresolvedFunctionType(CppQualType t);
    [ExtensionAttribute]
public static bool IsUnresolvedFunctionTypeWithAutoParams(CppQualType t);
    [ExtensionAttribute]
public static bool IsUnresolvedFunctionTypeWithImplicitIntParams(CppQualType t);
    [ExtensionAttribute]
public static bool IsFunctionTypeWithTrailingReturnType(CppQualType t);
    [ExtensionAttribute]
public static bool IsUnknownType(CppQualType t);
    [ExtensionAttribute]
public static bool IsNotUnknownType(CppQualType t);
    [ExtensionAttribute]
public static bool IsAnonymousType(CppQualType t);
    private static bool IsAnonymousEntity(ICppResolveEntity entity);
    [ExtensionAttribute]
public static bool IsPackExpansion(CppQualType t);
    [ExtensionAttribute]
public static CppQualType DropPackIfPackExpansion(CppQualType t);
    [ExtensionAttribute]
public static CppQualType DropPackExpansion(CppQualType t);
    [ExtensionAttribute]
public static CppQualType GetInnerTypeIfDependentEnableIf(CppQualType t);
    [ExtensionAttribute]
public static bool IsScalar(CppQualType t);
    [ExtensionAttribute]
public static bool IsPolymorphicClassType(CppQualType t);
    [ExtensionAttribute]
public static bool IsLambda(CppQualType t);
    [ExtensionAttribute]
public static bool IsAutoType(CppQualType t);
    [ExtensionAttribute]
public static bool IsDecltypeAutoType(CppQualType t);
    [ExtensionAttribute]
public static bool IsArithmetic(CppQualType t);
    [ExtensionAttribute]
public static bool IsArithmeticOrUnscopedEnum(CppQualType t);
    [ExtensionAttribute]
public static bool IsArithmeticOrUnscopedEnumOrHlslType(CppQualType t);
    [ExtensionAttribute]
public static bool IsArithmeticOrUnscopedOrCliEnum(CppQualType t);
    [ExtensionAttribute]
public static bool IsArithmeticOrEnum(CppQualType t);
    [ExtensionAttribute]
public static bool IsIntegralOrUnscopedEnum(CppQualType t);
    [ExtensionAttribute]
public static bool IsIntegralOrEnum(CppQualType t);
    [ExtensionAttribute]
public static bool IsCliEnum(CppQualType t);
    [ExtensionAttribute]
public static bool IsScopeEnum(CppQualType t);
    [ExtensionAttribute]
public static bool IsPointerOrInteriorPointer(CppQualType t);
    [ExtensionAttribute]
public static bool IsArray(CppQualType t);
    [ExtensionAttribute]
public static bool IsVector(CppQualType t);
    [ExtensionAttribute]
public static bool IsCliHandle(CppQualType t);
    [ExtensionAttribute]
public static bool IsCliInteriorPointer(CppQualType t);
    [ExtensionAttribute]
public static bool IsCliPinPointer(CppQualType t);
    [ExtensionAttribute]
public static bool IsCliMovablePointer(CppQualType t);
    [ExtensionAttribute]
public static bool IsCliHandleOrGeneric(CppQualType t);
    [ExtensionAttribute]
public static bool IsCliArray(CppQualType t);
    [ExtensionAttribute]
public static bool IsPointer(CppQualType t);
    [ExtensionAttribute]
public static bool IsMemberPointer(CppQualType t);
    [ExtensionAttribute]
public static bool IsPointerOrMemberPointer(CppQualType t);
    [ExtensionAttribute]
public static bool IsAnyPointer(CppQualType t);
    [ExtensionAttribute]
public static bool IsAnyCliPointer(CppQualType t);
    [ExtensionAttribute]
public static bool IsAnyFunctionType(CppQualType t);
    [ExtensionAttribute]
public static bool IsPointerToFunction(CppQualType t);
    [ExtensionAttribute]
public static ReferenceFlag GetReferenceFlag(CppQualType t);
    [ExtensionAttribute]
public static bool IsVoid(CppQualType t);
    [ExtensionAttribute]
public static bool IsVoidPtr(CppQualType t);
    [ExtensionAttribute]
public static bool IsTopLevelDependentType(CppQualType t);
    [ExtensionAttribute]
public static bool IsVoidFunctionParameter(CppQualType t);
    [ExtensionAttribute]
public static bool IsDependentFunctionReturnAutoType(CppQualType t);
    [ExtensionAttribute]
public static bool IsResolvedClassType(CppQualType t);
    [ExtensionAttribute]
public static bool IsResolvedEnumType(CppQualType t);
    [ExtensionAttribute]
public static bool IsUnresolvedClassType(CppQualType t);
    [ExtensionAttribute]
public static bool IsNullptrType(CppQualType t);
    [ExtensionAttribute]
public static bool IsBool(CppQualType t);
    [ExtensionAttribute]
public static bool IsResolvedClassOrCliHandleType(CppQualType t);
    [ExtensionAttribute]
public static bool IsUnresolvedTypeReference(CppQualType t);
    [ExtensionAttribute]
public static bool IsTemplateParameterType(CppQualType t);
    [ExtensionAttribute]
public static bool IsGenericParameterType(CppQualType t);
    [ExtensionAttribute]
public static bool IsBadArrayInnerType(CppQualType innerType);
    [ExtensionAttribute]
public static bool IsBadFunctionParameterType(CppQualType t);
    [ExtensionAttribute]
public static bool IsBadFunctionReturnType(CppQualType t);
    [ExtensionAttribute]
public static bool IsBadReferencedType(CppQualType t);
    [ExtensionAttribute]
public static bool IsBadMemberPointerClassType(CppQualType t);
    [ExtensionAttribute]
public static bool IsNumeric(CppQualType t, CppNumericTypeKind kind);
    [ExtensionAttribute]
public static bool IsCliClassOrInterfaceType(CppQualType t);
    [ExtensionAttribute]
public static bool IsCliRefClassOrInterfaceType(CppQualType t);
    [ExtensionAttribute]
public static bool IsCliInterfaceType(CppQualType t);
    [ExtensionAttribute]
public static bool IsCliRefClassType(CppQualType t);
    [ExtensionAttribute]
public static bool IsCliValueClassType(CppQualType t);
    [ExtensionAttribute]
public static bool IsCliGCCompatibleType(CppQualType t);
    [ExtensionAttribute]
public static bool CanBeMemberPointerClassType(CppQualType t);
    [ExtensionAttribute]
public static bool IsHlslVectorType(CppQualType t);
    [ExtensionAttribute]
public static bool IsHlslMatrixType(CppQualType t);
    [ExtensionAttribute]
public static bool IsHlslVectorOrMatrixType(CppQualType t);
    [ExtensionAttribute]
public static bool IsHlslSamplerType(CppQualType t);
    public static Nullable`1<int> GetArraySize(CppQualType t, CppTypeContext& tc);
    public static Nullable`1<int> GetArraySize(ICppExpression sizeExpr, CppTypeContext& tc);
    [ExtensionAttribute]
public static bool IsUnknownArraySize(ICppExpression sizeExpr);
    [ExtensionAttribute]
public static bool IsArrayOfUnknownSize(CppQualType t);
    [ExtensionAttribute]
public static bool IsArrayOfZeroSize(CppQualType t);
    [ExtensionAttribute]
public static bool IsZeroArraySize(ICppExpression sizeExpr);
    [ExtensionAttribute]
public static bool IsCharArray(CppQualType t, CppLanguageDialect dialect);
    [ExtensionAttribute]
public static bool IsDeducedClassTypePlaceholder(CppQualType t);
    [ExtensionAttribute]
public static TriBool IsStructuralType(CppQualType parameterType, CppLanguageDialect dialect);
    [ExtensionAttribute]
public static bool IsRecursiveTypeCalculationFailure(CppQualType type);
    [ExtensionAttribute]
public static bool IsWChar(CppQualType t);
    [ExtensionAttribute]
public static bool IsChar16(CppQualType t);
    [ExtensionAttribute]
public static bool IsChar(CppQualType t);
    [ExtensionAttribute]
public static bool IsChar(CppNumericTypeKind kind);
    [ExtensionAttribute]
public static bool IsBuiltinOrEnumType(CppQualType t);
    [ExtensionAttribute]
public static bool IsMemberFunctionPointer(CppQualType t);
    public static bool HasSameShape(CppQualType lhs, CppQualType rhs);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static CppIntTypeKind GetIntKind(CppQualType type);
    [ExtensionAttribute]
public static bool IsIntegral(CppQualType t);
    [ExtensionAttribute]
public static bool IsFloating(CppQualType t);
    [ExtensionAttribute]
public static bool IsEnum(CppQualType t);
    [ExtensionAttribute]
public static bool IsLinkageClassType(CppQualType t);
    [ExtensionAttribute]
public static bool IsStdInitializerList(CppQualType t);
    [ExtensionAttribute]
public static bool IsStdInitializerList(CppQualType t, CppQualType& innerType);
    [ExtensionAttribute]
public static bool IsAggregateType(CppQualType t, CppViewPos& viewPos);
    [ExtensionAttribute]
public static bool IsAggregateType(CppQualType t, CppViewPos& viewPos, bool allowDependent);
    [ExtensionAttribute]
public static bool IsUnresolvedFunctionReturnType(CppQualType t);
    [ExtensionAttribute]
public static bool IsMagicType(CppQualType t);
    [ExtensionAttribute]
public static bool IsMagicOrAutoType(CppQualType type);
    [ExtensionAttribute]
public static TriBool CanBeConst(CppQualType type);
    [ExtensionAttribute]
public static TriBool CanBePointerToConst(CppQualType type);
    [ExtensionAttribute]
public static bool IsTypeWithTrivialDestructor(CppQualType t, CppViewPos& vp);
    [ExtensionAttribute]
public static bool IsDefaultConstructible(CppQualType t, CppTypeContext& tc);
    [ExtensionAttribute]
public static bool IsTriviallyDefaultConstructible(CppQualType t, CppTypeContext& tc);
    [ExtensionAttribute]
public static bool IsTriviallyDestructible(CppQualType t, CppViewPos& vp);
    [ExtensionAttribute]
public static bool IsTriviallyCopyable(CppQualType t, CppViewPos& vp);
    [ExtensionAttribute]
public static bool IsCopyConstructible(CppQualType type, CppTypeContext& ctx, ICppFriendDeclTargetResolveEntity accessScope);
    [ExtensionAttribute]
public static bool IsMoveConstructible(CppQualType type, CppTypeContext& ctx, ICppFriendDeclTargetResolveEntity accessScope);
    [ExtensionAttribute]
public static bool IsMoveAssignable(CppQualType type, CppTypeContext& ctx, ICppFriendDeclTargetResolveEntity accessScope);
    public static bool IsMoreQualified(CVQualifiers lhs, CVQualifiers rhs);
    public static bool IsMoreOrEquallyQualified(CVQualifiers lhs, CVQualifiers rhs);
    [ExtensionAttribute]
public static ICppExpression GetArraySizeExpression(CppQualType t);
    [ExtensionAttribute]
public static ICppExpression GetCliArrayRankExpression(CppQualType t);
    [ExtensionAttribute]
public static Nullable`1<int> GetCliArrayRank(CppQualType t, CppTypeContext& tc);
    public static CppQualType DropArraySize(CppQualType t, ICppResolvedTypeFactory tf);
    public static bool IsAnyPointerOrHandleConversionToAccessibleAndUnambiguousBase(CppQualType from, CppQualType to, CppTypeContext& tc);
    public static TriBool MatchesForExceptionHandling(CppQualType thrown, CppQualType handler, CppTypeContext& tc);
    [ExtensionAttribute]
public static int GetArithmeticTypeSize(CppQualType t, CppLanguageDialect dialect);
    [ExtensionAttribute]
public static bool IsUnscopedEnum(CppQualType t);
    [ExtensionAttribute]
public static bool IsSigned(CppQualType t);
    [ExtensionAttribute]
public static bool IsDerivedFrom(CppQualType derived, CppQualType base, CppViewPos& viewPos);
    [ExtensionAttribute]
public static bool IsDerivedFromAllowingCliNumeric(CppQualType derived, CppQualType base, CppViewPos& viewPos);
    [ExtensionAttribute]
public static bool IsDerivedFromAllowingGeneric(CppQualType derived, CppQualType base, CppViewPos& viewPos);
    [ExtensionAttribute]
public static bool IsSameOrDerivedFrom(CppQualType derived, CppQualType base, CppViewPos& viewPos);
    public static bool AreSameOrInheritanceRelatedClasses(CppQualType lhs, CppQualType rhs, CppViewPos& viewPos);
    public static CppReferenceRelation GetReferenceRelation(CppQualType lhs, CppQualType rhs, CppTypeContext& tc, Boolean& derivedToBase);
    public static CppReferenceRelation GetReferenceRelation(CppQualType t1, CppQualType t2, CppTypeContext& tc);
    [ExtensionAttribute]
public static CppQualType MarkInvalidTypes(CppQualType t, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static ICppDependentTypeResolveEntity GetDependentTypeResolveEntity(CppQualType t);
    [ExtensionAttribute]
public static CppQualType AppendReferenceFlag(CppQualType t, ReferenceFlag refFlag);
    [ExtensionAttribute]
public static CppQualType AppendQualifiers(CppQualType t, Qualifiers quals);
    [ExtensionAttribute]
public static bool HasAnyEllipsis(CppQualType t);
    [ExtensionAttribute]
public static CppEllipsisKind GetEllipsisKind(CppQualType t);
    [ExtensionAttribute]
public static bool HasExplicitThisParameter(CppQualType t);
    [ExtensionAttribute]
public static CppQualType GetDelegateFunctionType(CppQualType t, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static bool IsUnresolvedFunctionWithAutoReturnType(CppQualType type);
    [ExtensionAttribute]
public static bool IsResolvedFunctionWithAutoReturnType(CppQualType t);
    [ExtensionAttribute]
public static CppRestrictionSpecifiers GetRestrictionSpecifiers(CppQualType type);
    [ExtensionAttribute]
public static CppQualType GetTypeWithInputQualifiers(CppQualType type, CppAttributeList attributes);
    [ExtensionAttribute]
public static ICppClassResolveEntity GetResolvedClassTypeEntity(CppQualType t);
    [ExtensionAttribute]
public static ICppClassResolveEntity GetResolvedEnumTypeEntity(CppQualType t);
    [ExtensionAttribute]
public static ICppClassResolveEntity GetResolvedClassOrEnumTypeEntity(CppQualType t);
    [ExtensionAttribute]
public static ICppClassResolveEntity GetResolvedClassOrCliHandleTypeEntity(CppQualType t);
    [ExtensionAttribute]
public static ICppClassResolveEntity GetResolvedClassOrEnumOrCliHandleTypeEntity(CppQualType t);
    [ExtensionAttribute]
public static bool IsBoxable(CppQualType t, CppGlobalNamespaceResolveEntity globalNs);
    [ExtensionAttribute]
public static CppQualType GetCliObjectHandleType(ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType GetCliStringHandleType(ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static bool IsCliStringHandleType(CppQualType t);
    [ExtensionAttribute]
public static bool IsCliStringClassType(CppQualType t);
    [ExtensionAttribute]
public static ICppTypeTemplateParameterOrPack GetTemplateParameterResolveEntity(CppQualType t);
    [ExtensionAttribute]
public static ICppGenericParameter GetGenericParameterResolveEntity(CppQualType t);
    [ExtensionAttribute]
public static CppQualType CanonizeMemberPointerClassType(CppQualType t);
    [ExtensionAttribute]
public static CppQualType GetArrayInnerType(CppQualType t);
    [ExtensionAttribute]
public static CppQualType GetArrayInnerType(CppArrayType t, Qualifiers q);
    [ExtensionAttribute]
public static CppQualType GetArrayInnerType(CppLinkageArrayType t, Qualifiers q);
    [ExtensionAttribute]
public static CppQualType GetCliArrayInnerType(CppQualType t);
    [ExtensionAttribute]
public static CppQualType GetCliArrayInnerType(CppCliArrayType t, Qualifiers q);
    [ExtensionAttribute]
public static CppQualType GetCliArrayInnerType(CppLinkageCliArrayType t, Qualifiers q);
    [ExtensionAttribute]
public static CppQualType GetArrayInnerTypeRecursively(CppQualType t);
    [ExtensionAttribute]
public static int GetArrayDimension(CppQualType t);
    [ExtensionAttribute]
public static CppQualType GetPointeeType(CppQualType t);
    [ExtensionAttribute]
public static CppQualType GetAnyPointeeType(CppQualType t);
    [ExtensionAttribute]
public static CppQualType GetAnyPointerPointeeType(CppQualType t);
    [ExtensionAttribute]
public static CppQualType GetMemberPointerClassType(CppQualType t);
    [ExtensionAttribute]
public static CppQualType GetMemberPointeeType(CppQualType t);
    [ExtensionAttribute]
public static ICppClassResolveEntity GetMemberPointerClassEntity(CppQualType t);
    [ExtensionAttribute]
public static CppQualType UnqualifyAnyPointerInnerType(CppQualType t, ICppResolvedTypeFactory f);
    [ExtensionAttribute]
public static CppQualType GetCliHandlePointeeType(CppQualType t);
    [ExtensionAttribute]
public static CppQualType GetPointeeIfPointer(CppQualType t);
    [ExtensionAttribute]
public static CppQualType GetPointeeIfCliHandle(CppQualType t);
    [ExtensionAttribute]
public static CppQualType GetInnerTypeIfDependentAutoType(CppQualType t);
    public static bool HaveEqualQualifiers(CppQualType lhs, CppQualType rhs);
    public static bool AreSimilarPointers(CppQualType lhs, CppQualType rhs);
    public static bool AreComparableCliHandles(CppQualType lhs, CppQualType rhs, CppTypeContext& tc);
    public static bool AreSimilarNonMemberPointerTypes(CppQualType firstT, CppQualType secondT);
    public static bool AreEqualUpToPointerAndQualificationConversion(CppQualType lhs, CppQualType rhs, CppTypeContext& tc);
    public static bool UnwrapSimilarPointerTypes(CppQualType& firstT, CppQualType& secondT);
    public static bool AreEqualUnqualifiedTypes(CppQualType lhs, CppQualType rhs);
    [ExtensionAttribute]
public static CppQualType GetFunctionReturnType(CppQualType funcT);
    [ExtensionAttribute]
public static CppQualType[] GetFunctionParameterTypes(CppQualType funcT);
    [ExtensionAttribute]
public static CppQualType GetFunctionParameterType(CppQualType funcT, int index);
    [ExtensionAttribute]
public static CppQualType GetResolvedFunctionReturnType(CppQualType funcT);
    [ExtensionAttribute]
public static CppQualType GetUnresolvedFunctionReturnType(CppQualType funcT);
    [ExtensionAttribute]
public static CppQualType GetReplacedFunctionReturnType(CppQualType funcT);
    [ExtensionAttribute]
public static ICppExceptionSpecification GetExceptionSpecification(CppQualType type);
    [ExtensionAttribute]
public static CppUnknownEntityInfo GetUnknownInfo(CppQualType t);
    public static CppQualType GetCompositePointerType(CppExpressionInfo expr, CppExpressionInfo otherExpr, ICppResolvedTypeFactory typeFactory, CppViewPos& viewPos);
    public static CppQualType GetCompositePointerType(CppQualType type, CppQualType otherType, ICppResolvedTypeFactory typeFactory, CppViewPos& viewPos);
    private static CppQualType ChangeMemberClass(CppQualType memPtr, CppQualType newClassT, ICppResolvedTypeFactory factory);
    private static CppQualType ChangeInnerType(CppQualType ptr, CppQualType newInnerT, ICppResolvedTypeFactory factory);
    private static CppQualType MakeSimilarPointerType(CppQualType type, CppQualType otherType, ICppResolvedTypeFactory factory, CppViewPos& viewPos);
    private static bool TryMakeCompositePointerType(CppQualType type, CppQualType otherType, ICppResolvedTypeFactory factory, CppQualType& result);
    [ExtensionAttribute]
public static CppQualType GetCVUnqualifiedArrayType(CppQualType t, ICppResolvedTypeFactory typeFactory, CVQualifiers& quals);
    [ExtensionAttribute]
public static CppQualType WithChangedQualifiersOf(CppQualType t, Qualifiers q);
    [ExtensionAttribute]
public static CppQualType RebindNamedType(CppQualType t, CppViewPos& viewPos);
    [ExtensionAttribute]
public static CppQualType RebindNamedType(CppQualType t, CppViewPos& viewPos, CppViewPos& paramsViewPos);
    [ExtensionAttribute]
public static ICppTypeTemplateInstantiationResolveEntity GetTemplateInstantiationTypeEntity(CppQualType t);
    [ExtensionAttribute]
public static bool CanBeAddressOfFunctionTargetType(CppQualType t);
    [ExtensionAttribute]
public static int GetParamCount(CppFunctionType t);
    [ExtensionAttribute]
public static int GetNonVariadicParamCount(CppFunctionType t);
    [ExtensionAttribute]
public static CppNumericType GetNumericType(CppQualType type);
    [ExtensionAttribute]
public static HlslVectorType GetHlslVectorType(CppQualType t);
    [ExtensionAttribute]
public static HlslMatrixType GetHlslMatrixType(CppQualType t);
    [ExtensionAttribute]
public static CppNumericTypeKind GetHlslComponentTypeKind(CppQualType t);
    [ExtensionAttribute]
public static HlslSamplerType GetHlslSamplerType(CppQualType t);
    [ExtensionAttribute]
public static ICppClassResolveEntity GetResolvedBoxableCliClassTypeEntity(CppQualType t, CppGlobalNamespaceResolveEntity globalNs);
    [ExtensionAttribute]
public static CppValueCategory PickCategoryForCallResultType(CppQualType resultType);
    private static CppTypeAndCategory AdjustPRValue(CppTypeAndCategory tc);
    [ExtensionAttribute]
public static CppTypeAndCategory GetTypeAndCategoryForCallReturnType(CppQualType resultType);
    public static CppTypeAndCategory GetClassMemberTypeAndCategory(CppTypeAndCategory objType, CppQualType memberType, bool isMutable);
    [ExtensionAttribute]
public static CppValueCategory PickCategoryForCastResultType(CppQualType resultType);
    [ExtensionAttribute]
public static CppTypeAndCategory GetTypeAndCategoryForCastResult(CppQualType resultType);
    [ExtensionAttribute]
public static bool IsObjectType(CppQualType t);
    [ExtensionAttribute]
public static bool IsObjectPointerType(CppQualType t);
    [ExtensionAttribute]
public static bool IsCompleteType(CppQualType t, CppViewPos& viewPos);
    [ExtensionAttribute]
public static bool IsCompleteClassType(CppQualType t, CppViewPos& viewPos);
    [ExtensionAttribute]
public static CppIsModifiableLValueResult CheckModifiableLValue(CppTypeAndCategory tt, CppViewPos& vp);
    [ExtensionAttribute]
public static CppCallingConvention GetCallingConvention(CppQualType type);
    [ExtensionAttribute]
public static CppQualType ChangeDefaultCallingConventionToDefaultMember(CppQualType type, ICppResolvedTypeFactory tf, Boolean& changed);
    [ExtensionAttribute]
public static CppQualType ChangeUnspecifiedCallingConventionToDefault(CppQualType type, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType ChangeCallingConvention(CppQualType type, CppCallingConvention old, CppCallingConvention new_, ICppResolvedTypeFactory tf, Boolean& changed);
    [ExtensionAttribute]
public static CppQualType DiscardCallingConvention(CppQualType type, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppTypeAndCategory DoLvalToRValConv(CppTypeAndCategory t);
    [ExtensionAttribute]
public static CppTypeAndCategory DoArrayToPtrConv(CppTypeAndCategory t, ICppResolvedTypeFactory typeFactory);
    [ExtensionAttribute]
public static CppQualType DoArrayToPtrConv(CppQualType t, ICppResolvedTypeFactory typeFactory);
    [ExtensionAttribute]
public static CppQualType DoFuncToPtrConv(CppQualType t, ICppResolvedTypeFactory typeFactory);
    [ExtensionAttribute]
public static CppQualType NormalizeFunctionTypeForOverride(CppQualType type, ICppResolvedTypeFactory typeFact);
    [ExtensionAttribute]
public static CppQualType ReplaceFunctionReturnType(CppQualType type, CppQualType returnType, ICppResolvedTypeFactory typeFact);
    [ExtensionAttribute]
public static CppQualType BuildCliHandleTypeWithFromQuals(CppQualType fromT, CppQualType toT, ICppResolvedTypeFactory typeFactory);
    [ExtensionAttribute]
public static CppQualType BuildAnyPointerTypeWithFromQuals(CppQualType fromT, CppQualType toT, ICppResolvedTypeFactory typeFactory);
    [ExtensionAttribute]
public static CppQualType BuildSamePointerType(CppQualType toT, CppQualType resPointeeT, ICppResolvedTypeFactory typeFactory);
    [ExtensionAttribute]
public static CppQualType AdjustFunctionParameterType(CppQualType type, ICppResolvedTypeFactory typeFact);
    [ExtensionAttribute]
public static CppQualType NormalizeFunctionParameterType(CppQualType type, ICppResolvedTypeFactory typeFact);
    [ExtensionAttribute]
public static CppQualType NormalizeFunctionType(CppQualType type, ICppResolvedTypeFactory typeFact);
    [ExtensionAttribute]
public static CppQualType[] NormalizeFunctionTypeParameters(CppQualType[] params, ICppResolvedTypeFactory typeFact);
    [ExtensionAttribute]
public static CppQualType ReplaceFunctionParameterTypes(CppQualType type, CppQualType[] parameterTypes, ICppResolvedTypeFactory typeFact);
    [ExtensionAttribute]
public static CppQualType ReplaceFunctionParameterType(CppQualType type, int index, CppQualType newParamType, ICppResolvedTypeFactory typeFact);
    internal static bool NeedDecorationToPreserveSpelling(CppQualType type, CppQualifiedNamePart reference, ICppResolveEntity referencedEntity, CppViewPos viewPos);
    private static bool QualifierIsInteresting(CppQualifiedName qualifier);
    [ExtensionAttribute]
public static CppQualType DecorateTypeAfterLookup(CppQualType type, ICppResolveEntity resolveEntity, CppQualifiedName name, CppViewPos viewPos, ICppResolvedTypeFactory tf);
    private static bool NamesAreEqual(CppQualifiedName name, CppQualifiedNamePart head, CppQualifiedName tail, CppEqualityComparer comparer);
    [ExtensionAttribute]
public static CppQualType DropDecorations(CppQualType type, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType DropDeclSpecPlacement(CppQualType type, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType DropClassTagDeclSpecPlacement(CppQualType type, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType WithRemovedDeclSpecPlacement(CppQualType type, CppDeclSpecKind spec);
    [ExtensionAttribute]
public static bool ContainsUnknownType(CppQualType type);
    [ExtensionAttribute]
public static ICppDecoratedFunctionParameter GetDecoratedFunctionParameter(CppQualType paramType);
    public static IList`1<CppQualType> GetUserDefinedLiteralOperatorParameterTypes(CppUserDefinedLiteralValueKind kind, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static TResult VisitValueKind(CppQualType qualType, ICppQualTypeValueKindVisitor`1<TResult> visitor, CppViewPos& viewPos);
    [ExtensionAttribute]
public static bool ShouldInternateTypeWithTypeFactory(CppQualType t);
    [ExtensionAttribute]
public static CppDependentInfo GetDependentInfo(CppQualType input);
    [ExtensionAttribute]
public static bool IsDependentAndNotCurrentInstantiation(CppQualType input, CppViewPos& viewPos);
    [ExtensionAttribute]
public static CppQualType AddSubstitutionFailure(CppQualType substitutionResult, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static ICppScopeLikeResolveEntity PickResolveScope(CppQualType input, ICppResolveEntity globalNamespaceHint);
    [ExtensionAttribute]
public static IEnumerable`1<ICppDeclaratorResolveEntity> CollectTypedefsInType(CppQualType type);
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertTypeClass(CppQualType input, CppTypeClasses typec);
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertCallingConventionIsSpecified(CppQualType type);
    [ExtensionAttribute]
public static bool HasSubstitutionFailure(CppQualType t);
    [ExtensionAttribute]
public static CppUnknownEntityInfo FindSubstitutionFailure(CppQualType t);
    [ExtensionAttribute]
public static int HashCode(CppQualType input);
    [ExtensionAttribute]
internal static int HashCode(CppQualType input, HashCodeWithEqualityComparerVisitor visitor);
    [ExtensionAttribute]
public static int HashCode(CppQualType input, ICppEqualityComparer equalComparer);
    [ExtensionAttribute]
public static int HashCodeDistinguishingTemplateParams(CppQualType input);
    [ExtensionAttribute]
public static int HashCodeIgnoringFunctionReturnType(CppQualType input);
    public static bool Equals(CppQualType lhs, CppQualType rhs);
    [AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertEquals(CppQualType lhs, CppQualType rhs);
    public static bool EqualsIgnoringMagicType(CppQualType lhs, CppQualType rhs);
    public static bool EqualsDistinguishingTemplateParamsAndDecorations(CppQualType lhs, CppQualType rhs);
    public static bool EqualsIgnoringFunctionReturnType(CppQualType lhs, CppQualType rhs);
    public static bool EqualsIgnoringFunctionReturnTypeAndMagicTypes(CppQualType lhs, CppQualType rhs);
    [ExtensionAttribute]
public static bool CanBePresented(CppQualType type, ICppScopeResolveEntity scope);
    [ExtensionAttribute]
public static bool CanBePresentedAllowingLambdas(CppQualType type, ICppScopeResolveEntity scope);
    [ExtensionAttribute]
public static bool IsValidTypeForPresentation(CppQualType t);
    [ExtensionAttribute]
public static void FindDeducibleTemplateParameterTags(CppQualType t, ICollection`1<CppTemplateParameterTag> output);
    [ExtensionAttribute]
public static CppQualType GetPredefinedQualTypeForSizeT(CppLanguageDialect dialect);
    [ExtensionAttribute]
public static CppQualType GetPredefinedQualTypeForPtrdiffT(CppLanguageDialect dialect);
    [ExtensionAttribute]
public static CppQualType GetPredefinedQualTypeForSizeT(ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType GetPredefinedQualTypeForPtrdiffT(ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType GetQualTypeForSizeT(CppGlobalNamespaceResolveEntity globalNs, ICppResolvedTypeFactory typeFactory);
    [ExtensionAttribute]
public static CppQualType GetQualTypeForSizeT(ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType GetInnerTypeIfDecoratedFunctionParameter(CppQualType paramType);
    [ExtensionAttribute]
public static CppQualType GetImplicitObjectParameterType(ICppClassResolveEntity cls, Qualifiers methodQuals, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType GetThisTypeByObjectType(CppQualType objType, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static bool IsDependentMemberAccessScopeType(CppQualType type, CppViewPos& vp);
    [ExtensionAttribute]
public static TriBool IsConstDefaultConstructible(ICppClassResolveEntity cls, CppViewPos& vp);
    private static TriBool IsConstDefaultConstructibleImpl(ICppClassResolveEntity cls, CppViewPos& vp, JetHashSet`1<ICppClassResolveEntity> visited);
    private static bool UnionHasSingleMemberWithDefaultInitializer(ICppClassResolveEntity cls);
    [ExtensionAttribute]
public static CppDefaultInitializationError GetTypeDefaultInitializationError(CppQualType targetType, CppTypeContext& tc, ICppTemplateFunctionCallDeductionErrorConsumer errorConsumer);
    [ExtensionAttribute]
public static CppDefaultInitializationError GetTypeDefaultInitializationError(CppQualType targetType, CppTypeContext& tc);
    [ExtensionAttribute]
public static CppDefaultInitializationError GetTypeDefaultInitializationError(CppQualType targetType, ICppFriendDeclTargetResolveEntity scope, CppTypeContext& tc, ICppTemplateFunctionCallDeductionErrorConsumer errorConsumer);
    [ExtensionAttribute]
public static CppDefaultInitializationError GetTypeDefaultInitializationError(CppQualType targetType, ICppFriendDeclTargetResolveEntity scope, CppTypeContext& tc);
    [ExtensionAttribute]
public static CppDefaultInitializationError GetBaseClassDefaultInitializationError(ICppClassResolveEntity base, ICppClassResolveEntity derived, CppTypeContext& tc);
    [ExtensionAttribute]
public static CppDefaultInitializationError GetClassDefaultInitializationError(ICppClassResolveEntity cls, ICppFriendDeclTargetResolveEntity scope, CppTypeContext& tc, ICppTemplateFunctionCallDeductionErrorConsumer errorConsumer);
    private static CppDefaultInitializationError GetClassDefaultInitializationErrorImpl(ICppClassResolveEntity cls, ICppClassResolveEntity owningClass, ICppFriendDeclTargetResolveEntity scope, CppTypeContext& tc, ICppTemplateFunctionCallDeductionErrorConsumer templateDeductionErrorConsumer);
    [ExtensionAttribute]
public static CppQualifiedName GetTypeReferenceTypeName(CppQualType t);
    [ExtensionAttribute]
public static CppQualifiedName GetNameSuggestionTypeName(CppQualType t);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static CppNameSuggestionType GetNameSuggestion(CppQualType t);
    [ExtensionAttribute]
public static CppQualType DropFunctionParameterNames(CppQualType type, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType CVUnqualifyFunctionParameters(CppQualType type, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static CppQualType DropNamedParameterDecoration(CppQualType type);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static CppTypedefType GetTypedef(CppQualType type);
    [ExtensionAttribute]
public static CppQualType GetScopeSuggestion(CppQualType type);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static CppInstantiatedTemplateAliasType GetTemplateAlias(CppQualType type);
    public static CppQualType BindingType(CppTypeAndCategory type, ICppResolvedTypeFactory factory);
    public static CppQualType BuiltinSubscriptType(CppTypeAndCategory leftT, CppTypeAndCategory rightT, ICppResolvedTypeFactory typeFactory);
    [ExtensionAttribute]
public static CppQualType TransformResolvedToLinkageType(CppQualType t, CppCreateLinkageEntityContext context);
    [ExtensionAttribute]
public static CppQualType CreateClassAndReplaceClassType(CppQualType input, CppCreateClassAndReplaceClassTypeContext& ctx);
    [ExtensionAttribute]
public static CppQualType CreateClassAndReplaceClassType(CppQualType input, CreateClassAndReplaceClassTypeVisitor visitor);
    [ExtensionAttribute]
public static CppQualType CreateClassAndReplaceClassTypeAndMarkParameterList(CppQualType input, CreateClassAndReplaceClassTypeVisitor visitor);
    [ExtensionAttribute]
public static bool ShouldNotBeSuggestedIfThereAreAlternatives(CppQualType t);
    [ExtensionAttribute]
public static CppQualType RemoveRedundantQualifierInDeclSpecs(CppQualType t, ICppResolveEntity qualifier, CppTypeContext& tc);
    [ExtensionAttribute]
public static CppTypeAndCategory DoNormalConversions(CppTypeAndCategory t, ICppResolvedTypeFactory typeFactory);
    [ExtensionAttribute]
public static CppQualType DoIntegralPromotion(CppQualType t, CppLanguageDialect dialect);
    private static CppQualType DoIntegralPromotionInternal(CppNumericType t, CppLanguageDialect dialect);
    public static bool IsIntegralPromotion(CppQualType from, CppQualType to, CppLanguageDialect dialect);
    public static bool IsFloatingPromotion(CppQualType from, CppQualType to);
    public static bool IsHlslFloatingPromotion(CppNumericTypeKind from, CppNumericTypeKind to, CppLanguageDialect dialect);
    public static bool IsHlslFloatingPromotion(CppQualType from, CppQualType to, CppLanguageDialect dialect);
    public static bool IsHlslFloatingConversion(CppNumericTypeKind from, CppNumericTypeKind to);
    public static bool IsClrcallConversion(CppExpressionInfo from, CppQualType toT, ICppResolvedTypeFactory typeFactory);
    public static bool IsMemberPointerConversion(CppQualType from, CppQualType to, CppTypeContext& tc);
    public static CppPointerConversionKind ClassifyPointerConversion(CppQualType from, CppQualType to, CppTypeContext& tc);
    private static bool FunctionTypesAreEqualExludingNoexcept(CppQualType from, CppQualType to, CppTypeContext& tc);
    public static CppBaseKindResult GetBaseKind(CppQualType derivedT, CppQualType baseT, CppViewPos& viewPos);
    public static bool IsOverride(CppQualType derived, CppQualType base, ICppResolvedTypeFactory typeFact);
    public static bool AreFunctionReturnTypesSameOrCovariant(CppQualType derived, CppQualType base, CppViewPos& viewPos);
    public static bool IsAccessibleAndUnambiguousBase(CppQualType derivedT, CppQualType baseT, CppViewPos& viewPos);
    public static bool IsHlslExtensionConversion(CppQualType from, CppQualType to);
    public static bool IsHlslTruncationConversion(CppQualType from, CppQualType to);
    public static CppCliHandleConversionKind ClassifyCliHandleConversion(CppQualType from, CppQualType to, CppTypeContext& tc, bool allowObject);
    public static bool IsQualificationConversion(CppQualType fromT, CppQualType toT, bool cStyle);
    public static bool IsHlslQualificationConversion(CppQualType fromT, CppQualType toT);
    public static bool IsMoreOrEquallyQualifiedTypeForConversion(CppQualType to, CppQualType from, bool cStyle);
    [ExtensionAttribute]
public static IEnumerable`1<CppQualType> WhereNotUnknown(IEnumerable`1<CppQualType> elements);
    [ExtensionAttribute]
public static CppQualType Substitute(CppQualType type, CppSubstitutionContext sctx, CppTypeContext tctx);
    public static CppQualType GetHlslComparingOperatorResultType(CppQualType lhsT, CppQualType rhsT);
    [ExtensionAttribute]
public static CppQualType DoUsualArithmeticConversions(CppQualType lhsT, CppQualType rhsT, CppLanguageDialect dialect);
    private static CppNumericType DoUsualArithmeticConversionsWithNumeric(CppNumericType lhsT, CppNumericType rhsT, CppLanguageDialect dialect);
    private static CppNumericType DoUsualHlslArithmeticConversions(CppNumericType lhsT, CppNumericType rhsT, CppLanguageDialect dialect);
    private static CppQualType DoUsualHlslArithmeticConversions(CppQualType lhsT, CppQualType rhsT, CppLanguageDialect dialect);
    private static CppNumericType GetNumericOrHlslComponentType(CppQualType t);
    private static CppQualType CreateCommonType(CppNumericType componentType, CppQualType lhsT, CppQualType rhsT);
    private static CppQualType CreateSimilarType(CppQualType baseType, CppNumericType componentType);
    private static bool UnwrapPointerAndCheckQuals(bool cStyle, Boolean& unwrappedAnyPointer, CppQualType& fromT, CppQualType& toT);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppTypeWithClassResolveEntity : CppType {
    [CompilerGeneratedAttribute]
private ICppClassResolveEntity <ResolveEntity>k__BackingField;
    public ICppClassResolveEntity ResolveEntity { get; }
    protected CppTypeWithClassResolveEntity(ICppClassResolveEntity resolveEntity);
    [CompilerGeneratedAttribute]
public ICppClassResolveEntity get_ResolveEntity();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppTypeWithClassSymbol : CppType {
    [CompilerGeneratedAttribute]
private ICppClassSymbol <Symbol>k__BackingField;
    public ICppClassSymbol Symbol { get; }
    protected CppTypeWithClassSymbol(ICppClassSymbol classSymbol);
    [CompilerGeneratedAttribute]
public ICppClassSymbol get_Symbol();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppTypeWithInnerType : CppTypeWithInnerTypeInterface {
    private CppQualType myInnerType;
    public CppQualType InnerType { get; }
    protected CppTypeWithInnerType(CppQualType inner);
    public virtual CppQualType get_InnerType();
    public virtual void SetInnerType(CppQualType t);
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppTypeWithInnerTypeInterface : CppType {
    public CppQualType InnerType { get; }
    public abstract virtual CppQualType get_InnerType();
    public abstract virtual void SetInnerType(CppQualType t);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppUnaryTypingResult : ValueType {
    public CppTypeAndCategory ResultType;
    public CppTypeAndCategory LeftOperandType;
    public CppUnaryTypingResult(CppTypeAndCategory resultType, CppTypeAndCategory leftOperandType);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppUnknownType : CppType {
    public static CppUnknownType InternalFailure;
    public static CppUnknownType InternalErrorDuringSubstitutionFailure;
    public static CppUnknownType RecursiveTypeCalculationFailure;
    public static CppUnknownType RecursiveTypeCalculationDuringSubstitutionFailure;
    public static CppUnknownType LookupFailure;
    public static CppUnknownType LookupErrorDuringSubstitutionFailure;
    public static CppUnknownType FailedToDeduceReturnTypeOfDefaultedComparisonFunction;
    public static CppUnknownType RewrittenEqualityCandidateDoesNotReturnBool;
    public static CppUnknownType TypeOfBracedInitList;
    public static CppUnknownType TypeOfFunctionOverloadSet;
    public static CppUnknownType ClassTemplateArgumentDeductionFail;
    public static CppUnknownType TypeInfoLookupFailure;
    public static CppUnknownType NontypeResolveEntityUsedAsTypeFailure;
    [CompilerGeneratedAttribute]
private CppUnknownEntityInfo <Info>k__BackingField;
    public CppUnknownEntityInfo Info { get; }
    public CppUnknownType(CppUnknownEntityInfo info);
    private static CppUnknownType();
    [CompilerGeneratedAttribute]
public CppUnknownEntityInfo get_Info();
    public static CppUnknownType Create(CppUnknownEntityInfo info);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppUnresolvedDeclarationSpecifierTypeBuilder : CppBasicDeclarationSpecifierTypeBuilder {
    private CppSymbolTypeIntern myTypeIntern;
    public CppUnresolvedDeclarationSpecifierTypeBuilder(CppSymbolTypeIntern typeIntern, CppLanguageDialect dialect);
    public sealed virtual void LearnClassType(ICppClassSymbol sym);
    public void Init(CppSymbolTypeIntern typeIntern, CppLanguageDialect dialect);
    public void Clear();
    protected virtual CppQualType InternateType(CppQualType t);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppUnresolvedFunctionMultipleArgumentsType : CppUnresolvedFunctionType {
    private CppFileLocation myContainingFile;
    private CppParameterDeclaratorData[] myParameters;
    private UInt32 myPackedIsParameterPack;
    public CppFileLocation ContainingFile { get; }
    public CppParameterDeclaratorData[] Parameters { get; }
    public UInt32 PackedIsParameterPack { get; }
    public CppParameterDeclaratorsData ParametersData { get; }
    public CppQualType[] ParameterTypes { get; }
    internal CppUnresolvedFunctionMultipleArgumentsType(CppQualType returnType, CppFunctionFlags flags, CppParameterDeclaratorsData params);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public CppFileLocation get_ContainingFile();
    public virtual int ParametersCount();
    public virtual bool HasAutoParams();
    public virtual bool WithImplicitIntParams();
    public virtual void GetMinMaxFunctionArgumentsCount(Int32& minCount, Int32& maxCount);
    public CppParameterDeclaratorData[] get_Parameters();
    public UInt32 get_PackedIsParameterPack();
    public CppParameterDeclaratorsData get_ParametersData();
    public virtual CppQualType[] get_ParameterTypes();
    public CppParameterDeclaratorSymbol CreateParameterDeclaratorSymbol(int idx);
    public virtual CppParameterDeclaratorSymbol[] CreateParameterDeclaratorSymbols();
    public bool IsParameterPack(int idx);
    protected virtual void UpdateParametersLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    protected virtual void PresentParameters(StringBuilder result);
    protected virtual bool ParametersAreEqual(CppUnresolvedFunctionType other, ICppEqualityComparer engine);
    internal static CppUnresolvedFunctionMultipleArgumentsType Create(CppQualType returnType, CppFunctionFlags flags, CppQualType trailingReturnType, ICppExceptionSpecification exceptionSpecification, CppParameterDeclaratorsData params);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppUnresolvedFunctionSingleArgumentType : CppUnresolvedFunctionType {
    private CppFileLocation myContainingFile;
    private CppParameterDeclaratorData myParameter;
    private bool myParamIsPack;
    public CppFileLocation ContainingFile { get; }
    public CppParameterDeclaratorData& Parameter { get; }
    public bool ParameterIsPack { get; }
    public CppQualType[] ParameterTypes { get; }
    internal CppUnresolvedFunctionSingleArgumentType(CppQualType returnType, CppFunctionFlags flags, CppParameterDeclaratorData param, bool isParameterPack, CppFileLocation containingFile);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public CppFileLocation get_ContainingFile();
    public CppParameterDeclaratorData& get_Parameter();
    public bool get_ParameterIsPack();
    public virtual int ParametersCount();
    public virtual bool HasAutoParams();
    public virtual bool WithImplicitIntParams();
    public virtual void GetMinMaxFunctionArgumentsCount(Int32& minCount, Int32& maxCount);
    public virtual CppQualType[] get_ParameterTypes();
    public virtual CppParameterDeclaratorSymbol[] CreateParameterDeclaratorSymbols();
    public CppParameterDeclaratorSymbol CreateParameterDeclaratorSymbol();
    protected virtual void PresentParameters(StringBuilder result);
    protected virtual void UpdateParametersLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    protected virtual bool ParametersAreEqual(CppUnresolvedFunctionType other, ICppEqualityComparer engine);
    internal static CppUnresolvedFunctionType Create(CppQualType returnType, CppFunctionFlags flags, CppQualType trailingReturnType, ICppExceptionSpecification exceptionSpecification, CppParameterDeclaratorData param, bool isParameterPack, CppFileLocation containingFile);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppUnresolvedFunctionSingleArgumentWithExceptionSpecificationType : CppUnresolvedFunctionSingleArgumentWithTrailingReturnType {
    [CompilerGeneratedAttribute]
private ICppExceptionSpecification <ExceptionSpecification>k__BackingField;
    public ICppExceptionSpecification ExceptionSpecification { get; }
    internal CppUnresolvedFunctionSingleArgumentWithExceptionSpecificationType(CppQualType returnType, CppFunctionFlags flags, CppParameterDeclaratorData param, bool isParameterPack, CppFileLocation containingFile, CppQualType trailingReturnType, ICppExceptionSpecification exceptionSpecification);
    [CompilerGeneratedAttribute]
public virtual ICppExceptionSpecification get_ExceptionSpecification();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppUnresolvedFunctionSingleArgumentWithTrailingReturnType : CppUnresolvedFunctionSingleArgumentType {
    [CompilerGeneratedAttribute]
private CppQualType <TrailingReturnType>k__BackingField;
    public CppQualType TrailingReturnType { get; }
    internal CppUnresolvedFunctionSingleArgumentWithTrailingReturnType(CppQualType returnType, CppFunctionFlags flags, CppParameterDeclaratorData param, bool isParameterPack, CppFileLocation containingFile, CppQualType trailingReturnType);
    [CompilerGeneratedAttribute]
public virtual CppQualType get_TrailingReturnType();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppUnresolvedFunctionType : CppTypeWithInnerTypeInterface {
    private CppFunctionBasicData myData;
    public CppQualType InnerType { get; }
    internal CppFunctionFlags Flags { get; }
    public CppEllipsisKind EllipsisKind { get; }
    public CppCallingConvention CallingConvention { get; }
    public CppRestrictionSpecifiers RestrictionSpecifiers { get; }
    public CppQualType ReturnType { get; }
    public CppQualType[] ParameterTypes { get; }
    public CppQualType TrailingReturnType { get; }
    [CanBeNullAttribute]
public ICppExceptionSpecification ExceptionSpecification { get; }
    internal CppUnresolvedFunctionType(CppQualType returnType, CppFunctionFlags flags);
    public virtual CppQualType get_InnerType();
    public sealed virtual void SetInnerType(CppQualType t);
    internal CppFunctionFlags get_Flags();
    public CppEllipsisKind get_EllipsisKind();
    public CppCallingConvention get_CallingConvention();
    public CppRestrictionSpecifiers get_RestrictionSpecifiers();
    public CppQualType get_ReturnType();
    public abstract virtual CppQualType[] get_ParameterTypes();
    public abstract virtual CppParameterDeclaratorSymbol[] CreateParameterDeclaratorSymbols();
    public virtual CppQualType get_TrailingReturnType();
    public virtual ICppExceptionSpecification get_ExceptionSpecification();
    public abstract virtual int ParametersCount();
    public abstract virtual bool HasAutoParams();
    public abstract virtual bool WithImplicitIntParams();
    public abstract virtual void GetMinMaxFunctionArgumentsCount(Int32& minCount, Int32& maxCount);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
    protected abstract virtual void PresentParameters(StringBuilder result);
    protected abstract virtual void UpdateParametersLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    protected abstract virtual bool ParametersAreEqual(CppUnresolvedFunctionType other, ICppEqualityComparer engine);
    protected static CppQualType CreateParameterType(CppParameterDeclaratorData param, bool isPack);
    protected static CppParameterDeclaratorSymbol CreateParameterDeclaratorSymbol(CppParameterDeclaratorData data, CppFileLocation containingFile, bool isPack);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppUnresolvedFunctionWithExceptionSpecificationType : CppUnresolvedFunctionWithTrailingReturnType {
    [CompilerGeneratedAttribute]
private ICppExceptionSpecification <ExceptionSpecification>k__BackingField;
    public ICppExceptionSpecification ExceptionSpecification { get; }
    internal CppUnresolvedFunctionWithExceptionSpecificationType(CppQualType returnType, CppFunctionFlags flags, CppParameterDeclaratorsData params, CppQualType trailingReturnType, ICppExceptionSpecification exceptionSpecification);
    [CompilerGeneratedAttribute]
public virtual ICppExceptionSpecification get_ExceptionSpecification();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppUnresolvedFunctionWithoutArgumentsType : CppUnresolvedFunctionType {
    public CppQualType[] ParameterTypes { get; }
    internal CppUnresolvedFunctionWithoutArgumentsType(CppQualType returnType, CppFunctionFlags flags);
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual int ParametersCount();
    public virtual bool HasAutoParams();
    public virtual bool WithImplicitIntParams();
    public virtual void GetMinMaxFunctionArgumentsCount(Int32& minCount, Int32& maxCount);
    public virtual CppQualType[] get_ParameterTypes();
    public virtual CppParameterDeclaratorSymbol[] CreateParameterDeclaratorSymbols();
    protected virtual void PresentParameters(StringBuilder result);
    protected virtual void UpdateParametersLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    protected virtual bool ParametersAreEqual(CppUnresolvedFunctionType other, ICppEqualityComparer engine);
    internal static CppUnresolvedFunctionType Create(CppQualType returnType, CppFunctionFlags flags, CppQualType trailingReturnType, ICppExceptionSpecification exceptionSpecification);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppUnresolvedFunctionWithoutArgumentsWithExceptionSpecificationType : CppUnresolvedFunctionWithoutArgumentsWithTrailingReturnType {
    [CompilerGeneratedAttribute]
private ICppExceptionSpecification <ExceptionSpecification>k__BackingField;
    public ICppExceptionSpecification ExceptionSpecification { get; }
    internal CppUnresolvedFunctionWithoutArgumentsWithExceptionSpecificationType(CppQualType returnType, CppFunctionFlags flags, CppQualType trailingReturnType, ICppExceptionSpecification exceptionSpecification);
    [CompilerGeneratedAttribute]
public virtual ICppExceptionSpecification get_ExceptionSpecification();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppUnresolvedFunctionWithoutArgumentsWithTrailingReturnType : CppUnresolvedFunctionWithoutArgumentsType {
    [CompilerGeneratedAttribute]
private CppQualType <TrailingReturnType>k__BackingField;
    public CppQualType TrailingReturnType { get; }
    internal CppUnresolvedFunctionWithoutArgumentsWithTrailingReturnType(CppQualType returnType, CppFunctionFlags flags, CppQualType trailingReturnType);
    [CompilerGeneratedAttribute]
public virtual CppQualType get_TrailingReturnType();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppUnresolvedFunctionWithTrailingReturnType : CppUnresolvedFunctionMultipleArgumentsType {
    [CompilerGeneratedAttribute]
private CppQualType <TrailingReturnType>k__BackingField;
    public CppQualType TrailingReturnType { get; }
    internal CppUnresolvedFunctionWithTrailingReturnType(CppQualType returnType, CppFunctionFlags flags, CppParameterDeclaratorsData params, CppQualType trailingReturnType);
    [CompilerGeneratedAttribute]
public virtual CppQualType get_TrailingReturnType();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppUnresolvedTypeBuilder : CppBasicTypeBuilder {
    private CppSymbolTypeIntern myTypeIntern;
    public CppUnresolvedTypeBuilder(CppSymbolTypeIntern typeIntern);
    public void Init(CppSymbolTypeIntern typeIntern);
    public sealed virtual ICppUnresolvedTypeBuilder CreateUnresolvedTypeBuilderForPartInParens();
    public sealed virtual void LearnTypePartInParens(ICppUnresolvedTypeBuilder b);
    public sealed virtual void LearnDeclarationSpecifierType();
    public sealed virtual bool IsFunction();
    protected virtual CppQualType InternateType(CppQualType t);
}
public enum JetBrains.ReSharper.Psi.Cpp.Types.CppValueCategory : Enum {
    public byte value__;
    public static CppValueCategory L_VALUE;
    public static CppValueCategory GC_L_VALUE;
    public static CppValueCategory X_VALUE;
    public static CppValueCategory PR_VALUE;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Types.CppValueCategoryUtil : object {
    [ExtensionAttribute]
public static CppValueCategory MakeGCLValueOrLValue(CppValueCategory cat);
    [ExtensionAttribute]
public static bool IsLValue(CppValueCategory cat);
    [ExtensionAttribute]
public static bool IsGCLValue(CppValueCategory cat);
    [ExtensionAttribute]
public static bool IsAnyLValue(CppValueCategory cat);
    [ExtensionAttribute]
public static bool IsXValue(CppValueCategory cat);
    [ExtensionAttribute]
public static bool IsPRValue(CppValueCategory cat);
    [ExtensionAttribute]
public static bool IsRValue(CppValueCategory cat);
    [ExtensionAttribute]
public static bool IsGLValue(CppValueCategory cat);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppVectorType : CppTypeWithInnerType {
    public ICppExpression Size;
    public CppQualType ElementType { get; }
    public CppVectorType(CppQualType elementType, ICppExpression size);
    public CppQualType get_ElementType();
    public virtual TResult Accept(ICppTypeVisitor`1<TResult> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer resultConsumer);
    public virtual string ToString();
    public Nullable`1<int> CalcNumberOfElements(CppTypeContext& tc);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppVerboseTypeFactory : CppVerboseTypeFactoryBase {
    private ICppRootFileResolveEntitiesCache myResolveCache;
    public ICppRootFileResolveEntitiesCache ResolveCache { get; }
    public CppVerboseTypeFactory(ICppRootFileResolveEntitiesCache resolveCache);
    public virtual ICppRootFileResolveEntitiesCache get_ResolveCache();
    public virtual CppLanguageDialect GetDialect();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Types.CppVerboseTypeFactoryBase : CppTypeInternOfBaseTypes {
    private ICppVerboseTypeVisitor`1<CppQualType> myIdentityTypeVisitor;
    public bool IgnoresScopeSuggestions { get; }
    public bool IgnoresNameSuggestions { get; }
    public ICppRootFileResolveEntitiesCache ResolveCache { get; }
    public virtual bool get_IgnoresScopeSuggestions();
    public virtual bool get_IgnoresNameSuggestions();
    public abstract virtual ICppRootFileResolveEntitiesCache get_ResolveCache();
    public abstract virtual CppLanguageDialect GetDialect();
    public virtual CppQualType GetReplacedFunctionType(CppQualType returnType, CppParameterListResolveEntity resolveEntity, CppFunctionFlags flags, CppQualType trailingReturnType, ICppExceptionSpecification exceptionSpecification);
    public virtual CppQualType GetResolvedTypeForEntity(ICppClassResolveEntity classEnt);
    public virtual CppQualType GetUnknownType(CppUnknownEntityInfo info);
    public virtual CppQualType GetTemplateParameterType(ICppTypeTemplateParameterOrPack templParameterEnt);
    public virtual CppQualType GetGenericParameterType(ICppGenericParameter genericParameterEnt);
    public virtual CppQualType GetDependentType(ICppDependentTypeResolveEntity depEnt);
    public virtual CppQualType GetResolvedAutoType(bool decltypeAuto, CppQualifiedName concept, ICppResolvedExpression constraint);
    public virtual CppQualType GetTyperefType(CppQualifiedName qualName, CppClassTag tag);
    public virtual CppQualType GetTypedefType(CppQualType innerType, ICppGroupedTypeDeclaratorResolveEntity decl);
    public virtual CppQualType GetInstantiatedTemplateAliasType(CppQualType innerType, CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity alias);
    public virtual CppQualType GetCEnumeratorType(CppQualType innerType, ICppClassResolveEntity decl);
    public virtual CppQualType GetNamedType(CppQualType innerType, CppQualifiedName name);
    public virtual CppQualType GetNameSuggestionType(CppQualType innerType, CppQualifiedName name);
    public virtual CppQualType GetScopeSuggestionType(CppQualType innerType, CppQualType scopeType);
    public virtual CppQualType GetNamedParameterType(ICppDecoratedFunctionParameter parameter, CppQualType innerType);
    public virtual CppQualType GetFunctionWithTrailingReturnType(CppQualType functionType);
    public virtual CppQualType GetDeducedClassTypePlaceholder(ICppDeducibleTypeTemplateResolveEntity classTemplate);
    public virtual CppQualType GetCachedType(ICppRawDeclaratorResolveEntity key);
    public virtual CppQualType GetCachedType(CppGroupedFunctionDeclaratorResolveEntity key);
    public virtual CppQualType TryGetCachedType(ICppRawDeclaratorResolveEntity key);
    public virtual ICppVerboseTypeVisitor`1<CppQualType> GetIdentityTypeVisitor();
    public virtual CppQualType GetTypeForClassSym(ICppClassSymbol sym);
    protected virtual CppQualType GetPointerTypeImpl(CppQualType t);
    protected virtual CppQualType GetCliHandleTypeImpl(CppQualType t);
    protected virtual CppQualType GetCliInteriorPointerTypeImpl(CppQualType t);
    protected virtual CppQualType GetCliPinPointerTypeImpl(CppQualType t);
    protected virtual CppQualType GetCliArrayTypeImpl(CppQualType t, ICppExpression rankExpr);
    protected virtual CppQualType GetReferenceTypeImpl(CppQualType t, ReferenceFlag isRval);
    protected virtual CppQualType GetFunctionTypeImpl(CppQualType returnType, CppQualType[] paramTypes, CppFunctionFlags flags, ICppExceptionSpecification exceptionSpecification);
    protected virtual CppQualType GetMemberPointerTypeImpl(CppQualType classType, CppQualType memberType);
    protected virtual CppQualType GetArrayTypeImpl(CppQualType t, ICppExpression sizeExpr);
    protected virtual CppQualType GetVectorTypeImpl(CppQualType elementType, ICppExpression size);
    protected virtual CppPackExpansionType GetPackExpansionTypeImpl(CppQualType t);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppVerboseTypeFactoryWithoutResolveCache : CppVerboseTypeFactoryBase {
    private CppLanguageDialect myDialect;
    public ICppRootFileResolveEntitiesCache ResolveCache { get; }
    public CppVerboseTypeFactoryWithoutResolveCache(CppLanguageDialect dialect);
    public virtual ICppRootFileResolveEntitiesCache get_ResolveCache();
    public virtual CppLanguageDialect GetDialect();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CppVoidType : CppType {
    public static CppVoidType INSTANCE;
    private static CppVoidType();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.CreateClassAndReplaceClassTypeVisitor : CppIdentityTypeVisitorWithResolvedOutput {
    private CppCreateClassAndReplaceClassTypeContext ctx;
    private CppType myRootType;
    public CreateClassAndReplaceClassTypeVisitor(CppCreateClassAndReplaceClassTypeContext& ctx);
    public CppQualType ApplyFirst(CppQualType type);
    public virtual CppQualType Visit(CppClassType e, Qualifiers quals);
    public virtual CppQualType Visit(CppEnumType e, Qualifiers quals);
    public virtual CppQualType Visit(CppDeclarationSpecifierType e, Qualifiers quals);
    public virtual CppQualType Visit(CppTypeReference e, Qualifiers quals);
    public virtual CppQualType Visit(CppElaboratedTypeReference e, Qualifiers quals);
    private void CreateFunctionParameter(CppParameterDeclaratorSymbol p, CppParameterListResolveEntity params);
    private CppQualType Visit(TFunction e, Qualifiers quals, CppParameterListResolveEntity params, Action`3<TFunction, CppParameterListResolveEntity, CreateClassAndReplaceClassTypeVisitor> paramCreator);
    public virtual CppQualType Visit(CppUnresolvedFunctionWithoutArgumentsType e, Qualifiers quals);
    public virtual CppQualType Visit(CppUnresolvedFunctionSingleArgumentType e, Qualifiers quals);
    public virtual CppQualType Visit(CppUnresolvedFunctionMultipleArgumentsType e, Qualifiers quals);
    public virtual CppQualType Visit(CppAutoType e, Qualifiers quals);
    protected virtual CppQualifiedName VisitAutoConceptName(CppQualifiedName name, Boolean& changed);
    public virtual CppQualType Visit(CppFunctionType e, Qualifiers quals);
    protected virtual ICppExpression VisitArraySize(ICppExpression arraySize, Boolean& changed);
    protected virtual ICppExpression VisitVectorSize(ICppExpression size, Boolean& changed);
    protected virtual ICppExpression VisitCliArrayRank(ICppExpression arrayRank, Boolean& changed);
    protected virtual ICppNoExceptSpecification VisitNoExceptSpecification(ICppNoExceptSpecification noexcept);
    public CreateClassAndReplaceClassTypeVisitor Init(ICppScopeResolveEntity lexicalParent, ICppScopeResolveEntity structuralParent, CppTemplateHeaders& templateHeaders, CppQualType declSpecQualType, CppTemplateParametersBase inventedTemplateParameters);
    public CreateClassAndReplaceClassTypeVisitor Init(ICppScopeResolveEntity lexicalParent, ICppScopeResolveEntity structuralParent, CppTemplateHeaders& templateHeaders, CppQualType declSpecQualType);
    public CreateClassAndReplaceClassTypeVisitor Init(ICppScopeResolveEntity lexicalParent, ICppScopeResolveEntity structuralParent, CppTemplateHeaders& templateHeaders);
    public CreateClassAndReplaceClassTypeVisitor Init(ICppScopeResolveEntity lexicalParent, CppTemplateHeaders& templateHeaders);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Types.CVQualifiers : Enum {
    public byte value__;
    public static CVQualifiers Empty;
    public static CVQualifiers Const;
    public static CVQualifiers Volatile;
    public static CVQualifiers CV;
}
public class JetBrains.ReSharper.Psi.Cpp.Types.EnumerateNestedClasses : object {
    public static void Enumerate(ICppSymbol sym, Action`1<ICppSymbol> output);
    public static void Enumerate(CppDeclarationSymbol decl, Action`1<ICppSymbol> output);
}
internal static class JetBrains.ReSharper.Psi.Cpp.Types.EnumerateNestedClassesImpl : object {
    private static void EnumerateNestedClasses(ICppTemplateArgument arg, Action`1<ICppSymbol> output);
    private static void EnumerateNestedClasses(ICppTemplateArgument[] args, Action`1<ICppSymbol> output);
    private static void EnumerateNestedClasses(CppQualifiedNamePart name, Action`1<ICppSymbol> output);
    private static void EnumerateNestedClasses(CppQualifiedName name, Action`1<ICppSymbol> output);
    private static void EnumerateNestedClasses(ICppTemplateParameterSymbol param, Action`1<ICppSymbol> output);
    private static void EnumerateNestedClasses(CppSymbolTemplateParameters plist, Action`1<ICppSymbol> output);
    private static void EnumerateNestedClassesFromParamList(ICppClassSymbol sym, Action`1<ICppSymbol> output);
    private static void EnumerateNestedClassesInitializers(CppDeclaratorInitializer init, Action`1<ICppSymbol> output);
    private static void EnumerateNestedClasses(CppQualType qualType, Action`1<ICppSymbol> output);
    public static void EnumerateNestedClassesFromType(CppQualType qualType, Action`1<ICppSymbol> output);
    public static void EnumerateNestedClassesFromSymbol(ICppSymbol sym, Action`1<ICppSymbol> output);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Types.FuncRefQualifier : Enum {
    public byte value__;
    public static FuncRefQualifier Empty;
    public static FuncRefQualifier Lval;
    public static FuncRefQualifier Rval;
    public static FuncRefQualifier ExplicitThis;
}
internal class JetBrains.ReSharper.Psi.Cpp.Types.HashCodeDistinguishingTemplateParamsVisitor : HashCodeVisitor {
    public static HashCodeDistinguishingTemplateParamsVisitor Instance;
    private static HashCodeDistinguishingTemplateParamsVisitor();
    public virtual int Visit(CppTemplateParameterType e, Qualifiers quals);
}
internal class JetBrains.ReSharper.Psi.Cpp.Types.HashCodeIgnoringFunctionReturnTypeVisitor : HashCodeVisitor {
    public static HashCodeIgnoringFunctionReturnTypeVisitor Instance;
    private static HashCodeIgnoringFunctionReturnTypeVisitor();
    public virtual int Visit(CppFunctionType e, Qualifiers quals);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.HashCodeVisitor : CppAbstractTypeVisitor`1<int> {
    public static HashCodeVisitor Instance;
    private static HashCodeVisitor();
    public virtual int VisitType(CppType t, Qualifiers q);
    public virtual int Visit(CppAutoType e, Qualifiers quals);
    public virtual int Visit(CppResolvedAutoType e, Qualifiers quals);
    public virtual int Visit(CppArrayType e, Qualifiers quals);
    public virtual int Visit(CppVectorType e, Qualifiers quals);
    public virtual int Visit(CppFunctionType e, Qualifiers quals);
    public int VisitUnresolvedFunctionType(CppUnresolvedFunctionType e, Qualifiers quals, int accumulator);
    public virtual int VisitUnresolvedFunctionType(CppUnresolvedFunctionType e, Qualifiers quals);
    public virtual int Visit(CppUnresolvedFunctionSingleArgumentType e, Qualifiers quals);
    public virtual int Visit(CppUnresolvedFunctionMultipleArgumentsType e, Qualifiers quals);
    public int Visit(CppParameterDeclaratorsData params);
    public virtual int Visit(CppReplacedFunctionType e, Qualifiers quals);
    public virtual int Visit(CppNumericType e, Qualifiers quals);
    public virtual int Visit(CppPointerType e, Qualifiers quals);
    public virtual int Visit(CppBuiltinTypeTraitType e, Qualifiers quals);
    public virtual int VisitReference(CppQualType inner, ReferenceFlag refFlag);
    public virtual int Visit(CppTemplateParameterType e, Qualifiers quals);
    public virtual int Visit(CppGenericParameterType e, Qualifiers quals);
    public virtual int Visit(CppPackExpansionType e, Qualifiers quals);
    public virtual int Visit(CppDependentType e, Qualifiers quals);
    public virtual int Visit(CppDependentInstantiatedTemplateAliasType e, Qualifiers quals);
    public virtual int Visit(CppClassType e, Qualifiers quals);
    public virtual int Visit(CppPendingClassType e, Qualifiers quals);
    public virtual int Visit(CppEnumType e, Qualifiers quals);
    public virtual int Visit(CppTypeReference e, Qualifiers quals);
    public virtual int Visit(CppElaboratedTypeReference e, Qualifiers quals);
    public virtual int Visit(CppVoidType e, Qualifiers quals);
    public virtual int Visit(CppResolvedClassType e, Qualifiers quals);
    public virtual int Visit(CppResolvedEnumType e, Qualifiers quals);
    public virtual int Visit(CppUnknownType e, Qualifiers quals);
    public virtual int Visit(CppNullptrType e, Qualifiers quals);
    public virtual int Visit(CppMemberPointerType t, Qualifiers quals);
    public virtual int Visit(CppDeclarationSpecifierType t, Qualifiers quals);
    public virtual int Visit(CppCliHandleType e, Qualifiers quals);
    public virtual int Visit(CppCliInteriorPointerType e, Qualifiers quals);
    public virtual int Visit(CppCliPinPointerType e, Qualifiers quals);
    public virtual int Visit(CppCliArrayType e, Qualifiers quals);
    public virtual int Visit(CppLinkageEntityType e, Qualifiers quals);
    public virtual int Visit(CppDependentLinkageEntityType e, Qualifiers quals);
    public virtual int Visit(CppLinkageTemplateParameterType e, Qualifiers quals);
    public virtual int Visit(CppLinkageArrayType e, Qualifiers quals);
    public virtual int Visit(CppLinkageVectorType e, Qualifiers quals);
    public virtual int Visit(CppLinkageCliArrayType e, Qualifiers quals);
    public virtual int Visit(HlslVectorType e, Qualifiers quals);
    public virtual int Visit(HlslMatrixType e, Qualifiers quals);
    public virtual int Visit(HlslSamplerType e, Qualifiers quals);
    public virtual int Visit(CppModuleEntityType t, Qualifiers quals);
    public virtual int Visit(CppTypedefModuleType t, Qualifiers quals);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.HashCodeWithEqualityComparerVisitor : HashCodeVisitor {
    private ICppEqualityComparer myEqualComparer;
    public HashCodeWithEqualityComparerVisitor(ICppEqualityComparer equalComparer);
    public virtual int Visit(CppTemplateParameterType e, Qualifiers quals);
    public virtual int Visit(CppGenericParameterType e, Qualifiers quals);
    public virtual int Visit(CppResolvedClassType e, Qualifiers quals);
    public virtual int Visit(CppResolvedEnumType e, Qualifiers quals);
    public virtual int Visit(CppDependentType e, Qualifiers quals);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.HlslMatrixType : CppType {
    [CompilerGeneratedAttribute]
private CppNumericTypeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <FirstDimensionSize>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <SecondDimensionSize>k__BackingField;
    public CppNumericTypeKind Kind { get; }
    public byte FirstDimensionSize { get; }
    public byte SecondDimensionSize { get; }
    public HlslMatrixType(CppNumericTypeKind kind, byte firstDimensionSize, byte secondDimensionSize);
    [CompilerGeneratedAttribute]
public CppNumericTypeKind get_Kind();
    [CompilerGeneratedAttribute]
public byte get_FirstDimensionSize();
    [CompilerGeneratedAttribute]
public byte get_SecondDimensionSize();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Cpp.Types.HlslPredefinedType : Enum {
    public int value__;
    public static HlslPredefinedType Half;
    public static HlslPredefinedType Float;
    public static HlslPredefinedType Double;
    public static HlslPredefinedType Int;
    public static HlslPredefinedType UInt;
    public static HlslPredefinedType Bool;
}
public class JetBrains.ReSharper.Psi.Cpp.Types.HlslPredefinedTypes : object {
    public static int VectorHalfStart;
    public static int VectorIntStart;
    public static int VectorUIntStart;
    public static int MatricesStart;
    public static int MatricesHalfStart;
    public static int MatricesIntStart;
    public static int MatricesUIntStart;
    private static CppQualType[] ourAllPredefinedTypes;
    internal static CppQualType[] AllPredefinedSamplers;
    public static CppQualType Float3 { get; }
    public static CppQualType Float4 { get; }
    public static CppQualType Sampler1D { get; }
    public static CppQualType Sampler2D { get; }
    public static CppQualType Sampler3D { get; }
    public static CppQualType SamplerCUBE { get; }
    public static CppQualType SamplerState { get; }
    public static CppQualType SamplerComparisonState { get; }
    private static HlslPredefinedTypes();
    public static CppQualType get_Float3();
    public static CppQualType get_Float4();
    public static CppQualType get_Sampler1D();
    public static CppQualType get_Sampler2D();
    public static CppQualType get_Sampler3D();
    public static CppQualType get_SamplerCUBE();
    public static CppQualType get_SamplerState();
    public static CppQualType get_SamplerComparisonState();
    public static CppQualType GetPredefinedVectorType(HlslPredefinedType type, byte size);
    public static CppQualType GetPredefinedMatrixType(HlslPredefinedType type, byte firstDimensionSize, byte secondDimensionSize);
    public static CppQualType[] GetAllPredefinedTypes();
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__AddVectors|9_0(CppNumericTypeKind kind, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__AddMatrices|9_1(CppNumericTypeKind kind, <>c__DisplayClass9_0& );
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Types.HlslPredefinedTypesUtil : object {
    [ExtensionAttribute]
public static HlslPredefinedType GetPredefinedTypeForNumKind(CppNumericTypeKind kind);
    public static CppQualType GetPredefinedVectorType(CppNumericTypeKind kind, byte size);
    public static CppQualType GetPredefinedMatrixType(CppNumericTypeKind kind, byte firstDimensionSize, byte secondDimensionSize);
    public static CppQualType GetPredefinedSamplerType(HlslSamplerKind kind);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Types.HlslQuals : Enum {
    public byte value__;
    public static HlslQuals NONE;
    public static HlslQuals QUAL_IN;
    public static HlslQuals QUAL_OUT;
    public static HlslQuals QUAL_CONST;
    public static HlslQuals QUAL_ROWMAJOR;
    public static HlslQuals QUAL_COLMAJOR;
    public static HlslQuals QUAL_INOUT;
}
public enum JetBrains.ReSharper.Psi.Cpp.Types.HlslSamplerKind : Enum {
    public byte value__;
    public static HlslSamplerKind sampler1D;
    public static HlslSamplerKind sampler2D;
    public static HlslSamplerKind sampler3D;
    public static HlslSamplerKind samplerCUBE;
    public static HlslSamplerKind SamplerState;
    public static HlslSamplerKind SamplerComparisonState;
}
public class JetBrains.ReSharper.Psi.Cpp.Types.HlslSamplerType : CppType {
    [CompilerGeneratedAttribute]
private HlslSamplerKind <Kind>k__BackingField;
    public HlslSamplerKind Kind { get; }
    public HlslSamplerType(HlslSamplerKind kind);
    [CompilerGeneratedAttribute]
public HlslSamplerKind get_Kind();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public string GetSamplerKindName();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Types.HlslVectorType : CppType {
    [CompilerGeneratedAttribute]
private CppNumericTypeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Size>k__BackingField;
    public CppNumericTypeKind Kind { get; }
    public byte Size { get; }
    public HlslVectorType(CppNumericTypeKind kind, byte size);
    [CompilerGeneratedAttribute]
public CppNumericTypeKind get_Kind();
    [CompilerGeneratedAttribute]
public byte get_Size();
    public virtual Result Accept(ICppTypeVisitor`1<Result> visitor, Qualifiers quals);
    public virtual bool EqualsType(Qualifiers lhsQuals, InputQualifiers lhsInputQuals, CppQualType rhs, ICppEqualityComparer engine);
    public virtual void UpdateLazyMergingInfo(ICppLazyMergingDataConsumer c);
    public virtual string ToString();
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppAutoType {
    public CppQualifiedName ConceptName { get; }
    public abstract virtual CppQualifiedName get_ConceptName();
    public abstract virtual bool IsDecltypeAuto();
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppBasicDeclarationSpecifierTypeBuilder {
    public abstract virtual CppQualType ComposeResultType();
    public abstract virtual void LearnTokenType(TokenNodeType tt);
    public abstract virtual void LearnDecltypeAuto();
    public abstract virtual void LearnBuiltinTypeTraitType(CppQualType argument, CppBuiltinTypeTraitKind kind);
    public abstract virtual void LearnConceptName(CppQualifiedName name, bool decltypeAuto);
    public abstract virtual void LearnQualifiedName(CppQualifiedName name);
    public abstract virtual void LearnElaboratedReference(CppQualifiedName name, CppClassTag tag);
    public abstract virtual void LearnMatrixSpecifier(HlslMatrixSpecifierBuilder& matrixSpecifierBuilder);
    public abstract virtual void LearnHlslBufferComponentType(CppQualType componentType);
    public abstract virtual void LearnClassTag();
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppBasicTypeBuilder {
    public abstract virtual CppQualType ComposeResultType();
    public abstract virtual void LearnBaseType(CppQualType type);
    public abstract virtual void LearnTokenType(TokenNodeType tt);
    public abstract virtual void LearnTokenType(TokenNodeType tt, ITokenNode location);
    public abstract virtual void LearnPtr(TokenNodeType ptr, CVQualifiers quals);
    public abstract virtual void LearnNameQualifierPtrName(CppQualifiedName name, CVQualifiers quals);
    public abstract virtual bool InnerTypeIsEmpty();
    public abstract virtual void LearnArraySize(ICppExpression expr);
    public abstract virtual void LearnUnknownArraySize();
    public abstract virtual void LearnFunctionParameters(CppSmallArray`1<CppParameterDeclaratorSymbol> syms, CppEllipsisKind ellipsisKind, CVQualifiers cvquals, FuncRefQualifier refQual, CppQualType trailingReturnType, CppRestrictionSpecifiers restrictionSpecifiers, ICppExceptionSpecification exceptionSpecification);
    public abstract virtual void LearnReplacedFunction(CppParameterListResolveEntity resolveEntity, CppEllipsisKind ellipsisKind, CVQualifiers cvquals, FuncRefQualifier refQual, CppQualType trailingReturnType, CppRestrictionSpecifiers restrictionSpecifiers, ICppExceptionSpecification exceptionSpecification);
    public abstract virtual void LearnCallingConvention(CppCallingConvention cc);
    public abstract virtual void LearnCallingConvention(ICppCallingConventionBuilder ccBuilder);
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppBinaryTypingErrorConsumer {
    public abstract virtual void CheckFirstOperandContextuallyConvertibleToBool(CppTypeAndCategory tc);
    public abstract virtual void CheckSecondOperandContextuallyConvertibleToBool(CppTypeAndCategory tc);
    public abstract virtual void CheckDerivedClassForDotMul(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT, CppQualType lhsClassT, CppQualType rhsClassT);
    public abstract virtual void CheckArgumentIsNullPointerConstant(bool checkLeftArgument);
    public abstract virtual void CheckAssignable(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public abstract virtual void LearnCompoundAssignmentError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT, CppOperatorKind op);
    public abstract virtual void LearnRemOrBitOpError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT, CppOperatorKind op);
    public abstract virtual void LearnMulOrDivOpError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT, CppOperatorKind op);
    public abstract virtual void LearnPlusPointerError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public abstract virtual void LearnMinusPointerError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public abstract virtual void LearnOtherInvalidBinaryArgumentsError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public abstract virtual void LearnRelationalOpError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT, CppOperatorKind op);
    public abstract virtual void LearnDotMulOpError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public abstract virtual void LearnDerefMulOpError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public abstract virtual void CheckForPointerAndQualificationConversions(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public abstract virtual void CheckComparableCliHandles(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
    public abstract virtual void LearnUsualArithmeticConversionsError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppClassLayoutBuilder {
    public abstract virtual void OnEntry(Entry entry, Layout layout);
    public abstract virtual void OnPadding();
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppDecoratedFunctionParameter {
    [CanBeNullAttribute]
public string Name { get; }
    [CanBeNullAttribute]
public ICppExpression Initializer { get; }
    public bool ShouldBeResolved { get; }
    public bool IsParameterPack { get; }
    public abstract virtual string get_Name();
    public abstract virtual ICppExpression get_Initializer();
    public abstract virtual bool get_ShouldBeResolved();
    public abstract virtual bool get_IsParameterPack();
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppExceptionSpecification {
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppLayoutBuilder {
    public bool WasInterrupted { get; }
    [CanBeNullAttribute]
public abstract virtual ICppClassLayoutBuilder BeginClass();
    [CanBeNullAttribute]
public abstract virtual ICppUnionLayoutBuilder BeginUnion();
    public abstract virtual bool get_WasInterrupted();
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppNoExceptSpecification {
    public abstract virtual bool HasArgument();
    [CanBeNullAttribute]
public abstract virtual ICppExpression GetArgument();
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppResolveCache {
    public abstract virtual CppQualType GetCachedType(ICppRawDeclaratorResolveEntity key);
    public abstract virtual CppQualType GetCachedType(CppGroupedFunctionDeclaratorResolveEntity key);
    public abstract virtual CppQualType TryGetCachedType(ICppRawDeclaratorResolveEntity key);
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppResolvedDeclarationSpecifierTypeBuilder {
    public abstract virtual void LearnResolvedClassType(ICppClassResolveEntity ent);
    public abstract virtual void LearnResolvedType(CppQualType resolvedType);
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppResolvedTypeBuilder {
    public abstract virtual ICppResolvedTypeBuilder CreateResolvedTypeBuilderForPartInParens();
    public abstract virtual void LearnTypePartInParens(ICppResolvedTypeBuilder builder);
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppResolvedTypeFactory {
    public bool IgnoresScopeSuggestions { get; }
    public bool IgnoresNameSuggestions { get; }
    public ICppRootFileResolveEntitiesCache ResolveCache { get; }
    public abstract virtual bool get_IgnoresScopeSuggestions();
    public abstract virtual bool get_IgnoresNameSuggestions();
    public abstract virtual ICppRootFileResolveEntitiesCache get_ResolveCache();
    public abstract virtual CppLanguageDialect GetDialect();
    public abstract virtual CppQualType GetReplacedFunctionType(CppQualType returnType, CppParameterListResolveEntity resolveEntity, CppFunctionFlags flags, CppQualType trailingReturnType, ICppExceptionSpecification exceptionSpecification);
    public abstract virtual CppQualType GetResolvedTypeForEntity(ICppClassResolveEntity classEnt);
    public abstract virtual CppQualType GetTemplateParameterType(ICppTypeTemplateParameterOrPack templParameterEnt);
    public abstract virtual CppQualType GetGenericParameterType(ICppGenericParameter templParameterEnt);
    public abstract virtual CppQualType GetResolvedAutoType(bool decltypeAuto, CppQualifiedName concept, ICppResolvedExpression constraint);
    public abstract virtual CppQualType GetDependentType(ICppDependentTypeResolveEntity depEnt);
    public abstract virtual CppQualType GetTypedefType(CppQualType innerType, ICppGroupedTypeDeclaratorResolveEntity decl);
    public abstract virtual CppQualType GetInstantiatedTemplateAliasType(CppQualType innerType, CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity ent);
    public abstract virtual CppQualType GetCEnumeratorType(CppQualType innerType, ICppClassResolveEntity enumDecl);
    public abstract virtual CppQualType GetNamedType(CppQualType innerType, CppQualifiedName name);
    public abstract virtual CppQualType GetNameSuggestionType(CppQualType innerType, CppQualifiedName name);
    public abstract virtual CppQualType GetScopeSuggestionType(CppQualType innerType, CppQualType scopeType);
    public abstract virtual CppQualType GetFunctionWithTrailingReturnType(CppQualType functionType);
    public abstract virtual CppQualType GetDeducedClassTypePlaceholder(ICppDeducibleTypeTemplateResolveEntity ent);
    public abstract virtual ICppVerboseTypeVisitor`1<CppQualType> GetIdentityTypeVisitor();
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppSubscriptErrorConsumer {
    public abstract virtual void LearnSubscriptError(CppTypeAndCategory lhsT, CppTypeAndCategory rhsT);
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppSymbolTypeFactory {
    public abstract virtual CppQualType GetTypeForClassSym(ICppClassSymbol sym);
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppTypeFactory {
    public abstract virtual CppQualType GetPointerType(CppQualType t);
    public abstract virtual CppQualType GetReferenceType(CppQualType t, ReferenceFlag isRval);
    public abstract virtual CppQualType GetArrayType(CppQualType t, ICppExpression sizeExpr);
    public abstract virtual CppQualType GetVectorType(CppQualType t, ICppExpression sizeExpr);
    public abstract virtual CppQualType GetFunctionType(CppQualType returnType, CppQualType[] paramTypes, CppFunctionFlags flags, ICppExceptionSpecification exceptionSpecification);
    public abstract virtual CppQualType GetDerefFunctionType(CppQualType returnType, CppQualType[] paramTypes, CppFunctionFlags flags, ICppExceptionSpecification exceptionSpecification);
    public abstract virtual CppQualType GetTyperefType(CppQualifiedName qualName, CppClassTag tag);
    public abstract virtual CppQualType GetMemberPointerType(CppQualType classType, CppQualType memberType);
    public abstract virtual CppQualType GetNamedParameterType(ICppDecoratedFunctionParameter parameter, CppQualType innerType);
    public abstract virtual CppQualType GetUnknownType(CppUnknownEntityInfo info);
    public abstract virtual CppPackExpansionType GetPackExpansionType(CppQualType t);
    public abstract virtual CppQualType GetAutoType(bool decltypeAuto, CppQualifiedName concept);
    public abstract virtual CppQualType GetCliHandleType(CppQualType t);
    public abstract virtual CppQualType GetCliInteriorPointerType(CppQualType t);
    public abstract virtual CppQualType GetCliPinPointerType(CppQualType t);
    public abstract virtual CppQualType GetCliArrayType(CppQualType t, ICppExpression rankExpr);
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppTypeVisitor`1 {
    public abstract virtual Result Visit(CppDecoratedType t, Qualifiers q);
    public abstract virtual Result Visit(CppUnknownType t, Qualifiers q);
    public abstract virtual Result Visit(CppUnresolvedFunctionWithoutArgumentsType t, Qualifiers q);
    public abstract virtual Result Visit(CppUnresolvedFunctionSingleArgumentType t, Qualifiers q);
    public abstract virtual Result Visit(CppUnresolvedFunctionMultipleArgumentsType t, Qualifiers q);
    public abstract virtual Result Visit(CppReplacedFunctionType t, Qualifiers q);
    public abstract virtual Result Visit(CppFunctionType t, Qualifiers q);
    public abstract virtual Result Visit(CppAutoType t, Qualifiers q);
    public abstract virtual Result Visit(CppResolvedAutoType t, Qualifiers q);
    public abstract virtual Result Visit(CppClassType t, Qualifiers q);
    public abstract virtual Result Visit(CppResolvedClassType t, Qualifiers q);
    public abstract virtual Result Visit(CppPendingClassType t, Qualifiers q);
    public abstract virtual Result Visit(CppEnumType t, Qualifiers q);
    public abstract virtual Result Visit(CppResolvedEnumType t, Qualifiers q);
    public abstract virtual Result Visit(CppTypeReference t, Qualifiers q);
    public abstract virtual Result Visit(CppElaboratedTypeReference t, Qualifiers q);
    public abstract virtual Result Visit(CppPointerType t, Qualifiers q);
    public abstract virtual Result Visit(CppMemberPointerType t, Qualifiers q);
    public abstract virtual Result Visit(CppVoidType t, Qualifiers q);
    public abstract virtual Result Visit(CppNullptrType t, Qualifiers q);
    public abstract virtual Result Visit(CppDeclarationSpecifierType t, Qualifiers q);
    public abstract virtual Result Visit(CppPackExpansionType t, Qualifiers q);
    public abstract virtual Result Visit(CppNumericType t, Qualifiers q);
    public abstract virtual Result Visit(CppArrayType t, Qualifiers q);
    public abstract virtual Result Visit(CppVectorType t, Qualifiers q);
    public abstract virtual Result Visit(CppTemplateParameterType t, Qualifiers q);
    public abstract virtual Result Visit(CppGenericParameterType t, Qualifiers q);
    public abstract virtual Result Visit(CppDependentType t, Qualifiers q);
    public abstract virtual Result Visit(CppDependentInstantiatedTemplateAliasType t, Qualifiers q);
    public abstract virtual Result Visit(CppDeducedClassTypePlaceholder t, Qualifiers q);
    public abstract virtual Result Visit(CppBuiltinTypeTraitType t, Qualifiers q);
    public abstract virtual Result Visit(CppCliArrayType t, Qualifiers q);
    public abstract virtual Result Visit(CppLinkageArrayType t, Qualifiers q);
    public abstract virtual Result Visit(CppLinkageVectorType t, Qualifiers q);
    public abstract virtual Result Visit(CppLinkageCliArrayType t, Qualifiers q);
    public abstract virtual Result Visit(CppLinkageEntityType t, Qualifiers q);
    public abstract virtual Result Visit(CppDependentLinkageEntityType t, Qualifiers q);
    public abstract virtual Result Visit(CppLinkageTemplateParameterType t, Qualifiers q);
    public abstract virtual Result Visit(CppCliHandleType t, Qualifiers q);
    public abstract virtual Result Visit(CppCliInteriorPointerType t, Qualifiers q);
    public abstract virtual Result Visit(CppCliPinPointerType t, Qualifiers q);
    public abstract virtual Result Visit(CppModuleEntityType t, Qualifiers q);
    public abstract virtual Result Visit(CppTypedefModuleType t, Qualifiers q);
    public abstract virtual Result Visit(CppInstantiatedTemplateAliasModuleType t, Qualifiers q);
    public abstract virtual Result Visit(CppDependentInstantiatedTemplateAliasModuleType t, Qualifiers q);
    public abstract virtual Result Visit(CppDeducedClassTypePlaceholderModuleType t, Qualifiers q);
    public abstract virtual Result Visit(HlslVectorType t, Qualifiers q);
    public abstract virtual Result Visit(HlslSamplerType t, Qualifiers q);
    public abstract virtual Result Visit(HlslMatrixType t, Qualifiers q);
    public abstract virtual Result VisitReference(CppQualType innerType, ReferenceFlag flag);
    public abstract virtual Result VisitTypeWithDeclSpecPlacement(CppQualType innerType, CppDeclSpecPlacement placement);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Types.ICppTypeVisitorUtil : object {
    [ExtensionAttribute]
public static Result ForwardVisitToInnerType(ICppTypeVisitor`1<Result> visitor, CppDecoratedType t, Qualifiers quals);
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppUnaryTypingErrorConsumer {
    public abstract virtual void CheckOperandContextuallyConvertibleToBool(CppTypeAndCategory tc);
    public abstract virtual void LearnIndirectionError(CppTypeAndCategory lhsT);
    public abstract virtual void LearnUnaryPlusError(CppTypeAndCategory lhsT);
    public abstract virtual void LearnPrefixIncrementError(CppTypeAndCategory lhsT);
    public abstract virtual void LearnPrefixDecrementError(CppTypeAndCategory lhsT);
    public abstract virtual void LearnPrefixDecrementIsBoolError();
    public abstract virtual void LearnUnaryMinusError(CppTypeAndCategory lhsT);
    public abstract virtual void LearnBitComplementError(CppTypeAndCategory lhsT);
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppUnionLayoutBuilder {
    public abstract virtual void OnEntry(Entry entry, Layout layout);
    public abstract virtual void OnPadding();
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppUnresolvedDeclarationSpecifierTypeBuilder {
    public abstract virtual void LearnClassType(ICppClassSymbol sym);
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppUnresolvedTypeBuilder {
    public abstract virtual ICppUnresolvedTypeBuilder CreateUnresolvedTypeBuilderForPartInParens();
    public abstract virtual void LearnTypePartInParens(ICppUnresolvedTypeBuilder builder);
    public abstract virtual void LearnDeclarationSpecifierType();
    public abstract virtual bool IsFunction();
}
public interface JetBrains.ReSharper.Psi.Cpp.Types.ICppVerboseTypeVisitor`1 {
    public abstract virtual Result Visit(CppNamedParameterType t, Qualifiers q);
    public abstract virtual Result Visit(CppNamedType t, Qualifiers q);
    public abstract virtual Result Visit(CppNameSuggestionType t, Qualifiers q);
    public abstract virtual Result Visit(CppScopeSuggestionType t, Qualifiers q);
    public abstract virtual Result Visit(CppCEnumeratorType t, Qualifiers q);
    public abstract virtual Result Visit(CppTypedefType t, Qualifiers q);
    public abstract virtual Result Visit(CppFunctionWithTrailingReturnType t, Qualifiers q);
    public abstract virtual Result Visit(CppInstantiatedTemplateAliasType t, Qualifiers q);
    public abstract virtual Result Visit(CppDecoratedBuiltinTypeTraitType t, Qualifiers q);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Types.InputQualifiers : Enum {
    public byte value__;
    public static InputQualifiers Empty;
    public static InputQualifiers In;
    public static InputQualifiers Out;
    public static InputQualifiers InOut;
}
internal class JetBrains.ReSharper.Psi.Cpp.Types.IsDependentAndNotCurrentInstantiationVisitor : IsDependentVisitor {
    private CppViewPos myViewPos;
    public IsDependentAndNotCurrentInstantiationVisitor(CppViewPos& vp);
    public virtual CppDependentInfo Visit(CppResolvedClassType e, Qualifiers quals);
}
internal class JetBrains.ReSharper.Psi.Cpp.Types.IsDependentVisitor : CppAbstractTypeVisitor`1<CppDependentInfo> {
    public static IsDependentVisitor INSTANCE;
    private static IsDependentVisitor();
    public CppDependentInfo ReApply(CppQualType qt);
    public virtual CppDependentInfo VisitType(CppType t, Qualifiers q);
    public virtual CppDependentInfo Visit(CppAutoType e, Qualifiers q);
    public virtual CppDependentInfo Visit(CppResolvedAutoType e, Qualifiers q);
    public virtual CppDependentInfo Visit(CppDeducedClassTypePlaceholder placeholder, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppArrayType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppVectorType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppCliArrayType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppFunctionType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppNumericType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppPointerType e, Qualifiers quals);
    public virtual CppDependentInfo VisitReference(CppQualType inner, ReferenceFlag refFlag);
    public virtual CppDependentInfo Visit(CppTemplateParameterType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppGenericParameterType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppPackExpansionType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppDependentType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppBuiltinTypeTraitType e, Qualifiers _);
    public virtual CppDependentInfo Visit(CppClassType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppEnumType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppTypeReference e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppElaboratedTypeReference e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppVoidType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppResolvedClassType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppResolvedEnumType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppUnknownType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppNullptrType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppMemberPointerType t, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppCliHandleType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppCliInteriorPointerType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppCliPinPointerType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(CppDependentInstantiatedTemplateAliasType e, Qualifiers quals);
    public virtual CppDependentInfo Visit(HlslVectorType t, Qualifiers q);
    public virtual CppDependentInfo Visit(HlslMatrixType t, Qualifiers q);
    public virtual CppDependentInfo Visit(HlslSamplerType t, Qualifiers q);
}
internal class JetBrains.ReSharper.Psi.Cpp.Types.PickResolveScopeVisitor : CppAbstractTypeVisitor`1<ICppScopeLikeResolveEntity> {
    private ICppResolveEntity myGlobalNamespaceHint;
    public PickResolveScopeVisitor(ICppResolveEntity globalNamespaceHint);
    public virtual ICppScopeLikeResolveEntity VisitType(CppType e, Qualifiers quals);
    public virtual ICppScopeLikeResolveEntity VisitReference(CppQualType inner, ReferenceFlag refFlag);
    public virtual ICppScopeLikeResolveEntity Visit(CppTemplateParameterType e, Qualifiers quals);
    public virtual ICppScopeLikeResolveEntity Visit(CppDependentType e, Qualifiers quals);
    public virtual ICppScopeLikeResolveEntity Visit(CppClassType e, Qualifiers quals);
    public virtual ICppScopeLikeResolveEntity Visit(CppEnumType e, Qualifiers quals);
    public virtual ICppScopeLikeResolveEntity Visit(CppTypeReference e, Qualifiers quals);
    public virtual ICppScopeLikeResolveEntity Visit(CppElaboratedTypeReference e, Qualifiers quals);
    public virtual ICppScopeLikeResolveEntity Visit(CppResolvedClassType e, Qualifiers quals);
    public virtual ICppScopeLikeResolveEntity Visit(CppResolvedEnumType e, Qualifiers quals);
    public virtual ICppScopeLikeResolveEntity Visit(CppGenericParameterType p, Qualifiers quals);
    public virtual ICppScopeLikeResolveEntity Visit(CppNumericType e, Qualifiers quals);
    public virtual ICppScopeLikeResolveEntity Visit(CppCliArrayType e, Qualifiers quals);
    public virtual ICppScopeLikeResolveEntity Visit(CppDependentInstantiatedTemplateAliasType e, Qualifiers quals);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Types.Qualifiers : Enum {
    public int value__;
    public static Qualifiers None;
    public static Qualifiers Const;
    public static Qualifiers Volatile;
    public static Qualifiers CV;
    public static Qualifiers CVClearMask;
    public static Qualifiers LvalueRef;
    public static Qualifiers RvalueRef;
    public static Qualifiers CliTrackingRef;
    public static Qualifiers RefClearMask;
    public static Qualifiers FuncLvalueRef;
    public static Qualifiers FuncRvalueRef;
    public static Qualifiers FuncRefClearMask;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Types.QualifiersUtil : object {
    public static int QualifiersBitsCount;
    public static int InputQualifiersBitsCount;
    public static int REF_OFFSET;
    private static int FUNC_REF_OFFSET;
    [ExtensionAttribute]
public static Qualifiers ClearCVQuals(Qualifiers quals);
    [ExtensionAttribute]
public static Qualifiers ClearConst(Qualifiers quals);
    [ExtensionAttribute]
public static Qualifiers ClearFuncRefFlag(Qualifiers quals);
    [ExtensionAttribute]
public static Qualifiers ClearRefFlag(Qualifiers quals);
    [ExtensionAttribute]
public static CVQualifiers GetCVQuals(Qualifiers quals);
    [ExtensionAttribute]
public static Qualifiers ToQuals(CVQualifiers quals);
    [ExtensionAttribute]
public static FuncRefQualifier GetFuncRefQual(Qualifiers quals);
    [ExtensionAttribute]
public static Qualifiers ToQuals(FuncRefQualifier quals);
    [ExtensionAttribute]
public static ReferenceFlag GetRefFlag(Qualifiers quals);
    [ExtensionAttribute]
public static Qualifiers ToQuals(ReferenceFlag quals);
    public static ReferenceFlag CollapseReferences(ReferenceFlag a, ReferenceFlag b);
    [ExtensionAttribute]
public static InputQualifiers ToInputQualifiers(HlslQuals quals);
    [ExtensionAttribute]
public static bool IsConst(CVQualifiers cvQuals);
    [ExtensionAttribute]
public static bool IsVolatile(CVQualifiers cvQuals);
}
internal class JetBrains.ReSharper.Psi.Cpp.Types.QualTypeToValueKindVisitor`1 : CppAbstractTypeVisitor`1<TResult> {
    private ICppQualTypeValueKindVisitor`1<TResult> myVisitor;
    private CppViewPos myViewPos;
    [DebuggerStepThroughAttribute]
public QualTypeToValueKindVisitor`1(ICppQualTypeValueKindVisitor`1<TResult> visitor, CppViewPos& viewPos);
    public virtual TResult VisitType(CppType t, Qualifiers q);
    public virtual TResult Visit(CppArrayType e, Qualifiers quals);
    public virtual TResult Visit(CppVectorType e, Qualifiers quals);
    public virtual TResult Visit(CppFunctionType e, Qualifiers quals);
    public virtual TResult Visit(CppAutoType e, Qualifiers quals);
    public virtual TResult Visit(CppResolvedAutoType e, Qualifiers quals);
    public virtual TResult Visit(CppNumericType e, Qualifiers quals);
    public virtual TResult Visit(CppPointerType e, Qualifiers quals);
    public virtual TResult VisitReference(CppQualType inner, ReferenceFlag refFlag);
    public virtual TResult Visit(CppTemplateParameterType e, Qualifiers quals);
    public virtual TResult Visit(CppGenericParameterType e, Qualifiers quals);
    public virtual TResult Visit(CppDependentType e, Qualifiers quals);
    public virtual TResult Visit(CppDependentInstantiatedTemplateAliasType e, Qualifiers quals);
    public virtual TResult Visit(CppClassType e, Qualifiers quals);
    public virtual TResult Visit(CppEnumType e, Qualifiers quals);
    public virtual TResult Visit(CppTypeReference e, Qualifiers quals);
    public virtual TResult Visit(CppElaboratedTypeReference e, Qualifiers quals);
    public virtual TResult Visit(CppVoidType e, Qualifiers quals);
    public virtual TResult Visit(CppResolvedClassType e, Qualifiers quals);
    public virtual TResult Visit(CppResolvedEnumType e, Qualifiers quals);
    public virtual TResult Visit(CppUnknownType e, Qualifiers quals);
    public virtual TResult Visit(CppNullptrType e, Qualifiers quals);
    public virtual TResult Visit(CppMemberPointerType t, Qualifiers quals);
    public virtual TResult Visit(CppCliHandleType e, Qualifiers quals);
    public virtual TResult Visit(CppCliInteriorPointerType e, Qualifiers quals);
    public virtual TResult Visit(CppCliPinPointerType e, Qualifiers quals);
    public virtual TResult Visit(HlslVectorType e, Qualifiers quals);
    public virtual TResult Visit(HlslMatrixType e, Qualifiers quals);
    public virtual TResult Visit(HlslSamplerType e, Qualifiers quals);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Types.ReferenceFlag : Enum {
    public byte value__;
    public static ReferenceFlag Empty;
    public static ReferenceFlag Lval;
    public static ReferenceFlag Rval;
    public static ReferenceFlag CliTracking;
}
public class JetBrains.ReSharper.Psi.Cpp.Types.ResolveDeclaratorTypeVisitor : ResolvingTypeVisitor {
    private CppViewPos myDeclaratorViewPos;
    public ResolveDeclaratorTypeVisitor(CppViewPos& specifiersViewPos, CppViewPos& declaratorViewPos, ICppResolvedTypeFactory typeFactory, bool returnDeducedClassTypePlaceholder);
    protected virtual CppQualType[] VisitFunctionParams(CppQualType[] types, Boolean& changed);
    protected virtual ICppExpression VisitArraySize(ICppExpression sizeExpr, Boolean& changed);
    protected virtual ICppExceptionSpecification VisitExceptionSpecification(ICppExceptionSpecification exceptionSpecification, Boolean& changed);
}
public class JetBrains.ReSharper.Psi.Cpp.Types.ResolvingTypeVisitor : CppIdentityTypeVisitorWithResolvedOutput {
    protected CppViewPos myScope;
    protected CallingConventionSelection myCcsel;
    protected bool myReturnDeducedClassTypePlaceholder;
    protected CppTypePlaceholders myVisitedPlaceholders;
    public ResolvingTypeVisitor(CppTypeContext& tc, bool returnDeducedClassTypePlaceholder, CallingConventionSelection ccsel);
    public CppTypePlaceholders GetVisitedPlaceholders();
    public virtual CppQualType Visit(CppPendingClassType e, Qualifiers quals);
    public virtual CppQualType Visit(CppUnresolvedFunctionWithoutArgumentsType e, Qualifiers quals);
    public virtual CppQualType Visit(CppUnresolvedFunctionSingleArgumentType e, Qualifiers quals);
    public virtual CppQualType Visit(CppUnresolvedFunctionMultipleArgumentsType e, Qualifiers quals);
    private CppQualType GetReplacedType(CppParameterDeclaratorData parameterData, bool isParameterPack);
    private CppQualType VisitUnresolvedFunctionType(CppUnresolvedFunctionType e, CppQualType[] paramTypes, Qualifiers quals);
    private CppQualType CreateResultForFunctionType(ICppResolvedTypeFactory tf, bool hasTrailingReturnType, Qualifiers quals, CppQualType returnType, CppQualType[] paramTypes, CppFunctionFlags flags, ICppExceptionSpecification exceptionSpecification);
    public virtual CppQualType Visit(CppReplacedFunctionType e, Qualifiers quals);
    public virtual CppQualType Visit(CppTypeReference e, Qualifiers quals);
    public virtual CppQualType Visit(CppElaboratedTypeReference e, Qualifiers quals);
    public virtual CppQualType Visit(CppMemberPointerType e, Qualifiers quals);
    public virtual CppQualType Visit(CppNamedParameterType e, Qualifiers quals);
    public virtual CppQualType Visit(CppAutoType e, Qualifiers quals);
    public virtual CppQualType Visit(CppBuiltinTypeTraitType t, Qualifiers quals);
    public virtual CppQualType VisitTypeWithDeclSpecPlacement(CppQualType innerType, CppDeclSpecPlacement placement);
    protected virtual ICppNoExceptSpecification VisitNoExceptSpecification(ICppNoExceptSpecification noexcept);
    protected virtual CppQualType ReApply(CppQualType t, Boolean& changed);
    protected CppQualType ReApply(CppQualType t, Boolean& changed, CallingConventionSelection ccsel);
    protected virtual CppUnknownEntityInfo ReApply(CppUnknownEntityInfo info, Boolean& changed);
    protected virtual CppQualType[] VisitFunctionParams(CppQualType[] types, Boolean& changed);
    protected virtual ICppExpression VisitArraySize(ICppExpression sizeExpr, Boolean& changed);
    protected virtual ICppExpression VisitVectorSize(ICppExpression sizeExpr, Boolean& changed);
    protected virtual ICppExpression VisitCliArrayRank(ICppExpression sizeExpr, Boolean& changed);
    private CppQualType HandleReference(CppQualifiedName name, CppClassTag tag, Qualifiers quals);
    private ICppDecoratedFunctionParameter ResolveParameter(ICppDecoratedFunctionParameter parameter);
    private CppCallingConvention SelectCallingConvention(CppCallingConvention cc);
    private CppRestrictionSpecifiers SelectRestrictionSpecifiers(CppRestrictionSpecifiers restrictionSpecifiers);
}
public class JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Attribute : CppAttribute {
    public static CppAttributeName RSCppUClassName;
    public static CppAttributeName RSCppUInterfaceName;
    public static CppAttributeName RSCppUStructName;
    public static CppAttributeName RSCppUEnumName;
    public static CppAttributeName RSCppUFunctionName;
    public static CppAttributeName RSCppUPropertyName;
    public static CppAttributeName RSCppGeneratedBodyName;
    public static CppAttributeName RSCppGeneratedBodyLegacyName;
    public static CppAttributeName RSCppRigVMMethodName;
    public static CppAttribute GeneratedBodyAttribute;
    public static CppAttribute GeneratedBodyLegacyAttribute;
    public KnownMetaSpecifiers MetaSpecifiers;
    private SortedList`2<string, FrugalLocalHashSet`1<string>> mySpecifiers;
    public CppUE4Attribute(CppAttributeName name, SortedList`2<string, FrugalLocalHashSet`1<string>> specifiers, KnownMetaSpecifiers metaSpecifiers);
    private static CppUE4Attribute();
    public virtual string ToString();
    public virtual bool Equals(ICppAttribute obj, CppEqualityComparer comparer);
    private static void AppendComma(StringBuilder builder, Boolean& isFirstItemInSequence);
    public SortedList`2<string, FrugalLocalHashSet`1<string>> GetSpecifiers();
    public bool ContainsSpecifier(string spec);
    public FrugalLocalHashSet`1<string> GetSpecifierValues(string spec);
}
public class JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4AttributeBuilder : object {
    private CppAttributeName myName;
    private SortedList`2<string, FrugalLocalHashSet`1<string>> mySpecifiers;
    private KnownMetaSpecifiers myMetaSpecifiers;
    public CppUE4AttributeBuilder(CppAttributeName name);
    public void LearnUE4SpecifierArg(string specifier);
    public void LearnUE4SpecifierValueArg(string specifier, string value);
    public void LearnUE4MetaArg(string tag, string value);
    public ICppAttribute GetUnresolvedAttribute();
    public ICppAttribute GetReplacedAttribute();
}
[CppPolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4AttributeMarshaller : CppPolymorphicMarshaller`1<CppUE4Attribute> {
    public virtual void Marshal(CppMarshallingContext context, CppUE4Attribute value);
    public virtual CppUE4Attribute Unmarshal(CppUnmarshallingContext context);
}
[CppCompilationPropertiesProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4CompilationPropertiesProvider : object {
    [CompilerGeneratedAttribute]
private ICppUE4SolutionDetector <solutionDetector>P;
    [CompilerGeneratedAttribute]
private ICppUE4ProjectModelStatistics <projectModelStatistics>P;
    [CompilerGeneratedAttribute]
private ICppUE4ProjectPropertiesProvider <projectPropertiesProvider>P;
    [CompilerGeneratedAttribute]
private ICppUE4ModuleNamesProvider <moduleNamesProvider>P;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IUnrealCompilationPropertiesProvider> <unrealCompilationPropertiesProviders>P;
    public CppUE4CompilationPropertiesProvider(ICppUE4SolutionDetector solutionDetector, ICppUE4ProjectModelStatistics projectModelStatistics, ICppUE4ProjectPropertiesProvider projectPropertiesProvider, ICppUE4ModuleNamesProvider moduleNamesProvider, IReadOnlyList`1<IUnrealCompilationPropertiesProvider> unrealCompilationPropertiesProviders);
    public sealed virtual CppCompilationProperties GetCompilationProperties(IProject project, IProjectFile projectFile, CppFileLocation rootFile, CppGlobalSymbolCache globalCache, CppIntelliSenseInfo intelliSenseInfo);
    private static CppCompilationProperties CreateDefaultUE4CompilationProperties(ICppUE4ModuleProperties ue4ModuleProperties, IProject project, CppFileLocation rootFile, CppGlobalSymbolCache globalCache);
}
public class JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4DeclaratorResolveEntityPack : CppDeclaratorResolveEntityPack {
    private CppUE4DeclaratorResolveEntityPack myPrototypePack;
    private CppUE4ImplicitlyGeneratedMemberType myGenerationType;
    private bool myIsGenerated;
    public CppUE4DeclaratorResolveEntityPack(ICppResolveEntity parent, CppQualifiedNamePart name, CppLocationAnchor anchor);
    private CppUE4Attribute GetAttribute(CppAttributeName name);
    public static bool IsRigVMMethod(ICppResolveEntity entity, CppUE4DeclaratorResolveEntityPack& pack, String& name);
    public CppUE4Attribute GetUFunctionAttribute();
    public CppUE4Attribute GetUPropertyAttribute();
    public void EnableGeneration(CppUE4ImplicitlyGeneratedMemberType generationType, CppUE4DeclaratorResolveEntityPack prototypePack);
    protected virtual void DoMergeDeclaratorsUpTo(CppLocationAnchor anchor, bool withImplicits);
    private ICppAttribute GetFirstAttributeWithName(CppAttributeName attributeName);
    public CppGroupedFunctionDeclaratorResolveEntity GetFunctionPrototype();
    private CppGroupedVariableDeclaratorResolveEntity GetPropertyPrototype();
    private void GenerateRpcWrapper(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf, RpcWrapperType wrapperType);
    private void GenerateGetLifetimeReplicatedProps(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf);
    private void GenerateEventExecutorWrapper(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf);
    private void GenerateRigVmStaticMethod(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf);
    private void GenerateSparseDataGetter(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf);
    private void GenerateAutoGetter(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf);
    private void GenerateAutoSetter(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf);
    public static CppQualType ProcessRigVmUPropertyType(CppQualType baseType, CppGroupedVariableDeclaratorResolveEntity uproperty);
    [CompilerGeneratedAttribute]
internal static CppQualType <GenerateGetLifetimeReplicatedProps>g__ConstructArrayOfFLifetimeProperties|14_0(ICppResolvedTypeFactory tf, CppLocationAnchor anchorPosForLookupOfGlobalEntities, CppViewPos& viewPos);
}
public enum JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4ImplicitlyGeneratedMemberType : Enum {
    public byte value__;
    public static CppUE4ImplicitlyGeneratedMemberType None;
    public static CppUE4ImplicitlyGeneratedMemberType RpcImplementation;
    public static CppUE4ImplicitlyGeneratedMemberType RpcValidation;
    public static CppUE4ImplicitlyGeneratedMemberType GetLifetimeReplicatedProps;
    public static CppUE4ImplicitlyGeneratedMemberType EventExecutor;
    public static CppUE4ImplicitlyGeneratedMemberType RigVmStaticMethod;
    public static CppUE4ImplicitlyGeneratedMemberType SparseDataGetter;
    public static CppUE4ImplicitlyGeneratedMemberType AutoGetter;
    public static CppUE4ImplicitlyGeneratedMemberType AutoSetter;
}
public static class JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Names : object {
    public static CppQualifiedId Super;
    public static CppQualifiedId ThisClass;
    public static CppQualifiedId UClassType;
    public static CppQualifiedId WithinClass;
    public static CppQualifiedId StaticStruct;
    public static CppQualifiedId StaticClass;
    public static CppQualifiedId FObjectInitializer;
    public static CppQualifiedId TArray;
    public static CppQualifiedId FLifetimeProperty;
    public static CppQualifiedId FRigVMExecuteContext;
    public static CppQualifiedId UScriptStruct;
    public static CppQualifiedId UClass;
    public static CppQualifiedId GetLifetimeReplicatedProps;
    public static CppQualifiedId UObject;
    public static CppQualifiedId FArchive;
    public static CppQualifiedId FStructuredArchive;
    public static CppQualifiedId FSlot;
    public static CppQualifiedId FVTableHelper;
    public static CppQualifiedId UInterface;
    public static CppQualifiedId AActor;
    public static CppQualifiedId ACharacter;
    public static CppQualifiedId UActorComponent;
    public static CppQualifiedId UWorld;
    public static CppQualifiedId GetUObject;
    public static CppQualifiedId ENetFieldsPrivate;
    public static CppQualifiedId NetFieldRepStart;
    public static CppQualifiedId NetFieldRepEnd;
    public static CppQualifiedId GetNetPushId;
    public static CppQualifiedId SetNetPushIdDynamic;
    public static CppQualifiedId GetNetPushIdDynamic;
    public static CppQualifiedId FFieldNotificationClassDescriptor;
    public static CppQualifiedId SuperDescriptor;
    public static CppQualifiedId allFields;
    public static CppQualifiedId TUniquePtr;
    public static CppQualifiedId TSharedPtr;
    public static CppQualifiedId TPair;
    public static CppQualifiedId GetWorld;
    public static CppQualifiedId UM;
    public static CppQualifiedId UMWidget;
    public static CppQualifiedId GetBeautifiedTestName;
    public static CppQualifiedId GetTestFlags;
    public static string FLLTAdaptedTestPrefix;
    public static CppQualifiedName FFieldId;
    public static string WithinSpecifier;
    public static string ConfigSpecifier;
    public static string SparseClassDataTypesSpecifier;
    public static string MetaSpecifier;
    public static string ClientSpecifier;
    public static string ServerSpecifier;
    public static string BlueprintNativeEventSpecifier;
    public static string NetMulticastSpecifier;
    public static string WithValidationSpecifier;
    public static string BlueprintImplementableEventSpecifier;
    public static string BlueprintCallableSpecifier;
    public static string Reliable;
    public static string Unreliable;
    public static string ReplicatedSpecifier;
    public static string ReplicatedUsingSpecifier;
    public static string BlueprintGetterSpecifier;
    public static string BlueprintReadWriteSpecifier;
    public static string BlueprintAssignableSpecifier;
    public static string EditAnywhereSpecifier;
    public static string EditDefaultsOnlySpecifier;
    public static string EditInlineSpecifier;
    public static string EditInstanceOnly;
    public static string FieldNotify;
    public static string Getter;
    public static string Setter;
    public static string CrossServerSpecifier;
    public static String[] AllSpecifiers;
    public static HashSet`1<string> AllSpecifiersSet;
    public static string RpcImplementationPostfix;
    public static string RpcValidationPostfix;
    public static string EventExecutorPrefix;
    public static string ObjectWithinSpecifierValue;
    public static string GetterSetterAutoValue;
    public static string RigVmStaticMethodPrefix;
    public static Dictionary`2<string, UE4ReflectionMacroType> MacroSubstitutionsToMacroType;
    public static string UObjectClassName;
    public static string UObjectBaseClassName;
    public static string AActorClassName;
    public static string SWidgetClassName;
    public static string HHitProxyClassName;
    public static string IInterfaceClassName;
    public static string FThreadSafeBoolClassName;
    public static string TOptionalClassName;
    public static string TAttributeClassName;
    public static string TAtomicClassName;
    public static string TGuardValueClassName;
    public static string FAutoConsoleVariableRefName;
    public static string FAutoConsoleVariableName;
    public static string TAutoConsoleVariableName;
    public static string FAutoConsoleVariableSinkName;
    public static string FLogCategoryName;
    public static string FindComponentByClass;
    public static string CreateDefaultSubobject;
    public static string GetDefaultObject;
    public static string Cast;
    public static string CastChecked;
    public static string TSubclassOf;
    public static string TObjectPtr;
    public static string TWeakObjectPtr;
    public static string TMulticastDelegate;
    public static string TBaseMulticastDelegate;
    public static string TBaseDynamicDelegate;
    public static string TBaseDynamicMulticastDelegate;
    public static string BindDynamic;
    public static string AddDynamic;
    public static string AddUniqueDynamic;
    public static string UCLASS;
    public static string UENUM;
    public static string USTRUCT;
    public static string UINTERFACE;
    public static string UPROPERTY;
    public static string UFUNCTION;
    public static string UE_LOG;
    public static string SNEW;
    public static string SASSIGNNEW;
    public static string BEGIN_SLATE_ARGS;
    public static string END_SLATE_ARGS;
    public static string SLATE_ARGUMENT;
    public static string SLATE_STYLE_ARGUMENT;
    public static string SLATE_EVENT;
    public static string SLATE_ATTRIBUTE;
    public static string SLATE_DEFAULT_SLOT;
    public static string SLATE_NAMED_SLOT;
    public static string FArguments;
    public static string SlateChildSlot;
    private static CppUE4Names();
    public static bool IsLexerAtUE4UMacro(ILexer lexer, bool checkOnlyTypeMacros);
    public static bool IsUMacro(string macroName, bool checkOnlyTypeMacros);
    public static bool IsHeaderToolGeneratedFileInclude(CppIncludeDirectiveContent directiveContent, CppInclusionContext inclusionContext, String& generatedFileName);
    public static bool IsHeaderToolGeneratedFileInclude(CppPPIncludeSymbol symbol, CppInclusionContext inclusionContext);
    public static bool IncludesGeneratedFile(CppFile file);
    public static bool IsCoreMinimalFileInclude(CppPPIncludeSymbol symbol, CppFileSymbolsCache symbolsCache);
    public static CppQualifiedId GetRigVMMethodName(string prototypeName);
    public static bool IsUnrealEngineTestName(CppQualifiedNamePart name);
    public static bool IsUnrealEngineCategoryName(CppQualifiedNamePart name);
    public static bool IsUnrealEngineTestCase(CppQualifiedNamePart name);
    public static bool IsUEInlineGeneratedCppInclude(ImportDirective directive);
    public static bool IsSlateMacroName(string macroName);
    public static bool IsSlateWidgetName(string name);
    public static bool IsSlateArgumentMacro(string macroName);
    private static bool IsHeaderToolGeneratedFileIncludeImpl(string includedFileName, CppInclusionContext inclusionContext, String& generatedFileName);
}
public enum JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4ProjectModelSupportMode : Enum {
    public byte value__;
    public static CppUE4ProjectModelSupportMode NotSupported;
    public static CppUE4ProjectModelSupportMode CanBeSimulated;
    public static CppUE4ProjectModelSupportMode UprojectOpened;
}
public static class JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Tokens : object {
    public static NodeTypeSet IsUE4ClassAttributeToken;
    public static NodeTypeSet IsUE4AttributeToken;
    public static NodeTypeDictionary`1<CppAttributeName> TokenToAttributeName;
    private static CppUE4Tokens();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util : object {
    public static CppDefineKey UnrealMacro;
    private static int DefaultNetFieldRepEndValue;
    private static CppUE4Util();
    public static bool IsReflectionMacro(CppPPDefineSymbol define);
    public static bool IsUE4RedefinedByReSharperMacro(ICppPPSymbol sym);
    public static bool IsUClass(ICppClassSymbol sym);
    public static bool IsUStruct(ICppClassSymbol sym);
    public static bool IsUEnum(ICppClassSymbol sym);
    public static bool IsUEType(ICppClassSymbol sym);
    public static bool IsUEType(ICppClassResolveEntity re);
    public static bool IsLooksLikeUClass(ICppClassResolveEntity re);
    public static bool IsUClass(ICppClassResolveEntity cent);
    public static string GetConfigName(ICppClassSymbol cent);
    public static string GetConfigName(ICppClassResolveEntity cent);
    public static bool IsUStruct(ICppClassResolveEntity cent);
    public static bool IsUEnum(ICppClassResolveEntity cent);
    public static bool IsUInterface(ICppClassResolveEntity cent);
    public static bool IsUInterface(CppClassLinkageEntity cent, CppLinkageEntityCache linkageCache);
    public static bool IsUInterface(ICppClassSymbol sym);
    public static bool IsIInterface(ICppClassResolveEntity cent);
    public static bool IsUFunction(ICppDeclaratorResolveEntity dent);
    public static bool IsUFunction(ICppFunctionDeclaratorResolveEntity fent);
    public static bool IsUFunction(ICppDeclaratorSymbol sym);
    public static bool IsUProperty(ICppDeclaratorResolveEntity dent);
    public static bool IsUProperty(ICppDeclaratorSymbol sym);
    public static bool IsUClassMember(ICppDeclaratorResolveEntity fent);
    public static bool IsActor(ICppClassResolveEntity cent, CppViewPos& viewPos);
    public static bool IsComponent(ICppClassResolveEntity cent, CppViewPos& viewPos);
    public static bool IsRpcFunction(ICppFunctionDeclaratorResolveEntity fent);
    public static bool IsRpcFunction(CppDeclaratorLinkageEntity fent, CppGlobalSymbolCache cache);
    public static bool IsRpcFunction(ICollection`1<ICppParserSymbol> symbols);
    public static bool IsRpcFunctionWithValidation(ICppFunctionDeclaratorResolveEntity fent);
    public static bool IsRpcFunctionWithValidation(CppDeclaratorLinkageEntity fent, CppGlobalSymbolCache cache);
    public static bool IsRpcFunctionWithValidation(ICollection`1<ICppParserSymbol> symbols);
    public static bool LooksLikeGeneratedRpcFunction(ICppFunctionDeclaratorResolveEntity fent);
    public static bool IsBlueprintImplementableEventFunction(ICppFunctionDeclaratorResolveEntity fent);
    public static bool IsBlueprintCallableFunction(ICppFunctionDeclaratorResolveEntity fent);
    public static bool IsDelegateClassMember(ICppDeclaratorResolveEntity ent, CppViewPos& vp);
    public static bool HasGeneratedBody(ICppClassSymbol sym);
    public static bool CanContainUEMembers(ICppClassResolveEntity cent);
    public static bool CanBeFinal(ICppClassResolveEntity cent);
    public static CppAccessibility GetAccessibilityOfGeneratedMember(CppGeneratedFunctionDeclaratorResolveEntity fent);
    public static ICppFunctionDeclaratorResolveEntity FindPrototypeOfRpcCandidate(ICppFunctionDeclaratorResolveEntity rpcCandidate, RpcWrapperType& outCandidateType);
    public static CppGroupedFunctionDeclaratorResolveEntity FindGeneratedRpcFunction(CppGroupedFunctionDeclaratorResolveEntity prototype, RpcWrapperType targetType);
    public static CppDeclaratorLinkageEntity FindGeneratedRpcFunction(CppDeclaratorLinkageEntity prototype, CppGlobalSymbolCache cache, RpcWrapperType targetType);
    public static string GetGeneratedRpcFunctionName(ICppFunctionDeclaratorResolveEntity prototype, RpcWrapperType targetType);
    public static string GetGeneratedRpcFunctionName(string name, RpcWrapperType targetType);
    public static ICppClassResolveEntity GetRelatedUInterface(ICppClassResolveEntity cent, ICppResolvedTypeFactory tf);
    [CanBeNullAttribute]
public static ICppClassResolveEntity GetUObject(CppViewPos& viewPos);
    [CanBeNullAttribute]
public static ICppClassResolveEntity GetUInterface(CppViewPos& viewPos);
    [CanBeNullAttribute]
public static ICppClassResolveEntity GetAActor(CppViewPos& viewPos);
    [CanBeNullAttribute]
public static ICppClassResolveEntity GetUActorComponent(CppViewPos& viewPos);
    [CanBeNullAttribute]
public static ICppClassResolveEntity GetUWorld(CppViewPos& viewPos);
    public static CppList`1<ICppSymbol> GetProbableIInterfaceByUInterface(CppGlobalSymbolCache globalCache, string name);
    public static CppQualType FindResolvedOrGetUnknownType(ICppResolvedTypeFactory tf, CppQualifiedId nameOfType, CppViewPos& viewPos);
    public static CppQualType FindResolvedOrGetUnknownType(ICppResolvedTypeFactory tf, CppQualifiedId nameOfOuterType, CppQualifiedId nameOfInnerType, CppViewPos& viewPos);
    public static ICppClassResolveEntity FindObjectResolvedEntityByUnprefixedName(ICppResolvedTypeFactory tf, string unprefixedNameOfType, CppLocationAnchor anchor);
    public static ICppClassResolveEntity FindStructResolvedEntityByUnprefixedName(ICppResolvedTypeFactory tf, string unprefixedNameOfType, CppLocationAnchor anchor);
    public static CppDeclaratorLinkageEntity TransformLinkageEntity(CppDeclaratorLinkageEntity source, ICppFunctionDeclaratorResolveEntity prototype, RpcWrapperType from, RpcWrapperType to, ICppResolvedTypeFactory tf);
    public static List`1<CppGroupedVariableDeclaratorResolveEntity> EnumerateAllUProperties(ICppClassResolveEntity cent);
    public static bool IsUEInclusionContextWithoutPredefinedMacros(ICppUE4SolutionDetector ueDetector, CppInclusionContext context);
    public static bool IsUEContext(ICppUE4SolutionDetector ueDetector, CppGlobalNamespaceResolveEntity globalNamespace, CppLocationAnchor anchor);
    [ExtensionAttribute]
public static bool IsValidTargetForUMacro(ICppResolveEntity ent);
    public static bool IsValidTargetForUMacro(ICppLinkageEntity ent);
    public static bool IsValidTargetForUMacro(ICppClassSymbol sym);
    private static string PresentUE4FunctionName(CppQualifiedNamePart functionName);
    private static string PresentRpcImplementationName(string prototypeName);
    private static string PresentRpcValidationName(string prototypeName);
    private static string PresentRpcImplementationName(CppQualifiedId prototype);
    private static string PresentRpcValidationName(CppQualifiedId prototype);
    private static string GetUnprefixedStructName(CppQualifiedNamePart name);
    private static CppQualifiedId GetRpcImplementationName(CppQualifiedId prototypeName);
    private static CppQualifiedId GetRpcValidationName(CppQualifiedId prototypeName);
    private static CppQualifiedId GetEventExecutorName(CppQualifiedId prototype);
    private static CppQualifiedId GetGetterName(CppQualifiedId prototypeName);
    private static CppQualifiedId GetSetterName(CppQualifiedId prototypeName);
    private static CppQualifiedId GetPrototypeName(CppQualifiedNamePart generatedName, RpcWrapperType generatedType);
    private static RpcWrapperType GetRpcCandidateType(CppQualifiedNamePart candidateName);
    private static CppEnumeratorResolveEntity GenerateEnumValue(CppEnumResolveEntity enumEntity, CppEnumWithBaseSymbol enumSymbol, CppQualifiedId name, ushort value, CppLocationAnchor anchor, CppEnumeratorResolveEntity previous);
    private static int GetNetFieldRepEndValue(ICppClassResolveEntity cent);
    private static void GenerateENetFieldsPrivate(ICppMutableClassResolveEntity cent, CppList`1<CppUE4DeclaratorResolveEntityPack> replicatedProperties, Boolean& hasReplicatedBases);
    private static void GeneratePushModelFunctions(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf);
    private static CppUE4DeclaratorResolveEntityPack FindOrCreateDeclaratorGroup(ICppMutableClassResolveEntity cent, CppQualifiedId name);
    private static void GenerateUClassMembersBasedOnUMacros(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf);
    private static bool IsWithPushModel(ICppResolvedTypeFactory tf);
    private static void GenerateRigVmMethods(ICppMutableClassResolveEntity cent);
    private static void GenerateIInterfaceMembersBasedOnUMacros(ICppMutableClassResolveEntity cent);
    private static void GenerateSparseDataGetter(ICppMutableClassResolveEntity cent, ICppClassResolveEntity sparseDataClass, ICppResolvedTypeFactory tf);
    private static void GenerateSparseDataGetters(ICppMutableClassResolveEntity cent, ICppClassResolveEntity sparseDataClass);
    private static void GenerateSparseData(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf);
    private static void GenerateAutoGetterSetter(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf);
    private static void GenerateUClassTypeTypedef(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf, CppLocationAnchor anchor);
    private static void GenerateThisClassTypedef(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf, CppLocationAnchor anchor);
    private static void GenerateSuperTypedef(ICppMutableClassResolveEntity cent, CppLocationAnchor anchor);
    private static void GenerateWithinTypedef(ICppMutableClassResolveEntity cent, CppQualType withinType, CppLocationAnchor anchor);
    private static void GenerateGetOuterWithinClass(ICppMutableClassResolveEntity cent, ICppClassResolveEntity withinClass, CppQualType withinType, ICppResolvedTypeFactory tf, CppLocationAnchor anchor);
    private static void GenerateStaticClass(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf, CppLocationAnchor anchor);
    private static void GenerateStaticStruct(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf, CppLocationAnchor anchor);
    private static void GenerateOldSerializer(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf, CppLocationAnchor anchor);
    private static void GenerateNewSerializer(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf, CppLocationAnchor anchor);
    private static void GenerateGetUObject(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf, CppLocationAnchor anchor);
    private static void GenerateDeclareWithin(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf);
    private static void GenerateDeclareSerializer(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf);
    private static void GenerateDeclareClass(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf, MembersGenerationPoint point);
    private static void GenerateInclass(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf, MembersGenerationPoint point);
    private static void GenerateDestructor(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf, CppLocationAnchor anchor);
    private static void GenerateInclassIInterface(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf, MembersGenerationPoint point);
    private static void GenerateConstructors(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf);
    private static void GenerateUE4ClassBody(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf, MembersGenerationPoint point);
    private static void GenerateUE4StructBody(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf, MembersGenerationPoint point);
    private static void GenerateUE4IInterfaceBody(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf, MembersGenerationPoint point);
    private static void GenerateFieldNotificationClassDescriptor(ICppMutableClassResolveEntity cent, ICppResolvedTypeFactory tf);
    private static CppQualType FindBaseFFieldNotificationClassDescriptor(ICppMutableClassResolveEntity cent, CppViewPos viewPos);
    private static void GenerateFieldNotificationClassDescriptor(ICppMutableClassResolveEntity cent, CppList`1<CppQualifiedNamePart> fields, ICppResolvedTypeFactory tf);
    private static ICppClassResolveEntity GetClassByName(CppViewPos& viewPos, CppQualifiedId name);
    private static bool HasAttributeWithName(CppAttributeList list, CppAttributeName name);
    private static bool HasUClassAttribute(CppAttributeList list);
    private static string GetConfigNameFromAttributeList(CppAttributeList list);
    private static bool HasUStructAttribute(CppAttributeList list);
    private static bool HasUEnumAttribute(CppAttributeList list);
    private static bool HasUPropertyAttribute(CppAttributeList list);
    public static bool HasUFunctionAttribute(CppAttributeList list);
    private static bool IsDerivedFrom(ICppClassResolveEntity derived, ICppClassResolveEntity from, CppViewPos& viewPos);
    private static void CollectAllUPropertiesFromCurrentToBase(ICppClassResolveEntity cent, List`1<CppGroupedVariableDeclaratorResolveEntity> accumulator, HashSet`1<ICppClassResolveEntity> visited);
    public static void GenerateUE4ImplicitlyGeneratedMembers(ICppMutableClassResolveEntity cent, MembersGenerationPoint point);
    public static CppClassLinkageEntity TryGetRelatedUInterface(CppClassLinkageEntity cent, CppGlobalSymbolCache globalCache);
    public static CppClassLinkageEntity TryGetRelatedIInterface(CppClassLinkageEntity cent, CppGlobalSymbolCache globalCache);
    [ExtensionAttribute]
public static bool IsGeneratedByUHT(ICppResolveEntity entity);
    public static bool IsGeneratedByUHT(CppAttributeList attributes);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Version : ValueType {
    [CompilerGeneratedAttribute]
private int <Major>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Minor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Patch>k__BackingField;
    public int Major { get; }
    public int Minor { get; }
    public int Patch { get; }
    public CppUE4Version(int major, int minor, int patch);
    [CompilerGeneratedAttribute]
public int get_Major();
    [CompilerGeneratedAttribute]
public int get_Minor();
    [CompilerGeneratedAttribute]
public int get_Patch();
    public bool IsValid();
    public bool IsUE4();
    public bool IsUE5();
    public static bool op_Equality(CppUE4Version left, CppUE4Version right);
    public static bool op_Inequality(CppUE4Version left, CppUE4Version right);
    public static bool op_LessThan(CppUE4Version left, CppUE4Version right);
    public static bool op_LessThanOrEqual(CppUE4Version left, CppUE4Version right);
    public static bool op_GreaterThan(CppUE4Version left, CppUE4Version right);
    public static bool op_GreaterThanOrEqual(CppUE4Version left, CppUE4Version right);
    public sealed virtual int CompareTo(CppUE4Version other);
    public sealed virtual bool Equals(CppUE4Version other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Cpp.UE4.CppUseModuleLikeForcedIncludes : Enum {
    public int value__;
    [DisplayAttribute]
public static CppUseModuleLikeForcedIncludes Never;
    [DisplayAttribute]
public static CppUseModuleLikeForcedIncludes DuringIndexing;
    [DisplayAttribute]
public static CppUseModuleLikeForcedIncludes Always;
}
public interface JetBrains.ReSharper.Psi.Cpp.UE4.ICppUE4SolutionDetector {
    public IProperty`1<bool> IsUnrealSolution { get; }
    public IProperty`1<UnrealEngineContext> UnrealContext { get; }
    public CppUE4ProjectModelSupportMode SupportRiderProjectModel { get; }
    public CppUseModuleLikeForcedIncludes UseModuleLikeForcedIncludes { get; }
    public abstract virtual IProperty`1<bool> get_IsUnrealSolution();
    public abstract virtual IProperty`1<UnrealEngineContext> get_UnrealContext();
    public abstract virtual CppUE4ProjectModelSupportMode get_SupportRiderProjectModel();
    public abstract virtual CppUseModuleLikeForcedIncludes get_UseModuleLikeForcedIncludes();
    public abstract virtual bool IsEngineProgramProject(IProject project);
    [ObsoleteAttribute("Works only when opening .sln")]
public abstract virtual bool IsUE4EngineProject(IProject project);
    [ObsoleteAttribute("Works only when opening .sln")]
public abstract virtual IProject GetUE4EngineProject();
    public abstract virtual bool IsUE4ProjectWithUnrealMacro(IProject project);
    public abstract virtual VirtualFileSystemPath GetUProjectPath();
}
public interface JetBrains.ReSharper.Psi.Cpp.UE4.IUnrealCompilationPropertiesProvider {
    [CanBeNullAttribute]
public abstract virtual CppCompilationProperties GetUnrealCompilationProperties(CppCompilationProperties defaultProps, ICppUE4ModuleProperties moduleProperties);
}
public enum JetBrains.ReSharper.Psi.Cpp.UE4.RpcWrapperType : Enum {
    public int value__;
    public static RpcWrapperType Implementation;
    public static RpcWrapperType Validation;
    public static RpcWrapperType Prototype;
    public static RpcWrapperType None;
}
public enum JetBrains.ReSharper.Psi.Cpp.UE4.UE4ReflectionMacroType : Enum {
    public int value__;
    public static UE4ReflectionMacroType None;
    public static UE4ReflectionMacroType Class;
    public static UE4ReflectionMacroType Function;
    public static UE4ReflectionMacroType Property;
    public static UE4ReflectionMacroType Struct;
    public static UE4ReflectionMacroType Enum;
    public static UE4ReflectionMacroType Interface;
    public static UE4ReflectionMacroType GeneratedBody;
    public static UE4ReflectionMacroType GeneratedBodyLegacy;
    public static UE4ReflectionMacroType RigVMMethod;
}
internal class JetBrains.ReSharper.Psi.Cpp.UE4.UnknownUE4Type : object {
    public static CppQualType Instance;
    private static UnknownUE4Type();
}
public class JetBrains.ReSharper.Psi.Cpp.UE4.UnrealEngineContext : object {
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <UnrealEngineSourcePath>k__BackingField;
    [CompilerGeneratedAttribute]
private CppUE4Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBuiltFromSource>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSpatialOS>k__BackingField;
    public VirtualFileSystemPath UnrealEngineSourcePath { get; public set; }
    public VirtualFileSystemPath UnrealEngineRoot { get; }
    public CppUE4Version Version { get; public set; }
    public bool IsBuiltFromSource { get; public set; }
    public bool IsSpatialOS { get; public set; }
    public IUnrealCacheSerializer`1<UnrealEngineContext> Serializer { get; }
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_UnrealEngineSourcePath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UnrealEngineSourcePath(VirtualFileSystemPath value);
    public VirtualFileSystemPath get_UnrealEngineRoot();
    [CompilerGeneratedAttribute]
public CppUE4Version get_Version();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Version(CppUE4Version value);
    [CompilerGeneratedAttribute]
public bool get_IsBuiltFromSource();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsBuiltFromSource(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSpatialOS();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsSpatialOS(bool value);
    public sealed virtual IUnrealCacheSerializer`1<UnrealEngineContext> get_Serializer();
    private bool Equals(UnrealEngineContext other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(UnrealEngineContext left, UnrealEngineContext right);
    public static bool op_Inequality(UnrealEngineContext left, UnrealEngineContext right);
}
public class JetBrains.ReSharper.Psi.Cpp.UE4.UnrealEngineContextSerializer : object {
    [CompilerGeneratedAttribute]
private static UnrealEngineContextSerializer <Instance>k__BackingField;
    public static UnrealEngineContextSerializer Instance { get; }
    private static UnrealEngineContextSerializer();
    [CompilerGeneratedAttribute]
public static UnrealEngineContextSerializer get_Instance();
    public sealed virtual UnrealEngineContext Load(BinaryReader reader);
    public sealed virtual void Save(UnrealEngineContext obj, BinaryWriter writer);
}
public class JetBrains.ReSharper.Psi.Cpp.UE4.UnrealPrefixes : object {
    private static String[] ourClassPrefixes;
    private static String[] ourPrefixesForCoreRedirects;
    private static String[] ourPrefixesForUht;
    private static UnrealPrefixes();
    [CanBeNullAttribute]
public static string StripUnrealPrefix(string className);
    [NotNullAttribute]
public static string GetPrefixIfAny(string className);
    [NotNullAttribute]
public static String[] GetClassPrefixes();
    [NotNullAttribute]
public static String[] GetPrefixesForUht();
    [NotNullAttribute]
public static string GetEntityNameForCoreRedirects(string possiblyPrefixedClassName);
    private static bool IsPrefixed(string className, String[] prefixes);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Cpp.Util.BitVector : ValueType {
    private static int SIZE_OF_INT;
    private Int32[] myData;
    public bool Item { get; public set; }
    public BitVector(int size);
    [PureAttribute]
public BitVector Copy();
    public Sliced Slice(int startIndex, int endIndex);
    public Sliced Slice(IndexRange indexRange);
    [PureAttribute]
public bool IsEmpty();
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public void AssertSameSize(BitVector other);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public void AssertIsValidBit(int index);
    public void And(BitVector other);
    public void Or(BitVector other);
    public void Xor(BitVector other);
    public void Except(BitVector other);
    public bool IsEqualTo(BitVector other);
    public bool GetBit(int index);
    public void SetBit(int index, bool value);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    private static int GetActualSize(int sizeInBits);
    private static void TranslateStartIndex(int index, Int32& arrayIndex, Int32& bitIndex);
    private static void TranslateEndIndex(int index, Int32& arrayIndex, Int32& bitIndex);
    private static int GetStartMask(int bitIndex);
    private static int GetEndMask(int bitIndex);
    private static int GetArrayIndexByBitIndex(int bitIndex);
    private static int GetMaskByBitIndex(int bitIndex);
    private static bool GetBit(Int32[] data, int index);
    private static void SetBit(Int32[] data, int index, bool value);
}
public static class JetBrains.ReSharper.Psi.Cpp.Util.CastTo`1 : object {
    public static T From(S s);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppAggregateParenInitInfo : CppUnknownEntityInfo {
    public static CppAggregateParenInitInfo Instance;
    private static CppAggregateParenInitInfo();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppAnchorIndexedValue`1 : ValueType {
    private BinarySearchList`2<CppLocationAnchor, T> myValues;
    public T Get(CppLocationAnchor anchor);
    public void Add(CppLocationAnchor anchor, T value);
    public void RemoveLast();
    public bool IsEmpty();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Util.CppAnchorRange`1 : ValueType {
    public TAnchor Start;
    public TAnchor End;
    public CppAnchorRange`1(TAnchor start, TAnchor end);
    public bool Contains(TAnchor anchor);
    public bool ContainsRange(CppAnchorRange`1<TAnchor> range);
    public bool IntersectsWith(CppAnchorRange`1<TAnchor> range);
    public bool IsEmpty();
    public sealed virtual bool Equals(CppAnchorRange`1<TAnchor> other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppAutoTypeConstraintFailure : CppUnknownEntityInfo {
    [CompilerGeneratedAttribute]
private ICppExpression <Constraint>k__BackingField;
    public ICppExpression Constraint { get; }
    public CppAutoTypeConstraintFailure(ICppExpression constraint);
    [CompilerGeneratedAttribute]
public ICppExpression get_Constraint();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppAutoTypeDeductionFailure : CppUnknownEntityInfo {
    [CompilerGeneratedAttribute]
private CppQualType <PatternType>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppExpression <Initializer>k__BackingField;
    public CppQualType PatternType { get; }
    [CanBeNullAttribute]
public ICppExpression Initializer { get; }
    public CppAutoTypeDeductionFailure(CppQualType autoType, ICppExpression initializer);
    [CompilerGeneratedAttribute]
public CppQualType get_PatternType();
    [CompilerGeneratedAttribute]
public ICppExpression get_Initializer();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppBufferUtil : object {
    public static int IndexOf(IBuffer buffer, string pattern, int start, int count);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppCachedReference`1 : ValueType {
    private static object NULL;
    private static object NON_INITIALIZED;
    private object myReference;
    public CppCachedReference`1(T reference);
    private static CppCachedReference`1();
    public void Clear();
    public bool Empty();
    [PublicAPIAttribute]
[CanBeNullAttribute]
public T GetOrInit(Func`1<T> evaluateFunc, Boolean& wasSet);
    [PublicAPIAttribute]
[CanBeNullAttribute]
public T GetOrInit(TArg1 arg1, Func`2<TArg1, T> evaluateFunc, Boolean& wasSet);
    [PublicAPIAttribute]
[CanBeNullAttribute]
public T GetOrInit(TArg1 arg1, TArg2 arg2, Func`3<TArg1, TArg2, T> evaluateFunc, Boolean& wasSet);
    [PublicAPIAttribute]
[CanBeNullAttribute]
public T GetOrInit(TArg1 arg1, TArg2 arg2, TArg3 arg3, Func`4<TArg1, TArg2, TArg3, T> evaluateFunc, Boolean& wasSet);
    [PublicAPIAttribute]
[CanBeNullAttribute]
public T GetOrInit(Func`1<T> evaluateFunc);
    [PublicAPIAttribute]
[CanBeNullAttribute]
public T GetOrInit(TArg1 arg1, Func`2<TArg1, T> evaluateFunc);
    [PublicAPIAttribute]
[CanBeNullAttribute]
public T GetOrInit(TArg1 arg1, TArg2 arg2, Func`3<TArg1, TArg2, T> evaluateFunc);
    [PublicAPIAttribute]
[CanBeNullAttribute]
public T GetOrInit(TArg1 arg1, TArg2 arg2, TArg3 arg3, Func`4<TArg1, TArg2, TArg3, T> evaluateFunc);
    public bool TryGet(T& result);
    public T Set(T value);
    private bool TryGet(T& result, Boolean& wasSet);
    public T Set(T newValue, Boolean& wasSet);
    [NotNullAttribute]
private static object Pack(T value);
    [CanBeNullAttribute]
private static T Unpack(object value);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppCachedValue`1 : ValueType {
    private SpinWaitLock myMutex;
    private bool myInitialized;
    private T myValue;
    public bool Empty();
    public T Get();
    public T Set(T newValue);
    public T Set(T newValue, Boolean& set);
    public void Clear();
}
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppCachesHashFunctions : object {
    public static Func`2<string, int> StringHashFunc;
    public static Func`2<string, int> PathStringHashFunc;
    public static Func`2<IPath, int> PathHashFunc;
    public static Func`2<VirtualFileSystemPath, int> FileSystemPathHashFunc;
    public static Func`2<CppPPDefineSymbol, int> DefineSymbolHashFunc;
    private static CppCachesHashFunctions();
    private static int GetHashCode(string str, bool caseSensitive);
    public static int GetHashCodeForNormalString(string str);
    public static int GetHashCodeForPathString(string str);
    public static int GetHashCode(IPath path);
    public static int GetHashCode(VirtualFileSystemPath path);
    public static int GetHashCode(CppPPDefineSymbol define);
}
public enum JetBrains.ReSharper.Psi.Cpp.Util.CppCharType : Enum {
    public int value__;
    public static CppCharType REGULAR;
    public static CppCharType WIDE;
    public static CppCharType CHAR8;
    public static CppCharType CHAR16;
    public static CppCharType CHAR32;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppCheckedEqualityComparerUtil : object {
    [ExtensionAttribute]
public static IEqualityComparer`1<T> MakeCheckedEqualityComparer(IEqualityComparer`1<T> comp);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppComparisonCategoryLookupFailure : CppUnknownEntityInfo {
    private static CppComparisonCategoryLookupFailure ourStrongOrderingInstance;
    private static CppComparisonCategoryLookupFailure ourWeakOrderingInstance;
    private static CppComparisonCategoryLookupFailure ourPartialOrderingInstance;
    [CompilerGeneratedAttribute]
private CppComparisonCategoryType <ComparisonCategory>k__BackingField;
    public CppComparisonCategoryType ComparisonCategory { get; }
    private CppComparisonCategoryLookupFailure(CppComparisonCategoryType comparisonCategory);
    private static CppComparisonCategoryLookupFailure();
    [CompilerGeneratedAttribute]
public CppComparisonCategoryType get_ComparisonCategory();
    public static CppComparisonCategoryLookupFailure Create(CppComparisonCategoryType comparisonCategory);
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppCompilationProperties : object {
    public static CppCompilationProperties Default;
    public VCXCompileAsManagedOptions ClrSupport;
    public bool ConformanceMode;
    public bool ConformantPreprocessor;
    public CppCoroutineMode CoroutineMode;
    public bool CPlusPlusDefineFromLanguageStandard;
    public DefaultCallingConvention DefaultCallingConvention;
    public bool DefaultCharIsUnsigned;
    public bool DisableLanguageExtensions;
    public bool ExcludedFromBuild;
    public List`1<string> ForcedIncludes;
    public bool ForceIncludePch;
    public bool HasBasicRuntimeChecks;
    public bool HasExceptionHandling;
    public bool HasRuntimeTypeInfo;
    public bool IgnorePrecompiledHeaderOptions;
    public CppHeaderSearchPaths HeaderSearchPaths;
    public bool IsAndroid;
    public bool IsDebug;
    public bool IsDll;
    public bool SanitizeAddress;
    public bool KernelMode;
    public bool Arm64DistinctNeonTypes;
    public Nullable`1<CppLanguageKind> LanguageKind;
    public CppLanguageStandard LanguageStandard;
    public CLanguageStandard CLanguageStandard;
    private int myHashCode;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myHashCodeCalculated;
    private int myIncludePathsHashCode;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myIncludePathsHashCodeCalculated;
    public bool OmitDefaultLibName;
    public CppLanguageDialect OverridenDialect;
    public string PrecompiledHeaderFile;
    public string PrecompiledHeaderThrough;
    public List`1<CppPPDefineSymbol> PredefinedMacros;
    public bool ProcessPredefinedMacros;
    public TargetMachine TargetMachine;
    public PlatformToolsetVersion Toolset;
    public bool TreatWChar_tAsBuiltInType;
    public List`1<string> UndefinedMacros;
    public PchOption UsePrecompiledHeader;
    public CppPropertiesOrigin PropertiesOrigin;
    private static CppCompilationProperties();
    public CppCompilationProperties ShallowClone();
    public int GetIncludePathsHashCode();
    public virtual int GetHashCode();
    public virtual bool Equals(object rhs);
    public virtual string ToString();
    private int CalcIncludePathsHashCode();
    private int CalcHashCode();
    public void Write(UnsafeWriter writer);
    public void Read(UnsafeReader reader);
    private static void WritePathList(UnsafeWriter writer, List`1<VirtualFileSystemPath> paths);
    private static List`1<VirtualFileSystemPath> ReadPathList(UnsafeReader reader);
    private static void WriteStringList(UnsafeWriter writer, List`1<string> l);
    private static List`1<string> ReadStringList(UnsafeReader reader);
    private static void WritePredefinedMacro(UnsafeWriter writer, CppPPDefineSymbol define);
    private static CppPPDefineSymbol ReadPredefinedMacro(UnsafeReader reader);
    [CompilerGeneratedAttribute]
internal static void <Read>g__ReadEnum|50_1(TEnum& result, <>c__DisplayClass50_0& );
    [CompilerGeneratedAttribute]
internal static void <Read>g__ReadBool|50_2(Boolean& result, <>c__DisplayClass50_0& );
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("4")]
[BaseTypeRequiredAttribute("JetBrains.ReSharper.Psi.Cpp.Util.ICppCompilationPropertiesProvider")]
public class JetBrains.ReSharper.Psi.Cpp.Util.CppCompilationPropertiesProviderAttribute : SolutionComponentAttribute {
    public static int PROJECT_MODEL_PRIORITY;
    public static int PLATFORM_PRIORITY;
    public static int NORMAL_PRIORITY;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    public int Priority { get; public set; }
    public CppCompilationPropertiesProviderAttribute(Instantiation instantiation);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Priority(int value);
}
public enum JetBrains.ReSharper.Psi.Cpp.Util.CppCoroutineMode : Enum {
    public byte value__;
    public static CppCoroutineMode Default;
    public static CppCoroutineMode Strict;
    public static CppCoroutineMode Experimental;
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Cpp.Util.CppCountingDictionary`2 : object {
    private Dictionary`2<TKey, KeyValuePair`2<TValue, int>> myDict;
    public TValue Item { get; }
    public CppCountingDictionary`2(IEqualityComparer`1<TKey> comparer);
    public TValue get_Item(TKey key);
    public bool ContainsKey(TKey key);
    public void Add(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public void Remove(TKey key);
}
internal class JetBrains.ReSharper.Psi.Cpp.Util.CppDeclaratorPresentationInfo : object {
    private List`1<CppTemplateParametersBase> myTemplateHeaders;
    private Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> myMapping;
    private CppQualifiedName myDeclQualifier;
    public CppDeclaratorPresentationInfo(List`1<CppTemplateParametersBase> templateHeaders, Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> mapping, CppQualifiedName declQualifier);
    public string PresentQualifier(CppViewPos& prefixVp);
    public string PresentDeclaratorName(CppQualifiedNamePart declName, CppViewPos& prefixVp, CppViewPos suffixVp);
    public List`1<CppTemplateParametersBase> GetTemplateParametersList();
    public Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> GetTemplateParametersMapping();
}
internal class JetBrains.ReSharper.Psi.Cpp.Util.CppDeclaratorPresentationInfoBuilder : ValueType {
    private List`1<CppTemplateParametersBase> myTemplateParameters;
    private Dictionary`2<ICppResolveEntity, CppTemplateParametersBase> myResolveEntityToTemplateParameters;
    private List`1<CppQualifiedNamePart> myNameParts;
    private ICppScopeResolveEntity myScope;
    private CppTypeContext myTypeContext;
    private bool mySeenExplicitSpecializationParent;
    private int myTypeTemplateParameterIndex;
    private int myExprTemplateParameterIndex;
    private int myTemplateTemplateParameterIndex;
    private CppDeclaratorPresentationInfoBuilder(CppTypeContext& tc);
    public static CppDeclaratorPresentationInfo GetPresentationInfo(CppQualifiedName qualifierHint, ICppScopeResolveEntity parent, ICppScopeResolveEntity targetScope, CppTypeContext& tc);
    private bool LearnLookupParent(ICppScopeResolveEntity ent);
    private CppQualifiedName CreateDeclQualifier(ICppScopeResolveEntity targetScope);
    private CppDeclaratorPresentationInfo Build(CppQualifiedName qualifierHint, ICppScopeResolveEntity targetScope);
    private bool LearnNonClassParent(ICppScopeResolveEntity ent);
    private bool LearnClassParent(ICppClassResolveEntity cls);
    private static bool HasTemplateParentsIgnoringThis(ICppClassResolveEntity cls);
    private void LearnTemplateParametersFromParent(ICppResolveEntity parent, CppTemplateParametersBase parameters);
    private void UpdateScope(ICppScopeResolveEntity ent);
    private CppTemplateParametersBase ReplaceAnonymousParams(CppTemplateParametersBase params);
    private CppTemplateParameters ReplaceAnonymousTemplateParams(CppTemplateParameters input);
    private CppGenericParameters ReplaceAnonymousGenericParams(CppGenericParameters input);
    private string CreateNameForTypeTemplateParameter();
    private CppQualifiedId CreateNameForExprTemplateParameter();
    private CppQualifiedId CreateNameForTemplateTemplateParameter();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Util.CppDecoratedNamePart : object {
    [CompilerGeneratedAttribute]
private CppQualifiedNamePart <InnerName>k__BackingField;
    public CppQualifiedNamePart InnerName { get; }
    protected CppDecoratedNamePart(CppQualifiedNamePart inner);
    [CompilerGeneratedAttribute]
public CppQualifiedNamePart get_InnerName();
    public virtual Result Accept(Data data, ICppQualifiedNamePartVisitor`2<Result, Data> visitor);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppDecoratedNamePartWithData`1 : CppDecoratedNamePart {
    [CompilerGeneratedAttribute]
private TData <Data>k__BackingField;
    public TData Data { get; }
    public CppDecoratedNamePartWithData`1(CppQualifiedNamePart inner, TData data);
    [CompilerGeneratedAttribute]
public TData get_Data();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppDeducedReturnTypeUsedBeforeFunctionDefinition : CppUnknownEntityInfo {
    public static CppDeducedReturnTypeUsedBeforeFunctionDefinition Instance;
    private static CppDeducedReturnTypeUsedBeforeFunctionDefinition();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Util.CppDependentInfo : Enum {
    public int value__;
    public static CppDependentInfo TypeDependent;
    public static CppDependentInfo ValueDependent;
    public static CppDependentInfo InstantiationDependent;
    public static CppDependentInfo UnknownDependent;
    public static CppDependentInfo GenericDependent;
    public static CppDependentInfo ContainsDependencyKiller;
    public static CppDependentInfo Uninitialized;
    public static CppDependentInfo NotDependent;
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppDependentInfoCachedValue : ValueType {
    private static int ourUninitializedValue;
    public static UninitializedT Uninitialized;
    private int myValue;
    public CppDependentInfoCachedValue(UninitializedT t);
    private static CppDependentInfoCachedValue();
    public bool Defined();
    public CppDependentInfo Get();
    public CppDependentInfo Set(CppDependentInfo value);
    public CppDependentInfo Set(CppDependentInfo value, Boolean& changed);
    public void Reset();
    private static byte ToUnderlyingType(CppDependentInfo value);
    private static CppDependentInfo FromUnderlyingType(int value);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppDependentInfoUtil : object {
    [ExtensionAttribute]
public static bool IsDependent(CppDependentInfo info);
    [ExtensionAttribute]
public static bool IsDependentOrContainsDependencyKiller(CppDependentInfo info);
    [ExtensionAttribute]
public static bool IsDependentNotUnknown(CppDependentInfo info);
    [ExtensionAttribute]
public static bool IsTypeDependent(CppDependentInfo info);
    [ExtensionAttribute]
public static bool IsTypeOrValueDependent(CppDependentInfo info);
    [ExtensionAttribute]
public static bool IsTypeOrValueOrInstantiationDependent(CppDependentInfo info);
    [ExtensionAttribute]
public static bool IsInstantiationDependent(CppDependentInfo info);
    [ExtensionAttribute]
public static bool IsTypeOrInstantiationDependent(CppDependentInfo info);
    [ExtensionAttribute]
public static bool IsTypeOrInstantiationOrUnknownDependent(CppDependentInfo info);
    [ExtensionAttribute]
public static bool IsTypeOrValueDependentOrContainsDependencyKiller(CppDependentInfo info);
    [ExtensionAttribute]
public static bool IsUnknownDependent(CppDependentInfo info);
    [ExtensionAttribute]
public static bool IsGenericDependent(CppDependentInfo info);
    [ExtensionAttribute]
public static bool IsValueOrUnknownDependent(CppDependentInfo info);
    [ExtensionAttribute]
public static bool IsTypeOrUnknownDependent(CppDependentInfo info);
    [ExtensionAttribute]
public static bool IsTypeOrValueOrGenericDependent(CppDependentInfo info);
    [ExtensionAttribute]
public static bool ContainsDependencyKiller(CppDependentInfo info);
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void AssertNotValueDependent(CppDependentInfo info);
    [ExtensionAttribute]
public static CppDependentInfo ConvertValueDependencyToTypeDependency(CppDependentInfo info);
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
private static void AssertInitialized(CppDependentInfo info);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppEnsureCheckForInterruptCookie : ValueType {
    public CppEnsureCheckForInterruptCookie(double limitMs);
    public sealed virtual void Dispose();
}
internal class JetBrains.ReSharper.Psi.Cpp.Util.CppEqualityComparerChecker`1 : object {
    private IEqualityComparer`1<T> myInner;
    public CppEqualityComparerChecker`1(IEqualityComparer`1<T> inner);
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
public enum JetBrains.ReSharper.Psi.Cpp.Util.CppEvaluationFailureKind : Enum {
    public int value__;
    public static CppEvaluationFailureKind NonConstantExpression;
    public static CppEvaluationFailureKind NonConstantExpressionWithContext;
    public static CppEvaluationFailureKind LookupFailure;
    public static CppEvaluationFailureKind UninitializedValue;
    public static CppEvaluationFailureKind InvalidBaseClass;
    public static CppEvaluationFailureKind NotASingleDelegatingCtor;
    public static CppEvaluationFailureKind UnresolvedFunctionOverloadSet;
    public static CppEvaluationFailureKind RecursiveVariableValueCalculation;
    public static CppEvaluationFailureKind DummySlotForAggregateInitialization;
    public static CppEvaluationFailureKind InternalError;
    public static CppEvaluationFailureKind InternalErrorWithContext;
    public static CppEvaluationFailureKind ITEMS_COUNT;
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppExpressionEvaluationFailure : CppUnknownEntityInfo {
    [CompilerGeneratedAttribute]
private CppEvaluationFailureKind <Failure>k__BackingField;
    public CppEvaluationFailureKind Failure { get; }
    public CppExpressionEvaluationFailure(CppEvaluationFailureKind failure);
    [CompilerGeneratedAttribute]
public CppEvaluationFailureKind get_Failure();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppExpressionIterativeTreeAdaptor : object {
    public static CppExpressionIterativeTreeAdaptor Instance;
    private static CppExpressionIterativeTreeAdaptor();
    public sealed virtual FrugalLocalList`1<ICppExpression> Children1(ICppExpression node);
    public sealed virtual IEnumerable`1<ICppExpression> Children2(ICppExpression node);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppFilter`1 : MulticastDelegate {
    public CppFilter`1(object object, IntPtr method);
    public virtual IEnumerable`1<T> Invoke(IEnumerable`1<T> e);
    public virtual IAsyncResult BeginInvoke(IEnumerable`1<T> e, AsyncCallback callback, object object);
    public virtual IEnumerable`1<T> EndInvoke(IAsyncResult result);
}
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppFilterFactory : object {
    public static CppFilter`1<T> CreateId();
    public static CppFilter`1<T> CreateEither(CppFilter`1<T> lhs, CppFilter`1<T> rhs);
    public static CppFilter`1<T> CreateWhere(Func`2<T, bool> pred);
    private static T IdFunction(T x);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppGenericAsTemplargFailure : CppUnknownEntityInfo {
    public static CppGenericAsTemplargFailure Instance;
    private static CppGenericAsTemplargFailure();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppGetExpressionChildren1Visitor : CppAbstractForwardingExpressionVisitor`1<FrugalLocalList`1<ICppExpression>> {
    public static CppGetExpressionChildren1Visitor Instance;
    private static CppGetExpressionChildren1Visitor();
    public virtual FrugalLocalList`1<ICppExpression> VisitExpression(ICppExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppEmptyExpression e);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppResolvedLiteralExpression e);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppUserDefinedLiteralExpression e);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppThisExpression e);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppParenExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppBinaryExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppUnaryExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppPostfixExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppConditionalExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppQualifiedReferenceExpression e);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppResolvedQualifiedReferenceExpression e);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppMemberAccessExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppNewExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppDeleteExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppSubscriptExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppCallExpression call);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppCastExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppSizeOfExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppSizeOfEllipsisExpression e);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppAlignOfExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppTypeIdExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppNoExceptExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppSingleArgumentTypeTraitExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppDoubleArgumentTypeTraitExpression e);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppMultiArgumentTypeTraitExpression e);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppMSUuidOfExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppMSNoopExpression e);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppMSAssumeExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppBuiltinAddressOfExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppGnuBuiltinConstantPExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppThrowExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppBracedInitListExpression e);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppBraceInitializedTemporaryExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppLambdaExpression e);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppReplacedLambdaExpression e);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppGnuStatementExpression e);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppReplacedGnuStatementExpression e);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppRequiresExpression e);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppReplacedRequiresExpression e);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppLinkageRequiresExpression e);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppPackExpansionExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppCliTypeIdExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppFoldExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppCoAwaitExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppCoYieldExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppC11GenericExpression expr);
    public virtual FrugalLocalList`1<ICppExpression> Visit(ICppDesignation d);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppGetExpressionChildren2Visitor : CppAbstractForwardingExpressionVisitor`1<IEnumerable`1<ICppExpression>> {
    public static CppGetExpressionChildren2Visitor Instance;
    private static CppGetExpressionChildren2Visitor();
    public virtual IEnumerable`1<ICppExpression> VisitExpression(ICppExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppEmptyExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppResolvedLiteralExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppUserDefinedLiteralExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppThisExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppParenExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppBinaryExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppUnaryExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppPostfixExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppConditionalExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppQualifiedReferenceExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppResolvedQualifiedReferenceExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppMemberAccessExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppNewExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppDeleteExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppSubscriptExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppCallExpression call);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppCastExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppSizeOfExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppSizeOfEllipsisExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppAlignOfExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppTypeIdExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppNoExceptExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppSingleArgumentTypeTraitExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppDoubleArgumentTypeTraitExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppMultiArgumentTypeTraitExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppMSUuidOfExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppMSNoopExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppMSAssumeExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppBuiltinAddressOfExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppGnuBuiltinConstantPExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppThrowExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppBracedInitListExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppBraceInitializedTemporaryExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppLambdaExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppReplacedLambdaExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppGnuStatementExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppReplacedGnuStatementExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppRequiresExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppReplacedRequiresExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppLinkageRequiresExpression e);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppPackExpansionExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppCliTypeIdExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppFoldExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppCoAwaitExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppCoYieldExpression expr);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppC11GenericExpression call);
    public virtual IEnumerable`1<ICppExpression> Visit(ICppDesignation e);
}
internal class JetBrains.ReSharper.Psi.Cpp.Util.CppGroupAllocation`1 : ValueType {
    private AbstractObjectPoolWithSubPools`1<T> myPool;
    [CompilerGeneratedAttribute]
private ObjectSubPool`1<T> <Pool>k__BackingField;
    public ObjectSubPool`1<T> Pool { get; }
    public CppGroupAllocation`1(AbstractObjectPoolWithSubPools`1<T> pool);
    public sealed virtual void Dispose();
    public T Alloc();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ObjectSubPool`1<T> get_Pool();
}
public enum JetBrains.ReSharper.Psi.Cpp.Util.CppIntegralLiteralSuffix : Enum {
    public int value__;
    public static CppIntegralLiteralSuffix NONE;
    public static CppIntegralLiteralSuffix UNSIGNED;
    public static CppIntegralLiteralSuffix CHAR;
    public static CppIntegralLiteralSuffix UNSIGNED_CHAR;
    public static CppIntegralLiteralSuffix SHORT;
    public static CppIntegralLiteralSuffix UNSIGNED_SHORT;
    public static CppIntegralLiteralSuffix LONG;
    public static CppIntegralLiteralSuffix UNSIGNED_LONG;
    public static CppIntegralLiteralSuffix LONGLONG;
    public static CppIntegralLiteralSuffix UNSIGNED_LONGLONG;
    public static CppIntegralLiteralSuffix SIGNED_SIZE_T;
    public static CppIntegralLiteralSuffix SIZE_T;
    public static CppIntegralLiteralSuffix USER_DEFINED;
    public static CppIntegralLiteralSuffix INVALID;
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppInternalFailure : CppUnknownEntityInfo {
    public static CppInternalFailure Instance;
    private static CppInternalFailure();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Cpp.Util.CppIntLiteralBase : Enum {
    public int value__;
    public static CppIntLiteralBase BIN;
    public static CppIntLiteralBase DEC;
    public static CppIntLiteralBase OCT;
    public static CppIntLiteralBase HEX;
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppInvalidArgumentOfBuiltinTypeTraitFailure : CppUnknownEntityInfo {
    public static CppInvalidArgumentOfBuiltinTypeTraitFailure Instance;
    private static CppInvalidArgumentOfBuiltinTypeTraitFailure();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppInvalidFoldExpressionFailure : CppUnknownEntityInfo {
    public static CppInvalidFoldExpressionFailure BothSidesContainUnexpandedPack;
    public static CppInvalidFoldExpressionFailure NoUnexpandedPack;
    public static CppInvalidFoldExpressionFailure EmptyUnaryFoldExpansion;
    [CompilerGeneratedAttribute]
private CppInvalidFoldExpressionFailureKind <Failure>k__BackingField;
    public CppInvalidFoldExpressionFailureKind Failure { get; }
    private CppInvalidFoldExpressionFailure(CppInvalidFoldExpressionFailureKind failure);
    private static CppInvalidFoldExpressionFailure();
    [CompilerGeneratedAttribute]
public CppInvalidFoldExpressionFailureKind get_Failure();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Cpp.Util.CppInvalidFoldExpressionFailureKind : Enum {
    public int value__;
    public static CppInvalidFoldExpressionFailureKind BothSidesContainUnexpandedPack;
    public static CppInvalidFoldExpressionFailureKind NoUnexpandedPack;
    public static CppInvalidFoldExpressionFailureKind EmptyUnaryFoldExpansion;
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppInvalidNonTypeTemplateArgumentValueFailure : CppUnknownEntityInfo {
    public static CppInvalidNonTypeTemplateArgumentValueFailure Instance;
    private static CppInvalidNonTypeTemplateArgumentValueFailure();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppInvalidNumberOfStructuredBindingsFailure : CppUnknownEntityInfo {
    [CompilerGeneratedAttribute]
private CppQualType <InnerType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExpectedNumElements>k__BackingField;
    public CppQualType InnerType { get; }
    public int ExpectedNumElements { get; }
    public CppInvalidNumberOfStructuredBindingsFailure(CppQualType innerType, int expectedNumElements);
    [CompilerGeneratedAttribute]
public CppQualType get_InnerType();
    [CompilerGeneratedAttribute]
public int get_ExpectedNumElements();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppInvalidStructuredBindingsInitializerClassFailure : CppUnknownEntityInfo {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string Reason { get; }
    public CppInvalidStructuredBindingsInitializerClassFailure(string reason);
    [CompilerGeneratedAttribute]
public string get_Reason();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppInvalidTypeFailure : CppUnknownEntityInfo {
    [CompilerGeneratedAttribute]
private CppQualType <FailureType>k__BackingField;
    [CompilerGeneratedAttribute]
private CppInvalidTypeFailureKind <Failure>k__BackingField;
    public CppQualType FailureType { get; }
    public CppInvalidTypeFailureKind Failure { get; }
    public CppInvalidTypeFailure(CppQualType innerType, CppInvalidTypeFailureKind failure);
    [CompilerGeneratedAttribute]
public CppQualType get_FailureType();
    [CompilerGeneratedAttribute]
public CppInvalidTypeFailureKind get_Failure();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Cpp.Util.CppInvalidTypeFailureKind : Enum {
    public int value__;
    public static CppInvalidTypeFailureKind BadFunctionParameterType;
    public static CppInvalidTypeFailureKind BadFunctionReturnType;
    public static CppInvalidTypeFailureKind BadPointeeType;
    public static CppInvalidTypeFailureKind BadArrayInnerType;
    public static CppInvalidTypeFailureKind BadReferencedType;
    public static CppInvalidTypeFailureKind BadMemberPointerClassType;
    public static CppInvalidTypeFailureKind BadMemberPointerPointeeType;
    public static CppInvalidTypeFailureKind BadNonTypeTemplateParameterType;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppIsModifiableImplementationUtil : object {
    [ExtensionAttribute]
public static bool IsAtQtGeneratedComment(CppDocumentBuffer docBuffer);
    [ExtensionAttribute]
public static bool IsCreatedByQrcTool(CppDocumentBuffer docBuffer);
    private static bool LexerTokenContainsText(CppInnerLexer& lexer, string text);
    private static bool IsAtQtGeneratedFileComment(CppInnerLexer& lexer);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppIsModifiableUtil : object {
    [ExtensionAttribute]
public static bool IsModifiableFile(CppFileLocation file, ISolution solution);
    [ExtensionAttribute]
public static bool IsModifiableFile(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
public static bool IsInsideModifiableFile(ITreeNode node);
    [ExtensionAttribute]
public static bool AreAllSymbolsInsideModifiableFiles(ICppResolveEntity ent);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppLinkageUnknownTypeFailure : CppUnknownEntityInfo {
    public static CppLinkageUnknownTypeFailure INSTANCE;
    private static CppLinkageUnknownTypeFailure();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Cpp.Util.CppListSlice`1 : ValueType {
    private IList`1<T> myList;
    private int myBase;
    private int myBound;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public CppListSlice`1(IList`1<T> list, int base, int bound);
    public CppListSlice`1(IList`1<T> list, int base);
    public static CppListSlice`1<T> WholeList(IList`1<T> list);
    public IList`1<T> GetUnderlyingList();
    public int GetBase();
    public int GetBound();
    public CppListSliceEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T t);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T t);
    public sealed virtual void CopyTo(T[] targetArray, int startingFrom);
    public sealed virtual bool Remove(T t);
    public sealed virtual T get_Item(int i);
    public sealed virtual void set_Item(int i, T value);
    public sealed virtual int IndexOf(T t);
    public sealed virtual void Insert(int i, T t);
    public sealed virtual void RemoveAt(int i);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppListSliceEnumerator`1 : ValueType {
    private CppListSlice`1<T> mySlice;
    private int myCurIndex;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public CppListSliceEnumerator`1(CppListSlice`1& slice);
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppLiteralEvaluationUtil : object {
    public static bool TryParseDigits(string input, UInt64& result, CppIntLiteralBase& base, Int32& suffixPosition, Boolean& hasOverflow);
    public static CppIntegralLiteralSuffix TryParseSuffix(string input, int suffixPosition, CppLanguageDialect dialect);
    public static CppIntTypeKind CalcIntTypeKind(ulong value, CppIntLiteralBase base, CppIntegralLiteralSuffix suffix, CppLanguageDialect dialect);
    public static bool TryParseInt(string r, CppLanguageDialect dialect, UInt64& result, CppIntLiteralBase& base, CppIntTypeKind& kind);
    public static bool TryParseInt(string r, CppLanguageDialect dialect, UInt64& result, CppIntLiteralBase& base, bool calcKind, CppIntTypeKind& kind, bool allowUnknownSuffixes);
    public static bool TryParseChar(string text, CppLanguageDialect dialect, UInt32& result, Int32& bytes, CppCharType& charType, Boolean& hasUnusedChars);
    private static int SkipCharacterPrefix(string text, CppCharType& charType);
    private static bool IsOctal(char ch);
    private static bool IsHex(char ch);
    private static bool IsDecimal(char ch);
    private static int ParseHex(char ch);
    public static ICppExpression CreateLiteralExpression(TokenNodeType tt, string text, CppLanguageDialect dialect);
    public static ICppExpression CreateStringLiteralExpression(FrugalLocalList`1<string> stringParts, string userDefinedSuffix);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppLocationRangeEndComparer : object {
    public virtual int Compare(CppAnchorRange`1<CppLocationAnchor> l, CppAnchorRange`1<CppLocationAnchor> r);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppLookupFailure : CppUnknownEntityInfo {
    public static CppLookupFailure Instance;
    private static CppLookupFailure();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppMacroUtil : object {
    public static string CalculateMacroSubstitutionText(MacroCall call, bool direct, TreeTextRange& range);
    public static CppTreeElementRange CalculateMacroSubstitutionRange(MacroCall call);
    public static CppList`1<ITokenNode> CalculateArgumentTokenSubstitution(ITokenNode token);
    public static CppList`1<ITokenNode> CalculateArgumentTokenSubstitution(ITokenNode token, MacroArgument arg);
    public static bool CameFromMacroSubstitution(ITokenNode node);
    public static bool CameFromMacroSubstitution(ITreeNode node);
    [NotNullAttribute]
public static List`1<CppFromSubstitutionTokenNode> GetTokensFromMacroSubstitution(MacroCall call, bool direct);
    public static bool IsClosed(ITreeNode node);
    public static bool CheckWhetherMacroSpawnsOnlySubtreesOf(ITreeNode node);
    public static bool CheckWhetherMacroSpawnsOnlySubtreesOf(ITreeRange range);
    public static bool ExistsMacroArgumentMappingOnto(ITreeRange range);
    public static bool ExistsMacroArgumentMappingOnto(ITreeNode node);
    public static bool ExistsMacroArgumentMappingOnto(ITreeNode node, HashSet`1& foundProtoTokens);
    public static bool ExistsMacroArgumentMappingOnto(IEnumerable`1<ITokenNode> tokens);
    public static CppTreeElementRange MacroArgumentProtoTokensRange(ITreeRange range);
    [NotNullAttribute]
private static List`1<CppFromSubstitutionTokenNode> CalculateMacroSubstitutionRangeInternal(MacroCall call, bool direct, TreeTextRange& textRange);
    private static bool ExistsMacroArgumentMappingOntoImpl(IEnumerable`1<ITokenNode> tokens, HashSet`1& foundProtoTokens);
    private static IList`1<ITokenNode> GetTokenList(ITreeRange range);
    private static IList`1<ITokenNode> GetTokenList(ITreeNode node);
    private static CppTreeElementRange CalculateMacroSubstitutionRangeSkippingMacroCalls(MacroCall mc);
    private static ITreeNode FindNodeParentForRangeCheck(ITreeNode node, ITreeNode rangeParent);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppMonostate : ValueType {
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppNoConcurrencyChecker : object {
    private int myCurrentThreadId;
    public void Lock();
    public void Unlock();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Util.CppNoConcurrencyCheckerGuard : ValueType {
    private CppNoConcurrencyChecker myCc;
    public CppNoConcurrencyCheckerGuard(CppNoConcurrencyChecker cc);
    public sealed virtual void Dispose();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppNonExpressionTemplateArgumentUsedAsExpressionFailure : CppUnknownEntityInfo {
    public static CppNonExpressionTemplateArgumentUsedAsExpressionFailure Instance;
    private static CppNonExpressionTemplateArgumentUsedAsExpressionFailure();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppNontypeModuleEntityUsedAsTypeFailure : CppUnknownEntityInfo {
    public static CppNontypeModuleEntityUsedAsTypeFailure Instance;
    private static CppNontypeModuleEntityUsedAsTypeFailure();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppNontypeResolveEntityUsedAsTypeFailure : CppUnknownEntityInfo {
    public static CppNontypeResolveEntityUsedAsTypeFailure Instance;
    private static CppNontypeResolveEntityUsedAsTypeFailure();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppOverridenProjectConfiguration : object {
    public static Key`1<CppCompilationProperties> PROJECT_PROPERTIES_KEY;
    private static CppOverridenProjectConfiguration();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppOverridenProjectFileProperties : ProjectFilePropertiesBase {
    [CompilerGeneratedAttribute]
private CppCompilationProperties <CompilationProperties>k__BackingField;
    public CppCompilationProperties CompilationProperties { get; private set; }
    public CppOverridenProjectFileProperties(CppCompilationProperties compilationProperties);
    [CompilerGeneratedAttribute]
public CppCompilationProperties get_CompilationProperties();
    [CompilerGeneratedAttribute]
private void set_CompilationProperties(CppCompilationProperties value);
    public virtual void ReadFileProperties(UnsafeReader reader, IStringIntern stringIntern);
    public virtual void WriteProjectFileProperties(UnsafeWriter writer, IStringIntern stringIntern);
    public virtual void Dump(TextWriter to, DumpFlags flags);
    public virtual bool UpdatePropertiesFrom(IProjectFileProperties properties);
}
[ProjectModelExtensionAttribute("16")]
public class JetBrains.ReSharper.Psi.Cpp.Util.CppOverridenProjectFilePropertiesProvider : ProjectFilePropertiesProviderBase {
    public static Guid Guid;
    private static CppOverridenProjectFilePropertiesProvider();
    public virtual bool IsApplicable(IProjectProperties projectProperties);
    public virtual IProjectFileProperties CreateProjectFileProperties();
}
public enum JetBrains.ReSharper.Psi.Cpp.Util.CppPartialOrderingResult : Enum {
    public int value__;
    public static CppPartialOrderingResult Less;
    public static CppPartialOrderingResult Indistinguishable;
    public static CppPartialOrderingResult Greater;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppPerfEventAccumulatorUtil : object {
    public static ICppPerfEventAccumulator CreateSimpleAccumulator(ICppPerfEventAccumulator parent);
    [ExtensionAttribute]
[ConditionalAttribute("JET_DEBUG_MODE")]
public static void TracePerfEvent(ICppPerfEventAccumulator perfEvents, ICppPerfEventType eventType, T arg);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Util.CppPoolAllocation`1 : ValueType {
    private AbstractObjectPool`1<T> myPool;
    [CompilerGeneratedAttribute]
private T <Object>k__BackingField;
    public T Object { get; }
    public CppPoolAllocation`1(AbstractObjectPool`1<T> pool);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public T get_Object();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppPPLocationRangeEndComparer : object {
    public sealed virtual int Compare(CppAnchorRange`1<CppPPLocationAnchor> l, CppAnchorRange`1<CppPPLocationAnchor> r);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppPrintDeclarationInfo : object {
    public string DeclaratorName;
    public List`1<CppTemplateParametersBase> TemplateHeaders;
    public CppViewPos ViewPosForPrefixTypePart;
    public CppViewPos ViewPosForSuffixTypePart;
    public CppPrintDeclarationInfo(string declName, List`1<CppTemplateParametersBase> templateHeaders, CppViewPos& vpForPrefix, CppViewPos& vpForSuffix);
}
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppPrintDeclarationUtil : object {
    public static CppPrintDeclarationInfo PrintScopeAsQualifierInScope(CppQualifiedName qualifierHint, ICppScopeResolveEntity scope, ICppScopeResolveEntity targetScope, CppTypeContext& tc);
    public static CppPrintDeclarationInfo PrintDeclarationInScope(ICppDeclaratorResolveEntity decl, CppQualifiedName qualifierHint, ICppScopeResolveEntity targetScope, CppTypeContext& tc);
    private static CppQualifiedNamePart GetNameForDeclaration(CppTemplateId name);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppPriorityMutex : ValueType {
    public static TagT Tag;
    private object myMutex;
    private object myPrioritisedMutex;
    private Priority modreq(System.Runtime.CompilerServices.IsVolatile) myLockRequestPriority;
    public CppPriorityMutex(TagT tag);
    private static CppPriorityMutex();
    public void Lock(Priority priority);
    public void Unlock();
    public bool IsLocked();
    public bool PrioritisedLockRequested(Priority priority);
    private void LockPrioritised(Priority priority);
    private void WaitForMorePrioritized(Priority priority);
    private void LockAndCheckPriority(Priority priority);
}
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppProcessTreeIterativelyUtil : object {
    public static void ProcessTreeIteratively(TNode root, ICppIterativeTreeAdaptor`1<TNode> adaptor, ICppIterativeTreeProcessor`1<TNode> processor);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppProgressIndicatorGuard : object {
    private IProgressIndicator myProgress;
    public CppProgressIndicatorGuard(IProgressIndicator progress, int totalWorkUnits);
    public CppProgressIndicatorGuard(IProgressIndicator progress, string taskName, int totalWorkUnits);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppProjectConfigurationUtil : object {
    public static bool IsMiscFilesOrSolutionProject(IProject project);
    public static bool IsInMiscFilesOrSolutionProject(IProjectFile projectFile);
    public static bool ExcludedFromBuild(ISolution solution, CppFileLocation file);
    public static bool ExcludedFromBuild(IProjectFile projectFile);
    [CanBeNullAttribute]
public static VCXProjectConfiguration GetProjectConfiguration(IProject project);
    public static bool IsCppProject(IProject project);
    public static bool IsOpenFolderProject(IProject project);
    public static bool IsCppOrOpenFolderProject(IProject project);
    public static bool HasXCodeToolset(IProject project);
    public static CppCompilationProperties ParseCommandLine(String[] commandLineArguments, VirtualFileSystemPath projectLocation);
    public static CppCompilationProperties GetVCCompilationProperties(IProject project, IProjectFile projectFile, CppFileLocation rootFile, CppGlobalSymbolCache globalCache);
    private static CppCompilationProperties GetCommandLineCompilationPropertiesImpl(IProject project, CppFileLocation rootFile, VCXProjectConfiguration configuration, CppGlobalSymbolCache cache, String[] commandLineArgs);
    public static CppCompilationProperties GetIntelliSenseCompilationProperties(IProject project, VirtualFileSystemPath projectFile, CppFileLocation rootFile, CppGlobalSymbolCache globalCache);
    public static CppCompilationProperties GetCompilationProperties(IProject project, IProjectFile projectFile, CppFileLocation rootFile, CppGlobalSymbolCache globalCache);
    public static CppCompilationProperties GetProjectCompilationProperties(IProject project, CppGlobalSymbolCache globalCache);
    public static ValueTuple`2<CppCompilationProperties, IProject> GetStandardLibraryCompilationProperties(CppFileLocation rootFile, CppGlobalSymbolCache globalCache);
    public static IEnumerable`1<VirtualFileSystemPath> GetProjectIncludePaths(IProject project, CppGlobalSymbolCache cache);
    public static CppLanguageDialect GetLanguageDialect(CppCompilationProperties props);
    public static bool IsMSVCPlatformToolset(PlatformToolsetVersion toolsetVersion);
    [ExtensionAttribute]
public static IDisposable CreateCompilationContextCookie(IProjectFile projectFile);
    private static CppIntelliSenseInfo GetIntelliSenseInfo(IProject project, VirtualFileSystemPath file, ICppIntelliSenseInfoProvider intelliSenseInfoProvider);
    public static bool IsTargetMachine64Bit(CppCompilationProperties props);
    private static PlatformToolsetVersion GetPlatformToolsetVersion(string platformToolset);
    private static bool Contains(List`1<CppPPDefineSymbol> defines, string name);
    public static CppLanguageKind GetCompilationLanguageByFileName(CppFileLocation file);
    private static string ParseOptionValue(string value);
    private static string ParseOptionWithValue(string name, string option, String[] args, Int32& argIdx);
    private static string ParseOptionWithConcatenatedValue(string name, string option);
    private static void ParseStdCppOption(string std, CppLanguageStandard& languageStandard);
    private static void ParseStdCOption(string std, CLanguageStandard& cLanguageStandard);
    private static void ParseCommandLineImpl(String[] commandLineArguments, VirtualFileSystemPath projectLocation, CppCompilationProperties props);
    private static CppLanguageKind GetLanguageKind(CppFileLocation rootFile, VCXProjectConfiguration configuration, VCCompilerToolProperties toolProperties);
    private static void IgnorePrecompiledHeaderOptionsIfNeeded(CppCompilationProperties props);
    private static void FixProjectPropertiesForUnrealCFiles(CppCompilationProperties props, CppFileLocation rootFile, ICppUE4SolutionDetector unrealDetector);
    private static List`1<VirtualFileSystemPath> ConcatIncludePaths(VirtualFileSystemPath[] s1, VirtualFileSystemPath[] s2, List`1<VirtualFileSystemPath> s3, VirtualFileSystemPath[] s4, List`1<VirtualFileSystemPath> s5, IList`1<VirtualFileSystemPath> s6);
    private static CppCompilationProperties GetCompilationPropertiesFromVCProject(IProject project, CppFileLocation rootFile, VCXProjectConfiguration configuration, VCProjectFileProperties fileProperties, VCCompilerToolProperties toolProperties, CppGlobalSymbolCache cache);
    private static bool ShouldForceIncludePch(CppFileLocation rootFile, Nullable`1<CppLanguageKind> languageKind);
    private static bool ContainsIgnoreCase(string text, string needle);
    public static CppCompilationProperties GetCompilationPropertiesFromIntelliSenseInfo(IProject project, CppFileLocation rootFile, CppIntelliSenseInfo context, CppGlobalSymbolCache cache, TargetMachine defaultTargetMachine);
    private static VCCompilerToolProperties GetToolProperties(IProject project, IProjectFile projectFile);
    private static CppCompilationProperties GetOverridenProperties(IProjectFileProperties file, IProjectConfiguration project, CppFileLocation rootFile);
    public static IList`1<VirtualFileSystemPath> GetIncludeDirectoriesFromReferencedProjects(IProject project);
    [ExtensionAttribute]
public static bool IsPrecompiledHeaderForceIncluded(CppCompilationProperties props);
}
public enum JetBrains.ReSharper.Psi.Cpp.Util.CppPropertiesOrigin : Enum {
    public byte value__;
    public static CppPropertiesOrigin VCProject;
    public static CppPropertiesOrigin ClCommandLine;
    public static CppPropertiesOrigin VSIntelliSense;
    public static CppPropertiesOrigin UnrealEngine;
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppRangeEndComparer`1 : object {
    public sealed virtual int Compare(CppAnchorRange`1<Anchor> l, CppAnchorRange`1<Anchor> r);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Util.CppReadNoConcurrencyGuard : ValueType {
    private CppRWNoConcurrencyChecker myMutex;
    private bool myRaceDetected;
    public CppReadNoConcurrencyGuard(CppRWNoConcurrencyChecker mutex);
    public sealed virtual void Dispose();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppRecursiveTypeCalculationFailure : CppUnknownEntityInfo {
    public static CppRecursiveTypeCalculationFailure Instance;
    private static CppRecursiveTypeCalculationFailure();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Cpp.Util.CppRWNoConcurrencyChecker : object {
    public static int WRITE_INCREMENT;
    public int Counter;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppStringBuilderUtil : object {
    public static TextRange AppendStringRetRange(StringBuilder sb, string s);
    public static StringBuilder AppendWsIfNeeded(StringBuilder sb);
    public static StringBuilder AppendWithWsIfNeeded(StringBuilder sb, string s);
    [ExtensionAttribute]
public static void AppendIndented(StringBuilder sb, string str, string indent);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppStringLiteralEvaluationUtil : object {
    public static ICppValueExpression[] StringLiteralToArray(FrugalLocalList`1<string> parts, CppLanguageDialect dialect, CppStringLiteralType& literalType);
    public static UInt32[] StringLiteralToRawArray(FrugalLocalList`1<string> parts, CppLanguageDialect dialect, CppStringLiteralType& literalType);
    public static int GetSizeOfStringLiteral(FrugalLocalList`1<string> parts, CppLanguageDialect dialect, CppStringLiteralType& resultType);
    public static CppStringLiteralType GetStringLiteralType(FrugalLocalList`1<string> parts, CppLanguageDialect dialect);
    public static string StringLiteralToSingleString(FrugalLocalList`1<string> parts);
    public static CppQualType LiteralTypeToQualType(CppStringLiteralType literalType, CppLanguageDialect dialect);
    public static ICppValue CreateCharacterValue(UInt32 value, CppStringLiteralType literalType, CppLanguageDialect dialect);
    public static ICppExpression CreateCharacterValue(UInt32 value, CppCharType charType, CppLanguageDialect dialect);
    public static ICppUnsignedIntegralValue CreateWChar(UInt32 value, CppLanguageDialect dialect);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Util.CppStringLiteralEvaluationUtil/<AppendUTF8CodePoint>d__9")]
private static IEnumerable`1<byte> AppendUTF8CodePoint(int cp);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Util.CppStringLiteralEvaluationUtil/<StringToUTF8Array>d__10")]
public static IEnumerable`1<UInt32> StringToUTF8Array(string unscreenedText);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Util.CppStringLiteralEvaluationUtil/<StringToUTF16Array>d__11")]
private static IEnumerable`1<UInt32> StringToUTF16Array(string unscreenedText);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Cpp.Util.CppStringLiteralEvaluationUtil/<StringToUTF32Array>d__12")]
public static IEnumerable`1<UInt32> StringToUTF32Array(string unscreenedText);
    private static CppStringLiteralType PrefixType(string text, CppLanguageDialect dialect);
    public static void StringLiteralPartToString(string text, StringBuilder sb);
    private static CppStringLiteralType GetLiteralType(FrugalLocalList`1<string> parts, CppLanguageDialect dialect);
    private static IEnumerable`1<UInt32> StringLiteralToArrayImpl(FrugalLocalList`1<string> parts, CppLanguageDialect dialect, CppStringLiteralType& literalType);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppStringUtil : object {
    public static Func`2<char, bool> IsLetter;
    public static Action`2<StringBuilder, string> AppendStringToStringBuilderAction;
    private static CppStringUtil();
    public static void AppendStringToStringBuilder(StringBuilder sb, string str);
    [ExtensionAttribute]
public static int IndexOf(string s, Func`2<char, bool> predicate);
    public static string Join(string separator, IEnumerable`1<T> values);
    public static StringBuilder Join(StringBuilder sb, string separator, IEnumerable`1<T> values, Action`2<StringBuilder, T> presenter);
    public static StringBuilder SortAndJoin(StringBuilder sb, string separator, IEnumerable`1<T> values, Action`2<StringBuilder, T> presenter);
    public static string FormatTemplateParameters(IEnumerable`1<T> parameters);
    public static Func`2<T, string> ToStringFunctor();
    public static ICollection`1<string> GetWordsInText(string text);
    public static string MakeSmaller(string str);
    public static string MakeSmaller(string str, int maxLen);
    public static string MakeDumpedPsiSmaller(string str);
    [ExtensionAttribute]
public static string IndentEachLine(string str, string indent);
    [ExtensionAttribute]
public static string IndentEachLineExceptFirst(string str, string indent);
    public static int GetHashCode(string s);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppStructuredBindingTypeDeductionFailure : CppUnknownEntityInfo {
    public static CppStructuredBindingTypeDeductionFailure TypeIsDependentOrUnknown;
    public static CppStructuredBindingTypeDeductionFailure DeclarationRequiresInitializer;
    public static CppStructuredBindingTypeDeductionFailure DecompositionOfArrayWithUnknownSize;
    public static CppStructuredBindingTypeDeductionFailure DecompositionOfNonClassAndNonArrayType;
    public static CppStructuredBindingTypeDeductionFailure TupleElementTypeLookupFailed;
    [CompilerGeneratedAttribute]
private CppStructuredBindingTypeDeductionFailureKind <Failure>k__BackingField;
    public CppStructuredBindingTypeDeductionFailureKind Failure { get; }
    private CppStructuredBindingTypeDeductionFailure(CppStructuredBindingTypeDeductionFailureKind failureKind);
    private static CppStructuredBindingTypeDeductionFailure();
    [CompilerGeneratedAttribute]
public CppStructuredBindingTypeDeductionFailureKind get_Failure();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Cpp.Util.CppStructuredBindingTypeDeductionFailureKind : Enum {
    public int value__;
    public static CppStructuredBindingTypeDeductionFailureKind TypeIsDependentOrUnknown;
    public static CppStructuredBindingTypeDeductionFailureKind DeclarationRequiresInitializer;
    public static CppStructuredBindingTypeDeductionFailureKind DecompositionOfArrayWithUnknownSize;
    public static CppStructuredBindingTypeDeductionFailureKind DecompositionOfNonClassAndNonArrayType;
    public static CppStructuredBindingTypeDeductionFailureKind TupleElementTypeLookupFailed;
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppSubstitutionFailure : CppUnknownEntityInfo {
    public static CppSubstitutionFailure InternalFailureInstance;
    public static CppSubstitutionFailure LookupFailureInstance;
    [CompilerGeneratedAttribute]
private CppUnknownEntityInfo <InnerFailure>k__BackingField;
    public CppUnknownEntityInfo InnerFailure { get; }
    public CppSubstitutionFailure(CppUnknownEntityInfo innerFailure);
    private static CppSubstitutionFailure();
    [CompilerGeneratedAttribute]
public CppUnknownEntityInfo get_InnerFailure();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Util.CppTypeContext : ValueType {
    public CppViewPos ViewPos;
    public ICppResolvedTypeFactory Factory;
    public CppTypeContext(CppViewPos ViewPos, ICppResolvedTypeFactory Factory);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CppTypeContext left, CppTypeContext right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CppTypeContext left, CppTypeContext right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CppTypeContext other);
    [CompilerGeneratedAttribute]
public void Deconstruct(CppViewPos& ViewPos, ICppResolvedTypeFactory& Factory);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppTypeContextUtil : object {
    public static CppTypeContext FromResolveEntity(ICppResolveEntity ent, CppViewPos& viewPos);
    public static CppTypeContext FromViewPos(CppViewPos& viewPos);
    [ExtensionAttribute]
public static CppTypeContext GetWithNonNormalizingFactory(CppTypeContext& tc);
    public static CppTypeContext FromPsi(ICppCompositeNode node);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppTypeConversionFailure : CppUnknownEntityInfo {
    [CompilerGeneratedAttribute]
private CppQualType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ICppExpression <Expression>k__BackingField;
    public CppQualType Type { get; }
    public ICppExpression Expression { get; }
    public CppTypeConversionFailure(CppQualType type, ICppExpression expr);
    [CompilerGeneratedAttribute]
public CppQualType get_Type();
    [CompilerGeneratedAttribute]
public ICppExpression get_Expression();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppTypeNameUtil : object {
    private static HashSet`1<CppQualifiedId> ourKnownIteratorNames;
    private static CppTypeNameUtil();
    public static bool IsIterator(CppTypedefType typedef);
    [ExtensionAttribute]
public static bool IsIterator(CppQualType type);
    [ExtensionAttribute]
public static CppQualType DropMemberTypedefs(CppQualType type, ICppResolvedTypeFactory tf, bool dropScopeAndNameSuggestions);
    private static bool ShouldRemoveAlias(CppTypeTemplateDeclaratorWithAppliedArgumentsResolveEntity alias);
    [ExtensionAttribute]
public static CppQualType Abbreviate(CppQualType type, ICppResolvedTypeFactory tf, bool dropScopeAndNameSuggestions);
    [ExtensionAttribute]
private static CppQualType AbbreviateNonReferenceType(CppQualType type, ICppResolvedTypeFactory tf, bool dropScopeAndNameSuggestions);
    private static CppQualType UnwrapKnownTraits(CppQualType wrappedType);
    public static bool UseSuggestedType(CppQualType& type, CppQualifiedName qualName);
    private static bool UseSuggestedTypeRecursively(CppQualType& type, CppQualifiedName qualName, ICppResolvedTypeFactory tf);
    private static List`1<CppQualType> GetTypeTemplateArguments(CppQualifiedName qualName);
    private static bool TryUseSuggestedType(CppQualType& type, IEnumerable`1<CppQualType> suggestedTypes);
    private static bool TryUseSuggestedType(CppQualType& type, CppQualType suggestedType);
    private static bool TryUseSuggestedTypeRecursively(CppQualType& type, List`1<CppQualType> suggestedTypes, ICppResolvedTypeFactory tf);
    [ExtensionAttribute]
public static bool IsReservedName(CppQualifiedNamePart name);
    [ExtensionAttribute]
private static bool HasReservedNames(CppQualifiedName name);
    [ExtensionAttribute]
private static bool HasReservedNames(ICppResolveEntity entity);
    [ExtensionAttribute]
private static CppQualType UnwrapReservedNames(CppQualType t, ICppResolvedTypeFactory tf);
    [CompilerGeneratedAttribute]
internal static CppQualType <UnwrapKnownTraits>g__UnwrapType|8_0(ICppTemplateArgument arg);
}
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppUE4ProjectConfigurationUtil : object {
    internal static bool ShouldUseModuleProperties(ICppUE4ProjectPropertiesProvider propsProvider, ICppUE4SolutionDetector ue4Detector);
    public static ICppUE4ModuleProperties GetUE4ModulePropertiesForFile(ICppUE4ModuleNamesProvider moduleNamesProvider, ICppUE4ProjectPropertiesProvider propsProvider, ICppUE4SolutionDetector ue4Detector, VirtualFileSystemPath rootFile);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppUnknownArraySizeFailure : CppUnknownEntityInfo {
    public static CppUnknownArraySizeFailure Instance;
    private static CppUnknownArraySizeFailure();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Cpp.Util.CppUnknownEntityInfo : object {
    public abstract virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public abstract virtual string ToString();
}
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppUnknownEntityInfoUtil : object {
    public static CppUnknownEntityInfo AddSubstitutionFailureIfNeeded(CppUnknownEntityInfo e);
    public static bool IsTypeSubstitutionFailure(CppUnknownEntityInfo e);
    public static bool IsExpressionSubstitutionFailure(CppUnknownEntityInfo e);
    public static bool IsTemplateSubstitutionFailure(CppUnknownEntityInfo e);
    public static bool IsLookupFailure(CppUnknownEntityInfo e);
    public static int HashCode(CppUnknownEntityInfo info);
    public static bool AreEqual(CppUnknownEntityInfo lhs, CppUnknownEntityInfo rhs);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppUnknownEntityInfoWithReason : CppUnknownEntityInfo {
    public static CppUnknownEntityInfoWithReason FailedToDeduceReturnTypeOfDefaultedComparisonFunction;
    public static CppUnknownEntityInfoWithReason RewrittenEqualityCandidateDoesNotReturnBool;
    public static CppUnknownEntityInfoWithReason TypeOfBracedInitList;
    public static CppUnknownEntityInfoWithReason TypeOfFunctionOverloadSet;
    public static CppUnknownEntityInfoWithReason ClassTemplateArgumentDeductionFail;
    public static CppUnknownEntityInfoWithReason TypeInfoLookupFailure;
    [CompilerGeneratedAttribute]
private CppUnknownEntityReason <Reason>k__BackingField;
    public CppUnknownEntityReason Reason { get; }
    private CppUnknownEntityInfoWithReason(CppUnknownEntityReason reason);
    private static CppUnknownEntityInfoWithReason();
    [CompilerGeneratedAttribute]
public CppUnknownEntityReason get_Reason();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Cpp.Util.CppUnknownEntityReason : Enum {
    public int value__;
    public static CppUnknownEntityReason FailedToDeduceReturnTypeOfDefaultedComparisonFunction;
    public static CppUnknownEntityReason RewrittenEqualityCandidateDoesNotReturnBool;
    public static CppUnknownEntityReason TypeOfBracedInitList;
    public static CppUnknownEntityReason TypeOfFunctionOverloadSet;
    public static CppUnknownEntityReason ClassTemplateArgumentDeductionFail;
    public static CppUnknownEntityReason TypeInfoLookupFailure;
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppUnknownTemplateDeductionInfo : CppUnknownEntityInfo {
    [CompilerGeneratedAttribute]
private object <TemplateParameter>k__BackingField;
    public object TemplateParameter { get; }
    public CppUnknownTemplateDeductionInfo(CppTemplateParameterTag param);
    public CppUnknownTemplateDeductionInfo(ICppModuleTemplateParameter param);
    [CompilerGeneratedAttribute]
public object get_TemplateParameter();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppUnknownUE4TypeFailure : CppUnknownEntityInfo {
    public static CppUnknownUE4TypeFailure Instance;
    private static CppUnknownUE4TypeFailure();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppUnresolvedTypeInChangeSignature : CppUnknownEntityInfo {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public string TypeName { get; }
    public CppUnresolvedTypeInChangeSignature(string typeName);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Cpp.Util.CppUsageKind : Enum {
    public int value__;
    public static CppUsageKind None;
    public static CppUsageKind Read;
    public static CppUsageKind Write;
    public static CppUsageKind ReadWrite;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Util.CppUsageKindUtil : object {
    [ExtensionAttribute]
public static bool IsReadUsage(CppUsageKind usage);
    [ExtensionAttribute]
public static bool IsWriteUsage(CppUsageKind usage);
    [ExtensionAttribute]
public static CppUsageKind Reduce(IEnumerable`1<CppUsageKind> usages);
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppWriteLock : ValueType {
    private WriteLockCookie myDisposable;
    public CppWriteLock(bool takeLock);
    public sealed virtual void Dispose();
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.Util.CppWriteNoConcurrencyGuard : ValueType {
    private CppRWNoConcurrencyChecker myMutex;
    private bool myRaceDetected;
    public CppWriteNoConcurrencyGuard(CppRWNoConcurrencyChecker mutex);
    public sealed virtual void Dispose();
}
public class JetBrains.ReSharper.Psi.Cpp.Util.CppZeroOrNegativeArraySizeFailure : CppUnknownEntityInfo {
    [CompilerGeneratedAttribute]
private ICppIntegralValue <SizeValue>k__BackingField;
    public ICppIntegralValue SizeValue { get; }
    public CppZeroOrNegativeArraySizeFailure(ICppIntegralValue expr);
    [CompilerGeneratedAttribute]
public ICppIntegralValue get_SizeValue();
    public virtual TResult Accept(ICppUnknownEntityInfoVisitor`1<TResult> visitor);
    public virtual string ToString();
}
public static class JetBrains.ReSharper.Psi.Cpp.Util.DictionaryUtil : object {
    public static Dictionary`2<TKey, TValue> Create(Tuple`2[] initValues);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Cpp.Util.EitherValue`2 : ValueType {
    private TLeft myLeftValue;
    private TRight myRightValue;
    private bool myIsLeft;
    private EitherValue`2(bool isLeft, TLeft left, TRight right);
    public static EitherValue`2<TLeft, TRight> CreateLeft(TLeft left);
    public static EitherValue`2<TLeft, TRight> CreateRight(TRight right);
    public bool IsLeft();
    public TLeft GetLeft();
    public TRight GetRight();
    public EitherValue`2<TNewLeft, TRight> CastLeft();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Cpp.Util.EnumerableUtil : object {
    [ExtensionAttribute]
public static FrugalLocalList`1<T> WhereExt(FrugalLocalList`1<T> that, Func`3<T, Arg, bool> pred, Arg a);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereExt(IEnumerable`1<T> that, Func`3<T, Arg, bool> pred, Arg a);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereExtBoth(IEnumerable`1<T> that, Func`3<T, Arg, bool> pred1, Func`3<T, Arg, bool> pred2, Arg a);
    [ExtensionAttribute]
public static bool HasSingleElement(IEnumerable`1<T> that);
    [ExtensionAttribute]
public static bool HasSingleElement(FrugalLocalList`1<T> that);
    [ExtensionAttribute]
public static T SingleOrNull(IEnumerable`1<T> that);
    [ExtensionAttribute]
public static bool ContainsAll(ICollection`1<T> collection, IEnumerable`1<T> elements);
    [ExtensionAttribute]
public static bool ContainsAny(ICollection`1<T> collection, IEnumerable`1<T> elements);
    [ExtensionAttribute]
public static IEnumerable`1<T> ContainedIn(IEnumerable`1<T> elements, ICollection`1<T> collection);
    [ExtensionAttribute]
public static bool SequenceEqual(T[] lhs, T[] rhs);
    public static bool SequenceEqual(CppSmallArray`1<T> lhs, CppSmallArray`1<T> rhs);
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<T> lhs, IEnumerable`1<T> rhs);
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<T> lhs, IEnumerable`1<T> rhs, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int SequenceHashCode(T[] elements, int seed);
    [ExtensionAttribute]
public static int SequenceHashCode(IEnumerable`1<T> elements, int seed);
    [ExtensionAttribute]
public static int SequenceHashCode(IEnumerable`1<T> elements, int seed, Func`2<T, int> hashCodeFun);
    [ExtensionAttribute]
public static int SequenceHashCode(IEnumerable`1<T> elements, int seed, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int SequenceHashCode(FrugalLocalList`1<T> elements, int seed);
    [ExtensionAttribute]
public static int SequenceHashCode(FrugalLocalList`1<T> elements, int seed, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int SequenceHashCode(T[] elements, int seed, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int SequenceHashCode(T[] elements, int seed, Func`2<T, int> hashCodeFun);
}
public interface JetBrains.ReSharper.Psi.Cpp.Util.ICppCompilationPropertiesProvider {
    [CanBeNullAttribute]
public abstract virtual CppCompilationProperties GetCompilationProperties(IProject project, IProjectFile projectFile, CppFileLocation rootFile, CppGlobalSymbolCache globalCache, CppIntelliSenseInfo intelliSenseInfo);
}
public interface JetBrains.ReSharper.Psi.Cpp.Util.ICppIterativeTreeAdaptor`1 {
    public abstract virtual FrugalLocalList`1<TNode> Children1(TNode node);
    public abstract virtual IEnumerable`1<TNode> Children2(TNode node);
}
public interface JetBrains.ReSharper.Psi.Cpp.Util.ICppIterativeTreeProcessor`1 {
    public abstract virtual bool InteriorShouldBeProcessed(TNode node);
    public abstract virtual void ProccessBeforeInterior(TNode node);
    public abstract virtual void ProccessAfterInterior(TNode node);
}
public interface JetBrains.ReSharper.Psi.Cpp.Util.ICppPerfEventAccumulator {
    public abstract virtual bool IsLogEnabled(ICppPerfEventType eventType);
    public abstract virtual void Increment(ICppPerfEventType eventType, string logMessage);
    public abstract virtual void Reset();
    public abstract virtual void EnableLogging(ICppPerfEventType eventType, bool enable);
    public abstract virtual IEnumerable`1<ICppPerfEventType> GetAllEventTypes();
    public abstract virtual string Dump();
}
public interface JetBrains.ReSharper.Psi.Cpp.Util.ICppPerfEventType {
    public abstract virtual string GetUserFriendlyName();
}
public interface JetBrains.ReSharper.Psi.Cpp.Util.ICppUE4ModuleNamesProvider {
    [CanBeNullAttribute]
public abstract virtual VirtualFileSystemPath GetAnyBuildCsFor(VirtualFileSystemPath path);
    [CanBeNullAttribute]
public abstract virtual VirtualFileSystemPath GetModuleBuildCsFor(VirtualFileSystemPath path, ICppUE4ProjectPropertiesProvider propertiesProvider, bool assertOnDisabledPropertiesProvider);
    [NotNullAttribute]
public abstract virtual string GetUE4ModuleNameOf(VirtualFileSystemPath buildCs);
    [NotNullAttribute]
public abstract virtual IDictionary`2<ModuleKind, IEnumerable`1<VirtualFileSystemPath>> GetModulesAllowedAsDependencyOf(VirtualFileSystemPath buildCs);
}
public interface JetBrains.ReSharper.Psi.Cpp.Util.ICppUE4ModuleProperties {
    public string ModuleName { get; }
    public string PlatformTarget { get; }
    public PlatformToolsetVersion PlatformToolset { get; }
    public CppLanguageStandard CppStandard { get; }
    public TargetMachine Architecture { get; }
    public RuntimeCheckOption BasicRuntimeChecks { get; }
    public RuntimeLibraryOption RuntimeLibrary { get; }
    public bool HasRuntimeTypeInfo { get; }
    public bool HasExceptionHandling { get; }
    public bool EnableCoroutines { get; }
    public bool IsAndroid { get; }
    public bool ConformanceMode { get; }
    public bool ConformantPreprocessor { get; }
    public bool SanitizeAddress { get; }
    public bool CPlusPlusDefineFromLanguageStandard { get; }
    public List`1<VirtualFileSystemPath> IncludePaths { get; }
    public OrderedHashSet`1<string> RawDefines { get; }
    public List`1<CppPPDefineSymbol> Defines { get; }
    public List`1<string> ForcedIncludes { get; }
    public List`1<string> DirectPublicDependencyModules { get; }
    public List`1<string> DirectPrivateDependencyModules { get; }
    public abstract virtual string get_ModuleName();
    public abstract virtual string get_PlatformTarget();
    public abstract virtual PlatformToolsetVersion get_PlatformToolset();
    public abstract virtual CppLanguageStandard get_CppStandard();
    public abstract virtual TargetMachine get_Architecture();
    public abstract virtual RuntimeCheckOption get_BasicRuntimeChecks();
    public abstract virtual RuntimeLibraryOption get_RuntimeLibrary();
    public abstract virtual bool get_HasRuntimeTypeInfo();
    public abstract virtual bool get_HasExceptionHandling();
    public abstract virtual bool get_EnableCoroutines();
    public abstract virtual bool get_IsAndroid();
    public abstract virtual bool get_ConformanceMode();
    public abstract virtual bool get_ConformantPreprocessor();
    public abstract virtual bool get_SanitizeAddress();
    public abstract virtual bool get_CPlusPlusDefineFromLanguageStandard();
    public abstract virtual List`1<VirtualFileSystemPath> get_IncludePaths();
    public abstract virtual OrderedHashSet`1<string> get_RawDefines();
    public abstract virtual List`1<CppPPDefineSymbol> get_Defines();
    public abstract virtual List`1<string> get_ForcedIncludes();
    public abstract virtual List`1<string> get_DirectPublicDependencyModules();
    public abstract virtual List`1<string> get_DirectPrivateDependencyModules();
}
public interface JetBrains.ReSharper.Psi.Cpp.Util.ICppUE4ModuleReferences {
    public OrderedHashSet`1<string> AllDependencyModules { get; }
    public OrderedHashSet`1<string> AllPublicDependencyModules { get; }
    public abstract virtual OrderedHashSet`1<string> get_AllDependencyModules();
    public abstract virtual OrderedHashSet`1<string> get_AllPublicDependencyModules();
}
public interface JetBrains.ReSharper.Psi.Cpp.Util.ICppUE4ModuleReferencesProvider {
    public bool IsEnabled { get; }
    public abstract virtual bool get_IsEnabled();
    public abstract virtual ICppUE4ModuleReferences GetReferences(VirtualFileSystemPath moduleBuildCs);
}
public interface JetBrains.ReSharper.Psi.Cpp.Util.ICppUE4ProjectModelCounterStatistics {
    public abstract virtual void ReportProjectModelGenerationResult(bool success, long timeMs);
    public abstract virtual void ReportTargetInfoGenerationResult(bool success, long timeMs, int numberOfTargets);
}
public interface JetBrains.ReSharper.Psi.Cpp.Util.ICppUE4ProjectModelStatistics {
    public abstract virtual void ReportAccessingCompilationProperties(bool success);
}
public interface JetBrains.ReSharper.Psi.Cpp.Util.ICppUE4ProjectPropertiesProvider {
    public bool IsEnabled { get; }
    public abstract virtual bool get_IsEnabled();
    public abstract virtual ICppUE4ModuleProperties GetProperties(VirtualFileSystemPath moduleBuildCs);
    public abstract virtual IReadOnlyDictionary`2<VirtualFileSystemPath, ICppUE4ModuleProperties> GetAllProperties();
    public abstract virtual bool IsSystemHeader(VirtualFileSystemPath header);
}
public interface JetBrains.ReSharper.Psi.Cpp.Util.ICppUnknownEntityInfoVisitor`1 {
    public abstract virtual TResult Visit(CppInternalFailure info);
    public abstract virtual TResult Visit(CppLookupFailure info);
    public abstract virtual TResult Visit(CppSubstitutionFailure info);
    public abstract virtual TResult Visit(CppNontypeResolveEntityUsedAsTypeFailure info);
    public abstract virtual TResult Visit(CppNontypeModuleEntityUsedAsTypeFailure info);
    public abstract virtual TResult Visit(CppUnknownTemplateDeductionInfo info);
    public abstract virtual TResult Visit(CppInvalidTypeFailure info);
    public abstract virtual TResult Visit(CppAutoTypeDeductionFailure info);
    public abstract virtual TResult Visit(CppAutoTypeConstraintFailure info);
    public abstract virtual TResult Visit(CppZeroOrNegativeArraySizeFailure info);
    public abstract virtual TResult Visit(CppUnknownArraySizeFailure info);
    public abstract virtual TResult Visit(CppExpressionEvaluationFailure info);
    public abstract virtual TResult Visit(CppTypeConversionFailure info);
    public abstract virtual TResult Visit(CppLinkageUnknownTypeFailure info);
    public abstract virtual TResult Visit(CppRecursiveTypeCalculationFailure info);
    public abstract virtual TResult Visit(CppStructuredBindingTypeDeductionFailure info);
    public abstract virtual TResult Visit(CppInvalidNumberOfStructuredBindingsFailure info);
    public abstract virtual TResult Visit(CppInvalidStructuredBindingsInitializerClassFailure info);
    public abstract virtual TResult Visit(CppInvalidFoldExpressionFailure info);
    public abstract virtual TResult Visit(CppUnknownUE4TypeFailure info);
    public abstract virtual TResult Visit(CppAggregateParenInitInfo info);
    public abstract virtual TResult Visit(CppDeducedReturnTypeUsedBeforeFunctionDefinition info);
    public abstract virtual TResult Visit(CppUnresolvedTypeInChangeSignature info);
    public abstract virtual TResult Visit(CppUnknownEntityInfoWithReason info);
    public abstract virtual TResult Visit(CppComparisonCategoryLookupFailure info);
    public abstract virtual TResult Visit(CppGenericAsTemplargFailure info);
    public abstract virtual TResult Visit(CppNonExpressionTemplateArgumentUsedAsExpressionFailure info);
    public abstract virtual TResult Visit(CppInvalidNonTypeTemplateArgumentValueFailure info);
    public abstract virtual TResult Visit(CppInvalidArgumentOfBuiltinTypeTraitFailure info);
}
public interface JetBrains.ReSharper.Psi.Cpp.Util.IGameEngineIncludeDirectiveResolver {
    public abstract virtual bool IsApplicable(CppInclusionContext context, string path);
    public abstract virtual string TransformPath(CppInclusionContext context, string path);
}
public enum JetBrains.ReSharper.Psi.Cpp.Util.ModuleKind : Enum {
    public int value__;
    public static ModuleKind EngineModule;
    public static ModuleKind EnginePlugin;
    public static ModuleKind GamePlugin;
    public static ModuleKind GameModule;
}
public enum JetBrains.ReSharper.Psi.Cpp.Util.PlatformToolsetVersion : Enum {
    public byte value__;
    public static PlatformToolsetVersion V80;
    public static PlatformToolsetVersion V90;
    public static PlatformToolsetVersion V100;
    public static PlatformToolsetVersion V110;
    public static PlatformToolsetVersion V120;
    public static PlatformToolsetVersion V140;
    public static PlatformToolsetVersion V141;
    public static PlatformToolsetVersion V142;
    public static PlatformToolsetVersion V143;
    public static PlatformToolsetVersion Linux;
    public static PlatformToolsetVersion ClangOnWindows;
    public static PlatformToolsetVersion ClangOnMac;
    public static PlatformToolsetVersion ClangOnLinux;
    public static PlatformToolsetVersion MSFS;
    public static PlatformToolsetVersion Unknown;
}
public class JetBrains.ReSharper.Psi.Cpp.Util.Ref`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; public set; }
    public Ref`1(T val);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
}
[ZoneMarkerAttribute]
internal class JetBrains.ReSharper.Psi.Cpp.ZoneMarker : object {
}
[ZoneDefinitionAttribute]
[ZoneLicenseAttribute("3735959238095958405395597736807690034463656785419506773541")]
[ZoneDefinitionProductAttribute]
[ZoneDefinitionConfigurableFeatureAttribute("ReSharper C++", "C++ Language Support", "True")]
public interface JetBrains.ReSharper.Psi.ICppProductZone {
}
[ZoneDefinitionAttribute]
public interface JetBrains.ReSharper.Psi.ILanguageCppZone {
}
[ZoneDefinitionAttribute("1")]
public interface JetBrains.ReSharper.Psi.IUnrealEngineZone {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
